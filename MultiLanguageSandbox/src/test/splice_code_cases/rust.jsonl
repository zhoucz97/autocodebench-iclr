{"code": "use std::collections::HashMap;\n\n/// Finds the number of common elements in all rows of a matrix.\n/// \n/// # Arguments\n/// * `mat` - A 2D vector representing the matrix\n/// \n/// # Returns\n/// The count of elements that appear in every row of the matrix\nfn find_common_elements(mat: &[Vec<i32>]) -> usize {\n    if mat.is_empty() {\n        return 0;\n    }\n\n    // Initialize a HashMap with the elements of the first row\n    let mut counter: HashMap<i32, usize> = HashMap::new();\n    for &num in &mat[0] {\n        *counter.entry(num).or_insert(0) += 1;\n    }\n\n    // Intersect the counts with subsequent rows\n    for row in mat.iter().skip(1) {\n        let mut row_counter: HashMap<i32, usize> = HashMap::new();\n        for &num in row {\n            *row_counter.entry(num).or_insert(0) += 1;\n        }\n\n        // Update the main counter with minimum counts\n        for (key, count) in counter.iter_mut() {\n            *count = (*count).min(*row_counter.get(key).unwrap_or(&0));\n        }\n    }\n\n    // Count elements that appear in all rows (count > 0)\n    counter.values().filter(|&&count| count > 0).count()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 13949, "assertions": "#[test]\nfn test_find_common_elements() {\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2, 3, 4],\n            vec![2, 4, 5, 6],\n            vec![3, 4, 7, 8],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        0\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![5, 5, 5],\n            vec![5, 5, 5],\n            vec![5, 5, 5],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2],\n            vec![1, 2],\n            vec![2, 3],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![]),\n        0\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Finds the number of common elements in all rows of a matrix.\n/// \n/// # Arguments\n/// * `mat` - A 2D vector representing the matrix\n/// \n/// # Returns\n/// The count of elements that appear in every row of the matrix\nfn find_common_elements(mat: &[Vec<i32>]) -> usize {\n    if mat.is_empty() {\n        return 0;\n    }\n\n    // Initialize a HashMap with the elements of the first row\n    let mut counter: HashMap<i32, usize> = HashMap::new();\n    for &num in &mat[0] {\n        *counter.entry(num).or_insert(0) += 1;\n    }\n\n    // Intersect the counts with subsequent rows\n    for row in mat.iter().skip(1) {\n        let mut row_counter: HashMap<i32, usize> = HashMap::new();\n        for &num in row {\n            *row_counter.entry(num).or_insert(0) += 1;\n        }\n\n        // Update the main counter with minimum counts\n        for (key, count) in counter.iter_mut() {\n            *count = (*count).min(*row_counter.get(key).unwrap_or(&0));\n        }\n    }\n\n    // Count elements that appear in all rows (count > 0)\n    counter.values().filter(|&&count| count > 0).count()\n}\n#[test]\nfn test_find_common_elements() {\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2, 3, 4],\n            vec![2, 4, 5, 6],\n            vec![3, 4, 7, 8],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        0\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![5, 5, 5],\n            vec![5, 5, 5],\n            vec![5, 5, 5],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![\n            vec![1, 2],\n            vec![1, 2],\n            vec![2, 3],\n        ]),\n        1\n    );\n    assert_eq!(\n        find_common_elements(&vec![]),\n        0\n    );\n}", "exec_outcome": "PASSED"}
{"code": "/// Calculates the minimum number of operations needed to transform string s1 into string s2.\n/// Each operation increments a character in s1 by 1 (with 'z' wrapping around to 'a').\n/// The function compares characters at each position and sums the differences.\nfn min_operations_to_transform(s1: &str, s2: &str) -> u32 {\n    // Check that both strings have the same length\n    assert_eq!(s1.len(), s2.len(), \"Strings must be of equal length\");\n    \n    let mut operations_needed = 0;\n\n    // Iterate through each character pair\n    for (c1, c2) in s1.chars().zip(s2.chars()) {\n        if c1 == c2 {\n            continue;\n        }\n        \n        // Calculate the difference between characters, wrapping around using modulo 26\n        let diff = (c2 as u32).wrapping_sub(c1 as u32) % 26;\n        operations_needed += diff;\n    }\n    \n    operations_needed\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 13746, "assertions": "#[test]\nfn test_min_operations_to_transform() {\n    assert_eq!(min_operations_to_transform(\"abc\", \"abc\"), 0);\n    assert_eq!(min_operations_to_transform(\"abc\", \"abd\"), 1);\n    assert_eq!(min_operations_to_transform(\"abc\", \"abz\"), 25);\n    assert_eq!(min_operations_to_transform(\"abz\", \"abx\"), 24);\n    assert_eq!(min_operations_to_transform(\"aaa\", \"bbb\"), 3);\n    assert_eq!(min_operations_to_transform(\"xyz\", \"abc\"), 3);\n}", "all_code": "/// Calculates the minimum number of operations needed to transform string s1 into string s2.\n/// Each operation increments a character in s1 by 1 (with 'z' wrapping around to 'a').\n/// The function compares characters at each position and sums the differences.\nfn min_operations_to_transform(s1: &str, s2: &str) -> u32 {\n    // Check that both strings have the same length\n    assert_eq!(s1.len(), s2.len(), \"Strings must be of equal length\");\n    \n    let mut operations_needed = 0;\n\n    // Iterate through each character pair\n    for (c1, c2) in s1.chars().zip(s2.chars()) {\n        if c1 == c2 {\n            continue;\n        }\n        \n        // Calculate the difference between characters, wrapping around using modulo 26\n        let diff = (c2 as u32).wrapping_sub(c1 as u32) % 26;\n        operations_needed += diff;\n    }\n    \n    operations_needed\n}\n#[test]\nfn test_min_operations_to_transform() {\n    assert_eq!(min_operations_to_transform(\"abc\", \"abc\"), 0);\n    assert_eq!(min_operations_to_transform(\"abc\", \"abd\"), 1);\n    assert_eq!(min_operations_to_transform(\"abc\", \"abz\"), 25);\n    assert_eq!(min_operations_to_transform(\"abz\", \"abx\"), 24);\n    assert_eq!(min_operations_to_transform(\"aaa\", \"bbb\"), 3);\n    assert_eq!(min_operations_to_transform(\"xyz\", \"abc\"), 3);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn generate_rna_sequences(sequence: &str) -> Vec<String> {\n    // Generates all possible valid RNA sequences by replacing each 'N' in the input sequence\n    // with all possible nucleotides ('A', 'C', 'G', 'U').\n    \n    let nucleotides = ['A', 'C', 'G', 'U'];\n    let mut result = vec![String::new()];  // Start with one empty string\n    \n    for char in sequence.chars() {\n        if char == 'N' {\n            // For 'N', expand each existing sequence with all possible nucleotides\n            result = result.into_iter().flat_map(|seq| {\n                nucleotides.iter().map(move |&nuc| {\n                    let mut new_seq = seq.clone();\n                    new_seq.push(nuc);\n                    new_seq\n                })\n            }).collect();\n        } else {\n            // For regular characters, just append them to all existing sequences\n            for seq in &mut result {\n                seq.push(char);\n            }\n        }\n    }\n    \n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 17866, "assertions": "#[test]\nfn test_generate_rna_sequences() {\n    // Test empty input\n    assert_eq!(generate_rna_sequences(\"\"), vec![\"\"]);\n    \n    // Test single non-N character\n    assert_eq!(generate_rna_sequences(\"A\"), vec![\"A\"]);\n    \n    // Test single N character\n    assert_eq!(\n        generate_rna_sequences(\"N\"),\n        vec![\"A\", \"C\", \"G\", \"U\"]\n    );\n    \n    // Test AN pattern\n    assert_eq!(\n        generate_rna_sequences(\"AN\"),\n        vec![\"AA\", \"AC\", \"AG\", \"AU\"]\n    );\n    \n    // Test NA pattern\n    assert_eq!(\n        generate_rna_sequences(\"NA\"),\n        vec![\"AA\", \"CA\", \"GA\", \"UA\"]\n    );\n    \n    // Test ANN pattern\n    assert_eq!(\n        generate_rna_sequences(\"ANN\"),\n        vec![\n            \"AAA\", \"AAC\", \"AAG\", \"AAU\",\n            \"ACA\", \"ACC\", \"ACG\", \"ACU\",\n            \"AGA\", \"AGC\", \"AGG\", \"AGU\",\n            \"AUA\", \"AUC\", \"AUG\", \"AUU\"\n        ]\n    );\n    \n    // Test NNN pattern (all combinations)\n    assert_eq!(\n        generate_rna_sequences(\"NNN\").len(),\n        64\n    );\n}", "all_code": "fn generate_rna_sequences(sequence: &str) -> Vec<String> {\n    // Generates all possible valid RNA sequences by replacing each 'N' in the input sequence\n    // with all possible nucleotides ('A', 'C', 'G', 'U').\n    \n    let nucleotides = ['A', 'C', 'G', 'U'];\n    let mut result = vec![String::new()];  // Start with one empty string\n    \n    for char in sequence.chars() {\n        if char == 'N' {\n            // For 'N', expand each existing sequence with all possible nucleotides\n            result = result.into_iter().flat_map(|seq| {\n                nucleotides.iter().map(move |&nuc| {\n                    let mut new_seq = seq.clone();\n                    new_seq.push(nuc);\n                    new_seq\n                })\n            }).collect();\n        } else {\n            // For regular characters, just append them to all existing sequences\n            for seq in &mut result {\n                seq.push(char);\n            }\n        }\n    }\n    \n    result\n}\n#[test]\nfn test_generate_rna_sequences() {\n    // Test empty input\n    assert_eq!(generate_rna_sequences(\"\"), vec![\"\"]);\n    \n    // Test single non-N character\n    assert_eq!(generate_rna_sequences(\"A\"), vec![\"A\"]);\n    \n    // Test single N character\n    assert_eq!(\n        generate_rna_sequences(\"N\"),\n        vec![\"A\", \"C\", \"G\", \"U\"]\n    );\n    \n    // Test AN pattern\n    assert_eq!(\n        generate_rna_sequences(\"AN\"),\n        vec![\"AA\", \"AC\", \"AG\", \"AU\"]\n    );\n    \n    // Test NA pattern\n    assert_eq!(\n        generate_rna_sequences(\"NA\"),\n        vec![\"AA\", \"CA\", \"GA\", \"UA\"]\n    );\n    \n    // Test ANN pattern\n    assert_eq!(\n        generate_rna_sequences(\"ANN\"),\n        vec![\n            \"AAA\", \"AAC\", \"AAG\", \"AAU\",\n            \"ACA\", \"ACC\", \"ACG\", \"ACU\",\n            \"AGA\", \"AGC\", \"AGG\", \"AGU\",\n            \"AUA\", \"AUC\", \"AUG\", \"AUU\"\n        ]\n    );\n    \n    // Test NNN pattern (all combinations)\n    assert_eq!(\n        generate_rna_sequences(\"NNN\").len(),\n        64\n    );\n}", "exec_outcome": "PASSED"}
{"code": "fn count_equal_subarrays(arr: &[i32]) -> i32 {\n    // Returns the number of contiguous subarrays where all elements are equal.\n    // \n    // Parameters:\n    // - arr: A slice of integers\n    //\n    // Returns:\n    // - The count of contiguous subarrays with all equal elements\n    let n = arr.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut subarray_length = 1;\n\n    // Iterate over the array starting from the second element\n    for i in 1..n {\n        if arr[i] == arr[i - 1] {\n            subarray_length += 1;\n        } else {\n            count += (subarray_length * (subarray_length + 1)) / 2;\n            subarray_length = 1;\n        }\n    }\n\n    // Add the last segment\n    count += (subarray_length * (subarray_length + 1)) / 2;\n    count\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 26331, "assertions": "#[test]\nfn test_count_equal_subarrays() {\n    assert_eq!(count_equal_subarrays(&[1, 2, 3]), 3);        // No equal adjacent elements\n    assert_eq!(count_equal_subarrays(&[1, 1, 1]), 6);        // All elements equal\n    assert_eq!(count_equal_subarrays(&[1, 1, 2, 2, 2]), 8);  // Mixed equal and unequal\n    assert_eq!(count_equal_subarrays(&[]), 0);               // Empty array\n    assert_eq!(count_equal_subarrays(&[5]), 1);              // Single element\n    assert_eq!(count_equal_subarrays(&[1, 2, 2, 3, 3, 3]), 10); // Multiple groups\n}", "all_code": "fn count_equal_subarrays(arr: &[i32]) -> i32 {\n    // Returns the number of contiguous subarrays where all elements are equal.\n    // \n    // Parameters:\n    // - arr: A slice of integers\n    //\n    // Returns:\n    // - The count of contiguous subarrays with all equal elements\n    let n = arr.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut count = 0;\n    let mut subarray_length = 1;\n\n    // Iterate over the array starting from the second element\n    for i in 1..n {\n        if arr[i] == arr[i - 1] {\n            subarray_length += 1;\n        } else {\n            count += (subarray_length * (subarray_length + 1)) / 2;\n            subarray_length = 1;\n        }\n    }\n\n    // Add the last segment\n    count += (subarray_length * (subarray_length + 1)) / 2;\n    count\n}\n#[test]\nfn test_count_equal_subarrays() {\n    assert_eq!(count_equal_subarrays(&[1, 2, 3]), 3);        // No equal adjacent elements\n    assert_eq!(count_equal_subarrays(&[1, 1, 1]), 6);        // All elements equal\n    assert_eq!(count_equal_subarrays(&[1, 1, 2, 2, 2]), 8);  // Mixed equal and unequal\n    assert_eq!(count_equal_subarrays(&[]), 0);               // Empty array\n    assert_eq!(count_equal_subarrays(&[5]), 1);              // Single element\n    assert_eq!(count_equal_subarrays(&[1, 2, 2, 3, 3, 3]), 10); // Multiple groups\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn count_set_bits_in_range(start: u32, end: u32) -> u32 {\n    // Counts the total number of set bits in the binary representations of all integers within the range [start, end] inclusive.\n    // \n    // Parameters:\n    // start - The starting number of the range (inclusive)\n    // end - The ending number of the range (inclusive)\n    //\n    // Returns:\n    // The total count of set bits in all numbers from start to end\n    \n    // Validate input values\n    if start > end {\n        panic!(\"start should be less than or equal to end\");\n    }\n    \n    // Count set bits in the given range\n    (start..=end).map(|number| number.count_ones()).sum()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 3827, "assertions": "#[test]\nfn test_count_set_bits_in_range() {\n    assert_eq!(count_set_bits_in_range(0, 0), 0);    // Single number 0\n    assert_eq!(count_set_bits_in_range(1, 1), 1);    // Single number 1\n    assert_eq!(count_set_bits_in_range(0, 1), 1);    // Range with two numbers\n    assert_eq!(count_set_bits_in_range(2, 5), 5);    // Small range\n    assert_eq!(count_set_bits_in_range(10, 15), 17); // Medium range\n    assert_eq!(count_set_bits_in_range(0, 255), 1024); // Larger range covering all 8-bit numbers\n}", "all_code": "fn count_set_bits_in_range(start: u32, end: u32) -> u32 {\n    // Counts the total number of set bits in the binary representations of all integers within the range [start, end] inclusive.\n    // \n    // Parameters:\n    // start - The starting number of the range (inclusive)\n    // end - The ending number of the range (inclusive)\n    //\n    // Returns:\n    // The total count of set bits in all numbers from start to end\n    \n    // Validate input values\n    if start > end {\n        panic!(\"start should be less than or equal to end\");\n    }\n    \n    // Count set bits in the given range\n    (start..=end).map(|number| number.count_ones()).sum()\n}\n#[test]\nfn test_count_set_bits_in_range() {\n    assert_eq!(count_set_bits_in_range(0, 0), 0);    // Single number 0\n    assert_eq!(count_set_bits_in_range(1, 1), 1);    // Single number 1\n    assert_eq!(count_set_bits_in_range(0, 1), 1);    // Range with two numbers\n    assert_eq!(count_set_bits_in_range(2, 5), 5);    // Small range\n    assert_eq!(count_set_bits_in_range(10, 15), 17); // Medium range\n    assert_eq!(count_set_bits_in_range(0, 255), 1024); // Larger range covering all 8-bit numbers\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn minimize_absolute_differences(nums: &mut Vec<i32>) -> Vec<i32> {\n    // Rearranges the array such that the sum of absolute differences between\n    // consecutive elements is minimized by sorting and interleaving from both ends.\n    \n    nums.sort();\n    let n = nums.len();\n    let mut result = Vec::with_capacity(n);\n    \n    for i in 0..n / 2 {\n        result.push(nums[n - 1 - i]);\n        result.push(nums[i]);\n    }\n    \n    if n % 2 != 0 {\n        result.push(nums[n / 2]);\n    }\n    \n    // Handle even lengths by potentially reversing\n    if result.len() == n {\n        result\n    } else {\n        result.into_iter().rev().collect()\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 28271, "assertions": "#[test]\nfn test_minimize_absolute_differences() {\n    let mut input1 = vec![1, 2, 3, 4];\n    assert_eq!(minimize_absolute_differences(&mut input1), vec![4, 1, 3, 2]);\n    \n    let mut input2 = vec![5, 2, 7, 1, 3];\n    assert_eq!(minimize_absolute_differences(&mut input2), vec![7, 1, 5, 2, 3]);\n    \n    let mut input3 = vec![10, 20];\n    assert_eq!(minimize_absolute_differences(&mut input3), vec![20, 10]);\n    \n    let mut input4 = vec![8];\n    assert_eq!(minimize_absolute_differences(&mut input4), vec![8]);\n    \n    let mut input5 = vec![4, 6, 2, 9, 5];\n    assert_eq!(minimize_absolute_differences(&mut input5), vec![9, 2, 6, 4, 5]);\n}", "all_code": "fn minimize_absolute_differences(nums: &mut Vec<i32>) -> Vec<i32> {\n    // Rearranges the array such that the sum of absolute differences between\n    // consecutive elements is minimized by sorting and interleaving from both ends.\n    \n    nums.sort();\n    let n = nums.len();\n    let mut result = Vec::with_capacity(n);\n    \n    for i in 0..n / 2 {\n        result.push(nums[n - 1 - i]);\n        result.push(nums[i]);\n    }\n    \n    if n % 2 != 0 {\n        result.push(nums[n / 2]);\n    }\n    \n    // Handle even lengths by potentially reversing\n    if result.len() == n {\n        result\n    } else {\n        result.into_iter().rev().collect()\n    }\n}\n#[test]\nfn test_minimize_absolute_differences() {\n    let mut input1 = vec![1, 2, 3, 4];\n    assert_eq!(minimize_absolute_differences(&mut input1), vec![4, 1, 3, 2]);\n    \n    let mut input2 = vec![5, 2, 7, 1, 3];\n    assert_eq!(minimize_absolute_differences(&mut input2), vec![7, 1, 5, 2, 3]);\n    \n    let mut input3 = vec![10, 20];\n    assert_eq!(minimize_absolute_differences(&mut input3), vec![20, 10]);\n    \n    let mut input4 = vec![8];\n    assert_eq!(minimize_absolute_differences(&mut input4), vec![8]);\n    \n    let mut input5 = vec![4, 6, 2, 9, 5];\n    assert_eq!(minimize_absolute_differences(&mut input5), vec![9, 2, 6, 4, 5]);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to convert a binary string to a decimal number\nfn binary_to_decimal(binary_str: &str) -> Result<u32, std::num::ParseIntError> {\n    // Use u32::from_str_radix to parse the binary string (base 2)\n    u32::from_str_radix(binary_str, 2)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 1491, "assertions": "#[test]\nfn test_binary_to_decimal() {\n    assert_eq!(binary_to_decimal(\"0\"), Ok(0));\n    assert_eq!(binary_to_decimal(\"1\"), Ok(1));\n    assert_eq!(binary_to_decimal(\"10\"), Ok(2));\n    assert_eq!(binary_to_decimal(\"1010\"), Ok(10));\n    assert_eq!(binary_to_decimal(\"1111\"), Ok(15));\n    assert_eq!(binary_to_decimal(\"10000\"), Ok(16));\n    assert_eq!(binary_to_decimal(\"101010\"), Ok(42));\n}", "all_code": "// Function to convert a binary string to a decimal number\nfn binary_to_decimal(binary_str: &str) -> Result<u32, std::num::ParseIntError> {\n    // Use u32::from_str_radix to parse the binary string (base 2)\n    u32::from_str_radix(binary_str, 2)\n}\n#[test]\nfn test_binary_to_decimal() {\n    assert_eq!(binary_to_decimal(\"0\"), Ok(0));\n    assert_eq!(binary_to_decimal(\"1\"), Ok(1));\n    assert_eq!(binary_to_decimal(\"10\"), Ok(2));\n    assert_eq!(binary_to_decimal(\"1010\"), Ok(10));\n    assert_eq!(binary_to_decimal(\"1111\"), Ok(15));\n    assert_eq!(binary_to_decimal(\"10000\"), Ok(16));\n    assert_eq!(binary_to_decimal(\"101010\"), Ok(42));\n}", "exec_outcome": "PASSED"}
{"code": "fn generate_primes(limit: usize) -> Vec<usize> {\n    // Generates a list of all prime numbers up to the given limit using the Sieve of Eratosthenes algorithm.\n    //\n    // # Arguments\n    // * `limit` - An usize representing the upper boundary (inclusive) to check for prime numbers.\n    //\n    // # Returns\n    // A Vec<usize> containing prime numbers up to the given limit.\n\n    if limit < 2 {\n        return vec![];\n    }\n\n    let mut sieve = vec![true; limit + 1];\n    sieve[0] = false;\n    sieve[1] = false; // 0 and 1 are not primes\n\n    for start in 2..=(limit as f64).sqrt() as usize + 1 {\n        if sieve[start] {\n            for multiples in (start * start..=limit).step_by(start) {\n                sieve[multiples] = false;\n            }\n        }\n    }\n\n    sieve.iter()\n        .enumerate()\n        .filter_map(|(num, &is_prime)| if is_prime { Some(num) } else { None })\n        .collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22082, "assertions": "#[test]\nfn test_generate_primes() {\n    assert_eq!(generate_primes(1), vec![]);\n    assert_eq!(generate_primes(2), vec![2]);\n    assert_eq!(generate_primes(10), vec![2, 3, 5, 7]);\n    assert_eq!(generate_primes(30), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n    assert_eq!(generate_primes(50), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]);\n    assert_eq!(generate_primes(100), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}", "all_code": "fn generate_primes(limit: usize) -> Vec<usize> {\n    // Generates a list of all prime numbers up to the given limit using the Sieve of Eratosthenes algorithm.\n    //\n    // # Arguments\n    // * `limit` - An usize representing the upper boundary (inclusive) to check for prime numbers.\n    //\n    // # Returns\n    // A Vec<usize> containing prime numbers up to the given limit.\n\n    if limit < 2 {\n        return vec![];\n    }\n\n    let mut sieve = vec![true; limit + 1];\n    sieve[0] = false;\n    sieve[1] = false; // 0 and 1 are not primes\n\n    for start in 2..=(limit as f64).sqrt() as usize + 1 {\n        if sieve[start] {\n            for multiples in (start * start..=limit).step_by(start) {\n                sieve[multiples] = false;\n            }\n        }\n    }\n\n    sieve.iter()\n        .enumerate()\n        .filter_map(|(num, &is_prime)| if is_prime { Some(num) } else { None })\n        .collect()\n}\n#[test]\nfn test_generate_primes() {\n    assert_eq!(generate_primes(1), vec![]);\n    assert_eq!(generate_primes(2), vec![2]);\n    assert_eq!(generate_primes(10), vec![2, 3, 5, 7]);\n    assert_eq!(generate_primes(30), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n    assert_eq!(generate_primes(50), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]);\n    assert_eq!(generate_primes(100), vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);\n}", "exec_outcome": "PASSED"}
{"code": "fn format_license_key(key: &str, k: usize) -> String {\n    // Formats the input license key string such that every k characters have a dash in between.\n    // \n    // Parameters:\n    // key - The input license key string composed of alphanumeric characters and dashes.\n    // k - The segment length.\n    //\n    // Returns:\n    // The reformatted license key string.\n\n    // Remove existing dashes and convert all characters to uppercase\n    let cleaned_key: String = key.chars()\n        .filter(|&c| c != '-')\n        .map(|c| c.to_ascii_uppercase())\n        .collect();\n\n    let length = cleaned_key.len();\n    let mut result = Vec::new();\n\n    // Process the string in reverse to group them in chunks of k\n    for (i, ch) in cleaned_key.chars().rev().enumerate() {\n        if i > 0 && i % k == 0 {\n            result.push('-');\n        }\n        result.push(ch);\n    }\n\n    // Reverse again to get the correct order and collect into String\n    result.iter().rev().collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21855, "assertions": "#[test]\nfn test_format_license_key() {\n    assert_eq!(format_license_key(\"5F3Z-2e-9-w\", 4), \"5F3Z-2E9W\");\n    assert_eq!(format_license_key(\"2-5g-3-J\", 2), \"2-5G-3J\");\n    assert_eq!(format_license_key(\"2-4A0r7-4k\", 3), \"24-A0R-74K\");\n    assert_eq!(format_license_key(\"a-b-c-d-e-f\", 1), \"A-B-C-D-E-F\");\n    assert_eq!(format_license_key(\"---\", 2), \"\");\n    assert_eq!(format_license_key(\"\", 4), \"\");\n}", "all_code": "fn format_license_key(key: &str, k: usize) -> String {\n    // Formats the input license key string such that every k characters have a dash in between.\n    // \n    // Parameters:\n    // key - The input license key string composed of alphanumeric characters and dashes.\n    // k - The segment length.\n    //\n    // Returns:\n    // The reformatted license key string.\n\n    // Remove existing dashes and convert all characters to uppercase\n    let cleaned_key: String = key.chars()\n        .filter(|&c| c != '-')\n        .map(|c| c.to_ascii_uppercase())\n        .collect();\n\n    let length = cleaned_key.len();\n    let mut result = Vec::new();\n\n    // Process the string in reverse to group them in chunks of k\n    for (i, ch) in cleaned_key.chars().rev().enumerate() {\n        if i > 0 && i % k == 0 {\n            result.push('-');\n        }\n        result.push(ch);\n    }\n\n    // Reverse again to get the correct order and collect into String\n    result.iter().rev().collect()\n}\n#[test]\nfn test_format_license_key() {\n    assert_eq!(format_license_key(\"5F3Z-2e-9-w\", 4), \"5F3Z-2E9W\");\n    assert_eq!(format_license_key(\"2-5g-3-J\", 2), \"2-5G-3J\");\n    assert_eq!(format_license_key(\"2-4A0r7-4k\", 3), \"24-A0R-74K\");\n    assert_eq!(format_license_key(\"a-b-c-d-e-f\", 1), \"A-B-C-D-E-F\");\n    assert_eq!(format_license_key(\"---\", 2), \"\");\n    assert_eq!(format_license_key(\"\", 4), \"\");\n}", "exec_outcome": "PASSED"}
{"code": "// Struct to represent the array query processor\nstruct ArrayQueryProcessor {\n    n: usize,\n    arr: Vec<i32>,\n}\n\nimpl ArrayQueryProcessor {\n    // Create a new ArrayQueryProcessor with given size and array\n    fn new(n: usize, arr: Vec<i32>) -> Self {\n        ArrayQueryProcessor { n, arr }\n    }\n\n    // Execute a single query on the array\n    fn execute_query(&mut self, query: &[i32]) -> Option<i32> {\n        match query[0] {\n            1 => {\n                // Update operation: set arr[p-1] = x\n                let p = query[1] as usize;\n                let x = query[2];\n                self.arr[p - 1] = x;\n                None\n            }\n            2 => {\n                // Sum operation: return sum of elements from l-1 to r-1\n                let l = query[1] as usize;\n                let r = query[2] as usize;\n                Some(self.arr[(l - 1)..r].iter().sum())\n            }\n            _ => None,\n        }\n    }\n}\n\n// Process multiple queries on an array\nfn process_queries(n: usize, arr: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n    let mut processor = ArrayQueryProcessor::new(n, arr);\n    let mut results = Vec::new();\n\n    for query in queries {\n        if let Some(result) = processor.execute_query(&query) {\n            results.push(result);\n        }\n    }\n\n    results\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 19044, "assertions": "#[test]\nfn test_array_query_processor() {\n    // Test case 1: Basic operations\n    let n1 = 5;\n    let arr1 = vec![1, 2, 3, 4, 5];\n    let queries1 = vec![\n        vec![2, 2, 4],  // Sum elements 2-4 (indices 1-3) = 2+3+4 = 9\n        vec![1, 3, 10], // Update element 3 to 10\n        vec![2, 2, 4],  // Sum elements 2-4 (indices 1-3) = 2+10+4 = 16\n    ];\n    assert_eq!(process_queries(n1, arr1, queries1), vec![9, 16]);\n\n    // Test case 2: Edge cases\n    let n2 = 3;\n    let arr2 = vec![0, 0, 0];\n    let queries2 = vec![\n        vec![1, 1, 5],  // Update element 1 to 5\n        vec![1, 2, 7],  // Update element 2 to 7\n        vec![2, 1, 3],  // Sum all elements = 5+7+0 = 12\n        vec![2, 2, 2],  // Sum single element = 7\n    ];\n    assert_eq!(process_queries(n2, arr2, queries2), vec![12, 7]);\n\n    // Test case 3: Single element array\n    let n3 = 1;\n    let arr3 = vec![100];\n    let queries3 = vec![\n        vec![2, 1, 1],  // Sum single element = 100\n        vec![1, 1, 50], // Update element 1 to 50\n        vec![2, 1, 1],  // Sum single element = 50\n    ];\n    assert_eq!(process_queries(n3, arr3, queries3), vec![100, 50]);\n}", "all_code": "// Struct to represent the array query processor\nstruct ArrayQueryProcessor {\n    n: usize,\n    arr: Vec<i32>,\n}\n\nimpl ArrayQueryProcessor {\n    // Create a new ArrayQueryProcessor with given size and array\n    fn new(n: usize, arr: Vec<i32>) -> Self {\n        ArrayQueryProcessor { n, arr }\n    }\n\n    // Execute a single query on the array\n    fn execute_query(&mut self, query: &[i32]) -> Option<i32> {\n        match query[0] {\n            1 => {\n                // Update operation: set arr[p-1] = x\n                let p = query[1] as usize;\n                let x = query[2];\n                self.arr[p - 1] = x;\n                None\n            }\n            2 => {\n                // Sum operation: return sum of elements from l-1 to r-1\n                let l = query[1] as usize;\n                let r = query[2] as usize;\n                Some(self.arr[(l - 1)..r].iter().sum())\n            }\n            _ => None,\n        }\n    }\n}\n\n// Process multiple queries on an array\nfn process_queries(n: usize, arr: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n    let mut processor = ArrayQueryProcessor::new(n, arr);\n    let mut results = Vec::new();\n\n    for query in queries {\n        if let Some(result) = processor.execute_query(&query) {\n            results.push(result);\n        }\n    }\n\n    results\n}\n#[test]\nfn test_array_query_processor() {\n    // Test case 1: Basic operations\n    let n1 = 5;\n    let arr1 = vec![1, 2, 3, 4, 5];\n    let queries1 = vec![\n        vec![2, 2, 4],  // Sum elements 2-4 (indices 1-3) = 2+3+4 = 9\n        vec![1, 3, 10], // Update element 3 to 10\n        vec![2, 2, 4],  // Sum elements 2-4 (indices 1-3) = 2+10+4 = 16\n    ];\n    assert_eq!(process_queries(n1, arr1, queries1), vec![9, 16]);\n\n    // Test case 2: Edge cases\n    let n2 = 3;\n    let arr2 = vec![0, 0, 0];\n    let queries2 = vec![\n        vec![1, 1, 5],  // Update element 1 to 5\n        vec![1, 2, 7],  // Update element 2 to 7\n        vec![2, 1, 3],  // Sum all elements = 5+7+0 = 12\n        vec![2, 2, 2],  // Sum single element = 7\n    ];\n    assert_eq!(process_queries(n2, arr2, queries2), vec![12, 7]);\n\n    // Test case 3: Single element array\n    let n3 = 1;\n    let arr3 = vec![100];\n    let queries3 = vec![\n        vec![2, 1, 1],  // Sum single element = 100\n        vec![1, 1, 50], // Update element 1 to 50\n        vec![2, 1, 1],  // Sum single element = 50\n    ];\n    assert_eq!(process_queries(n3, arr3, queries3), vec![100, 50]);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Processes warehouse operations and returns query results\n///\n/// # Arguments\n/// * `n` - Number of item types (unused in this implementation)\n/// * `m` - Number of operations\n/// * `item_names` - List of item names to initialize inventory\n/// * `operations` - List of operations to process (ADD, REMOVE, QUERY)\n///\n/// # Returns\n/// Vector of strings containing QUERY results in \"item count\" format\nfn warehouse_operations(n: usize, m: usize, item_names: Vec<&str>, operations: Vec<&str>) -> Vec<String> {\n    // Initialize inventory with all items set to count 0\n    let mut inventory: HashMap<&str, i32> = item_names.iter().map(|&item| (item, 0)).collect();\n    let mut results = Vec::new();\n\n    // Process each operation\n    for operation in operations {\n        let parts: Vec<&str> = operation.split_whitespace().collect();\n        \n        match parts[0] {\n            \"ADD\" => {\n                let item = parts[1];\n                let count: i32 = parts[2].parse().unwrap();\n                *inventory.entry(item).or_insert(0) += count;\n            },\n            \"REMOVE\" => {\n                let item = parts[1];\n                let count: i32 = parts[2].parse().unwrap();\n                *inventory.entry(item).or_insert(0) -= count;\n            },\n            \"QUERY\" => {\n                let item = parts[1];\n                if let Some(&count) = inventory.get(item) {\n                    results.push(format!(\"{} {}\", item, count));\n                }\n            },\n            _ => panic!(\"Unknown operation\"),\n        }\n    }\n\n    results\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 198, "assertions": "#[test]\nfn test_warehouse_operations() {\n    // Test case 1: Basic operations\n    let n1 = 3;\n    let m1 = 5;\n    let items1 = vec![\"apple\", \"banana\", \"orange\"];\n    let ops1 = vec![\n        \"ADD apple 10\",\n        \"ADD banana 5\",\n        \"QUERY apple\",\n        \"REMOVE apple 3\",\n        \"QUERY apple\",\n    ];\n    assert_eq!(\n        warehouse_operations(n1, m1, items1, ops1),\n        vec![\"apple 10\", \"apple 7\"]\n    );\n\n    // Test case 2: Item not in initial inventory\n    let n2 = 2;\n    let m2 = 4;\n    let items2 = vec![\"book\", \"pen\"];\n    let ops2 = vec![\n        \"ADD book 15\",\n        \"ADD pencil 20\",\n        \"QUERY book\",\n        \"QUERY pencil\",\n    ];\n    assert_eq!(\n        warehouse_operations(n2, m2, items2, ops2),\n        vec![\"book 15\", \"pencil 20\"]\n    );\n\n    // Test case 3: Remove operation\n    let n3 = 1;\n    let m3 = 3;\n    let items3 = vec![\"chair\"];\n    let ops3 = vec![\n        \"ADD chair 8\",\n        \"REMOVE chair 3\",\n        \"QUERY chair\",\n    ];\n    assert_eq!(\n        warehouse_operations(n3, m3, items3, ops3),\n        vec![\"chair 5\"]\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Processes warehouse operations and returns query results\n///\n/// # Arguments\n/// * `n` - Number of item types (unused in this implementation)\n/// * `m` - Number of operations\n/// * `item_names` - List of item names to initialize inventory\n/// * `operations` - List of operations to process (ADD, REMOVE, QUERY)\n///\n/// # Returns\n/// Vector of strings containing QUERY results in \"item count\" format\nfn warehouse_operations(n: usize, m: usize, item_names: Vec<&str>, operations: Vec<&str>) -> Vec<String> {\n    // Initialize inventory with all items set to count 0\n    let mut inventory: HashMap<&str, i32> = item_names.iter().map(|&item| (item, 0)).collect();\n    let mut results = Vec::new();\n\n    // Process each operation\n    for operation in operations {\n        let parts: Vec<&str> = operation.split_whitespace().collect();\n        \n        match parts[0] {\n            \"ADD\" => {\n                let item = parts[1];\n                let count: i32 = parts[2].parse().unwrap();\n                *inventory.entry(item).or_insert(0) += count;\n            },\n            \"REMOVE\" => {\n                let item = parts[1];\n                let count: i32 = parts[2].parse().unwrap();\n                *inventory.entry(item).or_insert(0) -= count;\n            },\n            \"QUERY\" => {\n                let item = parts[1];\n                if let Some(&count) = inventory.get(item) {\n                    results.push(format!(\"{} {}\", item, count));\n                }\n            },\n            _ => panic!(\"Unknown operation\"),\n        }\n    }\n\n    results\n}\n#[test]\nfn test_warehouse_operations() {\n    // Test case 1: Basic operations\n    let n1 = 3;\n    let m1 = 5;\n    let items1 = vec![\"apple\", \"banana\", \"orange\"];\n    let ops1 = vec![\n        \"ADD apple 10\",\n        \"ADD banana 5\",\n        \"QUERY apple\",\n        \"REMOVE apple 3\",\n        \"QUERY apple\",\n    ];\n    assert_eq!(\n        warehouse_operations(n1, m1, items1, ops1),\n        vec![\"apple 10\", \"apple 7\"]\n    );\n\n    // Test case 2: Item not in initial inventory\n    let n2 = 2;\n    let m2 = 4;\n    let items2 = vec![\"book\", \"pen\"];\n    let ops2 = vec![\n        \"ADD book 15\",\n        \"ADD pencil 20\",\n        \"QUERY book\",\n        \"QUERY pencil\",\n    ];\n    assert_eq!(\n        warehouse_operations(n2, m2, items2, ops2),\n        vec![\"book 15\", \"pencil 20\"]\n    );\n\n    // Test case 3: Remove operation\n    let n3 = 1;\n    let m3 = 3;\n    let items3 = vec![\"chair\"];\n    let ops3 = vec![\n        \"ADD chair 8\",\n        \"REMOVE chair 3\",\n        \"QUERY chair\",\n    ];\n    assert_eq!(\n        warehouse_operations(n3, m3, items3, ops3),\n        vec![\"chair 5\"]\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::VecDeque;\n\n// Function to count tree clusters in a forest represented as a 2D grid\n// Uses Depth-First Search (DFS) to mark connected trees as visited\nfn count_tree_clusters(forest: &mut Vec<Vec<char>>) -> usize {\n    let rows = forest.len();\n    if rows == 0 {\n        return 0;\n    }\n    let cols = forest[0].len();\n    let mut cluster_count = 0;\n\n    // Iterate through each cell in the forest\n    for i in 0..rows {\n        for j in 0..cols {\n            if forest[i][j] == 'T' {\n                cluster_count += 1;\n                dfs(i, j, rows, cols, forest);\n            }\n        }\n    }\n\n    cluster_count\n}\n\n// Helper DFS function to mark all connected trees as visited\nfn dfs(x: usize, y: usize, rows: usize, cols: usize, forest: &mut Vec<Vec<char>>) {\n    let mut stack = VecDeque::new();\n    stack.push_back((x, y));\n\n    while let Some((i, j)) = stack.pop_back() {\n        if forest[i][j] != 'T' {\n            continue;\n        }\n\n        forest[i][j] = '.'; // Mark as visited\n\n        // Check and add adjacent cells to the stack\n        if i > 0 && forest[i - 1][j] == 'T' {\n            stack.push_back((i - 1, j));\n        }\n        if i < rows - 1 && forest[i + 1][j] == 'T' {\n            stack.push_back((i + 1, j));\n        }\n        if j > 0 && forest[i][j - 1] == 'T' {\n            stack.push_back((i, j - 1));\n        }\n        if j < cols - 1 && forest[i][j + 1] == 'T' {\n            stack.push_back((i, j + 1));\n        }\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 28983, "assertions": "#[test]\nfn test_count_tree_clusters() {\n    // Test case 1: Single tree\n    let mut forest1 = vec![\n        vec!['.', '.', '.'],\n        vec!['.', 'T', '.'],\n        vec!['.', '.', '.'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest1), 1);\n\n    // Test case 2: Two separate clusters\n    let mut forest2 = vec![\n        vec!['T', '.', 'T'],\n        vec!['.', '.', '.'],\n        vec!['T', '.', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest2), 4);\n\n    // Test case 3: One large connected cluster\n    let mut forest3 = vec![\n        vec!['T', 'T', '.'],\n        vec!['T', '.', 'T'],\n        vec!['.', 'T', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest3), 1);\n\n    // Test case 4: Empty forest\n    let mut forest4 = vec![\n        vec!['.', '.'],\n        vec!['.', '.'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest4), 0);\n\n    // Test case 5: All trees but no connections\n    let mut forest5 = vec![\n        vec!['T', '.', 'T'],\n        vec!['T', '.', 'T'],\n        vec!['T', '.', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest5), 6);\n}", "all_code": "use std::collections::VecDeque;\n\n// Function to count tree clusters in a forest represented as a 2D grid\n// Uses Depth-First Search (DFS) to mark connected trees as visited\nfn count_tree_clusters(forest: &mut Vec<Vec<char>>) -> usize {\n    let rows = forest.len();\n    if rows == 0 {\n        return 0;\n    }\n    let cols = forest[0].len();\n    let mut cluster_count = 0;\n\n    // Iterate through each cell in the forest\n    for i in 0..rows {\n        for j in 0..cols {\n            if forest[i][j] == 'T' {\n                cluster_count += 1;\n                dfs(i, j, rows, cols, forest);\n            }\n        }\n    }\n\n    cluster_count\n}\n\n// Helper DFS function to mark all connected trees as visited\nfn dfs(x: usize, y: usize, rows: usize, cols: usize, forest: &mut Vec<Vec<char>>) {\n    let mut stack = VecDeque::new();\n    stack.push_back((x, y));\n\n    while let Some((i, j)) = stack.pop_back() {\n        if forest[i][j] != 'T' {\n            continue;\n        }\n\n        forest[i][j] = '.'; // Mark as visited\n\n        // Check and add adjacent cells to the stack\n        if i > 0 && forest[i - 1][j] == 'T' {\n            stack.push_back((i - 1, j));\n        }\n        if i < rows - 1 && forest[i + 1][j] == 'T' {\n            stack.push_back((i + 1, j));\n        }\n        if j > 0 && forest[i][j - 1] == 'T' {\n            stack.push_back((i, j - 1));\n        }\n        if j < cols - 1 && forest[i][j + 1] == 'T' {\n            stack.push_back((i, j + 1));\n        }\n    }\n}\n#[test]\nfn test_count_tree_clusters() {\n    // Test case 1: Single tree\n    let mut forest1 = vec![\n        vec!['.', '.', '.'],\n        vec!['.', 'T', '.'],\n        vec!['.', '.', '.'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest1), 1);\n\n    // Test case 2: Two separate clusters\n    let mut forest2 = vec![\n        vec!['T', '.', 'T'],\n        vec!['.', '.', '.'],\n        vec!['T', '.', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest2), 4);\n\n    // Test case 3: One large connected cluster\n    let mut forest3 = vec![\n        vec!['T', 'T', '.'],\n        vec!['T', '.', 'T'],\n        vec!['.', 'T', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest3), 1);\n\n    // Test case 4: Empty forest\n    let mut forest4 = vec![\n        vec!['.', '.'],\n        vec!['.', '.'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest4), 0);\n\n    // Test case 5: All trees but no connections\n    let mut forest5 = vec![\n        vec!['T', '.', 'T'],\n        vec!['T', '.', 'T'],\n        vec!['T', '.', 'T'],\n    ];\n    assert_eq!(count_tree_clusters(&mut forest5), 6);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "/// Finds an element that appears more than n/3 times in the array.\n/// Returns the element if found, otherwise returns -1.\n/// Uses Moore's Voting Algorithm to efficiently find potential candidates.\nfn find_element_appearing_more_than_n_by_3(nums: &[i32]) -> i32 {\n    if nums.is_empty() {\n        return -1;\n    }\n\n    let n = nums.len();\n    let (mut candidate1, mut candidate2) = (None, None);\n    let (mut count1, mut count2) = (0, 0);\n\n    // First pass: Find two potential candidates\n    for &num in nums {\n        if candidate1 == Some(num) {\n            count1 += 1;\n        } else if candidate2 == Some(num) {\n            count2 += 1;\n        } else if count1 == 0 {\n            candidate1 = Some(num);\n            count1 = 1;\n        } else if count2 == 0 {\n            candidate2 = Some(num);\n            count2 = 1;\n        } else {\n            count1 -= 1;\n            count2 -= 1;\n        }\n    }\n\n    // Second pass: Verify the candidates\n    let (mut count1, mut count2) = (0, 0);\n    for &num in nums {\n        if Some(num) == candidate1 {\n            count1 += 1;\n        } else if Some(num) == candidate2 {\n            count2 += 1;\n        }\n    }\n\n    if count1 > n / 3 {\n        return candidate1.unwrap();\n    }\n    if count2 > n / 3 {\n        return candidate2.unwrap();\n    }\n\n    -1\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 26641, "assertions": "#[test]\nfn test_find_element_appearing_more_than_n_by_3() {\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 2, 3, 1, 1]), 1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 2, 3, 4, 5]), -1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[2, 2, 1, 3, 1, 2, 2]), 2);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[]), -1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 1, 1, 3, 3, 3, 3]), 3);\n}", "all_code": "/// Finds an element that appears more than n/3 times in the array.\n/// Returns the element if found, otherwise returns -1.\n/// Uses Moore's Voting Algorithm to efficiently find potential candidates.\nfn find_element_appearing_more_than_n_by_3(nums: &[i32]) -> i32 {\n    if nums.is_empty() {\n        return -1;\n    }\n\n    let n = nums.len();\n    let (mut candidate1, mut candidate2) = (None, None);\n    let (mut count1, mut count2) = (0, 0);\n\n    // First pass: Find two potential candidates\n    for &num in nums {\n        if candidate1 == Some(num) {\n            count1 += 1;\n        } else if candidate2 == Some(num) {\n            count2 += 1;\n        } else if count1 == 0 {\n            candidate1 = Some(num);\n            count1 = 1;\n        } else if count2 == 0 {\n            candidate2 = Some(num);\n            count2 = 1;\n        } else {\n            count1 -= 1;\n            count2 -= 1;\n        }\n    }\n\n    // Second pass: Verify the candidates\n    let (mut count1, mut count2) = (0, 0);\n    for &num in nums {\n        if Some(num) == candidate1 {\n            count1 += 1;\n        } else if Some(num) == candidate2 {\n            count2 += 1;\n        }\n    }\n\n    if count1 > n / 3 {\n        return candidate1.unwrap();\n    }\n    if count2 > n / 3 {\n        return candidate2.unwrap();\n    }\n\n    -1\n}\n#[test]\nfn test_find_element_appearing_more_than_n_by_3() {\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 2, 3, 1, 1]), 1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 2, 3, 4, 5]), -1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[2, 2, 1, 3, 1, 2, 2]), 2);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[]), -1);\n    assert_eq!(find_element_appearing_more_than_n_by_3(&[1, 1, 1, 3, 3, 3, 3]), 3);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn babylonian_sqrt(n: f64, p: i32) -> Result<f64, String> {\n    // Returns the square root of a number 'n' with precision 'p' using the Babylonian method.\n    //\n    // Parameters:\n    // n - The number to find the square root of\n    // p - The precision (number of decimal places)\n    //\n    // Returns:\n    // Result<f64, String> - The square root of 'n' rounded to 'p' decimal places,\n    // or an error message if inputs are invalid\n\n    if n < 0.0 {\n        return Err(\"Cannot compute the square root of a negative number\".to_string());\n    }\n    if p < 0 {\n        return Err(\"Precision cannot be negative\".to_string());\n    }\n\n    let mut x = n;\n    let mut y = 1.0;\n    let e = 0.1_f64.powi(p + 1);\n\n    while (x - y).abs() > e {\n        x = (x + y) / 2.0;\n        y = n / x;\n    }\n\n    let scale = 10_f64.powi(p);\n    Ok((x * scale).round() / scale)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 13626, "assertions": "#[test]\nfn test_babylonian_sqrt() {\n    // Test cases with expected results\n    assert_eq!(babylonian_sqrt(16.0, 2), Ok(4.0));\n    assert_eq!(babylonian_sqrt(25.0, 3), Ok(5.0));\n    assert_eq!(babylonian_sqrt(2.0, 5), Ok(1.41421));\n    assert_eq!(\n        babylonian_sqrt(-4.0, 1),\n        Err(\"Cannot compute the square root of a negative number\".to_string())\n    );\n    assert_eq!(\n        babylonian_sqrt(10.0, -2),\n        Err(\"Precision cannot be negative\".to_string())\n    );\n    assert_eq!(babylonian_sqrt(0.0, 1), Ok(0.0));\n}", "all_code": "fn babylonian_sqrt(n: f64, p: i32) -> Result<f64, String> {\n    // Returns the square root of a number 'n' with precision 'p' using the Babylonian method.\n    //\n    // Parameters:\n    // n - The number to find the square root of\n    // p - The precision (number of decimal places)\n    //\n    // Returns:\n    // Result<f64, String> - The square root of 'n' rounded to 'p' decimal places,\n    // or an error message if inputs are invalid\n\n    if n < 0.0 {\n        return Err(\"Cannot compute the square root of a negative number\".to_string());\n    }\n    if p < 0 {\n        return Err(\"Precision cannot be negative\".to_string());\n    }\n\n    let mut x = n;\n    let mut y = 1.0;\n    let e = 0.1_f64.powi(p + 1);\n\n    while (x - y).abs() > e {\n        x = (x + y) / 2.0;\n        y = n / x;\n    }\n\n    let scale = 10_f64.powi(p);\n    Ok((x * scale).round() / scale)\n}\n#[test]\nfn test_babylonian_sqrt() {\n    // Test cases with expected results\n    assert_eq!(babylonian_sqrt(16.0, 2), Ok(4.0));\n    assert_eq!(babylonian_sqrt(25.0, 3), Ok(5.0));\n    assert_eq!(babylonian_sqrt(2.0, 5), Ok(1.41421));\n    assert_eq!(\n        babylonian_sqrt(-4.0, 1),\n        Err(\"Cannot compute the square root of a negative number\".to_string())\n    );\n    assert_eq!(\n        babylonian_sqrt(10.0, -2),\n        Err(\"Precision cannot be negative\".to_string())\n    );\n    assert_eq!(babylonian_sqrt(0.0, 1), Ok(0.0));\n}", "exec_outcome": "PASSED"}
{"code": "use std::iter::Peekable;\nuse std::str::Chars;\n\n/// Reverses the words in the given string while preserving whitespace.\n///\n/// # Arguments\n/// * `s` - A string slice containing the input text.\n///\n/// # Returns\n/// A String with words in reverse order, preserving original whitespace.\nfn reverse_words(s: &str) -> String {\n    if s.is_empty() || s.chars().all(|c| c.is_whitespace()) {\n        return s.to_string();\n    }\n\n    // Split words and reverse their order\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let reversed_words: Vec<&str> = words.into_iter().rev().collect();\n    let mut word_iter = reversed_words.into_iter().peekable();\n\n    let mut result = String::new();\n    let mut char_iter = s.chars().peekable();\n\n    // Rebuild the string with original whitespace but reversed words\n    while let Some(c) = char_iter.next() {\n        if c.is_whitespace() {\n            result.push(c);\n        } else {\n            // Push the next reversed word\n            if let Some(word) = word_iter.next() {\n                result.push_str(word);\n                // Skip characters until next whitespace\n                while char_iter.peek().map_or(false, |&c| !c.is_whitespace()) {\n                    char_iter.next();\n                }\n            }\n        }\n    }\n\n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23277, "assertions": "#[test]\nfn test_reverse_words() {\n    assert_eq!(reverse_words(\"hello world\"), \"world hello\");\n    assert_eq!(reverse_words(\"  hello   world  \"), \"  world   hello  \");\n    assert_eq!(reverse_words(\"single\"), \"single\");\n    assert_eq!(reverse_words(\"  \"), \"  \");\n    assert_eq!(reverse_words(\"\"), \"\");\n    assert_eq!(reverse_words(\"a b c d e\"), \"e d c b a\");\n    assert_eq!(reverse_words(\" leading space\"), \"space leading\");\n    assert_eq!(reverse_words(\"trailing space \"), \"space trailing \");\n}", "all_code": "use std::iter::Peekable;\nuse std::str::Chars;\n\n/// Reverses the words in the given string while preserving whitespace.\n///\n/// # Arguments\n/// * `s` - A string slice containing the input text.\n///\n/// # Returns\n/// A String with words in reverse order, preserving original whitespace.\nfn reverse_words(s: &str) -> String {\n    if s.is_empty() || s.chars().all(|c| c.is_whitespace()) {\n        return s.to_string();\n    }\n\n    // Split words and reverse their order\n    let words: Vec<&str> = s.split_whitespace().collect();\n    let reversed_words: Vec<&str> = words.into_iter().rev().collect();\n    let mut word_iter = reversed_words.into_iter().peekable();\n\n    let mut result = String::new();\n    let mut char_iter = s.chars().peekable();\n\n    // Rebuild the string with original whitespace but reversed words\n    while let Some(c) = char_iter.next() {\n        if c.is_whitespace() {\n            result.push(c);\n        } else {\n            // Push the next reversed word\n            if let Some(word) = word_iter.next() {\n                result.push_str(word);\n                // Skip characters until next whitespace\n                while char_iter.peek().map_or(false, |&c| !c.is_whitespace()) {\n                    char_iter.next();\n                }\n            }\n        }\n    }\n\n    result\n}\n#[test]\nfn test_reverse_words() {\n    assert_eq!(reverse_words(\"hello world\"), \"world hello\");\n    assert_eq!(reverse_words(\"  hello   world  \"), \"  world   hello  \");\n    assert_eq!(reverse_words(\"single\"), \"single\");\n    assert_eq!(reverse_words(\"  \"), \"  \");\n    assert_eq!(reverse_words(\"\"), \"\");\n    assert_eq!(reverse_words(\"a b c d e\"), \"e d c b a\");\n    assert_eq!(reverse_words(\" leading space\"), \"space leading\");\n    assert_eq!(reverse_words(\"trailing space \"), \"space trailing \");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn is_sorted(books: &[String]) -> &'static str {\n    // Checks if a slice of book titles is sorted in alphabetical order.\n    // Returns \"YES\" if sorted, \"NO\" otherwise.\n    for i in 0..books.len() - 1 {\n        if books[i] > books[i + 1] {\n            return \"NO\";\n        }\n    }\n    \"YES\"\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 2147, "assertions": "#[test]\nfn test_is_sorted() {\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"B\".to_string(), \"C\".to_string(), \"D\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"D\".to_string(), \"C\".to_string(), \"B\".to_string(), \"A\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"B\".to_string(), \"B\".to_string(), \"C\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"C\".to_string(), \"B\".to_string(), \"D\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"Z\".to_string(), \"A\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"Z\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![]), \"YES\");\n}", "all_code": "fn is_sorted(books: &[String]) -> &'static str {\n    // Checks if a slice of book titles is sorted in alphabetical order.\n    // Returns \"YES\" if sorted, \"NO\" otherwise.\n    for i in 0..books.len() - 1 {\n        if books[i] > books[i + 1] {\n            return \"NO\";\n        }\n    }\n    \"YES\"\n}\n#[test]\nfn test_is_sorted() {\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"B\".to_string(), \"C\".to_string(), \"D\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"D\".to_string(), \"C\".to_string(), \"B\".to_string(), \"A\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"B\".to_string(), \"B\".to_string(), \"C\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"C\".to_string(), \"B\".to_string(), \"D\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"Z\".to_string(), \"A\".to_string()]), \"NO\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string(), \"Z\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![\"A\".to_string()]), \"YES\");\n    assert_eq!(is_sorted(&vec![]), \"YES\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn subarray_beauty(n: usize, a: &[i32], queries: &[(usize, usize)]) -> Vec<i32> {\n    // Calculate the beauty for each query\n    // Beauty is defined as the difference between max and min elements in the subarray\n    queries.iter().map(|&(l, r)| {\n        let subarray = &a[l-1..r];\n        let max_element = *subarray.iter().max().unwrap();\n        let min_element = *subarray.iter().min().unwrap();\n        max_element - min_element\n    }).collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 18250, "assertions": "#[test]\nfn test_subarray_beauty() {\n    // Test case 1: Simple case with 5 elements and 2 queries\n    let n1 = 5;\n    let a1 = vec![1, 3, 5, 2, 4];\n    let queries1 = vec![(1, 3), (2, 5)];\n    assert_eq!(subarray_beauty(n1, &a1, &queries1), vec![4, 3]);\n\n    // Test case 2: All elements same\n    let n2 = 4;\n    let a2 = vec![7, 7, 7, 7];\n    let queries2 = vec![(1, 4), (2, 3), (1, 1)];\n    assert_eq!(subarray_beauty(n2, &a2, &queries2), vec![0, 0, 0]);\n\n    // Test case 3: Single element array\n    let n3 = 1;\n    let a3 = vec![10];\n    let queries3 = vec![(1, 1)];\n    assert_eq!(subarray_beauty(n3, &a3, &queries3), vec![0]);\n\n    // Test case 4: Large range with negative numbers\n    let n4 = 6;\n    let a4 = vec![-5, 0, 3, -2, 8, -1];\n    let queries4 = vec![(1, 6), (2, 4), (3, 5)];\n    assert_eq!(subarray_beauty(n4, &a4, &queries4), vec![13, 5, 10]);\n}", "all_code": "fn subarray_beauty(n: usize, a: &[i32], queries: &[(usize, usize)]) -> Vec<i32> {\n    // Calculate the beauty for each query\n    // Beauty is defined as the difference between max and min elements in the subarray\n    queries.iter().map(|&(l, r)| {\n        let subarray = &a[l-1..r];\n        let max_element = *subarray.iter().max().unwrap();\n        let min_element = *subarray.iter().min().unwrap();\n        max_element - min_element\n    }).collect()\n}\n#[test]\nfn test_subarray_beauty() {\n    // Test case 1: Simple case with 5 elements and 2 queries\n    let n1 = 5;\n    let a1 = vec![1, 3, 5, 2, 4];\n    let queries1 = vec![(1, 3), (2, 5)];\n    assert_eq!(subarray_beauty(n1, &a1, &queries1), vec![4, 3]);\n\n    // Test case 2: All elements same\n    let n2 = 4;\n    let a2 = vec![7, 7, 7, 7];\n    let queries2 = vec![(1, 4), (2, 3), (1, 1)];\n    assert_eq!(subarray_beauty(n2, &a2, &queries2), vec![0, 0, 0]);\n\n    // Test case 3: Single element array\n    let n3 = 1;\n    let a3 = vec![10];\n    let queries3 = vec![(1, 1)];\n    assert_eq!(subarray_beauty(n3, &a3, &queries3), vec![0]);\n\n    // Test case 4: Large range with negative numbers\n    let n4 = 6;\n    let a4 = vec![-5, 0, 3, -2, 8, -1];\n    let queries4 = vec![(1, 6), (2, 4), (3, 5)];\n    assert_eq!(subarray_beauty(n4, &a4, &queries4), vec![13, 5, 10]);\n}", "exec_outcome": "PASSED"}
{"code": "fn longest_alternating_subsequence(nums: &[i32]) -> i32 {\n    // Calculate the length of the longest alternating subsequence.\n    // An alternating subsequence is one where the elements alternate between increasing and decreasing.\n    // The function uses dynamic programming to track the longest increasing and decreasing subsequences ending at each position.\n\n    if nums.is_empty() {\n        return 0;\n    }\n\n    let n = nums.len();\n    let mut inc = 1;  // length of longest alternating subsequence ending at current position with increasing trend\n    let mut dec = 1;  // length of longest alternating subsequence ending at current position with decreasing trend\n\n    for i in 1..n {\n        if nums[i] > nums[i - 1] {\n            // Current element is greater than previous, so we can extend the decreasing subsequence\n            inc = dec + 1;\n        } else if nums[i] < nums[i - 1] {\n            // Current element is smaller than previous, so we can extend the increasing subsequence\n            dec = inc + 1;\n        }\n        // If equal, we don't change either inc or dec\n    }\n\n    std::cmp::max(inc, dec)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22285, "assertions": "#[test]\nfn test_longest_alternating_subsequence() {\n    assert_eq!(longest_alternating_subsequence(&[1, 5, 4, 7, 2, 9]), 5);\n    assert_eq!(longest_alternating_subsequence(&[1, 2, 3, 4, 5]), 2);\n    assert_eq!(longest_alternating_subsequence(&[5, 4, 3, 2, 1]), 2);\n    assert_eq!(longest_alternating_subsequence(&[1, 1, 1, 1, 1]), 1);\n    assert_eq!(longest_alternating_subsequence(&[]), 0);\n    assert_eq!(longest_alternating_subsequence(&[1, 2, 1, 2, 1, 2]), 6);\n}", "all_code": "fn longest_alternating_subsequence(nums: &[i32]) -> i32 {\n    // Calculate the length of the longest alternating subsequence.\n    // An alternating subsequence is one where the elements alternate between increasing and decreasing.\n    // The function uses dynamic programming to track the longest increasing and decreasing subsequences ending at each position.\n\n    if nums.is_empty() {\n        return 0;\n    }\n\n    let n = nums.len();\n    let mut inc = 1;  // length of longest alternating subsequence ending at current position with increasing trend\n    let mut dec = 1;  // length of longest alternating subsequence ending at current position with decreasing trend\n\n    for i in 1..n {\n        if nums[i] > nums[i - 1] {\n            // Current element is greater than previous, so we can extend the decreasing subsequence\n            inc = dec + 1;\n        } else if nums[i] < nums[i - 1] {\n            // Current element is smaller than previous, so we can extend the increasing subsequence\n            dec = inc + 1;\n        }\n        // If equal, we don't change either inc or dec\n    }\n\n    std::cmp::max(inc, dec)\n}\n#[test]\nfn test_longest_alternating_subsequence() {\n    assert_eq!(longest_alternating_subsequence(&[1, 5, 4, 7, 2, 9]), 5);\n    assert_eq!(longest_alternating_subsequence(&[1, 2, 3, 4, 5]), 2);\n    assert_eq!(longest_alternating_subsequence(&[5, 4, 3, 2, 1]), 2);\n    assert_eq!(longest_alternating_subsequence(&[1, 1, 1, 1, 1]), 1);\n    assert_eq!(longest_alternating_subsequence(&[]), 0);\n    assert_eq!(longest_alternating_subsequence(&[1, 2, 1, 2, 1, 2]), 6);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to reverse words in a string that are longer than 4 characters\nfn reverse_long_words(s: &str) -> String {\n    // Split the input string into words\n    let words: Vec<&str> = s.split_whitespace().collect();\n    \n    // Process each word: reverse if longer than 4 characters\n    let modified_words: Vec<String> = words.iter().map(|&word| {\n        if word.len() > 4 {\n            word.chars().rev().collect()\n        } else {\n            word.to_string()\n        }\n    }).collect();\n    \n    // Join the modified words back into a single string\n    modified_words.join(\" \")\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 6445, "assertions": "#[test]\nfn test_reverse_long_words() {\n    assert_eq!(reverse_long_words(\"hello world\"), \"olleh world\");\n    assert_eq!(reverse_long_words(\"rust is awesome\"), \"tsur is emosewa\");\n    assert_eq!(reverse_long_words(\"a bb ccc dddd eeeee\"), \"a bb ccc dddd eeeee\");\n    assert_eq!(\n        reverse_long_words(\"This is a test string with some longer words\"),\n        \"This is a test gnirts with some regnol words\"\n    );\n}", "all_code": "// Function to reverse words in a string that are longer than 4 characters\nfn reverse_long_words(s: &str) -> String {\n    // Split the input string into words\n    let words: Vec<&str> = s.split_whitespace().collect();\n    \n    // Process each word: reverse if longer than 4 characters\n    let modified_words: Vec<String> = words.iter().map(|&word| {\n        if word.len() > 4 {\n            word.chars().rev().collect()\n        } else {\n            word.to_string()\n        }\n    }).collect();\n    \n    // Join the modified words back into a single string\n    modified_words.join(\" \")\n}\n#[test]\nfn test_reverse_long_words() {\n    assert_eq!(reverse_long_words(\"hello world\"), \"olleh world\");\n    assert_eq!(reverse_long_words(\"rust is awesome\"), \"tsur is emosewa\");\n    assert_eq!(reverse_long_words(\"a bb ccc dddd eeeee\"), \"a bb ccc dddd eeeee\");\n    assert_eq!(\n        reverse_long_words(\"This is a test string with some longer words\"),\n        \"This is a test gnirts with some regnol words\"\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn add_ed(words: &[&str]) -> Vec<String> {\n    // Processes a slice of string references and returns a new Vec<String>\n    // where 'ed' is added to each word that doesn't already end with 'ed'.\n    // Words ending with 'ed' remain unchanged.\n    words.iter()\n        .map(|&word| {\n            if word.ends_with(\"ed\") {\n                word.to_string()\n            } else {\n                format!(\"{}ed\", word)\n            }\n        })\n        .collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21166, "assertions": "#[test]\nfn test_add_ed() {\n    assert_eq!(\n        add_ed(&[\"walk\", \"talk\", \"jumped\"]),\n        vec![\"walked\", \"talked\", \"jumped\"]\n    );\n    assert_eq!(\n        add_ed(&[\"played\", \"worked\", \"run\"]),\n        vec![\"played\", \"worked\", \"runed\"]\n    );\n    assert_eq!(\n        add_ed(&[\"ed\", \"coined\", \"jump\"]),\n        vec![\"ed\", \"coined\", \"jumped\"]\n    );\n    assert_eq!(add_ed(&[]), vec![] as Vec<String>);\n}", "all_code": "fn add_ed(words: &[&str]) -> Vec<String> {\n    // Processes a slice of string references and returns a new Vec<String>\n    // where 'ed' is added to each word that doesn't already end with 'ed'.\n    // Words ending with 'ed' remain unchanged.\n    words.iter()\n        .map(|&word| {\n            if word.ends_with(\"ed\") {\n                word.to_string()\n            } else {\n                format!(\"{}ed\", word)\n            }\n        })\n        .collect()\n}\n#[test]\nfn test_add_ed() {\n    assert_eq!(\n        add_ed(&[\"walk\", \"talk\", \"jumped\"]),\n        vec![\"walked\", \"talked\", \"jumped\"]\n    );\n    assert_eq!(\n        add_ed(&[\"played\", \"worked\", \"run\"]),\n        vec![\"played\", \"worked\", \"runed\"]\n    );\n    assert_eq!(\n        add_ed(&[\"ed\", \"coined\", \"jump\"]),\n        vec![\"ed\", \"coined\", \"jumped\"]\n    );\n    assert_eq!(add_ed(&[]), vec![] as Vec<String>);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n/// Calculates the minimum number of carousels needed to accommodate all intervals without overlap.\n/// Uses a min-heap to track end times of carousels and assigns each interval to the earliest available carousel.\nfn min_carousels(tests: &[(&[(i32, i32)], usize)]) -> Vec<usize> {\n    let mut results = Vec::with_capacity(tests.len());\n    \n    for &(intervals, _) in tests {\n        let mut sorted_intervals = intervals.to_vec();\n        sorted_intervals.sort();\n        \n        // Min-heap to track the end times of carousels (using Reverse for min-heap behavior)\n        let mut heap = BinaryHeap::new();\n        \n        for (start, end) in sorted_intervals {\n            if let Some(&Reverse(earliest_end)) = heap.peek() {\n                if earliest_end <= start {\n                    heap.pop();\n                }\n            }\n            heap.push(Reverse(end));\n        }\n        \n        results.push(heap.len());\n    }\n    \n    results\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 10590, "assertions": "#[test]\nfn test_min_carousels() {\n    let test_cases = vec![\n        // Single interval\n        (&[(1, 2)][..], 1),\n        // Two non-overlapping intervals\n        (&[(1, 2), (3, 4)][..], 2),\n        // Two overlapping intervals\n        (&[(1, 3), (2, 4)][..], 2),\n        // Three intervals where two can share a carousel\n        (&[(1, 3), (2, 4), (5, 6)][..], 2),\n        // Multiple overlapping intervals\n        (&[(1, 4), (2, 5), (3, 6), (7, 8)][..], 3),\n    ];\n    \n    let results = min_carousels(&test_cases);\n    \n    assert_eq!(results, vec![1, 1, 2, 2, 3]);\n}", "all_code": "use std::collections::BinaryHeap;\nuse std::cmp::Reverse;\n\n/// Calculates the minimum number of carousels needed to accommodate all intervals without overlap.\n/// Uses a min-heap to track end times of carousels and assigns each interval to the earliest available carousel.\nfn min_carousels(tests: &[(&[(i32, i32)], usize)]) -> Vec<usize> {\n    let mut results = Vec::with_capacity(tests.len());\n    \n    for &(intervals, _) in tests {\n        let mut sorted_intervals = intervals.to_vec();\n        sorted_intervals.sort();\n        \n        // Min-heap to track the end times of carousels (using Reverse for min-heap behavior)\n        let mut heap = BinaryHeap::new();\n        \n        for (start, end) in sorted_intervals {\n            if let Some(&Reverse(earliest_end)) = heap.peek() {\n                if earliest_end <= start {\n                    heap.pop();\n                }\n            }\n            heap.push(Reverse(end));\n        }\n        \n        results.push(heap.len());\n    }\n    \n    results\n}\n#[test]\nfn test_min_carousels() {\n    let test_cases = vec![\n        // Single interval\n        (&[(1, 2)][..], 1),\n        // Two non-overlapping intervals\n        (&[(1, 2), (3, 4)][..], 2),\n        // Two overlapping intervals\n        (&[(1, 3), (2, 4)][..], 2),\n        // Three intervals where two can share a carousel\n        (&[(1, 3), (2, 4), (5, 6)][..], 2),\n        // Multiple overlapping intervals\n        (&[(1, 4), (2, 5), (3, 6), (7, 8)][..], 3),\n    ];\n    \n    let results = min_carousels(&test_cases);\n    \n    assert_eq!(results, vec![1, 1, 2, 2, 3]);\n}", "exec_outcome": "PASSED"}
{"code": "fn evaluate_knight_moves(board: &[Vec<i32>]) -> Vec<Vec<i32>> {\n    // Possible moves for a knight in chess (dx, dy)\n    let moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ];\n    \n    let n = board.len();\n    let mut result = vec![vec![0; n]; n];\n    \n    for i in 0..n {\n        for j in 0..n {\n            if board[i][j] == 1 {  // There's a knight at this position\n                let mut valid_moves = 0;\n                for &(dx, dy) in &moves {\n                    let ni = i as i32 + dx;\n                    let nj = j as i32 + dy;\n                    // Check if the move is within bounds\n                    if ni >= 0 && ni < n as i32 && nj >= 0 && nj < n as i32 {\n                        valid_moves += 1;\n                    }\n                }\n                result[i][j] = valid_moves;\n            }\n        }\n    }\n    \n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23760, "assertions": "#[test]\nfn test_evaluate_knight_moves() {\n    // Test case 1: Empty 3x3 board\n    let board1 = vec![\n        vec![0, 0, 0],\n        vec![0, 0, 0],\n        vec![0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board1), vec![\n        vec![0, 0, 0],\n        vec![0, 0, 0],\n        vec![0, 0, 0]\n    ]);\n\n    // Test case 2: Single knight in center of 3x3 board\n    let board2 = vec![\n        vec![0, 0, 0],\n        vec![0, 1, 0],\n        vec![0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board2), vec![\n        vec![0, 0, 0],\n        vec![0, 8, 0],\n        vec![0, 0, 0]\n    ]);\n\n    // Test case 3: Knights in corners of 4x4 board\n    let board3 = vec![\n        vec![1, 0, 0, 1],\n        vec![0, 0, 0, 0],\n        vec![0, 0, 0, 0],\n        vec![1, 0, 0, 1]\n    ];\n    assert_eq!(evaluate_knight_moves(&board3), vec![\n        vec![2, 0, 0, 2],\n        vec![0, 0, 0, 0],\n        vec![0, 0, 0, 0],\n        vec![2, 0, 0, 2]\n    ]);\n\n    // Test case 4: Mixed positions on 5x5 board\n    let board4 = vec![\n        vec![1, 0, 0, 0, 1],\n        vec![0, 0, 1, 0, 0],\n        vec![0, 1, 0, 1, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![1, 0, 0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board4), vec![\n        vec![2, 0, 0, 0, 1],\n        vec![0, 0, 8, 0, 0],\n        vec![0, 8, 0, 4, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![2, 0, 0, 0, 0]\n    ]);\n}", "all_code": "fn evaluate_knight_moves(board: &[Vec<i32>]) -> Vec<Vec<i32>> {\n    // Possible moves for a knight in chess (dx, dy)\n    let moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ];\n    \n    let n = board.len();\n    let mut result = vec![vec![0; n]; n];\n    \n    for i in 0..n {\n        for j in 0..n {\n            if board[i][j] == 1 {  // There's a knight at this position\n                let mut valid_moves = 0;\n                for &(dx, dy) in &moves {\n                    let ni = i as i32 + dx;\n                    let nj = j as i32 + dy;\n                    // Check if the move is within bounds\n                    if ni >= 0 && ni < n as i32 && nj >= 0 && nj < n as i32 {\n                        valid_moves += 1;\n                    }\n                }\n                result[i][j] = valid_moves;\n            }\n        }\n    }\n    \n    result\n}\n#[test]\nfn test_evaluate_knight_moves() {\n    // Test case 1: Empty 3x3 board\n    let board1 = vec![\n        vec![0, 0, 0],\n        vec![0, 0, 0],\n        vec![0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board1), vec![\n        vec![0, 0, 0],\n        vec![0, 0, 0],\n        vec![0, 0, 0]\n    ]);\n\n    // Test case 2: Single knight in center of 3x3 board\n    let board2 = vec![\n        vec![0, 0, 0],\n        vec![0, 1, 0],\n        vec![0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board2), vec![\n        vec![0, 0, 0],\n        vec![0, 8, 0],\n        vec![0, 0, 0]\n    ]);\n\n    // Test case 3: Knights in corners of 4x4 board\n    let board3 = vec![\n        vec![1, 0, 0, 1],\n        vec![0, 0, 0, 0],\n        vec![0, 0, 0, 0],\n        vec![1, 0, 0, 1]\n    ];\n    assert_eq!(evaluate_knight_moves(&board3), vec![\n        vec![2, 0, 0, 2],\n        vec![0, 0, 0, 0],\n        vec![0, 0, 0, 0],\n        vec![2, 0, 0, 2]\n    ]);\n\n    // Test case 4: Mixed positions on 5x5 board\n    let board4 = vec![\n        vec![1, 0, 0, 0, 1],\n        vec![0, 0, 1, 0, 0],\n        vec![0, 1, 0, 1, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![1, 0, 0, 0, 0]\n    ];\n    assert_eq!(evaluate_knight_moves(&board4), vec![\n        vec![2, 0, 0, 0, 1],\n        vec![0, 0, 8, 0, 0],\n        vec![0, 8, 0, 4, 0],\n        vec![0, 0, 0, 0, 0],\n        vec![2, 0, 0, 0, 0]\n    ]);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn process_string(s: &str) -> String {\n    // Processes a string by removing duplicate characters while preserving order\n    // For each character in the input string:\n    // - If it's already in the result, remove the existing occurrence\n    // - If it's not in the result, add it to the end\n    let mut new_string = Vec::new();\n    \n    for c in s.chars() {\n        if let Some(pos) = new_string.iter().position(|&x| x == c) {\n            new_string.remove(pos);\n        } else {\n            new_string.push(c);\n        }\n    }\n    \n    new_string.into_iter().collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 5106, "assertions": "#[test]\nfn test_process_string() {\n    assert_eq!(process_string(\"abcde\"), \"abcde\");\n    assert_eq!(process_string(\"aabbcc\"), \"\");\n    assert_eq!(process_string(\"hello world\"), \"he wrd\");\n    assert_eq!(process_string(\"testing\"), \"esting\");\n    assert_eq!(process_string(\"\"), \"\");\n    assert_eq!(process_string(\"a\"), \"a\");\n    assert_eq!(process_string(\"abacbc\"), \"\");\n}", "all_code": "fn process_string(s: &str) -> String {\n    // Processes a string by removing duplicate characters while preserving order\n    // For each character in the input string:\n    // - If it's already in the result, remove the existing occurrence\n    // - If it's not in the result, add it to the end\n    let mut new_string = Vec::new();\n    \n    for c in s.chars() {\n        if let Some(pos) = new_string.iter().position(|&x| x == c) {\n            new_string.remove(pos);\n        } else {\n            new_string.push(c);\n        }\n    }\n    \n    new_string.into_iter().collect()\n}\n#[test]\nfn test_process_string() {\n    assert_eq!(process_string(\"abcde\"), \"abcde\");\n    assert_eq!(process_string(\"aabbcc\"), \"\");\n    assert_eq!(process_string(\"hello world\"), \"he wrd\");\n    assert_eq!(process_string(\"testing\"), \"esting\");\n    assert_eq!(process_string(\"\"), \"\");\n    assert_eq!(process_string(\"a\"), \"a\");\n    assert_eq!(process_string(\"abacbc\"), \"\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn max_points_on_board(grid: &[Vec<i32>]) -> i32 {\n    // Given a grid of n x n with point values, find the maximum points that can be collected in any path\n    // from top-left to bottom-right corner moving only right or down.\n    let n = grid.len();\n    // Initialize a 2D dp array with the same dimensions as the grid\n    let mut dp = vec![vec![0; n]; n];\n    \n    // Initialize the starting point\n    dp[0][0] = grid[0][0];\n    \n    // Fill the first row and the first column\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + grid[0][i];\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    \n    // Fill the rest of the dp array\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = std::cmp::max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    \n    // The bottom-right corner will have the maximum points collected\n    dp[n - 1][n - 1]\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 24501, "assertions": "#[test]\nfn test_max_points_on_board() {\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        29\n    );\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 2],\n            vec![3, 4],\n        ]),\n        8\n    );\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 0, 0],\n            vec![0, 1, 0],\n            vec![0, 0, 1],\n        ]),\n        3\n    );\n}", "all_code": "fn max_points_on_board(grid: &[Vec<i32>]) -> i32 {\n    // Given a grid of n x n with point values, find the maximum points that can be collected in any path\n    // from top-left to bottom-right corner moving only right or down.\n    let n = grid.len();\n    // Initialize a 2D dp array with the same dimensions as the grid\n    let mut dp = vec![vec![0; n]; n];\n    \n    // Initialize the starting point\n    dp[0][0] = grid[0][0];\n    \n    // Fill the first row and the first column\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + grid[0][i];\n        dp[i][0] = dp[i - 1][0] + grid[i][0];\n    }\n    \n    // Fill the rest of the dp array\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = std::cmp::max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n        }\n    }\n    \n    // The bottom-right corner will have the maximum points collected\n    dp[n - 1][n - 1]\n}\n#[test]\nfn test_max_points_on_board() {\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        29\n    );\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 2],\n            vec![3, 4],\n        ]),\n        8\n    );\n    assert_eq!(\n        max_points_on_board(&vec![\n            vec![1, 0, 0],\n            vec![0, 1, 0],\n            vec![0, 0, 1],\n        ]),\n        3\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Calculates the cosine similarity between two text strings.\n///\n/// The function works by:\n/// 1. Creating a vocabulary of all unique words from both texts\n/// 2. Creating frequency vectors for each text based on the vocabulary\n/// 3. Calculating the dot product and magnitudes of these vectors\n/// 4. Computing the cosine similarity as dot product / (magnitude1 * magnitude2)\nfn calculate_cosine_similarity(text1: &str, text2: &str) -> f64 {\n    // Tokenize both texts into words (split on whitespace)\n    let words1: Vec<&str> = text1.split_whitespace().collect();\n    let words2: Vec<&str> = text2.split_whitespace().collect();\n    \n    // Create a vocabulary of all unique words\n    let mut vocabulary = HashMap::new();\n    let mut index = 0;\n    \n    for word in words1.iter().chain(words2.iter()) {\n        vocabulary.entry(word.to_lowercase()).or_insert_with(|| {\n            let current_index = index;\n            index += 1;\n            current_index\n        });\n    }\n    \n    // Create frequency vectors for each text\n    let mut vec1 = vec![0; vocabulary.len()];\n    let mut vec2 = vec![0; vocabulary.len()];\n    \n    for word in words1 {\n        if let Some(&idx) = vocabulary.get(&word.to_lowercase()) {\n            vec1[idx] += 1;\n        }\n    }\n    \n    for word in words2 {\n        if let Some(&idx) = vocabulary.get(&word.to_lowercase()) {\n            vec2[idx] += 1;\n        }\n    }\n    \n    // Calculate dot product\n    let dot_product: i32 = vec1.iter().zip(vec2.iter()).map(|(&a, &b)| a * b).sum();\n    \n    // Calculate magnitudes\n    let magnitude1 = (vec1.iter().map(|&x| x * x).sum::<i32>() as f64).sqrt();\n    let magnitude2 = (vec2.iter().map(|&x| x * x).sum::<i32>() as f64).sqrt();\n    \n    // Calculate cosine similarity\n    if magnitude1 == 0.0 || magnitude2 == 0.0 {\n        0.0\n    } else {\n        dot_product as f64 / (magnitude1 * magnitude2)\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 27902, "assertions": "#[test]\nfn test_calculate_cosine_similarity() {\n    // Test identical texts\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"hello world\"), 1.0);\n    \n    // Test same words, different order\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"world hello\"), 1.0);\n    \n    // Test some overlap\n    assert!(calculate_cosine_similarity(\"hello world\", \"goodbye world\") > 0.0 && \n            calculate_cosine_similarity(\"hello world\", \"goodbye world\") < 1.0);\n    \n    // Test no overlap\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"foo bar\"), 0.0);\n    \n    // Test empty strings\n    assert_eq!(calculate_cosine_similarity(\"\", \"\"), 0.0);\n    \n    // Test one text is subset of another\n    assert!(calculate_cosine_similarity(\"hello\", \"hello world\") > 0.0 && \n            calculate_cosine_similarity(\"hello\", \"hello world\") < 1.0);\n    \n    // Test case difference\n    assert_eq!(calculate_cosine_similarity(\"rust is great\", \"Rust IS GREAT\"), 1.0);\n}", "all_code": "use std::collections::HashMap;\n\n/// Calculates the cosine similarity between two text strings.\n///\n/// The function works by:\n/// 1. Creating a vocabulary of all unique words from both texts\n/// 2. Creating frequency vectors for each text based on the vocabulary\n/// 3. Calculating the dot product and magnitudes of these vectors\n/// 4. Computing the cosine similarity as dot product / (magnitude1 * magnitude2)\nfn calculate_cosine_similarity(text1: &str, text2: &str) -> f64 {\n    // Tokenize both texts into words (split on whitespace)\n    let words1: Vec<&str> = text1.split_whitespace().collect();\n    let words2: Vec<&str> = text2.split_whitespace().collect();\n    \n    // Create a vocabulary of all unique words\n    let mut vocabulary = HashMap::new();\n    let mut index = 0;\n    \n    for word in words1.iter().chain(words2.iter()) {\n        vocabulary.entry(word.to_lowercase()).or_insert_with(|| {\n            let current_index = index;\n            index += 1;\n            current_index\n        });\n    }\n    \n    // Create frequency vectors for each text\n    let mut vec1 = vec![0; vocabulary.len()];\n    let mut vec2 = vec![0; vocabulary.len()];\n    \n    for word in words1 {\n        if let Some(&idx) = vocabulary.get(&word.to_lowercase()) {\n            vec1[idx] += 1;\n        }\n    }\n    \n    for word in words2 {\n        if let Some(&idx) = vocabulary.get(&word.to_lowercase()) {\n            vec2[idx] += 1;\n        }\n    }\n    \n    // Calculate dot product\n    let dot_product: i32 = vec1.iter().zip(vec2.iter()).map(|(&a, &b)| a * b).sum();\n    \n    // Calculate magnitudes\n    let magnitude1 = (vec1.iter().map(|&x| x * x).sum::<i32>() as f64).sqrt();\n    let magnitude2 = (vec2.iter().map(|&x| x * x).sum::<i32>() as f64).sqrt();\n    \n    // Calculate cosine similarity\n    if magnitude1 == 0.0 || magnitude2 == 0.0 {\n        0.0\n    } else {\n        dot_product as f64 / (magnitude1 * magnitude2)\n    }\n}\n#[test]\nfn test_calculate_cosine_similarity() {\n    // Test identical texts\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"hello world\"), 1.0);\n    \n    // Test same words, different order\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"world hello\"), 1.0);\n    \n    // Test some overlap\n    assert!(calculate_cosine_similarity(\"hello world\", \"goodbye world\") > 0.0 && \n            calculate_cosine_similarity(\"hello world\", \"goodbye world\") < 1.0);\n    \n    // Test no overlap\n    assert_eq!(calculate_cosine_similarity(\"hello world\", \"foo bar\"), 0.0);\n    \n    // Test empty strings\n    assert_eq!(calculate_cosine_similarity(\"\", \"\"), 0.0);\n    \n    // Test one text is subset of another\n    assert!(calculate_cosine_similarity(\"hello\", \"hello world\") > 0.0 && \n            calculate_cosine_similarity(\"hello\", \"hello world\") < 1.0);\n    \n    // Test case difference\n    assert_eq!(calculate_cosine_similarity(\"rust is great\", \"Rust IS GREAT\"), 1.0);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to find the maximum sum of any contiguous subarray (Kadane's algorithm)\n// This is a common algorithm for solving the maximum subarray problem.\nfn max_beauty_subarray(n: usize, beauty_factors: &[i32]) -> i32 {\n    // Initialize variables to track the current and global maximum sums\n    let mut max_current = beauty_factors[0];\n    let mut max_global = beauty_factors[0];\n    \n    // Iterate through the beauty factors starting from the second element\n    for i in 1..n {\n        // Update the current maximum sum: either start a new subarray or continue the current one\n        max_current = beauty_factors[i].max(max_current + beauty_factors[i]);\n        \n        // Update the global maximum sum if the current maximum is greater\n        if max_current > max_global {\n            max_global = max_current;\n        }\n    }\n    \n    max_global\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21578, "assertions": "#[test]\nfn test_max_beauty_subarray() {\n    // Simple case with positive and negative numbers\n    assert_eq!(max_beauty_subarray(3, &[1, -2, 3]), 3);\n    // Case with negative numbers and a positive subarray\n    assert_eq!(max_beauty_subarray(5, &[-2, -3, 4, -1, -2]), 4);\n    // Single element\n    assert_eq!(max_beauty_subarray(1, &[5]), 5);\n    // All positive numbers\n    assert_eq!(max_beauty_subarray(4, &[1, 2, 3, 4]), 10);\n    // All negative numbers\n    assert_eq!(max_beauty_subarray(4, &[-1, -2, -3, -4]), -1);\n}", "all_code": "// Function to find the maximum sum of any contiguous subarray (Kadane's algorithm)\n// This is a common algorithm for solving the maximum subarray problem.\nfn max_beauty_subarray(n: usize, beauty_factors: &[i32]) -> i32 {\n    // Initialize variables to track the current and global maximum sums\n    let mut max_current = beauty_factors[0];\n    let mut max_global = beauty_factors[0];\n    \n    // Iterate through the beauty factors starting from the second element\n    for i in 1..n {\n        // Update the current maximum sum: either start a new subarray or continue the current one\n        max_current = beauty_factors[i].max(max_current + beauty_factors[i]);\n        \n        // Update the global maximum sum if the current maximum is greater\n        if max_current > max_global {\n            max_global = max_current;\n        }\n    }\n    \n    max_global\n}\n#[test]\nfn test_max_beauty_subarray() {\n    // Simple case with positive and negative numbers\n    assert_eq!(max_beauty_subarray(3, &[1, -2, 3]), 3);\n    // Case with negative numbers and a positive subarray\n    assert_eq!(max_beauty_subarray(5, &[-2, -3, 4, -1, -2]), 4);\n    // Single element\n    assert_eq!(max_beauty_subarray(1, &[5]), 5);\n    // All positive numbers\n    assert_eq!(max_beauty_subarray(4, &[1, 2, 3, 4]), 10);\n    // All negative numbers\n    assert_eq!(max_beauty_subarray(4, &[-1, -2, -3, -4]), -1);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Represents a library with book catalog and borrowing functionality\nstruct Library {\n    catalog: HashMap<String, String>,          // Maps book titles to authors\n    borrowed_books: HashMap<String, String>,   // Maps book titles to usernames\n}\n\nimpl Library {\n    /// Creates a new, empty Library\n    fn new() -> Self {\n        Library {\n            catalog: HashMap::new(),\n            borrowed_books: HashMap::new(),\n        }\n    }\n\n    /// Adds a book to the library catalog if it doesn't already exist\n    fn add_book(&mut self, title: &str, author: &str) {\n        self.catalog.entry(title.to_string()).or_insert(author.to_string());\n    }\n\n    /// Allows a user to borrow a book if it's available\n    fn borrow_book(&mut self, username: &str, title: &str) -> bool {\n        if self.catalog.contains_key(title) && !self.borrowed_books.contains_key(title) {\n            self.borrowed_books.insert(title.to_string(), username.to_string());\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Allows a user to return a book they previously borrowed\n    fn return_book(&mut self, username: &str, title: &str) -> bool {\n        if let Some(borrower) = self.borrowed_books.get(title) {\n            if borrower == username {\n                self.borrowed_books.remove(title);\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Lists all currently available books (title and author)\n    fn list_available_books(&self) -> HashMap<String, String> {\n        self.catalog\n            .iter()\n            .filter(|(title, _)| !self.borrowed_books.contains_key(*title))\n            .map(|(title, author)| (title.clone(), author.clone()))\n            .collect()\n    }\n\n    /// Lists all currently borrowed books (title, author, and borrower)\n    fn list_borrowed_books(&self) -> HashMap<String, (String, String)> {\n        self.borrowed_books\n            .iter()\n            .filter_map(|(title, username)| {\n                self.catalog\n                    .get(title)\n                    .map(|author| (title.clone(), (author.clone(), username.clone())))\n            })\n            .collect()\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 13478, "assertions": "#[test]\nfn test_library_operations() {\n    let mut library = Library::new();\n\n    // Add books to the library\n    library.add_book(\"The Rust Programming Language\", \"Steve Klabnik and Carol Nichols\");\n    library.add_book(\"1984\", \"George Orwell\");\n    library.add_book(\"To Kill a Mockingbird\", \"Harper Lee\");\n    library.add_book(\"The Great Gatsby\", \"F. Scott Fitzgerald\");\n\n    // Test initial state\n    assert_eq!(library.list_available_books().len(), 4);\n    assert_eq!(library.list_borrowed_books().len(), 0);\n\n    // Test borrowing books\n    assert!(library.borrow_book(\"user1\", \"1984\"));\n    assert!(library.borrow_book(\"user2\", \"The Rust Programming Language\"));\n    assert!(!library.borrow_book(\"user1\", \"Nonexistent Book\"));\n    assert!(!library.borrow_book(\"user3\", \"1984\"));\n\n    // Test state after borrowing\n    assert_eq!(library.list_available_books().len(), 2);\n    assert_eq!(library.list_borrowed_books().len(), 2);\n\n    // Test returning books\n    assert!(library.return_book(\"user1\", \"1984\"));\n    assert!(!library.return_book(\"user2\", \"1984\"));\n    assert!(!library.return_book(\"user3\", \"Nonexistent Book\"));\n    assert!(library.return_book(\"user2\", \"The Rust Programming Language\"));\n\n    // Test final state\n    assert_eq!(library.list_available_books().len(), 4);\n    assert_eq!(library.list_borrowed_books().len(), 0);\n}", "all_code": "use std::collections::HashMap;\n\n/// Represents a library with book catalog and borrowing functionality\nstruct Library {\n    catalog: HashMap<String, String>,          // Maps book titles to authors\n    borrowed_books: HashMap<String, String>,   // Maps book titles to usernames\n}\n\nimpl Library {\n    /// Creates a new, empty Library\n    fn new() -> Self {\n        Library {\n            catalog: HashMap::new(),\n            borrowed_books: HashMap::new(),\n        }\n    }\n\n    /// Adds a book to the library catalog if it doesn't already exist\n    fn add_book(&mut self, title: &str, author: &str) {\n        self.catalog.entry(title.to_string()).or_insert(author.to_string());\n    }\n\n    /// Allows a user to borrow a book if it's available\n    fn borrow_book(&mut self, username: &str, title: &str) -> bool {\n        if self.catalog.contains_key(title) && !self.borrowed_books.contains_key(title) {\n            self.borrowed_books.insert(title.to_string(), username.to_string());\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Allows a user to return a book they previously borrowed\n    fn return_book(&mut self, username: &str, title: &str) -> bool {\n        if let Some(borrower) = self.borrowed_books.get(title) {\n            if borrower == username {\n                self.borrowed_books.remove(title);\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Lists all currently available books (title and author)\n    fn list_available_books(&self) -> HashMap<String, String> {\n        self.catalog\n            .iter()\n            .filter(|(title, _)| !self.borrowed_books.contains_key(*title))\n            .map(|(title, author)| (title.clone(), author.clone()))\n            .collect()\n    }\n\n    /// Lists all currently borrowed books (title, author, and borrower)\n    fn list_borrowed_books(&self) -> HashMap<String, (String, String)> {\n        self.borrowed_books\n            .iter()\n            .filter_map(|(title, username)| {\n                self.catalog\n                    .get(title)\n                    .map(|author| (title.clone(), (author.clone(), username.clone())))\n            })\n            .collect()\n    }\n}\n#[test]\nfn test_library_operations() {\n    let mut library = Library::new();\n\n    // Add books to the library\n    library.add_book(\"The Rust Programming Language\", \"Steve Klabnik and Carol Nichols\");\n    library.add_book(\"1984\", \"George Orwell\");\n    library.add_book(\"To Kill a Mockingbird\", \"Harper Lee\");\n    library.add_book(\"The Great Gatsby\", \"F. Scott Fitzgerald\");\n\n    // Test initial state\n    assert_eq!(library.list_available_books().len(), 4);\n    assert_eq!(library.list_borrowed_books().len(), 0);\n\n    // Test borrowing books\n    assert!(library.borrow_book(\"user1\", \"1984\"));\n    assert!(library.borrow_book(\"user2\", \"The Rust Programming Language\"));\n    assert!(!library.borrow_book(\"user1\", \"Nonexistent Book\"));\n    assert!(!library.borrow_book(\"user3\", \"1984\"));\n\n    // Test state after borrowing\n    assert_eq!(library.list_available_books().len(), 2);\n    assert_eq!(library.list_borrowed_books().len(), 2);\n\n    // Test returning books\n    assert!(library.return_book(\"user1\", \"1984\"));\n    assert!(!library.return_book(\"user2\", \"1984\"));\n    assert!(!library.return_book(\"user3\", \"Nonexistent Book\"));\n    assert!(library.return_book(\"user2\", \"The Rust Programming Language\"));\n\n    // Test final state\n    assert_eq!(library.list_available_books().len(), 4);\n    assert_eq!(library.list_borrowed_books().len(), 0);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Cleans a sentence by removing non-alphabetic characters, converting to lowercase,\n/// and sorting the characters alphabetically.\nfn clean_sentence(sentence: &str) -> String {\n    let cleaned: String = sentence\n        .chars()\n        .filter(|c| c.is_alphabetic())\n        .map(|c| c.to_ascii_lowercase())\n        .collect();\n    \n    let mut chars: Vec<char> = cleaned.chars().collect();\n    chars.sort();\n    chars.into_iter().collect()\n}\n\n/// Groups sentences into anagrams by their cleaned form.\n/// Returns a HashMap where keys are cleaned sentences and values are vectors of original sentences.\nfn find_anagram_sentences(sentences: &[&str]) -> HashMap<String, Vec<String>> {\n    let mut anagram_dict: HashMap<String, Vec<String>> = HashMap::new();\n\n    for &sentence in sentences {\n        let cleaned = clean_sentence(sentence);\n        anagram_dict\n            .entry(cleaned)\n            .or_default()\n            .push(sentence.to_string());\n    }\n\n    anagram_dict\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23090, "assertions": "#[test]\nfn test_anagram_sentences() {\n    // Test case 1\n    let case1 = vec![\"Listen\", \"silent\", \"enlist\", \"hello\", \"world\"];\n    let anagrams1 = find_anagram_sentences(&case1);\n    assert_eq!(\n        anagrams1.get(&\"eilnst\".to_string()),\n        Some(&vec![\"Listen\".to_string(), \"silent\".to_string(), \"enlist\".to_string()])\n    );\n    assert_eq!(anagrams1.get(&\"ehllo\".to_string()), Some(&vec![\"hello\".to_string()]));\n    assert_eq!(anagrams1.get(&\"dlorw\".to_string()), Some(&vec![\"world\".to_string()]));\n\n    // Test case 2\n    let case2 = vec![\"Dormitory\", \"Dirty room\", \"Clint Eastwood\", \"Old West action\"];\n    let anagrams2 = find_anagram_sentences(&case2);\n    assert_eq!(\n        anagrams2.get(&\"dimooprrty\".to_string()),\n        Some(&vec![\"Dormitory\".to_string(), \"Dirty room\".to_string()])\n    );\n    assert_eq!(\n        anagrams2.get(&\"acdeilnoostw\".to_string()),\n        Some(&vec![\"Clint Eastwood\".to_string(), \"Old West action\".to_string()])\n    );\n\n    // Test case 3\n    let case3 = vec![\"The eyes\", \"They see\", \"Coffee\", \"Fee fco\"];\n    let anagrams3 = find_anagram_sentences(&case3);\n    assert_eq!(\n        anagrams3.get(&\"eeehsty\".to_string()),\n        Some(&vec![\"The eyes\".to_string(), \"They see\".to_string()])\n    );\n    assert_eq!(\n        anagrams3.get(&\"ceeffo\".to_string()),\n        Some(&vec![\"Coffee\".to_string(), \"Fee fco\".to_string()])\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Cleans a sentence by removing non-alphabetic characters, converting to lowercase,\n/// and sorting the characters alphabetically.\nfn clean_sentence(sentence: &str) -> String {\n    let cleaned: String = sentence\n        .chars()\n        .filter(|c| c.is_alphabetic())\n        .map(|c| c.to_ascii_lowercase())\n        .collect();\n    \n    let mut chars: Vec<char> = cleaned.chars().collect();\n    chars.sort();\n    chars.into_iter().collect()\n}\n\n/// Groups sentences into anagrams by their cleaned form.\n/// Returns a HashMap where keys are cleaned sentences and values are vectors of original sentences.\nfn find_anagram_sentences(sentences: &[&str]) -> HashMap<String, Vec<String>> {\n    let mut anagram_dict: HashMap<String, Vec<String>> = HashMap::new();\n\n    for &sentence in sentences {\n        let cleaned = clean_sentence(sentence);\n        anagram_dict\n            .entry(cleaned)\n            .or_default()\n            .push(sentence.to_string());\n    }\n\n    anagram_dict\n}\n#[test]\nfn test_anagram_sentences() {\n    // Test case 1\n    let case1 = vec![\"Listen\", \"silent\", \"enlist\", \"hello\", \"world\"];\n    let anagrams1 = find_anagram_sentences(&case1);\n    assert_eq!(\n        anagrams1.get(&\"eilnst\".to_string()),\n        Some(&vec![\"Listen\".to_string(), \"silent\".to_string(), \"enlist\".to_string()])\n    );\n    assert_eq!(anagrams1.get(&\"ehllo\".to_string()), Some(&vec![\"hello\".to_string()]));\n    assert_eq!(anagrams1.get(&\"dlorw\".to_string()), Some(&vec![\"world\".to_string()]));\n\n    // Test case 2\n    let case2 = vec![\"Dormitory\", \"Dirty room\", \"Clint Eastwood\", \"Old West action\"];\n    let anagrams2 = find_anagram_sentences(&case2);\n    assert_eq!(\n        anagrams2.get(&\"dimooprrty\".to_string()),\n        Some(&vec![\"Dormitory\".to_string(), \"Dirty room\".to_string()])\n    );\n    assert_eq!(\n        anagrams2.get(&\"acdeilnoostw\".to_string()),\n        Some(&vec![\"Clint Eastwood\".to_string(), \"Old West action\".to_string()])\n    );\n\n    // Test case 3\n    let case3 = vec![\"The eyes\", \"They see\", \"Coffee\", \"Fee fco\"];\n    let anagrams3 = find_anagram_sentences(&case3);\n    assert_eq!(\n        anagrams3.get(&\"eeehsty\".to_string()),\n        Some(&vec![\"The eyes\".to_string(), \"They see\".to_string()])\n    );\n    assert_eq!(\n        anagrams3.get(&\"ceeffo\".to_string()),\n        Some(&vec![\"Coffee\".to_string(), \"Fee fco\".to_string()])\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::io;\n\n// Processes a series of queries on building step costs\n// n - number of buildings (unused in this implementation)\n// buildings - mutable reference to a vector of vectors representing building steps and their costs\n// queries - vector of query strings to process\n// Returns a vector of results for query type 1 (sum operations)\nfn process_queries(n: usize, buildings: &mut Vec<Vec<i32>>, queries: Vec<&str>) -> Vec<i32> {\n    let mut results = Vec::new();\n    \n    for query in queries {\n        let parts: Vec<&str> = query.split_whitespace().collect();\n        let query_type: i32 = parts[0].parse().unwrap();\n        let b: usize = parts[1].parse::<usize>().unwrap() - 1; // Convert to 0-based index\n\n        match query_type {\n            1 => {\n                // Sum query: sum steps from x to y (inclusive)\n                let x: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based start\n                let y: usize = parts[3].parse::<usize>().unwrap(); // 1-based end (inclusive)\n                let sum: i32 = buildings[b][x..y].iter().sum();\n                results.push(sum);\n            }\n            2 => {\n                // Insert query: insert new step at position p with cost c\n                let p: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based position\n                let c: i32 = parts[3].parse().unwrap();\n                buildings[b].insert(p, c);\n            }\n            3 => {\n                // Delete query: remove step at position p\n                let p: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based position\n                buildings[b].remove(p);\n            }\n            _ => panic!(\"Invalid query type\"),\n        }\n    }\n    \n    results\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23061, "assertions": "#[test]\nfn test_process_queries() {\n    let n = 3;\n    let mut buildings = vec![\n        vec![10, 20, 30, 40, 50],\n        vec![15, 25, 35],\n        vec![5, 10, 15, 20]\n    ];\n    let queries = vec![\n        \"1 1 2 4\",  // Sum building 1 steps 2-4 (20+30+40)\n        \"2 2 2 30\", // Insert cost 30 at position 2 in building 2\n        \"1 2 1 3\",  // Sum building 2 steps 1-3 (25+30+35)\n        \"3 1 3\",    // Remove step 3 from building 1 (40)\n        \"1 1 1 3\",  // Sum building 1 steps 1-3 (20+30+50)\n        \"1 3 2 4\"   // Sum building 3 steps 2-4 (10+15+20)\n    ];\n\n    let results = process_queries(n, &mut buildings, queries);\n\n    assert_eq!(results, vec![90, 90, 100, 45]);\n    assert_eq!(buildings[0], vec![10, 20, 30, 50]);\n    assert_eq!(buildings[1], vec![15, 25, 30, 35]);\n    assert_eq!(buildings[2], vec![5, 10, 15, 20]);\n}", "all_code": "use std::io;\n\n// Processes a series of queries on building step costs\n// n - number of buildings (unused in this implementation)\n// buildings - mutable reference to a vector of vectors representing building steps and their costs\n// queries - vector of query strings to process\n// Returns a vector of results for query type 1 (sum operations)\nfn process_queries(n: usize, buildings: &mut Vec<Vec<i32>>, queries: Vec<&str>) -> Vec<i32> {\n    let mut results = Vec::new();\n    \n    for query in queries {\n        let parts: Vec<&str> = query.split_whitespace().collect();\n        let query_type: i32 = parts[0].parse().unwrap();\n        let b: usize = parts[1].parse::<usize>().unwrap() - 1; // Convert to 0-based index\n\n        match query_type {\n            1 => {\n                // Sum query: sum steps from x to y (inclusive)\n                let x: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based start\n                let y: usize = parts[3].parse::<usize>().unwrap(); // 1-based end (inclusive)\n                let sum: i32 = buildings[b][x..y].iter().sum();\n                results.push(sum);\n            }\n            2 => {\n                // Insert query: insert new step at position p with cost c\n                let p: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based position\n                let c: i32 = parts[3].parse().unwrap();\n                buildings[b].insert(p, c);\n            }\n            3 => {\n                // Delete query: remove step at position p\n                let p: usize = parts[2].parse::<usize>().unwrap() - 1; // 0-based position\n                buildings[b].remove(p);\n            }\n            _ => panic!(\"Invalid query type\"),\n        }\n    }\n    \n    results\n}\n#[test]\nfn test_process_queries() {\n    let n = 3;\n    let mut buildings = vec![\n        vec![10, 20, 30, 40, 50],\n        vec![15, 25, 35],\n        vec![5, 10, 15, 20]\n    ];\n    let queries = vec![\n        \"1 1 2 4\",  // Sum building 1 steps 2-4 (20+30+40)\n        \"2 2 2 30\", // Insert cost 30 at position 2 in building 2\n        \"1 2 1 3\",  // Sum building 2 steps 1-3 (25+30+35)\n        \"3 1 3\",    // Remove step 3 from building 1 (40)\n        \"1 1 1 3\",  // Sum building 1 steps 1-3 (20+30+50)\n        \"1 3 2 4\"   // Sum building 3 steps 2-4 (10+15+20)\n    ];\n\n    let results = process_queries(n, &mut buildings, queries);\n\n    assert_eq!(results, vec![90, 90, 100, 45]);\n    assert_eq!(buildings[0], vec![10, 20, 30, 50]);\n    assert_eq!(buildings[1], vec![15, 25, 30, 35]);\n    assert_eq!(buildings[2], vec![5, 10, 15, 20]);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to encode a string by converting each character to its positional value in the alphabet\n// and summing these values.\n//\n// # Arguments\n// * `s` - A string slice consisting of lowercase alphabetical characters\n//\n// # Returns\n// The encoded value of the string as an integer\nfn encode_string(s: &str) -> u32 {\n    s.chars().map(|c| (c as u32) - ('a' as u32) + 1).sum()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 4426, "assertions": "#[test]\nfn test_encode_string() {\n    assert_eq!(encode_string(\"abc\"), 6);\n    assert_eq!(encode_string(\"xyz\"), 75);\n    assert_eq!(encode_string(\"a\"), 1);\n    assert_eq!(encode_string(\"z\"), 26);\n    assert_eq!(encode_string(\"hello\"), 52);\n}", "all_code": "// Function to encode a string by converting each character to its positional value in the alphabet\n// and summing these values.\n//\n// # Arguments\n// * `s` - A string slice consisting of lowercase alphabetical characters\n//\n// # Returns\n// The encoded value of the string as an integer\nfn encode_string(s: &str) -> u32 {\n    s.chars().map(|c| (c as u32) - ('a' as u32) + 1).sum()\n}\n#[test]\nfn test_encode_string() {\n    assert_eq!(encode_string(\"abc\"), 6);\n    assert_eq!(encode_string(\"xyz\"), 75);\n    assert_eq!(encode_string(\"a\"), 1);\n    assert_eq!(encode_string(\"z\"), 26);\n    assert_eq!(encode_string(\"hello\"), 52);\n}", "exec_outcome": "PASSED"}
{"code": "fn consecutive_product_sequence(arr: &[i32]) -> Vec<i32> {\n    // Replaces each element in the list (except first and last) with the product of the previous and next elements.\n    // For lists with less than 3 elements, returns the input unchanged.\n    \n    let n = arr.len();\n    // If the list has less than 3 elements, return a copy of it\n    if n < 3 {\n        return arr.to_vec();\n    }\n    \n    // Create a new vector to store the result\n    let mut result = arr.to_vec();\n    \n    // Iterate through elements (excluding first and last)\n    for i in 1..n-1 {\n        result[i] = arr[i-1] * arr[i+1];\n    }\n    \n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21615, "assertions": "#[test]\nfn test_consecutive_product_sequence() {\n    assert_eq!(consecutive_product_sequence(&[1, 2, 3, 4]), vec![1, 3, 8, 4]);\n    assert_eq!(consecutive_product_sequence(&[5, 6]), vec![5, 6]);\n    assert_eq!(consecutive_product_sequence(&[10]), vec![10]);\n    assert_eq!(consecutive_product_sequence(&[2, 3, 5, 7, 11]), vec![2, 10, 21, 55, 11]);\n    assert_eq!(consecutive_product_sequence(&[0, 1, 0, 1, 0]), vec![0, 0, 0, 0, 0]);\n    assert_eq!(consecutive_product_sequence(&[-1, -2, -3, -4]), vec![-1, 3, 8, -4]);\n}", "all_code": "fn consecutive_product_sequence(arr: &[i32]) -> Vec<i32> {\n    // Replaces each element in the list (except first and last) with the product of the previous and next elements.\n    // For lists with less than 3 elements, returns the input unchanged.\n    \n    let n = arr.len();\n    // If the list has less than 3 elements, return a copy of it\n    if n < 3 {\n        return arr.to_vec();\n    }\n    \n    // Create a new vector to store the result\n    let mut result = arr.to_vec();\n    \n    // Iterate through elements (excluding first and last)\n    for i in 1..n-1 {\n        result[i] = arr[i-1] * arr[i+1];\n    }\n    \n    result\n}\n#[test]\nfn test_consecutive_product_sequence() {\n    assert_eq!(consecutive_product_sequence(&[1, 2, 3, 4]), vec![1, 3, 8, 4]);\n    assert_eq!(consecutive_product_sequence(&[5, 6]), vec![5, 6]);\n    assert_eq!(consecutive_product_sequence(&[10]), vec![10]);\n    assert_eq!(consecutive_product_sequence(&[2, 3, 5, 7, 11]), vec![2, 10, 21, 55, 11]);\n    assert_eq!(consecutive_product_sequence(&[0, 1, 0, 1, 0]), vec![0, 0, 0, 0, 0]);\n    assert_eq!(consecutive_product_sequence(&[-1, -2, -3, -4]), vec![-1, 3, 8, -4]);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to determine the winner of the card game based on the number of cards.\n// The game rules are such that Alan starts first and picks optimally.\n// Alan wins if the integer division of M by 2 is odd, otherwise Barbara wins.\nfn determine_winner(m: i32) -> String {\n    if (m / 2) % 2 == 1 {\n        \"Alan\".to_string()\n    } else {\n        \"Barbara\".to_string()\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 9872, "assertions": "#[test]\nfn test_determine_winner() {\n    assert_eq!(determine_winner(4), \"Barbara\".to_string());\n    assert_eq!(determine_winner(6), \"Alan\".to_string());\n    assert_eq!(determine_winner(8), \"Barbara\".to_string());\n    assert_eq!(determine_winner(10), \"Alan\".to_string());\n    assert_eq!(determine_winner(2), \"Alan\".to_string());\n}", "all_code": "// Function to determine the winner of the card game based on the number of cards.\n// The game rules are such that Alan starts first and picks optimally.\n// Alan wins if the integer division of M by 2 is odd, otherwise Barbara wins.\nfn determine_winner(m: i32) -> String {\n    if (m / 2) % 2 == 1 {\n        \"Alan\".to_string()\n    } else {\n        \"Barbara\".to_string()\n    }\n}\n#[test]\nfn test_determine_winner() {\n    assert_eq!(determine_winner(4), \"Barbara\".to_string());\n    assert_eq!(determine_winner(6), \"Alan\".to_string());\n    assert_eq!(determine_winner(8), \"Barbara\".to_string());\n    assert_eq!(determine_winner(10), \"Alan\".to_string());\n    assert_eq!(determine_winner(2), \"Alan\".to_string());\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Determines the hour (in 24-hour format) that contains the most events.\n/// If multiple hours contain the maximum number of events, returns the earliest hour.\n///\n/// # Arguments\n/// * `timestamps` - A slice of string slices representing timestamps in \"YYYY-MM-DD HH:MM:SS\" format.\n///\n/// # Returns\n/// A tuple containing the most common hour (as a String) and the count of events in that hour.\nfn most_frequent_hour(timestamps: &[&str]) -> (String, usize) {\n    let mut hourly_count = HashMap::new();\n\n    // Count occurrences of each hour\n    for timestamp in timestamps {\n        let hour = timestamp.split_whitespace()\n                           .nth(1)\n                           .and_then(|time| time.split(':').next())\n                           .unwrap_or(\"\");\n        *hourly_count.entry(hour.to_string()).or_insert(0) += 1;\n    }\n\n    // Find the hour with maximum count, using the earliest hour in case of ties\n    let most_common_hour = hourly_count.iter()\n        .max_by_key(|&(hour, count)| (count, -(hour.parse::<i32>().unwrap_or(0))))\n        .map(|(hour, count)| (hour.clone(), *count))\n        .unwrap_or_else(|| (String::new(), 0));\n\n    most_common_hour\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 20288, "assertions": "#[test]\nfn test_most_frequent_hour() {\n    // Test case 1: Multiple timestamps with 12 as most frequent hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 12:30:45\",\n            \"2023-01-01 12:45:00\",\n            \"2023-01-02 13:15:30\",\n            \"2023-01-02 12:10:00\",\n            \"2023-01-03 12:00:00\",\n        ]),\n        (\"12\".to_string(), 3)\n    );\n\n    // Test case 2: Tie between hours, should return earliest hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 09:00:00\",\n            \"2023-01-01 09:30:00\",\n            \"2023-01-01 10:00:00\",\n            \"2023-01-02 09:00:00\",\n        ]),\n        (\"09\".to_string(), 2)\n    );\n\n    // Test case 3: All hours unique, should return earliest hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 00:00:00\",\n            \"2023-01-01 23:59:59\",\n            \"2023-01-02 00:00:01\",\n        ]),\n        (\"00\".to_string(), 2)\n    );\n\n    // Test case 4: Single timestamp\n    assert_eq!(\n        most_frequent_hour(&[\"2023-01-01 15:30:00\"]),\n        (\"15\".to_string(), 1)\n    );\n\n    // Test case 5: Empty input\n    assert_eq!(\n        most_frequent_hour(&[]),\n        (\"\".to_string(), 0)\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Determines the hour (in 24-hour format) that contains the most events.\n/// If multiple hours contain the maximum number of events, returns the earliest hour.\n///\n/// # Arguments\n/// * `timestamps` - A slice of string slices representing timestamps in \"YYYY-MM-DD HH:MM:SS\" format.\n///\n/// # Returns\n/// A tuple containing the most common hour (as a String) and the count of events in that hour.\nfn most_frequent_hour(timestamps: &[&str]) -> (String, usize) {\n    let mut hourly_count = HashMap::new();\n\n    // Count occurrences of each hour\n    for timestamp in timestamps {\n        let hour = timestamp.split_whitespace()\n                           .nth(1)\n                           .and_then(|time| time.split(':').next())\n                           .unwrap_or(\"\");\n        *hourly_count.entry(hour.to_string()).or_insert(0) += 1;\n    }\n\n    // Find the hour with maximum count, using the earliest hour in case of ties\n    let most_common_hour = hourly_count.iter()\n        .max_by_key(|&(hour, count)| (count, -(hour.parse::<i32>().unwrap_or(0))))\n        .map(|(hour, count)| (hour.clone(), *count))\n        .unwrap_or_else(|| (String::new(), 0));\n\n    most_common_hour\n}\n#[test]\nfn test_most_frequent_hour() {\n    // Test case 1: Multiple timestamps with 12 as most frequent hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 12:30:45\",\n            \"2023-01-01 12:45:00\",\n            \"2023-01-02 13:15:30\",\n            \"2023-01-02 12:10:00\",\n            \"2023-01-03 12:00:00\",\n        ]),\n        (\"12\".to_string(), 3)\n    );\n\n    // Test case 2: Tie between hours, should return earliest hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 09:00:00\",\n            \"2023-01-01 09:30:00\",\n            \"2023-01-01 10:00:00\",\n            \"2023-01-02 09:00:00\",\n        ]),\n        (\"09\".to_string(), 2)\n    );\n\n    // Test case 3: All hours unique, should return earliest hour\n    assert_eq!(\n        most_frequent_hour(&[\n            \"2023-01-01 00:00:00\",\n            \"2023-01-01 23:59:59\",\n            \"2023-01-02 00:00:01\",\n        ]),\n        (\"00\".to_string(), 2)\n    );\n\n    // Test case 4: Single timestamp\n    assert_eq!(\n        most_frequent_hour(&[\"2023-01-01 15:30:00\"]),\n        (\"15\".to_string(), 1)\n    );\n\n    // Test case 5: Empty input\n    assert_eq!(\n        most_frequent_hour(&[]),\n        (\"\".to_string(), 0)\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn sum_except_self(lst: &[i32]) -> Vec<i32> {\n    // Calculate the total sum of all elements in the list\n    let total_sum: i32 = lst.iter().sum();\n    \n    // For each element in the list, subtract the element from the total sum\n    lst.iter().map(|&x| total_sum - x).collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 13730, "assertions": "#[test]\nfn test_sum_except_self() {\n    assert_eq!(sum_except_self(&[1, 2, 3, 4]), vec![9, 8, 7, 6]);\n    assert_eq!(sum_except_self(&[5, 6, 7, 0]), vec![13, 12, 11, 18]);\n    assert_eq!(sum_except_self(&[0, 0, 0, 0]), vec![0, 0, 0, 0]);\n    assert_eq!(sum_except_self(&[10]), vec![0]);\n}", "all_code": "fn sum_except_self(lst: &[i32]) -> Vec<i32> {\n    // Calculate the total sum of all elements in the list\n    let total_sum: i32 = lst.iter().sum();\n    \n    // For each element in the list, subtract the element from the total sum\n    lst.iter().map(|&x| total_sum - x).collect()\n}\n#[test]\nfn test_sum_except_self() {\n    assert_eq!(sum_except_self(&[1, 2, 3, 4]), vec![9, 8, 7, 6]);\n    assert_eq!(sum_except_self(&[5, 6, 7, 0]), vec![13, 12, 11, 18]);\n    assert_eq!(sum_except_self(&[0, 0, 0, 0]), vec![0, 0, 0, 0]);\n    assert_eq!(sum_except_self(&[10]), vec![0]);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to compute the minimum waiting time by summing the first elements of each intersection tuple\nfn compute_minimum_waiting_time(intersections: &[(i32, i32)]) -> i32 {\n    // Sum all the first elements (a values) of the intersection tuples\n    intersections.iter().map(|inter| inter.0).sum()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 29007, "assertions": "#[test]\nfn test_compute_minimum_waiting_time() {\n    // Test case 1: Simple case with 2 intersections\n    assert_eq!(compute_minimum_waiting_time(&vec![(5, 2), (3, 4)]), 8);\n    \n    // Test case 2: Single intersection\n    assert_eq!(compute_minimum_waiting_time(&vec![(10, 1)]), 10);\n    \n    // Test case 3: Multiple intersections with zero waiting time\n    assert_eq!(compute_minimum_waiting_time(&vec![(0, 5), (0, 3), (0, 7)]), 0);\n    \n    // Test case 4: Mixed positive waiting times\n    assert_eq!(compute_minimum_waiting_time(&vec![(2, 1), (4, 3), (6, 5), (8, 7)]), 20);\n}", "all_code": "// Function to compute the minimum waiting time by summing the first elements of each intersection tuple\nfn compute_minimum_waiting_time(intersections: &[(i32, i32)]) -> i32 {\n    // Sum all the first elements (a values) of the intersection tuples\n    intersections.iter().map(|inter| inter.0).sum()\n}\n#[test]\nfn test_compute_minimum_waiting_time() {\n    // Test case 1: Simple case with 2 intersections\n    assert_eq!(compute_minimum_waiting_time(&vec![(5, 2), (3, 4)]), 8);\n    \n    // Test case 2: Single intersection\n    assert_eq!(compute_minimum_waiting_time(&vec![(10, 1)]), 10);\n    \n    // Test case 3: Multiple intersections with zero waiting time\n    assert_eq!(compute_minimum_waiting_time(&vec![(0, 5), (0, 3), (0, 7)]), 0);\n    \n    // Test case 4: Mixed positive waiting times\n    assert_eq!(compute_minimum_waiting_time(&vec![(2, 1), (4, 3), (6, 5), (8, 7)]), 20);\n}", "exec_outcome": "PASSED"}
{"code": "use std::cmp::max;\n\n/// Computes the maximum amount of gold that can be collected from a grid,\n/// moving only right, right-up, or right-down from each cell.\n///\n/// # Arguments\n/// * `grid` - A 2D vector representing the gold grid\n///\n/// # Returns\n/// The maximum amount of gold that can be collected\nfn max_gold(grid: Vec<Vec<i32>>) -> i32 {\n    let n = grid.len();\n    if n == 0 {\n        return 0;\n    }\n    let m = grid[0].len();\n    \n    // Create a DP table initialized to 0\n    let mut dp = vec![vec![0; m]; n];\n    \n    // Initialize first column\n    for i in 0..n {\n        dp[i][0] = grid[i][0];\n    }\n    \n    // Fill the DP table\n    for j in 1..m {\n        for i in 0..n {\n            let gold_from_left = dp[i][j - 1];\n            let gold_from_left_up = if i > 0 { dp[i - 1][j - 1] } else { 0 };\n            let gold_from_left_down = if i < n - 1 { dp[i + 1][j - 1] } else { 0 };\n            \n            dp[i][j] = grid[i][j] + max(gold_from_left, max(gold_from_left_up, gold_from_left_down));\n        }\n    }\n    \n    // Find the maximum in the last column\n    dp.iter().map(|row| row[m - 1]).max().unwrap_or(0)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21442, "assertions": "#[test]\nfn test_max_gold() {\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 3, 3],\n            vec![2, 1, 4],\n            vec![0, 6, 4]\n        ]),\n        12\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 3, 1, 5],\n            vec![2, 2, 4, 1],\n            vec![5, 0, 2, 3],\n            vec![0, 6, 1, 2]\n        ]),\n        16\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![10, 0, 0, 0],\n            vec![0, 0, 0, 0],\n            vec![0, 0, 0, 0]\n        ]),\n        10\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 2],\n            vec![3, 4]\n        ]),\n        6\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![5]\n        ]),\n        5\n    );\n}", "all_code": "use std::cmp::max;\n\n/// Computes the maximum amount of gold that can be collected from a grid,\n/// moving only right, right-up, or right-down from each cell.\n///\n/// # Arguments\n/// * `grid` - A 2D vector representing the gold grid\n///\n/// # Returns\n/// The maximum amount of gold that can be collected\nfn max_gold(grid: Vec<Vec<i32>>) -> i32 {\n    let n = grid.len();\n    if n == 0 {\n        return 0;\n    }\n    let m = grid[0].len();\n    \n    // Create a DP table initialized to 0\n    let mut dp = vec![vec![0; m]; n];\n    \n    // Initialize first column\n    for i in 0..n {\n        dp[i][0] = grid[i][0];\n    }\n    \n    // Fill the DP table\n    for j in 1..m {\n        for i in 0..n {\n            let gold_from_left = dp[i][j - 1];\n            let gold_from_left_up = if i > 0 { dp[i - 1][j - 1] } else { 0 };\n            let gold_from_left_down = if i < n - 1 { dp[i + 1][j - 1] } else { 0 };\n            \n            dp[i][j] = grid[i][j] + max(gold_from_left, max(gold_from_left_up, gold_from_left_down));\n        }\n    }\n    \n    // Find the maximum in the last column\n    dp.iter().map(|row| row[m - 1]).max().unwrap_or(0)\n}\n#[test]\nfn test_max_gold() {\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 3, 3],\n            vec![2, 1, 4],\n            vec![0, 6, 4]\n        ]),\n        12\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 3, 1, 5],\n            vec![2, 2, 4, 1],\n            vec![5, 0, 2, 3],\n            vec![0, 6, 1, 2]\n        ]),\n        16\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![10, 0, 0, 0],\n            vec![0, 0, 0, 0],\n            vec![0, 0, 0, 0]\n        ]),\n        10\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![1, 2],\n            vec![3, 4]\n        ]),\n        6\n    );\n    assert_eq!(\n        max_gold(vec![\n            vec![5]\n        ]),\n        5\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn max_performance(n: usize, a: &[i32], b: &[i32]) -> i32 {\n    // Calculates the maximum possible product of skill level and speed\n    // by comparing all possible combinations of skills and speeds.\n    // \n    // Parameters:\n    // n - Number of participants (unused in this implementation but kept for interface consistency)\n    // a - Slice of skill levels\n    // b - Slice of speeds\n    //\n    // Returns:\n    // The maximum product of skill level and speed\n\n    let mut max_product = 0;\n    \n    // Iterate through all combinations of skills and speeds\n    for &skill in a {\n        for &speed in b {\n            max_product = max_product.max(skill * speed);\n        }\n    }\n    \n    max_product\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 27552, "assertions": "#[test]\nfn test_max_performance() {\n    assert_eq!(max_performance(3, &[1, 2, 3], &[4, 5, 6]), 18);\n    assert_eq!(max_performance(2, &[10, 20], &[30, 40]), 800);\n    assert_eq!(max_performance(4, &[0, 0, 0, 0], &[1, 2, 3, 4]), 0);\n    assert_eq!(max_performance(1, &[5], &[10]), 50);\n    assert_eq!(max_performance(3, &[-1, -2, -3], &[-4, -5, -6]), 12);\n}", "all_code": "fn max_performance(n: usize, a: &[i32], b: &[i32]) -> i32 {\n    // Calculates the maximum possible product of skill level and speed\n    // by comparing all possible combinations of skills and speeds.\n    // \n    // Parameters:\n    // n - Number of participants (unused in this implementation but kept for interface consistency)\n    // a - Slice of skill levels\n    // b - Slice of speeds\n    //\n    // Returns:\n    // The maximum product of skill level and speed\n\n    let mut max_product = 0;\n    \n    // Iterate through all combinations of skills and speeds\n    for &skill in a {\n        for &speed in b {\n            max_product = max_product.max(skill * speed);\n        }\n    }\n    \n    max_product\n}\n#[test]\nfn test_max_performance() {\n    assert_eq!(max_performance(3, &[1, 2, 3], &[4, 5, 6]), 18);\n    assert_eq!(max_performance(2, &[10, 20], &[30, 40]), 800);\n    assert_eq!(max_performance(4, &[0, 0, 0, 0], &[1, 2, 3, 4]), 0);\n    assert_eq!(max_performance(1, &[5], &[10]), 50);\n    assert_eq!(max_performance(3, &[-1, -2, -3], &[-4, -5, -6]), 12);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn reorder_odd_even(arr: &mut Vec<i32>) -> Vec<i32> {\n    // Reorders the elements of the array such that all odd integers come before\n    // all even integers, maintaining the relative order among the odd and even\n    // integers as in the original array.\n    if arr.is_empty() {\n        return arr.clone();\n    }\n\n    let mut odd_idx = 0; // pointer for odd numbers\n    \n    for i in 0..arr.len() {\n        if arr[i] % 2 == 1 {\n            let val = arr.remove(i);\n            arr.insert(odd_idx, val);\n            odd_idx += 1;\n        }\n    }\n    \n    arr.clone()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22932, "assertions": "#[test]\nfn test_reorder_odd_even() {\n    let mut test_case1 = vec![];\n    assert_eq!(reorder_odd_even(&mut test_case1), vec![]);\n    \n    let mut test_case2 = vec![1, 2, 3, 4, 5, 6];\n    assert_eq!(reorder_odd_even(&mut test_case2), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case3 = vec![2, 4, 6, 1, 3, 5];\n    assert_eq!(reorder_odd_even(&mut test_case3), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case4 = vec![1, 3, 5, 2, 4, 6];\n    assert_eq!(reorder_odd_even(&mut test_case4), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case5 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(reorder_odd_even(&mut test_case5), vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 10]);\n    \n    let mut test_case6 = vec![2, 2, 2, 1, 1, 1];\n    assert_eq!(reorder_odd_even(&mut test_case6), vec![1, 1, 1, 2, 2, 2]);\n}", "all_code": "fn reorder_odd_even(arr: &mut Vec<i32>) -> Vec<i32> {\n    // Reorders the elements of the array such that all odd integers come before\n    // all even integers, maintaining the relative order among the odd and even\n    // integers as in the original array.\n    if arr.is_empty() {\n        return arr.clone();\n    }\n\n    let mut odd_idx = 0; // pointer for odd numbers\n    \n    for i in 0..arr.len() {\n        if arr[i] % 2 == 1 {\n            let val = arr.remove(i);\n            arr.insert(odd_idx, val);\n            odd_idx += 1;\n        }\n    }\n    \n    arr.clone()\n}\n#[test]\nfn test_reorder_odd_even() {\n    let mut test_case1 = vec![];\n    assert_eq!(reorder_odd_even(&mut test_case1), vec![]);\n    \n    let mut test_case2 = vec![1, 2, 3, 4, 5, 6];\n    assert_eq!(reorder_odd_even(&mut test_case2), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case3 = vec![2, 4, 6, 1, 3, 5];\n    assert_eq!(reorder_odd_even(&mut test_case3), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case4 = vec![1, 3, 5, 2, 4, 6];\n    assert_eq!(reorder_odd_even(&mut test_case4), vec![1, 3, 5, 2, 4, 6]);\n    \n    let mut test_case5 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq!(reorder_odd_even(&mut test_case5), vec![1, 3, 5, 7, 9, 2, 4, 6, 8, 10]);\n    \n    let mut test_case6 = vec![2, 2, 2, 1, 1, 1];\n    assert_eq!(reorder_odd_even(&mut test_case6), vec![1, 1, 1, 2, 2, 2]);\n}", "exec_outcome": "PASSED"}
{"code": "/// Checks if a number is prime and returns its factors if it's not prime.\n///\n/// # Arguments\n/// * `n` - The number to check for primality.\n///\n/// # Returns\n/// A tuple containing:\n/// - A boolean indicating whether the number is prime (true) or not (false)\n/// - A vector of factors (empty if the number is prime)\nfn is_prime(n: i32) -> (bool, Vec<i32>) {\n    // Handle edge cases\n    if n <= 1 {\n        return (false, Vec::new());\n    }\n    if n == 2 {\n        return (true, Vec::new());\n    }\n\n    let mut factors = Vec::new();\n    let sqrt_n = (n as f64).sqrt() as i32 + 1;\n\n    // Check for factors from 2 to sqrt(n)\n    for i in 2..sqrt_n {\n        if n % i == 0 {\n            factors.push(i);\n            let complement = n / i;\n            if i != complement {\n                factors.push(complement);\n            }\n        }\n    }\n\n    // If no factors found, it's prime\n    if factors.is_empty() {\n        (true, factors)\n    } else {\n        factors.sort();\n        (false, factors)\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 27397, "assertions": "#[test]\nfn test_is_prime() {\n    // Test cases with expected results\n    assert_eq!(is_prime(-1), (false, vec![]));\n    assert_eq!(is_prime(0), (false, vec![]));\n    assert_eq!(is_prime(1), (false, vec![]));\n    assert_eq!(is_prime(2), (true, vec![]));\n    assert_eq!(is_prime(3), (true, vec![]));\n    assert_eq!(is_prime(4), (false, vec![2]));\n    assert_eq!(is_prime(9), (false, vec![3]));\n    assert_eq!(is_prime(15), (false, vec![3, 5]));\n    assert_eq!(is_prime(17), (true, vec![]));\n    assert_eq!(is_prime(25), (false, vec![5]));\n    assert_eq!(is_prime(97), (true, vec![]));\n    assert_eq!(is_prime(100), (false, vec![2, 4, 5, 10, 20, 25, 50]));\n}", "all_code": "/// Checks if a number is prime and returns its factors if it's not prime.\n///\n/// # Arguments\n/// * `n` - The number to check for primality.\n///\n/// # Returns\n/// A tuple containing:\n/// - A boolean indicating whether the number is prime (true) or not (false)\n/// - A vector of factors (empty if the number is prime)\nfn is_prime(n: i32) -> (bool, Vec<i32>) {\n    // Handle edge cases\n    if n <= 1 {\n        return (false, Vec::new());\n    }\n    if n == 2 {\n        return (true, Vec::new());\n    }\n\n    let mut factors = Vec::new();\n    let sqrt_n = (n as f64).sqrt() as i32 + 1;\n\n    // Check for factors from 2 to sqrt(n)\n    for i in 2..sqrt_n {\n        if n % i == 0 {\n            factors.push(i);\n            let complement = n / i;\n            if i != complement {\n                factors.push(complement);\n            }\n        }\n    }\n\n    // If no factors found, it's prime\n    if factors.is_empty() {\n        (true, factors)\n    } else {\n        factors.sort();\n        (false, factors)\n    }\n}\n#[test]\nfn test_is_prime() {\n    // Test cases with expected results\n    assert_eq!(is_prime(-1), (false, vec![]));\n    assert_eq!(is_prime(0), (false, vec![]));\n    assert_eq!(is_prime(1), (false, vec![]));\n    assert_eq!(is_prime(2), (true, vec![]));\n    assert_eq!(is_prime(3), (true, vec![]));\n    assert_eq!(is_prime(4), (false, vec![2]));\n    assert_eq!(is_prime(9), (false, vec![3]));\n    assert_eq!(is_prime(15), (false, vec![3, 5]));\n    assert_eq!(is_prime(17), (true, vec![]));\n    assert_eq!(is_prime(25), (false, vec![5]));\n    assert_eq!(is_prime(97), (true, vec![]));\n    assert_eq!(is_prime(100), (false, vec![2, 4, 5, 10, 20, 25, 50]));\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Creates a vector with items that appear more than once in the input vector.\n/// Each item appears in the new vector as many times as the square of \n/// the number of appearances in the input vector.\nfn create_duplicate_list(my_list: &[i32]) -> Vec<i32> {\n    // Count occurrences of each item in the input list\n    let mut counts = HashMap::new();\n    for &item in my_list {\n        *counts.entry(item).or_insert(0) += 1;\n    }\n\n    let mut result = Vec::new();\n    \n    // For each item that appears more than once, add it to the result\n    // count^2 times\n    for (&item, &count) in counts.iter() {\n        if count > 1 {\n            result.extend(std::iter::repeat(item).take(count * count));\n        }\n    }\n    \n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23610, "assertions": "#[test]\nfn test_create_duplicate_list() {\n    assert_eq!(\n        create_duplicate_list(&vec![1, 2, 3, 2, 1, 4, 5, 6, 2]),\n        vec![1, 1, 2, 2, 2, 2, 2, 2]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![1, 1, 1, 1]),\n        vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![1, 2, 3, 4]),\n        vec![]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![5, 5, 6, 6, 6]),\n        vec![5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6]\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Creates a vector with items that appear more than once in the input vector.\n/// Each item appears in the new vector as many times as the square of \n/// the number of appearances in the input vector.\nfn create_duplicate_list(my_list: &[i32]) -> Vec<i32> {\n    // Count occurrences of each item in the input list\n    let mut counts = HashMap::new();\n    for &item in my_list {\n        *counts.entry(item).or_insert(0) += 1;\n    }\n\n    let mut result = Vec::new();\n    \n    // For each item that appears more than once, add it to the result\n    // count^2 times\n    for (&item, &count) in counts.iter() {\n        if count > 1 {\n            result.extend(std::iter::repeat(item).take(count * count));\n        }\n    }\n    \n    result\n}\n#[test]\nfn test_create_duplicate_list() {\n    assert_eq!(\n        create_duplicate_list(&vec![1, 2, 3, 2, 1, 4, 5, 6, 2]),\n        vec![1, 1, 2, 2, 2, 2, 2, 2]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![1, 1, 1, 1]),\n        vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![1, 2, 3, 4]),\n        vec![]\n    );\n    assert_eq!(\n        create_duplicate_list(&vec![5, 5, 6, 6, 6]),\n        vec![5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6]\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to check if a given square matrix is a magic square.\n// A magic square is a square matrix where the sums of each row, each column, and both main diagonals are all equal.\nfn is_magic_square(matrix: &Vec<Vec<i32>>) -> bool {\n    let n = matrix.len();\n    if n == 0 {\n        return false;\n    }\n\n    // Calculate the target sum from the first row\n    let target_sum: i32 = matrix[0].iter().sum();\n\n    // Check sums of all rows\n    for row in matrix {\n        if row.iter().sum::<i32>() != target_sum {\n            return false;\n        }\n    }\n\n    // Check sums of all columns\n    for col in 0..n {\n        let col_sum: i32 = matrix.iter().map(|row| row[col]).sum();\n        if col_sum != target_sum {\n            return false;\n        }\n    }\n\n    // Check sum of the main diagonal\n    let diag_sum: i32 = (0..n).map(|i| matrix[i][i]).sum();\n    if diag_sum != target_sum {\n        return false;\n    }\n\n    // Check sum of the anti-diagonal\n    let anti_diag_sum: i32 = (0..n).map(|i| matrix[i][n - 1 - i]).sum();\n    if anti_diag_sum != target_sum {\n        return false;\n    }\n\n    true\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 15314, "assertions": "#[test]\nfn test_is_magic_square() {\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![2, 7, 6],\n            vec![9, 5, 1],\n            vec![4, 3, 8],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 1, 1],\n            vec![1, 1, 1],\n            vec![1, 1, 1],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        false\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![16, 3, 2, 13],\n            vec![5, 10, 11, 8],\n            vec![9, 6, 7, 12],\n            vec![4, 15, 14, 1],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 2],\n            vec![3, 4],\n        ]),\n        false\n    );\n}", "all_code": "// Function to check if a given square matrix is a magic square.\n// A magic square is a square matrix where the sums of each row, each column, and both main diagonals are all equal.\nfn is_magic_square(matrix: &Vec<Vec<i32>>) -> bool {\n    let n = matrix.len();\n    if n == 0 {\n        return false;\n    }\n\n    // Calculate the target sum from the first row\n    let target_sum: i32 = matrix[0].iter().sum();\n\n    // Check sums of all rows\n    for row in matrix {\n        if row.iter().sum::<i32>() != target_sum {\n            return false;\n        }\n    }\n\n    // Check sums of all columns\n    for col in 0..n {\n        let col_sum: i32 = matrix.iter().map(|row| row[col]).sum();\n        if col_sum != target_sum {\n            return false;\n        }\n    }\n\n    // Check sum of the main diagonal\n    let diag_sum: i32 = (0..n).map(|i| matrix[i][i]).sum();\n    if diag_sum != target_sum {\n        return false;\n    }\n\n    // Check sum of the anti-diagonal\n    let anti_diag_sum: i32 = (0..n).map(|i| matrix[i][n - 1 - i]).sum();\n    if anti_diag_sum != target_sum {\n        return false;\n    }\n\n    true\n}\n#[test]\nfn test_is_magic_square() {\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![2, 7, 6],\n            vec![9, 5, 1],\n            vec![4, 3, 8],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 1, 1],\n            vec![1, 1, 1],\n            vec![1, 1, 1],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n        ]),\n        false\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![16, 3, 2, 13],\n            vec![5, 10, 11, 8],\n            vec![9, 6, 7, 12],\n            vec![4, 15, 14, 1],\n        ]),\n        true\n    );\n    assert_eq!(\n        is_magic_square(&vec![\n            vec![1, 2],\n            vec![3, 4],\n        ]),\n        false\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{HashMap, HashSet};\n\n/// Finds all paths from start node to end node in an unweighted graph using an iterative approach.\n///\n/// # Arguments\n/// * `graph` - A HashMap representing an adjacency list of the graph\n/// * `start` - The starting node\n/// * `end` - The end node\n///\n/// # Returns\n/// A vector of vectors, where each inner vector represents a path from start to end\nfn find_all_paths_iterative(\n    graph: &HashMap<String, Vec<String>>,\n    start: &str,\n    end: &str,\n) -> Vec<Vec<String>> {\n    let mut all_paths = Vec::new();\n    let mut stack = vec![(start.to_string(), vec![start.to_string()])];\n\n    while let Some((current_node, path)) = stack.pop() {\n        if current_node == end {\n            all_paths.push(path);\n        } else {\n            if let Some(neighbors) = graph.get(&current_node) {\n                for neighbor in neighbors {\n                    // Convert path to HashSet for efficient lookup\n                    let path_set: HashSet<_> = path.iter().collect();\n                    if !path_set.contains(neighbor) {\n                        let mut new_path = path.clone();\n                        new_path.push(neighbor.to_string());\n                        stack.push((neighbor.to_string(), new_path));\n                    }\n                }\n            }\n        }\n    }\n\n    all_paths\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 1240, "assertions": "#[test]\nfn test_find_all_paths_iterative() {\n    // Test graph represented as an adjacency list\n    let mut graph = HashMap::new();\n    graph.insert(\n        \"A\".to_string(),\n        vec![\"B\".to_string(), \"C\".to_string(), \"D\".to_string()],\n    );\n    graph.insert(\"B\".to_string(), vec![\"E\".to_string(), \"F\".to_string()]);\n    graph.insert(\"C\".to_string(), vec![\"G\".to_string()]);\n    graph.insert(\"D\".to_string(), vec![\"H\".to_string()]);\n    graph.insert(\"E\".to_string(), vec![\"F\".to_string()]);\n    graph.insert(\"F\".to_string(), vec![\"G\".to_string()]);\n    graph.insert(\"G\".to_string(), vec![\"H\".to_string()]);\n\n    // Test case 1: Simple path (A -> H)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"H\");\n    assert_eq!(paths.len(), 6); // There are 6 possible paths from A to H\n\n    // Test case 2: Start equals end (A -> A)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"A\");\n    assert_eq!(paths, vec![vec![\"A\".to_string()]]);\n\n    // Test case 3: No path exists (A -> Z)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"Z\");\n    assert_eq!(paths, Vec::<Vec<String>>::new());\n}", "all_code": "use std::collections::{HashMap, HashSet};\n\n/// Finds all paths from start node to end node in an unweighted graph using an iterative approach.\n///\n/// # Arguments\n/// * `graph` - A HashMap representing an adjacency list of the graph\n/// * `start` - The starting node\n/// * `end` - The end node\n///\n/// # Returns\n/// A vector of vectors, where each inner vector represents a path from start to end\nfn find_all_paths_iterative(\n    graph: &HashMap<String, Vec<String>>,\n    start: &str,\n    end: &str,\n) -> Vec<Vec<String>> {\n    let mut all_paths = Vec::new();\n    let mut stack = vec![(start.to_string(), vec![start.to_string()])];\n\n    while let Some((current_node, path)) = stack.pop() {\n        if current_node == end {\n            all_paths.push(path);\n        } else {\n            if let Some(neighbors) = graph.get(&current_node) {\n                for neighbor in neighbors {\n                    // Convert path to HashSet for efficient lookup\n                    let path_set: HashSet<_> = path.iter().collect();\n                    if !path_set.contains(neighbor) {\n                        let mut new_path = path.clone();\n                        new_path.push(neighbor.to_string());\n                        stack.push((neighbor.to_string(), new_path));\n                    }\n                }\n            }\n        }\n    }\n\n    all_paths\n}\n#[test]\nfn test_find_all_paths_iterative() {\n    // Test graph represented as an adjacency list\n    let mut graph = HashMap::new();\n    graph.insert(\n        \"A\".to_string(),\n        vec![\"B\".to_string(), \"C\".to_string(), \"D\".to_string()],\n    );\n    graph.insert(\"B\".to_string(), vec![\"E\".to_string(), \"F\".to_string()]);\n    graph.insert(\"C\".to_string(), vec![\"G\".to_string()]);\n    graph.insert(\"D\".to_string(), vec![\"H\".to_string()]);\n    graph.insert(\"E\".to_string(), vec![\"F\".to_string()]);\n    graph.insert(\"F\".to_string(), vec![\"G\".to_string()]);\n    graph.insert(\"G\".to_string(), vec![\"H\".to_string()]);\n\n    // Test case 1: Simple path (A -> H)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"H\");\n    assert_eq!(paths.len(), 6); // There are 6 possible paths from A to H\n\n    // Test case 2: Start equals end (A -> A)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"A\");\n    assert_eq!(paths, vec![vec![\"A\".to_string()]]);\n\n    // Test case 3: No path exists (A -> Z)\n    let paths = find_all_paths_iterative(&graph, \"A\", \"Z\");\n    assert_eq!(paths, Vec::<Vec<String>>::new());\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn count_substring(main_string: &str, substring: &str) -> usize {\n    // Counts the number of times a substring appears in a main string.\n    // This implementation handles overlapping occurrences correctly.\n    \n    if substring.is_empty() {\n        return 0;\n    }\n    \n    let mut count = 0;\n    let mut start = 0;\n    \n    while let Some(pos) = main_string[start..].find(substring) {\n        count += 1;\n        start += pos + 1;\n    }\n    \n    count\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 19086, "assertions": "#[test]\nfn test_count_substring() {\n    assert_eq!(count_substring(\"banana\", \"ana\"), 2);\n    assert_eq!(count_substring(\"hello world\", \"l\"), 3);\n    assert_eq!(count_substring(\"aaaaa\", \"aa\"), 4);\n    assert_eq!(count_substring(\"rust is awesome\", \"is\"), 1);\n    assert_eq!(count_substring(\"\", \"test\"), 0);\n    assert_eq!(count_substring(\"abc\", \"\"), 0);\n    assert_eq!(count_substring(\"same\", \"same\"), 1);\n}", "all_code": "fn count_substring(main_string: &str, substring: &str) -> usize {\n    // Counts the number of times a substring appears in a main string.\n    // This implementation handles overlapping occurrences correctly.\n    \n    if substring.is_empty() {\n        return 0;\n    }\n    \n    let mut count = 0;\n    let mut start = 0;\n    \n    while let Some(pos) = main_string[start..].find(substring) {\n        count += 1;\n        start += pos + 1;\n    }\n    \n    count\n}\n#[test]\nfn test_count_substring() {\n    assert_eq!(count_substring(\"banana\", \"ana\"), 2);\n    assert_eq!(count_substring(\"hello world\", \"l\"), 3);\n    assert_eq!(count_substring(\"aaaaa\", \"aa\"), 4);\n    assert_eq!(count_substring(\"rust is awesome\", \"is\"), 1);\n    assert_eq!(count_substring(\"\", \"test\"), 0);\n    assert_eq!(count_substring(\"abc\", \"\"), 0);\n    assert_eq!(count_substring(\"same\", \"same\"), 1);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashSet;\n\n/// Determines if a subset of the given list of integers sums up to the target.\n/// Uses dynamic programming to solve the subset sum problem.\nfn can_reach_target_sum(nums: &[i32], target: i32) -> bool {\n    let mut possible_sums = HashSet::new();\n    possible_sums.insert(0);\n\n    for &num in nums {\n        // Create a temporary vector to hold current sums for iteration\n        let current_sums: Vec<i32> = possible_sums.iter().cloned().collect();\n        \n        for &s in &current_sums {\n            let new_sum = s + num;\n            if new_sum == target {\n                return true;\n            }\n            possible_sums.insert(new_sum);\n        }\n    }\n\n    possible_sums.contains(&target)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22820, "assertions": "#[test]\nfn test_can_reach_target_sum() {\n    assert_eq!(can_reach_target_sum(&[1, 2, 3, 4], 7), true);  // 3+4 = 7\n    assert_eq!(can_reach_target_sum(&[1, 2, 3, 4], 10), false); // no subset sums to 10\n    assert_eq!(can_reach_target_sum(&[3, 34, 4, 12, 5, 2], 9), true);  // 4+5 = 9\n    assert_eq!(can_reach_target_sum(&[], 0), true); // empty subset sums to 0\n    assert_eq!(can_reach_target_sum(&[1, 1, 1, 1], 4), true);  // 1+1+1+1 = 4\n    assert_eq!(can_reach_target_sum(&[5, 10, 15], 25), true);  // 10+15 = 25\n}", "all_code": "use std::collections::HashSet;\n\n/// Determines if a subset of the given list of integers sums up to the target.\n/// Uses dynamic programming to solve the subset sum problem.\nfn can_reach_target_sum(nums: &[i32], target: i32) -> bool {\n    let mut possible_sums = HashSet::new();\n    possible_sums.insert(0);\n\n    for &num in nums {\n        // Create a temporary vector to hold current sums for iteration\n        let current_sums: Vec<i32> = possible_sums.iter().cloned().collect();\n        \n        for &s in &current_sums {\n            let new_sum = s + num;\n            if new_sum == target {\n                return true;\n            }\n            possible_sums.insert(new_sum);\n        }\n    }\n\n    possible_sums.contains(&target)\n}\n#[test]\nfn test_can_reach_target_sum() {\n    assert_eq!(can_reach_target_sum(&[1, 2, 3, 4], 7), true);  // 3+4 = 7\n    assert_eq!(can_reach_target_sum(&[1, 2, 3, 4], 10), false); // no subset sums to 10\n    assert_eq!(can_reach_target_sum(&[3, 34, 4, 12, 5, 2], 9), true);  // 4+5 = 9\n    assert_eq!(can_reach_target_sum(&[], 0), true); // empty subset sums to 0\n    assert_eq!(can_reach_target_sum(&[1, 1, 1, 1], 4), true);  // 1+1+1+1 = 4\n    assert_eq!(can_reach_target_sum(&[5, 10, 15], 25), true);  // 10+15 = 25\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::HashMap;\n\n/// Finds the redundant connection in the graph that can be removed to make it a tree.\n///\n/// This function uses the Union-Find (Disjoint Set Union) algorithm to detect cycles in the graph.\n/// When adding an edge would connect two already connected nodes, that edge is redundant.\n///\n/// # Arguments\n/// * `edges` - A vector of tuples representing the edges of the graph\n///\n/// # Returns\n/// The redundant edge as a tuple, or None if no redundant edge exists\nfn find_redundant_connection(edges: Vec<(usize, usize)>) -> Option<(usize, usize)> {\n    let mut parent: Vec<usize> = (0..=edges.len()).collect();\n    \n    /// Finds the root parent of a node with path compression\n    fn find(parent: &mut Vec<usize>, x: usize) -> usize {\n        if parent[x] != x {\n            parent[x] = find(parent, parent[x]);\n        }\n        parent[x]\n    }\n    \n    /// Unions two sets and returns false if they were already in the same set\n    fn union(parent: &mut Vec<usize>, x: usize, y: usize) -> bool {\n        let root_x = find(parent, x);\n        let root_y = find(parent, y);\n        if root_x == root_y {\n            return false;\n        }\n        parent[root_x] = root_y;\n        true\n    }\n    \n    for &(u, v) in &edges {\n        if !union(&mut parent, u, v) {\n            return Some((u, v));\n        }\n    }\n    \n    None\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 16634, "assertions": "#[test]\nfn test_find_redundant_connection() {\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (1, 3), (2, 3)]),\n        Some((2, 3))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (3, 4), (1, 4), (1, 5)]),\n        Some((1, 4))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (1, 3)]),\n        Some((1, 3))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (1, 3), (3, 4)]),\n        Some((1, 3))\n    );\n}", "all_code": "use std::collections::HashMap;\n\n/// Finds the redundant connection in the graph that can be removed to make it a tree.\n///\n/// This function uses the Union-Find (Disjoint Set Union) algorithm to detect cycles in the graph.\n/// When adding an edge would connect two already connected nodes, that edge is redundant.\n///\n/// # Arguments\n/// * `edges` - A vector of tuples representing the edges of the graph\n///\n/// # Returns\n/// The redundant edge as a tuple, or None if no redundant edge exists\nfn find_redundant_connection(edges: Vec<(usize, usize)>) -> Option<(usize, usize)> {\n    let mut parent: Vec<usize> = (0..=edges.len()).collect();\n    \n    /// Finds the root parent of a node with path compression\n    fn find(parent: &mut Vec<usize>, x: usize) -> usize {\n        if parent[x] != x {\n            parent[x] = find(parent, parent[x]);\n        }\n        parent[x]\n    }\n    \n    /// Unions two sets and returns false if they were already in the same set\n    fn union(parent: &mut Vec<usize>, x: usize, y: usize) -> bool {\n        let root_x = find(parent, x);\n        let root_y = find(parent, y);\n        if root_x == root_y {\n            return false;\n        }\n        parent[root_x] = root_y;\n        true\n    }\n    \n    for &(u, v) in &edges {\n        if !union(&mut parent, u, v) {\n            return Some((u, v));\n        }\n    }\n    \n    None\n}\n#[test]\nfn test_find_redundant_connection() {\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (1, 3), (2, 3)]),\n        Some((2, 3))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (3, 4), (1, 4), (1, 5)]),\n        Some((1, 4))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (1, 3)]),\n        Some((1, 3))\n    );\n    assert_eq!(\n        find_redundant_connection(vec![(1, 2), (2, 3), (1, 3), (3, 4)]),\n        Some((1, 3))\n    );\n}", "exec_outcome": "PASSED"}
{"code": "fn count_attack_pairs(soldier_strengths: &[i32]) -> i32 {\n    // Counts the number of unique pairs (i, j) where soldier_strengths[i] < soldier_strengths[j] and i < j\n    let n = soldier_strengths.len();\n    let mut count = 0;\n    \n    for i in 0..n {\n        for j in (i + 1)..n {\n            if soldier_strengths[i] < soldier_strengths[j] {\n                count += 1;\n            }\n        }\n    }\n    \n    count\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23757, "assertions": "#[test]\nfn test_count_attack_pairs() {\n    assert_eq!(count_attack_pairs(&vec![1, 2, 3, 4]), 6);    // All pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![4, 3, 2, 1]), 0);    // No pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![2, 1, 3, 4]), 4);    // Some pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![1, 1, 1, 1]), 0);    // No pairs satisfy the condition (all equal)\n    assert_eq!(count_attack_pairs(&vec![1, 3, 2, 4]), 5);    // Mixed case\n}", "all_code": "fn count_attack_pairs(soldier_strengths: &[i32]) -> i32 {\n    // Counts the number of unique pairs (i, j) where soldier_strengths[i] < soldier_strengths[j] and i < j\n    let n = soldier_strengths.len();\n    let mut count = 0;\n    \n    for i in 0..n {\n        for j in (i + 1)..n {\n            if soldier_strengths[i] < soldier_strengths[j] {\n                count += 1;\n            }\n        }\n    }\n    \n    count\n}\n#[test]\nfn test_count_attack_pairs() {\n    assert_eq!(count_attack_pairs(&vec![1, 2, 3, 4]), 6);    // All pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![4, 3, 2, 1]), 0);    // No pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![2, 1, 3, 4]), 4);    // Some pairs satisfy the condition\n    assert_eq!(count_attack_pairs(&vec![1, 1, 1, 1]), 0);    // No pairs satisfy the condition (all equal)\n    assert_eq!(count_attack_pairs(&vec![1, 3, 2, 4]), 5);    // Mixed case\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn interleave_strings(str_list: &[&str]) -> String {\n    // Interleaves characters from a list of strings character by character.\n    // \n    // Args:\n    // str_list: A slice of string references to be interleaved.\n    //\n    // Returns:\n    // A String with characters interleaved from the input strings.\n    // If the input is empty, returns an empty string.\n    if str_list.is_empty() {\n        return String::new();\n    }\n\n    // Find the maximum length among all strings\n    let max_len = str_list.iter().map(|s| s.len()).max().unwrap_or(0);\n    let mut result = String::new();\n\n    for i in 0..max_len {\n        for s in str_list {\n            // Push the character at position i if it exists\n            if let Some(c) = s.chars().nth(i) {\n                result.push(c);\n            }\n        }\n    }\n\n    result\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 23862, "assertions": "#[test]\nfn test_interleave_strings() {\n    assert_eq!(interleave_strings(&[\"abc\", \"123\", \"xyz\"]), \"a1xb2yc3z\");\n    assert_eq!(interleave_strings(&[\"a\", \"12\", \"xyz\"]), \"a1x2y\");\n    assert_eq!(interleave_strings(&[\"\", \"hello\", \"world\"]), \"hweolrllod\");\n    assert_eq!(interleave_strings(&[\"single\"]), \"single\");\n    assert_eq!(interleave_strings(&[]), \"\");\n}", "all_code": "fn interleave_strings(str_list: &[&str]) -> String {\n    // Interleaves characters from a list of strings character by character.\n    // \n    // Args:\n    // str_list: A slice of string references to be interleaved.\n    //\n    // Returns:\n    // A String with characters interleaved from the input strings.\n    // If the input is empty, returns an empty string.\n    if str_list.is_empty() {\n        return String::new();\n    }\n\n    // Find the maximum length among all strings\n    let max_len = str_list.iter().map(|s| s.len()).max().unwrap_or(0);\n    let mut result = String::new();\n\n    for i in 0..max_len {\n        for s in str_list {\n            // Push the character at position i if it exists\n            if let Some(c) = s.chars().nth(i) {\n                result.push(c);\n            }\n        }\n    }\n\n    result\n}\n#[test]\nfn test_interleave_strings() {\n    assert_eq!(interleave_strings(&[\"abc\", \"123\", \"xyz\"]), \"a1xb2yc3z\");\n    assert_eq!(interleave_strings(&[\"a\", \"12\", \"xyz\"]), \"a1x2y\");\n    assert_eq!(interleave_strings(&[\"\", \"hello\", \"world\"]), \"hweolrllod\");\n    assert_eq!(interleave_strings(&[\"single\"]), \"single\");\n    assert_eq!(interleave_strings(&[]), \"\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to evaluate a boolean expression given as a string\n// The expression can contain T (true), F (false), and operators ! (NOT), & (AND), | (OR)\n// The expression is first converted to postfix notation (Reverse Polish Notation) and then evaluated\nfn evaluate_boolean_expression(expression: &str) -> bool {\n    // Evaluates a postfix boolean expression\n    fn eval_sub_expression(tokens: &[char]) -> bool {\n        let mut stack: Vec<bool> = Vec::new();\n        \n        for &token in tokens {\n            match token {\n                'T' => stack.push(true),\n                'F' => stack.push(false),\n                '!' => {\n                    let operand = stack.pop().unwrap();\n                    stack.push(!operand);\n                },\n                '&' => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left && right);\n                },\n                '|' => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left || right);\n                },\n                _ => panic!(\"Invalid token in expression\"),\n            }\n        }\n        stack[0]\n    }\n    \n    // Converts infix expression to postfix notation using Shunting-yard algorithm\n    fn to_tokens(expression: &str) -> Vec<char> {\n        let mut output: Vec<char> = Vec::new();\n        let mut stack: Vec<char> = Vec::new();\n        let precedence = |c: char| match c {\n            '!' => 3,\n            '&' => 2,\n            '|' => 1,\n            '(' => 0,\n            _ => -1,\n        };\n        \n        for c in expression.chars() {\n            match c {\n                'T' | 'F' => output.push(c),\n                '(' => stack.push(c),\n                ')' => {\n                    while let Some(top) = stack.pop() {\n                        if top == '(' {\n                            break;\n                        }\n                        output.push(top);\n                    }\n                },\n                '!' | '&' | '|' => {\n                    while let Some(&top) = stack.last() {\n                        if precedence(c) <= precedence(top) {\n                            output.push(stack.pop().unwrap());\n                        } else {\n                            break;\n                        }\n                    }\n                    stack.push(c);\n                },\n                _ => panic!(\"Invalid character in expression\"),\n            }\n        }\n        \n        while let Some(op) = stack.pop() {\n            output.push(op);\n        }\n        \n        output\n    }\n    \n    let tokens = to_tokens(expression);\n    eval_sub_expression(&tokens)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 19082, "assertions": "#[test]\nfn test_evaluate_boolean_expression() {\n    let test_cases = vec![\n        (\"T\", true),\n        (\"F\", false),\n        (\"!T\", false),\n        (\"!F\", true),\n        (\"T&T\", true),\n        (\"T&F\", false),\n        (\"F&T\", false),\n        (\"F&F\", false),\n        (\"T|T\", true),\n        (\"T|F\", true),\n        (\"F|T\", true),\n        (\"F|F\", false),\n        (\"!(T|F)\", false),\n        (\"!T&!F\", false),\n        (\"!(T&F)\", true),\n        (\"T&(F|T)\", true),\n        (\"(T|F)&(F|T)\", true),\n        (\"!T|!(F&T)\", false),\n    ];\n    \n    for (expr, expected) in test_cases {\n        assert_eq!(evaluate_boolean_expression(expr), expected);\n    }\n}", "all_code": "// Function to evaluate a boolean expression given as a string\n// The expression can contain T (true), F (false), and operators ! (NOT), & (AND), | (OR)\n// The expression is first converted to postfix notation (Reverse Polish Notation) and then evaluated\nfn evaluate_boolean_expression(expression: &str) -> bool {\n    // Evaluates a postfix boolean expression\n    fn eval_sub_expression(tokens: &[char]) -> bool {\n        let mut stack: Vec<bool> = Vec::new();\n        \n        for &token in tokens {\n            match token {\n                'T' => stack.push(true),\n                'F' => stack.push(false),\n                '!' => {\n                    let operand = stack.pop().unwrap();\n                    stack.push(!operand);\n                },\n                '&' => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left && right);\n                },\n                '|' => {\n                    let right = stack.pop().unwrap();\n                    let left = stack.pop().unwrap();\n                    stack.push(left || right);\n                },\n                _ => panic!(\"Invalid token in expression\"),\n            }\n        }\n        stack[0]\n    }\n    \n    // Converts infix expression to postfix notation using Shunting-yard algorithm\n    fn to_tokens(expression: &str) -> Vec<char> {\n        let mut output: Vec<char> = Vec::new();\n        let mut stack: Vec<char> = Vec::new();\n        let precedence = |c: char| match c {\n            '!' => 3,\n            '&' => 2,\n            '|' => 1,\n            '(' => 0,\n            _ => -1,\n        };\n        \n        for c in expression.chars() {\n            match c {\n                'T' | 'F' => output.push(c),\n                '(' => stack.push(c),\n                ')' => {\n                    while let Some(top) = stack.pop() {\n                        if top == '(' {\n                            break;\n                        }\n                        output.push(top);\n                    }\n                },\n                '!' | '&' | '|' => {\n                    while let Some(&top) = stack.last() {\n                        if precedence(c) <= precedence(top) {\n                            output.push(stack.pop().unwrap());\n                        } else {\n                            break;\n                        }\n                    }\n                    stack.push(c);\n                },\n                _ => panic!(\"Invalid character in expression\"),\n            }\n        }\n        \n        while let Some(op) = stack.pop() {\n            output.push(op);\n        }\n        \n        output\n    }\n    \n    let tokens = to_tokens(expression);\n    eval_sub_expression(&tokens)\n}\n#[test]\nfn test_evaluate_boolean_expression() {\n    let test_cases = vec![\n        (\"T\", true),\n        (\"F\", false),\n        (\"!T\", false),\n        (\"!F\", true),\n        (\"T&T\", true),\n        (\"T&F\", false),\n        (\"F&T\", false),\n        (\"F&F\", false),\n        (\"T|T\", true),\n        (\"T|F\", true),\n        (\"F|T\", true),\n        (\"F|F\", false),\n        (\"!(T|F)\", false),\n        (\"!T&!F\", false),\n        (\"!(T&F)\", true),\n        (\"T&(F|T)\", true),\n        (\"(T|F)&(F|T)\", true),\n        (\"!T|!(F&T)\", false),\n    ];\n    \n    for (expr, expected) in test_cases {\n        assert_eq!(evaluate_boolean_expression(expr), expected);\n    }\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to calculate total fruits collected in a zigzag pattern from a garden grid\n// \n// Parameters:\n// - n: number of rows in the garden\n// - m: number of columns in the garden (not used in calculation but kept for completeness)\n// - garden: 2D vector representing the garden with fruit counts\n//\n// Returns:\n// - Total fruits collected by summing rows left-to-right for even rows and right-to-left for odd rows\nfn total_fruits_in_zigzag(n: usize, m: usize, garden: &[Vec<i32>]) -> i32 {\n    let mut total_fruits = 0;\n\n    for (i, row) in garden.iter().enumerate().take(n) {\n        if i % 2 == 0 {\n            // Sum the row left-to-right for even indices\n            total_fruits += row.iter().sum::<i32>();\n        } else {\n            // Sum the row right-to-left for odd indices\n            total_fruits += row.iter().rev().sum::<i32>();\n        }\n    }\n\n    total_fruits\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 25480, "assertions": "#[test]\nfn test_total_fruits_in_zigzag() {\n    // Test case 1: 3x3 grid with sequential numbers\n    assert_eq!(\n        total_fruits_in_zigzag(\n            3,\n            3,\n            &vec![\n                vec![1, 2, 3],\n                vec![4, 5, 6],\n                vec![7, 8, 9],\n            ]\n        ),\n        25\n    );\n\n    // Test case 2: 2x4 grid with all ones\n    assert_eq!(\n        total_fruits_in_zigzag(\n            2,\n            4,\n            &vec![\n                vec![1, 1, 1, 1],\n                vec![1, 1, 1, 1],\n            ]\n        ),\n        8\n    );\n\n    // Test case 3: 4x2 grid with alternating patterns\n    assert_eq!(\n        total_fruits_in_zigzag(\n            4,\n            2,\n            &vec![\n                vec![1, 2],\n                vec![3, 4],\n                vec![5, 6],\n                vec![7, 8],\n            ]\n        ),\n        24\n    );\n\n    // Test case 4: 1x1 grid (single element)\n    assert_eq!(\n        total_fruits_in_zigzag(\n            1,\n            1,\n            &vec![\n                vec![10],\n            ]\n        ),\n        10\n    );\n}", "all_code": "// Function to calculate total fruits collected in a zigzag pattern from a garden grid\n// \n// Parameters:\n// - n: number of rows in the garden\n// - m: number of columns in the garden (not used in calculation but kept for completeness)\n// - garden: 2D vector representing the garden with fruit counts\n//\n// Returns:\n// - Total fruits collected by summing rows left-to-right for even rows and right-to-left for odd rows\nfn total_fruits_in_zigzag(n: usize, m: usize, garden: &[Vec<i32>]) -> i32 {\n    let mut total_fruits = 0;\n\n    for (i, row) in garden.iter().enumerate().take(n) {\n        if i % 2 == 0 {\n            // Sum the row left-to-right for even indices\n            total_fruits += row.iter().sum::<i32>();\n        } else {\n            // Sum the row right-to-left for odd indices\n            total_fruits += row.iter().rev().sum::<i32>();\n        }\n    }\n\n    total_fruits\n}\n#[test]\nfn test_total_fruits_in_zigzag() {\n    // Test case 1: 3x3 grid with sequential numbers\n    assert_eq!(\n        total_fruits_in_zigzag(\n            3,\n            3,\n            &vec![\n                vec![1, 2, 3],\n                vec![4, 5, 6],\n                vec![7, 8, 9],\n            ]\n        ),\n        25\n    );\n\n    // Test case 2: 2x4 grid with all ones\n    assert_eq!(\n        total_fruits_in_zigzag(\n            2,\n            4,\n            &vec![\n                vec![1, 1, 1, 1],\n                vec![1, 1, 1, 1],\n            ]\n        ),\n        8\n    );\n\n    // Test case 3: 4x2 grid with alternating patterns\n    assert_eq!(\n        total_fruits_in_zigzag(\n            4,\n            2,\n            &vec![\n                vec![1, 2],\n                vec![3, 4],\n                vec![5, 6],\n                vec![7, 8],\n            ]\n        ),\n        24\n    );\n\n    // Test case 4: 1x1 grid (single element)\n    assert_eq!(\n        total_fruits_in_zigzag(\n            1,\n            1,\n            &vec![\n                vec![10],\n            ]\n        ),\n        10\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn convert_temperature(temp_str: &str) -> String {\n    // Converts a temperature value between Celsius and Fahrenheit.\n    //\n    // Parameters:\n    // temp_str: The string containing the temperature value with either \"C\" or \"F\" suffix.\n    //\n    // Returns:\n    // The converted temperature value with the appropriate suffix or \"Invalid input\" if the input is not valid.\n    if temp_str.len() < 2 {\n        return String::from(\"Invalid input\");\n    }\n\n    // Extracting the temperature value and the suffix\n    let (temp_value_str, suffix) = temp_str.split_at(temp_str.len() - 1);\n    let suffix = suffix.to_uppercase();\n\n    // Checking if the input format is valid\n    let temp_value = match temp_value_str.parse::<f64>() {\n        Ok(val) => val,\n        Err(_) => return String::from(\"Invalid input\"),\n    };\n\n    // Converting temperature based on the suffix\n    match suffix.as_str() {\n        \"C\" => {\n            // Convert from Celsius to Fahrenheit\n            let converted_temp = temp_value * 9.0 / 5.0 + 32.0;\n            format!(\"{:.1}F\", converted_temp)\n        }\n        \"F\" => {\n            // Convert from Fahrenheit to Celsius\n            let converted_temp = (temp_value - 32.0) * 5.0 / 9.0;\n            format!(\"{:.1}C\", converted_temp)\n        }\n        _ => String::from(\"Invalid input\"),\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 8570, "assertions": "#[test]\nfn test_convert_temperature() {\n    assert_eq!(convert_temperature(\"37C\"), \"98.6F\");\n    assert_eq!(convert_temperature(\"100F\"), \"37.8C\");\n    assert_eq!(convert_temperature(\"0C\"), \"32.0F\");\n    assert_eq!(convert_temperature(\"32F\"), \"0.0C\");\n    assert_eq!(convert_temperature(\"abc\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"123\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"X23F\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"37c\"), \"98.6F\"); // lowercase suffix\n}", "all_code": "fn convert_temperature(temp_str: &str) -> String {\n    // Converts a temperature value between Celsius and Fahrenheit.\n    //\n    // Parameters:\n    // temp_str: The string containing the temperature value with either \"C\" or \"F\" suffix.\n    //\n    // Returns:\n    // The converted temperature value with the appropriate suffix or \"Invalid input\" if the input is not valid.\n    if temp_str.len() < 2 {\n        return String::from(\"Invalid input\");\n    }\n\n    // Extracting the temperature value and the suffix\n    let (temp_value_str, suffix) = temp_str.split_at(temp_str.len() - 1);\n    let suffix = suffix.to_uppercase();\n\n    // Checking if the input format is valid\n    let temp_value = match temp_value_str.parse::<f64>() {\n        Ok(val) => val,\n        Err(_) => return String::from(\"Invalid input\"),\n    };\n\n    // Converting temperature based on the suffix\n    match suffix.as_str() {\n        \"C\" => {\n            // Convert from Celsius to Fahrenheit\n            let converted_temp = temp_value * 9.0 / 5.0 + 32.0;\n            format!(\"{:.1}F\", converted_temp)\n        }\n        \"F\" => {\n            // Convert from Fahrenheit to Celsius\n            let converted_temp = (temp_value - 32.0) * 5.0 / 9.0;\n            format!(\"{:.1}C\", converted_temp)\n        }\n        _ => String::from(\"Invalid input\"),\n    }\n}\n#[test]\nfn test_convert_temperature() {\n    assert_eq!(convert_temperature(\"37C\"), \"98.6F\");\n    assert_eq!(convert_temperature(\"100F\"), \"37.8C\");\n    assert_eq!(convert_temperature(\"0C\"), \"32.0F\");\n    assert_eq!(convert_temperature(\"32F\"), \"0.0C\");\n    assert_eq!(convert_temperature(\"abc\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"123\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"X23F\"), \"Invalid input\");\n    assert_eq!(convert_temperature(\"37c\"), \"98.6F\"); // lowercase suffix\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashSet;\n\n/// Counts the number of unique subarrays of length k where all elements are distinct.\n///\n/// # Arguments\n/// * `arr` - A slice of integers representing the input array\n/// * `k` - The length of subarrays to consider\n///\n/// # Returns\n/// The count of unique subarrays of length k with all distinct elements\nfn count_unique_subarrays(arr: &[i32], k: usize) -> usize {\n    if k > arr.len() {\n        return 0;\n    }\n\n    let mut unique_subarrays = HashSet::new();\n\n    for i in 0..=(arr.len() - k) {\n        let subarray = &arr[i..i + k];\n        let unique_elements: HashSet<_> = subarray.iter().collect();\n        \n        if unique_elements.len() == k {\n            unique_subarrays.insert(subarray);\n        }\n    }\n\n    unique_subarrays.len()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 16684, "assertions": "#[test]\nfn test_count_unique_subarrays() {\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4, 5], 3), 3);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 1, 2], 3), 2);\n    assert_eq!(count_unique_subarrays(&[1, 1, 1, 1, 1], 2), 0);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4], 5), 0);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4, 1, 2], 4), 2);\n}", "all_code": "use std::collections::HashSet;\n\n/// Counts the number of unique subarrays of length k where all elements are distinct.\n///\n/// # Arguments\n/// * `arr` - A slice of integers representing the input array\n/// * `k` - The length of subarrays to consider\n///\n/// # Returns\n/// The count of unique subarrays of length k with all distinct elements\nfn count_unique_subarrays(arr: &[i32], k: usize) -> usize {\n    if k > arr.len() {\n        return 0;\n    }\n\n    let mut unique_subarrays = HashSet::new();\n\n    for i in 0..=(arr.len() - k) {\n        let subarray = &arr[i..i + k];\n        let unique_elements: HashSet<_> = subarray.iter().collect();\n        \n        if unique_elements.len() == k {\n            unique_subarrays.insert(subarray);\n        }\n    }\n\n    unique_subarrays.len()\n}\n#[test]\nfn test_count_unique_subarrays() {\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4, 5], 3), 3);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 1, 2], 3), 2);\n    assert_eq!(count_unique_subarrays(&[1, 1, 1, 1, 1], 2), 0);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4], 5), 0);\n    assert_eq!(count_unique_subarrays(&[1, 2, 3, 4, 1, 2], 4), 2);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::cmp::min;\n\n/// Calculates the minimum cost to paint all houses with no two adjacent houses having the same color.\n/// Each house has different costs for painting it red, green, or blue.\n/// The costs are provided as a 2D vector where costs[i][0], costs[i][1], and costs[i][2] represent\n/// the cost of painting house i red, green, and blue respectively.\nfn min_cost(costs: Vec<Vec<i32>>) -> i32 {\n    let n = costs.len();\n    if n == 0 {\n        return 0;\n    }\n\n    // Create a mutable copy of the costs to modify\n    let mut dp = costs.clone();\n\n    for i in 1..n {\n        // Cost to paint current house red plus min cost of previous house being green or blue\n        dp[i][0] += min(dp[i-1][1], dp[i-1][2]);\n        \n        // Cost to paint current house green plus min cost of previous house being red or blue\n        dp[i][1] += min(dp[i-1][0], dp[i-1][2]);\n        \n        // Cost to paint current house blue plus min cost of previous house being red or green\n        dp[i][2] += min(dp[i-1][0], dp[i-1][1]);\n    }\n\n    // The result is the minimum cost among the three options for the last house\n    *dp[n-1].iter().min().unwrap()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 10930, "assertions": "#[test]\nfn test_min_cost() {\n    assert_eq!(\n        min_cost(vec![\n            vec![17, 2, 17],\n            vec![16, 16, 5],\n            vec![14, 3, 19],\n        ]),\n        10\n    );\n    assert_eq!(\n        min_cost(vec![\n            vec![7, 6, 2],\n        ]),\n        2\n    );\n    assert_eq!(\n        min_cost(vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n            vec![10, 11, 12],\n        ]),\n        18\n    );\n    assert_eq!(\n        min_cost(vec![]),\n        0\n    );\n}", "all_code": "use std::cmp::min;\n\n/// Calculates the minimum cost to paint all houses with no two adjacent houses having the same color.\n/// Each house has different costs for painting it red, green, or blue.\n/// The costs are provided as a 2D vector where costs[i][0], costs[i][1], and costs[i][2] represent\n/// the cost of painting house i red, green, and blue respectively.\nfn min_cost(costs: Vec<Vec<i32>>) -> i32 {\n    let n = costs.len();\n    if n == 0 {\n        return 0;\n    }\n\n    // Create a mutable copy of the costs to modify\n    let mut dp = costs.clone();\n\n    for i in 1..n {\n        // Cost to paint current house red plus min cost of previous house being green or blue\n        dp[i][0] += min(dp[i-1][1], dp[i-1][2]);\n        \n        // Cost to paint current house green plus min cost of previous house being red or blue\n        dp[i][1] += min(dp[i-1][0], dp[i-1][2]);\n        \n        // Cost to paint current house blue plus min cost of previous house being red or green\n        dp[i][2] += min(dp[i-1][0], dp[i-1][1]);\n    }\n\n    // The result is the minimum cost among the three options for the last house\n    *dp[n-1].iter().min().unwrap()\n}\n#[test]\nfn test_min_cost() {\n    assert_eq!(\n        min_cost(vec![\n            vec![17, 2, 17],\n            vec![16, 16, 5],\n            vec![14, 3, 19],\n        ]),\n        10\n    );\n    assert_eq!(\n        min_cost(vec![\n            vec![7, 6, 2],\n        ]),\n        2\n    );\n    assert_eq!(\n        min_cost(vec![\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n            vec![7, 8, 9],\n            vec![10, 11, 12],\n        ]),\n        18\n    );\n    assert_eq!(\n        min_cost(vec![]),\n        0\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::HashMap;\n\n/// Calculates the frequency of each character in a string, ignoring case and spaces.\n///\n/// # Arguments\n/// * `s` - The input string to analyze\n///\n/// # Returns\n/// A HashMap where keys are characters (in lowercase) and values are their counts\nfn character_frequency(s: &str) -> HashMap<char, usize> {\n    let mut frequency = HashMap::new();\n    \n    // Iterate through each character in the string (converted to lowercase)\n    for char in s.to_lowercase().chars() {\n        // Skip spaces\n        if char != ' ' {\n            // Increment the count for this character\n            *frequency.entry(char).or_insert(0) += 1;\n        }\n    }\n    \n    frequency\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 19915, "assertions": "#[test]\nfn test_character_frequency() {\n    let mut expected = HashMap::new();\n    \n    // Test case 1: \"Hello World\"\n    expected.insert('h', 1);\n    expected.insert('e', 1);\n    expected.insert('l', 3);\n    expected.insert('o', 2);\n    expected.insert('w', 1);\n    expected.insert('r', 1);\n    expected.insert('d', 1);\n    assert_eq!(character_frequency(\"Hello World\"), expected);\n    expected.clear();\n\n    // Test case 2: \"Rust is awesome\"\n    expected.insert('r', 1);\n    expected.insert('u', 1);\n    expected.insert('s', 2);\n    expected.insert('t', 1);\n    expected.insert('i', 1);\n    expected.insert('a', 1);\n    expected.insert('w', 1);\n    expected.insert('e', 2);\n    expected.insert('o', 1);\n    expected.insert('m', 1);\n    assert_eq!(character_frequency(\"Rust is awesome\"), expected);\n    expected.clear();\n\n    // Test case 3: Empty string\n    assert_eq!(character_frequency(\"\"), HashMap::new());\n\n    // Test case 4: Spaces only\n    assert_eq!(character_frequency(\"   \"), HashMap::new());\n}", "all_code": "use std::collections::HashMap;\n\n/// Calculates the frequency of each character in a string, ignoring case and spaces.\n///\n/// # Arguments\n/// * `s` - The input string to analyze\n///\n/// # Returns\n/// A HashMap where keys are characters (in lowercase) and values are their counts\nfn character_frequency(s: &str) -> HashMap<char, usize> {\n    let mut frequency = HashMap::new();\n    \n    // Iterate through each character in the string (converted to lowercase)\n    for char in s.to_lowercase().chars() {\n        // Skip spaces\n        if char != ' ' {\n            // Increment the count for this character\n            *frequency.entry(char).or_insert(0) += 1;\n        }\n    }\n    \n    frequency\n}\n#[test]\nfn test_character_frequency() {\n    let mut expected = HashMap::new();\n    \n    // Test case 1: \"Hello World\"\n    expected.insert('h', 1);\n    expected.insert('e', 1);\n    expected.insert('l', 3);\n    expected.insert('o', 2);\n    expected.insert('w', 1);\n    expected.insert('r', 1);\n    expected.insert('d', 1);\n    assert_eq!(character_frequency(\"Hello World\"), expected);\n    expected.clear();\n\n    // Test case 2: \"Rust is awesome\"\n    expected.insert('r', 1);\n    expected.insert('u', 1);\n    expected.insert('s', 2);\n    expected.insert('t', 1);\n    expected.insert('i', 1);\n    expected.insert('a', 1);\n    expected.insert('w', 1);\n    expected.insert('e', 2);\n    expected.insert('o', 1);\n    expected.insert('m', 1);\n    assert_eq!(character_frequency(\"Rust is awesome\"), expected);\n    expected.clear();\n\n    // Test case 3: Empty string\n    assert_eq!(character_frequency(\"\"), HashMap::new());\n\n    // Test case 4: Spaces only\n    assert_eq!(character_frequency(\"   \"), HashMap::new());\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::cmp;\n\nfn largest_contiguous_residential_block(grid: &[Vec<char>]) -> usize {\n    // Finds the largest contiguous block of residential land ('R') in the grid.\n    //\n    // # Arguments\n    // * `grid` - A 2D vector representing the city map with characters\n    //\n    // # Returns\n    // The size of the largest contiguous residential block as usize\n\n    if grid.is_empty() || grid[0].is_empty() {\n        return 0;\n    }\n\n    let rows = grid.len();\n    let cols = grid[0].len();\n    let mut visited = vec![vec![false; cols]; rows];\n    let mut max_block_size = 0;\n\n    // Nested DFS function to explore contiguous blocks\n    fn dfs(r: usize, c: usize, grid: &[Vec<char>], visited: &mut Vec<Vec<bool>>) -> usize {\n        if r >= grid.len() || c >= grid[0].len() || visited[r][c] || grid[r][c] != 'R' {\n            return 0;\n        }\n        visited[r][c] = true;\n        let mut size = 1;\n\n        // Explore all four directions (with bounds checking)\n        if r > 0 {\n            size += dfs(r - 1, c, grid, visited);\n        }\n        if r < grid.len() - 1 {\n            size += dfs(r + 1, c, grid, visited);\n        }\n        if c > 0 {\n            size += dfs(r, c - 1, grid, visited);\n        }\n        if c < grid[0].len() - 1 {\n            size += dfs(r, c + 1, grid, visited);\n        }\n\n        size\n    }\n\n    for r in 0..rows {\n        for c in 0..cols {\n            if grid[r][c] == 'R' && !visited[r][c] {\n                let current_block_size = dfs(r, c, grid, &mut visited);\n                max_block_size = cmp::max(max_block_size, current_block_size);\n            }\n        }\n    }\n\n    max_block_size\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 2920, "assertions": "#[test]\nfn test_largest_contiguous_residential_block() {\n    // Test case 1: Simple 2x2 grid with one block\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'R'],\n            vec!['R', 'C'],\n        ]),\n        3\n    );\n\n    // Test case 2: Grid with multiple separate blocks\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'C', 'R'],\n            vec!['C', 'R', 'C'],\n            vec!['R', 'C', 'R'],\n        ]),\n        1\n    );\n\n    // Test case 3: Large contiguous block\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'R', 'R', 'C'],\n            vec!['R', 'C', 'R', 'C'],\n            vec!['R', 'R', 'R', 'C'],\n            vec!['C', 'C', 'C', 'C'],\n        ]),\n        7\n    );\n\n    // Test case 4: Empty grid\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![]),\n        0\n    );\n\n    // Test case 5: Grid with no residential areas\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['C', 'C'],\n            vec!['C', 'C'],\n        ]),\n        0\n    );\n}", "all_code": "use std::cmp;\n\nfn largest_contiguous_residential_block(grid: &[Vec<char>]) -> usize {\n    // Finds the largest contiguous block of residential land ('R') in the grid.\n    //\n    // # Arguments\n    // * `grid` - A 2D vector representing the city map with characters\n    //\n    // # Returns\n    // The size of the largest contiguous residential block as usize\n\n    if grid.is_empty() || grid[0].is_empty() {\n        return 0;\n    }\n\n    let rows = grid.len();\n    let cols = grid[0].len();\n    let mut visited = vec![vec![false; cols]; rows];\n    let mut max_block_size = 0;\n\n    // Nested DFS function to explore contiguous blocks\n    fn dfs(r: usize, c: usize, grid: &[Vec<char>], visited: &mut Vec<Vec<bool>>) -> usize {\n        if r >= grid.len() || c >= grid[0].len() || visited[r][c] || grid[r][c] != 'R' {\n            return 0;\n        }\n        visited[r][c] = true;\n        let mut size = 1;\n\n        // Explore all four directions (with bounds checking)\n        if r > 0 {\n            size += dfs(r - 1, c, grid, visited);\n        }\n        if r < grid.len() - 1 {\n            size += dfs(r + 1, c, grid, visited);\n        }\n        if c > 0 {\n            size += dfs(r, c - 1, grid, visited);\n        }\n        if c < grid[0].len() - 1 {\n            size += dfs(r, c + 1, grid, visited);\n        }\n\n        size\n    }\n\n    for r in 0..rows {\n        for c in 0..cols {\n            if grid[r][c] == 'R' && !visited[r][c] {\n                let current_block_size = dfs(r, c, grid, &mut visited);\n                max_block_size = cmp::max(max_block_size, current_block_size);\n            }\n        }\n    }\n\n    max_block_size\n}\n#[test]\nfn test_largest_contiguous_residential_block() {\n    // Test case 1: Simple 2x2 grid with one block\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'R'],\n            vec!['R', 'C'],\n        ]),\n        3\n    );\n\n    // Test case 2: Grid with multiple separate blocks\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'C', 'R'],\n            vec!['C', 'R', 'C'],\n            vec!['R', 'C', 'R'],\n        ]),\n        1\n    );\n\n    // Test case 3: Large contiguous block\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['R', 'R', 'R', 'C'],\n            vec!['R', 'C', 'R', 'C'],\n            vec!['R', 'R', 'R', 'C'],\n            vec!['C', 'C', 'C', 'C'],\n        ]),\n        7\n    );\n\n    // Test case 4: Empty grid\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![]),\n        0\n    );\n\n    // Test case 5: Grid with no residential areas\n    assert_eq!(\n        largest_contiguous_residential_block(&vec![\n            vec!['C', 'C'],\n            vec!['C', 'C'],\n        ]),\n        0\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn min_insertions_to_palindrome(s: &str) -> usize {\n    // Returns the minimum number of insertions required to make the string a palindrome.\n    // Uses dynamic programming approach with a 2D table to store intermediate results.\n    \n    let n = s.len();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Create a 2D vector for dynamic programming table\n    let mut dp = vec![vec![0; n]; n];\n    \n    // Fill the table for all substring lengths from 2 to n\n    for length in 2..=n {\n        for i in 0..=(n - length) {\n            let j = i + length - 1;\n            if s.chars().nth(i) == s.chars().nth(j) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::min(dp[i + 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n    \n    dp[0][n - 1]\n}\n\nfn process_cases(test_cases: &[&str]) -> Vec<usize> {\n    // Processes multiple test cases and returns a vector of results.\n    // Each result is the minimum insertions needed to make the corresponding string a palindrome.\n    \n    test_cases.iter().map(|s| min_insertions_to_palindrome(s)).collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 14038, "assertions": "#[test]\nfn test_palindrome_insertions() {\n    let test_strings = [\n        (\"ab\", 1),      // Needs 1 insertion (aba or bab)\n        (\"aa\", 0),      // Already palindrome (0)\n        (\"abcd\", 3),    // Needs 3 insertions\n        (\"abcda\", 2),   // Needs 2 insertions (adcda or acdca)\n        (\"abcde\", 4),   // Needs 4 insertions\n        (\"race\", 3),    // Needs 3 insertions (ecarace)\n        (\"abcb\", 1),    // Needs 1 insertion (abcba)\n        (\"\", 0),        // Empty string (0)\n        (\"a\", 0),       // Single character (0)\n    ];\n    \n    for &(s, expected) in &test_strings {\n        assert_eq!(min_insertions_to_palindrome(s), expected);\n    }\n    \n    let batch_results = process_cases(&test_strings.iter().map(|&(s, _)| s).collect::<Vec<_>>());\n    for (i, &(_, expected)) in test_strings.iter().enumerate() {\n        assert_eq!(batch_results[i], expected);\n    }\n}", "all_code": "fn min_insertions_to_palindrome(s: &str) -> usize {\n    // Returns the minimum number of insertions required to make the string a palindrome.\n    // Uses dynamic programming approach with a 2D table to store intermediate results.\n    \n    let n = s.len();\n    if n == 0 {\n        return 0;\n    }\n    \n    // Create a 2D vector for dynamic programming table\n    let mut dp = vec![vec![0; n]; n];\n    \n    // Fill the table for all substring lengths from 2 to n\n    for length in 2..=n {\n        for i in 0..=(n - length) {\n            let j = i + length - 1;\n            if s.chars().nth(i) == s.chars().nth(j) {\n                dp[i][j] = dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::min(dp[i + 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n    \n    dp[0][n - 1]\n}\n\nfn process_cases(test_cases: &[&str]) -> Vec<usize> {\n    // Processes multiple test cases and returns a vector of results.\n    // Each result is the minimum insertions needed to make the corresponding string a palindrome.\n    \n    test_cases.iter().map(|s| min_insertions_to_palindrome(s)).collect()\n}\n#[test]\nfn test_palindrome_insertions() {\n    let test_strings = [\n        (\"ab\", 1),      // Needs 1 insertion (aba or bab)\n        (\"aa\", 0),      // Already palindrome (0)\n        (\"abcd\", 3),    // Needs 3 insertions\n        (\"abcda\", 2),   // Needs 2 insertions (adcda or acdca)\n        (\"abcde\", 4),   // Needs 4 insertions\n        (\"race\", 3),    // Needs 3 insertions (ecarace)\n        (\"abcb\", 1),    // Needs 1 insertion (abcba)\n        (\"\", 0),        // Empty string (0)\n        (\"a\", 0),       // Single character (0)\n    ];\n    \n    for &(s, expected) in &test_strings {\n        assert_eq!(min_insertions_to_palindrome(s), expected);\n    }\n    \n    let batch_results = process_cases(&test_strings.iter().map(|&(s, _)| s).collect::<Vec<_>>());\n    for (i, &(_, expected)) in test_strings.iter().enumerate() {\n        assert_eq!(batch_results[i], expected);\n    }\n}", "exec_outcome": "PASSED"}
{"code": "// Function to calculate the nth term of an arithmetic sequence\n// The sequence starts with a first term of 2 and has a common difference of 3\n// The formula used is: nth_term = first_term + (n - 1) * common_difference\nfn nth_term_arithmetic_sequence(n: i32) -> i32 {\n    let first_term = 2;\n    let common_difference = 3;\n    first_term + (n - 1) * common_difference\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 1713, "assertions": "#[test]\nfn test_nth_term_arithmetic_sequence() {\n    assert_eq!(nth_term_arithmetic_sequence(1), 2);\n    assert_eq!(nth_term_arithmetic_sequence(2), 5);\n    assert_eq!(nth_term_arithmetic_sequence(5), 14);\n    assert_eq!(nth_term_arithmetic_sequence(10), 29);\n}", "all_code": "// Function to calculate the nth term of an arithmetic sequence\n// The sequence starts with a first term of 2 and has a common difference of 3\n// The formula used is: nth_term = first_term + (n - 1) * common_difference\nfn nth_term_arithmetic_sequence(n: i32) -> i32 {\n    let first_term = 2;\n    let common_difference = 3;\n    first_term + (n - 1) * common_difference\n}\n#[test]\nfn test_nth_term_arithmetic_sequence() {\n    assert_eq!(nth_term_arithmetic_sequence(1), 2);\n    assert_eq!(nth_term_arithmetic_sequence(2), 5);\n    assert_eq!(nth_term_arithmetic_sequence(5), 14);\n    assert_eq!(nth_term_arithmetic_sequence(10), 29);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to determine if a banner can perfectly fit a specific number of logos side by side\n// Parameters:\n// - banner_length: Total length of the banner in millimeters (u32 for unsigned integer)\n// - number_of_logos: Number of logos to fit on the banner (u32)\n// - logo_width: Width of each logo in millimeters (u32)\n// Returns:\n// - bool: True if the total length can exactly fit the given number of logos, otherwise False\nfn can_fit_logos(banner_length: u32, number_of_logos: u32, logo_width: u32) -> bool {\n    banner_length == number_of_logos * logo_width\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 8698, "assertions": "#[test]\nfn test_can_fit_logos() {\n    // Perfect fit: 5 * 20 = 100\n    assert_eq!(can_fit_logos(100, 5, 20), true);\n    // Perfect fit: 3 * 50 = 150\n    assert_eq!(can_fit_logos(150, 3, 50), true);\n    // Not a perfect fit: 7 * 30 = 210 != 200\n    assert_eq!(can_fit_logos(200, 7, 30), false);\n    // Edge case: 0 logos fit in a 0-length banner\n    assert_eq!(can_fit_logos(0, 0, 10), true);\n    // Single logo fits perfectly\n    assert_eq!(can_fit_logos(10, 1, 10), true);\n}", "all_code": "// Function to determine if a banner can perfectly fit a specific number of logos side by side\n// Parameters:\n// - banner_length: Total length of the banner in millimeters (u32 for unsigned integer)\n// - number_of_logos: Number of logos to fit on the banner (u32)\n// - logo_width: Width of each logo in millimeters (u32)\n// Returns:\n// - bool: True if the total length can exactly fit the given number of logos, otherwise False\nfn can_fit_logos(banner_length: u32, number_of_logos: u32, logo_width: u32) -> bool {\n    banner_length == number_of_logos * logo_width\n}\n#[test]\nfn test_can_fit_logos() {\n    // Perfect fit: 5 * 20 = 100\n    assert_eq!(can_fit_logos(100, 5, 20), true);\n    // Perfect fit: 3 * 50 = 150\n    assert_eq!(can_fit_logos(150, 3, 50), true);\n    // Not a perfect fit: 7 * 30 = 210 != 200\n    assert_eq!(can_fit_logos(200, 7, 30), false);\n    // Edge case: 0 logos fit in a 0-length banner\n    assert_eq!(can_fit_logos(0, 0, 10), true);\n    // Single logo fits perfectly\n    assert_eq!(can_fit_logos(10, 1, 10), true);\n}", "exec_outcome": "PASSED"}
{"code": "fn pixel_forth(commands: &str) -> Vec<Vec<u8>> {\n    // Initialize a 10x10 grid with all zeros\n    let mut grid = vec![vec![0; 10]; 10];\n    let mut cursor_x: usize = 0;\n    let mut cursor_y: usize = 0;\n    let mut i = 0;\n    let commands: Vec<char> = commands.chars().collect();\n\n    while i < commands.len() {\n        let command = commands[i];\n        match command {\n            '>' => cursor_y = (cursor_y + 1) % 10,\n            '<' => cursor_y = (cursor_y as isize - 1).rem_euclid(10) as usize,\n            '^' => cursor_x = (cursor_x as isize - 1).rem_euclid(10) as usize,\n            'v' => cursor_x = (cursor_x + 1) % 10,\n            'X' => grid[cursor_x][cursor_y] = 1 - grid[cursor_x][cursor_y],\n            'O' => grid[cursor_x][cursor_y] = 1,\n            'F' => grid[cursor_x][cursor_y] = 0,\n            '[' => {\n                if grid[cursor_x][cursor_y] == 0 {\n                    let mut open_brackets = 1;\n                    while open_brackets > 0 {\n                        i += 1;\n                        match commands[i] {\n                            '[' => open_brackets += 1,\n                            ']' => open_brackets -= 1,\n                            _ => (),\n                        }\n                    }\n                }\n            }\n            ']' => {\n                if grid[cursor_x][cursor_y] == 1 {\n                    let mut closed_brackets = 1;\n                    while closed_brackets > 0 {\n                        i -= 1;\n                        match commands[i] {\n                            ']' => closed_brackets += 1,\n                            '[' => closed_brackets -= 1,\n                            _ => (),\n                        }\n                    }\n                }\n            }\n            '!' => {\n                grid = grid\n                    .iter()\n                    .map(|row| row.iter().map(|&cell| 1 - cell).collect())\n                    .collect();\n            }\n            'P' => {\n                // Print the grid\n                for row in &grid {\n                    println!(\n                        \"{}\",\n                        row.iter()\n                            .map(|&cell| cell.to_string())\n                            .collect::<Vec<String>>()\n                            .join(\" \")\n                    );\n                }\n            }\n            _ => (),\n        }\n        i += 1;\n    }\n\n    grid\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 18367, "assertions": "#[test]\nfn test_pixel_forth() {\n    // Test case 1: Simple right movement and toggle\n    assert_eq!(\n        pixel_forth(\">>>>X\"),\n        vec![\n            vec![0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 2: Movement in all directions with toggles\n    assert_eq!(\n        pixel_forth(\"vX<X^X\"),\n        vec![\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 3: Conditional loop\n    assert_eq!(\n        pixel_forth(\"O[>X]F\"),\n        vec![\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 4: Invert and print\n    assert_eq!(\n        pixel_forth(\"!\"),\n        vec![\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        ]\n    );\n}", "all_code": "fn pixel_forth(commands: &str) -> Vec<Vec<u8>> {\n    // Initialize a 10x10 grid with all zeros\n    let mut grid = vec![vec![0; 10]; 10];\n    let mut cursor_x: usize = 0;\n    let mut cursor_y: usize = 0;\n    let mut i = 0;\n    let commands: Vec<char> = commands.chars().collect();\n\n    while i < commands.len() {\n        let command = commands[i];\n        match command {\n            '>' => cursor_y = (cursor_y + 1) % 10,\n            '<' => cursor_y = (cursor_y as isize - 1).rem_euclid(10) as usize,\n            '^' => cursor_x = (cursor_x as isize - 1).rem_euclid(10) as usize,\n            'v' => cursor_x = (cursor_x + 1) % 10,\n            'X' => grid[cursor_x][cursor_y] = 1 - grid[cursor_x][cursor_y],\n            'O' => grid[cursor_x][cursor_y] = 1,\n            'F' => grid[cursor_x][cursor_y] = 0,\n            '[' => {\n                if grid[cursor_x][cursor_y] == 0 {\n                    let mut open_brackets = 1;\n                    while open_brackets > 0 {\n                        i += 1;\n                        match commands[i] {\n                            '[' => open_brackets += 1,\n                            ']' => open_brackets -= 1,\n                            _ => (),\n                        }\n                    }\n                }\n            }\n            ']' => {\n                if grid[cursor_x][cursor_y] == 1 {\n                    let mut closed_brackets = 1;\n                    while closed_brackets > 0 {\n                        i -= 1;\n                        match commands[i] {\n                            ']' => closed_brackets += 1,\n                            '[' => closed_brackets -= 1,\n                            _ => (),\n                        }\n                    }\n                }\n            }\n            '!' => {\n                grid = grid\n                    .iter()\n                    .map(|row| row.iter().map(|&cell| 1 - cell).collect())\n                    .collect();\n            }\n            'P' => {\n                // Print the grid\n                for row in &grid {\n                    println!(\n                        \"{}\",\n                        row.iter()\n                            .map(|&cell| cell.to_string())\n                            .collect::<Vec<String>>()\n                            .join(\" \")\n                    );\n                }\n            }\n            _ => (),\n        }\n        i += 1;\n    }\n\n    grid\n}\n#[test]\nfn test_pixel_forth() {\n    // Test case 1: Simple right movement and toggle\n    assert_eq!(\n        pixel_forth(\">>>>X\"),\n        vec![\n            vec![0, 0, 0, 0, 1, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 2: Movement in all directions with toggles\n    assert_eq!(\n        pixel_forth(\"vX<X^X\"),\n        vec![\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 3: Conditional loop\n    assert_eq!(\n        pixel_forth(\"O[>X]F\"),\n        vec![\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        ]\n    );\n\n    // Test case 4: Invert and print\n    assert_eq!(\n        pixel_forth(\"!\"),\n        vec![\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        ]\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn max_knapsack(weight_limit: usize, weights: &[usize], values: &[usize]) -> usize {\n    // Function to find the maximum value of items fitting within the given weight limit\n    // using dynamic programming approach.\n    //\n    // Args:\n    // weight_limit: Maximum weight capacity of the knapsack\n    // weights: Slice of weights of the items\n    // values: Slice of values of the items\n    //\n    // Returns:\n    // Maximum value that can be achieved within the given weight limit\n\n    // Initialize a DP array where dp[w] represents the maximum value achievable with weight 'w'\n    let mut dp = vec![0; weight_limit + 1];\n    \n    // Iterate through each item\n    for i in 0..values.len() {\n        // Iterate from the weight limit down to the current item's weight\n        for w in (weights[i]..=weight_limit).rev() {\n            // Update the DP array by either keeping the current value or adding the current item\n            dp[w] = dp[w].max(dp[w - weights[i]] + values[i]);\n        }\n    }\n    \n    // The last element of DP array contains the maximum value for the given weight limit\n    dp[weight_limit]\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 18242, "assertions": "#[test]\nfn test_max_knapsack() {\n    // Test case 1: Simple case with 3 items\n    assert_eq!(max_knapsack(5, &[1, 2, 3], &[6, 10, 12]), 22);\n\n    // Test case 2: All items can be taken\n    assert_eq!(max_knapsack(10, &[2, 3, 4], &[5, 6, 7]), 18);\n\n    // Test case 3: Only one item can be taken\n    assert_eq!(max_knapsack(3, &[4, 5, 6], &[1, 2, 3]), 0);\n\n    // Test case 4: Edge case with zero weight limit\n    assert_eq!(max_knapsack(0, &[1, 2, 3], &[4, 5, 6]), 0);\n\n    // Test case 5: Multiple items with same weight but different values\n    assert_eq!(max_knapsack(7, &[2, 2, 3, 3], &[5, 6, 7, 8]), 21);\n}", "all_code": "fn max_knapsack(weight_limit: usize, weights: &[usize], values: &[usize]) -> usize {\n    // Function to find the maximum value of items fitting within the given weight limit\n    // using dynamic programming approach.\n    //\n    // Args:\n    // weight_limit: Maximum weight capacity of the knapsack\n    // weights: Slice of weights of the items\n    // values: Slice of values of the items\n    //\n    // Returns:\n    // Maximum value that can be achieved within the given weight limit\n\n    // Initialize a DP array where dp[w] represents the maximum value achievable with weight 'w'\n    let mut dp = vec![0; weight_limit + 1];\n    \n    // Iterate through each item\n    for i in 0..values.len() {\n        // Iterate from the weight limit down to the current item's weight\n        for w in (weights[i]..=weight_limit).rev() {\n            // Update the DP array by either keeping the current value or adding the current item\n            dp[w] = dp[w].max(dp[w - weights[i]] + values[i]);\n        }\n    }\n    \n    // The last element of DP array contains the maximum value for the given weight limit\n    dp[weight_limit]\n}\n#[test]\nfn test_max_knapsack() {\n    // Test case 1: Simple case with 3 items\n    assert_eq!(max_knapsack(5, &[1, 2, 3], &[6, 10, 12]), 22);\n\n    // Test case 2: All items can be taken\n    assert_eq!(max_knapsack(10, &[2, 3, 4], &[5, 6, 7]), 18);\n\n    // Test case 3: Only one item can be taken\n    assert_eq!(max_knapsack(3, &[4, 5, 6], &[1, 2, 3]), 0);\n\n    // Test case 4: Edge case with zero weight limit\n    assert_eq!(max_knapsack(0, &[1, 2, 3], &[4, 5, 6]), 0);\n\n    // Test case 5: Multiple items with same weight but different values\n    assert_eq!(max_knapsack(7, &[2, 2, 3, 3], &[5, 6, 7, 8]), 21);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::cmp::Ordering;\n\n// Represents a graph edge with source, destination, and weight\n#[derive(Debug, Clone, Copy)]\nstruct Edge {\n    source: usize,\n    destination: usize,\n    weight: i32,\n}\n\nimpl Edge {\n    fn new(source: usize, destination: usize, weight: i32) -> Self {\n        Edge {\n            source,\n            destination,\n            weight,\n        }\n    }\n}\n\n// Implement ordering for Edge based on weight for sorting\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.weight.cmp(&other.weight))\n    }\n}\n\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.weight.cmp(&other.weight)\n    }\n}\n\nimpl PartialEq for Edge {\n    fn eq(&self, other: &Self) -> bool {\n        self.weight == other.weight\n    }\n}\n\nimpl Eq for Edge {}\n\n// Union-Find (Disjoint Set Union) data structure for Kruskal's algorithm\nstruct UnionFind {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl UnionFind {\n    fn new(size: usize) -> Self {\n        UnionFind {\n            parent: (0..size).collect(),\n            rank: vec![0; size],\n        }\n    }\n\n    // Find with path compression\n    fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] != x {\n            self.parent[x] = self.find(self.parent[x]);\n        }\n        self.parent[x]\n    }\n\n    // Union by rank\n    fn union(&mut self, x: usize, y: usize) {\n        let root_x = self.find(x);\n        let root_y = self.find(y);\n        \n        if root_x != root_y {\n            match self.rank[root_x].cmp(&self.rank[root_y]) {\n                Ordering::Less => self.parent[root_x] = root_y,\n                Ordering::Greater => self.parent[root_y] = root_x,\n                Ordering::Equal => {\n                    self.parent[root_y] = root_x;\n                    self.rank[root_x] += 1;\n                }\n            }\n        }\n    }\n}\n\n// Computes the weight sum of the edges in the minimum spanning tree\nfn minimum_spanning_tree(vertices: usize, edges: &mut Vec<Edge>) -> i32 {\n    // Sort edges by weight in ascending order\n    edges.sort();\n    \n    let mut uf = UnionFind::new(vertices + 1); // +1 because vertices are 1-based in the problem\n    let mut mst_weight = 0;\n    let mut edges_in_mst = 0;\n    \n    for &edge in edges.iter() {\n        if uf.find(edge.source) != uf.find(edge.destination) {\n            uf.union(edge.source, edge.destination);\n            mst_weight += edge.weight;\n            edges_in_mst += 1;\n            \n            // A tree with n vertices has n-1 edges\n            if edges_in_mst == vertices - 1 {\n                break;\n            }\n        }\n    }\n    \n    mst_weight\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 4564, "assertions": "#[test]\nfn test_minimum_spanning_tree() {\n    // Test case 1: Simple graph with 3 vertices and 3 edges\n    let mut edges1 = vec![\n        Edge::new(1, 2, 1),\n        Edge::new(2, 3, 2),\n        Edge::new(1, 3, 3),\n    ];\n    assert_eq!(minimum_spanning_tree(3, &mut edges1), 3);\n\n    // Test case 2: Graph with 4 vertices and 5 edges\n    let mut edges2 = vec![\n        Edge::new(1, 2, 4),\n        Edge::new(1, 3, 1),\n        Edge::new(2, 3, 2),\n        Edge::new(2, 4, 3),\n        Edge::new(3, 4, 5),\n    ];\n    assert_eq!(minimum_spanning_tree(4, &mut edges2), 6);\n\n    // Test case 3: Graph with single edge\n    let mut edges3 = vec![Edge::new(1, 2, 10)];\n    assert_eq!(minimum_spanning_tree(2, &mut edges3), 10);\n\n    // Test case 4: Disconnected graph (should return MST for connected component)\n    let mut edges4 = vec![\n        Edge::new(1, 2, 5),\n        Edge::new(3, 4, 7),\n    ];\n    assert_eq!(minimum_spanning_tree(4, &mut edges4), 12);\n}", "all_code": "use std::cmp::Ordering;\n\n// Represents a graph edge with source, destination, and weight\n#[derive(Debug, Clone, Copy)]\nstruct Edge {\n    source: usize,\n    destination: usize,\n    weight: i32,\n}\n\nimpl Edge {\n    fn new(source: usize, destination: usize, weight: i32) -> Self {\n        Edge {\n            source,\n            destination,\n            weight,\n        }\n    }\n}\n\n// Implement ordering for Edge based on weight for sorting\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.weight.cmp(&other.weight))\n    }\n}\n\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.weight.cmp(&other.weight)\n    }\n}\n\nimpl PartialEq for Edge {\n    fn eq(&self, other: &Self) -> bool {\n        self.weight == other.weight\n    }\n}\n\nimpl Eq for Edge {}\n\n// Union-Find (Disjoint Set Union) data structure for Kruskal's algorithm\nstruct UnionFind {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl UnionFind {\n    fn new(size: usize) -> Self {\n        UnionFind {\n            parent: (0..size).collect(),\n            rank: vec![0; size],\n        }\n    }\n\n    // Find with path compression\n    fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] != x {\n            self.parent[x] = self.find(self.parent[x]);\n        }\n        self.parent[x]\n    }\n\n    // Union by rank\n    fn union(&mut self, x: usize, y: usize) {\n        let root_x = self.find(x);\n        let root_y = self.find(y);\n        \n        if root_x != root_y {\n            match self.rank[root_x].cmp(&self.rank[root_y]) {\n                Ordering::Less => self.parent[root_x] = root_y,\n                Ordering::Greater => self.parent[root_y] = root_x,\n                Ordering::Equal => {\n                    self.parent[root_y] = root_x;\n                    self.rank[root_x] += 1;\n                }\n            }\n        }\n    }\n}\n\n// Computes the weight sum of the edges in the minimum spanning tree\nfn minimum_spanning_tree(vertices: usize, edges: &mut Vec<Edge>) -> i32 {\n    // Sort edges by weight in ascending order\n    edges.sort();\n    \n    let mut uf = UnionFind::new(vertices + 1); // +1 because vertices are 1-based in the problem\n    let mut mst_weight = 0;\n    let mut edges_in_mst = 0;\n    \n    for &edge in edges.iter() {\n        if uf.find(edge.source) != uf.find(edge.destination) {\n            uf.union(edge.source, edge.destination);\n            mst_weight += edge.weight;\n            edges_in_mst += 1;\n            \n            // A tree with n vertices has n-1 edges\n            if edges_in_mst == vertices - 1 {\n                break;\n            }\n        }\n    }\n    \n    mst_weight\n}\n#[test]\nfn test_minimum_spanning_tree() {\n    // Test case 1: Simple graph with 3 vertices and 3 edges\n    let mut edges1 = vec![\n        Edge::new(1, 2, 1),\n        Edge::new(2, 3, 2),\n        Edge::new(1, 3, 3),\n    ];\n    assert_eq!(minimum_spanning_tree(3, &mut edges1), 3);\n\n    // Test case 2: Graph with 4 vertices and 5 edges\n    let mut edges2 = vec![\n        Edge::new(1, 2, 4),\n        Edge::new(1, 3, 1),\n        Edge::new(2, 3, 2),\n        Edge::new(2, 4, 3),\n        Edge::new(3, 4, 5),\n    ];\n    assert_eq!(minimum_spanning_tree(4, &mut edges2), 6);\n\n    // Test case 3: Graph with single edge\n    let mut edges3 = vec![Edge::new(1, 2, 10)];\n    assert_eq!(minimum_spanning_tree(2, &mut edges3), 10);\n\n    // Test case 4: Disconnected graph (should return MST for connected component)\n    let mut edges4 = vec![\n        Edge::new(1, 2, 5),\n        Edge::new(3, 4, 7),\n    ];\n    assert_eq!(minimum_spanning_tree(4, &mut edges4), 12);\n}", "exec_outcome": "PASSED"}
{"code": "/// Determines whether all given rectangular pieces can fit on a board of specified dimensions\n/// based solely on total area comparison (does not account for actual piece arrangement).\n///\n/// # Arguments\n/// * `board_width` - Width of the board\n/// * `board_height` - Height of the board\n/// * `pieces` - Vector of tuples representing piece dimensions (width, height)\n///\n/// # Returns\n/// \"YES\" if the total area of pieces is less than or equal to the board area, \"NO\" otherwise\nfn can_place_all_pieces(board_width: u32, board_height: u32, pieces: &[(u32, u32)]) -> &'static str {\n    // Calculate total area of all pieces\n    let total_piece_area: u32 = pieces.iter().map(|(w, h)| w * h).sum();\n    \n    // Calculate board area\n    let board_area = board_width * board_height;\n    \n    // Compare areas\n    if total_piece_area <= board_area {\n        \"YES\"\n    } else {\n        \"NO\"\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 2263, "assertions": "#[test]\nfn test_can_place_all_pieces() {\n    assert_eq!(can_place_all_pieces(10, 10, &[(2, 3), (4, 5), (1, 1)]), \"YES\");\n    assert_eq!(can_place_all_pieces(5, 5, &[(6, 1), (1, 6)]), \"NO\");\n    assert_eq!(can_place_all_pieces(8, 4, &[(4, 4), (4, 4)]), \"YES\");\n    assert_eq!(can_place_all_pieces(3, 3, &[(1, 1); 10]), \"NO\");\n    assert_eq!(can_place_all_pieces(100, 1, &[(1, 100), (1, 1)]), \"NO\");\n}", "all_code": "/// Determines whether all given rectangular pieces can fit on a board of specified dimensions\n/// based solely on total area comparison (does not account for actual piece arrangement).\n///\n/// # Arguments\n/// * `board_width` - Width of the board\n/// * `board_height` - Height of the board\n/// * `pieces` - Vector of tuples representing piece dimensions (width, height)\n///\n/// # Returns\n/// \"YES\" if the total area of pieces is less than or equal to the board area, \"NO\" otherwise\nfn can_place_all_pieces(board_width: u32, board_height: u32, pieces: &[(u32, u32)]) -> &'static str {\n    // Calculate total area of all pieces\n    let total_piece_area: u32 = pieces.iter().map(|(w, h)| w * h).sum();\n    \n    // Calculate board area\n    let board_area = board_width * board_height;\n    \n    // Compare areas\n    if total_piece_area <= board_area {\n        \"YES\"\n    } else {\n        \"NO\"\n    }\n}\n#[test]\nfn test_can_place_all_pieces() {\n    assert_eq!(can_place_all_pieces(10, 10, &[(2, 3), (4, 5), (1, 1)]), \"YES\");\n    assert_eq!(can_place_all_pieces(5, 5, &[(6, 1), (1, 6)]), \"NO\");\n    assert_eq!(can_place_all_pieces(8, 4, &[(4, 4), (4, 4)]), \"YES\");\n    assert_eq!(can_place_all_pieces(3, 3, &[(1, 1); 10]), \"NO\");\n    assert_eq!(can_place_all_pieces(100, 1, &[(1, 100), (1, 1)]), \"NO\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn calculate_subarray_averages(data: &[i32], k: usize) -> Vec<f64> {\n    // Calculates the average of every contiguous subarray of length k in the given data slice.\n    //\n    // Parameters:\n    // data: Slice of integers\n    // k: Length of subarray\n    //\n    // Returns:\n    // A vector of averages of each contiguous subarray of length k\n    let n = data.len();\n    if n == 0 || k > n {\n        return Vec::new();\n    }\n\n    let mut subarray_averages = Vec::with_capacity(n - k + 1);\n    let mut current_sum: i32 = data[..k].iter().sum();\n    subarray_averages.push(current_sum as f64 / k as f64);\n\n    for i in k..n {\n        current_sum += data[i] - data[i - k];\n        subarray_averages.push(current_sum as f64 / k as f64);\n    }\n\n    subarray_averages\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 8049, "assertions": "#[test]\nfn test_calculate_subarray_averages() {\n    assert_eq!(\n        calculate_subarray_averages(&[1, 3, 2, 6, -1, 4, 1, 8, 2], 5),\n        vec![2.2, 2.8, 2.4, 3.6, 2.8]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[1, 2, 3, 4, 5], 2),\n        vec![1.5, 2.5, 3.5, 4.5]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[10, 20, 30, 40], 4),\n        vec![25.0]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[5], 1),\n        vec![5.0]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[], 3),\n        vec![]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[1, 2, 3], 5),\n        vec![]\n    );\n}", "all_code": "fn calculate_subarray_averages(data: &[i32], k: usize) -> Vec<f64> {\n    // Calculates the average of every contiguous subarray of length k in the given data slice.\n    //\n    // Parameters:\n    // data: Slice of integers\n    // k: Length of subarray\n    //\n    // Returns:\n    // A vector of averages of each contiguous subarray of length k\n    let n = data.len();\n    if n == 0 || k > n {\n        return Vec::new();\n    }\n\n    let mut subarray_averages = Vec::with_capacity(n - k + 1);\n    let mut current_sum: i32 = data[..k].iter().sum();\n    subarray_averages.push(current_sum as f64 / k as f64);\n\n    for i in k..n {\n        current_sum += data[i] - data[i - k];\n        subarray_averages.push(current_sum as f64 / k as f64);\n    }\n\n    subarray_averages\n}\n#[test]\nfn test_calculate_subarray_averages() {\n    assert_eq!(\n        calculate_subarray_averages(&[1, 3, 2, 6, -1, 4, 1, 8, 2], 5),\n        vec![2.2, 2.8, 2.4, 3.6, 2.8]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[1, 2, 3, 4, 5], 2),\n        vec![1.5, 2.5, 3.5, 4.5]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[10, 20, 30, 40], 4),\n        vec![25.0]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[5], 1),\n        vec![5.0]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[], 3),\n        vec![]\n    );\n    assert_eq!(\n        calculate_subarray_averages(&[1, 2, 3], 5),\n        vec![]\n    );\n}", "exec_outcome": "PASSED"}
{"code": "// Disjoint Set Union (DSU) implementation for Kruskal's algorithm\nstruct DSU {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl DSU {\n    // Create a new DSU with n elements (0..n-1)\n    fn new(n: usize) -> Self {\n        DSU {\n            parent: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n\n    // Find the root of the set containing element i\n    fn find(&mut self, i: usize) -> usize {\n        if self.parent[i] != i {\n            self.parent[i] = self.find(self.parent[i]);\n        }\n        self.parent[i]\n    }\n\n    // Union the sets containing elements x and y\n    fn union(&mut self, x: usize, y: usize) {\n        let root_x = self.find(x);\n        let root_y = self.find(y);\n\n        if root_x != root_y {\n            if self.rank[root_x] > self.rank[root_y] {\n                self.parent[root_y] = root_x;\n            } else if self.rank[root_x] < self.rank[root_y] {\n                self.parent[root_x] = root_y;\n            } else {\n                self.parent[root_y] = root_x;\n                self.rank[root_x] += 1;\n            }\n        }\n    }\n}\n\n// Calculate the minimum spanning tree cost using Kruskal's algorithm\nfn minimum_spanning_tree(n: usize, edges: &mut Vec<(usize, usize, i32)>) -> i32 {\n    // Sort edges by their weight in ascending order\n    edges.sort_by_key(|&(_, _, cost)| cost);\n\n    let mut dsu = DSU::new(n);\n    let mut mst_cost = 0;\n    let mut mst_edges = 0;\n\n    for &(u, v, cost) in edges.iter() {\n        if mst_edges == n - 1 {\n            break;\n        }\n\n        let root_u = dsu.find(u);\n        let root_v = dsu.find(v);\n\n        if root_u != root_v {\n            mst_cost += cost;\n            mst_edges += 1;\n            dsu.union(root_u, root_v);\n        }\n    }\n\n    mst_cost\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 12239, "assertions": "#[test]\nfn test_minimum_spanning_tree() {\n    // Test case 1: Simple graph with 3 nodes and 3 edges\n    let n1 = 3;\n    let mut edges1 = vec![\n        (0, 1, 1),\n        (1, 2, 2),\n        (0, 2, 3),\n    ];\n    assert_eq!(minimum_spanning_tree(n1, &mut edges1), 3);\n\n    // Test case 2: Graph with 4 nodes and 5 edges\n    let n2 = 4;\n    let mut edges2 = vec![\n        (0, 1, 10),\n        (0, 2, 6),\n        (0, 3, 5),\n        (1, 3, 15),\n        (2, 3, 4),\n    ];\n    assert_eq!(minimum_spanning_tree(n2, &mut edges2), 19);\n\n    // Test case 3: Single node graph (should return 0)\n    let n3 = 1;\n    let mut edges3 = vec![];\n    assert_eq!(minimum_spanning_tree(n3, &mut edges3), 0);\n\n    // Test case 4: Disconnected graph (should return cost of connected components)\n    let n4 = 4;\n    let mut edges4 = vec![\n        (0, 1, 1),\n        (2, 3, 2),\n    ];\n    assert_eq!(minimum_spanning_tree(n4, &mut edges4), 3);\n}", "all_code": "// Disjoint Set Union (DSU) implementation for Kruskal's algorithm\nstruct DSU {\n    parent: Vec<usize>,\n    rank: Vec<usize>,\n}\n\nimpl DSU {\n    // Create a new DSU with n elements (0..n-1)\n    fn new(n: usize) -> Self {\n        DSU {\n            parent: (0..n).collect(),\n            rank: vec![0; n],\n        }\n    }\n\n    // Find the root of the set containing element i\n    fn find(&mut self, i: usize) -> usize {\n        if self.parent[i] != i {\n            self.parent[i] = self.find(self.parent[i]);\n        }\n        self.parent[i]\n    }\n\n    // Union the sets containing elements x and y\n    fn union(&mut self, x: usize, y: usize) {\n        let root_x = self.find(x);\n        let root_y = self.find(y);\n\n        if root_x != root_y {\n            if self.rank[root_x] > self.rank[root_y] {\n                self.parent[root_y] = root_x;\n            } else if self.rank[root_x] < self.rank[root_y] {\n                self.parent[root_x] = root_y;\n            } else {\n                self.parent[root_y] = root_x;\n                self.rank[root_x] += 1;\n            }\n        }\n    }\n}\n\n// Calculate the minimum spanning tree cost using Kruskal's algorithm\nfn minimum_spanning_tree(n: usize, edges: &mut Vec<(usize, usize, i32)>) -> i32 {\n    // Sort edges by their weight in ascending order\n    edges.sort_by_key(|&(_, _, cost)| cost);\n\n    let mut dsu = DSU::new(n);\n    let mut mst_cost = 0;\n    let mut mst_edges = 0;\n\n    for &(u, v, cost) in edges.iter() {\n        if mst_edges == n - 1 {\n            break;\n        }\n\n        let root_u = dsu.find(u);\n        let root_v = dsu.find(v);\n\n        if root_u != root_v {\n            mst_cost += cost;\n            mst_edges += 1;\n            dsu.union(root_u, root_v);\n        }\n    }\n\n    mst_cost\n}\n#[test]\nfn test_minimum_spanning_tree() {\n    // Test case 1: Simple graph with 3 nodes and 3 edges\n    let n1 = 3;\n    let mut edges1 = vec![\n        (0, 1, 1),\n        (1, 2, 2),\n        (0, 2, 3),\n    ];\n    assert_eq!(minimum_spanning_tree(n1, &mut edges1), 3);\n\n    // Test case 2: Graph with 4 nodes and 5 edges\n    let n2 = 4;\n    let mut edges2 = vec![\n        (0, 1, 10),\n        (0, 2, 6),\n        (0, 3, 5),\n        (1, 3, 15),\n        (2, 3, 4),\n    ];\n    assert_eq!(minimum_spanning_tree(n2, &mut edges2), 19);\n\n    // Test case 3: Single node graph (should return 0)\n    let n3 = 1;\n    let mut edges3 = vec![];\n    assert_eq!(minimum_spanning_tree(n3, &mut edges3), 0);\n\n    // Test case 4: Disconnected graph (should return cost of connected components)\n    let n4 = 4;\n    let mut edges4 = vec![\n        (0, 1, 1),\n        (2, 3, 2),\n    ];\n    assert_eq!(minimum_spanning_tree(n4, &mut edges4), 3);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to check if a matrix is symmetric\nfn is_symmetric(matrix: &[Vec<i32>]) -> &'static str {\n    // Get the size of the matrix (n x n)\n    let n = matrix.len();\n    \n    // Check each element against its transposed counterpart\n    for i in 0..n {\n        for j in i..n {\n            if matrix[i][j] != matrix[j][i] {\n                return \"NO\";\n            }\n        }\n    }\n    \"YES\"\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 5911, "assertions": "#[test]\nfn test_is_symmetric() {\n    // Test case 1: Symmetric 3x3 matrix\n    let matrix1 = vec![\n        vec![1, 2, 3],\n        vec![2, 4, 5],\n        vec![3, 5, 6],\n    ];\n    assert_eq!(is_symmetric(&matrix1), \"YES\");\n\n    // Test case 2: Non-symmetric 2x2 matrix\n    let matrix2 = vec![\n        vec![1, 2],\n        vec![3, 4],\n    ];\n    assert_eq!(is_symmetric(&matrix2), \"NO\");\n\n    // Test case 3: Symmetric 1x1 matrix\n    let matrix3 = vec![\n        vec![5],\n    ];\n    assert_eq!(is_symmetric(&matrix3), \"YES\");\n\n    // Test case 4: Symmetric 4x4 matrix with negative numbers\n    let matrix4 = vec![\n        vec![1, -2, 3, 4],\n        vec![-2, 5, 6, 7],\n        vec![3, 6, 8, 9],\n        vec![4, 7, 9, 10],\n    ];\n    assert_eq!(is_symmetric(&matrix4), \"YES\");\n\n    // Test case 5: Non-symmetric 3x3 matrix\n    let matrix5 = vec![\n        vec![1, 0, 0],\n        vec![0, 1, 0],\n        vec![1, 0, 1],\n    ];\n    assert_eq!(is_symmetric(&matrix5), \"NO\");\n}", "all_code": "// Function to check if a matrix is symmetric\nfn is_symmetric(matrix: &[Vec<i32>]) -> &'static str {\n    // Get the size of the matrix (n x n)\n    let n = matrix.len();\n    \n    // Check each element against its transposed counterpart\n    for i in 0..n {\n        for j in i..n {\n            if matrix[i][j] != matrix[j][i] {\n                return \"NO\";\n            }\n        }\n    }\n    \"YES\"\n}\n#[test]\nfn test_is_symmetric() {\n    // Test case 1: Symmetric 3x3 matrix\n    let matrix1 = vec![\n        vec![1, 2, 3],\n        vec![2, 4, 5],\n        vec![3, 5, 6],\n    ];\n    assert_eq!(is_symmetric(&matrix1), \"YES\");\n\n    // Test case 2: Non-symmetric 2x2 matrix\n    let matrix2 = vec![\n        vec![1, 2],\n        vec![3, 4],\n    ];\n    assert_eq!(is_symmetric(&matrix2), \"NO\");\n\n    // Test case 3: Symmetric 1x1 matrix\n    let matrix3 = vec![\n        vec![5],\n    ];\n    assert_eq!(is_symmetric(&matrix3), \"YES\");\n\n    // Test case 4: Symmetric 4x4 matrix with negative numbers\n    let matrix4 = vec![\n        vec![1, -2, 3, 4],\n        vec![-2, 5, 6, 7],\n        vec![3, 6, 8, 9],\n        vec![4, 7, 9, 10],\n    ];\n    assert_eq!(is_symmetric(&matrix4), \"YES\");\n\n    // Test case 5: Non-symmetric 3x3 matrix\n    let matrix5 = vec![\n        vec![1, 0, 0],\n        vec![0, 1, 0],\n        vec![1, 0, 1],\n    ];\n    assert_eq!(is_symmetric(&matrix5), \"NO\");\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashSet;\n\n/// Calculates the number of valid Scrabble words that can be formed using exactly `k` characters\n/// from a given set of `n` distinct characters. This is computed as the number of permutations\n/// of `k` characters from the set of `n` characters, which is `n! / (n - k)!`.\n///\n/// # Arguments\n/// * `n` - The number of distinct characters.\n/// * `characters` - A string slice containing the distinct characters.\n/// * `k` - The length of the words to form.\n///\n/// # Returns\n/// * `i32` - The number of valid Scrabble words, or 0 if `k` exceeds `n`.\nfn count_scrabble_words(n: usize, characters: &str, k: usize) -> i32 {\n    // First, validate that all characters are distinct and the length matches `n`\n    let unique_chars: HashSet<char> = characters.chars().collect();\n    if unique_chars.len() != n {\n        return 0;\n    }\n\n    if k > n {\n        return 0;\n    }\n\n    // Calculate the permutation: n! / (n - k)!\n    let numerator: i32 = (1..=n).product::<usize>() as i32;\n    let denominator: i32 = (1..=(n - k)).product::<usize>() as i32;\n    numerator / denominator\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 19691, "assertions": "#[test]\nfn test_count_scrabble_words() {\n    // Valid cases\n    assert_eq!(count_scrabble_words(3, \"abc\", 2), 6);\n    assert_eq!(count_scrabble_words(4, \"abcd\", 3), 24);\n    assert_eq!(count_scrabble_words(5, \"abcde\", 5), 120);\n    \n    // Invalid cases\n    assert_eq!(count_scrabble_words(2, \"aab\", 1), 0);  // Characters not distinct\n    assert_eq!(count_scrabble_words(3, \"xyz\", 4), 0);  // k > n\n}", "all_code": "use std::collections::HashSet;\n\n/// Calculates the number of valid Scrabble words that can be formed using exactly `k` characters\n/// from a given set of `n` distinct characters. This is computed as the number of permutations\n/// of `k` characters from the set of `n` characters, which is `n! / (n - k)!`.\n///\n/// # Arguments\n/// * `n` - The number of distinct characters.\n/// * `characters` - A string slice containing the distinct characters.\n/// * `k` - The length of the words to form.\n///\n/// # Returns\n/// * `i32` - The number of valid Scrabble words, or 0 if `k` exceeds `n`.\nfn count_scrabble_words(n: usize, characters: &str, k: usize) -> i32 {\n    // First, validate that all characters are distinct and the length matches `n`\n    let unique_chars: HashSet<char> = characters.chars().collect();\n    if unique_chars.len() != n {\n        return 0;\n    }\n\n    if k > n {\n        return 0;\n    }\n\n    // Calculate the permutation: n! / (n - k)!\n    let numerator: i32 = (1..=n).product::<usize>() as i32;\n    let denominator: i32 = (1..=(n - k)).product::<usize>() as i32;\n    numerator / denominator\n}\n#[test]\nfn test_count_scrabble_words() {\n    // Valid cases\n    assert_eq!(count_scrabble_words(3, \"abc\", 2), 6);\n    assert_eq!(count_scrabble_words(4, \"abcd\", 3), 24);\n    assert_eq!(count_scrabble_words(5, \"abcde\", 5), 120);\n    \n    // Invalid cases\n    assert_eq!(count_scrabble_words(2, \"aab\", 1), 0);  // Characters not distinct\n    assert_eq!(count_scrabble_words(3, \"xyz\", 4), 0);  // k > n\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "/// Calculates the minimum number of operations required to make the maximum element\n/// of the array not greater than a given limit.\n///\n/// # Arguments\n/// * `n` - The length of the array (unused in this implementation but kept for interface consistency)\n/// * `x` - The maximum allowed value\n/// * `a` - The array of integers to process\n///\n/// # Returns\n/// The number of operations needed (difference between max element and x, or 0 if already within limit)\nfn min_operations_to_limit_max(n: usize, x: i32, a: &[i32]) -> i32 {\n    // Find the maximum value in the array\n    let max_a = match a.iter().max() {\n        Some(&max_val) => max_val,\n        None => return 0, // handle empty array case\n    };\n\n    // Return 0 if already within limit, otherwise the difference\n    if max_a <= x {\n        0\n    } else {\n        max_a - x\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 16318, "assertions": "#[test]\nfn test_min_operations_to_limit_max() {\n    assert_eq!(min_operations_to_limit_max(5, 3, &[1, 2, 3, 4, 5]), 2);\n    assert_eq!(min_operations_to_limit_max(4, 5, &[2, 3, 4, 1]), 0);\n    assert_eq!(min_operations_to_limit_max(3, 0, &[0, 0, 0]), 0);\n    assert_eq!(min_operations_to_limit_max(6, 10, &[15, 12, 8, 20, 9, 11]), 10);\n    assert_eq!(min_operations_to_limit_max(0, 5, &[]), 0);\n}", "all_code": "/// Calculates the minimum number of operations required to make the maximum element\n/// of the array not greater than a given limit.\n///\n/// # Arguments\n/// * `n` - The length of the array (unused in this implementation but kept for interface consistency)\n/// * `x` - The maximum allowed value\n/// * `a` - The array of integers to process\n///\n/// # Returns\n/// The number of operations needed (difference between max element and x, or 0 if already within limit)\nfn min_operations_to_limit_max(n: usize, x: i32, a: &[i32]) -> i32 {\n    // Find the maximum value in the array\n    let max_a = match a.iter().max() {\n        Some(&max_val) => max_val,\n        None => return 0, // handle empty array case\n    };\n\n    // Return 0 if already within limit, otherwise the difference\n    if max_a <= x {\n        0\n    } else {\n        max_a - x\n    }\n}\n#[test]\nfn test_min_operations_to_limit_max() {\n    assert_eq!(min_operations_to_limit_max(5, 3, &[1, 2, 3, 4, 5]), 2);\n    assert_eq!(min_operations_to_limit_max(4, 5, &[2, 3, 4, 1]), 0);\n    assert_eq!(min_operations_to_limit_max(3, 0, &[0, 0, 0]), 0);\n    assert_eq!(min_operations_to_limit_max(6, 10, &[15, 12, 8, 20, 9, 11]), 10);\n    assert_eq!(min_operations_to_limit_max(0, 5, &[]), 0);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{VecDeque, HashSet};\n\n/// Finds the minimum energy required to reach the destination 'D' from the start 'S' in a grid.\n/// The grid may contain obstacles marked by '#' and empty cells marked by '.'.\n/// Uses BFS to find the shortest path (minimum energy) from 'S' to 'D'.\n/// Returns -1 if the destination is unreachable.\nfn min_energy_to_reach_destination(n: usize, m: usize, grid: &Vec<Vec<char>>) -> i32 {\n    // Find the start and destination positions\n    let mut start = (0, 0);\n    let mut end = (0, 0);\n    let mut found_start = false;\n    let mut found_end = false;\n\n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j] == 'S' {\n                start = (i, j);\n                found_start = true;\n            } else if grid[i][j] == 'D' {\n                end = (i, j);\n                found_end = true;\n            }\n        }\n    }\n\n    if !found_start || !found_end {\n        return -1;\n    }\n\n    // BFS queue: stores (row, column, current_energy)\n    let mut queue = VecDeque::new();\n    queue.push_back((start.0, start.1, 0));\n\n    // Visited set to keep track of visited positions\n    let mut visited = HashSet::new();\n    visited.insert((start.0, start.1));\n\n    // Possible movement directions: up, down, left, right\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];\n\n    while let Some((x, y, energy)) = queue.pop_front() {\n        // Check if current position is the destination\n        if (x, y) == end {\n            return energy;\n        }\n\n        // Explore all four possible directions\n        for &(dx, dy) in &directions {\n            let nx = (x as i32 + dx) as usize;\n            let ny = (y as i32 + dy) as usize;\n\n            // Check if new position is within bounds, not visited, and not an obstacle\n            if nx < n && ny < m && !visited.contains(&(nx, ny)) && grid[nx][ny] != '#' {\n                visited.insert((nx, ny));\n                queue.push_back((nx, ny, energy + 1));\n            }\n        }\n    }\n\n    -1\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22666, "assertions": "#[test]\nfn test_min_energy_to_reach_destination() {\n    // Test case 1: Simple grid with one obstacle\n    let grid1 = vec![\n        vec!['S', '.', '.'],\n        vec!['.', '#', '.'],\n        vec!['.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(3, 3, &grid1), 4);\n\n    // Test case 2: Grid with no possible path\n    let grid2 = vec![\n        vec!['S', '#', '#'],\n        vec!['#', '#', '#'],\n        vec!['#', '#', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(3, 3, &grid2), -1);\n\n    // Test case 3: Straight path with no obstacles\n    let grid3 = vec![\n        vec!['S', '.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(1, 4, &grid3), 3);\n\n    // Test case 4: Grid with obstacle block in middle\n    let grid4 = vec![\n        vec!['S', '.', '.', '.'],\n        vec!['.', '#', '#', '.'],\n        vec!['.', '#', '#', '.'],\n        vec!['.', '.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(4, 4, &grid4), 6);\n}", "all_code": "use std::collections::{VecDeque, HashSet};\n\n/// Finds the minimum energy required to reach the destination 'D' from the start 'S' in a grid.\n/// The grid may contain obstacles marked by '#' and empty cells marked by '.'.\n/// Uses BFS to find the shortest path (minimum energy) from 'S' to 'D'.\n/// Returns -1 if the destination is unreachable.\nfn min_energy_to_reach_destination(n: usize, m: usize, grid: &Vec<Vec<char>>) -> i32 {\n    // Find the start and destination positions\n    let mut start = (0, 0);\n    let mut end = (0, 0);\n    let mut found_start = false;\n    let mut found_end = false;\n\n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j] == 'S' {\n                start = (i, j);\n                found_start = true;\n            } else if grid[i][j] == 'D' {\n                end = (i, j);\n                found_end = true;\n            }\n        }\n    }\n\n    if !found_start || !found_end {\n        return -1;\n    }\n\n    // BFS queue: stores (row, column, current_energy)\n    let mut queue = VecDeque::new();\n    queue.push_back((start.0, start.1, 0));\n\n    // Visited set to keep track of visited positions\n    let mut visited = HashSet::new();\n    visited.insert((start.0, start.1));\n\n    // Possible movement directions: up, down, left, right\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)];\n\n    while let Some((x, y, energy)) = queue.pop_front() {\n        // Check if current position is the destination\n        if (x, y) == end {\n            return energy;\n        }\n\n        // Explore all four possible directions\n        for &(dx, dy) in &directions {\n            let nx = (x as i32 + dx) as usize;\n            let ny = (y as i32 + dy) as usize;\n\n            // Check if new position is within bounds, not visited, and not an obstacle\n            if nx < n && ny < m && !visited.contains(&(nx, ny)) && grid[nx][ny] != '#' {\n                visited.insert((nx, ny));\n                queue.push_back((nx, ny, energy + 1));\n            }\n        }\n    }\n\n    -1\n}\n#[test]\nfn test_min_energy_to_reach_destination() {\n    // Test case 1: Simple grid with one obstacle\n    let grid1 = vec![\n        vec!['S', '.', '.'],\n        vec!['.', '#', '.'],\n        vec!['.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(3, 3, &grid1), 4);\n\n    // Test case 2: Grid with no possible path\n    let grid2 = vec![\n        vec!['S', '#', '#'],\n        vec!['#', '#', '#'],\n        vec!['#', '#', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(3, 3, &grid2), -1);\n\n    // Test case 3: Straight path with no obstacles\n    let grid3 = vec![\n        vec!['S', '.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(1, 4, &grid3), 3);\n\n    // Test case 4: Grid with obstacle block in middle\n    let grid4 = vec![\n        vec!['S', '.', '.', '.'],\n        vec!['.', '#', '#', '.'],\n        vec!['.', '#', '#', '.'],\n        vec!['.', '.', '.', 'D'],\n    ];\n    assert_eq!(min_energy_to_reach_destination(4, 4, &grid4), 6);\n}", "exec_outcome": "PASSED"}
{"code": "fn longest_ones(nums: &[i32]) -> i32 {\n    // Finds the maximum number of consecutive 1's with at most one 0 in between.\n    // Uses a sliding window approach with left and right pointers.\n    \n    let mut left = 0;\n    let mut max_ones = 0;\n    let mut zero_count = 0;\n    \n    for right in 0..nums.len() {\n        if nums[right] == 0 {\n            zero_count += 1;\n        }\n        \n        // When we have more than one zero, move left pointer forward\n        // until we have at most one zero in the window\n        while zero_count > 1 {\n            if nums[left] == 0 {\n                zero_count -= 1;\n            }\n            left += 1;\n        }\n        \n        // Update the maximum window size\n        max_ones = max_ones.max((right - left + 1) as i32);\n    }\n    \n    max_ones\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 24143, "assertions": "#[test]\nfn test_longest_ones() {\n    assert_eq!(longest_ones(&[1, 1, 0, 1, 1, 1]), 5);\n    assert_eq!(longest_ones(&[1, 0, 1, 1, 0, 1]), 4);\n    assert_eq!(longest_ones(&[0, 1, 1, 1, 0, 1, 1, 0, 1]), 5);\n    assert_eq!(longest_ones(&[1, 1, 1, 1, 1]), 5);\n    assert_eq!(longest_ones(&[0, 0, 0, 0]), 1);\n    assert_eq!(longest_ones(&[1, 0, 0, 1, 0, 1, 0, 1]), 2);\n}", "all_code": "fn longest_ones(nums: &[i32]) -> i32 {\n    // Finds the maximum number of consecutive 1's with at most one 0 in between.\n    // Uses a sliding window approach with left and right pointers.\n    \n    let mut left = 0;\n    let mut max_ones = 0;\n    let mut zero_count = 0;\n    \n    for right in 0..nums.len() {\n        if nums[right] == 0 {\n            zero_count += 1;\n        }\n        \n        // When we have more than one zero, move left pointer forward\n        // until we have at most one zero in the window\n        while zero_count > 1 {\n            if nums[left] == 0 {\n                zero_count -= 1;\n            }\n            left += 1;\n        }\n        \n        // Update the maximum window size\n        max_ones = max_ones.max((right - left + 1) as i32);\n    }\n    \n    max_ones\n}\n#[test]\nfn test_longest_ones() {\n    assert_eq!(longest_ones(&[1, 1, 0, 1, 1, 1]), 5);\n    assert_eq!(longest_ones(&[1, 0, 1, 1, 0, 1]), 4);\n    assert_eq!(longest_ones(&[0, 1, 1, 1, 0, 1, 1, 0, 1]), 5);\n    assert_eq!(longest_ones(&[1, 1, 1, 1, 1]), 5);\n    assert_eq!(longest_ones(&[0, 0, 0, 0]), 1);\n    assert_eq!(longest_ones(&[1, 0, 0, 1, 0, 1, 0, 1]), 2);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::HashMap;\n\n/// Finds the most frequent substring of length k in the input string.\n/// If there are multiple substrings with the same maximum frequency,\n/// returns the lexicographically smallest one.\n/// Returns an empty string if k is greater than the input string length.\nfn most_frequent_substring(input_string: &str, k: usize) -> String {\n    if k > input_string.len() {\n        return String::new();\n    }\n\n    let mut substring_counts = HashMap::new();\n\n    // Count occurrences of each substring of length k\n    for i in 0..=(input_string.len() - k) {\n        let substring = &input_string[i..i + k];\n        *substring_counts.entry(substring.to_string()).or_insert(0) += 1;\n    }\n\n    // Find the maximum frequency\n    let max_frequency = substring_counts.values().max().copied().unwrap_or(0);\n\n    // Collect all substrings with maximum frequency\n    let mut most_frequent_substrings: Vec<String> = substring_counts\n        .iter()\n        .filter(|&(_, &count)| count == max_frequency)\n        .map(|(s, _)| s.clone())\n        .collect();\n\n    // Return the lexicographically smallest substring\n    most_frequent_substrings.sort();\n    most_frequent_substrings.into_iter().next().unwrap_or_default()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 29074, "assertions": "#[test]\nfn test_most_frequent_substring() {\n    assert_eq!(most_frequent_substring(\"ababab\", 2), \"ab\");\n    assert_eq!(most_frequent_substring(\"abcde\", 3), \"abc\");\n    assert_eq!(most_frequent_substring(\"aaaaa\", 1), \"a\");\n    assert_eq!(most_frequent_substring(\"aabbb\", 2), \"bb\");\n    assert_eq!(most_frequent_substring(\"short\", 10), \"\");\n    assert_eq!(most_frequent_substring(\"banana\", 2), \"an\");\n    assert_eq!(most_frequent_substring(\"\", 2), \"\");\n}", "all_code": "use std::collections::HashMap;\n\n/// Finds the most frequent substring of length k in the input string.\n/// If there are multiple substrings with the same maximum frequency,\n/// returns the lexicographically smallest one.\n/// Returns an empty string if k is greater than the input string length.\nfn most_frequent_substring(input_string: &str, k: usize) -> String {\n    if k > input_string.len() {\n        return String::new();\n    }\n\n    let mut substring_counts = HashMap::new();\n\n    // Count occurrences of each substring of length k\n    for i in 0..=(input_string.len() - k) {\n        let substring = &input_string[i..i + k];\n        *substring_counts.entry(substring.to_string()).or_insert(0) += 1;\n    }\n\n    // Find the maximum frequency\n    let max_frequency = substring_counts.values().max().copied().unwrap_or(0);\n\n    // Collect all substrings with maximum frequency\n    let mut most_frequent_substrings: Vec<String> = substring_counts\n        .iter()\n        .filter(|&(_, &count)| count == max_frequency)\n        .map(|(s, _)| s.clone())\n        .collect();\n\n    // Return the lexicographically smallest substring\n    most_frequent_substrings.sort();\n    most_frequent_substrings.into_iter().next().unwrap_or_default()\n}\n#[test]\nfn test_most_frequent_substring() {\n    assert_eq!(most_frequent_substring(\"ababab\", 2), \"ab\");\n    assert_eq!(most_frequent_substring(\"abcde\", 3), \"abc\");\n    assert_eq!(most_frequent_substring(\"aaaaa\", 1), \"a\");\n    assert_eq!(most_frequent_substring(\"aabbb\", 2), \"bb\");\n    assert_eq!(most_frequent_substring(\"short\", 10), \"\");\n    assert_eq!(most_frequent_substring(\"banana\", 2), \"an\");\n    assert_eq!(most_frequent_substring(\"\", 2), \"\");\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Determines if a given sum can be formed using any combination of given coin denominations.\n///\n/// # Arguments\n/// * `n` - Number of different coin denominations.\n/// * `s` - The sum to form.\n/// * `coins` - List of coin denominations.\n///\n/// # Returns\n/// \"POSSIBLE\" if the sum can be formed using the given coin denominations, \"IMPOSSIBLE\" otherwise.\nfn is_sum_possible(n: usize, s: usize, coins: &[usize]) -> String {\n    // Initialize a vector to store dp values\n    let mut dp = vec![false; s + 1];\n    dp[0] = true; // Base case: We can always form the sum 0\n\n    for &coin in coins {\n        for x in coin..=s {\n            if dp[x - coin] {\n                dp[x] = true;\n            }\n        }\n    }\n\n    if dp[s] {\n        \"POSSIBLE\".to_string()\n    } else {\n        \"IMPOSSIBLE\".to_string()\n    }\n}\n\n/// Checks the possibility of forming sums for multiple queries.\n///\n/// # Arguments\n/// * `queries` - A vector of tuples where each tuple contains (n, s, coins).\n///\n/// # Returns\n/// A vector of results indicating \"POSSIBLE\" or \"IMPOSSIBLE\" for each query.\nfn check_possibility(queries: Vec<(usize, usize, Vec<usize>)>) -> Vec<String> {\n    queries\n        .into_iter()\n        .map(|(n, s, coins)| is_sum_possible(n, s, &coins))\n        .collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 11571, "assertions": "#[test]\nfn test_is_sum_possible() {\n    assert_eq!(\n        is_sum_possible(3, 11, &[3, 5, 7]),\n        \"POSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(2, 4, &[3, 5]),\n        \"IMPOSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(4, 15, &[2, 4, 6, 8]),\n        \"IMPOSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(1, 5, &[5]),\n        \"POSSIBLE\".to_string()\n    );\n}\n\n#[test]\nfn test_check_possibility() {\n    let queries = vec![\n        (3, 11, vec![3, 5, 7]),\n        (2, 4, vec![3, 5]),\n        (4, 15, vec![2, 4, 6, 8]),\n        (1, 5, vec![5]),\n    ];\n    let expected = vec![\n        \"POSSIBLE\".to_string(),\n        \"IMPOSSIBLE\".to_string(),\n        \"IMPOSSIBLE\".to_string(),\n        \"POSSIBLE\".to_string(),\n    ];\n    assert_eq!(check_possibility(queries), expected);\n}", "all_code": "use std::collections::HashMap;\n\n/// Determines if a given sum can be formed using any combination of given coin denominations.\n///\n/// # Arguments\n/// * `n` - Number of different coin denominations.\n/// * `s` - The sum to form.\n/// * `coins` - List of coin denominations.\n///\n/// # Returns\n/// \"POSSIBLE\" if the sum can be formed using the given coin denominations, \"IMPOSSIBLE\" otherwise.\nfn is_sum_possible(n: usize, s: usize, coins: &[usize]) -> String {\n    // Initialize a vector to store dp values\n    let mut dp = vec![false; s + 1];\n    dp[0] = true; // Base case: We can always form the sum 0\n\n    for &coin in coins {\n        for x in coin..=s {\n            if dp[x - coin] {\n                dp[x] = true;\n            }\n        }\n    }\n\n    if dp[s] {\n        \"POSSIBLE\".to_string()\n    } else {\n        \"IMPOSSIBLE\".to_string()\n    }\n}\n\n/// Checks the possibility of forming sums for multiple queries.\n///\n/// # Arguments\n/// * `queries` - A vector of tuples where each tuple contains (n, s, coins).\n///\n/// # Returns\n/// A vector of results indicating \"POSSIBLE\" or \"IMPOSSIBLE\" for each query.\nfn check_possibility(queries: Vec<(usize, usize, Vec<usize>)>) -> Vec<String> {\n    queries\n        .into_iter()\n        .map(|(n, s, coins)| is_sum_possible(n, s, &coins))\n        .collect()\n}\n#[test]\nfn test_is_sum_possible() {\n    assert_eq!(\n        is_sum_possible(3, 11, &[3, 5, 7]),\n        \"POSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(2, 4, &[3, 5]),\n        \"IMPOSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(4, 15, &[2, 4, 6, 8]),\n        \"IMPOSSIBLE\".to_string()\n    );\n    assert_eq!(\n        is_sum_possible(1, 5, &[5]),\n        \"POSSIBLE\".to_string()\n    );\n}\n\n#[test]\nfn test_check_possibility() {\n    let queries = vec![\n        (3, 11, vec![3, 5, 7]),\n        (2, 4, vec![3, 5]),\n        (4, 15, vec![2, 4, 6, 8]),\n        (1, 5, vec![5]),\n    ];\n    let expected = vec![\n        \"POSSIBLE\".to_string(),\n        \"IMPOSSIBLE\".to_string(),\n        \"IMPOSSIBLE\".to_string(),\n        \"POSSIBLE\".to_string(),\n    ];\n    assert_eq!(check_possibility(queries), expected);\n}", "exec_outcome": "PASSED"}
{"code": "/// Determines whether a sequence of numbers is arithmetic, geometric, or neither.\n/// An arithmetic sequence has a constant difference between consecutive terms.\n/// A geometric sequence has a constant ratio between consecutive terms.\n/// Returns \"Arithmetic\", \"Geometric\", or \"Neither\" as appropriate.\nfn sequence_type(nums: &[f64]) -> &'static str {\n    if nums.len() < 2 {\n        return \"Neither\";\n    }\n    \n    let mut is_arithmetic = true;\n    let mut is_geometric = true;\n    \n    // Check for arithmetic sequence\n    let common_difference = nums[1] - nums[0];\n    for i in 1..nums.len() {\n        if (nums[i] - nums[i - 1] - common_difference).abs() > f64::EPSILON {\n            is_arithmetic = false;\n            break;\n        }\n    }\n    \n    // Check for geometric sequence\n    if nums[0].abs() < f64::EPSILON {\n        is_geometric = false;\n    } else {\n        let common_ratio = nums[1] / nums[0];\n        for i in 1..nums.len() {\n            if nums[i].abs() < f64::EPSILON || \n               ((nums[i] / nums[i - 1]) - common_ratio).abs() > f64::EPSILON {\n                is_geometric = false;\n                break;\n            }\n        }\n    }\n    \n    if is_arithmetic {\n        \"Arithmetic\"\n    } else if is_geometric {\n        \"Geometric\"\n    } else {\n        \"Neither\"\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 9337, "assertions": "#[test]\nfn test_sequence_type() {\n    assert_eq!(sequence_type(&[1.0, 2.0, 3.0, 4.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[2.0, 4.0, 8.0, 16.0]), \"Geometric\");\n    assert_eq!(sequence_type(&[1.0, 2.0, 4.0, 7.0]), \"Neither\");\n    assert_eq!(sequence_type(&[0.0, 0.0, 0.0, 0.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[1.0, 0.0, 0.0, 0.0]), \"Neither\");\n    assert_eq!(sequence_type(&[5.0]), \"Neither\");\n    assert_eq!(sequence_type(&[3.0, -1.0, -5.0, -9.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[1.0, -2.0, 4.0, -8.0]), \"Geometric\");\n}", "all_code": "/// Determines whether a sequence of numbers is arithmetic, geometric, or neither.\n/// An arithmetic sequence has a constant difference between consecutive terms.\n/// A geometric sequence has a constant ratio between consecutive terms.\n/// Returns \"Arithmetic\", \"Geometric\", or \"Neither\" as appropriate.\nfn sequence_type(nums: &[f64]) -> &'static str {\n    if nums.len() < 2 {\n        return \"Neither\";\n    }\n    \n    let mut is_arithmetic = true;\n    let mut is_geometric = true;\n    \n    // Check for arithmetic sequence\n    let common_difference = nums[1] - nums[0];\n    for i in 1..nums.len() {\n        if (nums[i] - nums[i - 1] - common_difference).abs() > f64::EPSILON {\n            is_arithmetic = false;\n            break;\n        }\n    }\n    \n    // Check for geometric sequence\n    if nums[0].abs() < f64::EPSILON {\n        is_geometric = false;\n    } else {\n        let common_ratio = nums[1] / nums[0];\n        for i in 1..nums.len() {\n            if nums[i].abs() < f64::EPSILON || \n               ((nums[i] / nums[i - 1]) - common_ratio).abs() > f64::EPSILON {\n                is_geometric = false;\n                break;\n            }\n        }\n    }\n    \n    if is_arithmetic {\n        \"Arithmetic\"\n    } else if is_geometric {\n        \"Geometric\"\n    } else {\n        \"Neither\"\n    }\n}\n#[test]\nfn test_sequence_type() {\n    assert_eq!(sequence_type(&[1.0, 2.0, 3.0, 4.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[2.0, 4.0, 8.0, 16.0]), \"Geometric\");\n    assert_eq!(sequence_type(&[1.0, 2.0, 4.0, 7.0]), \"Neither\");\n    assert_eq!(sequence_type(&[0.0, 0.0, 0.0, 0.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[1.0, 0.0, 0.0, 0.0]), \"Neither\");\n    assert_eq!(sequence_type(&[5.0]), \"Neither\");\n    assert_eq!(sequence_type(&[3.0, -1.0, -5.0, -9.0]), \"Arithmetic\");\n    assert_eq!(sequence_type(&[1.0, -2.0, 4.0, -8.0]), \"Geometric\");\n}", "exec_outcome": "PASSED"}
{"code": "fn is_wildcard_balanced(s: &str) -> bool {\n    // Checks if the given string with '(', ')', and '*' can be balanced.\n    // The algorithm tracks the possible minimum (low) and maximum (high) number of open parentheses.\n    // If at any point high becomes negative, the string cannot be balanced.\n    // Finally, we check if low is zero, meaning we can balance the parentheses.\n    \n    let mut low = 0;\n    let mut high = 0;\n    \n    for char in s.chars() {\n        match char {\n            '(' => {\n                low += 1;\n                high += 1;\n            }\n            ')' => {\n                if low > 0 {\n                    low -= 1;\n                }\n                high -= 1;\n            }\n            '*' => {\n                if low > 0 {\n                    low -= 1;\n                }\n                high += 1;\n            }\n            _ => {} // Ignore other characters\n        }\n        \n        if high < 0 {\n            return false;\n        }\n    }\n    \n    low == 0\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 27393, "assertions": "#[test]\nfn test_is_wildcard_balanced() {\n    assert_eq!(is_wildcard_balanced(\"()\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*))\"), true);\n    assert_eq!(is_wildcard_balanced(\"((*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(((***\"), true);\n    assert_eq!(is_wildcard_balanced(\")*(\"), false);\n    assert_eq!(is_wildcard_balanced(\"((*)*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*()\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*)))\"), false);\n    assert_eq!(is_wildcard_balanced(\"((*\"), false);\n}", "all_code": "fn is_wildcard_balanced(s: &str) -> bool {\n    // Checks if the given string with '(', ')', and '*' can be balanced.\n    // The algorithm tracks the possible minimum (low) and maximum (high) number of open parentheses.\n    // If at any point high becomes negative, the string cannot be balanced.\n    // Finally, we check if low is zero, meaning we can balance the parentheses.\n    \n    let mut low = 0;\n    let mut high = 0;\n    \n    for char in s.chars() {\n        match char {\n            '(' => {\n                low += 1;\n                high += 1;\n            }\n            ')' => {\n                if low > 0 {\n                    low -= 1;\n                }\n                high -= 1;\n            }\n            '*' => {\n                if low > 0 {\n                    low -= 1;\n                }\n                high += 1;\n            }\n            _ => {} // Ignore other characters\n        }\n        \n        if high < 0 {\n            return false;\n        }\n    }\n    \n    low == 0\n}\n#[test]\nfn test_is_wildcard_balanced() {\n    assert_eq!(is_wildcard_balanced(\"()\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*))\"), true);\n    assert_eq!(is_wildcard_balanced(\"((*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(((***\"), true);\n    assert_eq!(is_wildcard_balanced(\")*(\"), false);\n    assert_eq!(is_wildcard_balanced(\"((*)*)\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*()\"), true);\n    assert_eq!(is_wildcard_balanced(\"(*)))\"), false);\n    assert_eq!(is_wildcard_balanced(\"((*\"), false);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to perform heap sort on a vector of integers\n// Parameters:\n// - arr: A mutable reference to a vector of i32 to be sorted\n// - ascending: A boolean indicating whether to sort in ascending (true) or descending (false) order\n// Returns: The sorted vector\nfn heap_sort(arr: &mut Vec<i32>, ascending: bool) -> Vec<i32> {\n    // Inner function to heapify a subtree rooted at index i\n    // n is the size of the heap\n    fn heapify(arr: &mut [i32], n: usize, i: usize, ascending: bool) {\n        let mut largest = i; // Initialize largest as root\n        let left = 2 * i + 1; // left child\n        let right = 2 * i + 2; // right child\n\n        // Find the largest/smallest element depending on sort order\n        if ascending {\n            if left < n && arr[left] > arr[largest] {\n                largest = left;\n            }\n            if right < n && arr[right] > arr[largest] {\n                largest = right;\n            }\n        } else {\n            if left < n && arr[left] < arr[largest] {\n                largest = left;\n            }\n            if right < n && arr[right] < arr[largest] {\n                largest = right;\n            }\n        }\n\n        // If largest is not root, swap and continue heapifying\n        if largest != i {\n            arr.swap(i, largest);\n            heapify(arr, n, largest, ascending);\n        }\n    }\n\n    let n = arr.len();\n\n    // Build heap (rearrange array)\n    for i in (0..n / 2).rev() {\n        heapify(arr, n, i, ascending);\n    }\n\n    // One by one extract elements from heap\n    for i in (1..n).rev() {\n        arr.swap(0, i); // Move current root to end\n        heapify(arr, i, 0, ascending); // Heapify the reduced heap\n    }\n\n    arr.to_vec()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 9947, "assertions": "#[test]\nfn test_heap_sort() {\n    // Test ascending sort\n    let mut input = vec![4, 10, 3, 5, 1];\n    assert_eq!(heap_sort(&mut input, true), vec![1, 3, 4, 5, 10]);\n    \n    // Test descending sort\n    let mut input = vec![4, 10, 3, 5, 1];\n    assert_eq!(heap_sort(&mut input, false), vec![10, 5, 4, 3, 1]);\n    \n    // Test already sorted ascending\n    let mut input = vec![1, 2, 3, 4, 5];\n    assert_eq!(heap_sort(&mut input, true), vec![1, 2, 3, 4, 5]);\n    \n    // Test already sorted descending\n    let mut input = vec![5, 4, 3, 2, 1];\n    assert_eq!(heap_sort(&mut input, false), vec![5, 4, 3, 2, 1]);\n    \n    // Test single element\n    let mut input = vec![1];\n    assert_eq!(heap_sort(&mut input, true), vec![1]);\n    \n    // Test empty vector\n    let mut input = vec![];\n    assert_eq!(heap_sort(&mut input, true), vec![]);\n}", "all_code": "// Function to perform heap sort on a vector of integers\n// Parameters:\n// - arr: A mutable reference to a vector of i32 to be sorted\n// - ascending: A boolean indicating whether to sort in ascending (true) or descending (false) order\n// Returns: The sorted vector\nfn heap_sort(arr: &mut Vec<i32>, ascending: bool) -> Vec<i32> {\n    // Inner function to heapify a subtree rooted at index i\n    // n is the size of the heap\n    fn heapify(arr: &mut [i32], n: usize, i: usize, ascending: bool) {\n        let mut largest = i; // Initialize largest as root\n        let left = 2 * i + 1; // left child\n        let right = 2 * i + 2; // right child\n\n        // Find the largest/smallest element depending on sort order\n        if ascending {\n            if left < n && arr[left] > arr[largest] {\n                largest = left;\n            }\n            if right < n && arr[right] > arr[largest] {\n                largest = right;\n            }\n        } else {\n            if left < n && arr[left] < arr[largest] {\n                largest = left;\n            }\n            if right < n && arr[right] < arr[largest] {\n                largest = right;\n            }\n        }\n\n        // If largest is not root, swap and continue heapifying\n        if largest != i {\n            arr.swap(i, largest);\n            heapify(arr, n, largest, ascending);\n        }\n    }\n\n    let n = arr.len();\n\n    // Build heap (rearrange array)\n    for i in (0..n / 2).rev() {\n        heapify(arr, n, i, ascending);\n    }\n\n    // One by one extract elements from heap\n    for i in (1..n).rev() {\n        arr.swap(0, i); // Move current root to end\n        heapify(arr, i, 0, ascending); // Heapify the reduced heap\n    }\n\n    arr.to_vec()\n}\n#[test]\nfn test_heap_sort() {\n    // Test ascending sort\n    let mut input = vec![4, 10, 3, 5, 1];\n    assert_eq!(heap_sort(&mut input, true), vec![1, 3, 4, 5, 10]);\n    \n    // Test descending sort\n    let mut input = vec![4, 10, 3, 5, 1];\n    assert_eq!(heap_sort(&mut input, false), vec![10, 5, 4, 3, 1]);\n    \n    // Test already sorted ascending\n    let mut input = vec![1, 2, 3, 4, 5];\n    assert_eq!(heap_sort(&mut input, true), vec![1, 2, 3, 4, 5]);\n    \n    // Test already sorted descending\n    let mut input = vec![5, 4, 3, 2, 1];\n    assert_eq!(heap_sort(&mut input, false), vec![5, 4, 3, 2, 1]);\n    \n    // Test single element\n    let mut input = vec![1];\n    assert_eq!(heap_sort(&mut input, true), vec![1]);\n    \n    // Test empty vector\n    let mut input = vec![];\n    assert_eq!(heap_sort(&mut input, true), vec![]);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{HashMap, HashSet};\n\n// Counts the number of connected components in an undirected graph and returns the components\n// The graph is represented as an adjacency list (HashMap where keys are nodes and values are neighbors)\nfn count_connected_components(graph: &HashMap<u32, Vec<u32>>) -> (usize, Vec<Vec<u32>>) {\n    // Performs DFS to explore a connected component starting from 'node'\n    // Modifies the 'visited' set and 'component' vector in place\n    fn dfs(node: u32, graph: &HashMap<u32, Vec<u32>>, visited: &mut HashSet<u32>, component: &mut Vec<u32>) {\n        visited.insert(node);\n        component.push(node);\n        \n        if let Some(neighbors) = graph.get(&node) {\n            for &neighbor in neighbors {\n                if !visited.contains(&neighbor) {\n                    dfs(neighbor, graph, visited, component);\n                }\n            }\n        }\n    }\n\n    let mut visited = HashSet::new();\n    let mut components = Vec::new();\n    \n    // Iterate through all nodes in the graph\n    for &node in graph.keys() {\n        if !visited.contains(&node) {\n            let mut component = Vec::new();\n            dfs(node, graph, &mut visited, &mut component);\n            components.push(component);\n        }\n    }\n    \n    (components.len(), components)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 18945, "assertions": "#[test]\nfn test_count_connected_components() {\n    // Test case 1: Single connected component\n    let graph1 = HashMap::from([\n        (1, vec![2, 3]),\n        (2, vec![1, 3]),\n        (3, vec![1, 2]),\n    ]);\n    let (count1, components1) = count_connected_components(&graph1);\n    assert_eq!(count1, 1);\n    assert_eq!(components1, vec![vec![1, 2, 3]]);\n\n    // Test case 2: Two connected components\n    let graph2 = HashMap::from([\n        (1, vec![2]),\n        (2, vec![1]),\n        (3, vec![4]),\n        (4, vec![3]),\n    ]);\n    let (count2, components2) = count_connected_components(&graph2);\n    assert_eq!(count2, 2);\n    assert!(components2.contains(&vec![1, 2]));\n    assert!(components2.contains(&vec![3, 4]));\n\n    // Test case 3: Three connected components (including isolated nodes)\n    let graph3 = HashMap::from([\n        (1, vec![2]),\n        (2, vec![1]),\n        (3, vec![]),\n        (4, vec![5]),\n        (5, vec![4]),\n    ]);\n    let (count3, components3) = count_connected_components(&graph3);\n    assert_eq!(count3, 3);\n    assert!(components3.contains(&vec![1, 2]));\n    assert!(components3.contains(&vec![3]));\n    assert!(components3.contains(&vec![4, 5]));\n\n    // Test case 4: Empty graph\n    let graph4 = HashMap::new();\n    let (count4, components4) = count_connected_components(&graph4);\n    assert_eq!(count4, 0);\n    assert_eq!(components4, Vec::<Vec<u32>>::new());\n}", "all_code": "use std::collections::{HashMap, HashSet};\n\n// Counts the number of connected components in an undirected graph and returns the components\n// The graph is represented as an adjacency list (HashMap where keys are nodes and values are neighbors)\nfn count_connected_components(graph: &HashMap<u32, Vec<u32>>) -> (usize, Vec<Vec<u32>>) {\n    // Performs DFS to explore a connected component starting from 'node'\n    // Modifies the 'visited' set and 'component' vector in place\n    fn dfs(node: u32, graph: &HashMap<u32, Vec<u32>>, visited: &mut HashSet<u32>, component: &mut Vec<u32>) {\n        visited.insert(node);\n        component.push(node);\n        \n        if let Some(neighbors) = graph.get(&node) {\n            for &neighbor in neighbors {\n                if !visited.contains(&neighbor) {\n                    dfs(neighbor, graph, visited, component);\n                }\n            }\n        }\n    }\n\n    let mut visited = HashSet::new();\n    let mut components = Vec::new();\n    \n    // Iterate through all nodes in the graph\n    for &node in graph.keys() {\n        if !visited.contains(&node) {\n            let mut component = Vec::new();\n            dfs(node, graph, &mut visited, &mut component);\n            components.push(component);\n        }\n    }\n    \n    (components.len(), components)\n}\n#[test]\nfn test_count_connected_components() {\n    // Test case 1: Single connected component\n    let graph1 = HashMap::from([\n        (1, vec![2, 3]),\n        (2, vec![1, 3]),\n        (3, vec![1, 2]),\n    ]);\n    let (count1, components1) = count_connected_components(&graph1);\n    assert_eq!(count1, 1);\n    assert_eq!(components1, vec![vec![1, 2, 3]]);\n\n    // Test case 2: Two connected components\n    let graph2 = HashMap::from([\n        (1, vec![2]),\n        (2, vec![1]),\n        (3, vec![4]),\n        (4, vec![3]),\n    ]);\n    let (count2, components2) = count_connected_components(&graph2);\n    assert_eq!(count2, 2);\n    assert!(components2.contains(&vec![1, 2]));\n    assert!(components2.contains(&vec![3, 4]));\n\n    // Test case 3: Three connected components (including isolated nodes)\n    let graph3 = HashMap::from([\n        (1, vec![2]),\n        (2, vec![1]),\n        (3, vec![]),\n        (4, vec![5]),\n        (5, vec![4]),\n    ]);\n    let (count3, components3) = count_connected_components(&graph3);\n    assert_eq!(count3, 3);\n    assert!(components3.contains(&vec![1, 2]));\n    assert!(components3.contains(&vec![3]));\n    assert!(components3.contains(&vec![4, 5]));\n\n    // Test case 4: Empty graph\n    let graph4 = HashMap::new();\n    let (count4, components4) = count_connected_components(&graph4);\n    assert_eq!(count4, 0);\n    assert_eq!(components4, Vec::<Vec<u32>>::new());\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::HashSet;\n\n/// Generates a sequence of length n starting with 1 and adding the difference d.\n/// If a number recurs, it continues from the next number until the sequence reaches length n.\n///\n/// # Arguments\n/// * `n` - Length of the sequence\n/// * `d` - Difference to be added\n///\n/// # Returns\n/// A vector of n unique numbers starting from 1, or an empty vector if not possible.\nfn generate_sequence(n: usize, d: i32) -> Vec<i32> {\n    let mut sequence = Vec::with_capacity(n);\n    let mut current_num = 1;\n    let mut seen_numbers = HashSet::new();\n\n    while sequence.len() < n {\n        if !seen_numbers.contains(&current_num) {\n            sequence.push(current_num);\n            seen_numbers.insert(current_num);\n        }\n        current_num += d;\n    }\n\n    sequence\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 24941, "assertions": "#[test]\nfn test_generate_sequence() {\n    assert_eq!(generate_sequence(5, 2), vec![1, 3, 5, 7, 9]);\n    assert_eq!(generate_sequence(10, 3), vec![1, 4, 7, 10, 13, 16, 19, 22, 25, 28]);\n    assert_eq!(generate_sequence(1, 100), vec![1]);\n    assert_eq!(generate_sequence(7, 0), vec![1]);\n}", "all_code": "use std::collections::HashSet;\n\n/// Generates a sequence of length n starting with 1 and adding the difference d.\n/// If a number recurs, it continues from the next number until the sequence reaches length n.\n///\n/// # Arguments\n/// * `n` - Length of the sequence\n/// * `d` - Difference to be added\n///\n/// # Returns\n/// A vector of n unique numbers starting from 1, or an empty vector if not possible.\nfn generate_sequence(n: usize, d: i32) -> Vec<i32> {\n    let mut sequence = Vec::with_capacity(n);\n    let mut current_num = 1;\n    let mut seen_numbers = HashSet::new();\n\n    while sequence.len() < n {\n        if !seen_numbers.contains(&current_num) {\n            sequence.push(current_num);\n            seen_numbers.insert(current_num);\n        }\n        current_num += d;\n    }\n\n    sequence\n}\n#[test]\nfn test_generate_sequence() {\n    assert_eq!(generate_sequence(5, 2), vec![1, 3, 5, 7, 9]);\n    assert_eq!(generate_sequence(10, 3), vec![1, 4, 7, 10, 13, 16, 19, 22, 25, 28]);\n    assert_eq!(generate_sequence(1, 100), vec![1]);\n    assert_eq!(generate_sequence(7, 0), vec![1]);\n}", "exec_outcome": "TIME_LIMIT_EXCEEDED"}
{"code": "use std::collections::HashMap;\n\n/// Returns the minimum number of adjacent swaps required to make nums1 equal to nums2.\n/// Returns -1 if it's impossible to make them equal through swaps.\nfn min_swaps_to_equal(nums1: &[i32], nums2: &[i32]) -> i32 {\n    // First check if the sorted versions are equal (i.e., same elements)\n    let mut sorted_nums1 = nums1.to_vec();\n    let mut sorted_nums2 = nums2.to_vec();\n    sorted_nums1.sort();\n    sorted_nums2.sort();\n    \n    if sorted_nums1 != sorted_nums2 {\n        return -1;\n    }\n    \n    // Create a mapping from value to its index in nums2\n    let mut index_map: HashMap<i32, usize> = HashMap::new();\n    for (i, &value) in nums2.iter().enumerate() {\n        index_map.insert(value, i);\n    }\n    \n    // We'll work on a mutable copy of nums2\n    let mut nums2_mut = nums2.to_vec();\n    let mut swaps = 0;\n    \n    for i in 0..nums1.len() {\n        while nums1[i] != nums2_mut[i] {\n            // Get the current position of the element that should be at position i\n            let swap_index = *index_map.get(&nums1[i]).unwrap();\n            \n            // Perform the swap\n            nums2_mut.swap(i, swap_index);\n            \n            // Update the index map for the swapped elements\n            index_map.insert(nums2_mut[i], i);\n            index_map.insert(nums2_mut[swap_index], swap_index);\n            \n            swaps += 1;\n        }\n    }\n    \n    swaps\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 15528, "assertions": "#[test]\nfn test_min_swaps_to_equal() {\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 3, 2, 4]), 1);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[4, 3, 2, 1]), 3);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 2, 4, 3]), 1);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 2, 3, 5]), -1);\n    assert_eq!(min_swaps_to_equal(&[5, 1, 2, 4, 3], &[1, 5, 4, 2, 3]), 3);\n}", "all_code": "use std::collections::HashMap;\n\n/// Returns the minimum number of adjacent swaps required to make nums1 equal to nums2.\n/// Returns -1 if it's impossible to make them equal through swaps.\nfn min_swaps_to_equal(nums1: &[i32], nums2: &[i32]) -> i32 {\n    // First check if the sorted versions are equal (i.e., same elements)\n    let mut sorted_nums1 = nums1.to_vec();\n    let mut sorted_nums2 = nums2.to_vec();\n    sorted_nums1.sort();\n    sorted_nums2.sort();\n    \n    if sorted_nums1 != sorted_nums2 {\n        return -1;\n    }\n    \n    // Create a mapping from value to its index in nums2\n    let mut index_map: HashMap<i32, usize> = HashMap::new();\n    for (i, &value) in nums2.iter().enumerate() {\n        index_map.insert(value, i);\n    }\n    \n    // We'll work on a mutable copy of nums2\n    let mut nums2_mut = nums2.to_vec();\n    let mut swaps = 0;\n    \n    for i in 0..nums1.len() {\n        while nums1[i] != nums2_mut[i] {\n            // Get the current position of the element that should be at position i\n            let swap_index = *index_map.get(&nums1[i]).unwrap();\n            \n            // Perform the swap\n            nums2_mut.swap(i, swap_index);\n            \n            // Update the index map for the swapped elements\n            index_map.insert(nums2_mut[i], i);\n            index_map.insert(nums2_mut[swap_index], swap_index);\n            \n            swaps += 1;\n        }\n    }\n    \n    swaps\n}\n#[test]\nfn test_min_swaps_to_equal() {\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 3, 2, 4]), 1);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[4, 3, 2, 1]), 3);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 2, 4, 3]), 1);\n    assert_eq!(min_swaps_to_equal(&[1, 2, 3, 4], &[1, 2, 3, 5]), -1);\n    assert_eq!(min_swaps_to_equal(&[5, 1, 2, 4, 3], &[1, 5, 4, 2, 3]), 3);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "/// Restores a sequence such that it becomes strictly increasing by replacing zeros.\n///\n/// # Arguments\n/// * `n` - The length of the sequence.\n/// * `k` - The maximum allowed value in the sequence.\n/// * `sequence` - A mutable vector representing the sequence where zeros need to be replaced.\n///\n/// # Returns\n/// A tuple containing:\n/// - \"YES\" if the sequence can be made strictly increasing, \"NO\" otherwise\n/// - The restored sequence (if successful)\nfn restore_sequence(n: usize, k: usize, sequence: &mut Vec<usize>) -> (String, Option<Vec<usize>>) {\n    // Create a list of all the missing positions (where value is 0)\n    let missing_indices: Vec<usize> = sequence.iter()\n        .enumerate()\n        .filter(|(_, &x)| x == 0)\n        .map(|(i, _)| i)\n        .collect();\n    \n    // Count unique non-zero values in the sequence\n    let unique_non_zero: usize = sequence.iter()\n        .filter(|&&x| x != 0)\n        .collect::<std::collections::HashSet<_>>()\n        .len();\n    \n    // Validate if it's possible to make the sequence strictly increasing\n    if missing_indices.len() + unique_non_zero > k {\n        return (\"NO\".to_string(), None);\n    }\n    \n    // Fill in the missing values to make the sequence strictly increasing\n    let mut current_value = 1;\n    for i in 0..n {\n        if sequence[i] == 0 {\n            while sequence.contains(&current_value) {\n                current_value += 1;\n            }\n            if current_value > k {\n                return (\"NO\".to_string(), None);\n            }\n            sequence[i] = current_value;\n        }\n        current_value = sequence[i] + 1;\n    }\n    \n    (\"YES\".to_string(), Some(sequence.clone()))\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 14157, "assertions": "#[test]\nfn test_restore_sequence() {\n    // Test case 1: Can be restored\n    let mut seq1 = vec![1, 0, 0, 0, 5];\n    let (res1, restored1) = restore_sequence(5, 5, &mut seq1);\n    assert_eq!(res1, \"YES\");\n    assert_eq!(restored1, Some(vec![1, 2, 3, 4, 5]));\n\n    // Test case 2: Can't be restored (k too small)\n    let mut seq2 = vec![1, 0, 0, 0, 5];\n    let (res2, restored2) = restore_sequence(5, 4, &mut seq2);\n    assert_eq!(res2, \"NO\");\n    assert_eq!(restored2, None);\n\n    // Test case 3: All zeros\n    let mut seq3 = vec![0, 0, 0, 0, 0];\n    let (res3, restored3) = restore_sequence(5, 6, &mut seq3);\n    assert_eq!(res3, \"YES\");\n    assert_eq!(restored3, Some(vec![1, 2, 3, 4, 5]));\n\n    // Test case 4: Already complete\n    let mut seq4 = vec![1, 2, 3];\n    let (res4, restored4) = restore_sequence(3, 3, &mut seq4);\n    assert_eq!(res4, \"YES\");\n    assert_eq!(restored4, Some(vec![1, 2, 3]));\n\n    // Test case 5: Some zeros\n    let mut seq5 = vec![1, 0, 3, 0];\n    let (res5, restored5) = restore_sequence(4, 4, &mut seq5);\n    assert_eq!(res5, \"YES\");\n    assert_eq!(restored5, Some(vec![1, 2, 3, 4]));\n}", "all_code": "/// Restores a sequence such that it becomes strictly increasing by replacing zeros.\n///\n/// # Arguments\n/// * `n` - The length of the sequence.\n/// * `k` - The maximum allowed value in the sequence.\n/// * `sequence` - A mutable vector representing the sequence where zeros need to be replaced.\n///\n/// # Returns\n/// A tuple containing:\n/// - \"YES\" if the sequence can be made strictly increasing, \"NO\" otherwise\n/// - The restored sequence (if successful)\nfn restore_sequence(n: usize, k: usize, sequence: &mut Vec<usize>) -> (String, Option<Vec<usize>>) {\n    // Create a list of all the missing positions (where value is 0)\n    let missing_indices: Vec<usize> = sequence.iter()\n        .enumerate()\n        .filter(|(_, &x)| x == 0)\n        .map(|(i, _)| i)\n        .collect();\n    \n    // Count unique non-zero values in the sequence\n    let unique_non_zero: usize = sequence.iter()\n        .filter(|&&x| x != 0)\n        .collect::<std::collections::HashSet<_>>()\n        .len();\n    \n    // Validate if it's possible to make the sequence strictly increasing\n    if missing_indices.len() + unique_non_zero > k {\n        return (\"NO\".to_string(), None);\n    }\n    \n    // Fill in the missing values to make the sequence strictly increasing\n    let mut current_value = 1;\n    for i in 0..n {\n        if sequence[i] == 0 {\n            while sequence.contains(&current_value) {\n                current_value += 1;\n            }\n            if current_value > k {\n                return (\"NO\".to_string(), None);\n            }\n            sequence[i] = current_value;\n        }\n        current_value = sequence[i] + 1;\n    }\n    \n    (\"YES\".to_string(), Some(sequence.clone()))\n}\n#[test]\nfn test_restore_sequence() {\n    // Test case 1: Can be restored\n    let mut seq1 = vec![1, 0, 0, 0, 5];\n    let (res1, restored1) = restore_sequence(5, 5, &mut seq1);\n    assert_eq!(res1, \"YES\");\n    assert_eq!(restored1, Some(vec![1, 2, 3, 4, 5]));\n\n    // Test case 2: Can't be restored (k too small)\n    let mut seq2 = vec![1, 0, 0, 0, 5];\n    let (res2, restored2) = restore_sequence(5, 4, &mut seq2);\n    assert_eq!(res2, \"NO\");\n    assert_eq!(restored2, None);\n\n    // Test case 3: All zeros\n    let mut seq3 = vec![0, 0, 0, 0, 0];\n    let (res3, restored3) = restore_sequence(5, 6, &mut seq3);\n    assert_eq!(res3, \"YES\");\n    assert_eq!(restored3, Some(vec![1, 2, 3, 4, 5]));\n\n    // Test case 4: Already complete\n    let mut seq4 = vec![1, 2, 3];\n    let (res4, restored4) = restore_sequence(3, 3, &mut seq4);\n    assert_eq!(res4, \"YES\");\n    assert_eq!(restored4, Some(vec![1, 2, 3]));\n\n    // Test case 5: Some zeros\n    let mut seq5 = vec![1, 0, 3, 0];\n    let (res5, restored5) = restore_sequence(4, 4, &mut seq5);\n    assert_eq!(res5, \"YES\");\n    assert_eq!(restored5, Some(vec![1, 2, 3, 4]));\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Counts how many strings in the input vector have exactly the same character\n/// frequency as the word \"hello\".\n///\n/// # Arguments\n/// * `n` - The number of strings in the input vector (unused in the function but kept for interface consistency)\n/// * `strings` - A vector of strings to check against the \"hello\" character frequency\n///\n/// # Returns\n/// The count of strings that match the \"hello\" character frequency exactly\nfn count_hello_strings(n: usize, strings: Vec<&str>) -> usize {\n    let keyword = \"hello\";\n    \n    // Create a frequency map for the keyword \"hello\"\n    let keyword_map = create_char_frequency_map(keyword);\n    \n    // Count how many strings have the exact same character frequency\n    strings.iter()\n        .filter(|&s| create_char_frequency_map(s) == keyword_map)\n        .count()\n}\n\n/// Creates a frequency map (HashMap) of characters in a string\n///\n/// # Arguments\n/// * `s` - The input string to analyze\n///\n/// # Returns\n/// A HashMap where keys are characters and values are their counts in the string\nfn create_char_frequency_map(s: &str) -> HashMap<char, usize> {\n    let mut map = HashMap::new();\n    for c in s.chars() {\n        *map.entry(c).or_insert(0) += 1;\n    }\n    map\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 11590, "assertions": "#[test]\nfn test_count_hello_strings() {\n    assert_eq!(count_hello_strings(5, vec![\"hello\", \"olelh\", \"world\", \"ehlloo\", \"ohell\"]), 3);\n    assert_eq!(count_hello_strings(3, vec![\"hello\", \"hello\", \"hello\"]), 3);\n    assert_eq!(count_hello_strings(4, vec![\"ehllo\", \"holle\", \"llohe\", \"hlloe\"]), 4);\n    assert_eq!(count_hello_strings(2, vec![\"hello\", \"nothello\"]), 1);\n    assert_eq!(count_hello_strings(1, vec![\"hell\"]), 0);\n}", "all_code": "use std::collections::HashMap;\n\n/// Counts how many strings in the input vector have exactly the same character\n/// frequency as the word \"hello\".\n///\n/// # Arguments\n/// * `n` - The number of strings in the input vector (unused in the function but kept for interface consistency)\n/// * `strings` - A vector of strings to check against the \"hello\" character frequency\n///\n/// # Returns\n/// The count of strings that match the \"hello\" character frequency exactly\nfn count_hello_strings(n: usize, strings: Vec<&str>) -> usize {\n    let keyword = \"hello\";\n    \n    // Create a frequency map for the keyword \"hello\"\n    let keyword_map = create_char_frequency_map(keyword);\n    \n    // Count how many strings have the exact same character frequency\n    strings.iter()\n        .filter(|&s| create_char_frequency_map(s) == keyword_map)\n        .count()\n}\n\n/// Creates a frequency map (HashMap) of characters in a string\n///\n/// # Arguments\n/// * `s` - The input string to analyze\n///\n/// # Returns\n/// A HashMap where keys are characters and values are their counts in the string\nfn create_char_frequency_map(s: &str) -> HashMap<char, usize> {\n    let mut map = HashMap::new();\n    for c in s.chars() {\n        *map.entry(c).or_insert(0) += 1;\n    }\n    map\n}\n#[test]\nfn test_count_hello_strings() {\n    assert_eq!(count_hello_strings(5, vec![\"hello\", \"olelh\", \"world\", \"ehlloo\", \"ohell\"]), 3);\n    assert_eq!(count_hello_strings(3, vec![\"hello\", \"hello\", \"hello\"]), 3);\n    assert_eq!(count_hello_strings(4, vec![\"ehllo\", \"holle\", \"llohe\", \"hlloe\"]), 4);\n    assert_eq!(count_hello_strings(2, vec![\"hello\", \"nothello\"]), 1);\n    assert_eq!(count_hello_strings(1, vec![\"hell\"]), 0);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\n/// Determines if s1 can be made equal to s2 using the provided swap pairs.\n///\n/// # Arguments\n/// * `s1` - The first string.\n/// * `s2` - The second string.\n/// * `pairs` - Vector of tuples indicating allowable swaps.\n///\n/// # Returns\n/// * `bool` - True if s1 can be made equal to s2 with the allowable swaps, otherwise False.\nfn can_be_equal_with_swaps(s1: &str, s2: &str, pairs: &[(usize, usize)]) -> bool {\n    // If the lengths of the strings are not the same, they cannot be equal\n    if s1.len() != s2.len() {\n        return false;\n    }\n\n    let n = s1.len();\n    let mut parent: Vec<usize> = (0..n).collect();\n    let mut rank: Vec<usize> = vec![0; n];\n\n    // Function to find the root of the component with path compression\n    fn find(parent: &mut [usize], i: usize) -> usize {\n        if parent[i] != i {\n            parent[i] = find(parent, parent[i]);\n        }\n        parent[i]\n    }\n\n    // Function to perform union of two sets with union by rank\n    fn union(parent: &mut [usize], rank: &mut [usize], x: usize, y: usize) {\n        let root_x = find(parent, x);\n        let root_y = find(parent, y);\n\n        if root_x != root_y {\n            if rank[root_x] > rank[root_y] {\n                parent[root_y] = root_x;\n            } else if rank[root_x] < rank[root_y] {\n                parent[root_x] = root_y;\n            } else {\n                parent[root_y] = root_x;\n                rank[root_x] += 1;\n            }\n        }\n    }\n\n    // Apply union operation for each pair\n    for &(a, b) in pairs {\n        union(&mut parent, &mut rank, a, b);\n    }\n\n    // Create maps for root to the list of characters that can be swapped in s1 and s2\n    let mut root_to_chars_s1: HashMap<usize, Vec<char>> = HashMap::new();\n    let mut root_to_chars_s2: HashMap<usize, Vec<char>> = HashMap::new();\n\n    for i in 0..n {\n        let root = find(&mut parent, i);\n        root_to_chars_s1.entry(root).or_default().push(s1.chars().nth(i).unwrap());\n        root_to_chars_s2.entry(root).or_default().push(s2.chars().nth(i).unwrap());\n    }\n\n    // Check if the characters in each component can be made equal\n    for (root, chars_s1) in root_to_chars_s1 {\n        if let Some(chars_s2) = root_to_chars_s2.get(&root) {\n            let mut sorted_s1 = chars_s1.clone();\n            let mut sorted_s2 = chars_s2.clone();\n            sorted_s1.sort_unstable();\n            sorted_s2.sort_unstable();\n            if sorted_s1 != sorted_s2 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    true\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 1430, "assertions": "#[test]\nfn test_can_be_equal_with_swaps() {\n    assert!(can_be_equal_with_swaps(\"abcd\", \"cbad\", &[(0, 1), (1, 2), (2, 3)]));\n    assert!(can_be_equal_with_swaps(\"abcd\", \"cbad\", &[(0, 1), (2, 3)]));\n    assert!(can_be_equal_with_swaps(\"abcd\", \"abcd\", &[]));\n    assert!(!can_be_equal_with_swaps(\"a\", \"b\", &[]));\n    assert!(can_be_equal_with_swaps(\"abc\", \"bca\", &[(0, 1), (1, 2)]));\n    assert!(can_be_equal_with_swaps(\"abc\", \"bac\", &[(0, 1)]));\n    assert!(!can_be_equal_with_swaps(\"abc\", \"cab\", &[(0, 1)]));\n}", "all_code": "use std::collections::HashMap;\n\n/// Determines if s1 can be made equal to s2 using the provided swap pairs.\n///\n/// # Arguments\n/// * `s1` - The first string.\n/// * `s2` - The second string.\n/// * `pairs` - Vector of tuples indicating allowable swaps.\n///\n/// # Returns\n/// * `bool` - True if s1 can be made equal to s2 with the allowable swaps, otherwise False.\nfn can_be_equal_with_swaps(s1: &str, s2: &str, pairs: &[(usize, usize)]) -> bool {\n    // If the lengths of the strings are not the same, they cannot be equal\n    if s1.len() != s2.len() {\n        return false;\n    }\n\n    let n = s1.len();\n    let mut parent: Vec<usize> = (0..n).collect();\n    let mut rank: Vec<usize> = vec![0; n];\n\n    // Function to find the root of the component with path compression\n    fn find(parent: &mut [usize], i: usize) -> usize {\n        if parent[i] != i {\n            parent[i] = find(parent, parent[i]);\n        }\n        parent[i]\n    }\n\n    // Function to perform union of two sets with union by rank\n    fn union(parent: &mut [usize], rank: &mut [usize], x: usize, y: usize) {\n        let root_x = find(parent, x);\n        let root_y = find(parent, y);\n\n        if root_x != root_y {\n            if rank[root_x] > rank[root_y] {\n                parent[root_y] = root_x;\n            } else if rank[root_x] < rank[root_y] {\n                parent[root_x] = root_y;\n            } else {\n                parent[root_y] = root_x;\n                rank[root_x] += 1;\n            }\n        }\n    }\n\n    // Apply union operation for each pair\n    for &(a, b) in pairs {\n        union(&mut parent, &mut rank, a, b);\n    }\n\n    // Create maps for root to the list of characters that can be swapped in s1 and s2\n    let mut root_to_chars_s1: HashMap<usize, Vec<char>> = HashMap::new();\n    let mut root_to_chars_s2: HashMap<usize, Vec<char>> = HashMap::new();\n\n    for i in 0..n {\n        let root = find(&mut parent, i);\n        root_to_chars_s1.entry(root).or_default().push(s1.chars().nth(i).unwrap());\n        root_to_chars_s2.entry(root).or_default().push(s2.chars().nth(i).unwrap());\n    }\n\n    // Check if the characters in each component can be made equal\n    for (root, chars_s1) in root_to_chars_s1 {\n        if let Some(chars_s2) = root_to_chars_s2.get(&root) {\n            let mut sorted_s1 = chars_s1.clone();\n            let mut sorted_s2 = chars_s2.clone();\n            sorted_s1.sort_unstable();\n            sorted_s2.sort_unstable();\n            if sorted_s1 != sorted_s2 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    true\n}\n#[test]\nfn test_can_be_equal_with_swaps() {\n    assert!(can_be_equal_with_swaps(\"abcd\", \"cbad\", &[(0, 1), (1, 2), (2, 3)]));\n    assert!(can_be_equal_with_swaps(\"abcd\", \"cbad\", &[(0, 1), (2, 3)]));\n    assert!(can_be_equal_with_swaps(\"abcd\", \"abcd\", &[]));\n    assert!(!can_be_equal_with_swaps(\"a\", \"b\", &[]));\n    assert!(can_be_equal_with_swaps(\"abc\", \"bca\", &[(0, 1), (1, 2)]));\n    assert!(can_be_equal_with_swaps(\"abc\", \"bac\", &[(0, 1)]));\n    assert!(!can_be_equal_with_swaps(\"abc\", \"cab\", &[(0, 1)]));\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::cmp::max;\n\n/// Calculates the minimized maximum distance between any robot pairs.\n/// The distance between two robots is defined as the absolute difference of their positions.\n///\n/// # Arguments\n/// * `positions` - A slice of integers representing the positions of robots.\n///\n/// # Returns\n/// The minimized maximum distance between any robot pairs as an i32.\nfn minimized_max_distance(positions: &mut [i32]) -> i32 {\n    // Sort the positions to make pairing adjacent positions easier\n    positions.sort();\n\n    // Initialize the minimized maximum distance to 0\n    let mut minimized_max_dist = 0;\n\n    // Iterate through the list, pairing adjacent robots (stepping by 2)\n    for i in (0..positions.len() - 1).step_by(2) {\n        minimized_max_dist = max(minimized_max_dist, positions[i + 1] - positions[i]);\n    }\n\n    minimized_max_dist\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 3804, "assertions": "#[test]\nfn test_minimized_max_distance() {\n    assert_eq!(minimized_max_distance(&mut vec![1, 3, 7, 10]), 3);\n    assert_eq!(minimized_max_distance(&mut vec![5, 2, 8, 1]), 3);\n    assert_eq!(minimized_max_distance(&mut vec![10, 20]), 10);\n    assert_eq!(minimized_max_distance(&mut vec![4, 4, 4, 4]), 0);\n    assert_eq!(minimized_max_distance(&mut vec![1, 2, 3, 4, 5, 6]), 1);\n}", "all_code": "use std::cmp::max;\n\n/// Calculates the minimized maximum distance between any robot pairs.\n/// The distance between two robots is defined as the absolute difference of their positions.\n///\n/// # Arguments\n/// * `positions` - A slice of integers representing the positions of robots.\n///\n/// # Returns\n/// The minimized maximum distance between any robot pairs as an i32.\nfn minimized_max_distance(positions: &mut [i32]) -> i32 {\n    // Sort the positions to make pairing adjacent positions easier\n    positions.sort();\n\n    // Initialize the minimized maximum distance to 0\n    let mut minimized_max_dist = 0;\n\n    // Iterate through the list, pairing adjacent robots (stepping by 2)\n    for i in (0..positions.len() - 1).step_by(2) {\n        minimized_max_dist = max(minimized_max_dist, positions[i + 1] - positions[i]);\n    }\n\n    minimized_max_dist\n}\n#[test]\nfn test_minimized_max_distance() {\n    assert_eq!(minimized_max_distance(&mut vec![1, 3, 7, 10]), 3);\n    assert_eq!(minimized_max_distance(&mut vec![5, 2, 8, 1]), 3);\n    assert_eq!(minimized_max_distance(&mut vec![10, 20]), 10);\n    assert_eq!(minimized_max_distance(&mut vec![4, 4, 4, 4]), 0);\n    assert_eq!(minimized_max_distance(&mut vec![1, 2, 3, 4, 5, 6]), 1);\n}", "exec_outcome": "PASSED"}
{"code": "fn shortest_subarray_to_sort(nums: &[i32]) -> usize {\n    let n = nums.len();\n    \n    // Edge case: if the array has 1 or 0 elements, it is already sorted\n    if n <= 1 {\n        return 0;\n    }\n    \n    // Find the left boundary where the order breaks\n    let mut left = 0;\n    while left < n - 1 && nums[left] <= nums[left + 1] {\n        left += 1;\n    }\n    \n    // If we reached the end, the array is already sorted\n    if left == n - 1 {\n        return 0;\n    }\n    \n    // Find the right boundary where the order breaks\n    let mut right = n - 1;\n    while right > 0 && nums[right] >= nums[right - 1] {\n        right -= 1;\n    }\n    \n    // Find min and max in the current subarray\n    let subarray_min = nums[left..=right].iter().min().unwrap();\n    let subarray_max = nums[left..=right].iter().max().unwrap();\n    \n    // Expand left boundary if needed\n    while left > 0 && nums[left - 1] > *subarray_min {\n        left -= 1;\n    }\n    \n    // Expand right boundary if needed\n    while right < n - 1 && nums[right + 1] < *subarray_max {\n        right += 1;\n    }\n    \n    right - left + 1\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 28028, "assertions": "#[test]\nfn test_shortest_subarray_to_sort() {\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 3, 4, 5]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 3, 2, 4, 5]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 3, 2, 4]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![5, 4, 3, 2, 1]), 5);\n    assert_eq!(shortest_subarray_to_sort(&vec![1]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 4, 3, 5, 6]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 3, 5, 4, 2, 6, 7]), 3);\n}", "all_code": "fn shortest_subarray_to_sort(nums: &[i32]) -> usize {\n    let n = nums.len();\n    \n    // Edge case: if the array has 1 or 0 elements, it is already sorted\n    if n <= 1 {\n        return 0;\n    }\n    \n    // Find the left boundary where the order breaks\n    let mut left = 0;\n    while left < n - 1 && nums[left] <= nums[left + 1] {\n        left += 1;\n    }\n    \n    // If we reached the end, the array is already sorted\n    if left == n - 1 {\n        return 0;\n    }\n    \n    // Find the right boundary where the order breaks\n    let mut right = n - 1;\n    while right > 0 && nums[right] >= nums[right - 1] {\n        right -= 1;\n    }\n    \n    // Find min and max in the current subarray\n    let subarray_min = nums[left..=right].iter().min().unwrap();\n    let subarray_max = nums[left..=right].iter().max().unwrap();\n    \n    // Expand left boundary if needed\n    while left > 0 && nums[left - 1] > *subarray_min {\n        left -= 1;\n    }\n    \n    // Expand right boundary if needed\n    while right < n - 1 && nums[right + 1] < *subarray_max {\n        right += 1;\n    }\n    \n    right - left + 1\n}\n#[test]\nfn test_shortest_subarray_to_sort() {\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 3, 4, 5]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 3, 2, 4, 5]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 3, 2, 4]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![5, 4, 3, 2, 1]), 5);\n    assert_eq!(shortest_subarray_to_sort(&vec![1]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![]), 0);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 2, 4, 3, 5, 6]), 2);\n    assert_eq!(shortest_subarray_to_sort(&vec![1, 3, 5, 4, 2, 6, 7]), 3);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::VecDeque;\n\n// Function to count land clusters in a grid using DFS\n// n: number of rows in the grid\n// m: number of columns in the grid\n// grid: 2D vector representing the grid ('L' for land, 'W' for water)\nfn count_land_clusters(n: usize, m: usize, grid: &mut Vec<Vec<char>>) -> i32 {\n    // Nested DFS function to explore connected land cells\n    fn dfs(x: i32, y: i32, n: i32, m: i32, grid: &mut Vec<Vec<char>>) {\n        // Check if current position is out of bounds or not land\n        if x < 0 || x >= n || y < 0 || y >= m || grid[x as usize][y as usize] != 'L' {\n            return;\n        }\n        \n        // Mark current cell as visited by changing it to 'W'\n        grid[x as usize][y as usize] = 'W';\n        \n        // Explore all four adjacent cells\n        dfs(x + 1, y, n, m, grid);\n        dfs(x - 1, y, n, m, grid);\n        dfs(x, y + 1, n, m, grid);\n        dfs(x, y - 1, n, m, grid);\n    }\n\n    let mut clusters = 0;\n    \n    // Iterate through each cell in the grid\n    for i in 0..n {\n        for j in 0..m {\n            // If we find land, perform DFS to mark all connected land\n            if grid[i][j] == 'L' {\n                dfs(i as i32, j as i32, n as i32, m as i32, grid);\n                clusters += 1;\n            }\n        }\n    }\n    \n    clusters\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 20576, "assertions": "#[test]\nfn test_count_land_clusters() {\n    // Test case 1: Simple 3x3 grid with 1 land cluster\n    let mut grid1 = vec![\n        vec!['L', 'W', 'W'],\n        vec!['W', 'L', 'W'],\n        vec!['W', 'W', 'L'],\n    ];\n    let n1 = grid1.len();\n    let m1 = grid1[0].len();\n    assert_eq!(count_land_clusters(n1, m1, &mut grid1), 1);\n\n    // Test case 2: 4x4 grid with 2 separate land clusters\n    let mut grid2 = vec![\n        vec!['L', 'W', 'L', 'W'],\n        vec!['L', 'W', 'L', 'W'],\n        vec!['W', 'W', 'W', 'W'],\n        vec!['L', 'L', 'W', 'L'],\n    ];\n    let n2 = grid2.len();\n    let m2 = grid2[0].len();\n    assert_eq!(count_land_clusters(n2, m2, &mut grid2), 2);\n\n    // Test case 3: All water grid\n    let mut grid3 = vec![\n        vec!['W', 'W', 'W'],\n        vec!['W', 'W', 'W'],\n    ];\n    let n3 = grid3.len();\n    let m3 = grid3[0].len();\n    assert_eq!(count_land_clusters(n3, m3, &mut grid3), 0);\n\n    // Test case 4: All land grid (single cluster)\n    let mut grid4 = vec![\n        vec!['L', 'L'],\n        vec!['L', 'L'],\n    ];\n    let n4 = grid4.len();\n    let m4 = grid4[0].len();\n    assert_eq!(count_land_clusters(n4, m4, &mut grid4), 1);\n}", "all_code": "use std::collections::VecDeque;\n\n// Function to count land clusters in a grid using DFS\n// n: number of rows in the grid\n// m: number of columns in the grid\n// grid: 2D vector representing the grid ('L' for land, 'W' for water)\nfn count_land_clusters(n: usize, m: usize, grid: &mut Vec<Vec<char>>) -> i32 {\n    // Nested DFS function to explore connected land cells\n    fn dfs(x: i32, y: i32, n: i32, m: i32, grid: &mut Vec<Vec<char>>) {\n        // Check if current position is out of bounds or not land\n        if x < 0 || x >= n || y < 0 || y >= m || grid[x as usize][y as usize] != 'L' {\n            return;\n        }\n        \n        // Mark current cell as visited by changing it to 'W'\n        grid[x as usize][y as usize] = 'W';\n        \n        // Explore all four adjacent cells\n        dfs(x + 1, y, n, m, grid);\n        dfs(x - 1, y, n, m, grid);\n        dfs(x, y + 1, n, m, grid);\n        dfs(x, y - 1, n, m, grid);\n    }\n\n    let mut clusters = 0;\n    \n    // Iterate through each cell in the grid\n    for i in 0..n {\n        for j in 0..m {\n            // If we find land, perform DFS to mark all connected land\n            if grid[i][j] == 'L' {\n                dfs(i as i32, j as i32, n as i32, m as i32, grid);\n                clusters += 1;\n            }\n        }\n    }\n    \n    clusters\n}\n#[test]\nfn test_count_land_clusters() {\n    // Test case 1: Simple 3x3 grid with 1 land cluster\n    let mut grid1 = vec![\n        vec!['L', 'W', 'W'],\n        vec!['W', 'L', 'W'],\n        vec!['W', 'W', 'L'],\n    ];\n    let n1 = grid1.len();\n    let m1 = grid1[0].len();\n    assert_eq!(count_land_clusters(n1, m1, &mut grid1), 1);\n\n    // Test case 2: 4x4 grid with 2 separate land clusters\n    let mut grid2 = vec![\n        vec!['L', 'W', 'L', 'W'],\n        vec!['L', 'W', 'L', 'W'],\n        vec!['W', 'W', 'W', 'W'],\n        vec!['L', 'L', 'W', 'L'],\n    ];\n    let n2 = grid2.len();\n    let m2 = grid2[0].len();\n    assert_eq!(count_land_clusters(n2, m2, &mut grid2), 2);\n\n    // Test case 3: All water grid\n    let mut grid3 = vec![\n        vec!['W', 'W', 'W'],\n        vec!['W', 'W', 'W'],\n    ];\n    let n3 = grid3.len();\n    let m3 = grid3[0].len();\n    assert_eq!(count_land_clusters(n3, m3, &mut grid3), 0);\n\n    // Test case 4: All land grid (single cluster)\n    let mut grid4 = vec![\n        vec!['L', 'L'],\n        vec!['L', 'L'],\n    ];\n    let n4 = grid4.len();\n    let m4 = grid4[0].len();\n    assert_eq!(count_land_clusters(n4, m4, &mut grid4), 1);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Function to find the longest sequence of elements in a sorted set S where each subsequent element\n// increases by a constant step k, starting from an initial value b1.\n//\n// Parameters:\n// - k: The constant step between consecutive elements in the sequence\n// - s: A sorted vector of integers representing the set S\n// - b1: The starting value of the sequence\n//\n// Returns:\n// A vector containing the longest sequence found\nfn longest_jump_sequence(k: i32, s: &[i32], b1: i32) -> Vec<i32> {\n    let mut sequence = Vec::new();\n    let mut current_value = b1;\n    \n    // Binary search the sorted vector to check if current_value exists\n    while s.binary_search(&current_value).is_ok() {\n        sequence.push(current_value);\n        current_value += k;\n    }\n    \n    sequence\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 17760, "assertions": "#[test]\nfn test_longest_jump_sequence() {\n    assert_eq!(longest_jump_sequence(2, &[1, 3, 5, 7, 9], 3), vec![3, 5, 7, 9]);\n    assert_eq!(longest_jump_sequence(3, &[2, 5, 8, 11, 14], 5), vec![5, 8, 11, 14]);\n    assert_eq!(longest_jump_sequence(1, &[1, 2, 3, 4, 5], 1), vec![1, 2, 3, 4, 5]);\n    assert_eq!(longest_jump_sequence(5, &[10, 15, 20], 10), vec![10, 15, 20]);\n    assert_eq!(longest_jump_sequence(2, &[1, 4, 7, 10], 1), vec![1]);\n    assert_eq!(longest_jump_sequence(3, &[1, 2, 3], 1), vec![1]);\n}", "all_code": "// Function to find the longest sequence of elements in a sorted set S where each subsequent element\n// increases by a constant step k, starting from an initial value b1.\n//\n// Parameters:\n// - k: The constant step between consecutive elements in the sequence\n// - s: A sorted vector of integers representing the set S\n// - b1: The starting value of the sequence\n//\n// Returns:\n// A vector containing the longest sequence found\nfn longest_jump_sequence(k: i32, s: &[i32], b1: i32) -> Vec<i32> {\n    let mut sequence = Vec::new();\n    let mut current_value = b1;\n    \n    // Binary search the sorted vector to check if current_value exists\n    while s.binary_search(&current_value).is_ok() {\n        sequence.push(current_value);\n        current_value += k;\n    }\n    \n    sequence\n}\n#[test]\nfn test_longest_jump_sequence() {\n    assert_eq!(longest_jump_sequence(2, &[1, 3, 5, 7, 9], 3), vec![3, 5, 7, 9]);\n    assert_eq!(longest_jump_sequence(3, &[2, 5, 8, 11, 14], 5), vec![5, 8, 11, 14]);\n    assert_eq!(longest_jump_sequence(1, &[1, 2, 3, 4, 5], 1), vec![1, 2, 3, 4, 5]);\n    assert_eq!(longest_jump_sequence(5, &[10, 15, 20], 10), vec![10, 15, 20]);\n    assert_eq!(longest_jump_sequence(2, &[1, 4, 7, 10], 1), vec![1]);\n    assert_eq!(longest_jump_sequence(3, &[1, 2, 3], 1), vec![1]);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{HashMap, VecDeque};\n\n/// Finds the order in which tasks can be executed given their dependencies using topological sorting.\n/// Returns either the task order as a vector or \"Not Possible\" if there's a cycle.\nfn find_task_order(n: usize, dependencies: &HashMap<usize, Vec<usize>>) -> Result<Vec<usize>, &'static str> {\n    // Create adjacency list and compute in-degrees for each task\n    let mut adj_list: HashMap<usize, Vec<usize>> = HashMap::new();\n    let mut in_degree: HashMap<usize, usize> = (1..=n).map(|task| (task, 0)).collect();\n\n    // Build the adjacency list and count in-degrees\n    for (&task, deps) in dependencies {\n        for &dep in deps {\n            adj_list.entry(dep).or_default().push(task);\n            *in_degree.entry(task).or_default() += 1;\n        }\n    }\n\n    // Initialize queue with tasks that have no dependencies\n    let mut queue: VecDeque<usize> = in_degree\n        .iter()\n        .filter(|&(_, &degree)| degree == 0)\n        .map(|(&task, _)| task)\n        .collect();\n\n    let mut task_order = Vec::with_capacity(n);\n\n    // Process tasks in topological order\n    while let Some(current_task) = queue.pop_front() {\n        task_order.push(current_task);\n\n        if let Some(neighbors) = adj_list.get(&current_task) {\n            for &neighbor in neighbors {\n                if let Some(degree) = in_degree.get_mut(&neighbor) {\n                    *degree -= 1;\n                    if *degree == 0 {\n                        queue.push_back(neighbor);\n                    }\n                }\n            }\n        }\n    }\n\n    // Check if all tasks were processed (no cycles)\n    if task_order.len() == n {\n        Ok(task_order)\n    } else {\n        Err(\"Not Possible\")\n    }\n}\n\n/// Parses input into the number of tasks and their dependencies\nfn parse_input(input_lines: &[&str]) -> (usize, HashMap<usize, Vec<usize>>) {\n    let n: usize = input_lines[0].parse().unwrap();\n    let mut dependencies = HashMap::new();\n\n    for line in &input_lines[1..=n] {\n        let parts: Vec<usize> = line.split_whitespace().map(|s| s.parse().unwrap()).collect();\n        let task = parts[0];\n        let deps = if parts[1] == 0 { // Using 0 instead of -1 for Rust's usize type\n            vec![]\n        } else {\n            parts[1..].to_vec()\n        };\n        dependencies.insert(task, deps);\n    }\n\n    (n, dependencies)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 11709, "assertions": "#[test]\nfn test_find_task_order() {\n    // Test case 1: Simple linear dependencies\n    let input1 = vec![\n        \"3\",\n        \"1 0\",\n        \"2 1 0\",\n        \"3 2 0\",\n    ];\n    let (n1, deps1) = parse_input(&input1);\n    assert_eq!(find_task_order(n1, &deps1), Ok(vec![1, 2, 3]));\n\n    // Test case 2: More complex dependencies\n    let input2 = vec![\n        \"5\",\n        \"1 0\",\n        \"2 1 0\",\n        \"3 1 0\",\n        \"4 2 3 0\",\n        \"5 4 0\",\n    ];\n    let (n2, deps2) = parse_input(&input2);\n    assert_eq!(find_task_order(n2, &deps2), Ok(vec![1, 2, 3, 4, 5]));\n\n    // Test case 3: Circular dependencies (should be impossible)\n    let input3 = vec![\n        \"3\",\n        \"1 2 0\",\n        \"2 3 0\",\n        \"3 1 0\",\n    ];\n    let (n3, deps3) = parse_input(&input3);\n    assert_eq!(find_task_order(n3, &deps3), Err(\"Not Possible\"));\n\n    // Test case 4: Independent tasks\n    let input4 = vec![\n        \"4\",\n        \"1 0\",\n        \"2 0\",\n        \"3 0\",\n        \"4 0\",\n    ];\n    let (n4, deps4) = parse_input(&input4);\n    let mut result = find_task_order(n4, &deps4).unwrap();\n    result.sort(); // Order of independent tasks isn't guaranteed\n    assert_eq!(result, vec![1, 2, 3, 4]);\n}", "all_code": "use std::collections::{HashMap, VecDeque};\n\n/// Finds the order in which tasks can be executed given their dependencies using topological sorting.\n/// Returns either the task order as a vector or \"Not Possible\" if there's a cycle.\nfn find_task_order(n: usize, dependencies: &HashMap<usize, Vec<usize>>) -> Result<Vec<usize>, &'static str> {\n    // Create adjacency list and compute in-degrees for each task\n    let mut adj_list: HashMap<usize, Vec<usize>> = HashMap::new();\n    let mut in_degree: HashMap<usize, usize> = (1..=n).map(|task| (task, 0)).collect();\n\n    // Build the adjacency list and count in-degrees\n    for (&task, deps) in dependencies {\n        for &dep in deps {\n            adj_list.entry(dep).or_default().push(task);\n            *in_degree.entry(task).or_default() += 1;\n        }\n    }\n\n    // Initialize queue with tasks that have no dependencies\n    let mut queue: VecDeque<usize> = in_degree\n        .iter()\n        .filter(|&(_, &degree)| degree == 0)\n        .map(|(&task, _)| task)\n        .collect();\n\n    let mut task_order = Vec::with_capacity(n);\n\n    // Process tasks in topological order\n    while let Some(current_task) = queue.pop_front() {\n        task_order.push(current_task);\n\n        if let Some(neighbors) = adj_list.get(&current_task) {\n            for &neighbor in neighbors {\n                if let Some(degree) = in_degree.get_mut(&neighbor) {\n                    *degree -= 1;\n                    if *degree == 0 {\n                        queue.push_back(neighbor);\n                    }\n                }\n            }\n        }\n    }\n\n    // Check if all tasks were processed (no cycles)\n    if task_order.len() == n {\n        Ok(task_order)\n    } else {\n        Err(\"Not Possible\")\n    }\n}\n\n/// Parses input into the number of tasks and their dependencies\nfn parse_input(input_lines: &[&str]) -> (usize, HashMap<usize, Vec<usize>>) {\n    let n: usize = input_lines[0].parse().unwrap();\n    let mut dependencies = HashMap::new();\n\n    for line in &input_lines[1..=n] {\n        let parts: Vec<usize> = line.split_whitespace().map(|s| s.parse().unwrap()).collect();\n        let task = parts[0];\n        let deps = if parts[1] == 0 { // Using 0 instead of -1 for Rust's usize type\n            vec![]\n        } else {\n            parts[1..].to_vec()\n        };\n        dependencies.insert(task, deps);\n    }\n\n    (n, dependencies)\n}\n#[test]\nfn test_find_task_order() {\n    // Test case 1: Simple linear dependencies\n    let input1 = vec![\n        \"3\",\n        \"1 0\",\n        \"2 1 0\",\n        \"3 2 0\",\n    ];\n    let (n1, deps1) = parse_input(&input1);\n    assert_eq!(find_task_order(n1, &deps1), Ok(vec![1, 2, 3]));\n\n    // Test case 2: More complex dependencies\n    let input2 = vec![\n        \"5\",\n        \"1 0\",\n        \"2 1 0\",\n        \"3 1 0\",\n        \"4 2 3 0\",\n        \"5 4 0\",\n    ];\n    let (n2, deps2) = parse_input(&input2);\n    assert_eq!(find_task_order(n2, &deps2), Ok(vec![1, 2, 3, 4, 5]));\n\n    // Test case 3: Circular dependencies (should be impossible)\n    let input3 = vec![\n        \"3\",\n        \"1 2 0\",\n        \"2 3 0\",\n        \"3 1 0\",\n    ];\n    let (n3, deps3) = parse_input(&input3);\n    assert_eq!(find_task_order(n3, &deps3), Err(\"Not Possible\"));\n\n    // Test case 4: Independent tasks\n    let input4 = vec![\n        \"4\",\n        \"1 0\",\n        \"2 0\",\n        \"3 0\",\n        \"4 0\",\n    ];\n    let (n4, deps4) = parse_input(&input4);\n    let mut result = find_task_order(n4, &deps4).unwrap();\n    result.sort(); // Order of independent tasks isn't guaranteed\n    assert_eq!(result, vec![1, 2, 3, 4]);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::{HashMap, VecDeque};\n\n/// A stack-like data structure that allows pushing elements and popping\n/// the most frequent element. If there are ties, the most recently pushed\n/// element is returned.\nstruct FreqStack {\n    freq: HashMap<i32, i32>,          // Tracks frequency of each value\n    group: HashMap<i32, VecDeque<i32>>, // Groups values by their frequency\n    max_freq: i32,                    // Tracks the current maximum frequency\n}\n\nimpl FreqStack {\n    /// Creates a new, empty FreqStack\n    fn new() -> Self {\n        FreqStack {\n            freq: HashMap::new(),\n            group: HashMap::new(),\n            max_freq: 0,\n        }\n    }\n\n    /// Pushes a value onto the stack\n    fn push(&mut self, val: i32) {\n        // Update the frequency count for this value\n        let count = self.freq.entry(val).or_insert(0);\n        *count += 1;\n        let current_freq = *count;\n\n        // Update max_freq if needed\n        if current_freq > self.max_freq {\n            self.max_freq = current_freq;\n        }\n\n        // Add the value to its frequency group\n        self.group.entry(current_freq).or_default().push_back(val);\n    }\n\n    /// Pops and returns the most frequent element.\n    /// If there are ties, returns the most recently pushed element.\n    fn pop(&mut self) -> i32 {\n        // Get the group with max frequency\n        if let Some(group) = self.group.get_mut(&self.max_freq) {\n            if let Some(val) = group.pop_back() {\n                // Update the frequency count\n                if let Some(count) = self.freq.get_mut(&val) {\n                    *count -= 1;\n                }\n\n                // If this group is now empty, decrease max_freq\n                if group.is_empty() {\n                    self.max_freq -= 1;\n                }\n\n                return val;\n            }\n        }\n        panic!(\"Cannot pop from empty FreqStack\");\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 5928, "assertions": "#[test]\nfn test_freq_stack() {\n    // Test case 1: Basic operations\n    let mut fs1 = FreqStack::new();\n    fs1.push(5);\n    fs1.push(7);\n    fs1.push(5);\n    fs1.push(7);\n    fs1.push(4);\n    fs1.push(5);\n    \n    assert_eq!(fs1.pop(), 5);\n    assert_eq!(fs1.pop(), 7);\n    assert_eq!(fs1.pop(), 5);\n    assert_eq!(fs1.pop(), 4);\n\n    // Test case 2: Ties in frequency\n    let mut fs2 = FreqStack::new();\n    fs2.push(1);\n    fs2.push(2);\n    fs2.push(3);\n    fs2.push(2);\n    fs2.push(1);\n    fs2.push(3);\n    fs2.push(4);\n    \n    assert_eq!(fs2.pop(), 3);\n    assert_eq!(fs2.pop(), 2);\n    assert_eq!(fs2.pop(), 1);\n    assert_eq!(fs2.pop(), 4);\n    assert_eq!(fs2.pop(), 3);\n    assert_eq!(fs2.pop(), 2);\n    assert_eq!(fs2.pop(), 1);\n\n    // Test case 3: Single element\n    let mut fs3 = FreqStack::new();\n    fs3.push(10);\n    fs3.push(10);\n    fs3.push(10);\n    \n    assert_eq!(fs3.pop(), 10);\n    assert_eq!(fs3.pop(), 10);\n    assert_eq!(fs3.pop(), 10);\n}", "all_code": "use std::collections::{HashMap, VecDeque};\n\n/// A stack-like data structure that allows pushing elements and popping\n/// the most frequent element. If there are ties, the most recently pushed\n/// element is returned.\nstruct FreqStack {\n    freq: HashMap<i32, i32>,          // Tracks frequency of each value\n    group: HashMap<i32, VecDeque<i32>>, // Groups values by their frequency\n    max_freq: i32,                    // Tracks the current maximum frequency\n}\n\nimpl FreqStack {\n    /// Creates a new, empty FreqStack\n    fn new() -> Self {\n        FreqStack {\n            freq: HashMap::new(),\n            group: HashMap::new(),\n            max_freq: 0,\n        }\n    }\n\n    /// Pushes a value onto the stack\n    fn push(&mut self, val: i32) {\n        // Update the frequency count for this value\n        let count = self.freq.entry(val).or_insert(0);\n        *count += 1;\n        let current_freq = *count;\n\n        // Update max_freq if needed\n        if current_freq > self.max_freq {\n            self.max_freq = current_freq;\n        }\n\n        // Add the value to its frequency group\n        self.group.entry(current_freq).or_default().push_back(val);\n    }\n\n    /// Pops and returns the most frequent element.\n    /// If there are ties, returns the most recently pushed element.\n    fn pop(&mut self) -> i32 {\n        // Get the group with max frequency\n        if let Some(group) = self.group.get_mut(&self.max_freq) {\n            if let Some(val) = group.pop_back() {\n                // Update the frequency count\n                if let Some(count) = self.freq.get_mut(&val) {\n                    *count -= 1;\n                }\n\n                // If this group is now empty, decrease max_freq\n                if group.is_empty() {\n                    self.max_freq -= 1;\n                }\n\n                return val;\n            }\n        }\n        panic!(\"Cannot pop from empty FreqStack\");\n    }\n}\n#[test]\nfn test_freq_stack() {\n    // Test case 1: Basic operations\n    let mut fs1 = FreqStack::new();\n    fs1.push(5);\n    fs1.push(7);\n    fs1.push(5);\n    fs1.push(7);\n    fs1.push(4);\n    fs1.push(5);\n    \n    assert_eq!(fs1.pop(), 5);\n    assert_eq!(fs1.pop(), 7);\n    assert_eq!(fs1.pop(), 5);\n    assert_eq!(fs1.pop(), 4);\n\n    // Test case 2: Ties in frequency\n    let mut fs2 = FreqStack::new();\n    fs2.push(1);\n    fs2.push(2);\n    fs2.push(3);\n    fs2.push(2);\n    fs2.push(1);\n    fs2.push(3);\n    fs2.push(4);\n    \n    assert_eq!(fs2.pop(), 3);\n    assert_eq!(fs2.pop(), 2);\n    assert_eq!(fs2.pop(), 1);\n    assert_eq!(fs2.pop(), 4);\n    assert_eq!(fs2.pop(), 3);\n    assert_eq!(fs2.pop(), 2);\n    assert_eq!(fs2.pop(), 1);\n\n    // Test case 3: Single element\n    let mut fs3 = FreqStack::new();\n    fs3.push(10);\n    fs3.push(10);\n    fs3.push(10);\n    \n    assert_eq!(fs3.pop(), 10);\n    assert_eq!(fs3.pop(), 10);\n    assert_eq!(fs3.pop(), 10);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::{VecDeque, HashSet};\n\n/// Determines if there's a path from 'S' to 'X' in the given grid.\n/// Returns \"YES\" if a path exists, \"NO\" otherwise.\n///\n/// # Arguments\n/// * `n` - Number of rows in the grid\n/// * `m` - Number of columns in the grid\n/// * `grid` - 2D vector representing the grid with characters\nfn can_reach_destination(n: usize, m: usize, grid: &Vec<Vec<char>>) -> &'static str {\n    // Find the starting point 'S' and destination 'X'\n    let mut start = None;\n    let mut end = None;\n    \n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j] == 'S' {\n                start = Some((i, j));\n            }\n            if grid[i][j] == 'X' {\n                end = Some((i, j));\n            }\n            \n            if start.is_some() && end.is_some() {\n                break;\n            }\n        }\n        if start.is_some() && end.is_some() {\n            break;\n        }\n    }\n\n    let start = match start {\n        Some(pos) => pos,\n        None => return \"NO\",\n    };\n    \n    let end = match end {\n        Some(pos) => pos,\n        None => return \"NO\",\n    };\n\n    // Directions for moving in the grid (right, down, left, up)\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n\n    // BFS algorithm to find path from 'S' to 'X'\n    let mut queue = VecDeque::new();\n    queue.push_back(start);\n    \n    let mut visited = HashSet::new();\n    visited.insert(start);\n\n    while let Some((x, y)) = queue.pop_front() {\n        if (x, y) == end {\n            return \"YES\";\n        }\n\n        for &(dx, dy) in &directions {\n            let nx = x as i32 + dx;\n            let ny = y as i32 + dy;\n\n            if nx >= 0 && ny >= 0 {\n                let nx = nx as usize;\n                let ny = ny as usize;\n                \n                if nx < n && ny < m && grid[nx][ny] != '#' && !visited.contains(&(nx, ny)) {\n                    queue.push_back((nx, ny));\n                    visited.insert((nx, ny));\n                }\n            }\n        }\n    }\n\n    \"NO\"\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 6177, "assertions": "#[test]\nfn test_can_reach_destination() {\n    // Test case 1: Path exists through open cells\n    assert_eq!(\n        can_reach_destination(\n            3, 3,\n            &vec![\n                vec!['S', '.', '.'],\n                vec!['#', '#', '.'],\n                vec!['.', '.', 'X'],\n            ]\n        ),\n        \"YES\"\n    );\n\n    // Test case 2: No path exists due to walls\n    assert_eq!(\n        can_reach_destination(\n            3, 3,\n            &vec![\n                vec!['S', '#', '.'],\n                vec!['#', '#', '.'],\n                vec!['.', '.', 'X'],\n            ]\n        ),\n        \"NO\"\n    );\n\n    // Test case 3: Direct path exists\n    assert_eq!(\n        can_reach_destination(\n            2, 2,\n            &vec![\n                vec!['S', 'X'],\n                vec!['.', '.'],\n            ]\n        ),\n        \"YES\"\n    );\n\n    // Test case 4: No path exists (completely blocked)\n    assert_eq!(\n        can_reach_destination(\n            2, 2,\n            &vec![\n                vec!['S', '#'],\n                vec!['#', 'X'],\n            ]\n        ),\n        \"NO\"\n    );\n\n    // Test case 5: No destination exists\n    assert_eq!(\n        can_reach_destination(\n            1, 1,\n            &vec![\n                vec!['S'],\n            ]\n        ),\n        \"NO\"\n    );\n}", "all_code": "use std::collections::{VecDeque, HashSet};\n\n/// Determines if there's a path from 'S' to 'X' in the given grid.\n/// Returns \"YES\" if a path exists, \"NO\" otherwise.\n///\n/// # Arguments\n/// * `n` - Number of rows in the grid\n/// * `m` - Number of columns in the grid\n/// * `grid` - 2D vector representing the grid with characters\nfn can_reach_destination(n: usize, m: usize, grid: &Vec<Vec<char>>) -> &'static str {\n    // Find the starting point 'S' and destination 'X'\n    let mut start = None;\n    let mut end = None;\n    \n    for i in 0..n {\n        for j in 0..m {\n            if grid[i][j] == 'S' {\n                start = Some((i, j));\n            }\n            if grid[i][j] == 'X' {\n                end = Some((i, j));\n            }\n            \n            if start.is_some() && end.is_some() {\n                break;\n            }\n        }\n        if start.is_some() && end.is_some() {\n            break;\n        }\n    }\n\n    let start = match start {\n        Some(pos) => pos,\n        None => return \"NO\",\n    };\n    \n    let end = match end {\n        Some(pos) => pos,\n        None => return \"NO\",\n    };\n\n    // Directions for moving in the grid (right, down, left, up)\n    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];\n\n    // BFS algorithm to find path from 'S' to 'X'\n    let mut queue = VecDeque::new();\n    queue.push_back(start);\n    \n    let mut visited = HashSet::new();\n    visited.insert(start);\n\n    while let Some((x, y)) = queue.pop_front() {\n        if (x, y) == end {\n            return \"YES\";\n        }\n\n        for &(dx, dy) in &directions {\n            let nx = x as i32 + dx;\n            let ny = y as i32 + dy;\n\n            if nx >= 0 && ny >= 0 {\n                let nx = nx as usize;\n                let ny = ny as usize;\n                \n                if nx < n && ny < m && grid[nx][ny] != '#' && !visited.contains(&(nx, ny)) {\n                    queue.push_back((nx, ny));\n                    visited.insert((nx, ny));\n                }\n            }\n        }\n    }\n\n    \"NO\"\n}\n#[test]\nfn test_can_reach_destination() {\n    // Test case 1: Path exists through open cells\n    assert_eq!(\n        can_reach_destination(\n            3, 3,\n            &vec![\n                vec!['S', '.', '.'],\n                vec!['#', '#', '.'],\n                vec!['.', '.', 'X'],\n            ]\n        ),\n        \"YES\"\n    );\n\n    // Test case 2: No path exists due to walls\n    assert_eq!(\n        can_reach_destination(\n            3, 3,\n            &vec![\n                vec!['S', '#', '.'],\n                vec!['#', '#', '.'],\n                vec!['.', '.', 'X'],\n            ]\n        ),\n        \"NO\"\n    );\n\n    // Test case 3: Direct path exists\n    assert_eq!(\n        can_reach_destination(\n            2, 2,\n            &vec![\n                vec!['S', 'X'],\n                vec!['.', '.'],\n            ]\n        ),\n        \"YES\"\n    );\n\n    // Test case 4: No path exists (completely blocked)\n    assert_eq!(\n        can_reach_destination(\n            2, 2,\n            &vec![\n                vec!['S', '#'],\n                vec!['#', 'X'],\n            ]\n        ),\n        \"NO\"\n    );\n\n    // Test case 5: No destination exists\n    assert_eq!(\n        can_reach_destination(\n            1, 1,\n            &vec![\n                vec!['S'],\n            ]\n        ),\n        \"NO\"\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{HashMap, VecDeque, HashSet};\n\n/// Determines the relationship between two employees in a hierarchy.\n///\n/// # Arguments\n/// * `report_list` - A slice of tuples where the first element is the manager and the second is the direct report.\n/// * `target_pair` - A tuple where we determine the relationship of the first employee to the second.\n///\n/// # Returns\n/// The relationship as a string slice: \"Manager\", \"Direct Report\", \"Indirect Report\", \"Colleague\", or \"None\".\nfn determine_relationship(report_list: &[(&str, &str)], target_pair: (&str, &str)) -> &'static str {\n    // Build a manager-to-reports mapping\n    let mut manager_dict: HashMap<&str, Vec<&str>> = HashMap::new();\n    for &(manager, report) in report_list {\n        manager_dict.entry(manager).or_default().push(report);\n    }\n\n    /// Breadth-first search to find the depth of relationship between employees\n    fn bfs(manager_dict: &HashMap<&str, Vec<&str>>, start: &str, target: &str) -> Option<usize> {\n        let mut queue = VecDeque::new();\n        let mut visited = HashSet::new();\n        queue.push_back((start, 0));\n        \n        while let Some((current, depth)) = queue.pop_front() {\n            if current == target {\n                return Some(depth);\n            }\n            visited.insert(current);\n            if let Some(reports) = manager_dict.get(current) {\n                for &next_employee in reports {\n                    if !visited.contains(next_employee) {\n                        queue.push_back((next_employee, depth + 1));\n                    }\n                }\n            }\n        }\n        None\n    }\n\n    let (employee1, employee2) = target_pair;\n\n    // Check for direct report relationship\n    if manager_dict.get(employee2)\n        .map_or(false, |reports| reports.contains(&employee1)) {\n        return \"Direct Report\";\n    }\n\n    // Check for indirect report relationship\n    if let Some(_) = bfs(&manager_dict, employee2, employee1) {\n        return \"Indirect Report\";\n    }\n\n    // Check for colleague relationship\n    for (manager, reports) in &manager_dict {\n        if reports.contains(&employee1) && reports.contains(&employee2) {\n            return \"Colleague\";\n        }\n    }\n\n    // Check for manager relationship\n    if bfs(&manager_dict, employee1, employee2) == Some(1) {\n        return \"Manager\";\n    }\n\n    // No relationship found\n    \"None\"\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 22065, "assertions": "#[test]\nfn test_determine_relationship() {\n    // Test case 1: Direct Report\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"B\", \"A\")\n        ),\n        \"Direct Report\"\n    );\n\n    // Test case 2: Indirect Report\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"C\", \"A\")\n        ),\n        \"Indirect Report\"\n    );\n\n    // Test case 3: Colleague\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"D\"), (\"C\", \"E\")],\n            (\"B\", \"C\")\n        ),\n        \"Colleague\"\n    );\n\n    // Test case 4: Manager\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"A\", \"B\")\n        ),\n        \"Manager\"\n    );\n\n    // Test case 5: None (no relationship)\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"A\", \"E\")\n        ),\n        \"None\"\n    );\n\n    // Test case 6: None (no relationship)\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")],\n            (\"A\", \"D\")\n        ),\n        \"None\"\n    );\n}", "all_code": "use std::collections::{HashMap, VecDeque, HashSet};\n\n/// Determines the relationship between two employees in a hierarchy.\n///\n/// # Arguments\n/// * `report_list` - A slice of tuples where the first element is the manager and the second is the direct report.\n/// * `target_pair` - A tuple where we determine the relationship of the first employee to the second.\n///\n/// # Returns\n/// The relationship as a string slice: \"Manager\", \"Direct Report\", \"Indirect Report\", \"Colleague\", or \"None\".\nfn determine_relationship(report_list: &[(&str, &str)], target_pair: (&str, &str)) -> &'static str {\n    // Build a manager-to-reports mapping\n    let mut manager_dict: HashMap<&str, Vec<&str>> = HashMap::new();\n    for &(manager, report) in report_list {\n        manager_dict.entry(manager).or_default().push(report);\n    }\n\n    /// Breadth-first search to find the depth of relationship between employees\n    fn bfs(manager_dict: &HashMap<&str, Vec<&str>>, start: &str, target: &str) -> Option<usize> {\n        let mut queue = VecDeque::new();\n        let mut visited = HashSet::new();\n        queue.push_back((start, 0));\n        \n        while let Some((current, depth)) = queue.pop_front() {\n            if current == target {\n                return Some(depth);\n            }\n            visited.insert(current);\n            if let Some(reports) = manager_dict.get(current) {\n                for &next_employee in reports {\n                    if !visited.contains(next_employee) {\n                        queue.push_back((next_employee, depth + 1));\n                    }\n                }\n            }\n        }\n        None\n    }\n\n    let (employee1, employee2) = target_pair;\n\n    // Check for direct report relationship\n    if manager_dict.get(employee2)\n        .map_or(false, |reports| reports.contains(&employee1)) {\n        return \"Direct Report\";\n    }\n\n    // Check for indirect report relationship\n    if let Some(_) = bfs(&manager_dict, employee2, employee1) {\n        return \"Indirect Report\";\n    }\n\n    // Check for colleague relationship\n    for (manager, reports) in &manager_dict {\n        if reports.contains(&employee1) && reports.contains(&employee2) {\n            return \"Colleague\";\n        }\n    }\n\n    // Check for manager relationship\n    if bfs(&manager_dict, employee1, employee2) == Some(1) {\n        return \"Manager\";\n    }\n\n    // No relationship found\n    \"None\"\n}\n#[test]\nfn test_determine_relationship() {\n    // Test case 1: Direct Report\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"B\", \"A\")\n        ),\n        \"Direct Report\"\n    );\n\n    // Test case 2: Indirect Report\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"C\", \"A\")\n        ),\n        \"Indirect Report\"\n    );\n\n    // Test case 3: Colleague\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"A\", \"C\"), (\"B\", \"D\"), (\"C\", \"E\")],\n            (\"B\", \"C\")\n        ),\n        \"Colleague\"\n    );\n\n    // Test case 4: Manager\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"A\", \"B\")\n        ),\n        \"Manager\"\n    );\n\n    // Test case 5: None (no relationship)\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"B\", \"D\"), (\"D\", \"E\")],\n            (\"A\", \"E\")\n        ),\n        \"None\"\n    );\n\n    // Test case 6: None (no relationship)\n    assert_eq!(\n        determine_relationship(\n            &[(\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")],\n            (\"A\", \"D\")\n        ),\n        \"None\"\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::cmp::{max, min};\n\n/// Determines if the array is k-diverse.\n/// A k-diverse array is one where the difference between the maximum\n/// and minimum values in any contiguous subarray of length k is ≤ k.\nfn is_k_diverse(arr: &[i32], k: usize) -> bool {\n    let n = arr.len();\n    if k == 1 {\n        return true;\n    }\n\n    for i in 0..(n - k + 1) {\n        let subarray = &arr[i..i + k];\n        let subarray_max = subarray.iter().max().unwrap();\n        let subarray_min = subarray.iter().min().unwrap();\n        if subarray_max - subarray_min > k as i32 {\n            return false;\n        }\n    }\n\n    true\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 17068, "assertions": "#[test]\nfn test_is_k_diverse() {\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 1), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 2), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 3), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 4), true);\n    assert_eq!(is_k_diverse(&[1, 5, 3, 4], 2), false);\n    assert_eq!(is_k_diverse(&[1, 5, 3, 4], 3), true);\n}", "all_code": "use std::cmp::{max, min};\n\n/// Determines if the array is k-diverse.\n/// A k-diverse array is one where the difference between the maximum\n/// and minimum values in any contiguous subarray of length k is ≤ k.\nfn is_k_diverse(arr: &[i32], k: usize) -> bool {\n    let n = arr.len();\n    if k == 1 {\n        return true;\n    }\n\n    for i in 0..(n - k + 1) {\n        let subarray = &arr[i..i + k];\n        let subarray_max = subarray.iter().max().unwrap();\n        let subarray_min = subarray.iter().min().unwrap();\n        if subarray_max - subarray_min > k as i32 {\n            return false;\n        }\n    }\n\n    true\n}\n#[test]\nfn test_is_k_diverse() {\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 1), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 2), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 3), true);\n    assert_eq!(is_k_diverse(&[1, 2, 3, 4], 4), true);\n    assert_eq!(is_k_diverse(&[1, 5, 3, 4], 2), false);\n    assert_eq!(is_k_diverse(&[1, 5, 3, 4], 3), true);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::HashMap;\n\n// Function to find the minimum number of edges to remove to split the graph into two connected components\n// using a Kruskal's algorithm approach with Union-Find (Disjoint Set Union)\nfn min_edges_to_remove(n: usize, m: usize, edges: &mut Vec<(usize, usize, i32)>) -> usize {\n    // Union-Find data structure implementation\n    struct UnionFind {\n        parent: Vec<usize>,\n        rank: Vec<usize>,\n    }\n\n    impl UnionFind {\n        fn new(size: usize) -> Self {\n            UnionFind {\n                parent: (0..size).collect(),\n                rank: vec![0; size],\n            }\n        }\n\n        fn find(&mut self, u: usize) -> usize {\n            if self.parent[u] != u {\n                self.parent[u] = self.find(self.parent[u]);\n            }\n            self.parent[u]\n        }\n\n        fn union(&mut self, u: usize, v: usize) {\n            let root_u = self.find(u);\n            let root_v = self.find(v);\n\n            if root_u != root_v {\n                if self.rank[root_u] > self.rank[root_v] {\n                    self.parent[root_v] = root_u;\n                } else if self.rank[root_u] < self.rank[root_v] {\n                    self.parent[root_u] = root_v;\n                } else {\n                    self.parent[root_v] = root_u;\n                    self.rank[root_u] += 1;\n                }\n            }\n        }\n    }\n\n    // Sort edges by weight in ascending order\n    edges.sort_by_key(|&(_, _, w)| w);\n\n    let mut uf = UnionFind::new(n + 1); // 1-based indexing\n    let mut mst_edges = Vec::new();\n\n    // Kruskal's algorithm to find MST\n    for &(u, v, w) in edges.iter() {\n        if uf.find(u) != uf.find(v) {\n            uf.union(u, v);\n            mst_edges.push((u, v, w));\n        }\n    }\n\n    // The answer is 1 if we have an MST, otherwise 0\n    if mst_edges.is_empty() { 0 } else { 1 }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 794, "assertions": "#[test]\nfn test_min_edges_to_remove() {\n    let test_cases = vec![\n        (\n            4,  // n\n            5,  // m\n            vec![(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (2, 4, 5)],  // edges\n            1   // expected result\n        ),\n        (\n            3,  // n\n            3,  // m\n            vec![(1, 2, 1), (2, 3, 2), (1, 3, 3)],  // edges\n            1   // expected result\n        ),\n        (\n            2,  // n\n            1,  // m\n            vec![(1, 2, 5)],  // edges\n            0   // expected result (already disconnected)\n        ),\n        (\n            5,  // n\n            7,  // m\n            vec![(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 5), (2, 5, 6), (3, 5, 7)],  // edges\n            1   // expected result\n        ),\n    ];\n\n    for (i, (n, m, mut edges, expected)) in test_cases.into_iter().enumerate() {\n        let result = min_edges_to_remove(n, m, &mut edges);\n        assert_eq!(result, expected, \"Test case {} failed\", i + 1);\n    }\n}", "all_code": "use std::collections::HashMap;\n\n// Function to find the minimum number of edges to remove to split the graph into two connected components\n// using a Kruskal's algorithm approach with Union-Find (Disjoint Set Union)\nfn min_edges_to_remove(n: usize, m: usize, edges: &mut Vec<(usize, usize, i32)>) -> usize {\n    // Union-Find data structure implementation\n    struct UnionFind {\n        parent: Vec<usize>,\n        rank: Vec<usize>,\n    }\n\n    impl UnionFind {\n        fn new(size: usize) -> Self {\n            UnionFind {\n                parent: (0..size).collect(),\n                rank: vec![0; size],\n            }\n        }\n\n        fn find(&mut self, u: usize) -> usize {\n            if self.parent[u] != u {\n                self.parent[u] = self.find(self.parent[u]);\n            }\n            self.parent[u]\n        }\n\n        fn union(&mut self, u: usize, v: usize) {\n            let root_u = self.find(u);\n            let root_v = self.find(v);\n\n            if root_u != root_v {\n                if self.rank[root_u] > self.rank[root_v] {\n                    self.parent[root_v] = root_u;\n                } else if self.rank[root_u] < self.rank[root_v] {\n                    self.parent[root_u] = root_v;\n                } else {\n                    self.parent[root_v] = root_u;\n                    self.rank[root_u] += 1;\n                }\n            }\n        }\n    }\n\n    // Sort edges by weight in ascending order\n    edges.sort_by_key(|&(_, _, w)| w);\n\n    let mut uf = UnionFind::new(n + 1); // 1-based indexing\n    let mut mst_edges = Vec::new();\n\n    // Kruskal's algorithm to find MST\n    for &(u, v, w) in edges.iter() {\n        if uf.find(u) != uf.find(v) {\n            uf.union(u, v);\n            mst_edges.push((u, v, w));\n        }\n    }\n\n    // The answer is 1 if we have an MST, otherwise 0\n    if mst_edges.is_empty() { 0 } else { 1 }\n}\n#[test]\nfn test_min_edges_to_remove() {\n    let test_cases = vec![\n        (\n            4,  // n\n            5,  // m\n            vec![(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (2, 4, 5)],  // edges\n            1   // expected result\n        ),\n        (\n            3,  // n\n            3,  // m\n            vec![(1, 2, 1), (2, 3, 2), (1, 3, 3)],  // edges\n            1   // expected result\n        ),\n        (\n            2,  // n\n            1,  // m\n            vec![(1, 2, 5)],  // edges\n            0   // expected result (already disconnected)\n        ),\n        (\n            5,  // n\n            7,  // m\n            vec![(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (1, 5, 5), (2, 5, 6), (3, 5, 7)],  // edges\n            1   // expected result\n        ),\n    ];\n\n    for (i, (n, m, mut edges, expected)) in test_cases.into_iter().enumerate() {\n        let result = min_edges_to_remove(n, m, &mut edges);\n        assert_eq!(result, expected, \"Test case {} failed\", i + 1);\n    }\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::fs::File;\nuse std::io::{Read, Write};\nuse std::path::Path;\n\n/// Replaces consecutive duplicate words in each line of a file with a given replacement word.\n/// \n/// # Arguments\n/// * `file_path` - Path to the text file to process\n/// * `replacement_word` - Word to replace consecutive duplicates with\n/// \n/// # Returns\n/// * `Result<(), std::io::Error>` - Returns Ok(()) on success, or an IO error if file operations fail\nfn replace_duplicate_words(file_path: &str, replacement_word: &str) -> Result<(), std::io::Error> {\n    // Read the entire file content\n    let mut file = File::open(file_path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n\n    // Process each line\n    let modified_lines: Vec<String> = contents.lines()\n        .map(|line| {\n            let words: Vec<&str> = line.split_whitespace().collect();\n            if words.is_empty() {\n                return line.to_string();\n            }\n\n            let mut new_words = Vec::new();\n            let mut i = 0;\n            while i < words.len() {\n                if i < words.len() - 1 && words[i] == words[i + 1] {\n                    new_words.push(replacement_word);\n                    while i < words.len() - 1 && words[i] == words[i + 1] {\n                        i += 1;\n                    }\n                } else {\n                    new_words.push(words[i]);\n                }\n                i += 1;\n            }\n            new_words.join(\" \")\n        })\n        .collect();\n\n    // Write the modified content back to the file\n    let mut file = File::create(file_path)?;\n    for line in modified_lines {\n        writeln!(file, \"{}\", line)?;\n    }\n\n    Ok(())\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 4631, "assertions": "#[test]\nfn test_replace_duplicate_words() {\n    use std::fs::File;\n    use std::io::{Read, Write};\n    use std::path::Path;\n\n    // Test case 1: Basic duplicates\n    let path1 = \"test1.txt\";\n    let content1 = \"hello hello world\\nthis is is a test\\n\";\n    let mut file = File::create(path1).unwrap();\n    writeln!(file, \"{}\", content1).unwrap();\n    replace_duplicate_words(path1, \"REPLACED\").unwrap();\n    let mut modified1 = String::new();\n    File::open(path1).unwrap().read_to_string(&mut modified1).unwrap();\n    assert_eq!(modified1, \"REPLACED world\\nthis REPLACED a test\\n\");\n    std::fs::remove_file(path1).unwrap();\n\n    // Test case 2: Multiple duplicates and single words\n    let path2 = \"test2.txt\";\n    let content2 = \"single\\nno duplicates here\\nword word word\\n\";\n    let mut file = File::create(path2).unwrap();\n    writeln!(file, \"{}\", content2).unwrap();\n    replace_duplicate_words(path2, \"X\").unwrap();\n    let mut modified2 = String::new();\n    File::open(path2).unwrap().read_to_string(&mut modified2).unwrap();\n    assert_eq!(modified2, \"single\\nno duplicates here\\nX\\n\");\n    std::fs::remove_file(path2).unwrap();\n\n    // Test case 3: Multiple spaces and duplicates\n    let path3 = \"test3.txt\";\n    let content3 = \"a a b b c c\\n  multiple   spaces  \\n\";\n    let mut file = File::create(path3).unwrap();\n    writeln!(file, \"{}\", content3).unwrap();\n    replace_duplicate_words(path3, \"DUPE\").unwrap();\n    let mut modified3 = String::new();\n    File::open(path3).unwrap().read_to_string(&mut modified3).unwrap();\n    assert_eq!(modified3, \"DUPE DUPE DUPE\\nmultiple spaces\\n\");\n    std::fs::remove_file(path3).unwrap();\n}", "all_code": "use std::fs::File;\nuse std::io::{Read, Write};\nuse std::path::Path;\n\n/// Replaces consecutive duplicate words in each line of a file with a given replacement word.\n/// \n/// # Arguments\n/// * `file_path` - Path to the text file to process\n/// * `replacement_word` - Word to replace consecutive duplicates with\n/// \n/// # Returns\n/// * `Result<(), std::io::Error>` - Returns Ok(()) on success, or an IO error if file operations fail\nfn replace_duplicate_words(file_path: &str, replacement_word: &str) -> Result<(), std::io::Error> {\n    // Read the entire file content\n    let mut file = File::open(file_path)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n\n    // Process each line\n    let modified_lines: Vec<String> = contents.lines()\n        .map(|line| {\n            let words: Vec<&str> = line.split_whitespace().collect();\n            if words.is_empty() {\n                return line.to_string();\n            }\n\n            let mut new_words = Vec::new();\n            let mut i = 0;\n            while i < words.len() {\n                if i < words.len() - 1 && words[i] == words[i + 1] {\n                    new_words.push(replacement_word);\n                    while i < words.len() - 1 && words[i] == words[i + 1] {\n                        i += 1;\n                    }\n                } else {\n                    new_words.push(words[i]);\n                }\n                i += 1;\n            }\n            new_words.join(\" \")\n        })\n        .collect();\n\n    // Write the modified content back to the file\n    let mut file = File::create(file_path)?;\n    for line in modified_lines {\n        writeln!(file, \"{}\", line)?;\n    }\n\n    Ok(())\n}\n#[test]\nfn test_replace_duplicate_words() {\n    use std::fs::File;\n    use std::io::{Read, Write};\n    use std::path::Path;\n\n    // Test case 1: Basic duplicates\n    let path1 = \"test1.txt\";\n    let content1 = \"hello hello world\\nthis is is a test\\n\";\n    let mut file = File::create(path1).unwrap();\n    writeln!(file, \"{}\", content1).unwrap();\n    replace_duplicate_words(path1, \"REPLACED\").unwrap();\n    let mut modified1 = String::new();\n    File::open(path1).unwrap().read_to_string(&mut modified1).unwrap();\n    assert_eq!(modified1, \"REPLACED world\\nthis REPLACED a test\\n\");\n    std::fs::remove_file(path1).unwrap();\n\n    // Test case 2: Multiple duplicates and single words\n    let path2 = \"test2.txt\";\n    let content2 = \"single\\nno duplicates here\\nword word word\\n\";\n    let mut file = File::create(path2).unwrap();\n    writeln!(file, \"{}\", content2).unwrap();\n    replace_duplicate_words(path2, \"X\").unwrap();\n    let mut modified2 = String::new();\n    File::open(path2).unwrap().read_to_string(&mut modified2).unwrap();\n    assert_eq!(modified2, \"single\\nno duplicates here\\nX\\n\");\n    std::fs::remove_file(path2).unwrap();\n\n    // Test case 3: Multiple spaces and duplicates\n    let path3 = \"test3.txt\";\n    let content3 = \"a a b b c c\\n  multiple   spaces  \\n\";\n    let mut file = File::create(path3).unwrap();\n    writeln!(file, \"{}\", content3).unwrap();\n    replace_duplicate_words(path3, \"DUPE\").unwrap();\n    let mut modified3 = String::new();\n    File::open(path3).unwrap().read_to_string(&mut modified3).unwrap();\n    assert_eq!(modified3, \"DUPE DUPE DUPE\\nmultiple spaces\\n\");\n    std::fs::remove_file(path3).unwrap();\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn max_subarray_sum_2d(matrix: &[Vec<i32>]) -> i32 {\n    /// Computes the maximum subarray sum for a 1D array using Kadane's algorithm\n    fn max_subarray_sum_1d(arr: &[i32]) -> i32 {\n        let mut max_sum = arr[0];\n        let mut current_sum = arr[0];\n        \n        for &num in &arr[1..] {\n            current_sum = num.max(current_sum + num);\n            max_sum = max_sum.max(current_sum);\n        }\n        \n        max_sum\n    }\n\n    let mut max_sum = i32::MIN;\n    \n    // Check all row-wise subarrays\n    for row in matrix {\n        let row_max = max_subarray_sum_1d(row);\n        max_sum = max_sum.max(row_max);\n    }\n    \n    // Check all column-wise subarrays if matrix has at least one row\n    if !matrix.is_empty() {\n        for col in 0..matrix[0].len() {\n            let col_array: Vec<i32> = matrix.iter().map(|row| row[col]).collect();\n            let col_max = max_subarray_sum_1d(&col_array);\n            max_sum = max_sum.max(col_max);\n        }\n    }\n    \n    max_sum\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 21606, "assertions": "#[test]\nfn test_max_subarray_sum_2d() {\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, 2, -1, -4, -20],\n            vec![-8, -3, 4, 2, 1],\n            vec![3, 8, 10, 1, 3],\n            vec![-4, -1, 1, 7, -6],\n        ]),\n        29\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![-1, -2, -3],\n            vec![-4, -5, -6],\n        ]),\n        -1\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n        ]),\n        21\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![0, 0, 0],\n            vec![0, 0, 0],\n        ]),\n        0\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, -2, 3],\n            vec![-4, 5, -6],\n            vec![7, -8, 9],\n        ]),\n        16\n    );\n}", "all_code": "fn max_subarray_sum_2d(matrix: &[Vec<i32>]) -> i32 {\n    /// Computes the maximum subarray sum for a 1D array using Kadane's algorithm\n    fn max_subarray_sum_1d(arr: &[i32]) -> i32 {\n        let mut max_sum = arr[0];\n        let mut current_sum = arr[0];\n        \n        for &num in &arr[1..] {\n            current_sum = num.max(current_sum + num);\n            max_sum = max_sum.max(current_sum);\n        }\n        \n        max_sum\n    }\n\n    let mut max_sum = i32::MIN;\n    \n    // Check all row-wise subarrays\n    for row in matrix {\n        let row_max = max_subarray_sum_1d(row);\n        max_sum = max_sum.max(row_max);\n    }\n    \n    // Check all column-wise subarrays if matrix has at least one row\n    if !matrix.is_empty() {\n        for col in 0..matrix[0].len() {\n            let col_array: Vec<i32> = matrix.iter().map(|row| row[col]).collect();\n            let col_max = max_subarray_sum_1d(&col_array);\n            max_sum = max_sum.max(col_max);\n        }\n    }\n    \n    max_sum\n}\n#[test]\nfn test_max_subarray_sum_2d() {\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, 2, -1, -4, -20],\n            vec![-8, -3, 4, 2, 1],\n            vec![3, 8, 10, 1, 3],\n            vec![-4, -1, 1, 7, -6],\n        ]),\n        29\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![-1, -2, -3],\n            vec![-4, -5, -6],\n        ]),\n        -1\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, 2, 3],\n            vec![4, 5, 6],\n        ]),\n        21\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![0, 0, 0],\n            vec![0, 0, 0],\n        ]),\n        0\n    );\n    assert_eq!(\n        max_subarray_sum_2d(&[\n            vec![1, -2, 3],\n            vec![-4, 5, -6],\n            vec![7, -8, 9],\n        ]),\n        16\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn transform_character(c: char) -> char {\n    // Transforms a single character according to the rules:\n    // - Digits: increment by 1, wrapping around after 9\n    // - Letters: increment by 1, wrapping around after 'z'\n    // - Other characters remain unchanged\n    if c.is_ascii_digit() {\n        let digit = c.to_digit(10).unwrap();\n        char::from_digit((digit + 1) % 10, 10).unwrap()\n    } else if c.is_ascii_alphabetic() {\n        if c == 'z' {\n            'a'\n        } else if c == 'Z' {\n            'A'\n        } else {\n            ((c as u8) + 1) as char\n        }\n    } else {\n        c\n    }\n}\n\nfn transform_grid(grid: Vec<String>) -> Vec<String> {\n    // Transforms each character in the grid according to transform_character rules\n    grid.into_iter()\n        .map(|row| row.chars().map(transform_character).collect())\n        .collect()\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 8384, "assertions": "#[test]\nfn test_transform_grid() {\n    // Test case 1: Mixed characters\n    assert_eq!(\n        transform_grid(vec![\n            \"abc123\".to_string(),\n            \"xyz987\".to_string(),\n            \"!@#$%^\".to_string(),\n        ]),\n        vec![\n            \"bcd234\".to_string(),\n            \"yz0988\".to_string(),\n            \"!@#$%^\".to_string(),\n        ]\n    );\n\n    // Test case 2: Edge cases with wrapping\n    assert_eq!(\n        transform_grid(vec![\n            \"000000\".to_string(),\n            \"999999\".to_string(),\n            \"ZZZZZZ\".to_string(),\n            \"zzzzzz\".to_string(),\n        ]),\n        vec![\n            \"111111\".to_string(),\n            \"000000\".to_string(),\n            \"AAAAAA\".to_string(),\n            \"aaaaaa\".to_string(),\n        ]\n    );\n\n    // Test case 3: Alternating characters\n    assert_eq!(\n        transform_grid(vec![\n            \"a1b2c3\".to_string(),\n            \"x9y8z7\".to_string(),\n            \"A0B0C0\".to_string(),\n        ]),\n        vec![\n            \"b2c3d4\".to_string(),\n            \"y0z9a8\".to_string(),\n            \"B1C1D1\".to_string(),\n        ]\n    );\n}", "all_code": "fn transform_character(c: char) -> char {\n    // Transforms a single character according to the rules:\n    // - Digits: increment by 1, wrapping around after 9\n    // - Letters: increment by 1, wrapping around after 'z'\n    // - Other characters remain unchanged\n    if c.is_ascii_digit() {\n        let digit = c.to_digit(10).unwrap();\n        char::from_digit((digit + 1) % 10, 10).unwrap()\n    } else if c.is_ascii_alphabetic() {\n        if c == 'z' {\n            'a'\n        } else if c == 'Z' {\n            'A'\n        } else {\n            ((c as u8) + 1) as char\n        }\n    } else {\n        c\n    }\n}\n\nfn transform_grid(grid: Vec<String>) -> Vec<String> {\n    // Transforms each character in the grid according to transform_character rules\n    grid.into_iter()\n        .map(|row| row.chars().map(transform_character).collect())\n        .collect()\n}\n#[test]\nfn test_transform_grid() {\n    // Test case 1: Mixed characters\n    assert_eq!(\n        transform_grid(vec![\n            \"abc123\".to_string(),\n            \"xyz987\".to_string(),\n            \"!@#$%^\".to_string(),\n        ]),\n        vec![\n            \"bcd234\".to_string(),\n            \"yz0988\".to_string(),\n            \"!@#$%^\".to_string(),\n        ]\n    );\n\n    // Test case 2: Edge cases with wrapping\n    assert_eq!(\n        transform_grid(vec![\n            \"000000\".to_string(),\n            \"999999\".to_string(),\n            \"ZZZZZZ\".to_string(),\n            \"zzzzzz\".to_string(),\n        ]),\n        vec![\n            \"111111\".to_string(),\n            \"000000\".to_string(),\n            \"AAAAAA\".to_string(),\n            \"aaaaaa\".to_string(),\n        ]\n    );\n\n    // Test case 3: Alternating characters\n    assert_eq!(\n        transform_grid(vec![\n            \"a1b2c3\".to_string(),\n            \"x9y8z7\".to_string(),\n            \"A0B0C0\".to_string(),\n        ]),\n        vec![\n            \"b2c3d4\".to_string(),\n            \"y0z9a8\".to_string(),\n            \"B1C1D1\".to_string(),\n        ]\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Define a Product struct to represent product information\nstruct Product {\n    name: String,\n    price: f64,\n    quantity: i32,\n}\n\n/// Calculates the total price of all products by multiplying each product's price by its quantity\n/// and summing up all these values.\n///\n/// # Arguments\n///\n/// * `products` - A slice of Product structs containing name, price, and quantity\n///\n/// # Returns\n///\n/// The total price of all products as a floating-point number\nfn calculate_total_price(products: &[Product]) -> f64 {\n    let mut total_price = 0.0;\n    for product in products {\n        total_price += product.price * product.quantity as f64;\n    }\n    total_price\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 20110, "assertions": "#[test]\nfn test_calculate_total_price() {\n    // Test case 1: Single product\n    let test_case1 = vec![\n        Product {\n            name: String::from(\"Apple\"),\n            price: 1.50,\n            quantity: 3,\n        }\n    ];\n    assert_eq!(calculate_total_price(&test_case1), 4.50);\n\n    // Test case 2: Multiple products\n    let test_case2 = vec![\n        Product {\n            name: String::from(\"Apple\"),\n            price: 1.50,\n            quantity: 3,\n        },\n        Product {\n            name: String::from(\"Banana\"),\n            price: 0.75,\n            quantity: 5,\n        },\n        Product {\n            name: String::from(\"Orange\"),\n            price: 1.25,\n            quantity: 2,\n        },\n    ];\n    assert_eq!(calculate_total_price(&test_case2), 9.25);\n\n    // Test case 3: Empty product list\n    let test_case3: Vec<Product> = vec![];\n    assert_eq!(calculate_total_price(&test_case3), 0.0);\n\n    // Test case 4: Products with zero quantity\n    let test_case4 = vec![\n        Product {\n            name: String::from(\"Expired Milk\"),\n            price: 2.99,\n            quantity: 0,\n        }\n    ];\n    assert_eq!(calculate_total_price(&test_case4), 0.0);\n}", "all_code": "// Define a Product struct to represent product information\nstruct Product {\n    name: String,\n    price: f64,\n    quantity: i32,\n}\n\n/// Calculates the total price of all products by multiplying each product's price by its quantity\n/// and summing up all these values.\n///\n/// # Arguments\n///\n/// * `products` - A slice of Product structs containing name, price, and quantity\n///\n/// # Returns\n///\n/// The total price of all products as a floating-point number\nfn calculate_total_price(products: &[Product]) -> f64 {\n    let mut total_price = 0.0;\n    for product in products {\n        total_price += product.price * product.quantity as f64;\n    }\n    total_price\n}\n#[test]\nfn test_calculate_total_price() {\n    // Test case 1: Single product\n    let test_case1 = vec![\n        Product {\n            name: String::from(\"Apple\"),\n            price: 1.50,\n            quantity: 3,\n        }\n    ];\n    assert_eq!(calculate_total_price(&test_case1), 4.50);\n\n    // Test case 2: Multiple products\n    let test_case2 = vec![\n        Product {\n            name: String::from(\"Apple\"),\n            price: 1.50,\n            quantity: 3,\n        },\n        Product {\n            name: String::from(\"Banana\"),\n            price: 0.75,\n            quantity: 5,\n        },\n        Product {\n            name: String::from(\"Orange\"),\n            price: 1.25,\n            quantity: 2,\n        },\n    ];\n    assert_eq!(calculate_total_price(&test_case2), 9.25);\n\n    // Test case 3: Empty product list\n    let test_case3: Vec<Product> = vec![];\n    assert_eq!(calculate_total_price(&test_case3), 0.0);\n\n    // Test case 4: Products with zero quantity\n    let test_case4 = vec![\n        Product {\n            name: String::from(\"Expired Milk\"),\n            price: 2.99,\n            quantity: 0,\n        }\n    ];\n    assert_eq!(calculate_total_price(&test_case4), 0.0);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Calculate the mean squared error between two lists of numbers.\n// \n// # Arguments\n// * `predictions` - A slice of predicted values as floating-point numbers.\n// * `actuals` - A slice of actual values as floating-point numbers.\n//\n// # Returns\n// The mean squared error between the predicted and actual values.\nfn mean_squared_error(predictions: &[f64], actuals: &[f64]) -> f64 {\n    let n = predictions.len() as f64;\n    let total_error: f64 = predictions.iter()\n        .zip(actuals.iter())\n        .map(|(&p, &a)| (p - a).powi(2))\n        .sum();\n    total_error / n\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 987, "assertions": "#[test]\nfn test_mean_squared_error() {\n    // Perfect prediction\n    assert_eq!(mean_squared_error(&[1.0, 2.0, 3.0], &[1.0, 2.0, 3.0]), 0.0);\n    // Off by 1\n    assert_eq!(mean_squared_error(&[1.0, 2.0, 3.0], &[2.0, 3.0, 4.0]), 1.0);\n    // All wrong\n    assert_eq!(mean_squared_error(&[0.0, 0.0, 0.0], &[1.0, 2.0, 3.0]), 14.0 / 3.0);\n}", "all_code": "// Calculate the mean squared error between two lists of numbers.\n// \n// # Arguments\n// * `predictions` - A slice of predicted values as floating-point numbers.\n// * `actuals` - A slice of actual values as floating-point numbers.\n//\n// # Returns\n// The mean squared error between the predicted and actual values.\nfn mean_squared_error(predictions: &[f64], actuals: &[f64]) -> f64 {\n    let n = predictions.len() as f64;\n    let total_error: f64 = predictions.iter()\n        .zip(actuals.iter())\n        .map(|(&p, &a)| (p - a).powi(2))\n        .sum();\n    total_error / n\n}\n#[test]\nfn test_mean_squared_error() {\n    // Perfect prediction\n    assert_eq!(mean_squared_error(&[1.0, 2.0, 3.0], &[1.0, 2.0, 3.0]), 0.0);\n    // Off by 1\n    assert_eq!(mean_squared_error(&[1.0, 2.0, 3.0], &[2.0, 3.0, 4.0]), 1.0);\n    // All wrong\n    assert_eq!(mean_squared_error(&[0.0, 0.0, 0.0], &[1.0, 2.0, 3.0]), 14.0 / 3.0);\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::{HashMap, HashSet, VecDeque};\n\n/// Checks if it's possible to complete a circular flight tour visiting all cities.\n/// A tour is possible if:\n/// 1. Each city has equal in-degree and out-degree\n/// 2. The graph is strongly connected (all cities are reachable from any starting city)\nfn can_complete_tour(n: usize, flights: &[(usize, usize)]) -> &'static str {\n    // If there are no flights, a tour is not possible\n    if n == 0 {\n        return \"NO\";\n    }\n\n    // Create adjacency list and track degrees\n    let mut graph: HashMap<usize, Vec<usize>> = HashMap::new();\n    let mut in_degree: HashMap<usize, usize> = HashMap::new();\n    let mut out_degree: HashMap<usize, usize> = HashMap::new();\n    let mut cities = HashSet::new();\n\n    for &(src, dest) in flights {\n        graph.entry(src).or_default().push(dest);\n        *out_degree.entry(src).or_default() += 1;\n        *in_degree.entry(dest).or_default() += 1;\n        cities.insert(src);\n        cities.insert(dest);\n    }\n\n    // Check if each city has equal in-degree and out-degree\n    for &city in &cities {\n        if in_degree.get(&city).unwrap_or(&0) != out_degree.get(&city).unwrap_or(&0) {\n            return \"NO\";\n        }\n    }\n\n    // Perform BFS to check connectivity\n    fn bfs(start_city: usize, graph: &HashMap<usize, Vec<usize>>) -> HashSet<usize> {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        queue.push_back(start_city);\n        \n        while let Some(city) = queue.pop_front() {\n            if visited.insert(city) {\n                if let Some(neighbors) = graph.get(&city) {\n                    for &neighbor in neighbors {\n                        if !visited.contains(&neighbor) {\n                            queue.push_back(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        visited\n    }\n\n    // Pick any starting city\n    let start_city = *cities.iter().next().unwrap();\n    let visited_cities = bfs(start_city, &graph);\n\n    if visited_cities.len() == cities.len() {\n        \"YES\"\n    } else {\n        \"NO\"\n    }\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 286, "assertions": "#[test]\nfn test_can_complete_tour() {\n    assert_eq!(\n        can_complete_tour(3, &[(0, 1), (1, 2), (2, 0)]),\n        \"YES\"  // Complete cycle\n    );\n    assert_eq!(\n        can_complete_tour(4, &[(0, 1), (1, 2), (2, 3), (3, 0)]),\n        \"YES\"  // Complete cycle\n    );\n    assert_eq!(\n        can_complete_tour(3, &[(0, 1), (1, 2), (2, 1)]),\n        \"NO\"   // In-degree != out-degree for city 1\n    );\n    assert_eq!(\n        can_complete_tour(4, &[(0, 1), (1, 2), (2, 0), (0, 3)]),\n        \"NO\"   // City 3 is not strongly connected\n    );\n    assert_eq!(\n        can_complete_tour(0, &[]),\n        \"NO\"   // No cities\n    );\n    assert_eq!(\n        can_complete_tour(1, &[]),\n        \"NO\"   // Single city but no flights\n    );\n    assert_eq!(\n        can_complete_tour(1, &[(0, 0)]),\n        \"YES\"  // Single city with self-loop\n    );\n}", "all_code": "use std::collections::{HashMap, HashSet, VecDeque};\n\n/// Checks if it's possible to complete a circular flight tour visiting all cities.\n/// A tour is possible if:\n/// 1. Each city has equal in-degree and out-degree\n/// 2. The graph is strongly connected (all cities are reachable from any starting city)\nfn can_complete_tour(n: usize, flights: &[(usize, usize)]) -> &'static str {\n    // If there are no flights, a tour is not possible\n    if n == 0 {\n        return \"NO\";\n    }\n\n    // Create adjacency list and track degrees\n    let mut graph: HashMap<usize, Vec<usize>> = HashMap::new();\n    let mut in_degree: HashMap<usize, usize> = HashMap::new();\n    let mut out_degree: HashMap<usize, usize> = HashMap::new();\n    let mut cities = HashSet::new();\n\n    for &(src, dest) in flights {\n        graph.entry(src).or_default().push(dest);\n        *out_degree.entry(src).or_default() += 1;\n        *in_degree.entry(dest).or_default() += 1;\n        cities.insert(src);\n        cities.insert(dest);\n    }\n\n    // Check if each city has equal in-degree and out-degree\n    for &city in &cities {\n        if in_degree.get(&city).unwrap_or(&0) != out_degree.get(&city).unwrap_or(&0) {\n            return \"NO\";\n        }\n    }\n\n    // Perform BFS to check connectivity\n    fn bfs(start_city: usize, graph: &HashMap<usize, Vec<usize>>) -> HashSet<usize> {\n        let mut visited = HashSet::new();\n        let mut queue = VecDeque::new();\n        queue.push_back(start_city);\n        \n        while let Some(city) = queue.pop_front() {\n            if visited.insert(city) {\n                if let Some(neighbors) = graph.get(&city) {\n                    for &neighbor in neighbors {\n                        if !visited.contains(&neighbor) {\n                            queue.push_back(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        visited\n    }\n\n    // Pick any starting city\n    let start_city = *cities.iter().next().unwrap();\n    let visited_cities = bfs(start_city, &graph);\n\n    if visited_cities.len() == cities.len() {\n        \"YES\"\n    } else {\n        \"NO\"\n    }\n}\n#[test]\nfn test_can_complete_tour() {\n    assert_eq!(\n        can_complete_tour(3, &[(0, 1), (1, 2), (2, 0)]),\n        \"YES\"  // Complete cycle\n    );\n    assert_eq!(\n        can_complete_tour(4, &[(0, 1), (1, 2), (2, 3), (3, 0)]),\n        \"YES\"  // Complete cycle\n    );\n    assert_eq!(\n        can_complete_tour(3, &[(0, 1), (1, 2), (2, 1)]),\n        \"NO\"   // In-degree != out-degree for city 1\n    );\n    assert_eq!(\n        can_complete_tour(4, &[(0, 1), (1, 2), (2, 0), (0, 3)]),\n        \"NO\"   // City 3 is not strongly connected\n    );\n    assert_eq!(\n        can_complete_tour(0, &[]),\n        \"NO\"   // No cities\n    );\n    assert_eq!(\n        can_complete_tour(1, &[]),\n        \"NO\"   // Single city but no flights\n    );\n    assert_eq!(\n        can_complete_tour(1, &[(0, 0)]),\n        \"YES\"  // Single city with self-loop\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::VecDeque;\n\n/// Checks if a word can be typed on a keyboard where each subsequent character must be adjacent\n/// (including diagonally) to the previous one, without reusing the same key.\n///\n/// # Arguments\n/// * `n` - Number of rows in the keyboard\n/// * `m` - Number of columns in the keyboard\n/// * `keyboard` - 2D vector representing the keyboard layout\n/// * `word` - The word to check if it can be typed\n///\n/// # Returns\n/// * `bool` - True if the word can be typed, false otherwise\nfn can_type_word(n: usize, m: usize, keyboard: &mut Vec<Vec<char>>, word: &str) -> bool {\n    // Define all 8 possible movement directions (including diagonals)\n    let directions = [\n        (-1, 0), (1, 0), (0, -1), (0, 1),\n        (-1, -1), (-1, 1), (1, -1), (1, 1)\n    ];\n\n    // Check if coordinates are within keyboard bounds\n    let is_valid = |x: i32, y: i32| -> bool {\n        x >= 0 && x < n as i32 && y >= 0 && y < m as i32\n    };\n\n    // Depth-first search to find the word path\n    fn dfs(\n        x: usize,\n        y: usize,\n        word_idx: usize,\n        word: &[char],\n        keyboard: &mut Vec<Vec<char>>,\n        directions: &[(i32, i32); 8],\n        is_valid: &dyn Fn(i32, i32) -> bool,\n    ) -> bool {\n        if word_idx == word.len() {\n            return true;\n        }\n\n        let temp = keyboard[x][y];\n        keyboard[x][y] = '#'; // Mark as visited\n\n        for &(dx, dy) in directions {\n            let new_x = x as i32 + dx;\n            let new_y = y as i32 + dy;\n\n            if is_valid(new_x, new_y) {\n                let new_x = new_x as usize;\n                let new_y = new_y as usize;\n                if keyboard[new_x][new_y] == word[word_idx] {\n                    if dfs(new_x, new_y, word_idx + 1, word, keyboard, directions, is_valid) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        keyboard[x][y] = temp; // Unmark\n        false\n    }\n\n    let word_chars: Vec<char> = word.chars().collect();\n    if word_chars.is_empty() {\n        return true;\n    }\n\n    // Check each cell for the first character of the word\n    for row in 0..n {\n        for col in 0..m {\n            if keyboard[row][col] == word_chars[0] {\n                if dfs(row, col, 1, &word_chars, keyboard, &directions, &is_valid) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    false\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 3392, "assertions": "#[test]\nfn test_can_type_word() {\n    let mut keyboard1 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard1, \"abc\"), true);\n    \n    let mut keyboard2 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard2, \"abe\"), true);\n    \n    let mut keyboard3 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard3, \"abf\"), false);\n    \n    let mut keyboard4 = vec![\n        vec!['a', 'b'],\n        vec!['c', 'd'],\n    ];\n    assert_eq!(can_type_word(2, 2, &mut keyboard4, \"abcd\"), true);\n    \n    let mut keyboard5 = vec![\n        vec!['a', 'b'],\n        vec!['c', 'd'],\n    ];\n    assert_eq!(can_type_word(2, 2, &mut keyboard5, \"abab\"), false);\n}", "all_code": "use std::collections::VecDeque;\n\n/// Checks if a word can be typed on a keyboard where each subsequent character must be adjacent\n/// (including diagonally) to the previous one, without reusing the same key.\n///\n/// # Arguments\n/// * `n` - Number of rows in the keyboard\n/// * `m` - Number of columns in the keyboard\n/// * `keyboard` - 2D vector representing the keyboard layout\n/// * `word` - The word to check if it can be typed\n///\n/// # Returns\n/// * `bool` - True if the word can be typed, false otherwise\nfn can_type_word(n: usize, m: usize, keyboard: &mut Vec<Vec<char>>, word: &str) -> bool {\n    // Define all 8 possible movement directions (including diagonals)\n    let directions = [\n        (-1, 0), (1, 0), (0, -1), (0, 1),\n        (-1, -1), (-1, 1), (1, -1), (1, 1)\n    ];\n\n    // Check if coordinates are within keyboard bounds\n    let is_valid = |x: i32, y: i32| -> bool {\n        x >= 0 && x < n as i32 && y >= 0 && y < m as i32\n    };\n\n    // Depth-first search to find the word path\n    fn dfs(\n        x: usize,\n        y: usize,\n        word_idx: usize,\n        word: &[char],\n        keyboard: &mut Vec<Vec<char>>,\n        directions: &[(i32, i32); 8],\n        is_valid: &dyn Fn(i32, i32) -> bool,\n    ) -> bool {\n        if word_idx == word.len() {\n            return true;\n        }\n\n        let temp = keyboard[x][y];\n        keyboard[x][y] = '#'; // Mark as visited\n\n        for &(dx, dy) in directions {\n            let new_x = x as i32 + dx;\n            let new_y = y as i32 + dy;\n\n            if is_valid(new_x, new_y) {\n                let new_x = new_x as usize;\n                let new_y = new_y as usize;\n                if keyboard[new_x][new_y] == word[word_idx] {\n                    if dfs(new_x, new_y, word_idx + 1, word, keyboard, directions, is_valid) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        keyboard[x][y] = temp; // Unmark\n        false\n    }\n\n    let word_chars: Vec<char> = word.chars().collect();\n    if word_chars.is_empty() {\n        return true;\n    }\n\n    // Check each cell for the first character of the word\n    for row in 0..n {\n        for col in 0..m {\n            if keyboard[row][col] == word_chars[0] {\n                if dfs(row, col, 1, &word_chars, keyboard, &directions, &is_valid) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    false\n}\n#[test]\nfn test_can_type_word() {\n    let mut keyboard1 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard1, \"abc\"), true);\n    \n    let mut keyboard2 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard2, \"abe\"), true);\n    \n    let mut keyboard3 = vec![\n        vec!['a', 'b', 'c'],\n        vec!['d', 'e', 'f'],\n        vec!['g', 'h', 'i'],\n    ];\n    assert_eq!(can_type_word(3, 3, &mut keyboard3, \"abf\"), false);\n    \n    let mut keyboard4 = vec![\n        vec!['a', 'b'],\n        vec!['c', 'd'],\n    ];\n    assert_eq!(can_type_word(2, 2, &mut keyboard4, \"abcd\"), true);\n    \n    let mut keyboard5 = vec![\n        vec!['a', 'b'],\n        vec!['c', 'd'],\n    ];\n    assert_eq!(can_type_word(2, 2, &mut keyboard5, \"abab\"), false);\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "fn top_k_average(scores: &[i32], k: usize) -> f64 {\n    // Returns the average of the top K scores in the given list.\n    // If there are fewer than K scores, returns the average of all the scores present.\n    //\n    // Args:\n    // scores: Slice of integer scores.\n    // k: The number of top scores to consider for the average.\n    //\n    // Returns:\n    // The average of the top K scores as a floating-point number.\n\n    if scores.is_empty() {\n        return 0.0;\n    }\n\n    let k = k.min(scores.len()); // Ensure K does not exceed the length of the scores slice\n\n    // Create a mutable vector to sort the scores in descending order\n    let mut sorted_scores = scores.to_vec();\n    sorted_scores.sort_by(|a, b| b.cmp(a)); // Sort in descending order\n\n    // Take the top K scores\n    let top_k_scores = &sorted_scores[..k];\n\n    // Calculate the average of the top K scores\n    let sum: i32 = top_k_scores.iter().sum();\n    let average = sum as f64 / k as f64;\n\n    average\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 16271, "assertions": "#[test]\nfn test_top_k_average() {\n    assert_eq!(top_k_average(&[90, 80, 70, 60, 50], 3), 80.0);\n    assert_eq!(top_k_average(&[100, 90, 80], 5), 90.0);\n    assert_eq!(top_k_average(&[], 3), 0.0);\n    assert_eq!(top_k_average(&[85, 75, 95, 65, 55], 1), 95.0);\n}", "all_code": "fn top_k_average(scores: &[i32], k: usize) -> f64 {\n    // Returns the average of the top K scores in the given list.\n    // If there are fewer than K scores, returns the average of all the scores present.\n    //\n    // Args:\n    // scores: Slice of integer scores.\n    // k: The number of top scores to consider for the average.\n    //\n    // Returns:\n    // The average of the top K scores as a floating-point number.\n\n    if scores.is_empty() {\n        return 0.0;\n    }\n\n    let k = k.min(scores.len()); // Ensure K does not exceed the length of the scores slice\n\n    // Create a mutable vector to sort the scores in descending order\n    let mut sorted_scores = scores.to_vec();\n    sorted_scores.sort_by(|a, b| b.cmp(a)); // Sort in descending order\n\n    // Take the top K scores\n    let top_k_scores = &sorted_scores[..k];\n\n    // Calculate the average of the top K scores\n    let sum: i32 = top_k_scores.iter().sum();\n    let average = sum as f64 / k as f64;\n\n    average\n}\n#[test]\nfn test_top_k_average() {\n    assert_eq!(top_k_average(&[90, 80, 70, 60, 50], 3), 80.0);\n    assert_eq!(top_k_average(&[100, 90, 80], 5), 90.0);\n    assert_eq!(top_k_average(&[], 3), 0.0);\n    assert_eq!(top_k_average(&[85, 75, 95, 65, 55], 1), 95.0);\n}", "exec_outcome": "PASSED"}
{"code": "// Function to compute the maximum product of any two distinct elements in a list of integers.\n// The function first checks if the list has at least two elements, then sorts the list.\n// The maximum product can be either from the two largest positive numbers or from the two smallest negative numbers.\nfn max_product_of_two(nums: &[i32]) -> Result<i32, String> {\n    if nums.len() < 2 {\n        return Err(\"At least two elements are required\".to_string());\n    }\n\n    let mut sorted_nums = nums.to_vec();\n    sorted_nums.sort();\n\n    let product_first_two = sorted_nums[0] * sorted_nums[1];\n    let product_last_two = sorted_nums[sorted_nums.len() - 1] * sorted_nums[sorted_nums.len() - 2];\n\n    Ok(std::cmp::max(product_first_two, product_last_two))\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 10376, "assertions": "#[test]\nfn test_max_product_of_two() {\n    assert_eq!(max_product_of_two(&[1, 2, 3, 4]), Ok(12));\n    assert_eq!(max_product_of_two(&[-10, -3, 5, 6]), Ok(30));\n    assert_eq!(max_product_of_two(&[-5, -4, 0, 3, 7]), Ok(20));\n    assert_eq!(\n        max_product_of_two(&[1]),\n        Err(\"At least two elements are required\".to_string())\n    );\n}", "all_code": "// Function to compute the maximum product of any two distinct elements in a list of integers.\n// The function first checks if the list has at least two elements, then sorts the list.\n// The maximum product can be either from the two largest positive numbers or from the two smallest negative numbers.\nfn max_product_of_two(nums: &[i32]) -> Result<i32, String> {\n    if nums.len() < 2 {\n        return Err(\"At least two elements are required\".to_string());\n    }\n\n    let mut sorted_nums = nums.to_vec();\n    sorted_nums.sort();\n\n    let product_first_two = sorted_nums[0] * sorted_nums[1];\n    let product_last_two = sorted_nums[sorted_nums.len() - 1] * sorted_nums[sorted_nums.len() - 2];\n\n    Ok(std::cmp::max(product_first_two, product_last_two))\n}\n#[test]\nfn test_max_product_of_two() {\n    assert_eq!(max_product_of_two(&[1, 2, 3, 4]), Ok(12));\n    assert_eq!(max_product_of_two(&[-10, -3, 5, 6]), Ok(30));\n    assert_eq!(max_product_of_two(&[-5, -4, 0, 3, 7]), Ok(20));\n    assert_eq!(\n        max_product_of_two(&[1]),\n        Err(\"At least two elements are required\".to_string())\n    );\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "use std::collections::VecDeque;\n\n// Solves a maze represented as a 2D grid of characters\n// 'S' represents the start, 'E' represents the end\n// '#' represents walls, '.' represents open paths\n// Returns true if there's a path from 'S' to 'E', false otherwise\nfn maze_solver(maze: &[Vec<char>]) -> bool {\n    // Finds the coordinates of 'S' (start) and 'E' (end) in the maze\n    fn find_start_end(maze: &[Vec<char>]) -> (Option<(usize, usize)>, Option<(usize, usize)>) {\n        let mut start = None;\n        let mut end = None;\n        \n        for (i, row) in maze.iter().enumerate() {\n            for (j, &cell) in row.iter().enumerate() {\n                if cell == 'S' {\n                    start = Some((i, j));\n                } else if cell == 'E' {\n                    end = Some((i, j));\n                }\n            }\n        }\n        (start, end)\n    }\n\n    // Checks if a move to (x, y) is valid (within bounds, not a wall, not visited)\n    fn is_valid_move(maze: &[Vec<char>], x: usize, y: usize, visited: &[Vec<bool>]) -> bool {\n        let rows = maze.len();\n        let cols = if rows > 0 { maze[0].len() } else { 0 };\n        \n        x < rows && y < cols && maze[x][y] != '#' && !visited[x][y]\n    }\n\n    // Depth-first search implementation to find path from start to end\n    fn dfs(\n        maze: &[Vec<char>],\n        x: usize,\n        y: usize,\n        end: (usize, usize),\n        visited: &mut [Vec<bool>],\n    ) -> bool {\n        if (x, y) == end {\n            return true;\n        }\n        \n        visited[x][y] = true;\n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]; // right, down, left, up\n        \n        for &(dx, dy) in &directions {\n            let nx = x as isize + dx;\n            let ny = y as isize + dy;\n            \n            if nx >= 0 && ny >= 0 {\n                let nx = nx as usize;\n                let ny = ny as usize;\n                \n                if is_valid_move(maze, nx, ny, visited) && dfs(maze, nx, ny, end, visited) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    let (start, end) = find_start_end(maze);\n    if start.is_none() || end.is_none() {\n        return false;\n    }\n\n    let start_pos = start.unwrap();\n    let end_pos = end.unwrap();\n    let rows = maze.len();\n    let cols = if rows > 0 { maze[0].len() } else { 0 };\n    \n    let mut visited = vec![vec![false; cols]; rows];\n    dfs(maze, start_pos.0, start_pos.1, end_pos, &mut visited)\n}", "test_cases": "", "test_case_results": "running 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s", "task_id": 17303, "assertions": "#[test]\nfn test_maze_solver() {\n    // Simple solvable maze\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        true\n    );\n    \n    // Simple unsolvable maze\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '#', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        false\n    );\n    \n    // No start position\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['.', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        false\n    );\n    \n    // No end position\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', '.'],\n        ]),\n        false\n    );\n    \n    // Empty maze\n    assert_eq!(\n        maze_solver(&vec![]),\n        false\n    );\n}", "all_code": "use std::collections::VecDeque;\n\n// Solves a maze represented as a 2D grid of characters\n// 'S' represents the start, 'E' represents the end\n// '#' represents walls, '.' represents open paths\n// Returns true if there's a path from 'S' to 'E', false otherwise\nfn maze_solver(maze: &[Vec<char>]) -> bool {\n    // Finds the coordinates of 'S' (start) and 'E' (end) in the maze\n    fn find_start_end(maze: &[Vec<char>]) -> (Option<(usize, usize)>, Option<(usize, usize)>) {\n        let mut start = None;\n        let mut end = None;\n        \n        for (i, row) in maze.iter().enumerate() {\n            for (j, &cell) in row.iter().enumerate() {\n                if cell == 'S' {\n                    start = Some((i, j));\n                } else if cell == 'E' {\n                    end = Some((i, j));\n                }\n            }\n        }\n        (start, end)\n    }\n\n    // Checks if a move to (x, y) is valid (within bounds, not a wall, not visited)\n    fn is_valid_move(maze: &[Vec<char>], x: usize, y: usize, visited: &[Vec<bool>]) -> bool {\n        let rows = maze.len();\n        let cols = if rows > 0 { maze[0].len() } else { 0 };\n        \n        x < rows && y < cols && maze[x][y] != '#' && !visited[x][y]\n    }\n\n    // Depth-first search implementation to find path from start to end\n    fn dfs(\n        maze: &[Vec<char>],\n        x: usize,\n        y: usize,\n        end: (usize, usize),\n        visited: &mut [Vec<bool>],\n    ) -> bool {\n        if (x, y) == end {\n            return true;\n        }\n        \n        visited[x][y] = true;\n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]; // right, down, left, up\n        \n        for &(dx, dy) in &directions {\n            let nx = x as isize + dx;\n            let ny = y as isize + dy;\n            \n            if nx >= 0 && ny >= 0 {\n                let nx = nx as usize;\n                let ny = ny as usize;\n                \n                if is_valid_move(maze, nx, ny, visited) && dfs(maze, nx, ny, end, visited) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n\n    let (start, end) = find_start_end(maze);\n    if start.is_none() || end.is_none() {\n        return false;\n    }\n\n    let start_pos = start.unwrap();\n    let end_pos = end.unwrap();\n    let rows = maze.len();\n    let cols = if rows > 0 { maze[0].len() } else { 0 };\n    \n    let mut visited = vec![vec![false; cols]; rows];\n    dfs(maze, start_pos.0, start_pos.1, end_pos, &mut visited)\n}\n#[test]\nfn test_maze_solver() {\n    // Simple solvable maze\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        true\n    );\n    \n    // Simple unsolvable maze\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '#', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        false\n    );\n    \n    // No start position\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['.', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', 'E'],\n        ]),\n        false\n    );\n    \n    // No end position\n    assert_eq!(\n        maze_solver(&vec![\n            vec!['S', '.', '.', '#'],\n            vec!['#', '#', '.', '.'],\n            vec!['#', '#', '.', '.'],\n        ]),\n        false\n    );\n    \n    // Empty maze\n    assert_eq!(\n        maze_solver(&vec![]),\n        false\n    );\n}", "exec_outcome": "PASSED"}
{"code": "use std::collections::HashMap;\n\npub type KeyType = i32;\n\n#[derive(Default)]\nstruct CityDatabase {\n    cities: HashMap<KeyType, Vec<String>>,\n}\n\nimpl CityDatabase {\n    // Optional constructor\n    pub fn new() -> Self {\n        Self {\n            cities: HashMap::new(),\n        }\n    }\n\n    // Add a city to the database\n    pub fn add_city(&mut self, region_code: KeyType, city_name: String) -> Result<(), String> {\n        if region_code <= 0 {\n            return Err(\"Region code must be positive\".to_string());\n        }\n        if city_name.trim().is_empty() {\n            return Err(\"City name cannot be empty\".to_string());\n        }\n        self.cities.entry(region_code).or_default().push(city_name);\n        Ok(())\n    }\n\n    // Get all cities in a region\n    pub fn get_cities_by_region(&self, region_code: KeyType) -> Vec<String> {\n        self.cities\n            .get(&region_code)\n            .cloned()\n            .unwrap_or_else(Vec::new)\n    }\n\n    // Get number of cities in a region\n    pub fn count_cities_in_region(&self, region_code: KeyType) -> usize {\n        self.cities\n            .get(&region_code)\n            .map(|v| v.len())\n            .unwrap_or(0)\n    }\n\n    // Get all region codes\n    pub fn get_all_region_codes(&self) -> Vec<KeyType> {\n        self.cities.keys().cloned().collect()\n    }\n\n    // Find region code by city name (returns 0 if not found)\n    pub fn find_region_by_city(&self, city_name: &str) -> KeyType {\n        for (code, cities) in &self.cities {\n            if cities.iter().any(|c| c == city_name) {\n                return *code;\n            }\n        }\n        0\n    }\n\n    // Remove all cities from a region\n    pub fn remove_region(&mut self, region_code: KeyType) {\n        self.cities.remove(&region_code);\n    }\n\n    // Print all cities grouped by region\n    pub fn print_all_cities(&self) {\n        const REGION_COL_WIDTH: usize = 12;\n\n        println!(\"{:>width$} | {}\", \"Region Code\", \"City Name\", width = REGION_COL_WIDTH);\n        println!(\"------------|----------\");\n\n        let mut codes: Vec<_> = self.cities.keys().cloned().collect();\n        codes.sort_unstable();\n\n        for code in codes {\n            if let Some(cities) = self.cities.get(&code) {\n                for city in cities {\n                    println!(\"{:>width$} | {}\", code, city, width = REGION_COL_WIDTH);\n                }\n            }\n        }\n    }\n}", "task_id": 17919, "assertions": "\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_operations() {\n        let mut db = CityDatabase::new();\n        db.add_city(41, \"Bytom\".to_string()).unwrap();\n        db.add_city(81, \"Gdynia\".to_string()).unwrap();\n        db.add_city(81, \"Sopot\".to_string()).unwrap();\n        \n        let cities = db.get_cities_by_region(81);\n        assert_eq!(cities.len(), 2);\n        assert!(cities.contains(&\"Gdynia\".to_string()));\n        assert!(cities.contains(&\"Sopot\".to_string()));\n        assert_eq!(db.count_cities_in_region(41), 1);\n    }\n\n    #[test]\n    fn test_finding_region_by_city() {\n        let mut db = CityDatabase::new();\n        db.add_city(27, \"Starachowice\".to_string()).unwrap();\n        db.add_city(41, \"Rybnik\".to_string()).unwrap();\n        db.add_city(27, \"Sandomierz\".to_string()).unwrap();\n        \n        assert_eq!(db.find_region_by_city(\"Rybnik\"), 41);\n        assert_eq!(db.find_region_by_city(\"Warsaw\"), 0);\n    }\n\n    #[test]\n    fn test_invalid_inputs() {\n        let mut db = CityDatabase::new();\n        assert!(db.add_city(0, \"Invalid\".to_string()).is_err());\n        assert!(db.add_city(1, \"\".to_string()).is_err());\n    }\n}\n","all_code": "use std::collections::HashMap;\n\npub type KeyType = i32;\n\n#[derive(Default)]\nstruct CityDatabase {\n    cities: HashMap<KeyType, Vec<String>>,\n}\n\nimpl CityDatabase {\n    // Optional constructor\n    pub fn new() -> Self {\n        Self {\n            cities: HashMap::new(),\n        }\n    }\n\n    // Add a city to the database\n    pub fn add_city(&mut self, region_code: KeyType, city_name: String) -> Result<(), String> {\n        if region_code <= 0 {\n            return Err(\"Region code must be positive\".to_string());\n        }\n        if city_name.trim().is_empty() {\n            return Err(\"City name cannot be empty\".to_string());\n        }\n        self.cities.entry(region_code).or_default().push(city_name);\n        Ok(())\n    }\n\n    // Get all cities in a region\n    pub fn get_cities_by_region(&self, region_code: KeyType) -> Vec<String> {\n        self.cities\n            .get(&region_code)\n            .cloned()\n            .unwrap_or_else(Vec::new)\n    }\n\n    // Get number of cities in a region\n    pub fn count_cities_in_region(&self, region_code: KeyType) -> usize {\n        self.cities\n            .get(&region_code)\n            .map(|v| v.len())\n            .unwrap_or(0)\n    }\n\n    // Get all region codes\n    pub fn get_all_region_codes(&self) -> Vec<KeyType> {\n        self.cities.keys().cloned().collect()\n    }\n\n    // Find region code by city name (returns 0 if not found)\n    pub fn find_region_by_city(&self, city_name: &str) -> KeyType {\n        for (code, cities) in &self.cities {\n            if cities.iter().any(|c| c == city_name) {\n                return *code;\n            }\n        }\n        0\n    }\n\n    // Remove all cities from a region\n    pub fn remove_region(&mut self, region_code: KeyType) {\n        self.cities.remove(&region_code);\n    }\n\n    // Print all cities grouped by region\n    pub fn print_all_cities(&self) {\n        const REGION_COL_WIDTH: usize = 12;\n\n        println!(\"{:>width$} | {}\", \"Region Code\", \"City Name\", width = REGION_COL_WIDTH);\n        println!(\"------------|----------\");\n\n        let mut codes: Vec<_> = self.cities.keys().cloned().collect();\n        codes.sort_unstable();\n\n        for code in codes {\n            if let Some(cities) = self.cities.get(&code) {\n                for city in cities {\n                    println!(\"{:>width$} | {}\", code, city, width = REGION_COL_WIDTH);\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_basic_operations() {\n        let mut db = CityDatabase::new();\n        db.add_city(41, \"Bytom\".to_string()).unwrap();\n        db.add_city(81, \"Gdynia\".to_string()).unwrap();\n        db.add_city(81, \"Sopot\".to_string()).unwrap();\n        \n        let cities = db.get_cities_by_region(81);\n        assert_eq!(cities.len(), 2);\n        assert!(cities.contains(&\"Gdynia\".to_string()));\n        assert!(cities.contains(&\"Sopot\".to_string()));\n        assert_eq!(db.count_cities_in_region(41), 1);\n    }\n\n    #[test]\n    fn test_finding_region_by_city() {\n        let mut db = CityDatabase::new();\n        db.add_city(27, \"Starachowice\".to_string()).unwrap();\n        db.add_city(41, \"Rybnik\".to_string()).unwrap();\n        db.add_city(27, \"Sandomierz\".to_string()).unwrap();\n        \n        assert_eq!(db.find_region_by_city(\"Rybnik\"), 41);\n        assert_eq!(db.find_region_by_city(\"Warsaw\"), 0);\n    }\n\n    #[test]\n    fn test_invalid_inputs() {\n        let mut db = CityDatabase::new();\n        assert!(db.add_city(0, \"Invalid\".to_string()).is_err());\n        assert!(db.add_city(1, \"\".to_string()).is_err());\n    }\n}\n", "exec_outcome": "PASSED"}
