{"code": "using System;\n\nnamespace MaxAffordableN\n{\n    class Program\n    {\n        // Calculate the number of digits in a given integer.\n        // Returns 0 if the number is 0.\n        static int GetDigitCount(int number)\n        {\n            if (number == 0)\n                return 0;\n            return number.ToString().Length;\n        }\n\n        // Find the maximum integer N such that A*N + B*d <= X, where d is the number of digits in N.\n        // Uses binary search to efficiently find N within the range [0, 10^9].\n        static int FindMaxAffordableN(int A, int B, int X)\n        {\n            long low = 0;\n            long high = (long)1e18; // Sufficiently large upper bound for binary search\n            long maxN = 0;\n\n            while (low <= high)\n            {\n                long mid = (low + high) / 2;\n                int d = mid == 0 ? 0 : mid.ToString().Length;\n                long cost = A * mid + B * d;\n\n                if (cost <= X)\n                {\n                    maxN = mid;\n                    low = mid + 1;\n                }\n                else\n                {\n                    high = mid - 1;\n                }\n            }\n\n            // The answer cannot exceed 1e9\n            if (maxN > (long)1e9)\n                maxN = (long)1e9;\n\n            return (int)maxN;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: A=2, B=3, X=10\nMaximum affordable N: 3\nExpected: N where 2*N + 3*d <= 10\n\nInput: A=1, B=1, X=1000000000\nMaximum affordable N: 999999991\nExpected: N where 1*N + 1*d <= 1e9\n\nInput: A=10, B=1, X=100\nMaximum affordable N: 9\nExpected: N where 10*N + 1*d <= 100\n\nInput: A=5, B=5, X=100\nMaximum affordable N: 18\nExpected: N where 5*N + 5*d <= 100", "task_id": 2836, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxAffordableN\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.FindMaxAffordableN(2, 3, 10) == 3);\n            Debug.Assert(Program.FindMaxAffordableN(1, 1, 1000000000) == 999999991);\n            Debug.Assert(Program.FindMaxAffordableN(10, 1, 100) == 9);\n            Debug.Assert(Program.FindMaxAffordableN(5, 5, 100) == 18);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MaxAffordableN\n{\n    class Program\n    {\n        // Calculate the number of digits in a given integer.\n        // Returns 0 if the number is 0.\n    public static int GetDigitCount(int number)\n        {\n            if (number == 0)\n                return 0;\n            return number.ToString().Length;\n        }\n\n        // Find the maximum integer N such that A*N + B*d <= X, where d is the number of digits in N.\n        // Uses binary search to efficiently find N within the range [0, 10^9].\n    public static int FindMaxAffordableN(int A, int B, int X)\n        {\n            long low = 0;\n            long high = (long)1e18; // Sufficiently large upper bound for binary search\n            long maxN = 0;\n\n            while (low <= high)\n            {\n                long mid = (low + high) / 2;\n                int d = mid == 0 ? 0 : mid.ToString().Length;\n                long cost = A * mid + B * d;\n\n                if (cost <= X)\n                {\n                    maxN = mid;\n                    low = mid + 1;\n                }\n                else\n                {\n                    high = mid - 1;\n                }\n            }\n\n            // The answer cannot exceed 1e9\n            if (maxN > (long)1e9)\n                maxN = (long)1e9;\n\n            return (int)maxN;\n        }\n    }\n}\n\nnamespace MaxAffordableN\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.FindMaxAffordableN(2, 3, 10) == 3);\n            Debug.Assert(Program.FindMaxAffordableN(1, 1, 1000000000) == 999999991);\n            Debug.Assert(Program.FindMaxAffordableN(10, 1, 100) == 9);\n            Debug.Assert(Program.FindMaxAffordableN(5, 5, 100) == 18);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace MatrixTransposer\n{\n    class MatrixUtils\n    {\n        // TransposeMatrix returns the transpose of the given 2D matrix.\n        // If the input matrix is empty or null, it returns an empty matrix.\n        public static int[][] TransposeMatrix(int[][] matrix)\n        {\n            if (matrix == null || matrix.Length == 0 || matrix[0] == null || matrix[0].Length == 0)\n            {\n                return new int[0][];\n            }\n\n            int rows = matrix.Length;\n            int cols = matrix[0].Length;\n\n            // Create a new matrix with transposed dimensions\n            int[][] transposed = new int[cols][];\n            for (int i = 0; i < cols; i++)\n            {\n                transposed[i] = new int[rows];\n            }\n\n            // Fill the transposed matrix\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                {\n                    transposed[j][i] = matrix[i][j];\n                }\n            }\n\n            return transposed;\n        }\n\n        // Helper method to print a matrix\n        public static void PrintMatrix(int[][] matrix)\n        {\n            if (matrix == null || matrix.Length == 0)\n            {\n                Console.WriteLine(\"[]\");\n                return;\n            }\n\n            Console.WriteLine(\"[\");\n            foreach (var row in matrix)\n            {\n                Console.WriteLine(\"  [\" + string.Join(\", \", row) + \"]\");\n            }\n            Console.WriteLine(\"]\");\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Matrix:\n[\n  [1, 2, 3]\n  [4, 5, 6]\n]\nTransposed Matrix:\n[\n  [1, 4]\n  [2, 5]\n  [3, 6]\n]\n\nInput Matrix:\n[\n  [7, 8]\n  [9, 10]\n  [11, 12]\n]\nTransposed Matrix:\n[\n  [7, 9, 11]\n  [8, 10, 12]\n]\n\nInput Matrix:\n[\n  [0, 0]\n  [0, 0]\n]\nTransposed Matrix:\n[\n  [0, 0]\n  [0, 0]\n]\n\nInput Matrix:\n[]\nTransposed Matrix:\n[]", "task_id": 15755, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MatrixTransposer\n{\n    class TestMatrixTransposer\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[][] testCase1 = new int[][]\n            {\n                new int[] { 1, 2, 3 },\n                new int[] { 4, 5, 6 }\n            };\n            int[][] expected1 = new int[][]\n            {\n                new int[] { 1, 4 },\n                new int[] { 2, 5 },\n                new int[] { 3, 6 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase1), expected1));\n\n            // Test case 2\n            int[][] testCase2 = new int[][]\n            {\n                new int[] { 7, 8 },\n                new int[] { 9, 10 },\n                new int[] { 11, 12 }\n            };\n            int[][] expected2 = new int[][]\n            {\n                new int[] { 7, 9, 11 },\n                new int[] { 8, 10, 12 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase2), expected2));\n\n            // Test case 3\n            int[][] testCase3 = new int[][]\n            {\n                new int[] { 0, 0 },\n                new int[] { 0, 0 }\n            };\n            int[][] expected3 = new int[][]\n            {\n                new int[] { 0, 0 },\n                new int[] { 0, 0 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase3), expected3));\n\n            // Test case 4 (empty matrix)\n            int[][] testCase4 = new int[0][];\n            int[][] expected4 = new int[0][];\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase4), expected4));\n        }\n\n        private static bool CompareMatrices(int[][] matrix1, int[][] matrix2)\n        {\n            if (matrix1.Length != matrix2.Length) return false;\n            for (int i = 0; i < matrix1.Length; i++)\n            {\n                if (matrix1[i].Length != matrix2[i].Length) return false;\n                for (int j = 0; j < matrix1[i].Length; j++)\n                {\n                    if (matrix1[i][j] != matrix2[i][j]) return false;\n                }\n            }\n            return true;\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace MatrixTransposer\n{\n    class MatrixUtils\n    {\n        // TransposeMatrix returns the transpose of the given 2D matrix.\n        // If the input matrix is empty or null, it returns an empty matrix.\n        public static int[][] TransposeMatrix(int[][] matrix)\n        {\n            if (matrix == null || matrix.Length == 0 || matrix[0] == null || matrix[0].Length == 0)\n            {\n                return new int[0][];\n            }\n\n            int rows = matrix.Length;\n            int cols = matrix[0].Length;\n\n            // Create a new matrix with transposed dimensions\n            int[][] transposed = new int[cols][];\n            for (int i = 0; i < cols; i++)\n            {\n                transposed[i] = new int[rows];\n            }\n\n            // Fill the transposed matrix\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                {\n                    transposed[j][i] = matrix[i][j];\n                }\n            }\n\n            return transposed;\n        }\n\n        // Helper method to print a matrix\n        public static void PrintMatrix(int[][] matrix)\n        {\n            if (matrix == null || matrix.Length == 0)\n            {\n                Console.WriteLine(\"[]\");\n                return;\n            }\n\n            Console.WriteLine(\"[\");\n            foreach (var row in matrix)\n            {\n                Console.WriteLine(\"  [\" + string.Join(\", \", row) + \"]\");\n            }\n            Console.WriteLine(\"]\");\n        }\n    }\n}\n\nnamespace MatrixTransposer\n{\n    class TestMatrixTransposer\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[][] testCase1 = new int[][]\n            {\n                new int[] { 1, 2, 3 },\n                new int[] { 4, 5, 6 }\n            };\n            int[][] expected1 = new int[][]\n            {\n                new int[] { 1, 4 },\n                new int[] { 2, 5 },\n                new int[] { 3, 6 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase1), expected1));\n\n            // Test case 2\n            int[][] testCase2 = new int[][]\n            {\n                new int[] { 7, 8 },\n                new int[] { 9, 10 },\n                new int[] { 11, 12 }\n            };\n            int[][] expected2 = new int[][]\n            {\n                new int[] { 7, 9, 11 },\n                new int[] { 8, 10, 12 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase2), expected2));\n\n            // Test case 3\n            int[][] testCase3 = new int[][]\n            {\n                new int[] { 0, 0 },\n                new int[] { 0, 0 }\n            };\n            int[][] expected3 = new int[][]\n            {\n                new int[] { 0, 0 },\n                new int[] { 0, 0 }\n            };\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase3), expected3));\n\n            // Test case 4 (empty matrix)\n            int[][] testCase4 = new int[0][];\n            int[][] expected4 = new int[0][];\n            Debug.Assert(CompareMatrices(MatrixUtils.TransposeMatrix(testCase4), expected4));\n        }\n\n        private static bool CompareMatrices(int[][] matrix1, int[][] matrix2)\n        {\n            if (matrix1.Length != matrix2.Length) return false;\n            for (int i = 0; i < matrix1.Length; i++)\n            {\n                if (matrix1[i].Length != matrix2[i].Length) return false;\n                for (int j = 0; j < matrix1[i].Length; j++)\n                {\n                    if (matrix1[i][j] != matrix2[i][j]) return false;\n                }\n            }\n            return true;\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace SubsetSumFinder\n{\n    class Program\n    {\n        // Finds all subsets of the input list that sum up to the target value.\n        // The method uses a brute-force approach to generate all possible subsets\n        // and checks if their sum equals the target.\n        public static List<List<int>> FindSubsetsThatSumToTarget(int[] nums, int target)\n        {\n            List<List<int>> result = new List<List<int>>();\n            int n = nums.Length;\n\n            // Iterate over all possible subset sizes from 1 to n\n            for (int i = 1; i <= n; i++)\n            {\n                // Generate all combinations of size i\n                foreach (var combo in GenerateCombinations(nums, i))\n                {\n                    if (Sum(combo) == target)\n                    {\n                        result.Add(new List<int>(combo));\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        // Helper method to generate all combinations of size k from the input array\n        static IEnumerable<int[]> GenerateCombinations(int[] nums, int k)\n        {\n            int n = nums.Length;\n            int[] indices = new int[k];\n            for (int i = 0; i < k; i++)\n            {\n                indices[i] = i;\n            }\n\n            while (indices[0] <= n - k)\n            {\n                int[] combination = new int[k];\n                for (int i = 0; i < k; i++)\n                {\n                    combination[i] = nums[indices[i]];\n                }\n                yield return combination;\n\n                int j = k - 1;\n                while (j >= 0 && indices[j] == n - k + j)\n                {\n                    j--;\n                }\n\n                if (j < 0)\n                {\n                    break;\n                }\n\n                indices[j]++;\n                for (int l = j + 1; l < k; l++)\n                {\n                    indices[l] = indices[l - 1] + 1;\n                }\n            }\n        }\n\n        // Helper method to calculate the sum of an array\n        static int Sum(int[] array)\n        {\n            int sum = 0;\n            foreach (int num in array)\n            {\n                sum += num;\n            }\n            return sum;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4], Target: 5\nSubsets that sum to target:\n[1, 4]\n[2, 3]\n\nInput: [5, 6, 7, 0], Target: 12\nSubsets that sum to target:\n[5, 7]\n[5, 7, 0]\n\nInput: [0, 0, 0, 0], Target: 0\nSubsets that sum to target:\n[0]\n[0]\n[0]\n[0]\n[0, 0]\n[0, 0]\n[0, 0]\n[0, 0]\n[0, 0]\n[0, 0]\n[0, 0, 0]\n[0, 0, 0]\n[0, 0, 0]\n[0, 0, 0]\n[0, 0, 0, 0]", "task_id": 2271, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace SubsetSumFinder\n{\n    class TestSubsetSumFinder\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var subsets1 = Program.FindSubsetsThatSumToTarget(new int[] { 1, 2, 3, 4 }, 5);\n            Debug.Assert(subsets1.Count == 2);\n            Debug.Assert(subsets1.Exists(subset => subset.Count == 2 && subset[0] == 1 && subset[1] == 4));\n            Debug.Assert(subsets1.Exists(subset => subset.Count == 2 && subset[0] == 2 && subset[1] == 3));\n\n            // Test case 2\n            var subsets2 = Program.FindSubsetsThatSumToTarget(new int[] { 5, 6, 7, 0 }, 12);\n            Debug.Assert(subsets2.Count == 2);\n            Debug.Assert(subsets2.Exists(subset => subset.Count == 2 && subset[0] == 5 && subset[1] == 7));\n            Debug.Assert(subsets2.Exists(subset => subset.Count == 3 && subset[0] == 5 && subset[1] == 7 && subset[2] == 0));\n\n            // Test case 3\n            var subsets3 = Program.FindSubsetsThatSumToTarget(new int[] { 0, 0, 0, 0 }, 0);\n            Debug.Assert(subsets3.Count == 15);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace SubsetSumFinder\n{\n    class Program\n    {\n        // Finds all subsets of the input list that sum up to the target value.\n        // The method uses a brute-force approach to generate all possible subsets\n        // and checks if their sum equals the target.\n        public static List<List<int>> FindSubsetsThatSumToTarget(int[] nums, int target)\n        {\n            List<List<int>> result = new List<List<int>>();\n            int n = nums.Length;\n\n            // Iterate over all possible subset sizes from 1 to n\n            for (int i = 1; i <= n; i++)\n            {\n                // Generate all combinations of size i\n                foreach (var combo in GenerateCombinations(nums, i))\n                {\n                    if (Sum(combo) == target)\n                    {\n                        result.Add(new List<int>(combo));\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        // Helper method to generate all combinations of size k from the input array\n    public static IEnumerable<int[]> GenerateCombinations(int[] nums, int k)\n        {\n            int n = nums.Length;\n            int[] indices = new int[k];\n            for (int i = 0; i < k; i++)\n            {\n                indices[i] = i;\n            }\n\n            while (indices[0] <= n - k)\n            {\n                int[] combination = new int[k];\n                for (int i = 0; i < k; i++)\n                {\n                    combination[i] = nums[indices[i]];\n                }\n                yield return combination;\n\n                int j = k - 1;\n                while (j >= 0 && indices[j] == n - k + j)\n                {\n                    j--;\n                }\n\n                if (j < 0)\n                {\n                    break;\n                }\n\n                indices[j]++;\n                for (int l = j + 1; l < k; l++)\n                {\n                    indices[l] = indices[l - 1] + 1;\n                }\n            }\n        }\n\n        // Helper method to calculate the sum of an array\n    public static int Sum(int[] array)\n        {\n            int sum = 0;\n            foreach (int num in array)\n            {\n                sum += num;\n            }\n            return sum;\n        }\n    }\n}\n\nnamespace SubsetSumFinder\n{\n    class TestSubsetSumFinder\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var subsets1 = Program.FindSubsetsThatSumToTarget(new int[] { 1, 2, 3, 4 }, 5);\n            Debug.Assert(subsets1.Count == 2);\n            Debug.Assert(subsets1.Exists(subset => subset.Count == 2 && subset[0] == 1 && subset[1] == 4));\n            Debug.Assert(subsets1.Exists(subset => subset.Count == 2 && subset[0] == 2 && subset[1] == 3));\n\n            // Test case 2\n            var subsets2 = Program.FindSubsetsThatSumToTarget(new int[] { 5, 6, 7, 0 }, 12);\n            Debug.Assert(subsets2.Count == 2);\n            Debug.Assert(subsets2.Exists(subset => subset.Count == 2 && subset[0] == 5 && subset[1] == 7));\n            Debug.Assert(subsets2.Exists(subset => subset.Count == 3 && subset[0] == 5 && subset[1] == 7 && subset[2] == 0));\n\n            // Test case 3\n            var subsets3 = Program.FindSubsetsThatSumToTarget(new int[] { 0, 0, 0, 0 }, 0);\n            Debug.Assert(subsets3.Count == 15);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace StringMinimizer\n{\n    class Program\n    {\n        /// <summary>\n        /// Returns the length of the minimized string after deleting the matching characters from both strings,\n        /// or -1 if it's not possible to perform such deletions.\n        /// </summary>\n        /// <param name=\"s\">First input string.</param>\n        /// <param name=\"t\">Second input string.</param>\n        /// <returns>The minimized length or -1 if no common subsequence exists.</returns>\n        static int MinimizeLength(string s, string t)\n        {\n            int lenS = s.Length;\n            int lenT = t.Length;\n\n            // Define a 2D DP array to store the lengths of the longest common subsequence\n            int[,] dp = new int[lenS + 1, lenT + 1];\n\n            // Fill the DP table\n            for (int i = 1; i <= lenS; i++)\n            {\n                for (int j = 1; j <= lenT; j++)\n                {\n                    if (s[i - 1] == t[j - 1])\n                    {\n                        dp[i, j] = dp[i - 1, j - 1] + 1;\n                    }\n                    else\n                    {\n                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                    }\n                }\n            }\n\n            int lcsLength = dp[lenS, lenT];\n\n            // If there's no common subsequence, return -1\n            if (lcsLength == 0)\n            {\n                return -1;\n            }\n\n            // The minimized length of the resulting string after deletions\n            int minimizedLength = (lenS - lcsLength) + (lenT - lcsLength);\n\n            return minimizedLength;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: s = \"abc\", t = \"abc\"\nMinimized Length: 0\n\nInput: s = \"abc\", t = \"def\"\nMinimized Length: -1\n\nInput: s = \"abcde\", t = \"ace\"\nMinimized Length: 2\n\nInput: s = \"abc\", t = \"ab\"\nMinimized Length: 1\n\nInput: s = \"abcd\", t = \"efgh\"\nMinimized Length: -1\n\nInput: s = \"\", t = \"\"\nMinimized Length: -1\n\nInput: s = \"a\", t = \"a\"\nMinimized Length: 0\n\nInput: s = \"abc\", t = \"bc\"\nMinimized Length: 1", "task_id": 11973, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StringMinimizer\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"abc\") == 0);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"def\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"abcde\", \"ace\") == 2);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"ab\") == 1);\n            Debug.Assert(Program.MinimizeLength(\"abcd\", \"efgh\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"\", \"\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"a\", \"a\") == 0);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"bc\") == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace StringMinimizer\n{\n    class Program\n    {\n        /// <summary>\n        /// Returns the length of the minimized string after deleting the matching characters from both strings,\n        /// or -1 if it's not possible to perform such deletions.\n        /// </summary>\n        /// <param name=\"s\">First input string.</param>\n        /// <param name=\"t\">Second input string.</param>\n        /// <returns>The minimized length or -1 if no common subsequence exists.</returns>\n    public static int MinimizeLength(string s, string t)\n        {\n            int lenS = s.Length;\n            int lenT = t.Length;\n\n            // Define a 2D DP array to store the lengths of the longest common subsequence\n            int[,] dp = new int[lenS + 1, lenT + 1];\n\n            // Fill the DP table\n            for (int i = 1; i <= lenS; i++)\n            {\n                for (int j = 1; j <= lenT; j++)\n                {\n                    if (s[i - 1] == t[j - 1])\n                    {\n                        dp[i, j] = dp[i - 1, j - 1] + 1;\n                    }\n                    else\n                    {\n                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);\n                    }\n                }\n            }\n\n            int lcsLength = dp[lenS, lenT];\n\n            // If there's no common subsequence, return -1\n            if (lcsLength == 0)\n            {\n                return -1;\n            }\n\n            // The minimized length of the resulting string after deletions\n            int minimizedLength = (lenS - lcsLength) + (lenT - lcsLength);\n\n            return minimizedLength;\n        }\n    }\n}\n\nnamespace StringMinimizer\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"abc\") == 0);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"def\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"abcde\", \"ace\") == 2);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"ab\") == 1);\n            Debug.Assert(Program.MinimizeLength(\"abcd\", \"efgh\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"\", \"\") == -1);\n            Debug.Assert(Program.MinimizeLength(\"a\", \"a\") == 0);\n            Debug.Assert(Program.MinimizeLength(\"abc\", \"bc\") == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace StringDivisorCalculator\n{\n    class StringDivisorCalculator\n    {\n        // Computes the greatest common divisor (GCD) of an array of integers.\n        // Uses the Euclidean algorithm iteratively for each element in the array.\n        public static int ComputeGcd(int[] arr)\n        {\n            if (arr.Length == 0)\n                return 0;\n\n            int currentGcd = arr[0];\n            for (int i = 1; i < arr.Length; i++)\n            {\n                currentGcd = Gcd(currentGcd, arr[i]);\n                if (currentGcd == 1)\n                    break;\n            }\n            return currentGcd;\n        }\n\n        // Helper method to compute GCD of two numbers using the Euclidean algorithm.\n        public static int Gcd(int a, int b)\n        {\n            while (b != 0)\n            {\n                int temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        // Gets all divisors of a number n, sorted in ascending order.\n        // Returns an empty list if n is 0.\n        public static List<int> GetDivisors(int n)\n        {\n            if (n == 0)\n                return new List<int>();\n\n            var divisors = new HashSet<int>();\n            for (int i = 1; i <= Math.Sqrt(n); i++)\n            {\n                if (n % i == 0)\n                {\n                    divisors.Add(i);\n                    divisors.Add(n / i);\n                }\n            }\n            return divisors.OrderBy(d => d).ToList();\n        }\n\n        // Processes a test case: calculates character coefficients, computes GCD, and finds divisors.\n        public static List<int> ProcessCase(string s)\n        {\n            var charCoeffs = new Dictionary<char, int>();\n            int length = s.Length;\n            for (int idx = 0; idx < length; idx++)\n            {\n                char currentChar = s[idx];\n                int exp = length - 1 - idx;\n                int term = (int)Math.Pow(10, exp);\n                if (!charCoeffs.ContainsKey(currentChar))\n                {\n                    charCoeffs[currentChar] = 0;\n                }\n                charCoeffs[currentChar] += term;\n            }\n            int[] coeffs = charCoeffs.Values.ToArray();\n            int currentGcd = ComputeGcd(coeffs);\n            return GetDivisors(currentGcd);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input for Case 1: \"123\"\nCase 1: 1\nInput for Case 2: \"abab\"\nCase 2: 1 101\nInput for Case 3: \"0000\"\nCase 3: 1 11 101 1111\nInput for Case 4: \"xyzxyz\"\nCase 4: 1 7 11 13 77 91 143 1001", "task_id": 14320, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace StringDivisorCalculator\n{\n    class TestStringDivisorCalculator\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            List<int> result1 = StringDivisorCalculator.ProcessCase(\"123\");\n            Debug.Assert(result1.SequenceEqual(new List<int> { 1 }));\n\n            // Test case 2\n            List<int> result2 = StringDivisorCalculator.ProcessCase(\"abab\");\n            Debug.Assert(result2.SequenceEqual(new List<int> { 1, 101 }));\n\n            // Test case 3\n            List<int> result3 = StringDivisorCalculator.ProcessCase(\"0000\");\n            Debug.Assert(result3.SequenceEqual(new List<int> { 1, 11, 101, 1111 }));\n\n            // Test case 4\n            List<int> result4 = StringDivisorCalculator.ProcessCase(\"xyzxyz\");\n            Debug.Assert(result4.SequenceEqual(new List<int> { 1, 7, 11, 13, 77, 91, 143, 1001 }));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace StringDivisorCalculator\n{\n    class StringDivisorCalculator\n    {\n        // Computes the greatest common divisor (GCD) of an array of integers.\n        // Uses the Euclidean algorithm iteratively for each element in the array.\n        public static int ComputeGcd(int[] arr)\n        {\n            if (arr.Length == 0)\n                return 0;\n\n            int currentGcd = arr[0];\n            for (int i = 1; i < arr.Length; i++)\n            {\n                currentGcd = Gcd(currentGcd, arr[i]);\n                if (currentGcd == 1)\n                    break;\n            }\n            return currentGcd;\n        }\n\n        // Helper method to compute GCD of two numbers using the Euclidean algorithm.\n        public static int Gcd(int a, int b)\n        {\n            while (b != 0)\n            {\n                int temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        // Gets all divisors of a number n, sorted in ascending order.\n        // Returns an empty list if n is 0.\n        public static List<int> GetDivisors(int n)\n        {\n            if (n == 0)\n                return new List<int>();\n\n            var divisors = new HashSet<int>();\n            for (int i = 1; i <= Math.Sqrt(n); i++)\n            {\n                if (n % i == 0)\n                {\n                    divisors.Add(i);\n                    divisors.Add(n / i);\n                }\n            }\n            return divisors.OrderBy(d => d).ToList();\n        }\n\n        // Processes a test case: calculates character coefficients, computes GCD, and finds divisors.\n        public static List<int> ProcessCase(string s)\n        {\n            var charCoeffs = new Dictionary<char, int>();\n            int length = s.Length;\n            for (int idx = 0; idx < length; idx++)\n            {\n                char currentChar = s[idx];\n                int exp = length - 1 - idx;\n                int term = (int)Math.Pow(10, exp);\n                if (!charCoeffs.ContainsKey(currentChar))\n                {\n                    charCoeffs[currentChar] = 0;\n                }\n                charCoeffs[currentChar] += term;\n            }\n            int[] coeffs = charCoeffs.Values.ToArray();\n            int currentGcd = ComputeGcd(coeffs);\n            return GetDivisors(currentGcd);\n        }\n    }\n}\n\nnamespace StringDivisorCalculator\n{\n    class TestStringDivisorCalculator\n    {\n        public static void Main()\n        {\n            // Test case 1\n            List<int> result1 = StringDivisorCalculator.ProcessCase(\"123\");\n            Debug.Assert(result1.SequenceEqual(new List<int> { 1 }));\n\n            // Test case 2\n            List<int> result2 = StringDivisorCalculator.ProcessCase(\"abab\");\n            Debug.Assert(result2.SequenceEqual(new List<int> { 1, 101 }));\n\n            // Test case 3\n            List<int> result3 = StringDivisorCalculator.ProcessCase(\"0000\");\n            Debug.Assert(result3.SequenceEqual(new List<int> { 1, 11, 101, 1111 }));\n\n            // Test case 4\n            List<int> result4 = StringDivisorCalculator.ProcessCase(\"xyzxyz\");\n            Debug.Assert(result4.SequenceEqual(new List<int> { 1, 7, 11, 13, 77, 91, 143, 1001 }));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AnagramFinder\n{\n    class AnagramUtils\n    {\n        // Preprocesses a word by removing non-alphabetic characters, converting to lowercase, and sorting the letters.\n        // This helps in comparing words for anagrams.\n        public static string Preprocess(string word)\n        {\n            var filteredChars = word.Where(c => char.IsLetter(c)).Select(c => char.ToLower(c));\n            return string.Concat(filteredChars.OrderBy(c => c));\n        }\n\n        // Finds all anagrams of a given word in a list of words.\n        // An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n        public static List<string> FindAnagrams(string word, List<string> wordList)\n        {\n            string wordProcessed = Preprocess(word);\n            return wordList.Where(w => Preprocess(w) == wordProcessed).ToList();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Word: listen\nWord List: enlists, google, inlets, banana, silent, LISTEN\nAnagrams: inlets, silent, LISTEN\n\nInput Word: dormitory\nWord List: dirty room, dormitory, dirtyroom, room dirty, moon starer\nAnagrams: dirty room, dormitory, dirtyroom, room dirty\n\nInput Word: The eyes\nWord List: they see, the eyes, theyese, eyes the\nAnagrams: they see, the eyes, theyese, eyes the", "task_id": 13189, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace AnagramFinder\n{\n    class TestAnagramUtils\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var result1 = AnagramUtils.FindAnagrams(\"listen\", new List<string> { \"enlists\", \"google\", \"inlets\", \"banana\", \"silent\", \"LISTEN\" });\n            Debug.Assert(result1.Count == 3);\n            Debug.Assert(result1.Contains(\"inlets\"));\n            Debug.Assert(result1.Contains(\"silent\"));\n            Debug.Assert(result1.Contains(\"LISTEN\"));\n\n            // Test case 2\n            var result2 = AnagramUtils.FindAnagrams(\"dormitory\", new List<string> { \"dirty room\", \"dormitory\", \"dirtyroom\", \"room dirty\", \"moon starer\" });\n            Debug.Assert(result2.Count == 4);\n            Debug.Assert(result2.Contains(\"dirty room\"));\n            Debug.Assert(result2.Contains(\"dormitory\"));\n            Debug.Assert(result2.Contains(\"dirtyroom\"));\n            Debug.Assert(result2.Contains(\"room dirty\"));\n\n            // Test case 3\n            var result3 = AnagramUtils.FindAnagrams(\"The eyes\", new List<string> { \"they see\", \"the eyes\", \"theyese\", \"eyes the\" });\n            Debug.Assert(result3.Count == 4);\n            Debug.Assert(result3.Contains(\"they see\"));\n            Debug.Assert(result3.Contains(\"the eyes\"));\n            Debug.Assert(result3.Contains(\"theyese\"));\n            Debug.Assert(result3.Contains(\"eyes the\"));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace AnagramFinder\n{\n    class AnagramUtils\n    {\n        // Preprocesses a word by removing non-alphabetic characters, converting to lowercase, and sorting the letters.\n        // This helps in comparing words for anagrams.\n        public static string Preprocess(string word)\n        {\n            var filteredChars = word.Where(c => char.IsLetter(c)).Select(c => char.ToLower(c));\n            return string.Concat(filteredChars.OrderBy(c => c));\n        }\n\n        // Finds all anagrams of a given word in a list of words.\n        // An anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n        public static List<string> FindAnagrams(string word, List<string> wordList)\n        {\n            string wordProcessed = Preprocess(word);\n            return wordList.Where(w => Preprocess(w) == wordProcessed).ToList();\n        }\n    }\n}\n\nnamespace AnagramFinder\n{\n    class TestAnagramUtils\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var result1 = AnagramUtils.FindAnagrams(\"listen\", new List<string> { \"enlists\", \"google\", \"inlets\", \"banana\", \"silent\", \"LISTEN\" });\n            Debug.Assert(result1.Count == 3);\n            Debug.Assert(result1.Contains(\"inlets\"));\n            Debug.Assert(result1.Contains(\"silent\"));\n            Debug.Assert(result1.Contains(\"LISTEN\"));\n\n            // Test case 2\n            var result2 = AnagramUtils.FindAnagrams(\"dormitory\", new List<string> { \"dirty room\", \"dormitory\", \"dirtyroom\", \"room dirty\", \"moon starer\" });\n            Debug.Assert(result2.Count == 4);\n            Debug.Assert(result2.Contains(\"dirty room\"));\n            Debug.Assert(result2.Contains(\"dormitory\"));\n            Debug.Assert(result2.Contains(\"dirtyroom\"));\n            Debug.Assert(result2.Contains(\"room dirty\"));\n\n            // Test case 3\n            var result3 = AnagramUtils.FindAnagrams(\"The eyes\", new List<string> { \"they see\", \"the eyes\", \"theyese\", \"eyes the\" });\n            Debug.Assert(result3.Count == 4);\n            Debug.Assert(result3.Contains(\"they see\"));\n            Debug.Assert(result3.Contains(\"the eyes\"));\n            Debug.Assert(result3.Contains(\"theyese\"));\n            Debug.Assert(result3.Contains(\"eyes the\"));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace StringPatternAnalyzer\n{\n    class StringPatternAnalyzer\n    {\n        // Computes the \"next\" array used in the KMP algorithm for pattern matching.\n        // This array helps in determining the longest prefix which is also a suffix for every substring.\n        public static int[] ComputeNextArray(string s)\n        {\n            int n = s.Length;\n            int[] nextArr = new int[n];\n            int j = 0;\n\n            for (int i = 1; i < n; i++)\n            {\n                while (j > 0 && s[i] != s[j])\n                {\n                    j = nextArr[j - 1];\n                }\n                if (s[i] == s[j])\n                {\n                    j++;\n                }\n                nextArr[i] = j;\n            }\n            return nextArr;\n        }\n\n        // Determines the smallest repeating unit in the string and returns the repetition count.\n        // If no repetition is found, returns 1.\n        public static int FindSmallestRepetition(string s)\n        {\n            int n = s.Length;\n            if (n == 0)\n            {\n                return 0;\n            }\n\n            int[] nextArr = ComputeNextArray(s);\n            int lastNext = nextArr[n - 1];\n            int lenCandidate = n - lastNext;\n\n            if (n % lenCandidate == 0)\n            {\n                return n / lenCandidate;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: \"abcabcabc\"\nRepetition Count: 3\n\nInput: \"aaaaa\"\nRepetition Count: 5\n\nInput: \"ababab\"\nRepetition Count: 3\n\nInput: \"abcde\"\nRepetition Count: 1\n\nInput: \"\"\nRepetition Count: 0\n\nInput: \"a\"\nRepetition Count: 1", "task_id": 9947, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StringPatternAnalyzer\n{\n    class TestStringPatternAnalyzer\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"abcabcabc\") == 3);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"aaaaa\") == 5);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"ababab\") == 3);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"abcde\") == 1);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"\") == 0);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"a\") == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace StringPatternAnalyzer\n{\n    class StringPatternAnalyzer\n    {\n        // Computes the \"next\" array used in the KMP algorithm for pattern matching.\n        // This array helps in determining the longest prefix which is also a suffix for every substring.\n        public static int[] ComputeNextArray(string s)\n        {\n            int n = s.Length;\n            int[] nextArr = new int[n];\n            int j = 0;\n\n            for (int i = 1; i < n; i++)\n            {\n                while (j > 0 && s[i] != s[j])\n                {\n                    j = nextArr[j - 1];\n                }\n                if (s[i] == s[j])\n                {\n                    j++;\n                }\n                nextArr[i] = j;\n            }\n            return nextArr;\n        }\n\n        // Determines the smallest repeating unit in the string and returns the repetition count.\n        // If no repetition is found, returns 1.\n        public static int FindSmallestRepetition(string s)\n        {\n            int n = s.Length;\n            if (n == 0)\n            {\n                return 0;\n            }\n\n            int[] nextArr = ComputeNextArray(s);\n            int lastNext = nextArr[n - 1];\n            int lenCandidate = n - lastNext;\n\n            if (n % lenCandidate == 0)\n            {\n                return n / lenCandidate;\n            }\n            else\n            {\n                return 1;\n            }\n        }\n    }\n}\n\nnamespace StringPatternAnalyzer\n{\n    class TestStringPatternAnalyzer\n    {\n        public static void Main()\n        {\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"abcabcabc\") == 3);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"aaaaa\") == 5);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"ababab\") == 3);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"abcde\") == 1);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"\") == 0);\n            Debug.Assert(StringPatternAnalyzer.FindSmallestRepetition(\"a\") == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace IntervalProcessor\n{\n    class IntervalProcessor\n    {\n        // Processes intervals and computes the result based on counts and sums of intervals.\n        // n: number of intervals\n        // K: upper bound for time\n        // intervals: array of tuples representing start and end of each interval\n        public static string ProcessIntervals(int n, int K, (int s, int e)[] intervals)\n        {\n            int maxIndex = K + 2;\n            int[] deltaC = new int[maxIndex];\n            int[] deltaS = new int[maxIndex];\n\n            // Process each interval to populate deltaC and deltaS\n            foreach (var interval in intervals)\n            {\n                int s = interval.s;\n                int e = interval.e;\n\n                deltaC[s] += 1;\n                if (e + 1 <= K)\n                {\n                    deltaC[e + 1] -= 1;\n                }\n\n                deltaS[s] += s;\n                if (e + 1 <= K)\n                {\n                    deltaS[e + 1] -= s;\n                }\n            }\n\n            // Compute prefix sums for C and S\n            int[] C = new int[K + 2];\n            int currentC = 0;\n            for (int t = 1; t <= K; t++)\n            {\n                currentC += deltaC[t];\n                C[t] = currentC;\n            }\n\n            int[] S = new int[K + 2];\n            int currentS = 0;\n            for (int t = 1; t <= K; t++)\n            {\n                currentS += deltaS[t];\n                S[t] = currentS;\n            }\n\n            // Compute the result for each time t\n            string[] result = new string[K];\n            for (int t = 1; t <= K; t++)\n            {\n                int total = (t + 1) * C[t] - S[t];\n                result[t - 1] = total.ToString();\n            }\n\n            return string.Join(\" \", result);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n = 3, K = 5, intervals = [(1, 3), (2, 4), (3, 5)]\nResult: 1 3 6 5 3\n\nTest Case 2:\nInput: n = 1, K = 5, intervals = [(1, 5)]\nResult: 1 2 3 4 5\n\nTest Case 3:\nInput: n = 2, K = 6, intervals = [(1, 2), (4, 6)]\nResult: 1 2 0 1 2 3", "task_id": 29651, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace IntervalProcessor\n{\n    class TestIntervalProcessor\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: Example from the original code\n            int n1 = 3;\n            int K1 = 5;\n            (int s, int e)[] intervals1 = new (int, int)[] { (1, 3), (2, 4), (3, 5) };\n            string result1 = IntervalProcessor.ProcessIntervals(n1, K1, intervals1);\n            Debug.Assert(result1 == \"1 3 6 5 3\");\n\n            // Test Case 2: Single interval covering the entire range\n            int n2 = 1;\n            int K2 = 5;\n            (int s, int e)[] intervals2 = new (int, int)[] { (1, 5) };\n            string result2 = IntervalProcessor.ProcessIntervals(n2, K2, intervals2);\n            Debug.Assert(result2 == \"1 2 3 4 5\");\n\n            // Test Case 3: Intervals with gaps\n            int n3 = 2;\n            int K3 = 6;\n            (int s, int e)[] intervals3 = new (int, int)[] { (1, 2), (4, 6) };\n            string result3 = IntervalProcessor.ProcessIntervals(n3, K3, intervals3);\n            Debug.Assert(result3 == \"1 2 0 1 2 3\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace IntervalProcessor\n{\n    class IntervalProcessor\n    {\n        // Processes intervals and computes the result based on counts and sums of intervals.\n        // n: number of intervals\n        // K: upper bound for time\n        // intervals: array of tuples representing start and end of each interval\n        public static string ProcessIntervals(int n, int K, (int s, int e)[] intervals)\n        {\n            int maxIndex = K + 2;\n            int[] deltaC = new int[maxIndex];\n            int[] deltaS = new int[maxIndex];\n\n            // Process each interval to populate deltaC and deltaS\n            foreach (var interval in intervals)\n            {\n                int s = interval.s;\n                int e = interval.e;\n\n                deltaC[s] += 1;\n                if (e + 1 <= K)\n                {\n                    deltaC[e + 1] -= 1;\n                }\n\n                deltaS[s] += s;\n                if (e + 1 <= K)\n                {\n                    deltaS[e + 1] -= s;\n                }\n            }\n\n            // Compute prefix sums for C and S\n            int[] C = new int[K + 2];\n            int currentC = 0;\n            for (int t = 1; t <= K; t++)\n            {\n                currentC += deltaC[t];\n                C[t] = currentC;\n            }\n\n            int[] S = new int[K + 2];\n            int currentS = 0;\n            for (int t = 1; t <= K; t++)\n            {\n                currentS += deltaS[t];\n                S[t] = currentS;\n            }\n\n            // Compute the result for each time t\n            string[] result = new string[K];\n            for (int t = 1; t <= K; t++)\n            {\n                int total = (t + 1) * C[t] - S[t];\n                result[t - 1] = total.ToString();\n            }\n\n            return string.Join(\" \", result);\n        }\n    }\n}\n\nnamespace IntervalProcessor\n{\n    class TestIntervalProcessor\n    {\n        public static void Main()\n        {\n            // Test Case 1: Example from the original code\n            int n1 = 3;\n            int K1 = 5;\n            (int s, int e)[] intervals1 = new (int, int)[] { (1, 3), (2, 4), (3, 5) };\n            string result1 = IntervalProcessor.ProcessIntervals(n1, K1, intervals1);\n            Debug.Assert(result1 == \"1 3 6 5 3\");\n\n            // Test Case 2: Single interval covering the entire range\n            int n2 = 1;\n            int K2 = 5;\n            (int s, int e)[] intervals2 = new (int, int)[] { (1, 5) };\n            string result2 = IntervalProcessor.ProcessIntervals(n2, K2, intervals2);\n            Debug.Assert(result2 == \"1 2 3 4 5\");\n\n            // Test Case 3: Intervals with gaps\n            int n3 = 2;\n            int K3 = 6;\n            (int s, int e)[] intervals3 = new (int, int)[] { (1, 2), (4, 6) };\n            string result3 = IntervalProcessor.ProcessIntervals(n3, K3, intervals3);\n            Debug.Assert(result3 == \"1 2 0 1 2 3\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace FinancialRecordParser\n{\n    class FinancialRecordParser\n    {\n        // Parses a single financial record string and returns a dictionary of key-value pairs.\n        // Each line in the record string is expected to be in the format \"key: value\".\n        // Lines are split by newline characters, and each line is split into key and value by the first colon.\n        // Both key and value are trimmed of leading and trailing whitespace.\n        public static Dictionary<string, string> ParseFinancialRecord(string recordString)\n        {\n            Dictionary<string, string> recordDict = new Dictionary<string, string>();\n            string[] lines = recordString.Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (string line in lines)\n            {\n                string[] parts = line.Split(new[] { ':' }, 2);\n                if (parts.Length == 2)\n                {\n                    string key = parts[0].Trim();\n                    string value = parts[1].Trim();\n                    recordDict[key] = value;\n                }\n            }\n\n            return recordDict;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input:\nDate: 2023-10-01\nAmount: 100.00\nDescription: Groceries\nParsed Record:\n  Date: 2023-10-01\n  Amount: 100.00\n  Description: Groceries\n\nInput:\nDate: 2023-10-02\nAmount: 50.00\nDescription: Gas\nCategory: Transportation\nParsed Record:\n  Date: 2023-10-02\n  Amount: 50.00\n  Description: Gas\n  Category: Transportation\n\nInput:\nDate: 2023-10-03\nAmount: 200.00\nDescription: \nParsed Record:\n  Date: 2023-10-03\n  Amount: 200.00\n  Description:", "task_id": 11216, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace FinancialRecordParser\n{\n    class TestFinancialRecordParser\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            string testCase1 = \"Date: 2023-10-01\\nAmount: 100.00\\nDescription: Groceries\";\n            var result1 = FinancialRecordParser.ParseFinancialRecord(testCase1);\n            Debug.Assert(result1[\"Date\"] == \"2023-10-01\");\n            Debug.Assert(result1[\"Amount\"] == \"100.00\");\n            Debug.Assert(result1[\"Description\"] == \"Groceries\");\n            Debug.Assert(result1.Count == 3);\n\n            // Test Case 2\n            string testCase2 = \"Date: 2023-10-02\\nAmount: 50.00\\nDescription: Gas\\nCategory: Transportation\";\n            var result2 = FinancialRecordParser.ParseFinancialRecord(testCase2);\n            Debug.Assert(result2[\"Date\"] == \"2023-10-02\");\n            Debug.Assert(result2[\"Amount\"] == \"50.00\");\n            Debug.Assert(result2[\"Description\"] == \"Gas\");\n            Debug.Assert(result2[\"Category\"] == \"Transportation\");\n            Debug.Assert(result2.Count == 4);\n\n            // Test Case 3\n            string testCase3 = \"Date: 2023-10-03\\nAmount: 200.00\\nDescription: \";\n            var result3 = FinancialRecordParser.ParseFinancialRecord(testCase3);\n            Debug.Assert(result3[\"Date\"] == \"2023-10-03\");\n            Debug.Assert(result3[\"Amount\"] == \"200.00\");\n            Debug.Assert(result3[\"Description\"] == \"\");\n            Debug.Assert(result3.Count == 3);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace FinancialRecordParser\n{\n    class FinancialRecordParser\n    {\n        // Parses a single financial record string and returns a dictionary of key-value pairs.\n        // Each line in the record string is expected to be in the format \"key: value\".\n        // Lines are split by newline characters, and each line is split into key and value by the first colon.\n        // Both key and value are trimmed of leading and trailing whitespace.\n        public static Dictionary<string, string> ParseFinancialRecord(string recordString)\n        {\n            Dictionary<string, string> recordDict = new Dictionary<string, string>();\n            string[] lines = recordString.Split(new[] { '\\n' }, StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (string line in lines)\n            {\n                string[] parts = line.Split(new[] { ':' }, 2);\n                if (parts.Length == 2)\n                {\n                    string key = parts[0].Trim();\n                    string value = parts[1].Trim();\n                    recordDict[key] = value;\n                }\n            }\n\n            return recordDict;\n        }\n    }\n}\n\nnamespace FinancialRecordParser\n{\n    class TestFinancialRecordParser\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            string testCase1 = \"Date: 2023-10-01\\nAmount: 100.00\\nDescription: Groceries\";\n            var result1 = FinancialRecordParser.ParseFinancialRecord(testCase1);\n            Debug.Assert(result1[\"Date\"] == \"2023-10-01\");\n            Debug.Assert(result1[\"Amount\"] == \"100.00\");\n            Debug.Assert(result1[\"Description\"] == \"Groceries\");\n            Debug.Assert(result1.Count == 3);\n\n            // Test Case 2\n            string testCase2 = \"Date: 2023-10-02\\nAmount: 50.00\\nDescription: Gas\\nCategory: Transportation\";\n            var result2 = FinancialRecordParser.ParseFinancialRecord(testCase2);\n            Debug.Assert(result2[\"Date\"] == \"2023-10-02\");\n            Debug.Assert(result2[\"Amount\"] == \"50.00\");\n            Debug.Assert(result2[\"Description\"] == \"Gas\");\n            Debug.Assert(result2[\"Category\"] == \"Transportation\");\n            Debug.Assert(result2.Count == 4);\n\n            // Test Case 3\n            string testCase3 = \"Date: 2023-10-03\\nAmount: 200.00\\nDescription: \";\n            var result3 = FinancialRecordParser.ParseFinancialRecord(testCase3);\n            Debug.Assert(result3[\"Date\"] == \"2023-10-03\");\n            Debug.Assert(result3[\"Amount\"] == \"200.00\");\n            Debug.Assert(result3[\"Description\"] == \"\");\n            Debug.Assert(result3.Count == 3);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace HouseNumberFinder\n{\n    class Program\n    {\n        // FindRightHouse calculates the house number on the right side that faces the given house number on the left side.\n        // The formula used is: rightHouseNumber = n - k + 1, where n is the total number of houses on each side, and k is the house number on the left side.\n        public static int[] FindRightHouse(int t, (int n, int k)[] testCases)\n        {\n            int[] results = new int[t];\n            for (int i = 0; i < t; i++)\n            {\n                results[i] = testCases[i].n - testCases[i].k + 1;\n            }\n            return results;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 5, k = 1\nRight House Number: 5\nInput: n = 10, k = 3\nRight House Number: 8\nInput: n = 7, k = 7\nRight House Number: 1\nInput: n = 4, k = 2\nRight House Number: 3", "task_id": 21044, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace HouseNumberFinder\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            (int n, int k)[] testCases = new (int n, int k)[]\n            {\n                (5, 1),\n                (10, 3),\n                (7, 7),\n                (4, 2)\n            };\n\n            int t = testCases.Length;\n            int[] results = Program.FindRightHouse(t, testCases);\n\n            Debug.Assert(results[0] == 5);\n            Debug.Assert(results[1] == 8);\n            Debug.Assert(results[2] == 1);\n            Debug.Assert(results[3] == 3);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace HouseNumberFinder\n{\n    class Program\n    {\n        // FindRightHouse calculates the house number on the right side that faces the given house number on the left side.\n        // The formula used is: rightHouseNumber = n - k + 1, where n is the total number of houses on each side, and k is the house number on the left side.\n        public static int[] FindRightHouse(int t, (int n, int k)[] testCases)\n        {\n            int[] results = new int[t];\n            for (int i = 0; i < t; i++)\n            {\n                results[i] = testCases[i].n - testCases[i].k + 1;\n            }\n            return results;\n        }\n    }\n}\n\nnamespace HouseNumberFinder\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            (int n, int k)[] testCases = new (int n, int k)[]\n            {\n                (5, 1),\n                (10, 3),\n                (7, 7),\n                (4, 2)\n            };\n\n            int t = testCases.Length;\n            int[] results = Program.FindRightHouse(t, testCases);\n\n            Debug.Assert(results[0] == 5);\n            Debug.Assert(results[1] == 8);\n            Debug.Assert(results[2] == 1);\n            Debug.Assert(results[3] == 3);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace CalculatorApp\n{\n    class Calculator\n    {\n        private List<string> logs;\n\n        // Constructor initializes the logs list\n        public Calculator()\n        {\n            logs = new List<string>();\n        }\n\n        // Adds two numbers and logs the operation\n        public double Add(double a, double b)\n        {\n            double result = a + b;\n            logs.Add($\"Operation: {a} + {b} = {result}\");\n            return result;\n        }\n\n        // Subtracts the second number from the first and logs the operation\n        public double Subtract(double a, double b)\n        {\n            double result = a - b;\n            logs.Add($\"Operation: {a} - {b} = {result}\");\n            return result;\n        }\n\n        // Multiplies two numbers and logs the operation\n        public double Multiply(double a, double b)\n        {\n            double result = a * b;\n            logs.Add($\"Operation: {a} * {b} = {result}\");\n            return result;\n        }\n\n        // Divides the first number by the second and logs the operation\n        // Throws an exception if division by zero is attempted\n        public double Divide(double a, double b)\n        {\n            if (b == 0)\n            {\n                throw new DivideByZeroException(\"Cannot divide by zero\");\n            }\n            double result = a / b;\n            logs.Add($\"Operation: {a} / {b} = {result}\");\n            return result;\n        }\n\n        // Returns the list of logged operations\n        public List<string> GetLogs()\n        {\n            return logs;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: a = 5, b = 3\nAdd Result: 8\nInput: a = 5, b = 3\nSubtract Result: 2\nInput: a = 5, b = 3\nMultiply Result: 15\nInput: a = 5, b = 3\nDivide Result: 1.6666666666666667\nInput: a = 5, b = 0\nException: Cannot divide by zero\n\nOperation Logs:\nOperation: 5 + 3 = 8\nOperation: 5 - 3 = 2\nOperation: 5 * 3 = 15\nOperation: 5 / 3 = 1.6666666666666667", "task_id": 15363, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace CalculatorApp\n{\n    class TestCalculator\n    {\n        public static void RunTests()\n        {\n            Calculator calculator = new Calculator();\n\n            // Test Add\n            Debug.Assert(calculator.Add(5, 3) == 8);\n\n            // Test Subtract\n            Debug.Assert(calculator.Subtract(5, 3) == 2);\n\n            // Test Multiply\n            Debug.Assert(calculator.Multiply(5, 3) == 15);\n\n            // Test Divide\n            Debug.Assert(Math.Abs(calculator.Divide(5, 3) - 1.6666666666666667) < 0.000001);\n\n            // Test Divide by zero exception\n            bool exceptionThrown = false;\n            try\n            {\n                calculator.Divide(5, 0);\n            }\n            catch (DivideByZeroException)\n            {\n                exceptionThrown = true;\n            }\n            Debug.Assert(exceptionThrown);\n\n            // Test logs\n            List<string> logs = calculator.GetLogs();\n            Debug.Assert(logs.Count == 4);\n            Debug.Assert(logs[0] == \"Operation: 5 + 3 = 8\");\n            Debug.Assert(logs[1] == \"Operation: 5 - 3 = 2\");\n            Debug.Assert(logs[2] == \"Operation: 5 * 3 = 15\");\n            Debug.Assert(logs[3] == \"Operation: 5 / 3 = 1.6666666666666667\");\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace CalculatorApp\n{\n    class Calculator\n    {\n        private List<string> logs;\n\n        // Constructor initializes the logs list\n        public Calculator()\n        {\n            logs = new List<string>();\n        }\n\n        // Adds two numbers and logs the operation\n        public double Add(double a, double b)\n        {\n            double result = a + b;\n            logs.Add($\"Operation: {a} + {b} = {result}\");\n            return result;\n        }\n\n        // Subtracts the second number from the first and logs the operation\n        public double Subtract(double a, double b)\n        {\n            double result = a - b;\n            logs.Add($\"Operation: {a} - {b} = {result}\");\n            return result;\n        }\n\n        // Multiplies two numbers and logs the operation\n        public double Multiply(double a, double b)\n        {\n            double result = a * b;\n            logs.Add($\"Operation: {a} * {b} = {result}\");\n            return result;\n        }\n\n        // Divides the first number by the second and logs the operation\n        // Throws an exception if division by zero is attempted\n        public double Divide(double a, double b)\n        {\n            if (b == 0)\n            {\n                throw new DivideByZeroException(\"Cannot divide by zero\");\n            }\n            double result = a / b;\n            logs.Add($\"Operation: {a} / {b} = {result}\");\n            return result;\n        }\n\n        // Returns the list of logged operations\n        public List<string> GetLogs()\n        {\n            return logs;\n        }\n    }\n}\n\nnamespace CalculatorApp\n{\n    class TestCalculator\n    {\n        public static void Main()\n        {\n            Calculator calculator = new Calculator();\n\n            // Test Add\n            Debug.Assert(calculator.Add(5, 3) == 8);\n\n            // Test Subtract\n            Debug.Assert(calculator.Subtract(5, 3) == 2);\n\n            // Test Multiply\n            Debug.Assert(calculator.Multiply(5, 3) == 15);\n\n            // Test Divide\n            Debug.Assert(Math.Abs(calculator.Divide(5, 3) - 1.6666666666666667) < 0.000001);\n\n            // Test Divide by zero exception\n            bool exceptionThrown = false;\n            try\n            {\n                calculator.Divide(5, 0);\n            }\n            catch (DivideByZeroException)\n            {\n                exceptionThrown = true;\n            }\n            Debug.Assert(exceptionThrown);\n\n            // Test logs\n            List<string> logs = calculator.GetLogs();\n            Debug.Assert(logs.Count == 4);\n            Debug.Assert(logs[0] == \"Operation: 5 + 3 = 8\");\n            Debug.Assert(logs[1] == \"Operation: 5 - 3 = 2\");\n            Debug.Assert(logs[2] == \"Operation: 5 * 3 = 15\");\n            Debug.Assert(logs[3] == \"Operation: 5 / 3 = 1.6666666666666667\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace EulerTotientFunction\n{\n    class EulerTotient\n    {\n        // ComputePhi calculates Euler's totient function (phi) for a given integer m.\n        // The totient function phi(m) is the count of integers up to m that are coprime with m.\n        public static int ComputePhi(int m)\n        {\n            if (m == 1)\n            {\n                return 1;\n            }\n\n            int originalM = m;\n            HashSet<int> factors = new HashSet<int>();\n            \n            // Factorize m into its prime factors\n            for (int i = 2; i * i <= m; i++)\n            {\n                if (m % i == 0)\n                {\n                    factors.Add(i);\n                    while (m % i == 0)\n                    {\n                        m /= i;\n                    }\n                }\n            }\n\n            if (m > 1)\n            {\n                factors.Add(m);\n            }\n\n            // Calculate phi using the product formula: phi(m) = m * product(1 - 1/p) for each prime p dividing m\n            int phi = originalM;\n            foreach (int p in factors)\n            {\n                phi = phi / p * (p - 1);\n            }\n\n            return phi;\n        }\n\n        // CalculateSum computes the sum based on the given formula: d * (phi(m) * m / 2), where m = n / d\n        public static int CalculateSum(int n, int d)\n        {\n            int m = n / d;\n            if (m == 1)\n            {\n                return 0;\n            }\n\n            int phi = ComputePhi(m);\n            int sumK = phi * m / 2;\n            return d * sumK;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 10, d = 2\nResult: 20\nInput: n = 15, d = 3\nResult: 30\nInput: n = 7, d = 1\nResult: 21\nInput: n = 1, d = 1\nResult: 0\nInput: n = 100, d = 10\nResult: 200", "task_id": 23248, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace EulerTotientFunction\n{\n    class TestEulerTotient\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(EulerTotient.CalculateSum(10, 2) == 20);\n            Debug.Assert(EulerTotient.CalculateSum(15, 3) == 30);\n            Debug.Assert(EulerTotient.CalculateSum(7, 1) == 21);\n            Debug.Assert(EulerTotient.CalculateSum(1, 1) == 0);\n            Debug.Assert(EulerTotient.CalculateSum(100, 10) == 200);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace EulerTotientFunction\n{\n    class EulerTotient\n    {\n        // ComputePhi calculates Euler's totient function (phi) for a given integer m.\n        // The totient function phi(m) is the count of integers up to m that are coprime with m.\n        public static int ComputePhi(int m)\n        {\n            if (m == 1)\n            {\n                return 1;\n            }\n\n            int originalM = m;\n            HashSet<int> factors = new HashSet<int>();\n            \n            // Factorize m into its prime factors\n            for (int i = 2; i * i <= m; i++)\n            {\n                if (m % i == 0)\n                {\n                    factors.Add(i);\n                    while (m % i == 0)\n                    {\n                        m /= i;\n                    }\n                }\n            }\n\n            if (m > 1)\n            {\n                factors.Add(m);\n            }\n\n            // Calculate phi using the product formula: phi(m) = m * product(1 - 1/p) for each prime p dividing m\n            int phi = originalM;\n            foreach (int p in factors)\n            {\n                phi = phi / p * (p - 1);\n            }\n\n            return phi;\n        }\n\n        // CalculateSum computes the sum based on the given formula: d * (phi(m) * m / 2), where m = n / d\n        public static int CalculateSum(int n, int d)\n        {\n            int m = n / d;\n            if (m == 1)\n            {\n                return 0;\n            }\n\n            int phi = ComputePhi(m);\n            int sumK = phi * m / 2;\n            return d * sumK;\n        }\n    }\n}\n\nnamespace EulerTotientFunction\n{\n    class TestEulerTotient\n    {\n        public static void Main()\n        {\n            Debug.Assert(EulerTotient.CalculateSum(10, 2) == 20);\n            Debug.Assert(EulerTotient.CalculateSum(15, 3) == 30);\n            Debug.Assert(EulerTotient.CalculateSum(7, 1) == 21);\n            Debug.Assert(EulerTotient.CalculateSum(1, 1) == 0);\n            Debug.Assert(EulerTotient.CalculateSum(100, 10) == 200);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace CircularStartIndexFinder\n{\n    class CircularStartIndexFinder\n    {\n        // Finds the starting index in a circular array where the cumulative sum of differences\n        // between two arrays remains non-negative for a full cycle.\n        // The method assumes there's always a valid starting index (as per problem statement).\n        public static int FindCircularStartIndex(int[] a, int[] b)\n        {\n            int n = a.Length;\n            int[] c = new int[n];\n            \n            // Calculate the difference between corresponding elements of a and b\n            for (int i = 0; i < n; i++)\n            {\n                c[i] = a[i] - b[i];\n            }\n            \n            int start = 0;\n            int currentSum = 0;\n            \n            // Iterate through the circular array (2n iterations to cover all possibilities)\n            for (int i = 0; i < 2 * n; i++)\n            {\n                int mod_i = i % n;\n                currentSum += c[mod_i];\n                \n                // If current sum becomes negative, reset starting point and sum\n                if (currentSum < 0)\n                {\n                    start = i + 1;\n                    currentSum = 0;\n                }\n                \n                // If we've covered n consecutive elements with non-negative sum, return the start\n                if (i - start + 1 >= n)\n                {\n                    return start % n;\n                }\n            }\n            \n            // This line should theoretically never be reached (as per problem statement)\n            return 0;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nArray A: [1, 2, 3, 4]\nArray B: [0, 1, 2, 3]\nStarting Index: 0\n\nTest Case 2:\nArray A: [3, 1, 2, 4]\nArray B: [4, 2, 1, 3]\nStarting Index: 2\n\nTest Case 3:\nArray A: [5, 5, 5, 5]\nArray B: [1, 1, 1, 1]\nStarting Index: 0\n\nTest Case 4:\nArray A: [2, 3, 4, 1]\nArray B: [3, 4, 1, 2]\nStarting Index: 2", "task_id": 26755, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace CircularStartIndexFinder\n{\n    class TestCircularStartIndexFinder\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Simple case with obvious solution\n            int[] a1 = { 1, 2, 3, 4 };\n            int[] b1 = { 0, 1, 2, 3 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a1, b1) == 0);\n\n            // Test case 2: Solution requires wrapping around the array\n            int[] a2 = { 3, 1, 2, 4 };\n            int[] b2 = { 4, 2, 1, 3 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a2, b2) == 2);\n\n            // Test case 3: All differences are positive\n            int[] a3 = { 5, 5, 5, 5 };\n            int[] b3 = { 1, 1, 1, 1 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a3, b3) == 0);\n\n            // Test case 4: Solution at index 2\n            int[] a4 = { 2, 3, 4, 1 };\n            int[] b4 = { 3, 4, 1, 2 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a4, b4) == 2);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace CircularStartIndexFinder\n{\n    class CircularStartIndexFinder\n    {\n        // Finds the starting index in a circular array where the cumulative sum of differences\n        // between two arrays remains non-negative for a full cycle.\n        // The method assumes there's always a valid starting index (as per problem statement).\n        public static int FindCircularStartIndex(int[] a, int[] b)\n        {\n            int n = a.Length;\n            int[] c = new int[n];\n            \n            // Calculate the difference between corresponding elements of a and b\n            for (int i = 0; i < n; i++)\n            {\n                c[i] = a[i] - b[i];\n            }\n            \n            int start = 0;\n            int currentSum = 0;\n            \n            // Iterate through the circular array (2n iterations to cover all possibilities)\n            for (int i = 0; i < 2 * n; i++)\n            {\n                int mod_i = i % n;\n                currentSum += c[mod_i];\n                \n                // If current sum becomes negative, reset starting point and sum\n                if (currentSum < 0)\n                {\n                    start = i + 1;\n                    currentSum = 0;\n                }\n                \n                // If we've covered n consecutive elements with non-negative sum, return the start\n                if (i - start + 1 >= n)\n                {\n                    return start % n;\n                }\n            }\n            \n            // This line should theoretically never be reached (as per problem statement)\n            return 0;\n        }\n    }\n}\n\nnamespace CircularStartIndexFinder\n{\n    class TestCircularStartIndexFinder\n    {\n        public static void Main()\n        {\n            // Test case 1: Simple case with obvious solution\n            int[] a1 = { 1, 2, 3, 4 };\n            int[] b1 = { 0, 1, 2, 3 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a1, b1) == 0);\n\n            // Test case 2: Solution requires wrapping around the array\n            int[] a2 = { 3, 1, 2, 4 };\n            int[] b2 = { 4, 2, 1, 3 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a2, b2) == 2);\n\n            // Test case 3: All differences are positive\n            int[] a3 = { 5, 5, 5, 5 };\n            int[] b3 = { 1, 1, 1, 1 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a3, b3) == 0);\n\n            // Test case 4: Solution at index 2\n            int[] a4 = { 2, 3, 4, 1 };\n            int[] b4 = { 3, 4, 1, 2 };\n            Debug.Assert(CircularStartIndexFinder.FindCircularStartIndex(a4, b4) == 2);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace IntervalEfficiencyCalculator\n{\n    // Represents an interval with start time, end time, and efficiency\n    public class Interval\n    {\n        public int Start { get; set; }\n        public int End { get; set; }\n        public int Efficiency { get; set; }\n\n        public Interval(int start, int end, int efficiency)\n        {\n            Start = start;\n            End = end;\n            Efficiency = efficiency;\n        }\n    }\n\n    public class EfficiencyCalculator\n    {\n        // Calculate the maximum efficiency from non-overlapping intervals\n        // Intervals are sorted by their end times, and we use dynamic programming to find the optimal solution\n        public static int CalculateMaxEfficiency(List<Interval> intervals, int R)\n        {\n            if (intervals.Count == 0)\n            {\n                return 0;\n            }\n\n            // Sort intervals based on their end times\n            intervals.Sort((a, b) => a.End.CompareTo(b.End));\n\n            // Extract end times for binary search\n            List<int> endTimes = intervals.Select(interval => interval.End).ToList();\n\n            // Initialize DP array\n            int[] dp = new int[intervals.Count];\n            dp[0] = intervals[0].Efficiency;\n\n            for (int i = 1; i < intervals.Count; i++)\n            {\n                int currentStart = intervals[i].Start;\n                int requiredEnd = currentStart - R;\n\n                // Find the rightmost interval ending before or at requiredEnd\n                int idx = endTimes.BinarySearch(0, i, requiredEnd, null);\n                if (idx < 0)\n                {\n                    idx = ~idx - 1;\n                }\n\n                int prevMax = idx >= 0 ? dp[idx] : 0;\n                int currentEfficiency = intervals[i].Efficiency;\n                dp[i] = Math.Max(prevMax + currentEfficiency, dp[i - 1]);\n            }\n\n            return dp[intervals.Count - 1];\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nIntervals: [(1, 5, 10), (2, 7, 15), (5, 9, 20)]\nR: 1\nMax Efficiency: 20\n\nTest Case 2:\nIntervals: []\nR: 2\nMax Efficiency: 0\n\nTest Case 3:\nIntervals: [(1, 3, 5)]\nR: 1\nMax Efficiency: 5\n\nTest Case 4:\nIntervals: [(1, 3, 5), (4, 6, 10), (7, 9, 15)]\nR: 1\nMax Efficiency: 30", "task_id": 1247, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace IntervalEfficiencyCalculator\n{\n    class TestEfficiencyCalculator\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Sample input from the original code\n            List<Interval> testCase1 = new List<Interval>\n            {\n                new Interval(1, 5, 10),\n                new Interval(2, 7, 15),\n                new Interval(5, 9, 20)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase1, 1) == 20);\n\n            // Test case 2: No intervals\n            List<Interval> testCase2 = new List<Interval>();\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase2, 2) == 0);\n\n            // Test case 3: Single interval\n            List<Interval> testCase3 = new List<Interval>\n            {\n                new Interval(1, 3, 5)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase3, 1) == 5);\n\n            // Test case 4: Multiple non-overlapping intervals\n            List<Interval> testCase4 = new List<Interval>\n            {\n                new Interval(1, 3, 5),\n                new Interval(4, 6, 10),\n                new Interval(7, 9, 15)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase4, 1) == 30);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace IntervalEfficiencyCalculator\n{\n    // Represents an interval with start time, end time, and efficiency\n    public class Interval\n    {\n        public int Start { get; set; }\n        public int End { get; set; }\n        public int Efficiency { get; set; }\n\n        public Interval(int start, int end, int efficiency)\n        {\n            Start = start;\n            End = end;\n            Efficiency = efficiency;\n        }\n    }\n\n    public class EfficiencyCalculator\n    {\n        // Calculate the maximum efficiency from non-overlapping intervals\n        // Intervals are sorted by their end times, and we use dynamic programming to find the optimal solution\n        public static int CalculateMaxEfficiency(List<Interval> intervals, int R)\n        {\n            if (intervals.Count == 0)\n            {\n                return 0;\n            }\n\n            // Sort intervals based on their end times\n            intervals.Sort((a, b) => a.End.CompareTo(b.End));\n\n            // Extract end times for binary search\n            List<int> endTimes = intervals.Select(interval => interval.End).ToList();\n\n            // Initialize DP array\n            int[] dp = new int[intervals.Count];\n            dp[0] = intervals[0].Efficiency;\n\n            for (int i = 1; i < intervals.Count; i++)\n            {\n                int currentStart = intervals[i].Start;\n                int requiredEnd = currentStart - R;\n\n                // Find the rightmost interval ending before or at requiredEnd\n                int idx = endTimes.BinarySearch(0, i, requiredEnd, null);\n                if (idx < 0)\n                {\n                    idx = ~idx - 1;\n                }\n\n                int prevMax = idx >= 0 ? dp[idx] : 0;\n                int currentEfficiency = intervals[i].Efficiency;\n                dp[i] = Math.Max(prevMax + currentEfficiency, dp[i - 1]);\n            }\n\n            return dp[intervals.Count - 1];\n        }\n    }\n}\n\nnamespace IntervalEfficiencyCalculator\n{\n    class TestEfficiencyCalculator\n    {\n        public static void Main()\n        {\n            // Test case 1: Sample input from the original code\n            List<Interval> testCase1 = new List<Interval>\n            {\n                new Interval(1, 5, 10),\n                new Interval(2, 7, 15),\n                new Interval(5, 9, 20)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase1, 1) == 20);\n\n            // Test case 2: No intervals\n            List<Interval> testCase2 = new List<Interval>();\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase2, 2) == 0);\n\n            // Test case 3: Single interval\n            List<Interval> testCase3 = new List<Interval>\n            {\n                new Interval(1, 3, 5)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase3, 1) == 5);\n\n            // Test case 4: Multiple non-overlapping intervals\n            List<Interval> testCase4 = new List<Interval>\n            {\n                new Interval(1, 3, 5),\n                new Interval(4, 6, 10),\n                new Interval(7, 9, 15)\n            };\n            Debug.Assert(EfficiencyCalculator.CalculateMaxEfficiency(testCase4, 1) == 30);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace MazePathFinder\n{\n    class MazeSolver\n    {\n        // Finds the shortest path from any player 'P' to any treasure 'T' in the given maze.\n        // Uses BFS (Breadth-First Search) to explore the maze and find the shortest path.\n        // Returns a list of tuples representing the path coordinates, or null if no path exists.\n        public static List<(int, int)> FindShortestPath(char[,] maze)\n        {\n            // Directions in which we can move: up, down, left, right\n            var directions = new List<(int, int)> { (0, 1), (0, -1), (1, 0), (-1, 0) };\n\n            // Find all players' positions and treasures\n            var players = new List<(int, int)>();\n            var treasures = new List<(int, int)>();\n            for (int i = 0; i < maze.GetLength(0); i++)\n            {\n                for (int j = 0; j < maze.GetLength(1); j++)\n                {\n                    if (maze[i, j] == 'P')\n                    {\n                        players.Add((i, j));\n                    }\n                    else if (maze[i, j] == 'T')\n                    {\n                        treasures.Add((i, j));\n                    }\n                }\n            }\n\n            // BFS implementation to find shortest path from start to any of the ends\n            List<(int, int)> Bfs((int, int) start, HashSet<(int, int)> ends)\n            {\n                var queue = new Queue<(List<(int, int)> path, (int x, int y) current)>();\n                queue.Enqueue((new List<(int, int)> { start }, start));\n                var visited = new HashSet<(int, int)>();\n\n                while (queue.Count > 0)\n                {\n                    var (path, (x, y)) = queue.Dequeue();\n\n                    if (ends.Contains((x, y)))\n                    {\n                        return path;\n                    }\n\n                    visited.Add((x, y));\n\n                    foreach (var (dx, dy) in directions)\n                    {\n                        int nx = x + dx, ny = y + dy;\n                        if (nx >= 0 && nx < maze.GetLength(0) && ny >= 0 && ny < maze.GetLength(1) &&\n                            maze[nx, ny] != '#' && !visited.Contains((nx, ny)))\n                        {\n                            var newPath = new List<(int, int)>(path) { (nx, ny) };\n                            queue.Enqueue((newPath, (nx, ny)));\n                        }\n                    }\n                }\n                return null;\n            }\n\n            // Finding shortest path for each player by searching for any treasure\n            List<(int, int)> shortestPath = null;\n            foreach (var player in players)\n            {\n                var path = Bfs(player, new HashSet<(int, int)>(treasures));\n                if (path != null && (shortestPath == null || path.Count < shortestPath.Count))\n                {\n                    shortestPath = path;\n                }\n            }\n\n            return shortestPath;\n        }\n\n        // Helper method to print the maze\n        public static void PrintMaze(char[,] maze)\n        {\n            for (int i = 0; i < maze.GetLength(0); i++)\n            {\n                for (int j = 0; j < maze.GetLength(1); j++)\n                {\n                    Console.Write(maze[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/Program.cs(67,45): warning CS8600: Converting null literal or possible null value to non-nullable type. [/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/MyProject.csproj]\n/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/Program.cs(77,20): warning CS8603: Possible null reference return. [/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/MyProject.csproj]\n/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/Program.cs(63,24): warning CS8603: Possible null reference return. [/data/codes/c#/1577cbf82a564cb6a62f10852e1e8e56/MyProject/MyProject.csproj]\nTest Case 1:\nMaze:\n# # # # # # # # \n# P           # \n# # #   # #   # \n#         #   # \n#   # #   #   # \n#   #         # \n#   #   # # T # \n# # # # # # # # \nShortest path found:\n(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (2, 6) (3, 6) (4, 6) (5, 6) (6, 6) \nPath length: 11\n\nTest Case 2:\nMaze:\n# # # # # # # # \n# P           # \n# # #   # #   # \n#         #   # \n#   # #   #   # \n#   #         # \n#   #   # # # # \n# # # # # # # # \nNo path to treasure found.\n\nTest Case 3:\nMaze:\n# # # # # # # # \n# P       P   # \n# # #   # #   # \n#         # T # \n#   # #   #   # \n#   #       T # \n#   #   # # # # \n# # # # # # # # \nShortest path found:\n(1, 5) (1, 6) (2, 6) (3, 6) \nPath length: 4", "task_id": 18572, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace MazePathFinder\n{\n    class TestMazeSolver\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Original maze from the example\n            char[,] maze1 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', ' ', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', ' ', '#'},\n                {'#', ' ', '#', ' ', '#', '#', 'T', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path1 = MazeSolver.FindShortestPath(maze1);\n            Debug.Assert(path1 != null);\n            Debug.Assert(path1.Count == 11);\n            Debug.Assert(path1[0] == (1, 1));\n            Debug.Assert(path1[^1] == (6, 6));\n\n            // Test case 2: Maze with no path to treasure\n            char[,] maze2 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', ' ', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', ' ', '#'},\n                {'#', ' ', '#', ' ', '#', '#', '#', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path2 = MazeSolver.FindShortestPath(maze2);\n            Debug.Assert(path2 == null);\n\n            // Test case 3: Maze with multiple players and treasures\n            char[,] maze3 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', 'P', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', 'T', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', 'T', '#'},\n                {'#', ' ', '#', ' ', '#', '#', '#', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path3 = MazeSolver.FindShortestPath(maze3);\n            Debug.Assert(path3 != null);\n            Debug.Assert(path3.Count == 4);\n            Debug.Assert(path3[0] == (1, 5));\n            Debug.Assert(path3[^1] == (3, 6));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace MazePathFinder\n{\n    class MazeSolver\n    {\n        // Finds the shortest path from any player 'P' to any treasure 'T' in the given maze.\n        // Uses BFS (Breadth-First Search) to explore the maze and find the shortest path.\n        // Returns a list of tuples representing the path coordinates, or null if no path exists.\n        public static List<(int, int)> FindShortestPath(char[,] maze)\n        {\n            // Directions in which we can move: up, down, left, right\n            var directions = new List<(int, int)> { (0, 1), (0, -1), (1, 0), (-1, 0) };\n\n            // Find all players' positions and treasures\n            var players = new List<(int, int)>();\n            var treasures = new List<(int, int)>();\n            for (int i = 0; i < maze.GetLength(0); i++)\n            {\n                for (int j = 0; j < maze.GetLength(1); j++)\n                {\n                    if (maze[i, j] == 'P')\n                    {\n                        players.Add((i, j));\n                    }\n                    else if (maze[i, j] == 'T')\n                    {\n                        treasures.Add((i, j));\n                    }\n                }\n            }\n\n            // BFS implementation to find shortest path from start to any of the ends\n            List<(int, int)> Bfs((int, int) start, HashSet<(int, int)> ends)\n            {\n                var queue = new Queue<(List<(int, int)> path, (int x, int y) current)>();\n                queue.Enqueue((new List<(int, int)> { start }, start));\n                var visited = new HashSet<(int, int)>();\n\n                while (queue.Count > 0)\n                {\n                    var (path, (x, y)) = queue.Dequeue();\n\n                    if (ends.Contains((x, y)))\n                    {\n                        return path;\n                    }\n\n                    visited.Add((x, y));\n\n                    foreach (var (dx, dy) in directions)\n                    {\n                        int nx = x + dx, ny = y + dy;\n                        if (nx >= 0 && nx < maze.GetLength(0) && ny >= 0 && ny < maze.GetLength(1) &&\n                            maze[nx, ny] != '#' && !visited.Contains((nx, ny)))\n                        {\n                            var newPath = new List<(int, int)>(path) { (nx, ny) };\n                            queue.Enqueue((newPath, (nx, ny)));\n                        }\n                    }\n                }\n                return null;\n            }\n\n            // Finding shortest path for each player by searching for any treasure\n            List<(int, int)> shortestPath = null;\n            foreach (var player in players)\n            {\n                var path = Bfs(player, new HashSet<(int, int)>(treasures));\n                if (path != null && (shortestPath == null || path.Count < shortestPath.Count))\n                {\n                    shortestPath = path;\n                }\n            }\n\n            return shortestPath;\n        }\n\n        // Helper method to print the maze\n        public static void PrintMaze(char[,] maze)\n        {\n            for (int i = 0; i < maze.GetLength(0); i++)\n            {\n                for (int j = 0; j < maze.GetLength(1); j++)\n                {\n                    Console.Write(maze[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n\nnamespace MazePathFinder\n{\n    class TestMazeSolver\n    {\n        public static void Main()\n        {\n            // Test case 1: Original maze from the example\n            char[,] maze1 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', ' ', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', ' ', '#'},\n                {'#', ' ', '#', ' ', '#', '#', 'T', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path1 = MazeSolver.FindShortestPath(maze1);\n            Debug.Assert(path1 != null);\n            Debug.Assert(path1.Count == 11);\n            Debug.Assert(path1[0] == (1, 1));\n            Debug.Assert(path1[^1] == (6, 6));\n\n            // Test case 2: Maze with no path to treasure\n            char[,] maze2 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', ' ', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', ' ', '#'},\n                {'#', ' ', '#', ' ', '#', '#', '#', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path2 = MazeSolver.FindShortestPath(maze2);\n            Debug.Assert(path2 == null);\n\n            // Test case 3: Maze with multiple players and treasures\n            char[,] maze3 = {\n                {'#', '#', '#', '#', '#', '#', '#', '#'},\n                {'#', 'P', ' ', ' ', ' ', 'P', ' ', '#'},\n                {'#', '#', '#', ' ', '#', '#', ' ', '#'},\n                {'#', ' ', ' ', ' ', ' ', '#', 'T', '#'},\n                {'#', ' ', '#', '#', ' ', '#', ' ', '#'},\n                {'#', ' ', '#', ' ', ' ', ' ', 'T', '#'},\n                {'#', ' ', '#', ' ', '#', '#', '#', '#'},\n                {'#', '#', '#', '#', '#', '#', '#', '#'}\n            };\n\n            var path3 = MazeSolver.FindShortestPath(maze3);\n            Debug.Assert(path3 != null);\n            Debug.Assert(path3.Count == 4);\n            Debug.Assert(path3[0] == (1, 5));\n            Debug.Assert(path3[^1] == (3, 6));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace GridDistanceCalculator\n{\n    class GridUtils\n    {\n        // Computes the row (k) and position in the row (a) for a given number (x) in a triangular grid.\n        // The grid is structured such that row k contains k numbers, starting from k*(k-1)/2 + 1 to k*(k+1)/2.\n        public static (int K, int A) ComputeKA(int x)\n        {\n            int low = 1;\n            int high = 2 * (int)Math.Pow(10, 9); // Sufficiently large upper bound\n\n            // Binary search to find the smallest k such that k*(k+1)/2 >= x\n            while (low < high)\n            {\n                int mid = (low + high) / 2;\n                int sMid = mid * (mid + 1) / 2;\n                if (sMid >= x)\n                {\n                    high = mid;\n                }\n                else\n                {\n                    low = mid + 1;\n                }\n            }\n            int k = low;\n            int a = x - (k - 1) * k / 2;\n            return (k, a);\n        }\n\n        // Computes the distance between two numbers (m and n) in a triangular grid.\n        // The distance is calculated based on their positions (k and a) in the grid.\n        public static int ComputeDistance(int m, int n)\n        {\n            var (k_m, a_m) = ComputeKA(m);\n            var (k_n, a_n) = ComputeKA(n);\n\n            if (k_m == k_n)\n            {\n                return Math.Abs(a_m - a_n);\n            }\n            else\n            {\n                // Ensure m is in the lower row\n                if (k_m > k_n)\n                {\n                    (k_m, k_n) = (k_n, k_m);\n                    (a_m, a_n) = (a_n, a_m);\n                }\n                int delta = k_n - k_m;\n                int left = a_m;\n                int right = a_m + delta;\n                int horizontal = Math.Max(Math.Max(left - a_n, a_n - right), 0);\n                return delta + horizontal;\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: m = 1, n = 2\nPosition of m: Row = 676258178, Position = 725126592\nPosition of n: Row = 676258178, Position = 725126593\nDistance: 1\n\nInput: m = 3, n = 5\nPosition of m: Row = 676258178, Position = 725126594\nPosition of n: Row = 676258178, Position = 725126596\nDistance: 2\n\nInput: m = 1, n = 4\nPosition of m: Row = 676258178, Position = 725126592\nPosition of n: Row = 676258178, Position = 725126595\nDistance: 3\n\nInput: m = 6, n = 12\nPosition of m: Row = 676258178, Position = 725126597\nPosition of n: Row = 676258178, Position = 725126603\nDistance: 6\n\nInput: m = 10, n = 20\nPosition of m: Row = 676258178, Position = 725126601\nPosition of n: Row = 676258178, Position = 725126611\nDistance: 10\n\nInput: m = 7, n = 7\nPosition of m: Row = 676258178, Position = 725126598\nPosition of n: Row = 676258178, Position = 725126598\nDistance: 0", "task_id": 21391, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace GridDistanceCalculator\n{\n    class TestGridUtils\n    {\n        public static void RunTests()\n        {\n            // Test cases with expected results\n            Debug.Assert(GridUtils.ComputeDistance(1, 2) == 1);\n            Debug.Assert(GridUtils.ComputeDistance(3, 5) == 2);\n            Debug.Assert(GridUtils.ComputeDistance(1, 4) == 3);\n            Debug.Assert(GridUtils.ComputeDistance(6, 12) == 6);\n            Debug.Assert(GridUtils.ComputeDistance(10, 20) == 10);\n            Debug.Assert(GridUtils.ComputeDistance(7, 7) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace GridDistanceCalculator\n{\n    class GridUtils\n    {\n        // Computes the row (k) and position in the row (a) for a given number (x) in a triangular grid.\n        // The grid is structured such that row k contains k numbers, starting from k*(k-1)/2 + 1 to k*(k+1)/2.\n        public static (int K, int A) ComputeKA(int x)\n        {\n            int low = 1;\n            int high = 2 * (int)Math.Pow(10, 9); // Sufficiently large upper bound\n\n            // Binary search to find the smallest k such that k*(k+1)/2 >= x\n            while (low < high)\n            {\n                int mid = (low + high) / 2;\n                int sMid = mid * (mid + 1) / 2;\n                if (sMid >= x)\n                {\n                    high = mid;\n                }\n                else\n                {\n                    low = mid + 1;\n                }\n            }\n            int k = low;\n            int a = x - (k - 1) * k / 2;\n            return (k, a);\n        }\n\n        // Computes the distance between two numbers (m and n) in a triangular grid.\n        // The distance is calculated based on their positions (k and a) in the grid.\n        public static int ComputeDistance(int m, int n)\n        {\n            var (k_m, a_m) = ComputeKA(m);\n            var (k_n, a_n) = ComputeKA(n);\n\n            if (k_m == k_n)\n            {\n                return Math.Abs(a_m - a_n);\n            }\n            else\n            {\n                // Ensure m is in the lower row\n                if (k_m > k_n)\n                {\n                    (k_m, k_n) = (k_n, k_m);\n                    (a_m, a_n) = (a_n, a_m);\n                }\n                int delta = k_n - k_m;\n                int left = a_m;\n                int right = a_m + delta;\n                int horizontal = Math.Max(Math.Max(left - a_n, a_n - right), 0);\n                return delta + horizontal;\n            }\n        }\n    }\n}\n\nnamespace GridDistanceCalculator\n{\n    class TestGridUtils\n    {\n        public static void Main()\n        {\n            // Test cases with expected results\n            Debug.Assert(GridUtils.ComputeDistance(1, 2) == 1);\n            Debug.Assert(GridUtils.ComputeDistance(3, 5) == 2);\n            Debug.Assert(GridUtils.ComputeDistance(1, 4) == 3);\n            Debug.Assert(GridUtils.ComputeDistance(6, 12) == 6);\n            Debug.Assert(GridUtils.ComputeDistance(10, 20) == 10);\n            Debug.Assert(GridUtils.ComputeDistance(7, 7) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace HalfSumCounter\n{\n    class Program\n    {\n        // CountHalfSumOccurrences calculates the sum of the input array,\n        // checks if half of this sum is an integer, and counts how many times\n        // this half-sum appears in the array.\n        // Returns the count if the half-sum exists and is an integer, otherwise returns -1.\n        static int CountHalfSumOccurrences(int[] nums)\n        {\n            int total = nums.Sum();\n            double target = (double)total / 2;\n\n            if (!IsInteger(target))\n            {\n                return -1;\n            }\n\n            int intTarget = (int)target;\n            int count = nums.Count(num => num == intTarget);\n\n            return count > 0 ? count : -1;\n        }\n\n        // Helper method to check if a double value is an integer\n        static bool IsInteger(double value)\n        {\n            return value == Math.Truncate(value);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\n-1\nInput: [5, 5, 10, 0]\n1\nInput: [2, 2, 2, 2]\n-1\nInput: [3, 3, 3]\n-1\nInput: [0, 0, 0, 0]\n4", "task_id": 14897, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace HalfSumCounter\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 1, 2, 3, 4 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 5, 5, 10, 0 }) == 1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 2, 2, 2, 2 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 3, 3, 3 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 0, 0, 0, 0 }) == 4);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace HalfSumCounter\n{\n    class Program\n    {\n        // CountHalfSumOccurrences calculates the sum of the input array,\n        // checks if half of this sum is an integer, and counts how many times\n        // this half-sum appears in the array.\n        // Returns the count if the half-sum exists and is an integer, otherwise returns -1.\n    public static int CountHalfSumOccurrences(int[] nums)\n        {\n            int total = nums.Sum();\n            double target = (double)total / 2;\n\n            if (!IsInteger(target))\n            {\n                return -1;\n            }\n\n            int intTarget = (int)target;\n            int count = nums.Count(num => num == intTarget);\n\n            return count > 0 ? count : -1;\n        }\n\n        // Helper method to check if a double value is an integer\n    public static bool IsInteger(double value)\n        {\n            return value == Math.Truncate(value);\n        }\n    }\n}\n\nnamespace HalfSumCounter\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 1, 2, 3, 4 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 5, 5, 10, 0 }) == 1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 2, 2, 2, 2 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 3, 3, 3 }) == -1);\n            Debug.Assert(Program.CountHalfSumOccurrences(new int[] { 0, 0, 0, 0 }) == 4);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace StringSplitter\n{\n    class Program\n    {\n        /// <summary>\n        /// Splits the string `s` into `k` parts such that each part has the minimum possible length difference.\n        /// Returns these `k` parts as an array of strings. If it is not possible to split the string into exactly `k` parts,\n        /// returns an empty array.\n        /// </summary>\n        /// <param name=\"s\">The string to split.</param>\n        /// <param name=\"k\">The number of parts to split the string into.</param>\n        /// <returns>An array of strings representing the split parts, or an empty array if splitting is not possible.</returns>\n        static string[] SplitString(string s, int k)\n        {\n            int length = s.Length;\n\n            if (k > length)\n            {\n                return new string[0];\n            }\n\n            int partSize = length / k;\n            int remainder = length % k;\n\n            string[] result = new string[k];\n            int start = 0;\n\n            for (int i = 0; i < k; i++)\n            {\n                int end = start + partSize + (i < remainder ? 1 : 0);\n                result[i] = s.Substring(start, end - start);\n                start = end;\n            }\n\n            return result;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input string: \"abcdefghij\", k: 3\nSplit parts: [abcd, efg, hij]\nInput string: \"hello\", k: 2\nSplit parts: [hel, lo]\nInput string: \"splitthis\", k: 4\nSplit parts: [spl, it, th, is]\nInput string: \"short\", k: 10\nCannot split the string into k parts.", "task_id": 21024, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StringSplitter\n{\n    class TestStringSplitter\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            string[] result1 = Program.SplitString(\"abcdefghij\", 3);\n            Debug.Assert(result1.Length == 3);\n            Debug.Assert(result1[0] == \"abcd\");\n            Debug.Assert(result1[1] == \"efg\");\n            Debug.Assert(result1[2] == \"hij\");\n\n            // Test case 2\n            string[] result2 = Program.SplitString(\"hello\", 2);\n            Debug.Assert(result2.Length == 2);\n            Debug.Assert(result2[0] == \"hel\");\n            Debug.Assert(result2[1] == \"lo\");\n\n            // Test case 3\n            string[] result3 = Program.SplitString(\"splitthis\", 4);\n            Debug.Assert(result3.Length == 4);\n            Debug.Assert(result3[0] == \"spl\");\n            Debug.Assert(result3[1] == \"it\");\n            Debug.Assert(result3[2] == \"th\");\n            Debug.Assert(result3[3] == \"is\");\n\n            // Test case 4\n            string[] result4 = Program.SplitString(\"short\", 10);\n            Debug.Assert(result4.Length == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace StringSplitter\n{\n    class Program\n    {\n        /// <summary>\n        /// Splits the string `s` into `k` parts such that each part has the minimum possible length difference.\n        /// Returns these `k` parts as an array of strings. If it is not possible to split the string into exactly `k` parts,\n        /// returns an empty array.\n        /// </summary>\n        /// <param name=\"s\">The string to split.</param>\n        /// <param name=\"k\">The number of parts to split the string into.</param>\n        /// <returns>An array of strings representing the split parts, or an empty array if splitting is not possible.</returns>\n    public static string[] SplitString(string s, int k)\n        {\n            int length = s.Length;\n\n            if (k > length)\n            {\n                return new string[0];\n            }\n\n            int partSize = length / k;\n            int remainder = length % k;\n\n            string[] result = new string[k];\n            int start = 0;\n\n            for (int i = 0; i < k; i++)\n            {\n                int end = start + partSize + (i < remainder ? 1 : 0);\n                result[i] = s.Substring(start, end - start);\n                start = end;\n            }\n\n            return result;\n        }\n    }\n}\n\nnamespace StringSplitter\n{\n    class TestStringSplitter\n    {\n        public static void Main()\n        {\n            // Test case 1\n            string[] result1 = Program.SplitString(\"abcdefghij\", 3);\n            Debug.Assert(result1.Length == 3);\n            Debug.Assert(result1[0] == \"abcd\");\n            Debug.Assert(result1[1] == \"efg\");\n            Debug.Assert(result1[2] == \"hij\");\n\n            // Test case 2\n            string[] result2 = Program.SplitString(\"hello\", 2);\n            Debug.Assert(result2.Length == 2);\n            Debug.Assert(result2[0] == \"hel\");\n            Debug.Assert(result2[1] == \"lo\");\n\n            // Test case 3\n            string[] result3 = Program.SplitString(\"splitthis\", 4);\n            Debug.Assert(result3.Length == 4);\n            Debug.Assert(result3[0] == \"spl\");\n            Debug.Assert(result3[1] == \"it\");\n            Debug.Assert(result3[2] == \"th\");\n            Debug.Assert(result3[3] == \"is\");\n\n            // Test case 4\n            string[] result4 = Program.SplitString(\"short\", 10);\n            Debug.Assert(result4.Length == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace DiscountCalculator\n{\n    class Program\n    {\n        // CalculateDiscountedPrices computes the discounted prices for a list of items\n        // given their original prices and discount percentages.\n        // Parameters:\n        //   originalPrices: An array of original prices as doubles.\n        //   discounts: An array of discount percentages as doubles.\n        // Returns:\n        //   An array of discounted prices as doubles.\n        public static double[] CalculateDiscountedPrices(double[] originalPrices, double[] discounts)\n        {\n            if (originalPrices.Length != discounts.Length)\n            {\n                throw new ArgumentException(\"Original prices and discounts arrays must have the same length.\");\n            }\n\n            double[] discountedPrices = new double[originalPrices.Length];\n            for (int i = 0; i < originalPrices.Length; i++)\n            {\n                discountedPrices[i] = originalPrices[i] * (1 - discounts[i] / 100);\n            }\n            return discountedPrices;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Original Prices: 100, 200, 300\nDiscounts: 10, 20, 30\nDiscounted Prices: 90, 160, 210\n\nOriginal Prices: 50, 75, 125\nDiscounts: 5, 10, 15\nDiscounted Prices: 47.5, 67.5, 106.25\n\nOriginal Prices: 10, 20, 30, 40\nDiscounts: 0, 25, 50, 75\nDiscounted Prices: 10, 15, 15, 10", "task_id": 5635, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace DiscountCalculator\n{\n    class TestDiscountCalculator\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            double[] originalPrices1 = { 100.0, 200.0, 300.0 };\n            double[] discounts1 = { 10.0, 20.0, 30.0 };\n            double[] expected1 = { 90.0, 160.0, 210.0 };\n            double[] result1 = Program.CalculateDiscountedPrices(originalPrices1, discounts1);\n            Debug.Assert(result1.Length == expected1.Length);\n            for (int i = 0; i < result1.Length; i++)\n            {\n                Debug.Assert(result1[i] == expected1[i]);\n            }\n\n            // Test Case 2\n            double[] originalPrices2 = { 50.0, 75.0, 125.0 };\n            double[] discounts2 = { 5.0, 10.0, 15.0 };\n            double[] expected2 = { 47.5, 67.5, 106.25 };\n            double[] result2 = Program.CalculateDiscountedPrices(originalPrices2, discounts2);\n            Debug.Assert(result2.Length == expected2.Length);\n            for (int i = 0; i < result2.Length; i++)\n            {\n                Debug.Assert(result2[i] == expected2[i]);\n            }\n\n            // Test Case 3\n            double[] originalPrices3 = { 10.0, 20.0, 30.0, 40.0 };\n            double[] discounts3 = { 0.0, 25.0, 50.0, 75.0 };\n            double[] expected3 = { 10.0, 15.0, 15.0, 10.0 };\n            double[] result3 = Program.CalculateDiscountedPrices(originalPrices3, discounts3);\n            Debug.Assert(result3.Length == expected3.Length);\n            for (int i = 0; i < result3.Length; i++)\n            {\n                Debug.Assert(result3[i] == expected3[i]);\n            }\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace DiscountCalculator\n{\n    class Program\n    {\n        // CalculateDiscountedPrices computes the discounted prices for a list of items\n        // given their original prices and discount percentages.\n        // Parameters:\n        //   originalPrices: An array of original prices as doubles.\n        //   discounts: An array of discount percentages as doubles.\n        // Returns:\n        //   An array of discounted prices as doubles.\n        public static double[] CalculateDiscountedPrices(double[] originalPrices, double[] discounts)\n        {\n            if (originalPrices.Length != discounts.Length)\n            {\n                throw new ArgumentException(\"Original prices and discounts arrays must have the same length.\");\n            }\n\n            double[] discountedPrices = new double[originalPrices.Length];\n            for (int i = 0; i < originalPrices.Length; i++)\n            {\n                discountedPrices[i] = originalPrices[i] * (1 - discounts[i] / 100);\n            }\n            return discountedPrices;\n        }\n    }\n}\n\nnamespace DiscountCalculator\n{\n    class TestDiscountCalculator\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            double[] originalPrices1 = { 100.0, 200.0, 300.0 };\n            double[] discounts1 = { 10.0, 20.0, 30.0 };\n            double[] expected1 = { 90.0, 160.0, 210.0 };\n            double[] result1 = Program.CalculateDiscountedPrices(originalPrices1, discounts1);\n            Debug.Assert(result1.Length == expected1.Length);\n            for (int i = 0; i < result1.Length; i++)\n            {\n                Debug.Assert(result1[i] == expected1[i]);\n            }\n\n            // Test Case 2\n            double[] originalPrices2 = { 50.0, 75.0, 125.0 };\n            double[] discounts2 = { 5.0, 10.0, 15.0 };\n            double[] expected2 = { 47.5, 67.5, 106.25 };\n            double[] result2 = Program.CalculateDiscountedPrices(originalPrices2, discounts2);\n            Debug.Assert(result2.Length == expected2.Length);\n            for (int i = 0; i < result2.Length; i++)\n            {\n                Debug.Assert(result2[i] == expected2[i]);\n            }\n\n            // Test Case 3\n            double[] originalPrices3 = { 10.0, 20.0, 30.0, 40.0 };\n            double[] discounts3 = { 0.0, 25.0, 50.0, 75.0 };\n            double[] expected3 = { 10.0, 15.0, 15.0, 10.0 };\n            double[] result3 = Program.CalculateDiscountedPrices(originalPrices3, discounts3);\n            Debug.Assert(result3.Length == expected3.Length);\n            for (int i = 0; i < result3.Length; i++)\n            {\n                Debug.Assert(result3[i] == expected3[i]);\n            }\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace GridPathfinder\n{\n    class Pathfinder\n    {\n        // minSteps calculates the minimum steps required to move from the start position to the target position in a grid.\n        // The grid is represented as a 2D char array where '.' represents a walkable path and '#' represents a blocked cell.\n        // The start and target positions are 1-based indices.\n        // Returns -1 if there is no valid path.\n        public static int MinSteps(char[][] grid, int[] start, int[] target)\n        {\n            int n = grid.Length;\n            int m = grid[0].Length;\n\n            // Convert to 0-based index\n            int r1 = start[0] - 1;\n            int c1 = start[1] - 1;\n            int r2 = target[0] - 1;\n            int c2 = target[1] - 1;\n\n            if (grid[r1][c1] == '#' || grid[r2][c2] == '#')\n            {\n                return -1;\n            }\n\n            // Directions: up, down, left, right\n            int[][] directions = new int[][]\n            {\n                new int[] { -1, 0 },\n                new int[] { 1, 0 },\n                new int[] { 0, -1 },\n                new int[] { 0, 1 }\n            };\n\n            Queue<(int, int, int)> queue = new Queue<(int, int, int)>();\n            queue.Enqueue((r1, c1, 0));\n            HashSet<(int, int)> visited = new HashSet<(int, int)>();\n            visited.Add((r1, c1));\n\n            while (queue.Count > 0)\n            {\n                var (r, c, steps) = queue.Dequeue();\n\n                if (r == r2 && c == c2)\n                {\n                    return steps;\n                }\n\n                foreach (var dir in directions)\n                {\n                    int nr = r + dir[0];\n                    int nc = c + dir[1];\n\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && !visited.Contains((nr, nc)) && grid[nr][nc] == '.')\n                    {\n                        visited.Add((nr, nc));\n                        queue.Enqueue((nr, nc, steps + 1));\n                    }\n                }\n            }\n\n            return -1;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nGrid:\n. . . #\n. # . .\n. . . .\nStart: [1, 1]\nTarget: [3, 4]\nMin Steps: 5\n\nTest Case 2:\nGrid:\n. # .\n# # #\n. # .\nStart: [1, 1]\nTarget: [3, 3]\nMin Steps: -1\n\nTest Case 3:\nGrid:\n. . .\n. . .\n. . #\nStart: [1, 1]\nTarget: [3, 3]\nMin Steps: -1", "task_id": 22126, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GridPathfinder\n{\n    class TestPathfinder\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: Simple grid with a clear path\n            char[][] grid1 = new char[][]\n            {\n                new char[] { '.', '.', '.', '#' },\n                new char[] { '.', '#', '.', '.' },\n                new char[] { '.', '.', '.', '.' }\n            };\n            int[] start1 = new int[] { 1, 1 };\n            int[] target1 = new int[] { 3, 4 };\n            Debug.Assert(Pathfinder.MinSteps(grid1, start1, target1) == 5);\n\n            // Test Case 2: Grid with no valid path\n            char[][] grid2 = new char[][]\n            {\n                new char[] { '.', '#', '.' },\n                new char[] { '#', '#', '#' },\n                new char[] { '.', '#', '.' }\n            };\n            int[] start2 = new int[] { 1, 1 };\n            int[] target2 = new int[] { 3, 3 };\n            Debug.Assert(Pathfinder.MinSteps(grid2, start2, target2) == -1);\n\n            // Test Case 3: Start or target is blocked\n            char[][] grid3 = new char[][]\n            {\n                new char[] { '.', '.', '.' },\n                new char[] { '.', '.', '.' },\n                new char[] { '.', '.', '#' }\n            };\n            int[] start3 = new int[] { 1, 1 };\n            int[] target3 = new int[] { 3, 3 };\n            Debug.Assert(Pathfinder.MinSteps(grid3, start3, target3) == -1);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace GridPathfinder\n{\n    class Pathfinder\n    {\n        // minSteps calculates the minimum steps required to move from the start position to the target position in a grid.\n        // The grid is represented as a 2D char array where '.' represents a walkable path and '#' represents a blocked cell.\n        // The start and target positions are 1-based indices.\n        // Returns -1 if there is no valid path.\n        public static int MinSteps(char[][] grid, int[] start, int[] target)\n        {\n            int n = grid.Length;\n            int m = grid[0].Length;\n\n            // Convert to 0-based index\n            int r1 = start[0] - 1;\n            int c1 = start[1] - 1;\n            int r2 = target[0] - 1;\n            int c2 = target[1] - 1;\n\n            if (grid[r1][c1] == '#' || grid[r2][c2] == '#')\n            {\n                return -1;\n            }\n\n            // Directions: up, down, left, right\n            int[][] directions = new int[][]\n            {\n                new int[] { -1, 0 },\n                new int[] { 1, 0 },\n                new int[] { 0, -1 },\n                new int[] { 0, 1 }\n            };\n\n            Queue<(int, int, int)> queue = new Queue<(int, int, int)>();\n            queue.Enqueue((r1, c1, 0));\n            HashSet<(int, int)> visited = new HashSet<(int, int)>();\n            visited.Add((r1, c1));\n\n            while (queue.Count > 0)\n            {\n                var (r, c, steps) = queue.Dequeue();\n\n                if (r == r2 && c == c2)\n                {\n                    return steps;\n                }\n\n                foreach (var dir in directions)\n                {\n                    int nr = r + dir[0];\n                    int nc = c + dir[1];\n\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m && !visited.Contains((nr, nc)) && grid[nr][nc] == '.')\n                    {\n                        visited.Add((nr, nc));\n                        queue.Enqueue((nr, nc, steps + 1));\n                    }\n                }\n            }\n\n            return -1;\n        }\n    }\n}\n\nnamespace GridPathfinder\n{\n    class TestPathfinder\n    {\n        public static void Main()\n        {\n            // Test Case 1: Simple grid with a clear path\n            char[][] grid1 = new char[][]\n            {\n                new char[] { '.', '.', '.', '#' },\n                new char[] { '.', '#', '.', '.' },\n                new char[] { '.', '.', '.', '.' }\n            };\n            int[] start1 = new int[] { 1, 1 };\n            int[] target1 = new int[] { 3, 4 };\n            Debug.Assert(Pathfinder.MinSteps(grid1, start1, target1) == 5);\n\n            // Test Case 2: Grid with no valid path\n            char[][] grid2 = new char[][]\n            {\n                new char[] { '.', '#', '.' },\n                new char[] { '#', '#', '#' },\n                new char[] { '.', '#', '.' }\n            };\n            int[] start2 = new int[] { 1, 1 };\n            int[] target2 = new int[] { 3, 3 };\n            Debug.Assert(Pathfinder.MinSteps(grid2, start2, target2) == -1);\n\n            // Test Case 3: Start or target is blocked\n            char[][] grid3 = new char[][]\n            {\n                new char[] { '.', '.', '.' },\n                new char[] { '.', '.', '.' },\n                new char[] { '.', '.', '#' }\n            };\n            int[] start3 = new int[] { 1, 1 };\n            int[] target3 = new int[] { 3, 3 };\n            Debug.Assert(Pathfinder.MinSteps(grid3, start3, target3) == -1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace RepeatedSubstringChecker\n{\n    class Program\n    {\n        // Checks if the given string 's' contains any repeated substring of length 3 or more.\n        // Returns true if a repeated substring is found, false otherwise.\n        public static bool ContainsRepeatedSubstring(string s)\n        {\n            int n = s.Length;\n            HashSet<string> seenSubstrings = new HashSet<string>();\n            \n            // Check for all possible substring lengths from 3 up to half the string length\n            for (int length = 3; length <= n / 2 + 1; length++)\n            {\n                // Check all possible starting positions for the current substring length\n                for (int start = 0; start <= n - length; start++)\n                {\n                    string substring = s.Substring(start, length);\n                    if (seenSubstrings.Contains(substring))\n                    {\n                        return true;\n                    }\n                    seenSubstrings.Add(substring);\n                }\n            }\n            \n            return false;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: \"abcabc\"\nContains repeated substring: true\n\nInput: \"abcdefgh\"\nContains repeated substring: false\n\nInput: \"aaa\"\nContains repeated substring: false\n\nInput: \"ababab\"\nContains repeated substring: true\n\nInput: \"xyzxyzxyz\"\nContains repeated substring: true\n\nInput: \"aabbcc\"\nContains repeated substring: false\n\nInput: \"hellohell\"\nContains repeated substring: true", "task_id": 12384, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace RepeatedSubstringChecker\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"abcabc\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"abcdefgh\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"aaa\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"ababab\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"xyzxyzxyz\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"aabbcc\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"hellohell\") == true);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace RepeatedSubstringChecker\n{\n    class Program\n    {\n        // Checks if the given string 's' contains any repeated substring of length 3 or more.\n        // Returns true if a repeated substring is found, false otherwise.\n        public static bool ContainsRepeatedSubstring(string s)\n        {\n            int n = s.Length;\n            HashSet<string> seenSubstrings = new HashSet<string>();\n            \n            // Check for all possible substring lengths from 3 up to half the string length\n            for (int length = 3; length <= n / 2 + 1; length++)\n            {\n                // Check all possible starting positions for the current substring length\n                for (int start = 0; start <= n - length; start++)\n                {\n                    string substring = s.Substring(start, length);\n                    if (seenSubstrings.Contains(substring))\n                    {\n                        return true;\n                    }\n                    seenSubstrings.Add(substring);\n                }\n            }\n            \n            return false;\n        }\n    }\n}\n\nnamespace RepeatedSubstringChecker\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"abcabc\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"abcdefgh\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"aaa\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"ababab\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"xyzxyzxyz\") == true);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"aabbcc\") == false);\n            Debug.Assert(Program.ContainsRepeatedSubstring(\"hellohell\") == true);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace SudokuSolver\n{\n    class SudokuSolver\n    {\n        // Solves a given 9x9 Sudoku puzzle board in-place.\n        // The board is represented as a 9x9 array of integers, with zeros representing empty spaces.\n        public static bool SolveSudoku(int[,] board)\n        {\n            return Solve(board);\n        }\n\n        // Helper method to check if a number can be placed in a specific cell without violating Sudoku rules.\n        static bool IsValid(int[,] board, int row, int col, int num)\n        {\n            // Check if the number is not in the current row or column\n            for (int i = 0; i < 9; i++)\n            {\n                if (board[row, i] == num || board[i, col] == num)\n                {\n                    return false;\n                }\n            }\n\n            // Check if the number is not in the current 3x3 subgrid\n            int startRow = 3 * (row / 3);\n            int startCol = 3 * (col / 3);\n            for (int i = startRow; i < startRow + 3; i++)\n            {\n                for (int j = startCol; j < startCol + 3; j++)\n                {\n                    if (board[i, j] == num)\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        // Recursive helper method to solve the Sudoku puzzle using backtracking.\n        static bool Solve(int[,] board)\n        {\n            for (int row = 0; row < 9; row++)\n            {\n                for (int col = 0; col < 9; col++)\n                {\n                    if (board[row, col] == 0)\n                    {\n                        for (int num = 1; num <= 9; num++)\n                        {\n                            if (IsValid(board, row, col, num))\n                            {\n                                board[row, col] = num;\n                                if (Solve(board))\n                                {\n                                    return true;\n                                }\n                                board[row, col] = 0; // Backtrack\n                            }\n                        }\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        // Helper method to print the Sudoku board to the console.\n        public static void PrintBoard(int[,] board)\n        {\n            for (int i = 0; i < 9; i++)\n            {\n                for (int j = 0; j < 9; j++)\n                {\n                    Console.Write(board[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Board 1 (Before Solving):\n5 3 0 0 7 0 0 0 0 \n6 0 0 1 9 5 0 0 0 \n0 9 8 0 0 0 0 6 0 \n8 0 0 0 6 0 0 0 3 \n4 0 0 8 0 3 0 0 1 \n7 0 0 0 2 0 0 0 6 \n0 6 0 0 0 0 2 8 0 \n0 0 0 4 1 9 0 0 5 \n0 0 0 0 8 0 0 7 9 \n\nTest Board 1 (After Solving):\n5 3 4 6 7 8 9 1 2 \n6 7 2 1 9 5 3 4 8 \n1 9 8 3 4 2 5 6 7 \n8 5 9 7 6 1 4 2 3 \n4 2 6 8 5 3 7 9 1 \n7 1 3 9 2 4 8 5 6 \n9 6 1 5 3 7 2 8 4 \n2 8 7 4 1 9 6 3 5 \n3 4 5 2 8 6 1 7 9 \n\nSolved Successfully: True\n\nTest Board 2 (Before Solving):\n0 0 0 2 6 0 7 0 1 \n6 8 0 0 7 0 0 9 0 \n1 9 0 0 0 4 5 0 0 \n8 2 0 1 0 0 0 4 0 \n0 0 4 6 0 2 9 0 0 \n0 5 0 0 0 3 0 2 8 \n0 0 9 3 0 0 0 7 4 \n0 4 0 0 5 0 0 3 6 \n7 0 3 0 1 8 0 0 0 \n\nTest Board 2 (After Solving):\n4 3 5 2 6 9 7 8 1 \n6 8 2 5 7 1 4 9 3 \n1 9 7 8 3 4 5 6 2 \n8 2 6 1 9 5 3 4 7 \n3 7 4 6 8 2 9 1 5 \n9 5 1 7 4 3 6 2 8 \n5 1 9 3 2 6 8 7 4 \n2 4 8 9 5 7 1 3 6 \n7 6 3 4 1 8 2 5 9 \n\nSolved Successfully: True", "task_id": 359, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace SudokuSolver\n{\n    class TestSudokuSolver\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[,] testBoard1 = new int[,]\n            {\n                {5, 3, 0, 0, 7, 0, 0, 0, 0},\n                {6, 0, 0, 1, 9, 5, 0, 0, 0},\n                {0, 9, 8, 0, 0, 0, 0, 6, 0},\n                {8, 0, 0, 0, 6, 0, 0, 0, 3},\n                {4, 0, 0, 8, 0, 3, 0, 0, 1},\n                {7, 0, 0, 0, 2, 0, 0, 0, 6},\n                {0, 6, 0, 0, 0, 0, 2, 8, 0},\n                {0, 0, 0, 4, 1, 9, 0, 0, 5},\n                {0, 0, 0, 0, 8, 0, 0, 7, 9}\n            };\n\n            bool isSolved1 = SudokuSolver.SolveSudoku(testBoard1);\n            Debug.Assert(isSolved1);\n            Debug.Assert(testBoard1[0, 0] == 5 && testBoard1[0, 1] == 3 && testBoard1[0, 2] == 4);\n            Debug.Assert(testBoard1[8, 6] == 1 && testBoard1[8, 7] == 7 && testBoard1[8, 8] == 9);\n\n            // Test case 2\n            int[,] testBoard2 = new int[,]\n            {\n                {0, 0, 0, 2, 6, 0, 7, 0, 1},\n                {6, 8, 0, 0, 7, 0, 0, 9, 0},\n                {1, 9, 0, 0, 0, 4, 5, 0, 0},\n                {8, 2, 0, 1, 0, 0, 0, 4, 0},\n                {0, 0, 4, 6, 0, 2, 9, 0, 0},\n                {0, 5, 0, 0, 0, 3, 0, 2, 8},\n                {0, 0, 9, 3, 0, 0, 0, 7, 4},\n                {0, 4, 0, 0, 5, 0, 0, 3, 6},\n                {7, 0, 3, 0, 1, 8, 0, 0, 0}\n            };\n\n            bool isSolved2 = SudokuSolver.SolveSudoku(testBoard2);\n            Debug.Assert(isSolved2);\n            Debug.Assert(testBoard2[0, 0] == 4 && testBoard2[0, 1] == 3 && testBoard2[0, 2] == 5);\n            Debug.Assert(testBoard2[8, 6] == 2 && testBoard2[8, 7] == 5 && testBoard2[8, 8] == 9);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace SudokuSolver\n{\n    class SudokuSolver\n    {\n        // Solves a given 9x9 Sudoku puzzle board in-place.\n        // The board is represented as a 9x9 array of integers, with zeros representing empty spaces.\n        public static bool SolveSudoku(int[,] board)\n        {\n            return Solve(board);\n        }\n\n        // Helper method to check if a number can be placed in a specific cell without violating Sudoku rules.\n    public static bool IsValid(int[,] board, int row, int col, int num)\n        {\n            // Check if the number is not in the current row or column\n            for (int i = 0; i < 9; i++)\n            {\n                if (board[row, i] == num || board[i, col] == num)\n                {\n                    return false;\n                }\n            }\n\n            // Check if the number is not in the current 3x3 subgrid\n            int startRow = 3 * (row / 3);\n            int startCol = 3 * (col / 3);\n            for (int i = startRow; i < startRow + 3; i++)\n            {\n                for (int j = startCol; j < startCol + 3; j++)\n                {\n                    if (board[i, j] == num)\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        // Recursive helper method to solve the Sudoku puzzle using backtracking.\n    public static bool Solve(int[,] board)\n        {\n            for (int row = 0; row < 9; row++)\n            {\n                for (int col = 0; col < 9; col++)\n                {\n                    if (board[row, col] == 0)\n                    {\n                        for (int num = 1; num <= 9; num++)\n                        {\n                            if (IsValid(board, row, col, num))\n                            {\n                                board[row, col] = num;\n                                if (Solve(board))\n                                {\n                                    return true;\n                                }\n                                board[row, col] = 0; // Backtrack\n                            }\n                        }\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        // Helper method to print the Sudoku board to the console.\n        public static void PrintBoard(int[,] board)\n        {\n            for (int i = 0; i < 9; i++)\n            {\n                for (int j = 0; j < 9; j++)\n                {\n                    Console.Write(board[i, j] + \" \");\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n\nnamespace SudokuSolver\n{\n    class TestSudokuSolver\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[,] testBoard1 = new int[,]\n            {\n                {5, 3, 0, 0, 7, 0, 0, 0, 0},\n                {6, 0, 0, 1, 9, 5, 0, 0, 0},\n                {0, 9, 8, 0, 0, 0, 0, 6, 0},\n                {8, 0, 0, 0, 6, 0, 0, 0, 3},\n                {4, 0, 0, 8, 0, 3, 0, 0, 1},\n                {7, 0, 0, 0, 2, 0, 0, 0, 6},\n                {0, 6, 0, 0, 0, 0, 2, 8, 0},\n                {0, 0, 0, 4, 1, 9, 0, 0, 5},\n                {0, 0, 0, 0, 8, 0, 0, 7, 9}\n            };\n\n            bool isSolved1 = SudokuSolver.SolveSudoku(testBoard1);\n            Debug.Assert(isSolved1);\n            Debug.Assert(testBoard1[0, 0] == 5 && testBoard1[0, 1] == 3 && testBoard1[0, 2] == 4);\n            Debug.Assert(testBoard1[8, 6] == 1 && testBoard1[8, 7] == 7 && testBoard1[8, 8] == 9);\n\n            // Test case 2\n            int[,] testBoard2 = new int[,]\n            {\n                {0, 0, 0, 2, 6, 0, 7, 0, 1},\n                {6, 8, 0, 0, 7, 0, 0, 9, 0},\n                {1, 9, 0, 0, 0, 4, 5, 0, 0},\n                {8, 2, 0, 1, 0, 0, 0, 4, 0},\n                {0, 0, 4, 6, 0, 2, 9, 0, 0},\n                {0, 5, 0, 0, 0, 3, 0, 2, 8},\n                {0, 0, 9, 3, 0, 0, 0, 7, 4},\n                {0, 4, 0, 0, 5, 0, 0, 3, 6},\n                {7, 0, 3, 0, 1, 8, 0, 0, 0}\n            };\n\n            bool isSolved2 = SudokuSolver.SolveSudoku(testBoard2);\n            Debug.Assert(isSolved2);\n            Debug.Assert(testBoard2[0, 0] == 4 && testBoard2[0, 1] == 3 && testBoard2[0, 2] == 5);\n            Debug.Assert(testBoard2[8, 6] == 2 && testBoard2[8, 7] == 5 && testBoard2[8, 8] == 9);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AntFallDownTime\n{\n    class AntFallDownCalculator\n    {\n        // CalculateLastAntFallDownTime calculates the time when the last ant falls down from a stick of length L.\n        // Each ant starts at position x and moves left ('L') or right ('R').\n        // The time for an ant moving left is x seconds, and for an ant moving right is (L - x) seconds.\n        // The method returns the maximum time among all ants, which is when the last ant falls down.\n        public static int CalculateLastAntFallDownTime(int L, int[] positions, string[] directions)\n        {\n            List<int> times = new List<int>();\n            for (int i = 0; i < positions.Length; i++)\n            {\n                if (directions[i] == \"L\")\n                {\n                    times.Add(positions[i]);\n                }\n                else\n                {\n                    times.Add(L - positions[i]);\n                }\n            }\n            return times.Count > 0 ? times.Max() : 0;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: L = 10, Positions = [2, 6, 7], Directions = [L, R, L]\nThe last ant will fall down in 7 seconds.\nInput: L = 20, Positions = [3, 5, 10, 18], Directions = [R, L, R, L]\nThe last ant will fall down in 18 seconds.\nInput: L = 15, Positions = [8], Directions = [R]\nThe last ant will fall down in 7 seconds.\nInput: L = 5, Positions = [], Directions = []\nThe last ant will fall down in 0 seconds.", "task_id": 28532, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace AntFallDownTime\n{\n    class TestAntFallDownCalculator\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            int L1 = 10;\n            int[] positions1 = { 2, 6, 7 };\n            string[] directions1 = { \"L\", \"R\", \"L\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L1, positions1, directions1) == 7);\n\n            // Test Case 2\n            int L2 = 20;\n            int[] positions2 = { 3, 5, 10, 18 };\n            string[] directions2 = { \"R\", \"L\", \"R\", \"L\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L2, positions2, directions2) == 18);\n\n            // Test Case 3 (Edge case: single ant)\n            int L3 = 15;\n            int[] positions3 = { 8 };\n            string[] directions3 = { \"R\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L3, positions3, directions3) == 7);\n\n            // Test Case 4 (Edge case: no ants)\n            int L4 = 5;\n            int[] positions4 = { };\n            string[] directions4 = { };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L4, positions4, directions4) == 0);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace AntFallDownTime\n{\n    class AntFallDownCalculator\n    {\n        // CalculateLastAntFallDownTime calculates the time when the last ant falls down from a stick of length L.\n        // Each ant starts at position x and moves left ('L') or right ('R').\n        // The time for an ant moving left is x seconds, and for an ant moving right is (L - x) seconds.\n        // The method returns the maximum time among all ants, which is when the last ant falls down.\n        public static int CalculateLastAntFallDownTime(int L, int[] positions, string[] directions)\n        {\n            List<int> times = new List<int>();\n            for (int i = 0; i < positions.Length; i++)\n            {\n                if (directions[i] == \"L\")\n                {\n                    times.Add(positions[i]);\n                }\n                else\n                {\n                    times.Add(L - positions[i]);\n                }\n            }\n            return times.Count > 0 ? times.Max() : 0;\n        }\n    }\n}\n\nnamespace AntFallDownTime\n{\n    class TestAntFallDownCalculator\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            int L1 = 10;\n            int[] positions1 = { 2, 6, 7 };\n            string[] directions1 = { \"L\", \"R\", \"L\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L1, positions1, directions1) == 7);\n\n            // Test Case 2\n            int L2 = 20;\n            int[] positions2 = { 3, 5, 10, 18 };\n            string[] directions2 = { \"R\", \"L\", \"R\", \"L\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L2, positions2, directions2) == 18);\n\n            // Test Case 3 (Edge case: single ant)\n            int L3 = 15;\n            int[] positions3 = { 8 };\n            string[] directions3 = { \"R\" };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L3, positions3, directions3) == 7);\n\n            // Test Case 4 (Edge case: no ants)\n            int L4 = 5;\n            int[] positions4 = { };\n            string[] directions4 = { };\n            Debug.Assert(AntFallDownCalculator.CalculateLastAntFallDownTime(L4, positions4, directions4) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace TestCaseSolver\n{\n    class Program\n    {\n        // Solves a single test case given l and r.\n        // Returns 0 if l equals r, 10^18 if l is 1 and r is 2, otherwise returns r - l.\n        public static long SolveTestCase(int l, int r)\n        {\n            if (l == r)\n            {\n                return 0;\n            }\n            if (l == 1 && r == 2)\n            {\n                return 1000000000000000000L; // 10^18\n            }\n            return r - l;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: l = 1, r = 1\nResult: 0\n\nInput: l = 1, r = 2\nResult: 1000000000000000000\n\nInput: l = 3, r = 5\nResult: 2\n\nInput: l = 10, r = 20\nResult: 10\n\nInput: l = 0, r = 0\nResult: 0\n\nInput: l = 2, r = 3\nResult: 1", "task_id": 17797, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace TestCaseSolver\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.SolveTestCase(1, 1) == 0);\n            Debug.Assert(Program.SolveTestCase(1, 2) == 1000000000000000000L);\n            Debug.Assert(Program.SolveTestCase(3, 5) == 2);\n            Debug.Assert(Program.SolveTestCase(10, 20) == 10);\n            Debug.Assert(Program.SolveTestCase(0, 0) == 0);\n            Debug.Assert(Program.SolveTestCase(2, 3) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace TestCaseSolver\n{\n    class Program\n    {\n        // Solves a single test case given l and r.\n        // Returns 0 if l equals r, 10^18 if l is 1 and r is 2, otherwise returns r - l.\n        public static long SolveTestCase(int l, int r)\n        {\n            if (l == r)\n            {\n                return 0;\n            }\n            if (l == 1 && r == 2)\n            {\n                return 1000000000000000000L; // 10^18\n            }\n            return r - l;\n        }\n    }\n}\n\nnamespace TestCaseSolver\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.SolveTestCase(1, 1) == 0);\n            Debug.Assert(Program.SolveTestCase(1, 2) == 1000000000000000000L);\n            Debug.Assert(Program.SolveTestCase(3, 5) == 2);\n            Debug.Assert(Program.SolveTestCase(10, 20) == 10);\n            Debug.Assert(Program.SolveTestCase(0, 0) == 0);\n            Debug.Assert(Program.SolveTestCase(2, 3) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace DynamicProgrammingSolution\n{\n    class DynamicProgrammingSolution\n    {\n        // Constants for modulus and maximum value\n        public const int MOD = 1000000007;\n        public const int MAXN = 100000;\n\n        // Precompute the dynamic programming arrays\n        public static void PrecomputeDP(out int[] dp1, out int[] dp2, out int[] ans)\n        {\n            dp1 = new int[MAXN + 1];\n            dp2 = new int[MAXN + 1];\n            ans = new int[MAXN + 1];\n\n            // Base cases\n            dp1[1] = 3;  // Day 1: one way with single consecutive occurrence\n            dp2[1] = 0;  // Day 1: no way to have two consecutive same days\n\n            // Fill the DP arrays\n            for (int i = 2; i <= MAXN; i++)\n            {\n                dp1[i] = (int)(((long)(dp1[i - 1] + dp2[i - 1]) * 2) % MOD);\n                dp2[i] = dp1[i - 1] % MOD;\n            }\n\n            // Compute the answer array\n            for (int i = 1; i <= MAXN; i++)\n            {\n                ans[i] = (dp1[i] + dp2[i]) % MOD;\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input n: 1\nResult: 3\n\nInput n: 2\nResult: 9\n\nInput n: 3\nResult: 24\n\nInput n: 5\nResult: 180\n\nInput n: 10\nResult: 27408\n\nInput n: 100\nResult: 4220901\n\nInput n: 1000\nResult: 411653997\n\nInput n: 10000\nResult: 379155103\n\nInput n: 100000\nResult: 813268185", "task_id": 15895, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace DynamicProgrammingSolution\n{\n    class TestDynamicProgrammingSolution\n    {\n        public static void RunTests()\n        {\n            DynamicProgrammingSolution.PrecomputeDP(out var dp1, out var dp2, out var ans);\n\n            Debug.Assert(ans[1] == 3);\n            Debug.Assert(ans[2] == 9);\n            Debug.Assert(ans[3] == 24);\n            Debug.Assert(ans[5] == 180);\n            Debug.Assert(ans[10] == 27408);\n            Debug.Assert(ans[100] == 4220901);\n            Debug.Assert(ans[1000] == 411653997);\n            Debug.Assert(ans[10000] == 379155103);\n            Debug.Assert(ans[100000] == 813268185);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace DynamicProgrammingSolution\n{\n    class DynamicProgrammingSolution\n    {\n        // Constants for modulus and maximum value\n        public const int MOD = 1000000007;\n        public const int MAXN = 100000;\n\n        // Precompute the dynamic programming arrays\n        public static void PrecomputeDP(out int[] dp1, out int[] dp2, out int[] ans)\n        {\n            dp1 = new int[MAXN + 1];\n            dp2 = new int[MAXN + 1];\n            ans = new int[MAXN + 1];\n\n            // Base cases\n            dp1[1] = 3;  // Day 1: one way with single consecutive occurrence\n            dp2[1] = 0;  // Day 1: no way to have two consecutive same days\n\n            // Fill the DP arrays\n            for (int i = 2; i <= MAXN; i++)\n            {\n                dp1[i] = (int)(((long)(dp1[i - 1] + dp2[i - 1]) * 2) % MOD);\n                dp2[i] = dp1[i - 1] % MOD;\n            }\n\n            // Compute the answer array\n            for (int i = 1; i <= MAXN; i++)\n            {\n                ans[i] = (dp1[i] + dp2[i]) % MOD;\n            }\n        }\n    }\n}\n\nnamespace DynamicProgrammingSolution\n{\n    class TestDynamicProgrammingSolution\n    {\n        public static void Main()\n        {\n            DynamicProgrammingSolution.PrecomputeDP(out var dp1, out var dp2, out var ans);\n\n            Debug.Assert(ans[1] == 3);\n            Debug.Assert(ans[2] == 9);\n            Debug.Assert(ans[3] == 24);\n            Debug.Assert(ans[5] == 180);\n            Debug.Assert(ans[10] == 27408);\n            Debug.Assert(ans[100] == 4220901);\n            Debug.Assert(ans[1000] == 411653997);\n            Debug.Assert(ans[10000] == 379155103);\n            Debug.Assert(ans[100000] == 813268185);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace TeamSelection\n{\n    class Program\n    {\n        // Finds the number of team members that meet the criteria (A >= x and B <= y)\n        // and returns the indices of test cases with the maximum count.\n        static List<int> FindBestTeams(List<(int A, int B)> members, List<(int X, int Y)> testCases)\n        {\n            // Sort members by B ascending, then by A ascending\n            var sortedMembers = members.OrderBy(m => m.B).ThenBy(m => m.A).ToList();\n            var sortedB = sortedMembers.Select(m => m.B).ToList();\n            var sortedA = sortedMembers.Select(m => m.A).ToList();\n\n            int maxCount = 0;\n            List<int> results = new List<int>();\n\n            for (int idx = 0; idx < testCases.Count; idx++)\n            {\n                int x = testCases[idx].X;\n                int y = testCases[idx].Y;\n\n                // Find the rightmost index where B <= y\n                int k = sortedB.BinarySearch(y);\n                if (k < 0)\n                {\n                    k = ~k; // Bitwise complement to get the insertion point\n                }\n                else\n                {\n                    k++; // If exact match found, move to the next index\n                }\n\n                // Count the number of A >= x in the first k elements\n                int count = sortedA.Take(k).Count(a => a >= x);\n\n                // Update max and results\n                if (count > maxCount)\n                {\n                    maxCount = count;\n                    results = new List<int> { idx + 1 };\n                }\n                else if (count == maxCount)\n                {\n                    results.Add(idx + 1);\n                }\n            }\n\n            return maxCount == 0 ? new List<int> { 0 } : results.OrderBy(i => i).ToList();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nMembers: (10, 20), (15, 25), (5, 15), (30, 10)\nTest Cases: (10, 20), (15, 25), (5, 30)\nResult: 3\n\nTest Case 2:\nMembers: (1, 2), (3, 4)\nTest Cases: (5, 1), (4, 3)\nResult: 0\n\nTest Case 3:\nMembers: (10, 10), (20, 20)\nTest Cases: (5, 30), (10, 20)\nResult: 1, 2", "task_id": 29772, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace TeamSelection\n{\n    class TestTeamSelection\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Sample input from the problem\n            var members1 = new List<(int A, int B)>\n            {\n                (10, 20),\n                (15, 25),\n                (5, 15),\n                (30, 10)\n            };\n\n            var testCases1 = new List<(int X, int Y)>\n            {\n                (10, 20),\n                (15, 25),\n                (5, 30)\n            };\n\n            var result1 = Program.FindBestTeams(members1, testCases1);\n            Debug.Assert(result1.SequenceEqual(new List<int> { 3 }));\n\n            // Test case 2: No members meet the criteria\n            var members2 = new List<(int A, int B)>\n            {\n                (1, 2),\n                (3, 4)\n            };\n\n            var testCases2 = new List<(int X, int Y)>\n            {\n                (5, 1),\n                (4, 3)\n            };\n\n            var result2 = Program.FindBestTeams(members2, testCases2);\n            Debug.Assert(result2.SequenceEqual(new List<int> { 0 }));\n\n            // Test case 3: All members meet the criteria\n            var members3 = new List<(int A, int B)>\n            {\n                (10, 10),\n                (20, 20)\n            };\n\n            var testCases3 = new List<(int X, int Y)>\n            {\n                (5, 30),\n                (10, 20)\n            };\n\n            var result3 = Program.FindBestTeams(members3, testCases3);\n            Debug.Assert(result3.SequenceEqual(new List<int> { 1, 2 }));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace TeamSelection\n{\n    class Program\n    {\n        // Finds the number of team members that meet the criteria (A >= x and B <= y)\n        // and returns the indices of test cases with the maximum count.\n    public static List<int> FindBestTeams(List<(int A, int B)> members, List<(int X, int Y)> testCases)\n        {\n            // Sort members by B ascending, then by A ascending\n            var sortedMembers = members.OrderBy(m => m.B).ThenBy(m => m.A).ToList();\n            var sortedB = sortedMembers.Select(m => m.B).ToList();\n            var sortedA = sortedMembers.Select(m => m.A).ToList();\n\n            int maxCount = 0;\n            List<int> results = new List<int>();\n\n            for (int idx = 0; idx < testCases.Count; idx++)\n            {\n                int x = testCases[idx].X;\n                int y = testCases[idx].Y;\n\n                // Find the rightmost index where B <= y\n                int k = sortedB.BinarySearch(y);\n                if (k < 0)\n                {\n                    k = ~k; // Bitwise complement to get the insertion point\n                }\n                else\n                {\n                    k++; // If exact match found, move to the next index\n                }\n\n                // Count the number of A >= x in the first k elements\n                int count = sortedA.Take(k).Count(a => a >= x);\n\n                // Update max and results\n                if (count > maxCount)\n                {\n                    maxCount = count;\n                    results = new List<int> { idx + 1 };\n                }\n                else if (count == maxCount)\n                {\n                    results.Add(idx + 1);\n                }\n            }\n\n            return maxCount == 0 ? new List<int> { 0 } : results.OrderBy(i => i).ToList();\n        }\n    }\n}\n\nnamespace TeamSelection\n{\n    class TestTeamSelection\n    {\n        public static void Main()\n        {\n            // Test case 1: Sample input from the problem\n            var members1 = new List<(int A, int B)>\n            {\n                (10, 20),\n                (15, 25),\n                (5, 15),\n                (30, 10)\n            };\n\n            var testCases1 = new List<(int X, int Y)>\n            {\n                (10, 20),\n                (15, 25),\n                (5, 30)\n            };\n\n            var result1 = Program.FindBestTeams(members1, testCases1);\n            Debug.Assert(result1.SequenceEqual(new List<int> { 3 }));\n\n            // Test case 2: No members meet the criteria\n            var members2 = new List<(int A, int B)>\n            {\n                (1, 2),\n                (3, 4)\n            };\n\n            var testCases2 = new List<(int X, int Y)>\n            {\n                (5, 1),\n                (4, 3)\n            };\n\n            var result2 = Program.FindBestTeams(members2, testCases2);\n            Debug.Assert(result2.SequenceEqual(new List<int> { 0 }));\n\n            // Test case 3: All members meet the criteria\n            var members3 = new List<(int A, int B)>\n            {\n                (10, 10),\n                (20, 20)\n            };\n\n            var testCases3 = new List<(int X, int Y)>\n            {\n                (5, 30),\n                (10, 20)\n            };\n\n            var result3 = Program.FindBestTeams(members3, testCases3);\n            Debug.Assert(result3.SequenceEqual(new List<int> { 1, 2 }));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace LongestStackSequence\n{\n    class Program\n    {\n        // Calculates the length of the longest possible sequence of containers\n        // that can be stacked such that each container is heavier than the one below it.\n        // Uses dynamic programming to solve the problem.\n        // weights: Array of container weights.\n        // Returns: Length of the longest stackable sequence of containers.\n        static int LongestStackSequence(int[] weights)\n        {\n            int n = weights.Length;\n            if (n == 0)\n            {\n                return 0;\n            }\n\n            int[] dp = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                dp[i] = 1; // Initialize DP array where each sequence length is at least 1\n            }\n\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = 0; j < i; j++)\n                {\n                    if (weights[i] > weights[j])\n                    {\n                        dp[i] = Math.Max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n\n            int maxLength = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (dp[i] > maxLength)\n                {\n                    maxLength = dp[i];\n                }\n            }\n\n            return maxLength;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [3, 1, 4, 1, 5, 9, 2, 6, 5]\nLongest stackable sequence length: 4\nInput: [10, 20, 10, 30, 10, 40]\nLongest stackable sequence length: 4\nInput: [1, 2, 3, 4, 5]\nLongest stackable sequence length: 5\nInput: [5, 4, 3, 2, 1]\nLongest stackable sequence length: 1\nInput: []\nLongest stackable sequence length: 0", "task_id": 12045, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace LongestStackSequence\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[] testCase1 = { 3, 1, 4, 1, 5, 9, 2, 6, 5 };\n            Debug.Assert(Program.LongestStackSequence(testCase1) == 4);\n\n            // Test case 2\n            int[] testCase2 = { 10, 20, 10, 30, 10, 40 };\n            Debug.Assert(Program.LongestStackSequence(testCase2) == 4);\n\n            // Test case 3\n            int[] testCase3 = { 1, 2, 3, 4, 5 };\n            Debug.Assert(Program.LongestStackSequence(testCase3) == 5);\n\n            // Test case 4\n            int[] testCase4 = { 5, 4, 3, 2, 1 };\n            Debug.Assert(Program.LongestStackSequence(testCase4) == 1);\n\n            // Test case 5 (edge case: empty array)\n            int[] testCase5 = { };\n            Debug.Assert(Program.LongestStackSequence(testCase5) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace LongestStackSequence\n{\n    class Program\n    {\n        // Calculates the length of the longest possible sequence of containers\n        // that can be stacked such that each container is heavier than the one below it.\n        // Uses dynamic programming to solve the problem.\n        // weights: Array of container weights.\n        // Returns: Length of the longest stackable sequence of containers.\n    public static int LongestStackSequence(int[] weights)\n        {\n            int n = weights.Length;\n            if (n == 0)\n            {\n                return 0;\n            }\n\n            int[] dp = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                dp[i] = 1; // Initialize DP array where each sequence length is at least 1\n            }\n\n            for (int i = 1; i < n; i++)\n            {\n                for (int j = 0; j < i; j++)\n                {\n                    if (weights[i] > weights[j])\n                    {\n                        dp[i] = Math.Max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n\n            int maxLength = 0;\n            for (int i = 0; i < n; i++)\n            {\n                if (dp[i] > maxLength)\n                {\n                    maxLength = dp[i];\n                }\n            }\n\n            return maxLength;\n        }\n    }\n}\n\nnamespace LongestStackSequence\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[] testCase1 = { 3, 1, 4, 1, 5, 9, 2, 6, 5 };\n            Debug.Assert(Program.LongestStackSequence(testCase1) == 4);\n\n            // Test case 2\n            int[] testCase2 = { 10, 20, 10, 30, 10, 40 };\n            Debug.Assert(Program.LongestStackSequence(testCase2) == 4);\n\n            // Test case 3\n            int[] testCase3 = { 1, 2, 3, 4, 5 };\n            Debug.Assert(Program.LongestStackSequence(testCase3) == 5);\n\n            // Test case 4\n            int[] testCase4 = { 5, 4, 3, 2, 1 };\n            Debug.Assert(Program.LongestStackSequence(testCase4) == 1);\n\n            // Test case 5 (edge case: empty array)\n            int[] testCase5 = { };\n            Debug.Assert(Program.LongestStackSequence(testCase5) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace ProjectFundingCalculator\n{\n    class Program\n    {\n        /// <summary>\n        /// Calculates the maximum number of projects that can be funded within the given budget.\n        /// Projects are sorted by cost, and the cheapest projects are funded first to maximize the count.\n        /// </summary>\n        /// <param name=\"projects\">An array of integers representing the cost of each project.</param>\n        /// <param name=\"budget\">The total budget available.</param>\n        /// <returns>The maximum number of projects that can be funded.</returns>\n        public static int MaxProjectsFunded(int[] projects, int budget)\n        {\n            // Sort the projects by cost to prioritize cheaper projects\n            Array.Sort(projects);\n            int fundedProjects = 0;\n            int currentBudget = 0;\n            \n            foreach (int cost in projects)\n            {\n                if (currentBudget + cost <= budget)\n                {\n                    currentBudget += cost;\n                    fundedProjects++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            return fundedProjects;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Projects: [10, 20, 30, 40], Budget: 50\nMaximum projects funded: 2\n\nProjects: [5, 10, 15, 20], Budget: 30\nMaximum projects funded: 3\n\nProjects: [1, 2, 3, 4, 5], Budget: 10\nMaximum projects funded: 4\n\nProjects: [100, 200, 300], Budget: 150\nMaximum projects funded: 1", "task_id": 3299, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ProjectFundingCalculator\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[] projects1 = { 10, 20, 30, 40 };\n            int budget1 = 50;\n            Debug.Assert(Program.MaxProjectsFunded(projects1, budget1) == 2);\n\n            // Test case 2\n            int[] projects2 = { 5, 10, 15, 20 };\n            int budget2 = 30;\n            Debug.Assert(Program.MaxProjectsFunded(projects2, budget2) == 3);\n\n            // Test case 3\n            int[] projects3 = { 1, 2, 3, 4, 5 };\n            int budget3 = 10;\n            Debug.Assert(Program.MaxProjectsFunded(projects3, budget3) == 4);\n\n            // Test case 4\n            int[] projects4 = { 100, 200, 300 };\n            int budget4 = 150;\n            Debug.Assert(Program.MaxProjectsFunded(projects4, budget4) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace ProjectFundingCalculator\n{\n    class Program\n    {\n        /// <summary>\n        /// Calculates the maximum number of projects that can be funded within the given budget.\n        /// Projects are sorted by cost, and the cheapest projects are funded first to maximize the count.\n        /// </summary>\n        /// <param name=\"projects\">An array of integers representing the cost of each project.</param>\n        /// <param name=\"budget\">The total budget available.</param>\n        /// <returns>The maximum number of projects that can be funded.</returns>\n        public static int MaxProjectsFunded(int[] projects, int budget)\n        {\n            // Sort the projects by cost to prioritize cheaper projects\n            Array.Sort(projects);\n            int fundedProjects = 0;\n            int currentBudget = 0;\n            \n            foreach (int cost in projects)\n            {\n                if (currentBudget + cost <= budget)\n                {\n                    currentBudget += cost;\n                    fundedProjects++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            return fundedProjects;\n        }\n    }\n}\n\nnamespace ProjectFundingCalculator\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[] projects1 = { 10, 20, 30, 40 };\n            int budget1 = 50;\n            Debug.Assert(Program.MaxProjectsFunded(projects1, budget1) == 2);\n\n            // Test case 2\n            int[] projects2 = { 5, 10, 15, 20 };\n            int budget2 = 30;\n            Debug.Assert(Program.MaxProjectsFunded(projects2, budget2) == 3);\n\n            // Test case 3\n            int[] projects3 = { 1, 2, 3, 4, 5 };\n            int budget3 = 10;\n            Debug.Assert(Program.MaxProjectsFunded(projects3, budget3) == 4);\n\n            // Test case 4\n            int[] projects4 = { 100, 200, 300 };\n            int budget4 = 150;\n            Debug.Assert(Program.MaxProjectsFunded(projects4, budget4) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace MaximumNonOverlappingSegments\n{\n    class Program\n    {\n        // Finds the maximum number of non-overlapping segments from a list of segments.\n        // Segments are first sorted by their end points, and then a greedy algorithm is used\n        // to select the segments that don't overlap with the last selected segment.\n        public static int FindMaximumNonOverlappingSegments(List<(int Start, int End)> segments)\n        {\n            // Sort segments by their end points\n            segments = segments.OrderBy(s => s.End).ToList();\n            \n            int count = 0;\n            int lastEnd = -1;\n            \n            foreach (var segment in segments)\n            {\n                if (segment.Start >= lastEnd)\n                {\n                    count++;\n                    lastEnd = segment.End;\n                }\n            }\n            \n            return count;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Segments: [(1, 3), (2, 4), (3, 5)]\nMaximum Non-overlapping Segments: 2\nInput Segments: [(1, 2), (3, 4), (5, 6)]\nMaximum Non-overlapping Segments: 3\nInput Segments: [(5, 6), (1, 2), (3, 4)]\nMaximum Non-overlapping Segments: 3\nInput Segments: [(1, 5), (2, 3), (4, 6)]\nMaximum Non-overlapping Segments: 2\nInput Segments: [(1, 2), (2, 3), (3, 4)]\nMaximum Non-overlapping Segments: 3", "task_id": 22535, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace MaximumNonOverlappingSegments\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            var testCases = new List<(List<(int Start, int End)> Segments, int Expected)>()\n            {\n                (new List<(int Start, int End)> { (1, 3), (2, 4), (3, 5) }, 2),\n                (new List<(int Start, int End)> { (1, 2), (3, 4), (5, 6) }, 3),\n                (new List<(int Start, int End)> { (5, 6), (1, 2), (3, 4) }, 3),\n                (new List<(int Start, int End)> { (1, 5), (2, 3), (4, 6) }, 2),\n                (new List<(int Start, int End)> { (1, 2), (2, 3), (3, 4) }, 3)\n            };\n\n            foreach (var testCase in testCases)\n            {\n                int result = Program.FindMaximumNonOverlappingSegments(testCase.Segments);\n                Debug.Assert(result == testCase.Expected, \n                    $\"Test failed for segments [{string.Join(\", \", testCase.Segments)}]. Expected: {testCase.Expected}, Actual: {result}\");\n            }\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace MaximumNonOverlappingSegments\n{\n    class Program\n    {\n        // Finds the maximum number of non-overlapping segments from a list of segments.\n        // Segments are first sorted by their end points, and then a greedy algorithm is used\n        // to select the segments that don't overlap with the last selected segment.\n        public static int FindMaximumNonOverlappingSegments(List<(int Start, int End)> segments)\n        {\n            // Sort segments by their end points\n            segments = segments.OrderBy(s => s.End).ToList();\n            \n            int count = 0;\n            int lastEnd = -1;\n            \n            foreach (var segment in segments)\n            {\n                if (segment.Start >= lastEnd)\n                {\n                    count++;\n                    lastEnd = segment.End;\n                }\n            }\n            \n            return count;\n        }\n    }\n}\n\nnamespace MaximumNonOverlappingSegments\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            var testCases = new List<(List<(int Start, int End)> Segments, int Expected)>()\n            {\n                (new List<(int Start, int End)> { (1, 3), (2, 4), (3, 5) }, 2),\n                (new List<(int Start, int End)> { (1, 2), (3, 4), (5, 6) }, 3),\n                (new List<(int Start, int End)> { (5, 6), (1, 2), (3, 4) }, 3),\n                (new List<(int Start, int End)> { (1, 5), (2, 3), (4, 6) }, 2),\n                (new List<(int Start, int End)> { (1, 2), (2, 3), (3, 4) }, 3)\n            };\n\n            foreach (var testCase in testCases)\n            {\n                int result = Program.FindMaximumNonOverlappingSegments(testCase.Segments);\n                Debug.Assert(result == testCase.Expected, \n                    $\"Test failed for segments [{string.Join(\", \", testCase.Segments)}]. Expected: {testCase.Expected}, Actual: {result}\");\n            }\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace VotingRanking\n{\n    class Program\n    {\n        // RankTeams ranks the teams based on the voting results.\n        // The ranking is determined by the count of votes each team receives in each position,\n        // sorted in descending order. If counts are equal, the team name is used as a tiebreaker.\n        static string RankTeams(string[] votes)\n        {\n            if (votes.Length == 0)\n            {\n                return string.Empty;\n            }\n\n            // Extract the list of teams from the first vote\n            var teams = votes[0].ToCharArray().ToList();\n            int n = teams.Count;\n\n            // Initialize counts for each team\n            var counts = new Dictionary<char, int[]>();\n            foreach (var team in teams)\n            {\n                counts[team] = new int[n];\n            }\n\n            // Process each vote to update counts\n            foreach (var vote in votes)\n            {\n                for (int i = 0; i < n; i++)\n                {\n                    char team = vote[i];\n                    counts[team][i]++;\n                }\n            }\n\n            // Sort the teams based on the defined criteria\n            var sortedTeams = teams.OrderByDescending(t => counts[t], new CountComparer())\n                                  .ThenBy(t => t)\n                                  .ToList();\n\n            // Generate the result string\n            return new string(sortedTeams.ToArray());\n        }\n\n        // CountComparer is a custom comparer for comparing team counts.\n        // It compares the counts in each position in descending order.\n        private class CountComparer : IComparer<int[]>\n        {\n            public int Compare(int[] x, int[] y)\n            {\n                for (int i = 0; i < x.Length; i++)\n                {\n                    if (x[i] != y[i])\n                    {\n                        return y[i].CompareTo(x[i]);\n                    }\n                }\n                return 0;\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/07429f1b2f9f45b4849c9eaaeb571781/MyProject/Program.cs(53,24): warning CS8767: Nullability of reference types in type of parameter 'x' of 'int CountComparer.Compare(int[] x, int[] y)' doesn't match implicitly implemented member 'int IComparer<int[]>.Compare(int[]? x, int[]? y)' (possibly because of nullability attributes). [/data/codes/c#/07429f1b2f9f45b4849c9eaaeb571781/MyProject/MyProject.csproj]\n/data/codes/c#/07429f1b2f9f45b4849c9eaaeb571781/MyProject/Program.cs(53,24): warning CS8767: Nullability of reference types in type of parameter 'y' of 'int CountComparer.Compare(int[] x, int[] y)' doesn't match implicitly implemented member 'int IComparer<int[]>.Compare(int[]? x, int[]? y)' (possibly because of nullability attributes). [/data/codes/c#/07429f1b2f9f45b4849c9eaaeb571781/MyProject/MyProject.csproj]\nInput: [ABC, ACB, ABC, ACB, ACB]\nRanking: BCA\nInput: [WXYZ, XYZW]\nRanking: ZYWX\nInput: [ZMNAGUEDSJYLBOPHRQICWFXTVK]\nRanking: KVTXFWCIQRHPOBLYJSDEUGANMZ\nInput: []\nRanking:", "task_id": 1762, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace VotingRanking\n{\n    class TestVotingRanking\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            string[] testCase1 = { \"ABC\", \"ACB\", \"ABC\", \"ACB\", \"ACB\" };\n            string result1 = Program.RankTeams(testCase1);\n            Debug.Assert(result1 == \"BCA\");\n\n            // Test case 2\n            string[] testCase2 = { \"WXYZ\", \"XYZW\" };\n            string result2 = Program.RankTeams(testCase2);\n            Debug.Assert(result2 == \"ZYWX\");\n\n            // Test case 3\n            string[] testCase3 = { \"ZMNAGUEDSJYLBOPHRQICWFXTVK\" };\n            string result3 = Program.RankTeams(testCase3);\n            Debug.Assert(result3 == \"KVTXFWCIQRHPOBLYJSDEUGANMZ\");\n\n            // Test case 4\n            string[] testCase4 = { };\n            string result4 = Program.RankTeams(testCase4);\n            Debug.Assert(result4 == \"\");\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace VotingRanking\n{\n    class Program\n    {\n        // RankTeams ranks the teams based on the voting results.\n        // The ranking is determined by the count of votes each team receives in each position,\n        // sorted in descending order. If counts are equal, the team name is used as a tiebreaker.\n    public static string RankTeams(string[] votes)\n        {\n            if (votes.Length == 0)\n            {\n                return string.Empty;\n            }\n\n            // Extract the list of teams from the first vote\n            var teams = votes[0].ToCharArray().ToList();\n            int n = teams.Count;\n\n            // Initialize counts for each team\n            var counts = new Dictionary<char, int[]>();\n            foreach (var team in teams)\n            {\n                counts[team] = new int[n];\n            }\n\n            // Process each vote to update counts\n            foreach (var vote in votes)\n            {\n                for (int i = 0; i < n; i++)\n                {\n                    char team = vote[i];\n                    counts[team][i]++;\n                }\n            }\n\n            // Sort the teams based on the defined criteria\n            var sortedTeams = teams.OrderByDescending(t => counts[t], new CountComparer())\n                                  .ThenBy(t => t)\n                                  .ToList();\n\n            // Generate the result string\n            return new string(sortedTeams.ToArray());\n        }\n\n        // CountComparer is a custom comparer for comparing team counts.\n        // It compares the counts in each position in descending order.\n        private class CountComparer : IComparer<int[]>\n        {\n            public int Compare(int[] x, int[] y)\n            {\n                for (int i = 0; i < x.Length; i++)\n                {\n                    if (x[i] != y[i])\n                    {\n                        return y[i].CompareTo(x[i]);\n                    }\n                }\n                return 0;\n            }\n        }\n    }\n}\n\nnamespace VotingRanking\n{\n    class TestVotingRanking\n    {\n        public static void Main()\n        {\n            // Test case 1\n            string[] testCase1 = { \"ABC\", \"ACB\", \"ABC\", \"ACB\", \"ACB\" };\n            string result1 = Program.RankTeams(testCase1);\n            Debug.Assert(result1 == \"BCA\");\n\n            // Test case 2\n            string[] testCase2 = { \"WXYZ\", \"XYZW\" };\n            string result2 = Program.RankTeams(testCase2);\n            Debug.Assert(result2 == \"ZYWX\");\n\n            // Test case 3\n            string[] testCase3 = { \"ZMNAGUEDSJYLBOPHRQICWFXTVK\" };\n            string result3 = Program.RankTeams(testCase3);\n            Debug.Assert(result3 == \"KVTXFWCIQRHPOBLYJSDEUGANMZ\");\n\n            // Test case 4\n            string[] testCase4 = { };\n            string result4 = Program.RankTeams(testCase4);\n            Debug.Assert(result4 == \"\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace SpiralCoordinatesCalculator\n{\n    class SpiralCoordinates\n    {\n        // CalculateSpiralCoordinates calculates the (R, C) coordinates for a given number N in a spiral pattern.\n        // The spiral starts at (0, 0) for N = 1 and expands outward in a counter-clockwise manner.\n        public static (int R, int C) CalculateSpiralCoordinates(int N)\n        {\n            if (N == 1)\n            {\n                return (0, 0);\n            }\n\n            int k = (int)Math.Ceiling((Math.Sqrt(N) - 1) / 2);\n            int m = N - (int)Math.Pow(2 * k - 1, 2) - 1;\n            int side = m / (2 * k);\n            int p = m % (2 * k);\n\n            int R, C;\n            switch (side)\n            {\n                case 0:\n                    R = p;\n                    C = k;\n                    break;\n                case 1:\n                    R = k;\n                    C = k - p - 1;\n                    break;\n                case 2:\n                    R = k - p - 1;\n                    C = -k;\n                    break;\n                default:\n                    R = -k;\n                    C = -k + p + 1;\n                    break;\n            }\n\n            return (R, C);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: 1\nCoordinates: (0,0)\nInput: 2\nCoordinates: (0,1)\nInput: 5\nCoordinates: (1,-1)\nInput: 10\nCoordinates: (0,2)\nInput: 17\nCoordinates: (2,-2)\nInput: 26\nCoordinates: (0,3)", "task_id": 5166, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace SpiralCoordinatesCalculator\n{\n    class TestSpiralCoordinates\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(1) == (0, 0));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(2) == (0, 1));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(5) == (1, -1));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(10) == (0, 2));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(17) == (2, -2));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(26) == (0, 3));\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace SpiralCoordinatesCalculator\n{\n    class SpiralCoordinates\n    {\n        // CalculateSpiralCoordinates calculates the (R, C) coordinates for a given number N in a spiral pattern.\n        // The spiral starts at (0, 0) for N = 1 and expands outward in a counter-clockwise manner.\n        public static (int R, int C) CalculateSpiralCoordinates(int N)\n        {\n            if (N == 1)\n            {\n                return (0, 0);\n            }\n\n            int k = (int)Math.Ceiling((Math.Sqrt(N) - 1) / 2);\n            int m = N - (int)Math.Pow(2 * k - 1, 2) - 1;\n            int side = m / (2 * k);\n            int p = m % (2 * k);\n\n            int R, C;\n            switch (side)\n            {\n                case 0:\n                    R = p;\n                    C = k;\n                    break;\n                case 1:\n                    R = k;\n                    C = k - p - 1;\n                    break;\n                case 2:\n                    R = k - p - 1;\n                    C = -k;\n                    break;\n                default:\n                    R = -k;\n                    C = -k + p + 1;\n                    break;\n            }\n\n            return (R, C);\n        }\n    }\n}\n\nnamespace SpiralCoordinatesCalculator\n{\n    class TestSpiralCoordinates\n    {\n        public static void Main()\n        {\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(1) == (0, 0));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(2) == (0, 1));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(5) == (1, -1));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(10) == (0, 2));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(17) == (2, -2));\n            Debug.Assert(SpiralCoordinates.CalculateSpiralCoordinates(26) == (0, 3));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace MatrixOperations\n{\n    class Program\n    {\n        // ApplyOperations applies a series of operations to a matrix and returns the maximum value in the matrix after all operations.\n        // The matrix is initialized with zeros and has dimensions n x m.\n        // Each operation is a tuple (i, j, x) which means adding x to all elements in rows i-1 to j-1 (inclusive) across all columns.\n        static int ApplyOperations(int n, int m, int[][] operations)\n        {\n            // Initialize the matrix with zeros\n            int[][] matrix = new int[n][];\n            for (int i = 0; i < n; i++)\n            {\n                matrix[i] = new int[m];\n            }\n\n            // Apply each operation\n            foreach (var op in operations)\n            {\n                int i = op[0];\n                int j = op[1];\n                int x = op[2];\n\n                for (int row = i - 1; row < j; row++)\n                {\n                    for (int col = 0; col < m; col++)\n                    {\n                        matrix[row][col] += x;\n                    }\n                }\n            }\n\n            // Find the maximum value in the matrix\n            int maxValue = matrix.Max(row => row.Max());\n            return maxValue;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 3, m: 3\nOperations: [(1, 2, 1), (2, 3, 2)]\nMaximum Value: 3\n\nTest Case 2:\nn: 2, m: 4\nOperations: [(1, 2, 5)]\nMaximum Value: 5\n\nTest Case 3:\nn: 4, m: 2\nOperations: [(1, 3, 2), (2, 4, 3), (1, 1, 1)]\nMaximum Value: 5", "task_id": 19282, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MatrixOperations\n{\n    class TestMatrixOperations\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: 3x3 matrix with 2 operations\n            int n1 = 3;\n            int m1 = 3;\n            int[][] operations1 = new int[][]\n            {\n                new int[] { 1, 2, 1 },\n                new int[] { 2, 3, 2 }\n            };\n            Debug.Assert(Program.ApplyOperations(n1, m1, operations1) == 3);\n\n            // Test Case 2: 2x4 matrix with 1 operation\n            int n2 = 2;\n            int m2 = 4;\n            int[][] operations2 = new int[][]\n            {\n                new int[] { 1, 2, 5 }\n            };\n            Debug.Assert(Program.ApplyOperations(n2, m2, operations2) == 5);\n\n            // Test Case 3: 4x2 matrix with 3 operations\n            int n3 = 4;\n            int m3 = 2;\n            int[][] operations3 = new int[][]\n            {\n                new int[] { 1, 3, 2 },\n                new int[] { 2, 4, 3 },\n                new int[] { 1, 1, 1 }\n            };\n            Debug.Assert(Program.ApplyOperations(n3, m3, operations3) == 5);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace MatrixOperations\n{\n    class Program\n    {\n        // ApplyOperations applies a series of operations to a matrix and returns the maximum value in the matrix after all operations.\n        // The matrix is initialized with zeros and has dimensions n x m.\n        // Each operation is a tuple (i, j, x) which means adding x to all elements in rows i-1 to j-1 (inclusive) across all columns.\n    public static int ApplyOperations(int n, int m, int[][] operations)\n        {\n            // Initialize the matrix with zeros\n            int[][] matrix = new int[n][];\n            for (int i = 0; i < n; i++)\n            {\n                matrix[i] = new int[m];\n            }\n\n            // Apply each operation\n            foreach (var op in operations)\n            {\n                int i = op[0];\n                int j = op[1];\n                int x = op[2];\n\n                for (int row = i - 1; row < j; row++)\n                {\n                    for (int col = 0; col < m; col++)\n                    {\n                        matrix[row][col] += x;\n                    }\n                }\n            }\n\n            // Find the maximum value in the matrix\n            int maxValue = matrix.Max(row => row.Max());\n            return maxValue;\n        }\n    }\n}\n\nnamespace MatrixOperations\n{\n    class TestMatrixOperations\n    {\n        public static void Main()\n        {\n            // Test Case 1: 3x3 matrix with 2 operations\n            int n1 = 3;\n            int m1 = 3;\n            int[][] operations1 = new int[][]\n            {\n                new int[] { 1, 2, 1 },\n                new int[] { 2, 3, 2 }\n            };\n            Debug.Assert(Program.ApplyOperations(n1, m1, operations1) == 3);\n\n            // Test Case 2: 2x4 matrix with 1 operation\n            int n2 = 2;\n            int m2 = 4;\n            int[][] operations2 = new int[][]\n            {\n                new int[] { 1, 2, 5 }\n            };\n            Debug.Assert(Program.ApplyOperations(n2, m2, operations2) == 5);\n\n            // Test Case 3: 4x2 matrix with 3 operations\n            int n3 = 4;\n            int m3 = 2;\n            int[][] operations3 = new int[][]\n            {\n                new int[] { 1, 3, 2 },\n                new int[] { 2, 4, 3 },\n                new int[] { 1, 1, 1 }\n            };\n            Debug.Assert(Program.ApplyOperations(n3, m3, operations3) == 5);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace TaskAssignmentChecker\n{\n    class Program\n    {\n        // Determines if it's possible to assign tasks to drivers such that no driver exceeds their maximum working time.\n        // The method sorts tasks and drivers in descending order and attempts to assign the longest tasks first.\n        // If a task cannot be assigned to any driver without exceeding their maximum working time, it returns \"NO\".\n        // Otherwise, after all tasks are assigned, it returns \"YES\".\n        public static string CanAssignTasks(int n, int m, int[] tasks, int[] drivers)\n        {\n            Array.Sort(tasks);\n            Array.Reverse(tasks);\n            Array.Sort(drivers);\n            Array.Reverse(drivers);\n\n            foreach (var task in tasks)\n            {\n                bool assigned = false;\n                for (int i = 0; i < m; i++)\n                {\n                    if (drivers[i] >= task)\n                    {\n                        drivers[i] -= task;\n                        assigned = true;\n                        break;\n                    }\n                }\n                if (!assigned)\n                {\n                    return \"NO\";\n                }\n            }\n            return \"YES\";\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1 - Input: n=3, m=2, tasks=[5, 3, 2], drivers=[6, 4]\nResult: NO\nTest Case 2 - Input: n=3, m=2, tasks=[5, 3, 2], drivers=[4, 3]\nResult: NO\nTest Case 3 - Input: n=3, m=3, tasks=[4, 3, 2], drivers=[4, 3, 2]\nResult: YES\nTest Case 4 - Input: n=2, m=3, tasks=[5, 3], drivers=[6, 4, 3]\nResult: YES", "task_id": 22481, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace TaskAssignmentChecker\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Sufficient drivers for tasks\n            int n1 = 3;\n            int m1 = 2;\n            int[] tasks1 = { 5, 3, 2 };\n            int[] drivers1 = { 6, 4 };\n            Debug.Assert(Program.CanAssignTasks(n1, m1, tasks1, drivers1) == \"NO\");\n\n            // Test case 2: Insufficient drivers for tasks\n            int n2 = 3;\n            int m2 = 2;\n            int[] tasks2 = { 5, 3, 2 };\n            int[] drivers2 = { 4, 3 };\n            Debug.Assert(Program.CanAssignTasks(n2, m2, tasks2, drivers2) == \"NO\");\n\n            // Test case 3: Exact fit\n            int n3 = 3;\n            int m3 = 3;\n            int[] tasks3 = { 4, 3, 2 };\n            int[] drivers3 = { 4, 3, 2 };\n            Debug.Assert(Program.CanAssignTasks(n3, m3, tasks3, drivers3) == \"YES\");\n\n            // Test case 4: More drivers than tasks\n            int n4 = 2;\n            int m4 = 3;\n            int[] tasks4 = { 5, 3 };\n            int[] drivers4 = { 6, 4, 3 };\n            Debug.Assert(Program.CanAssignTasks(n4, m4, tasks4, drivers4) == \"YES\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace TaskAssignmentChecker\n{\n    class Program\n    {\n        // Determines if it's possible to assign tasks to drivers such that no driver exceeds their maximum working time.\n        // The method sorts tasks and drivers in descending order and attempts to assign the longest tasks first.\n        // If a task cannot be assigned to any driver without exceeding their maximum working time, it returns \"NO\".\n        // Otherwise, after all tasks are assigned, it returns \"YES\".\n        public static string CanAssignTasks(int n, int m, int[] tasks, int[] drivers)\n        {\n            Array.Sort(tasks);\n            Array.Reverse(tasks);\n            Array.Sort(drivers);\n            Array.Reverse(drivers);\n\n            foreach (var task in tasks)\n            {\n                bool assigned = false;\n                for (int i = 0; i < m; i++)\n                {\n                    if (drivers[i] >= task)\n                    {\n                        drivers[i] -= task;\n                        assigned = true;\n                        break;\n                    }\n                }\n                if (!assigned)\n                {\n                    return \"NO\";\n                }\n            }\n            return \"YES\";\n        }\n    }\n}\n\nnamespace TaskAssignmentChecker\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Sufficient drivers for tasks\n            int n1 = 3;\n            int m1 = 2;\n            int[] tasks1 = { 5, 3, 2 };\n            int[] drivers1 = { 6, 4 };\n            Debug.Assert(Program.CanAssignTasks(n1, m1, tasks1, drivers1) == \"NO\");\n\n            // Test case 2: Insufficient drivers for tasks\n            int n2 = 3;\n            int m2 = 2;\n            int[] tasks2 = { 5, 3, 2 };\n            int[] drivers2 = { 4, 3 };\n            Debug.Assert(Program.CanAssignTasks(n2, m2, tasks2, drivers2) == \"NO\");\n\n            // Test case 3: Exact fit\n            int n3 = 3;\n            int m3 = 3;\n            int[] tasks3 = { 4, 3, 2 };\n            int[] drivers3 = { 4, 3, 2 };\n            Debug.Assert(Program.CanAssignTasks(n3, m3, tasks3, drivers3) == \"YES\");\n\n            // Test case 4: More drivers than tasks\n            int n4 = 2;\n            int m4 = 3;\n            int[] tasks4 = { 5, 3 };\n            int[] drivers4 = { 6, 4, 3 };\n            Debug.Assert(Program.CanAssignTasks(n4, m4, tasks4, drivers4) == \"YES\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BinaryMaskDistanceCalculator\n{\n    class Program\n    {\n        // Computes the maximum distance masks from a set of initial masks using BFS.\n        // The distance is defined as the minimum number of bit flips required to reach any mask from the initial set.\n        // Returns the binary string representation of one of the masks with the maximum distance.\n        static string FindFarthestMask(int k, HashSet<int> uniqueMasks)\n        {\n            int size = 1 << k;\n            int[] distance = new int[size];\n            Array.Fill(distance, -1);\n            Queue<int> queue = new Queue<int>();\n\n            // Initialize BFS with the given unique masks\n            foreach (int mask in uniqueMasks)\n            {\n                distance[mask] = 0;\n                queue.Enqueue(mask);\n            }\n\n            // Perform BFS\n            while (queue.Count > 0)\n            {\n                int u = queue.Dequeue();\n                for (int i = 0; i < k; i++)\n                {\n                    int v = u ^ (1 << i); // Flip the i-th bit\n                    if (distance[v] == -1)\n                    {\n                        distance[v] = distance[u] + 1;\n                        queue.Enqueue(v);\n                    }\n                }\n            }\n\n            // Find the maximum distance and corresponding masks\n            int maxDist = distance.Max();\n            List<int> bestMasks = Enumerable.Range(0, size).Where(mask => distance[mask] == maxDist).ToList();\n\n            // Return the first mask in the list as a binary string\n            return Convert.ToString(bestMasks[0], 2).PadLeft(k, '0');\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput n: 3, k: 4\nInput masks: 0000, 0101, 1111\nFarthest mask: 0011\n\nTest Case 2:\nInput n: 2, k: 3\nInput masks: 000, 111\nFarthest mask: 001\n\nTest Case 3:\nInput n: 1, k: 2\nInput masks: 01\nFarthest mask: 10", "task_id": 7922, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BinaryMaskDistanceCalculator\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: n=3, k=4, masks=[\"0000\", \"0101\", \"1111\"]\n            int k1 = 4;\n            HashSet<int> masks1 = new HashSet<int> { 0b0000, 0b0101, 0b1111 };\n            string result1 = Program.FindFarthestMask(k1, masks1);\n            Debug.Assert(result1 == \"0011\");\n\n            // Test case 2: n=2, k=3, masks=[\"000\", \"111\"]\n            int k2 = 3;\n            HashSet<int> masks2 = new HashSet<int> { 0b000, 0b111 };\n            string result2 = Program.FindFarthestMask(k2, masks2);\n            Debug.Assert(result2 == \"001\");\n\n            // Test case 3: n=1, k=2, masks=[\"01\"]\n            int k3 = 2;\n            HashSet<int> masks3 = new HashSet<int> { 0b01 };\n            string result3 = Program.FindFarthestMask(k3, masks3);\n            Debug.Assert(result3 == \"10\");\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace BinaryMaskDistanceCalculator\n{\n    class Program\n    {\n        // Computes the maximum distance masks from a set of initial masks using BFS.\n        // The distance is defined as the minimum number of bit flips required to reach any mask from the initial set.\n        // Returns the binary string representation of one of the masks with the maximum distance.\n    public static string FindFarthestMask(int k, HashSet<int> uniqueMasks)\n        {\n            int size = 1 << k;\n            int[] distance = new int[size];\n            Array.Fill(distance, -1);\n            Queue<int> queue = new Queue<int>();\n\n            // Initialize BFS with the given unique masks\n            foreach (int mask in uniqueMasks)\n            {\n                distance[mask] = 0;\n                queue.Enqueue(mask);\n            }\n\n            // Perform BFS\n            while (queue.Count > 0)\n            {\n                int u = queue.Dequeue();\n                for (int i = 0; i < k; i++)\n                {\n                    int v = u ^ (1 << i); // Flip the i-th bit\n                    if (distance[v] == -1)\n                    {\n                        distance[v] = distance[u] + 1;\n                        queue.Enqueue(v);\n                    }\n                }\n            }\n\n            // Find the maximum distance and corresponding masks\n            int maxDist = distance.Max();\n            List<int> bestMasks = Enumerable.Range(0, size).Where(mask => distance[mask] == maxDist).ToList();\n\n            // Return the first mask in the list as a binary string\n            return Convert.ToString(bestMasks[0], 2).PadLeft(k, '0');\n        }\n    }\n}\n\nnamespace BinaryMaskDistanceCalculator\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: n=3, k=4, masks=[\"0000\", \"0101\", \"1111\"]\n            int k1 = 4;\n            HashSet<int> masks1 = new HashSet<int> { 0b0000, 0b0101, 0b1111 };\n            string result1 = Program.FindFarthestMask(k1, masks1);\n            Debug.Assert(result1 == \"0011\");\n\n            // Test case 2: n=2, k=3, masks=[\"000\", \"111\"]\n            int k2 = 3;\n            HashSet<int> masks2 = new HashSet<int> { 0b000, 0b111 };\n            string result2 = Program.FindFarthestMask(k2, masks2);\n            Debug.Assert(result2 == \"001\");\n\n            // Test case 3: n=1, k=2, masks=[\"01\"]\n            int k3 = 2;\n            HashSet<int> masks3 = new HashSet<int> { 0b01 };\n            string result3 = Program.FindFarthestMask(k3, masks3);\n            Debug.Assert(result3 == \"10\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace GraphComponentCounter\n{\n    class Program\n    {\n        // CountConnectedComponents calculates the number of connected components in an undirected graph.\n        // The graph is represented as an adjacency list.\n        public static int CountConnectedComponents(int n, List<int>[] adj)\n        {\n            bool[] visited = new bool[n + 1];\n            int count = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i])\n                {\n                    count++;\n                    Queue<int> q = new Queue<int>();\n                    q.Enqueue(i);\n                    visited[i] = true;\n\n                    while (q.Count > 0)\n                    {\n                        int current = q.Dequeue();\n                        foreach (int neighbor in adj[current])\n                        {\n                            if (!visited[neighbor])\n                            {\n                                visited[neighbor] = true;\n                                q.Enqueue(neighbor);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return count;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of nodes: 3\nEdges: 1-2, 2-3\nNumber of connected components: 1\n\nTest Case 2:\nNumber of nodes: 6\nEdges: 1-2, 2-3, 4-5\nNumber of connected components: 3\n\nTest Case 3:\nNumber of nodes: 5\nEdges: None\nNumber of connected components: 5", "task_id": 16253, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace GraphComponentCounter\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Graph with 3 nodes and 2 edges forming a single connected component\n            int n1 = 3;\n            List<int>[] adj1 = new List<int>[n1 + 1];\n            for (int i = 0; i <= n1; i++)\n            {\n                adj1[i] = new List<int>();\n            }\n            adj1[1].Add(2);\n            adj1[2].Add(1);\n            adj1[2].Add(3);\n            adj1[3].Add(2);\n            Debug.Assert(Program.CountConnectedComponents(n1, adj1) == 1);\n\n            // Test case 2: Graph with 6 nodes and 4 edges forming two connected components\n            int n2 = 6;\n            List<int>[] adj2 = new List<int>[n2 + 1];\n            for (int i = 0; i <= n2; i++)\n            {\n                adj2[i] = new List<int>();\n            }\n            adj2[1].Add(2);\n            adj2[2].Add(1);\n            adj2[2].Add(3);\n            adj2[3].Add(2);\n            adj2[4].Add(5);\n            adj2[5].Add(4);\n            Debug.Assert(Program.CountConnectedComponents(n2, adj2) == 3);\n\n            // Test case 3: Graph with 5 nodes and no edges (5 connected components)\n            int n3 = 5;\n            List<int>[] adj3 = new List<int>[n3 + 1];\n            for (int i = 0; i <= n3; i++)\n            {\n                adj3[i] = new List<int>();\n            }\n            Debug.Assert(Program.CountConnectedComponents(n3, adj3) == 5);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace GraphComponentCounter\n{\n    class Program\n    {\n        // CountConnectedComponents calculates the number of connected components in an undirected graph.\n        // The graph is represented as an adjacency list.\n        public static int CountConnectedComponents(int n, List<int>[] adj)\n        {\n            bool[] visited = new bool[n + 1];\n            int count = 0;\n\n            for (int i = 1; i <= n; i++)\n            {\n                if (!visited[i])\n                {\n                    count++;\n                    Queue<int> q = new Queue<int>();\n                    q.Enqueue(i);\n                    visited[i] = true;\n\n                    while (q.Count > 0)\n                    {\n                        int current = q.Dequeue();\n                        foreach (int neighbor in adj[current])\n                        {\n                            if (!visited[neighbor])\n                            {\n                                visited[neighbor] = true;\n                                q.Enqueue(neighbor);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return count;\n        }\n    }\n}\n\nnamespace GraphComponentCounter\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Graph with 3 nodes and 2 edges forming a single connected component\n            int n1 = 3;\n            List<int>[] adj1 = new List<int>[n1 + 1];\n            for (int i = 0; i <= n1; i++)\n            {\n                adj1[i] = new List<int>();\n            }\n            adj1[1].Add(2);\n            adj1[2].Add(1);\n            adj1[2].Add(3);\n            adj1[3].Add(2);\n            Debug.Assert(Program.CountConnectedComponents(n1, adj1) == 1);\n\n            // Test case 2: Graph with 6 nodes and 4 edges forming two connected components\n            int n2 = 6;\n            List<int>[] adj2 = new List<int>[n2 + 1];\n            for (int i = 0; i <= n2; i++)\n            {\n                adj2[i] = new List<int>();\n            }\n            adj2[1].Add(2);\n            adj2[2].Add(1);\n            adj2[2].Add(3);\n            adj2[3].Add(2);\n            adj2[4].Add(5);\n            adj2[5].Add(4);\n            Debug.Assert(Program.CountConnectedComponents(n2, adj2) == 3);\n\n            // Test case 3: Graph with 5 nodes and no edges (5 connected components)\n            int n3 = 5;\n            List<int>[] adj3 = new List<int>[n3 + 1];\n            for (int i = 0; i <= n3; i++)\n            {\n                adj3[i] = new List<int>();\n            }\n            Debug.Assert(Program.CountConnectedComponents(n3, adj3) == 5);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace TableAllocation\n{\n    class Program\n    {\n        // Determines if each reservation can be allocated to a table.\n        // Parameters:\n        // - tables: A list of integers representing the table's sizes.\n        // - reservations: A list of integers where each integer represents a reservation size.\n        // Returns:\n        // A list of booleans indicating if a reservation can be successfully allocated.\n        static List<bool> AllocateTables(List<int> tables, List<int> reservations)\n        {\n            // Create a copy of the table sizes to keep track of available capacities\n            List<int> availableTables = new List<int>(tables);\n            List<bool> allocationResults = new List<bool>();\n\n            foreach (int reservation in reservations)\n            {\n                bool successfulAllocation = false;\n                // Iterate through available tables to find a suitable one\n                for (int i = 0; i < availableTables.Count; i++)\n                {\n                    if (availableTables[i] >= reservation)\n                    {\n                        // Mark table as occupied by setting its size to 0\n                        availableTables[i] = 0;\n                        successfulAllocation = true;\n                        break;\n                    }\n                }\n                allocationResults.Add(successfulAllocation);\n            }\n\n            return allocationResults;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Tables: 4, 6, 2, 8\nReservations: 3, 5, 7, 2\nAllocation Results: True, True, True, True\n\nTables: 10, 10, 10\nReservations: 5, 5, 5, 5\nAllocation Results: True, True, True, False\n\nTables: 2, 4, 6\nReservations: 3, 3, 3\nAllocation Results: True, True, False", "task_id": 19681, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace TableAllocation\n{\n    class TestTableAllocation\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var tables1 = new List<int> { 4, 6, 2, 8 };\n            var reservations1 = new List<int> { 3, 5, 7, 2 };\n            var expectedResults1 = new List<bool> { true, true, true, true };\n            var actualResults1 = Program.AllocateTables(tables1, reservations1);\n            Debug.Assert(actualResults1.Count == expectedResults1.Count);\n            for (int i = 0; i < actualResults1.Count; i++)\n            {\n                Debug.Assert(actualResults1[i] == expectedResults1[i]);\n            }\n\n            // Test case 2\n            var tables2 = new List<int> { 10, 10, 10 };\n            var reservations2 = new List<int> { 5, 5, 5, 5 };\n            var expectedResults2 = new List<bool> { true, true, true, false };\n            var actualResults2 = Program.AllocateTables(tables2, reservations2);\n            Debug.Assert(actualResults2.Count == expectedResults2.Count);\n            for (int i = 0; i < actualResults2.Count; i++)\n            {\n                Debug.Assert(actualResults2[i] == expectedResults2[i]);\n            }\n\n            // Test case 3\n            var tables3 = new List<int> { 2, 4, 6 };\n            var reservations3 = new List<int> { 3, 3, 3 };\n            var expectedResults3 = new List<bool> { true, true, false };\n            var actualResults3 = Program.AllocateTables(tables3, reservations3);\n            Debug.Assert(actualResults3.Count == expectedResults3.Count);\n            for (int i = 0; i < actualResults3.Count; i++)\n            {\n                Debug.Assert(actualResults3[i] == expectedResults3[i]);\n            }\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace TableAllocation\n{\n    class Program\n    {\n        // Determines if each reservation can be allocated to a table.\n        // Parameters:\n        // - tables: A list of integers representing the table's sizes.\n        // - reservations: A list of integers where each integer represents a reservation size.\n        // Returns:\n        // A list of booleans indicating if a reservation can be successfully allocated.\n    public static List<bool> AllocateTables(List<int> tables, List<int> reservations)\n        {\n            // Create a copy of the table sizes to keep track of available capacities\n            List<int> availableTables = new List<int>(tables);\n            List<bool> allocationResults = new List<bool>();\n\n            foreach (int reservation in reservations)\n            {\n                bool successfulAllocation = false;\n                // Iterate through available tables to find a suitable one\n                for (int i = 0; i < availableTables.Count; i++)\n                {\n                    if (availableTables[i] >= reservation)\n                    {\n                        // Mark table as occupied by setting its size to 0\n                        availableTables[i] = 0;\n                        successfulAllocation = true;\n                        break;\n                    }\n                }\n                allocationResults.Add(successfulAllocation);\n            }\n\n            return allocationResults;\n        }\n    }\n}\n\nnamespace TableAllocation\n{\n    class TestTableAllocation\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var tables1 = new List<int> { 4, 6, 2, 8 };\n            var reservations1 = new List<int> { 3, 5, 7, 2 };\n            var expectedResults1 = new List<bool> { true, true, true, true };\n            var actualResults1 = Program.AllocateTables(tables1, reservations1);\n            Debug.Assert(actualResults1.Count == expectedResults1.Count);\n            for (int i = 0; i < actualResults1.Count; i++)\n            {\n                Debug.Assert(actualResults1[i] == expectedResults1[i]);\n            }\n\n            // Test case 2\n            var tables2 = new List<int> { 10, 10, 10 };\n            var reservations2 = new List<int> { 5, 5, 5, 5 };\n            var expectedResults2 = new List<bool> { true, true, true, false };\n            var actualResults2 = Program.AllocateTables(tables2, reservations2);\n            Debug.Assert(actualResults2.Count == expectedResults2.Count);\n            for (int i = 0; i < actualResults2.Count; i++)\n            {\n                Debug.Assert(actualResults2[i] == expectedResults2[i]);\n            }\n\n            // Test case 3\n            var tables3 = new List<int> { 2, 4, 6 };\n            var reservations3 = new List<int> { 3, 3, 3 };\n            var expectedResults3 = new List<bool> { true, true, false };\n            var actualResults3 = Program.AllocateTables(tables3, reservations3);\n            Debug.Assert(actualResults3.Count == expectedResults3.Count);\n            for (int i = 0; i < actualResults3.Count; i++)\n            {\n                Debug.Assert(actualResults3[i] == expectedResults3[i]);\n            }\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BookPurchaseOptimizer\n{\n    class Program\n    {\n        // Calculates the maximum number of books that can be purchased with a given budget,\n        // where one book can be bought at half price.\n        // For each test case, it considers each book as the discounted one and calculates\n        // how many books can be bought in each scenario, then returns the maximum count.\n        static List<int> MaxBooks(int T, List<Tuple<Tuple<int, int>, List<int>>> testCases)\n        {\n            List<int> results = new List<int>();\n            \n            for (int i = 0; i < T; i++)\n            {\n                int N = testCases[i].Item1.Item1;\n                int B = testCases[i].Item1.Item2;\n                List<int> prices = new List<int>(testCases[i].Item2);\n                \n                int maxBookCount = 0;\n                prices.Sort();\n                \n                for (int j = 0; j < N; j++)\n                {\n                    // Create a new list with the j-th book discounted\n                    List<int> discountedPrices = new List<int>(prices);\n                    discountedPrices[j] = discountedPrices[j] / 2;\n                    discountedPrices.Sort();\n                    \n                    int totalSpent = 0;\n                    int bookCount = 0;\n                    \n                    foreach (int price in discountedPrices)\n                    {\n                        if (totalSpent + price <= B)\n                        {\n                            totalSpent += price;\n                            bookCount++;\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    \n                    maxBookCount = Math.Max(maxBookCount, bookCount);\n                }\n                \n                results.Add(maxBookCount);\n            }\n            \n            return results;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of books: 4, Budget: 10\nBook prices: [4, 3, 2, 5]\nMaximum books that can be purchased: 3\n\nTest Case 2:\nNumber of books: 3, Budget: 15\nBook prices: [5, 6, 7]\nMaximum books that can be purchased: 3\n\nTest Case 3:\nNumber of books: 2, Budget: 5\nBook prices: [10, 20]\nMaximum books that can be purchased: 1\n\nTest Case 4:\nNumber of books: 0, Budget: 100\nBook prices: []\nMaximum books that can be purchased: 0", "task_id": 22543, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BookPurchaseOptimizer\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Can buy 3 books (discount the most expensive one)\n            var testCase1 = Tuple.Create(Tuple.Create(4, 10), new List<int> {4, 3, 2, 5});\n            \n            // Test case 2: Can buy all books with discount\n            var testCase2 = Tuple.Create(Tuple.Create(3, 15), new List<int> {5, 6, 7});\n            \n            // Test case 3: Can't buy any books\n            var testCase3 = Tuple.Create(Tuple.Create(2, 5), new List<int> {10, 20});\n            \n            // Test case 4: Edge case with empty price list\n            var testCase4 = Tuple.Create(Tuple.Create(0, 100), new List<int>());\n            \n            var testCases = new List<Tuple<Tuple<int, int>, List<int>>>\n            {\n                testCase1,\n                testCase2,\n                testCase3,\n                testCase4\n            };\n            \n            int T = testCases.Count;\n            List<int> results = Program.MaxBooks(T, testCases);\n            \n            Debug.Assert(results[0] == 3);\n            Debug.Assert(results[1] == 3);\n            Debug.Assert(results[2] == 1);\n            Debug.Assert(results[3] == 0);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace BookPurchaseOptimizer\n{\n    class Program\n    {\n        // Calculates the maximum number of books that can be purchased with a given budget,\n        // where one book can be bought at half price.\n        // For each test case, it considers each book as the discounted one and calculates\n        // how many books can be bought in each scenario, then returns the maximum count.\n    public static List<int> MaxBooks(int T, List<Tuple<Tuple<int, int>, List<int>>> testCases)\n        {\n            List<int> results = new List<int>();\n            \n            for (int i = 0; i < T; i++)\n            {\n                int N = testCases[i].Item1.Item1;\n                int B = testCases[i].Item1.Item2;\n                List<int> prices = new List<int>(testCases[i].Item2);\n                \n                int maxBookCount = 0;\n                prices.Sort();\n                \n                for (int j = 0; j < N; j++)\n                {\n                    // Create a new list with the j-th book discounted\n                    List<int> discountedPrices = new List<int>(prices);\n                    discountedPrices[j] = discountedPrices[j] / 2;\n                    discountedPrices.Sort();\n                    \n                    int totalSpent = 0;\n                    int bookCount = 0;\n                    \n                    foreach (int price in discountedPrices)\n                    {\n                        if (totalSpent + price <= B)\n                        {\n                            totalSpent += price;\n                            bookCount++;\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    \n                    maxBookCount = Math.Max(maxBookCount, bookCount);\n                }\n                \n                results.Add(maxBookCount);\n            }\n            \n            return results;\n        }\n    }\n}\n\nnamespace BookPurchaseOptimizer\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Can buy 3 books (discount the most expensive one)\n            var testCase1 = Tuple.Create(Tuple.Create(4, 10), new List<int> {4, 3, 2, 5});\n            \n            // Test case 2: Can buy all books with discount\n            var testCase2 = Tuple.Create(Tuple.Create(3, 15), new List<int> {5, 6, 7});\n            \n            // Test case 3: Can't buy any books\n            var testCase3 = Tuple.Create(Tuple.Create(2, 5), new List<int> {10, 20});\n            \n            // Test case 4: Edge case with empty price list\n            var testCase4 = Tuple.Create(Tuple.Create(0, 100), new List<int>());\n            \n            var testCases = new List<Tuple<Tuple<int, int>, List<int>>>\n            {\n                testCase1,\n                testCase2,\n                testCase3,\n                testCase4\n            };\n            \n            int T = testCases.Count;\n            List<int> results = Program.MaxBooks(T, testCases);\n            \n            Debug.Assert(results[0] == 3);\n            Debug.Assert(results[1] == 3);\n            Debug.Assert(results[2] == 1);\n            Debug.Assert(results[3] == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace BSTIterator\n{\n    // TreeNode class represents a node in a binary search tree\n    public class TreeNode\n    {\n        public int Val { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n\n        public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)\n        {\n            Val = val;\n            Left = left;\n            Right = right;\n        }\n    }\n\n    // BSTIterator class implements an iterator for a binary search tree that allows in-order traversal\n    public class BSTIterator\n    {\n        private Stack<TreeNode> stack;\n\n        // Initializes the iterator with the root of the BST\n        public BSTIterator(TreeNode root)\n        {\n            stack = new Stack<TreeNode>();\n            // Partial in-order traversal to push all left children to stack\n            while (root != null)\n            {\n                stack.Push(root);\n                root = root.Left;\n            }\n        }\n\n        // Returns true if there are more elements to iterate over\n        public bool HasNext()\n        {\n            return stack.Count > 0;\n        }\n\n        // Returns the next smallest element in the BST\n        public int Next()\n        {\n            // Pop the top element from the stack which is the next smallest element\n            TreeNode node = stack.Pop();\n            TreeNode tmp = node;\n            // If there is a right child, push all the left children of the right child to the stack\n            if (tmp.Right != null)\n            {\n                tmp = tmp.Right;\n                while (tmp != null)\n                {\n                    stack.Push(tmp);\n                    tmp = tmp.Left;\n                }\n            }\n            return node.Val;\n        }\n\n        // Returns the value at the top of the stack without removing it\n        public int Peek()\n        {\n            if (stack.Count > 0)\n            {\n                return stack.Peek().Val;\n            }\n            throw new InvalidOperationException(\"Iterator is empty\");\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(13,54): warning CS8625: Cannot convert null literal to non-nullable reference type. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\n/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(13,77): warning CS8625: Cannot convert null literal to non-nullable reference type. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\n/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(109,21): warning CS8625: Cannot convert null literal to non-nullable reference type. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\n/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(107,17): warning CS8625: Cannot convert null literal to non-nullable reference type. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\n/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(123,30): warning CS8600: Converting null literal or possible null value to non-nullable type. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\n/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/Program.cs(124,53): warning CS8604: Possible null reference argument for parameter 'root' in 'BSTIterator.BSTIterator(TreeNode root)'. [/data/codes/c#/653cae4b79194f6fa8a5167a5b5f6492/MyProject/MyProject.csproj]\nTest Case 1:\nInput BST: [4,2,5,1,3]\nIn-order traversal using iterator:\n1 2 3 4 5 \n\nTest Case 2:\nInput BST: [1,null,2,null,3]\nIn-order traversal using iterator:\n1 2 3 \n\nTest Case 3:\nInput BST: []\nHas next element? False", "task_id": 5181, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BSTIterator\n{\n    class TestBSTIterator\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Simple BST\n            TreeNode root1 = new TreeNode(4,\n                new TreeNode(2,\n                    new TreeNode(1),\n                    new TreeNode(3)),\n                new TreeNode(5));\n\n            BSTIterator iterator1 = new BSTIterator(root1);\n            Debug.Assert(iterator1.Next() == 1);\n            Debug.Assert(iterator1.Next() == 2);\n            Debug.Assert(iterator1.Next() == 3);\n            Debug.Assert(iterator1.Next() == 4);\n            Debug.Assert(iterator1.Next() == 5);\n            Debug.Assert(iterator1.HasNext() == false);\n\n            // Test case 2: BST with only right children\n            TreeNode root2 = new TreeNode(1,\n                null,\n                new TreeNode(2,\n                    null,\n                    new TreeNode(3)));\n\n            BSTIterator iterator2 = new BSTIterator(root2);\n            Debug.Assert(iterator2.Next() == 1);\n            Debug.Assert(iterator2.Next() == 2);\n            Debug.Assert(iterator2.Next() == 3);\n            Debug.Assert(iterator2.HasNext() == false);\n\n            // Test case 3: Empty BST\n            TreeNode root3 = null;\n            BSTIterator iterator3 = new BSTIterator(root3);\n            Debug.Assert(iterator3.HasNext() == false);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace BSTIterator\n{\n    // TreeNode class represents a node in a binary search tree\n    public class TreeNode\n    {\n        public int Val { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n\n        public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)\n        {\n            Val = val;\n            Left = left;\n            Right = right;\n        }\n    }\n\n    // BSTIterator class implements an iterator for a binary search tree that allows in-order traversal\n    public class BSTIterator\n    {\n        private Stack<TreeNode> stack;\n\n        // Initializes the iterator with the root of the BST\n        public BSTIterator(TreeNode root)\n        {\n            stack = new Stack<TreeNode>();\n            // Partial in-order traversal to push all left children to stack\n            while (root != null)\n            {\n                stack.Push(root);\n                root = root.Left;\n            }\n        }\n\n        // Returns true if there are more elements to iterate over\n        public bool HasNext()\n        {\n            return stack.Count > 0;\n        }\n\n        // Returns the next smallest element in the BST\n        public int Next()\n        {\n            // Pop the top element from the stack which is the next smallest element\n            TreeNode node = stack.Pop();\n            TreeNode tmp = node;\n            // If there is a right child, push all the left children of the right child to the stack\n            if (tmp.Right != null)\n            {\n                tmp = tmp.Right;\n                while (tmp != null)\n                {\n                    stack.Push(tmp);\n                    tmp = tmp.Left;\n                }\n            }\n            return node.Val;\n        }\n\n        // Returns the value at the top of the stack without removing it\n        public int Peek()\n        {\n            if (stack.Count > 0)\n            {\n                return stack.Peek().Val;\n            }\n            throw new InvalidOperationException(\"Iterator is empty\");\n        }\n    }\n}\n\nnamespace BSTIterator\n{\n    class TestBSTIterator\n    {\n        public static void Main()\n        {\n            // Test case 1: Simple BST\n            TreeNode root1 = new TreeNode(4,\n                new TreeNode(2,\n                    new TreeNode(1),\n                    new TreeNode(3)),\n                new TreeNode(5));\n\n            BSTIterator iterator1 = new BSTIterator(root1);\n            Debug.Assert(iterator1.Next() == 1);\n            Debug.Assert(iterator1.Next() == 2);\n            Debug.Assert(iterator1.Next() == 3);\n            Debug.Assert(iterator1.Next() == 4);\n            Debug.Assert(iterator1.Next() == 5);\n            Debug.Assert(iterator1.HasNext() == false);\n\n            // Test case 2: BST with only right children\n            TreeNode root2 = new TreeNode(1,\n                null,\n                new TreeNode(2,\n                    null,\n                    new TreeNode(3)));\n\n            BSTIterator iterator2 = new BSTIterator(root2);\n            Debug.Assert(iterator2.Next() == 1);\n            Debug.Assert(iterator2.Next() == 2);\n            Debug.Assert(iterator2.Next() == 3);\n            Debug.Assert(iterator2.HasNext() == false);\n\n            // Test case 3: Empty BST\n            TreeNode root3 = null;\n            BSTIterator iterator3 = new BSTIterator(root3);\n            Debug.Assert(iterator3.HasNext() == false);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace CodeProcessor\n{\n    class Program\n    {\n        // Calculate the minimum number of deletions required to ensure the list of codes is unique and in non-decreasing order.\n        // The function first converts the input array to a distinct set, sorts it, and then calculates the deletions required.\n        // The deletions required is the difference between the original array length and the length of the unique sorted array.\n        static int MinDeletionsToUniqueSortedCodes(int[] codes)\n        {\n            var uniqueSortedCodes = codes.Distinct().OrderBy(code => code).ToArray();\n            return codes.Length - uniqueSortedCodes.Length;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 2, 3, 4]\nDeletions Required: 1\nInput: [5, 6, 7, 0, 0]\nDeletions Required: 1\nInput: [0, 0, 0, 0]\nDeletions Required: 3\nInput: [1, 3, 2, 2, 4]\nDeletions Required: 1", "task_id": 10997, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace CodeProcessor\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 1, 2, 2, 3, 4 }) == 1);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 5, 6, 7, 0, 0 }) == 1);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 0, 0, 0, 0 }) == 3);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 1, 3, 2, 2, 4 }) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace CodeProcessor\n{\n    class Program\n    {\n        // Calculate the minimum number of deletions required to ensure the list of codes is unique and in non-decreasing order.\n        // The function first converts the input array to a distinct set, sorts it, and then calculates the deletions required.\n        // The deletions required is the difference between the original array length and the length of the unique sorted array.\n    public static int MinDeletionsToUniqueSortedCodes(int[] codes)\n        {\n            var uniqueSortedCodes = codes.Distinct().OrderBy(code => code).ToArray();\n            return codes.Length - uniqueSortedCodes.Length;\n        }\n    }\n}\n\nnamespace CodeProcessor\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 1, 2, 2, 3, 4 }) == 1);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 5, 6, 7, 0, 0 }) == 1);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 0, 0, 0, 0 }) == 3);\n            Debug.Assert(Program.MinDeletionsToUniqueSortedCodes(new int[] { 1, 3, 2, 2, 4 }) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MaxTotalCalculator\n{\n    class MaxTotalCalculator\n    {\n        // CalculateMaxTotal computes the maximum total value based on two options:\n        // Option 1: Choose to close on some day i, then the total is prefix[i-1] + 2 * A[i-1]\n        // Option 2: Never close, then the total is the sum of all elements in the array\n        public static int CalculateMaxTotal(int[] A)\n        {\n            int N = A.Length;\n            int[] prefix = new int[N + 1];\n            \n            // Compute prefix sums\n            for (int i = 1; i <= N; i++)\n            {\n                prefix[i] = prefix[i - 1] + A[i - 1];\n            }\n            \n            int maxTotal = 0;\n            \n            // Option 1: Check each day as the closing day\n            for (int i = 1; i <= N; i++)\n            {\n                int current = prefix[i - 1] + 2 * A[i - 1];\n                if (current > maxTotal)\n                {\n                    maxTotal = current;\n                }\n            }\n            \n            // Option 2: Never close\n            int totalAll = prefix[N];\n            if (totalAll > maxTotal)\n            {\n                maxTotal = totalAll;\n            }\n            \n            return maxTotal;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nMaxTotal: 14\n\nInput: [5, 6, 7, 0]\nMaxTotal: 25\n\nInput: [0, 0, 0, 0]\nMaxTotal: 0\n\nInput: [10]\nMaxTotal: 20\n\nInput: [-1, -2, 3, 4]\nMaxTotal: 8", "task_id": 23224, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxTotalCalculator\n{\n    class TestMaxTotalCalculator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 1, 2, 3, 4 }) == 14);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 5, 6, 7, 0 }) == 25);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 0, 0, 0, 0 }) == 0);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 10 }) == 20);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { -1, -2, 3, 4 }) == 8);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MaxTotalCalculator\n{\n    class MaxTotalCalculator\n    {\n        // CalculateMaxTotal computes the maximum total value based on two options:\n        // Option 1: Choose to close on some day i, then the total is prefix[i-1] + 2 * A[i-1]\n        // Option 2: Never close, then the total is the sum of all elements in the array\n        public static int CalculateMaxTotal(int[] A)\n        {\n            int N = A.Length;\n            int[] prefix = new int[N + 1];\n            \n            // Compute prefix sums\n            for (int i = 1; i <= N; i++)\n            {\n                prefix[i] = prefix[i - 1] + A[i - 1];\n            }\n            \n            int maxTotal = 0;\n            \n            // Option 1: Check each day as the closing day\n            for (int i = 1; i <= N; i++)\n            {\n                int current = prefix[i - 1] + 2 * A[i - 1];\n                if (current > maxTotal)\n                {\n                    maxTotal = current;\n                }\n            }\n            \n            // Option 2: Never close\n            int totalAll = prefix[N];\n            if (totalAll > maxTotal)\n            {\n                maxTotal = totalAll;\n            }\n            \n            return maxTotal;\n        }\n    }\n}\n\nnamespace MaxTotalCalculator\n{\n    class TestMaxTotalCalculator\n    {\n        public static void Main()\n        {\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 1, 2, 3, 4 }) == 14);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 5, 6, 7, 0 }) == 25);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 0, 0, 0, 0 }) == 0);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { 10 }) == 20);\n            Debug.Assert(MaxTotalCalculator.CalculateMaxTotal(new int[] { -1, -2, 3, 4 }) == 8);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nnamespace ChemicalFormulaParser\n{\n    public class ChemicalFormulaParser\n    {\n        // Counts the number of atoms of each element in a chemical formula\n        // Handles nested parentheses and multipliers\n        public static Dictionary<string, int> CountAtoms(string formula)\n        {\n            var stack = new Stack<Dictionary<string, int>>();\n            stack.Push(new Dictionary<string, int>());\n            int idx = 0;\n            int n = formula.Length;\n\n            while (idx < n)\n            {\n                if (formula[idx] == '(')\n                {\n                    stack.Push(new Dictionary<string, int>());\n                    idx++;\n                }\n                else if (formula[idx] == ')')\n                {\n                    idx++;\n                    int start = idx;\n                    while (idx < n && char.IsDigit(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string multiplierStr = idx > start ? formula.Substring(start, idx - start) : \"1\";\n                    int multiplier = int.Parse(multiplierStr);\n\n                    var top = stack.Pop();\n                    var current = stack.Peek();\n                    foreach (var kvp in top)\n                    {\n                        if (current.ContainsKey(kvp.Key))\n                        {\n                            current[kvp.Key] += kvp.Value * multiplier;\n                        }\n                        else\n                        {\n                            current[kvp.Key] = kvp.Value * multiplier;\n                        }\n                    }\n                }\n                else\n                {\n                    int start = idx;\n                    idx++;\n                    while (idx < n && char.IsLower(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string element = formula.Substring(start, idx - start);\n\n                    start = idx;\n                    while (idx < n && char.IsDigit(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string countStr = idx > start ? formula.Substring(start, idx - start) : \"1\";\n                    int count = int.Parse(countStr);\n\n                    var current = stack.Peek();\n                    if (current.ContainsKey(element))\n                    {\n                        current[element] += count;\n                    }\n                    else\n                    {\n                        current[element] = count;\n                    }\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: H2O\nResult: { H: 2, O: 1 }\n\nInput: Mg(OH)2\nResult: { Mg: 1, O: 2, H: 2 }\n\nInput: K4[ON(SO3)2]2\nResult: { K: 4, [: 1, O: 7, N: 1, S: 2, ]: 2 }\n\nInput: C6H12O6\nResult: { C: 6, H: 12, O: 6 }\n\nInput: (NH4)2SO4\nResult: { N: 2, H: 8, S: 1, O: 4 }\n\nInput: Na2CO3.10H2O\nResult: { Na: 2, C: 1, O: 4, .: 10, H: 2 }", "task_id": 7569, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ChemicalFormulaParser\n{\n    class TestChemicalFormulaParser\n    {\n        public static void RunTests()\n        {\n            // Test case 1: H2O\n            var result1 = ChemicalFormulaParser.CountAtoms(\"H2O\");\n            Debug.Assert(result1[\"H\"] == 2);\n            Debug.Assert(result1[\"O\"] == 1);\n            Debug.Assert(result1.Count == 2);\n\n            // Test case 2: Mg(OH)2\n            var result2 = ChemicalFormulaParser.CountAtoms(\"Mg(OH)2\");\n            Debug.Assert(result2[\"Mg\"] == 1);\n            Debug.Assert(result2[\"O\"] == 2);\n            Debug.Assert(result2[\"H\"] == 2);\n            Debug.Assert(result2.Count == 3);\n\n            // Test case 3: K4[ON(SO3)2]2\n            var result3 = ChemicalFormulaParser.CountAtoms(\"K4[ON(SO3)2]2\");\n            Debug.Assert(result3[\"K\"] == 4);\n            Debug.Assert(result3[\"[\"] == 1);\n            Debug.Assert(result3[\"O\"] == 7);\n            Debug.Assert(result3[\"N\"] == 1);\n            Debug.Assert(result3[\"S\"] == 2);\n            Debug.Assert(result3[\"]\"] == 2);\n            Debug.Assert(result3.Count == 6);\n\n            // Test case 4: C6H12O6\n            var result4 = ChemicalFormulaParser.CountAtoms(\"C6H12O6\");\n            Debug.Assert(result4[\"C\"] == 6);\n            Debug.Assert(result4[\"H\"] == 12);\n            Debug.Assert(result4[\"O\"] == 6);\n            Debug.Assert(result4.Count == 3);\n\n            // Test case 5: (NH4)2SO4\n            var result5 = ChemicalFormulaParser.CountAtoms(\"(NH4)2SO4\");\n            Debug.Assert(result5[\"N\"] == 2);\n            Debug.Assert(result5[\"H\"] == 8);\n            Debug.Assert(result5[\"S\"] == 1);\n            Debug.Assert(result5[\"O\"] == 4);\n            Debug.Assert(result5.Count == 4);\n\n            // Test case 6: Na2CO3.10H2O\n            var result6 = ChemicalFormulaParser.CountAtoms(\"Na2CO3.10H2O\");\n            Debug.Assert(result6[\"Na\"] == 2);\n            Debug.Assert(result6[\"C\"] == 1);\n            Debug.Assert(result6[\"O\"] == 4);\n            Debug.Assert(result6[\".\"] == 10);\n            Debug.Assert(result6[\"H\"] == 2);\n            Debug.Assert(result6.Count == 5);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\nusing System;\n\nnamespace ChemicalFormulaParser\n{\n    public class ChemicalFormulaParser\n    {\n        // Counts the number of atoms of each element in a chemical formula\n        // Handles nested parentheses and multipliers\n        public static Dictionary<string, int> CountAtoms(string formula)\n        {\n            var stack = new Stack<Dictionary<string, int>>();\n            stack.Push(new Dictionary<string, int>());\n            int idx = 0;\n            int n = formula.Length;\n\n            while (idx < n)\n            {\n                if (formula[idx] == '(')\n                {\n                    stack.Push(new Dictionary<string, int>());\n                    idx++;\n                }\n                else if (formula[idx] == ')')\n                {\n                    idx++;\n                    int start = idx;\n                    while (idx < n && char.IsDigit(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string multiplierStr = idx > start ? formula.Substring(start, idx - start) : \"1\";\n                    int multiplier = int.Parse(multiplierStr);\n\n                    var top = stack.Pop();\n                    var current = stack.Peek();\n                    foreach (var kvp in top)\n                    {\n                        if (current.ContainsKey(kvp.Key))\n                        {\n                            current[kvp.Key] += kvp.Value * multiplier;\n                        }\n                        else\n                        {\n                            current[kvp.Key] = kvp.Value * multiplier;\n                        }\n                    }\n                }\n                else\n                {\n                    int start = idx;\n                    idx++;\n                    while (idx < n && char.IsLower(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string element = formula.Substring(start, idx - start);\n\n                    start = idx;\n                    while (idx < n && char.IsDigit(formula[idx]))\n                    {\n                        idx++;\n                    }\n                    string countStr = idx > start ? formula.Substring(start, idx - start) : \"1\";\n                    int count = int.Parse(countStr);\n\n                    var current = stack.Peek();\n                    if (current.ContainsKey(element))\n                    {\n                        current[element] += count;\n                    }\n                    else\n                    {\n                        current[element] = count;\n                    }\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}\n\nnamespace ChemicalFormulaParser\n{\n    class TestChemicalFormulaParser\n    {\n        public static void Main()\n        {\n            // Test case 1: H2O\n            var result1 = ChemicalFormulaParser.CountAtoms(\"H2O\");\n            Debug.Assert(result1[\"H\"] == 2);\n            Debug.Assert(result1[\"O\"] == 1);\n            Debug.Assert(result1.Count == 2);\n\n            // Test case 2: Mg(OH)2\n            var result2 = ChemicalFormulaParser.CountAtoms(\"Mg(OH)2\");\n            Debug.Assert(result2[\"Mg\"] == 1);\n            Debug.Assert(result2[\"O\"] == 2);\n            Debug.Assert(result2[\"H\"] == 2);\n            Debug.Assert(result2.Count == 3);\n\n            // Test case 3: K4[ON(SO3)2]2\n            var result3 = ChemicalFormulaParser.CountAtoms(\"K4[ON(SO3)2]2\");\n            Debug.Assert(result3[\"K\"] == 4);\n            Debug.Assert(result3[\"[\"] == 1);\n            Debug.Assert(result3[\"O\"] == 7);\n            Debug.Assert(result3[\"N\"] == 1);\n            Debug.Assert(result3[\"S\"] == 2);\n            Debug.Assert(result3[\"]\"] == 2);\n            Debug.Assert(result3.Count == 6);\n\n            // Test case 4: C6H12O6\n            var result4 = ChemicalFormulaParser.CountAtoms(\"C6H12O6\");\n            Debug.Assert(result4[\"C\"] == 6);\n            Debug.Assert(result4[\"H\"] == 12);\n            Debug.Assert(result4[\"O\"] == 6);\n            Debug.Assert(result4.Count == 3);\n\n            // Test case 5: (NH4)2SO4\n            var result5 = ChemicalFormulaParser.CountAtoms(\"(NH4)2SO4\");\n            Debug.Assert(result5[\"N\"] == 2);\n            Debug.Assert(result5[\"H\"] == 8);\n            Debug.Assert(result5[\"S\"] == 1);\n            Debug.Assert(result5[\"O\"] == 4);\n            Debug.Assert(result5.Count == 4);\n\n            // Test case 6: Na2CO3.10H2O\n            var result6 = ChemicalFormulaParser.CountAtoms(\"Na2CO3.10H2O\");\n            Debug.Assert(result6[\"Na\"] == 2);\n            Debug.Assert(result6[\"C\"] == 1);\n            Debug.Assert(result6[\"O\"] == 4);\n            Debug.Assert(result6[\".\"] == 10);\n            Debug.Assert(result6[\"H\"] == 2);\n            Debug.Assert(result6.Count == 5);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MaxBlockSizeFinder\n{\n    class Program\n    {\n        // Performs a depth-first search (DFS) to find the size of the block of cells with the same height.\n        // Marks visited cells by setting their value to -1 to avoid revisiting.\n        // Returns the size of the block starting at (x, y).\n        static int Dfs(int x, int y, int height, int n, int[][] grid)\n        {\n            if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] != height)\n            {\n                return 0;\n            }\n            grid[x][y] = -1; // Mark as visited\n            int size = 1;\n            // Directions: up, down, left, right\n            int[][] directions = new int[][]\n            {\n                new int[] { -1, 0 },\n                new int[] { 1, 0 },\n                new int[] { 0, -1 },\n                new int[] { 0, 1 }\n            };\n            foreach (var dir in directions)\n            {\n                size += Dfs(x + dir[0], y + dir[1], height, n, grid);\n            }\n            return size;\n        }\n\n        // Finds the maximum block size in the grid where a block is a group of adjacent cells with the same height.\n        // Adjacent cells are those that are horizontally or vertically neighboring.\n        static int FindMaxBlockSize(int n, int[][] grid)\n        {\n            int maxBlockSize = 0;\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (grid[i][j] != -1) // Not visited\n                    {\n                        int height = grid[i][j];\n                        maxBlockSize = Math.Max(maxBlockSize, Dfs(i, j, height, n, grid));\n                    }\n                }\n            }\n            return maxBlockSize;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Grid:\n1, 1, 2\n1, 1, 2\n3, 3, 2\nMax Block Size: 4\n\nTest Case 2:\nInput Grid:\n4, 4\n4, 4\nMax Block Size: 4\n\nTest Case 3:\nInput Grid:\n1, 1, 2, 3\n1, 2, 2, 3\n4, 4, 4, 3\n4, 5, 5, 5\nMax Block Size: 4", "task_id": 16632, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxBlockSizeFinder\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: 3x3 grid with a single block of size 4\n            int[][] grid1 = new int[][]\n            {\n                new int[] { 1, 1, 2 },\n                new int[] { 1, 1, 2 },\n                new int[] { 3, 3, 2 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(3, grid1) == 4);\n\n            // Test case 2: 2x2 grid with all cells having the same height\n            int[][] grid2 = new int[][]\n            {\n                new int[] { 4, 4 },\n                new int[] { 4, 4 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(2, grid2) == 4);\n\n            // Test case 3: 4x4 grid with multiple blocks\n            int[][] grid3 = new int[][]\n            {\n                new int[] { 1, 1, 2, 3 },\n                new int[] { 1, 2, 2, 3 },\n                new int[] { 4, 4, 4, 3 },\n                new int[] { 4, 5, 5, 5 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(4, grid3) == 4);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MaxBlockSizeFinder\n{\n    class Program\n    {\n        // Performs a depth-first search (DFS) to find the size of the block of cells with the same height.\n        // Marks visited cells by setting their value to -1 to avoid revisiting.\n        // Returns the size of the block starting at (x, y).\n    public static int Dfs(int x, int y, int height, int n, int[][] grid)\n        {\n            if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] != height)\n            {\n                return 0;\n            }\n            grid[x][y] = -1; // Mark as visited\n            int size = 1;\n            // Directions: up, down, left, right\n            int[][] directions = new int[][]\n            {\n                new int[] { -1, 0 },\n                new int[] { 1, 0 },\n                new int[] { 0, -1 },\n                new int[] { 0, 1 }\n            };\n            foreach (var dir in directions)\n            {\n                size += Dfs(x + dir[0], y + dir[1], height, n, grid);\n            }\n            return size;\n        }\n\n        // Finds the maximum block size in the grid where a block is a group of adjacent cells with the same height.\n        // Adjacent cells are those that are horizontally or vertically neighboring.\n    public static int FindMaxBlockSize(int n, int[][] grid)\n        {\n            int maxBlockSize = 0;\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    if (grid[i][j] != -1) // Not visited\n                    {\n                        int height = grid[i][j];\n                        maxBlockSize = Math.Max(maxBlockSize, Dfs(i, j, height, n, grid));\n                    }\n                }\n            }\n            return maxBlockSize;\n        }\n    }\n}\n\nnamespace MaxBlockSizeFinder\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: 3x3 grid with a single block of size 4\n            int[][] grid1 = new int[][]\n            {\n                new int[] { 1, 1, 2 },\n                new int[] { 1, 1, 2 },\n                new int[] { 3, 3, 2 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(3, grid1) == 4);\n\n            // Test case 2: 2x2 grid with all cells having the same height\n            int[][] grid2 = new int[][]\n            {\n                new int[] { 4, 4 },\n                new int[] { 4, 4 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(2, grid2) == 4);\n\n            // Test case 3: 4x4 grid with multiple blocks\n            int[][] grid3 = new int[][]\n            {\n                new int[] { 1, 1, 2, 3 },\n                new int[] { 1, 2, 2, 3 },\n                new int[] { 4, 4, 4, 3 },\n                new int[] { 4, 5, 5, 5 }\n            };\n            Debug.Assert(Program.FindMaxBlockSize(4, grid3) == 4);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace CostOptimization\n{\n    class Program\n    {\n        // Calculates the cost to reduce all numbers in the array to at most k.\n        // The cost is computed as the sum of (num - k) * p for each num > k.\n        // If the cost exceeds w at any point, the calculation is terminated early for efficiency.\n        static int CalculateCost(int[] numbers, int k, int p, int w)\n        {\n            int cost = 0;\n            foreach (int num in numbers)\n            {\n                if (num > k)\n                {\n                    int diff = num - k;\n                    cost += diff * p;\n                    if (cost > w)\n                    {\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n        // Finds the minimal k such that the cost to reduce all numbers in the array to at most k is <= w.\n        // Uses binary search between 0 and the maximum value in the array - 1.\n        // If no such k is found, returns the maximum value in the array.\n        static int FindMinimalK(int[] numbers, int p, int w)\n        {\n            int maxNum = 0;\n            foreach (int num in numbers)\n            {\n                if (num > maxNum)\n                {\n                    maxNum = num;\n                }\n            }\n\n            if (maxNum == 0)\n            {\n                return 0;\n            }\n\n            int left = 0;\n            int right = maxNum - 1;\n            int bestK = -1;\n\n            while (left <= right)\n            {\n                int mid = (left + right) / 2;\n                int currentCost = CalculateCost(numbers, mid, p, w);\n                if (currentCost <= w)\n                {\n                    bestK = mid;\n                    right = mid - 1;\n                }\n                else\n                {\n                    left = mid + 1;\n                }\n            }\n\n            return bestK != -1 ? bestK : maxNum;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput numbers: [5, 8, 3, 10]\np: 2, w: 15\nMinimal k: 6\n\nTest Case 2:\nInput numbers: [5, 8, 3, 10]\np: 2, w: 5\nMinimal k: 8\n\nTest Case 3:\nInput numbers: [0, 0, 0, 0]\np: 2, w: 10\nMinimal k: 0", "task_id": 29934, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace CostOptimization\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Normal case with solution\n            int[] numbers1 = { 5, 8, 3, 10 };\n            int p1 = 2;\n            int w1 = 15;\n            Debug.Assert(Program.FindMinimalK(numbers1, p1, w1) == 6);\n\n            // Test case 2: No solution, cost exceeds w for all k < maxNum\n            int[] numbers2 = { 5, 8, 3, 10 };\n            int p2 = 2;\n            int w2 = 5;\n            Debug.Assert(Program.FindMinimalK(numbers2, p2, w2) == 8);\n\n            // Test case 3: All numbers are zero\n            int[] numbers3 = { 0, 0, 0, 0 };\n            int p3 = 2;\n            int w3 = 10;\n            Debug.Assert(Program.FindMinimalK(numbers3, p3, w3) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace CostOptimization\n{\n    class Program\n    {\n        // Calculates the cost to reduce all numbers in the array to at most k.\n        // The cost is computed as the sum of (num - k) * p for each num > k.\n        // If the cost exceeds w at any point, the calculation is terminated early for efficiency.\n    public static int CalculateCost(int[] numbers, int k, int p, int w)\n        {\n            int cost = 0;\n            foreach (int num in numbers)\n            {\n                if (num > k)\n                {\n                    int diff = num - k;\n                    cost += diff * p;\n                    if (cost > w)\n                    {\n                        break;\n                    }\n                }\n            }\n            return cost;\n        }\n\n        // Finds the minimal k such that the cost to reduce all numbers in the array to at most k is <= w.\n        // Uses binary search between 0 and the maximum value in the array - 1.\n        // If no such k is found, returns the maximum value in the array.\n    public static int FindMinimalK(int[] numbers, int p, int w)\n        {\n            int maxNum = 0;\n            foreach (int num in numbers)\n            {\n                if (num > maxNum)\n                {\n                    maxNum = num;\n                }\n            }\n\n            if (maxNum == 0)\n            {\n                return 0;\n            }\n\n            int left = 0;\n            int right = maxNum - 1;\n            int bestK = -1;\n\n            while (left <= right)\n            {\n                int mid = (left + right) / 2;\n                int currentCost = CalculateCost(numbers, mid, p, w);\n                if (currentCost <= w)\n                {\n                    bestK = mid;\n                    right = mid - 1;\n                }\n                else\n                {\n                    left = mid + 1;\n                }\n            }\n\n            return bestK != -1 ? bestK : maxNum;\n        }\n    }\n}\n\nnamespace CostOptimization\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Normal case with solution\n            int[] numbers1 = { 5, 8, 3, 10 };\n            int p1 = 2;\n            int w1 = 15;\n            Debug.Assert(Program.FindMinimalK(numbers1, p1, w1) == 6);\n\n            // Test case 2: No solution, cost exceeds w for all k < maxNum\n            int[] numbers2 = { 5, 8, 3, 10 };\n            int p2 = 2;\n            int w2 = 5;\n            Debug.Assert(Program.FindMinimalK(numbers2, p2, w2) == 8);\n\n            // Test case 3: All numbers are zero\n            int[] numbers3 = { 0, 0, 0, 0 };\n            int p3 = 2;\n            int w3 = 10;\n            Debug.Assert(Program.FindMinimalK(numbers3, p3, w3) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace ArrayRotation\n{\n    class Program\n    {\n        /// <summary>\n        /// Rotates the array to the right by the given number of steps.\n        /// </summary>\n        /// <param name=\"arr\">The input array to be rotated.</param>\n        /// <param name=\"steps\">The number of steps to rotate the array.</param>\n        /// <returns>The rotated array.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when steps is not an integer.</exception>\n        static int[] RotateArray(int[] arr, int steps)\n        {\n            if (arr.Length == 0)\n            {\n                return arr; // return empty array if input array is empty\n            }\n\n            // Handle steps that are larger than array length and negative steps\n            steps = steps % arr.Length;\n            if (steps < 0)\n            {\n                steps += arr.Length; // convert negative steps to positive equivalent\n            }\n\n            int[] rotatedArray = new int[arr.Length];\n            Array.Copy(arr, arr.Length - steps, rotatedArray, 0, steps);\n            Array.Copy(arr, 0, rotatedArray, steps, arr.Length - steps);\n            return rotatedArray;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Array: [1, 2, 3, 4], Steps: 1\nRotated Array: [4, 1, 2, 3]\nInput Array: [1, 2, 3, 4], Steps: 3\nRotated Array: [2, 3, 4, 1]\nInput Array: [1, 2, 3, 4], Steps: 4\nRotated Array: [1, 2, 3, 4]\nInput Array: [1, 2, 3, 4], Steps: -1\nRotated Array: [2, 3, 4, 1]\nInput Array: [], Steps: 2\nRotated Array: []", "task_id": 367, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ArrayRotation\n{\n    class TestArrayRotation\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Rotate right by 1 step\n            int[] arr1 = { 1, 2, 3, 4 };\n            int[] expected1 = { 4, 1, 2, 3 };\n            int[] result1 = Program.RotateArray(arr1, 1);\n            Debug.Assert(CompareArrays(result1, expected1));\n\n            // Test case 2: Rotate right by 3 steps\n            int[] arr2 = { 1, 2, 3, 4 };\n            int[] expected2 = { 2, 3, 4, 1 };\n            int[] result2 = Program.RotateArray(arr2, 3);\n            Debug.Assert(CompareArrays(result2, expected2));\n\n            // Test case 3: Rotate right by 4 steps (full rotation)\n            int[] arr3 = { 1, 2, 3, 4 };\n            int[] expected3 = { 1, 2, 3, 4 };\n            int[] result3 = Program.RotateArray(arr3, 4);\n            Debug.Assert(CompareArrays(result3, expected3));\n\n            // Test case 4: Rotate right by -1 step (equivalent to rotating left by 1 step)\n            int[] arr4 = { 1, 2, 3, 4 };\n            int[] expected4 = { 2, 3, 4, 1 };\n            int[] result4 = Program.RotateArray(arr4, -1);\n            Debug.Assert(CompareArrays(result4, expected4));\n\n            // Test case 5: Empty array\n            int[] arr5 = { };\n            int[] expected5 = { };\n            int[] result5 = Program.RotateArray(arr5, 2);\n            Debug.Assert(CompareArrays(result5, expected5));\n        }\n\n        private static bool CompareArrays(int[] a, int[] b)\n        {\n            if (a.Length != b.Length) return false;\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace ArrayRotation\n{\n    class Program\n    {\n        /// <summary>\n        /// Rotates the array to the right by the given number of steps.\n        /// </summary>\n        /// <param name=\"arr\">The input array to be rotated.</param>\n        /// <param name=\"steps\">The number of steps to rotate the array.</param>\n        /// <returns>The rotated array.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when steps is not an integer.</exception>\n    public static int[] RotateArray(int[] arr, int steps)\n        {\n            if (arr.Length == 0)\n            {\n                return arr; // return empty array if input array is empty\n            }\n\n            // Handle steps that are larger than array length and negative steps\n            steps = steps % arr.Length;\n            if (steps < 0)\n            {\n                steps += arr.Length; // convert negative steps to positive equivalent\n            }\n\n            int[] rotatedArray = new int[arr.Length];\n            Array.Copy(arr, arr.Length - steps, rotatedArray, 0, steps);\n            Array.Copy(arr, 0, rotatedArray, steps, arr.Length - steps);\n            return rotatedArray;\n        }\n    }\n}\n\nnamespace ArrayRotation\n{\n    class TestArrayRotation\n    {\n        public static void Main()\n        {\n            // Test case 1: Rotate right by 1 step\n            int[] arr1 = { 1, 2, 3, 4 };\n            int[] expected1 = { 4, 1, 2, 3 };\n            int[] result1 = Program.RotateArray(arr1, 1);\n            Debug.Assert(CompareArrays(result1, expected1));\n\n            // Test case 2: Rotate right by 3 steps\n            int[] arr2 = { 1, 2, 3, 4 };\n            int[] expected2 = { 2, 3, 4, 1 };\n            int[] result2 = Program.RotateArray(arr2, 3);\n            Debug.Assert(CompareArrays(result2, expected2));\n\n            // Test case 3: Rotate right by 4 steps (full rotation)\n            int[] arr3 = { 1, 2, 3, 4 };\n            int[] expected3 = { 1, 2, 3, 4 };\n            int[] result3 = Program.RotateArray(arr3, 4);\n            Debug.Assert(CompareArrays(result3, expected3));\n\n            // Test case 4: Rotate right by -1 step (equivalent to rotating left by 1 step)\n            int[] arr4 = { 1, 2, 3, 4 };\n            int[] expected4 = { 2, 3, 4, 1 };\n            int[] result4 = Program.RotateArray(arr4, -1);\n            Debug.Assert(CompareArrays(result4, expected4));\n\n            // Test case 5: Empty array\n            int[] arr5 = { };\n            int[] expected5 = { };\n            int[] result5 = Program.RotateArray(arr5, 2);\n            Debug.Assert(CompareArrays(result5, expected5));\n        }\n\n        private static bool CompareArrays(int[] a, int[] b)\n        {\n            if (a.Length != b.Length) return false;\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace BaseDigitCalculator\n{\n    class Program\n    {\n        // CalculateMaxDigits computes the maximum number of digits the sum of two numbers (a and b)\n        // can have when represented in any base greater than the maximum digit in a or b.\n        public static int CalculateMaxDigits(string aStr, string bStr)\n        {\n            // Find the maximum digit in the concatenated strings aStr and bStr\n            int maxDigit = 0;\n            foreach (char c in aStr + bStr)\n            {\n                int digit = c - '0';\n                if (digit > maxDigit)\n                {\n                    maxDigit = digit;\n                }\n            }\n\n            // The minimum base is maxDigit + 1\n            int pMin = maxDigit + 1;\n\n            // Convert a and b to integers\n            int a = int.Parse(aStr);\n            int b = int.Parse(bStr);\n            int sum = a + b;\n\n            // Calculate the maximum number of digits in any base >= pMin\n            // The maximum digits occur at the smallest base (pMin)\n            if (sum == 0)\n            {\n                return 1; // Edge case: sum is zero, which is represented as \"0\" in any base\n            }\n\n            int maxDigits = 0;\n            int temp = sum;\n            while (temp > 0)\n            {\n                temp /= pMin;\n                maxDigits++;\n            }\n\n            return maxDigits;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: a = 1, b = 1\nMax Digits: 2\n\nInput: a = 10, b = 20\nMax Digits: 4\n\nInput: a = 999, b = 1\nMax Digits: 4\n\nInput: a = 123, b = 456\nMax Digits: 4\n\nInput: a = 0, b = 0\nMax Digits: 1", "task_id": 24340, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BaseDigitCalculator\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateMaxDigits(\"1\", \"1\") == 2);\n            Debug.Assert(Program.CalculateMaxDigits(\"10\", \"20\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"999\", \"1\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"123\", \"456\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"0\", \"0\") == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace BaseDigitCalculator\n{\n    class Program\n    {\n        // CalculateMaxDigits computes the maximum number of digits the sum of two numbers (a and b)\n        // can have when represented in any base greater than the maximum digit in a or b.\n        public static int CalculateMaxDigits(string aStr, string bStr)\n        {\n            // Find the maximum digit in the concatenated strings aStr and bStr\n            int maxDigit = 0;\n            foreach (char c in aStr + bStr)\n            {\n                int digit = c - '0';\n                if (digit > maxDigit)\n                {\n                    maxDigit = digit;\n                }\n            }\n\n            // The minimum base is maxDigit + 1\n            int pMin = maxDigit + 1;\n\n            // Convert a and b to integers\n            int a = int.Parse(aStr);\n            int b = int.Parse(bStr);\n            int sum = a + b;\n\n            // Calculate the maximum number of digits in any base >= pMin\n            // The maximum digits occur at the smallest base (pMin)\n            if (sum == 0)\n            {\n                return 1; // Edge case: sum is zero, which is represented as \"0\" in any base\n            }\n\n            int maxDigits = 0;\n            int temp = sum;\n            while (temp > 0)\n            {\n                temp /= pMin;\n                maxDigits++;\n            }\n\n            return maxDigits;\n        }\n    }\n}\n\nnamespace BaseDigitCalculator\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateMaxDigits(\"1\", \"1\") == 2);\n            Debug.Assert(Program.CalculateMaxDigits(\"10\", \"20\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"999\", \"1\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"123\", \"456\") == 4);\n            Debug.Assert(Program.CalculateMaxDigits(\"0\", \"0\") == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace StringModifier\n{\n    class Program\n    {\n        /// <summary>\n        /// Modifies the input string by converting every k-th character (1-indexed) to uppercase.\n        /// </summary>\n        /// <param name=\"s\">The input string to be modified.</param>\n        /// <param name=\"k\">The position interval for characters to be converted to uppercase.</param>\n        /// <returns>The modified string with every k-th character in uppercase.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when k is not a positive integer or the input string is empty.</exception>\n        public static string UppercaseKthCharacter(string s, int k)\n        {\n            if (k <= 0 || string.IsNullOrEmpty(s))\n            {\n                throw new ArgumentException(\"k must be a positive integer and s cannot be empty\");\n            }\n\n            // Convert the string to a char array for mutable operations\n            char[] charArray = s.ToCharArray();\n\n            // Iterate over the string and uppercase every k-th character (1-indexed)\n            for (int i = k - 1; i < charArray.Length; i += k)\n            {\n                charArray[i] = char.ToUpper(charArray[i]);\n            }\n\n            // Convert the char array back to a string\n            return new string(charArray);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: \"hello world\", k: 2\nModified string: \"hElLo wOrLd\"\nInput: \"abcdefghij\", k: 3\nModified string: \"abCdeFghIj\"\nInput: \"test\", k: 1\nModified string: \"TEST\"\nInput: \"lowercase\", k: 4\nModified string: \"lowErcaSe\"\nInput: \"12345\", k: 5\nModified string: \"12345\"", "task_id": 29908, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StringModifier\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            string result1 = Program.UppercaseKthCharacter(\"hello world\", 2);\n            Debug.Assert(result1 == \"hElLo wOrLd\");\n\n            // Test case 2\n            string result2 = Program.UppercaseKthCharacter(\"abcdefghij\", 3);\n            Debug.Assert(result2 == \"abCdeFghIj\");\n\n            // Test case 3\n            string result3 = Program.UppercaseKthCharacter(\"test\", 1);\n            Debug.Assert(result3 == \"TEST\");\n\n            // Test case 4\n            string result4 = Program.UppercaseKthCharacter(\"lowercase\", 4);\n            Debug.Assert(result4 == \"lowErcaSe\");\n\n            // Test case 5\n            string result5 = Program.UppercaseKthCharacter(\"12345\", 5);\n            Debug.Assert(result5 == \"12345\");\n\n            // Test case for exception\n            try\n            {\n                Program.UppercaseKthCharacter(\"\", 1);\n                Debug.Assert(false); // Should not reach here\n            }\n            catch (ArgumentException)\n            {\n                Debug.Assert(true); // Expected exception\n            }\n\n            try\n            {\n                Program.UppercaseKthCharacter(\"test\", 0);\n                Debug.Assert(false); // Should not reach here\n            }\n            catch (ArgumentException)\n            {\n                Debug.Assert(true); // Expected exception\n            }\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace StringModifier\n{\n    class Program\n    {\n        /// <summary>\n        /// Modifies the input string by converting every k-th character (1-indexed) to uppercase.\n        /// </summary>\n        /// <param name=\"s\">The input string to be modified.</param>\n        /// <param name=\"k\">The position interval for characters to be converted to uppercase.</param>\n        /// <returns>The modified string with every k-th character in uppercase.</returns>\n        /// <exception cref=\"ArgumentException\">Thrown when k is not a positive integer or the input string is empty.</exception>\n        public static string UppercaseKthCharacter(string s, int k)\n        {\n            if (k <= 0 || string.IsNullOrEmpty(s))\n            {\n                throw new ArgumentException(\"k must be a positive integer and s cannot be empty\");\n            }\n\n            // Convert the string to a char array for mutable operations\n            char[] charArray = s.ToCharArray();\n\n            // Iterate over the string and uppercase every k-th character (1-indexed)\n            for (int i = k - 1; i < charArray.Length; i += k)\n            {\n                charArray[i] = char.ToUpper(charArray[i]);\n            }\n\n            // Convert the char array back to a string\n            return new string(charArray);\n        }\n    }\n}\n\nnamespace StringModifier\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            string result1 = Program.UppercaseKthCharacter(\"hello world\", 2);\n            Debug.Assert(result1 == \"hElLo wOrLd\");\n\n            // Test case 2\n            string result2 = Program.UppercaseKthCharacter(\"abcdefghij\", 3);\n            Debug.Assert(result2 == \"abCdeFghIj\");\n\n            // Test case 3\n            string result3 = Program.UppercaseKthCharacter(\"test\", 1);\n            Debug.Assert(result3 == \"TEST\");\n\n            // Test case 4\n            string result4 = Program.UppercaseKthCharacter(\"lowercase\", 4);\n            Debug.Assert(result4 == \"lowErcaSe\");\n\n            // Test case 5\n            string result5 = Program.UppercaseKthCharacter(\"12345\", 5);\n            Debug.Assert(result5 == \"12345\");\n\n            // Test case for exception\n            try\n            {\n                Program.UppercaseKthCharacter(\"\", 1);\n                Debug.Assert(false); // Should not reach here\n            }\n            catch (ArgumentException)\n            {\n                Debug.Assert(true); // Expected exception\n            }\n\n            try\n            {\n                Program.UppercaseKthCharacter(\"test\", 0);\n                Debug.Assert(false); // Should not reach here\n            }\n            catch (ArgumentException)\n            {\n                Debug.Assert(true); // Expected exception\n            }\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace BulbController\n{\n    class BulbUtils\n    {\n        // Sets the bulb at position `i` (1-based) to state `x`.\n        public static void SetBulb(int[] bulbs, int i, int x)\n        {\n            bulbs[i - 1] = x;\n        }\n\n        // Toggles the state of bulbs from position `l` to `r` (1-based).\n        public static void ToggleBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 1 - bulbs[idx];\n            }\n        }\n\n        // Turns off bulbs from position `l` to `r` (1-based).\n        public static void TurnOffBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 0;\n            }\n        }\n\n        // Turns on bulbs from position `l` to `r` (1-based).\n        public static void TurnOnBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 1;\n            }\n        }\n\n        // Processes all commands and returns the final state of the bulbs.\n        public static int[] ProcessCommands(int n, int m, int[] initialBulbs, int[][] commands)\n        {\n            int[] bulbs = new int[n];\n            Array.Copy(initialBulbs, bulbs, n);\n\n            foreach (var cmd in commands)\n            {\n                int a = cmd[0];\n                if (a == 1)\n                {\n                    int i = cmd[1];\n                    int x = cmd[2];\n                    SetBulb(bulbs, i, x);\n                }\n                else if (a == 2)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    ToggleBulbs(bulbs, l, r);\n                }\n                else if (a == 3)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    TurnOffBulbs(bulbs, l, r);\n                }\n                else if (a == 4)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    TurnOnBulbs(bulbs, l, r);\n                }\n            }\n\n            return bulbs;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInitial Bulbs: 0, 0, 0, 0, 0, 0, 0, 0\nCommands:\n1, 2, 1\n1, 4, 1\n2, 2, 4\nFinal Bulbs: 0, 0, 1, 0, 0, 0, 0, 0\n\nTest Case 2:\nInitial Bulbs: 1, 0, 1, 0, 1\nCommands:\n2, 1, 5\nFinal Bulbs: 0, 1, 0, 1, 0\n\nTest Case 3:\nInitial Bulbs: 1, 1, 1, 1, 1, 1\nCommands:\n3, 2, 5\n4, 1, 3\nFinal Bulbs: 1, 1, 1, 0, 0, 1", "task_id": 6675, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BulbController\n{\n    class TestBulbUtils\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            int n1 = 8;\n            int m1 = 3;\n            int[] initialBulbs1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\n            int[][] commands1 = new int[][]\n            {\n                new int[] { 1, 2, 1 },\n                new int[] { 1, 4, 1 },\n                new int[] { 2, 2, 4 }\n            };\n            int[] expected1 = { 0, 0, 1, 0, 0, 0, 0, 0 };\n            int[] result1 = BulbUtils.ProcessCommands(n1, m1, initialBulbs1, commands1);\n            Debug.Assert(CompareArrays(result1, expected1), \"Test Case 1 failed\");\n\n            // Test Case 2\n            int n2 = 5;\n            int m2 = 1;\n            int[] initialBulbs2 = { 1, 0, 1, 0, 1 };\n            int[][] commands2 = new int[][]\n            {\n                new int[] { 2, 1, 5 }\n            };\n            int[] expected2 = { 0, 1, 0, 1, 0 };\n            int[] result2 = BulbUtils.ProcessCommands(n2, m2, initialBulbs2, commands2);\n            Debug.Assert(CompareArrays(result2, expected2), \"Test Case 2 failed\");\n\n            // Test Case 3\n            int n3 = 6;\n            int m3 = 2;\n            int[] initialBulbs3 = { 1, 1, 1, 1, 1, 1 };\n            int[][] commands3 = new int[][]\n            {\n                new int[] { 3, 2, 5 },\n                new int[] { 4, 1, 3 }\n            };\n            int[] expected3 = { 1, 1, 1, 0, 0, 1 };\n            int[] result3 = BulbUtils.ProcessCommands(n3, m3, initialBulbs3, commands3);\n            Debug.Assert(CompareArrays(result3, expected3), \"Test Case 3 failed\");\n        }\n\n        private static bool CompareArrays(int[] a, int[] b)\n        {\n            if (a.Length != b.Length) return false;\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace BulbController\n{\n    class BulbUtils\n    {\n        // Sets the bulb at position `i` (1-based) to state `x`.\n        public static void SetBulb(int[] bulbs, int i, int x)\n        {\n            bulbs[i - 1] = x;\n        }\n\n        // Toggles the state of bulbs from position `l` to `r` (1-based).\n        public static void ToggleBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 1 - bulbs[idx];\n            }\n        }\n\n        // Turns off bulbs from position `l` to `r` (1-based).\n        public static void TurnOffBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 0;\n            }\n        }\n\n        // Turns on bulbs from position `l` to `r` (1-based).\n        public static void TurnOnBulbs(int[] bulbs, int l, int r)\n        {\n            for (int idx = l - 1; idx < r; idx++)\n            {\n                bulbs[idx] = 1;\n            }\n        }\n\n        // Processes all commands and returns the final state of the bulbs.\n        public static int[] ProcessCommands(int n, int m, int[] initialBulbs, int[][] commands)\n        {\n            int[] bulbs = new int[n];\n            Array.Copy(initialBulbs, bulbs, n);\n\n            foreach (var cmd in commands)\n            {\n                int a = cmd[0];\n                if (a == 1)\n                {\n                    int i = cmd[1];\n                    int x = cmd[2];\n                    SetBulb(bulbs, i, x);\n                }\n                else if (a == 2)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    ToggleBulbs(bulbs, l, r);\n                }\n                else if (a == 3)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    TurnOffBulbs(bulbs, l, r);\n                }\n                else if (a == 4)\n                {\n                    int l = cmd[1];\n                    int r = cmd[2];\n                    TurnOnBulbs(bulbs, l, r);\n                }\n            }\n\n            return bulbs;\n        }\n    }\n}\n\nnamespace BulbController\n{\n    class TestBulbUtils\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            int n1 = 8;\n            int m1 = 3;\n            int[] initialBulbs1 = { 0, 0, 0, 0, 0, 0, 0, 0 };\n            int[][] commands1 = new int[][]\n            {\n                new int[] { 1, 2, 1 },\n                new int[] { 1, 4, 1 },\n                new int[] { 2, 2, 4 }\n            };\n            int[] expected1 = { 0, 0, 1, 0, 0, 0, 0, 0 };\n            int[] result1 = BulbUtils.ProcessCommands(n1, m1, initialBulbs1, commands1);\n            Debug.Assert(CompareArrays(result1, expected1), \"Test Case 1 failed\");\n\n            // Test Case 2\n            int n2 = 5;\n            int m2 = 1;\n            int[] initialBulbs2 = { 1, 0, 1, 0, 1 };\n            int[][] commands2 = new int[][]\n            {\n                new int[] { 2, 1, 5 }\n            };\n            int[] expected2 = { 0, 1, 0, 1, 0 };\n            int[] result2 = BulbUtils.ProcessCommands(n2, m2, initialBulbs2, commands2);\n            Debug.Assert(CompareArrays(result2, expected2), \"Test Case 2 failed\");\n\n            // Test Case 3\n            int n3 = 6;\n            int m3 = 2;\n            int[] initialBulbs3 = { 1, 1, 1, 1, 1, 1 };\n            int[][] commands3 = new int[][]\n            {\n                new int[] { 3, 2, 5 },\n                new int[] { 4, 1, 3 }\n            };\n            int[] expected3 = { 1, 1, 1, 0, 0, 1 };\n            int[] result3 = BulbUtils.ProcessCommands(n3, m3, initialBulbs3, commands3);\n            Debug.Assert(CompareArrays(result3, expected3), \"Test Case 3 failed\");\n        }\n\n        private static bool CompareArrays(int[] a, int[] b)\n        {\n            if (a.Length != b.Length) return false;\n            for (int i = 0; i < a.Length; i++)\n            {\n                if (a[i] != b[i]) return false;\n            }\n            return true;\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MinimumSumCalculator\n{\n    class Program\n    {\n        // CalculateMinimumSum computes the minimum possible sum of the elements of the array\n        // after reversing exactly one segment. Since reversing a segment does not change the total sum,\n        // the result is always the sum of the initial array.\n        public static int CalculateMinimumSum(int n, int[] arr)\n        {\n            int sum = 0;\n            for (int i = 0; i < n; i++)\n            {\n                sum += arr[i];\n            }\n            return sum;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Array: [1, 2, 3, 4]\nMinimum Sum: 10\n\nInput Array: [5, 6, 7, 0, 1]\nMinimum Sum: 19\n\nInput Array: [0, 0, 0]\nMinimum Sum: 0\n\nInput Array: [10]\nMinimum Sum: 10", "task_id": 2922, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MinimumSumCalculator\n{\n    class TestMinimumSumCalculator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateMinimumSum(4, new int[] { 1, 2, 3, 4 }) == 10);\n            Debug.Assert(Program.CalculateMinimumSum(5, new int[] { 5, 6, 7, 0, 1 }) == 19);\n            Debug.Assert(Program.CalculateMinimumSum(3, new int[] { 0, 0, 0 }) == 0);\n            Debug.Assert(Program.CalculateMinimumSum(1, new int[] { 10 }) == 10);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MinimumSumCalculator\n{\n    class Program\n    {\n        // CalculateMinimumSum computes the minimum possible sum of the elements of the array\n        // after reversing exactly one segment. Since reversing a segment does not change the total sum,\n        // the result is always the sum of the initial array.\n        public static int CalculateMinimumSum(int n, int[] arr)\n        {\n            int sum = 0;\n            for (int i = 0; i < n; i++)\n            {\n                sum += arr[i];\n            }\n            return sum;\n        }\n    }\n}\n\nnamespace MinimumSumCalculator\n{\n    class TestMinimumSumCalculator\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateMinimumSum(4, new int[] { 1, 2, 3, 4 }) == 10);\n            Debug.Assert(Program.CalculateMinimumSum(5, new int[] { 5, 6, 7, 0, 1 }) == 19);\n            Debug.Assert(Program.CalculateMinimumSum(3, new int[] { 0, 0, 0 }) == 0);\n            Debug.Assert(Program.CalculateMinimumSum(1, new int[] { 10 }) == 10);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace ArraySortChecker\n{\n    class Program\n    {\n        // CheckSortPossible checks if the given array can be sorted by swapping adjacent elements\n        // only if their sum is less than or equal to a given threshold X.\n        // Returns \"YES\" if it's possible to sort the array under the given conditions, otherwise \"NO\".\n        public static string CheckSortPossible(int[] A, int X)\n        {\n            // Check if the array is already sorted\n            if (A.SequenceEqual(A.OrderBy(x => x)))\n            {\n                return \"YES\";\n            }\n\n            // Check each adjacent pair where current element is greater than the next\n            for (int i = 0; i < A.Length - 1; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    if (A[i] + A[i + 1] > X)\n                    {\n                        return \"NO\";\n                    }\n                }\n            }\n\n            return \"YES\";\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Array: [1, 2, 3, 4], X: 5\nResult: YES\nInput Array: [3, 2, 1], X: 5\nResult: YES\nInput Array: [5, 4, 3], X: 6\nResult: NO\nInput Array: [1], X: 0\nResult: YES", "task_id": 22793, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ArraySortChecker\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Already sorted array\n            int[] testCase1 = { 1, 2, 3, 4 };\n            int X1 = 5;\n            Debug.Assert(Program.CheckSortPossible(testCase1, X1) == \"YES\");\n\n            // Test case 2: Can be sorted by swapping adjacent elements with sum <= X\n            int[] testCase2 = { 3, 2, 1 };\n            int X2 = 5;\n            Debug.Assert(Program.CheckSortPossible(testCase2, X2) == \"YES\");\n\n            // Test case 3: Cannot be sorted because sum of adjacent elements > X\n            int[] testCase3 = { 5, 4, 3 };\n            int X3 = 6;\n            Debug.Assert(Program.CheckSortPossible(testCase3, X3) == \"NO\");\n\n            // Test case 4: Single element array (always sorted)\n            int[] testCase4 = { 1 };\n            int X4 = 0;\n            Debug.Assert(Program.CheckSortPossible(testCase4, X4) == \"YES\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace ArraySortChecker\n{\n    class Program\n    {\n        // CheckSortPossible checks if the given array can be sorted by swapping adjacent elements\n        // only if their sum is less than or equal to a given threshold X.\n        // Returns \"YES\" if it's possible to sort the array under the given conditions, otherwise \"NO\".\n        public static string CheckSortPossible(int[] A, int X)\n        {\n            // Check if the array is already sorted\n            if (A.SequenceEqual(A.OrderBy(x => x)))\n            {\n                return \"YES\";\n            }\n\n            // Check each adjacent pair where current element is greater than the next\n            for (int i = 0; i < A.Length - 1; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    if (A[i] + A[i + 1] > X)\n                    {\n                        return \"NO\";\n                    }\n                }\n            }\n\n            return \"YES\";\n        }\n    }\n}\n\nnamespace ArraySortChecker\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Already sorted array\n            int[] testCase1 = { 1, 2, 3, 4 };\n            int X1 = 5;\n            Debug.Assert(Program.CheckSortPossible(testCase1, X1) == \"YES\");\n\n            // Test case 2: Can be sorted by swapping adjacent elements with sum <= X\n            int[] testCase2 = { 3, 2, 1 };\n            int X2 = 5;\n            Debug.Assert(Program.CheckSortPossible(testCase2, X2) == \"YES\");\n\n            // Test case 3: Cannot be sorted because sum of adjacent elements > X\n            int[] testCase3 = { 5, 4, 3 };\n            int X3 = 6;\n            Debug.Assert(Program.CheckSortPossible(testCase3, X3) == \"NO\");\n\n            // Test case 4: Single element array (always sorted)\n            int[] testCase4 = { 1 };\n            int X4 = 0;\n            Debug.Assert(Program.CheckSortPossible(testCase4, X4) == \"YES\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace SumCalculator\n{\n    class Program\n    {\n        // SumOfNumbers calculates the sum of all numbers from 1 to n using a loop.\n        // If the input n is less than 1, it returns 0.\n        public static int SumOfNumbers(int n)\n        {\n            if (n < 1)\n            {\n                return 0;\n            }\n\n            int total = 0;\n            for (int number = 1; number <= n; number++)\n            {\n                total += number;\n            }\n            return total;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: 5\nSum: 15\nInput: 10\nSum: 55\nInput: 0\nSum: 0\nInput: -3\nSum: 0\nInput: 1\nSum: 1", "task_id": 5098, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace SumCalculator\n{\n    class TestSumCalculator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.SumOfNumbers(5) == 15);\n            Debug.Assert(Program.SumOfNumbers(10) == 55);\n            Debug.Assert(Program.SumOfNumbers(0) == 0);\n            Debug.Assert(Program.SumOfNumbers(-3) == 0);\n            Debug.Assert(Program.SumOfNumbers(1) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace SumCalculator\n{\n    class Program\n    {\n        // SumOfNumbers calculates the sum of all numbers from 1 to n using a loop.\n        // If the input n is less than 1, it returns 0.\n        public static int SumOfNumbers(int n)\n        {\n            if (n < 1)\n            {\n                return 0;\n            }\n\n            int total = 0;\n            for (int number = 1; number <= n; number++)\n            {\n                total += number;\n            }\n            return total;\n        }\n    }\n}\n\nnamespace SumCalculator\n{\n    class TestSumCalculator\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.SumOfNumbers(5) == 15);\n            Debug.Assert(Program.SumOfNumbers(10) == 55);\n            Debug.Assert(Program.SumOfNumbers(0) == 0);\n            Debug.Assert(Program.SumOfNumbers(-3) == 0);\n            Debug.Assert(Program.SumOfNumbers(1) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace StringSequenceChecker\n{\n    class StringSequenceChecker\n    {\n        // CheckSequence checks if the string H contains the required sequence of characters\n        // derived from string J. For each character in J, the corresponding required character\n        // in H is calculated as (25 - (J_char - 'A')) + 'A'.\n        // The method returns \"Yes\" if all required characters are found in order in H, otherwise \"No\".\n        public static string CheckSequence(string H, string J)\n        {\n            int m = J.Length;\n            int n = H.Length;\n            if (m > n)\n            {\n                return \"No\";\n            }\n\n            int jPtr = 0;\n            int targetLen = m;\n            foreach (char hChar in H)\n            {\n                if (jPtr >= targetLen)\n                {\n                    break;\n                }\n                char currentJChar = J[jPtr];\n                // Calculate the required character in H\n                int requiredVal = 25 - (currentJChar - 'A');\n                char requiredChar = (char)(requiredVal + 'A');\n                if (hChar == requiredChar)\n                {\n                    jPtr++;\n                }\n            }\n            return jPtr == targetLen ? \"Yes\" : \"No\";\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: H = ABCDEF, J = XYZ\nResult: No\nInput: H = ZYXWVU, J = ABC\nResult: Yes\nInput: H = ZYXWVU, J = ABD\nResult: Yes\nInput: H = ABCDEF, J = A\nResult: No\nInput: H = ZYXWVU, J = \nResult: Yes\nInput: H = , J = ABC\nResult: No\n\nTesting termination condition (0 0):\nInput: H = 0, J = 0\nTerminating...", "task_id": 15777, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StringSequenceChecker\n{\n    class TestStringSequenceChecker\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ABCDEF\", \"XYZ\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"ABC\") == \"Yes\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"ABD\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ABCDEF\", \"A\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"\") == \"Yes\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"\", \"ABC\") == \"No\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace StringSequenceChecker\n{\n    class StringSequenceChecker\n    {\n        // CheckSequence checks if the string H contains the required sequence of characters\n        // derived from string J. For each character in J, the corresponding required character\n        // in H is calculated as (25 - (J_char - 'A')) + 'A'.\n        // The method returns \"Yes\" if all required characters are found in order in H, otherwise \"No\".\n        public static string CheckSequence(string H, string J)\n        {\n            int m = J.Length;\n            int n = H.Length;\n            if (m > n)\n            {\n                return \"No\";\n            }\n\n            int jPtr = 0;\n            int targetLen = m;\n            foreach (char hChar in H)\n            {\n                if (jPtr >= targetLen)\n                {\n                    break;\n                }\n                char currentJChar = J[jPtr];\n                // Calculate the required character in H\n                int requiredVal = 25 - (currentJChar - 'A');\n                char requiredChar = (char)(requiredVal + 'A');\n                if (hChar == requiredChar)\n                {\n                    jPtr++;\n                }\n            }\n            return jPtr == targetLen ? \"Yes\" : \"No\";\n        }\n    }\n}\n\nnamespace StringSequenceChecker\n{\n    class TestStringSequenceChecker\n    {\n        public static void Main()\n        {\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ABCDEF\", \"XYZ\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"ABC\") == \"Yes\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"ABD\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ABCDEF\", \"A\") == \"No\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"ZYXWVU\", \"\") == \"Yes\");\n            Debug.Assert(StringSequenceChecker.CheckSequence(\"\", \"ABC\") == \"No\");\n        }\n    }\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "using System;\n\nnamespace QuantumStatistics\n{\n    public class QuantumDistributions\n    {\n        // FermiDiracDistribution calculates the Fermi-Dirac distribution for a given set of energies, temperature, and chemical potential.\n        // The Fermi-Dirac distribution describes the probability that a quantum state at a given energy is occupied by a fermion.\n        public static double[] FermiDiracDistribution(double[] energies, double T, double mu)\n        {\n            // Boltzmann constant in eV/K\n            const double k_b = 8.617333262145e-5;\n\n            double[] fdDistribution = new double[energies.Length];\n            for (int i = 0; i < energies.Length; i++)\n            {\n                double exponent = (energies[i] - mu) / (k_b * T);\n                fdDistribution[i] = 1.0 / (1.0 + Math.Exp(exponent));\n            }\n            return fdDistribution;\n        }\n\n        // BoseEinsteinDistribution calculates the Bose-Einstein distribution for a given set of energies, temperature, and chemical potential.\n        // The Bose-Einstein distribution describes the probability that a quantum state at a given energy is occupied by a boson.\n        public static double[] BoseEinsteinDistribution(double[] energies, double T, double mu)\n        {\n            // Boltzmann constant in eV/K\n            const double k_b = 8.617333262145e-5;\n\n            double[] beDistribution = new double[energies.Length];\n            for (int i = 0; i < energies.Length; i++)\n            {\n                double exponent = (energies[i] - mu) / (k_b * T);\n                beDistribution[i] = 1.0 / (Math.Exp(exponent) - 1.0);\n            }\n            return beDistribution;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Testing Fermi-Dirac Distribution:\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 0\nResult: [0.020468792122412812, 3.984462000758095E-09, 1.587593756199934E-17, 6.325707019423987E-26, 2.5204539347250155E-34]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 0.5\nResult: [0.9999998093241592, 0.5, 3.984462000758095E-09, 1.587593756199934E-17, 6.325707019423987E-26]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 1\nResult: [0.9999999999999993, 0.9999999960155379, 0.5, 3.984462000758095E-09, 1.587593756199934E-17]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 500, mu: 0\nResult: [0.08940646531342888, 9.124684391959913E-06, 8.326138470672717E-11, 7.597407899446259E-16, 6.932458184436032E-21]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 500, mu: 0.5\nResult: [0.9999070740322503, 0.5, 9.124684391959913E-06, 8.326138470672717E-11, 7.597407899446259E-16]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 500, mu: 1\nResult: [0.9999999991519932, 0.999990875315608, 0.5, 9.124684391959913E-06, 8.326138470672717E-11]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 1000, mu: 0\nResult: [0.23858519822727708, 0.0030116257474686542, 9.124684391959913E-06, 2.756339507503667E-08, 8.326138470672717E-11]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 1000, mu: 0.5\nResult: [0.9904517877153993, 0.5, 0.0030116257474686542, 9.124684391959913E-06, 2.756339507503667E-08]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 1000, mu: 1\nResult: [0.9999708802939616, 0.9969883742525313, 0.5, 0.0030116257474686542, 9.124684391959913E-06]\n\nTesting Bose-Einstein Distribution:\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 0\nResult: [0.02134250262147485, 3.98446203250997E-09, 1.587593756199934E-17, 6.325707019423987E-26, 2.5204539347250155E-34]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 0.5\nResult: [-1.0000001906759135, Infinity, 3.98446203250997E-09, 1.587593756199934E-17, 6.325707019423987E-26]\nInput - Energies: [0.1, 0.5, 1, 1.5, 2], T: 300, mu: 1\nResult: [-1.0000000000000009, -1.000000003984462, Infinity, 3.98446203250997E-09, 1.587593756199934E-17]\nInput - Energies: [0.1, 0.5,", "task_id": 11950, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace QuantumStatistics\n{\n    class TestQuantumDistributions\n    {\n        public static void RunTests()\n        {\n            double[] energies = { 0.1, 0.5, 1.0, 1.5, 2.0 };\n            \n            // Test Fermi-Dirac distribution\n            double[] fdResult1 = QuantumDistributions.FermiDiracDistribution(energies, 300, 0);\n            Debug.Assert(Math.Abs(fdResult1[0] - 0.020468792122412812) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult1[1] - 3.984462000758095E-09) < 1e-15);\n            \n            double[] fdResult2 = QuantumDistributions.FermiDiracDistribution(energies, 300, 0.5);\n            Debug.Assert(Math.Abs(fdResult2[0] - 0.9999998093241592) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult2[2] - 3.984462000758095E-09) < 1e-15);\n            \n            double[] fdResult3 = QuantumDistributions.FermiDiracDistribution(energies, 1000, 1);\n            Debug.Assert(Math.Abs(fdResult3[0] - 0.9999708802939616) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult3[3] - 0.0030116257474686542) < 1e-15);\n\n            // Test Bose-Einstein distribution\n            double[] beResult1 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 0);\n            Debug.Assert(Math.Abs(beResult1[0] - 0.02134250262147485) < 1e-15);\n            Debug.Assert(Math.Abs(beResult1[1] - 3.98446203250997E-09) < 1e-15);\n            \n            double[] beResult2 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 0.5);\n            Debug.Assert(double.IsInfinity(beResult2[1]));\n            Debug.Assert(Math.Abs(beResult2[2] - 3.98446203250997E-09) < 1e-15);\n            \n            double[] beResult3 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 1);\n            Debug.Assert(double.IsInfinity(beResult3[2]));\n            Debug.Assert(Math.Abs(beResult3[3] - 3.98446203250997E-09) < 1e-15);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace QuantumStatistics\n{\n    public class QuantumDistributions\n    {\n        // FermiDiracDistribution calculates the Fermi-Dirac distribution for a given set of energies, temperature, and chemical potential.\n        // The Fermi-Dirac distribution describes the probability that a quantum state at a given energy is occupied by a fermion.\n        public static double[] FermiDiracDistribution(double[] energies, double T, double mu)\n        {\n            // Boltzmann constant in eV/K\n            const double k_b = 8.617333262145e-5;\n\n            double[] fdDistribution = new double[energies.Length];\n            for (int i = 0; i < energies.Length; i++)\n            {\n                double exponent = (energies[i] - mu) / (k_b * T);\n                fdDistribution[i] = 1.0 / (1.0 + Math.Exp(exponent));\n            }\n            return fdDistribution;\n        }\n\n        // BoseEinsteinDistribution calculates the Bose-Einstein distribution for a given set of energies, temperature, and chemical potential.\n        // The Bose-Einstein distribution describes the probability that a quantum state at a given energy is occupied by a boson.\n        public static double[] BoseEinsteinDistribution(double[] energies, double T, double mu)\n        {\n            // Boltzmann constant in eV/K\n            const double k_b = 8.617333262145e-5;\n\n            double[] beDistribution = new double[energies.Length];\n            for (int i = 0; i < energies.Length; i++)\n            {\n                double exponent = (energies[i] - mu) / (k_b * T);\n                beDistribution[i] = 1.0 / (Math.Exp(exponent) - 1.0);\n            }\n            return beDistribution;\n        }\n    }\n}\n\nnamespace QuantumStatistics\n{\n    class TestQuantumDistributions\n    {\n        public static void Main()\n        {\n            double[] energies = { 0.1, 0.5, 1.0, 1.5, 2.0 };\n            \n            // Test Fermi-Dirac distribution\n            double[] fdResult1 = QuantumDistributions.FermiDiracDistribution(energies, 300, 0);\n            Debug.Assert(Math.Abs(fdResult1[0] - 0.020468792122412812) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult1[1] - 3.984462000758095E-09) < 1e-15);\n            \n            double[] fdResult2 = QuantumDistributions.FermiDiracDistribution(energies, 300, 0.5);\n            Debug.Assert(Math.Abs(fdResult2[0] - 0.9999998093241592) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult2[2] - 3.984462000758095E-09) < 1e-15);\n            \n            double[] fdResult3 = QuantumDistributions.FermiDiracDistribution(energies, 1000, 1);\n            Debug.Assert(Math.Abs(fdResult3[0] - 0.9999708802939616) < 1e-15);\n            Debug.Assert(Math.Abs(fdResult3[3] - 0.0030116257474686542) < 1e-15);\n\n            // Test Bose-Einstein distribution\n            double[] beResult1 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 0);\n            Debug.Assert(Math.Abs(beResult1[0] - 0.02134250262147485) < 1e-15);\n            Debug.Assert(Math.Abs(beResult1[1] - 3.98446203250997E-09) < 1e-15);\n            \n            double[] beResult2 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 0.5);\n            Debug.Assert(double.IsInfinity(beResult2[1]));\n            Debug.Assert(Math.Abs(beResult2[2] - 3.98446203250997E-09) < 1e-15);\n            \n            double[] beResult3 = QuantumDistributions.BoseEinsteinDistribution(energies, 300, 1);\n            Debug.Assert(double.IsInfinity(beResult3[2]));\n            Debug.Assert(Math.Abs(beResult3[3] - 3.98446203250997E-09) < 1e-15);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace GameScheduler\n{\n    class Program\n    {\n        // Schedules games to minimize penalties and returns the total profit after penalties\n        // Games are sorted by penalty in descending order, then scheduled as late as possible\n        // within their deadline to maximize available slots for other games.\n        static int CalculateMaxProfit(int m, int n, int[] deadlines, int[] penalties)\n        {\n            // Combine deadlines and penalties into game tuples and sort by penalty (descending)\n            var games = deadlines.Zip(penalties, (t, w) => new { Deadline = t, Penalty = w })\n                               .OrderByDescending(g => g.Penalty)\n                               .ThenBy(g => g.Deadline)\n                               .ToList();\n\n            // Track occupied time slots (1-based index)\n            bool[] occupied = new bool[n + 2];\n            int totalPenalty = 0;\n\n            foreach (var game in games)\n            {\n                bool foundSlot = false;\n                // Try to place the game in the latest possible slot before its deadline\n                for (int slot = game.Deadline; slot >= 1; slot--)\n                {\n                    if (!occupied[slot])\n                    {\n                        occupied[slot] = true;\n                        foundSlot = true;\n                        break;\n                    }\n                }\n\n                // If no slot found, add to penalty\n                if (!foundSlot)\n                {\n                    totalPenalty += game.Penalty;\n                }\n            }\n\n            return m - totalPenalty;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: m=100, n=5, deadlines=[3, 2, 1, 2, 3], penalties=[10, 20, 30, 40, 50]\nResult: 70\n\nTest Case 2:\nInput: m=200, n=3, deadlines=[1, 2, 3], penalties=[10, 20, 30]\nResult: 200\n\nTest Case 3:\nInput: m=150, n=2, deadlines=[1, 1], penalties=[50, 60]\nResult: 100", "task_id": 14141, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace GameScheduler\n{\n    class TestGameScheduler\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: Sample input from original code\n            int m1 = 100;\n            int n1 = 5;\n            int[] deadlines1 = { 3, 2, 1, 2, 3 };\n            int[] penalties1 = { 10, 20, 30, 40, 50 };\n            Debug.Assert(Program.CalculateMaxProfit(m1, n1, deadlines1, penalties1) == 70);\n\n            // Test Case 2: All games can be scheduled\n            int m2 = 200;\n            int n2 = 3;\n            int[] deadlines2 = { 1, 2, 3 };\n            int[] penalties2 = { 10, 20, 30 };\n            Debug.Assert(Program.CalculateMaxProfit(m2, n2, deadlines2, penalties2) == 200);\n\n            // Test Case 3: No games can be scheduled (all will incur penalty)\n            int m3 = 150;\n            int n3 = 2;\n            int[] deadlines3 = { 1, 1 };\n            int[] penalties3 = { 50, 60 };\n            Debug.Assert(Program.CalculateMaxProfit(m3, n3, deadlines3, penalties3) == 100);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace GameScheduler\n{\n    class Program\n    {\n        // Schedules games to minimize penalties and returns the total profit after penalties\n        // Games are sorted by penalty in descending order, then scheduled as late as possible\n        // within their deadline to maximize available slots for other games.\n    public static int CalculateMaxProfit(int m, int n, int[] deadlines, int[] penalties)\n        {\n            // Combine deadlines and penalties into game tuples and sort by penalty (descending)\n            var games = deadlines.Zip(penalties, (t, w) => new { Deadline = t, Penalty = w })\n                               .OrderByDescending(g => g.Penalty)\n                               .ThenBy(g => g.Deadline)\n                               .ToList();\n\n            // Track occupied time slots (1-based index)\n            bool[] occupied = new bool[n + 2];\n            int totalPenalty = 0;\n\n            foreach (var game in games)\n            {\n                bool foundSlot = false;\n                // Try to place the game in the latest possible slot before its deadline\n                for (int slot = game.Deadline; slot >= 1; slot--)\n                {\n                    if (!occupied[slot])\n                    {\n                        occupied[slot] = true;\n                        foundSlot = true;\n                        break;\n                    }\n                }\n\n                // If no slot found, add to penalty\n                if (!foundSlot)\n                {\n                    totalPenalty += game.Penalty;\n                }\n            }\n\n            return m - totalPenalty;\n        }\n    }\n}\n\nnamespace GameScheduler\n{\n    class TestGameScheduler\n    {\n        public static void Main()\n        {\n            // Test Case 1: Sample input from original code\n            int m1 = 100;\n            int n1 = 5;\n            int[] deadlines1 = { 3, 2, 1, 2, 3 };\n            int[] penalties1 = { 10, 20, 30, 40, 50 };\n            Debug.Assert(Program.CalculateMaxProfit(m1, n1, deadlines1, penalties1) == 70);\n\n            // Test Case 2: All games can be scheduled\n            int m2 = 200;\n            int n2 = 3;\n            int[] deadlines2 = { 1, 2, 3 };\n            int[] penalties2 = { 10, 20, 30 };\n            Debug.Assert(Program.CalculateMaxProfit(m2, n2, deadlines2, penalties2) == 200);\n\n            // Test Case 3: No games can be scheduled (all will incur penalty)\n            int m3 = 150;\n            int n3 = 2;\n            int[] deadlines3 = { 1, 1 };\n            int[] penalties3 = { 50, 60 };\n            Debug.Assert(Program.CalculateMaxProfit(m3, n3, deadlines3, penalties3) == 100);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BookStackingProblem\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum total height of books stacked with shelf width constraint.\n        /// </summary>\n        /// <param name=\"n\">Number of books</param>\n        /// <param name=\"W\">Maximum width of a single stack</param>\n        /// <param name=\"books\">List of tuples (width, height) for each book</param>\n        /// <returns>Maximum total height</returns>\n        static int MaxTotalHeight(int n, int W, List<(int Width, int Height)> books)\n        {\n            // Sort books by their heights in descending order\n            books.Sort((x, y) => y.Height.CompareTo(x.Height));\n            \n            // Initialize a list to keep track of the stack heights\n            List<(int CurrentWidth, int CurrentHeight)> stackHeights = new List<(int, int)>();\n            \n            foreach (var book in books)\n            {\n                bool placed = false;\n                // Try to place the book in an existing stack\n                for (int i = 0; i < stackHeights.Count; i++)\n                {\n                    var currentStack = stackHeights[i];\n                    if (currentStack.CurrentWidth + book.Width <= W)\n                    {\n                        stackHeights[i] = (currentStack.CurrentWidth + book.Width, currentStack.CurrentHeight + book.Height);\n                        placed = true;\n                        break;\n                    }\n                }\n                // If the book was not placed in an existing stack, create a new stack\n                if (!placed)\n                {\n                    stackHeights.Add((book.Width, book.Height));\n                }\n            }\n            \n            // The total height is the sum of heights of all stacks\n            int totalHeight = stackHeights.Sum(stack => stack.CurrentHeight);\n            \n            return totalHeight;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n = 3, W = 5, books = [(2, 5), (3, 10), (1, 8)]\nMaximum Total Height: 23\n\nTest Case 2:\nInput: n = 3, W = 5, books = [(1, 3), (2, 4), (1, 5)]\nMaximum Total Height: 12\n\nTest Case 3:\nInput: n = 3, W = 4, books = [(4, 6), (4, 7), (4, 8)]\nMaximum Total Height: 21", "task_id": 2342, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace BookStackingProblem\n{\n    class TestBookStacking\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Basic scenario\n            var books1 = new List<(int Width, int Height)> { (2, 5), (3, 10), (1, 8) };\n            int n1 = 3;\n            int W1 = 5;\n            Debug.Assert(Program.MaxTotalHeight(n1, W1, books1) == 23);\n\n            // Test case 2: All books fit into one stack\n            var books2 = new List<(int Width, int Height)> { (1, 3), (2, 4), (1, 5) };\n            int n2 = 3;\n            int W2 = 5;\n            Debug.Assert(Program.MaxTotalHeight(n2, W2, books2) == 12);\n\n            // Test case 3: Each book needs a separate stack\n            var books3 = new List<(int Width, int Height)> { (4, 6), (4, 7), (4, 8) };\n            int n3 = 3;\n            int W3 = 4;\n            Debug.Assert(Program.MaxTotalHeight(n3, W3, books3) == 21);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace BookStackingProblem\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum total height of books stacked with shelf width constraint.\n        /// </summary>\n        /// <param name=\"n\">Number of books</param>\n        /// <param name=\"W\">Maximum width of a single stack</param>\n        /// <param name=\"books\">List of tuples (width, height) for each book</param>\n        /// <returns>Maximum total height</returns>\n    public static int MaxTotalHeight(int n, int W, List<(int Width, int Height)> books)\n        {\n            // Sort books by their heights in descending order\n            books.Sort((x, y) => y.Height.CompareTo(x.Height));\n            \n            // Initialize a list to keep track of the stack heights\n            List<(int CurrentWidth, int CurrentHeight)> stackHeights = new List<(int, int)>();\n            \n            foreach (var book in books)\n            {\n                bool placed = false;\n                // Try to place the book in an existing stack\n                for (int i = 0; i < stackHeights.Count; i++)\n                {\n                    var currentStack = stackHeights[i];\n                    if (currentStack.CurrentWidth + book.Width <= W)\n                    {\n                        stackHeights[i] = (currentStack.CurrentWidth + book.Width, currentStack.CurrentHeight + book.Height);\n                        placed = true;\n                        break;\n                    }\n                }\n                // If the book was not placed in an existing stack, create a new stack\n                if (!placed)\n                {\n                    stackHeights.Add((book.Width, book.Height));\n                }\n            }\n            \n            // The total height is the sum of heights of all stacks\n            int totalHeight = stackHeights.Sum(stack => stack.CurrentHeight);\n            \n            return totalHeight;\n        }\n    }\n}\n\nnamespace BookStackingProblem\n{\n    class TestBookStacking\n    {\n        public static void Main()\n        {\n            // Test case 1: Basic scenario\n            var books1 = new List<(int Width, int Height)> { (2, 5), (3, 10), (1, 8) };\n            int n1 = 3;\n            int W1 = 5;\n            Debug.Assert(Program.MaxTotalHeight(n1, W1, books1) == 23);\n\n            // Test case 2: All books fit into one stack\n            var books2 = new List<(int Width, int Height)> { (1, 3), (2, 4), (1, 5) };\n            int n2 = 3;\n            int W2 = 5;\n            Debug.Assert(Program.MaxTotalHeight(n2, W2, books2) == 12);\n\n            // Test case 3: Each book needs a separate stack\n            var books3 = new List<(int Width, int Height)> { (4, 6), (4, 7), (4, 8) };\n            int n3 = 3;\n            int W3 = 4;\n            Debug.Assert(Program.MaxTotalHeight(n3, W3, books3) == 21);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace ListChunker\n{\n    class Program\n    {\n        // ChunkList divides a list into sublists (chunks) of a specified size.\n        // If the input list is empty or the chunk size is less than or equal to 0, it returns an empty list of chunks.\n        // Each chunk is represented as an array for consistency and ease of use.\n        public static List<T[]> ChunkList<T>(List<T> lst, int chunkSize)\n        {\n            List<T[]> chunks = new List<T[]>();\n            \n            if (lst == null || lst.Count == 0 || chunkSize <= 0)\n            {\n                return chunks;\n            }\n\n            for (int i = 0; i < lst.Count; i += chunkSize)\n            {\n                int remainingElements = lst.Count - i;\n                int currentChunkSize = Math.Min(chunkSize, remainingElements);\n                T[] chunk = new T[currentChunkSize];\n                Array.Copy(lst.ToArray(), i, chunk, 0, currentChunkSize);\n                chunks.Add(chunk);\n            }\n\n            return chunks;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input List: [1, 2, 3, 4, 5, 6, 7, 8]\nChunk Size: 3\nChunks:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8]\n\nInput List: [a, b, c, d, e]\nChunk Size: 2\nChunks:\n[a, b]\n[c, d]\n[e]\n\nInput List: []\nChunk Size: 3\nChunks:\n\nInput List: [1, 2, 3]\nChunk Size: 5\nChunks:\n[1, 2, 3]", "task_id": 1117, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ListChunker\n{\n    class TestListChunker\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Chunk a list of integers\n            List<int> intList = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8 };\n            var intChunks = Program.ChunkList(intList, 3);\n            Debug.Assert(intChunks.Count == 3);\n            Debug.Assert(intChunks[0].Length == 3 && intChunks[0][0] == 1 && intChunks[0][2] == 3);\n            Debug.Assert(intChunks[1].Length == 3 && intChunks[1][0] == 4 && intChunks[1][2] == 6);\n            Debug.Assert(intChunks[2].Length == 2 && intChunks[2][0] == 7 && intChunks[2][1] == 8);\n\n            // Test case 2: Chunk a list of strings\n            List<string> stringList = new List<string> { \"a\", \"b\", \"c\", \"d\", \"e\" };\n            var stringChunks = Program.ChunkList(stringList, 2);\n            Debug.Assert(stringChunks.Count == 3);\n            Debug.Assert(stringChunks[0].Length == 2 && stringChunks[0][0] == \"a\" && stringChunks[0][1] == \"b\");\n            Debug.Assert(stringChunks[1].Length == 2 && stringChunks[1][0] == \"c\" && stringChunks[1][1] == \"d\");\n            Debug.Assert(stringChunks[2].Length == 1 && stringChunks[2][0] == \"e\");\n\n            // Test case 3: Empty list\n            List<int> emptyList = new List<int>();\n            var emptyChunks = Program.ChunkList(emptyList, 3);\n            Debug.Assert(emptyChunks.Count == 0);\n\n            // Test case 4: Chunk size larger than list size\n            List<int> smallList = new List<int> { 1, 2, 3 };\n            var smallChunks = Program.ChunkList(smallList, 5);\n            Debug.Assert(smallChunks.Count == 1);\n            Debug.Assert(smallChunks[0].Length == 3 && smallChunks[0][0] == 1 && smallChunks[0][2] == 3);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace ListChunker\n{\n    class Program\n    {\n        // ChunkList divides a list into sublists (chunks) of a specified size.\n        // If the input list is empty or the chunk size is less than or equal to 0, it returns an empty list of chunks.\n        // Each chunk is represented as an array for consistency and ease of use.\n        public static List<T[]> ChunkList<T>(List<T> lst, int chunkSize)\n        {\n            List<T[]> chunks = new List<T[]>();\n            \n            if (lst == null || lst.Count == 0 || chunkSize <= 0)\n            {\n                return chunks;\n            }\n\n            for (int i = 0; i < lst.Count; i += chunkSize)\n            {\n                int remainingElements = lst.Count - i;\n                int currentChunkSize = Math.Min(chunkSize, remainingElements);\n                T[] chunk = new T[currentChunkSize];\n                Array.Copy(lst.ToArray(), i, chunk, 0, currentChunkSize);\n                chunks.Add(chunk);\n            }\n\n            return chunks;\n        }\n    }\n}\n\nnamespace ListChunker\n{\n    class TestListChunker\n    {\n        public static void Main()\n        {\n            // Test case 1: Chunk a list of integers\n            List<int> intList = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8 };\n            var intChunks = Program.ChunkList(intList, 3);\n            Debug.Assert(intChunks.Count == 3);\n            Debug.Assert(intChunks[0].Length == 3 && intChunks[0][0] == 1 && intChunks[0][2] == 3);\n            Debug.Assert(intChunks[1].Length == 3 && intChunks[1][0] == 4 && intChunks[1][2] == 6);\n            Debug.Assert(intChunks[2].Length == 2 && intChunks[2][0] == 7 && intChunks[2][1] == 8);\n\n            // Test case 2: Chunk a list of strings\n            List<string> stringList = new List<string> { \"a\", \"b\", \"c\", \"d\", \"e\" };\n            var stringChunks = Program.ChunkList(stringList, 2);\n            Debug.Assert(stringChunks.Count == 3);\n            Debug.Assert(stringChunks[0].Length == 2 && stringChunks[0][0] == \"a\" && stringChunks[0][1] == \"b\");\n            Debug.Assert(stringChunks[1].Length == 2 && stringChunks[1][0] == \"c\" && stringChunks[1][1] == \"d\");\n            Debug.Assert(stringChunks[2].Length == 1 && stringChunks[2][0] == \"e\");\n\n            // Test case 3: Empty list\n            List<int> emptyList = new List<int>();\n            var emptyChunks = Program.ChunkList(emptyList, 3);\n            Debug.Assert(emptyChunks.Count == 0);\n\n            // Test case 4: Chunk size larger than list size\n            List<int> smallList = new List<int> { 1, 2, 3 };\n            var smallChunks = Program.ChunkList(smallList, 5);\n            Debug.Assert(smallChunks.Count == 1);\n            Debug.Assert(smallChunks[0].Length == 3 && smallChunks[0][0] == 1 && smallChunks[0][2] == 3);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace BooleanCircuitEvaluator\n{\n    class BooleanCircuitEvaluator\n    {\n        // Evaluates a boolean circuit expression given variable values and circuit tokens\n        // Returns true if the final result is 'T', false if 'F'\n        public static bool EvaluateBooleanCircuit(int n, string[] inputValues, string[] circuitTokens)\n        {\n            // Create a dictionary to map variables (A, B, etc.) to their boolean values\n            Dictionary<char, bool> valueMap = new Dictionary<char, bool>();\n            for (int i = 0; i < n; i++)\n            {\n                char var = (char)('A' + i);\n                valueMap[var] = (inputValues[i] == \"T\");\n            }\n\n            Stack<bool> stack = new Stack<bool>();\n            foreach (string token in circuitTokens)\n            {\n                if (valueMap.ContainsKey(token[0]))\n                {\n                    // Push variable's value onto stack\n                    stack.Push(valueMap[token[0]]);\n                }\n                else if (token == \"-\")\n                {\n                    // Negation operation\n                    bool a = stack.Pop();\n                    stack.Push(!a);\n                }\n                else\n                {\n                    // Binary operations\n                    bool b = stack.Pop();\n                    bool a = stack.Pop();\n                    switch (token)\n                    {\n                        case \"*\":\n                            stack.Push(a && b); // AND operation\n                            break;\n                        case \"+\":\n                            stack.Push(a || b); // OR operation\n                            break;\n                    }\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nVariables: T, F\nCircuit: A B *\nResult: F\n\nTest Case 2:\nVariables: T, F\nCircuit: A - B +\nResult: F\n\nTest Case 3:\nVariables: T, F, T\nCircuit: A B + C - *\nResult: F\n\nTest Case 4:\nVariables: F\nCircuit: A\nResult: F", "task_id": 88, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BooleanCircuitEvaluator\n{\n    class TestBooleanCircuitEvaluator\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Simple AND operation (A * B) where A=T, B=F\n            int n1 = 2;\n            string[] inputValues1 = { \"T\", \"F\" };\n            string[] circuit1 = { \"A\", \"B\", \"*\" };\n            bool result1 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n1, inputValues1, circuit1);\n            Debug.Assert(result1 == false);\n\n            // Test case 2: OR operation with negation (-A + B) where A=T, B=F\n            int n2 = 2;\n            string[] inputValues2 = { \"T\", \"F\" };\n            string[] circuit2 = { \"A\", \"-\", \"B\", \"+\" };\n            bool result2 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n2, inputValues2, circuit2);\n            Debug.Assert(result2 == false);\n\n            // Test case 3: Complex expression ((A + B) * -C) where A=T, B=F, C=T\n            int n3 = 3;\n            string[] inputValues3 = { \"T\", \"F\", \"T\" };\n            string[] circuit3 = { \"A\", \"B\", \"+\", \"C\", \"-\", \"*\" };\n            bool result3 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n3, inputValues3, circuit3);\n            Debug.Assert(result3 == false);\n\n            // Test case 4: Single variable (A) where A=F\n            int n4 = 1;\n            string[] inputValues4 = { \"F\" };\n            string[] circuit4 = { \"A\" };\n            bool result4 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n4, inputValues4, circuit4);\n            Debug.Assert(result4 == false);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace BooleanCircuitEvaluator\n{\n    class BooleanCircuitEvaluator\n    {\n        // Evaluates a boolean circuit expression given variable values and circuit tokens\n        // Returns true if the final result is 'T', false if 'F'\n        public static bool EvaluateBooleanCircuit(int n, string[] inputValues, string[] circuitTokens)\n        {\n            // Create a dictionary to map variables (A, B, etc.) to their boolean values\n            Dictionary<char, bool> valueMap = new Dictionary<char, bool>();\n            for (int i = 0; i < n; i++)\n            {\n                char var = (char)('A' + i);\n                valueMap[var] = (inputValues[i] == \"T\");\n            }\n\n            Stack<bool> stack = new Stack<bool>();\n            foreach (string token in circuitTokens)\n            {\n                if (valueMap.ContainsKey(token[0]))\n                {\n                    // Push variable's value onto stack\n                    stack.Push(valueMap[token[0]]);\n                }\n                else if (token == \"-\")\n                {\n                    // Negation operation\n                    bool a = stack.Pop();\n                    stack.Push(!a);\n                }\n                else\n                {\n                    // Binary operations\n                    bool b = stack.Pop();\n                    bool a = stack.Pop();\n                    switch (token)\n                    {\n                        case \"*\":\n                            stack.Push(a && b); // AND operation\n                            break;\n                        case \"+\":\n                            stack.Push(a || b); // OR operation\n                            break;\n                    }\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}\n\nnamespace BooleanCircuitEvaluator\n{\n    class TestBooleanCircuitEvaluator\n    {\n        public static void Main()\n        {\n            // Test case 1: Simple AND operation (A * B) where A=T, B=F\n            int n1 = 2;\n            string[] inputValues1 = { \"T\", \"F\" };\n            string[] circuit1 = { \"A\", \"B\", \"*\" };\n            bool result1 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n1, inputValues1, circuit1);\n            Debug.Assert(result1 == false);\n\n            // Test case 2: OR operation with negation (-A + B) where A=T, B=F\n            int n2 = 2;\n            string[] inputValues2 = { \"T\", \"F\" };\n            string[] circuit2 = { \"A\", \"-\", \"B\", \"+\" };\n            bool result2 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n2, inputValues2, circuit2);\n            Debug.Assert(result2 == false);\n\n            // Test case 3: Complex expression ((A + B) * -C) where A=T, B=F, C=T\n            int n3 = 3;\n            string[] inputValues3 = { \"T\", \"F\", \"T\" };\n            string[] circuit3 = { \"A\", \"B\", \"+\", \"C\", \"-\", \"*\" };\n            bool result3 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n3, inputValues3, circuit3);\n            Debug.Assert(result3 == false);\n\n            // Test case 4: Single variable (A) where A=F\n            int n4 = 1;\n            string[] inputValues4 = { \"F\" };\n            string[] circuit4 = { \"A\" };\n            bool result4 = BooleanCircuitEvaluator.EvaluateBooleanCircuit(n4, inputValues4, circuit4);\n            Debug.Assert(result4 == false);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace ChargeProcessor\n{\n    class ChargeCalculator\n    {\n        // Processes the operations and calculates the charges for each entity.\n        // Parameters:\n        //   m: The number of charges/entities to track.\n        //   operations: An array of tuples where each tuple represents an operation (p, c).\n        // Returns:\n        //   An array of integers representing the total charge for each entity (indices 1 to m).\n        public static int[] CalculateCharges(int m, (int p, int c)[] operations)\n        {\n            int?[] currentIn = new int?[m + 1]; // Using nullable int to represent None (null in C#)\n            int[] charges = new int[m + 1];     // Indices 1 to m are used\n\n            foreach (var operation in operations)\n            {\n                int p = operation.p;\n                int c = operation.c;\n\n                if (currentIn[c] == null)\n                {\n                    currentIn[c] = p;\n                }\n                else\n                {\n                    int prevP = currentIn[c].Value;\n                    if (prevP == p)\n                    {\n                        charges[c] += 100;\n                    }\n                    else\n                    {\n                        charges[c] += Math.Abs(p - prevP);\n                    }\n                    currentIn[c] = null;\n                }\n            }\n\n            // Check for any remaining non-null currentIn entries\n            for (int c = 1; c <= m; c++)\n            {\n                if (currentIn[c] != null)\n                {\n                    charges[c] += 100;\n                }\n            }\n\n            // Extract charges from index 1 to m\n            int[] result = new int[m];\n            Array.Copy(charges, 1, result, 0, m);\n            return result;\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/f536094a3e8846349391d4224da3425e/MyProject/Program.cs(29,33): warning CS8629: Nullable value type may be null. [/data/codes/c#/f536094a3e8846349391d4224da3425e/MyProject/MyProject.csproj]\nTest Case 1:\nOperations: (10,1), (15,1), (20,2), (20,2), (30,3)\nCharges: 5, 100, 100\n\nTest Case 2:\nOperations: None\nCharges: 0, 0\n\nTest Case 3:\nOperations: (5,1), (5,1), (10,1), (10,1)\nCharges: 200", "task_id": 13197, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ChargeProcessor\n{\n    class TestChargeCalculator\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: Example from the Python code's logic\n            (int p, int c)[] operations1 = new (int p, int c)[]\n            {\n                (10, 1),\n                (15, 1),\n                (20, 2),\n                (20, 2),\n                (30, 3)\n            };\n            int[] result1 = ChargeCalculator.CalculateCharges(3, operations1);\n            Debug.Assert(result1[0] == 5);\n            Debug.Assert(result1[1] == 100);\n            Debug.Assert(result1[2] == 100);\n\n            // Test Case 2: No operations, m = 2\n            (int p, int c)[] operations2 = Array.Empty<(int p, int c)>();\n            int[] result2 = ChargeCalculator.CalculateCharges(2, operations2);\n            Debug.Assert(result2[0] == 0);\n            Debug.Assert(result2[1] == 0);\n\n            // Test Case 3: All operations for the same charge\n            (int p, int c)[] operations3 = new (int p, int c)[]\n            {\n                (5, 1),\n                (5, 1),\n                (10, 1),\n                (10, 1)\n            };\n            int[] result3 = ChargeCalculator.CalculateCharges(1, operations3);\n            Debug.Assert(result3[0] == 200);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace ChargeProcessor\n{\n    class ChargeCalculator\n    {\n        // Processes the operations and calculates the charges for each entity.\n        // Parameters:\n        //   m: The number of charges/entities to track.\n        //   operations: An array of tuples where each tuple represents an operation (p, c).\n        // Returns:\n        //   An array of integers representing the total charge for each entity (indices 1 to m).\n        public static int[] CalculateCharges(int m, (int p, int c)[] operations)\n        {\n            int?[] currentIn = new int?[m + 1]; // Using nullable int to represent None (null in C#)\n            int[] charges = new int[m + 1];     // Indices 1 to m are used\n\n            foreach (var operation in operations)\n            {\n                int p = operation.p;\n                int c = operation.c;\n\n                if (currentIn[c] == null)\n                {\n                    currentIn[c] = p;\n                }\n                else\n                {\n                    int prevP = currentIn[c].Value;\n                    if (prevP == p)\n                    {\n                        charges[c] += 100;\n                    }\n                    else\n                    {\n                        charges[c] += Math.Abs(p - prevP);\n                    }\n                    currentIn[c] = null;\n                }\n            }\n\n            // Check for any remaining non-null currentIn entries\n            for (int c = 1; c <= m; c++)\n            {\n                if (currentIn[c] != null)\n                {\n                    charges[c] += 100;\n                }\n            }\n\n            // Extract charges from index 1 to m\n            int[] result = new int[m];\n            Array.Copy(charges, 1, result, 0, m);\n            return result;\n        }\n    }\n}\n\nnamespace ChargeProcessor\n{\n    class TestChargeCalculator\n    {\n        public static void Main()\n        {\n            // Test Case 1: Example from the Python code's logic\n            (int p, int c)[] operations1 = new (int p, int c)[]\n            {\n                (10, 1),\n                (15, 1),\n                (20, 2),\n                (20, 2),\n                (30, 3)\n            };\n            int[] result1 = ChargeCalculator.CalculateCharges(3, operations1);\n            Debug.Assert(result1[0] == 5);\n            Debug.Assert(result1[1] == 100);\n            Debug.Assert(result1[2] == 100);\n\n            // Test Case 2: No operations, m = 2\n            (int p, int c)[] operations2 = Array.Empty<(int p, int c)>();\n            int[] result2 = ChargeCalculator.CalculateCharges(2, operations2);\n            Debug.Assert(result2[0] == 0);\n            Debug.Assert(result2[1] == 0);\n\n            // Test Case 3: All operations for the same charge\n            (int p, int c)[] operations3 = new (int p, int c)[]\n            {\n                (5, 1),\n                (5, 1),\n                (10, 1),\n                (10, 1)\n            };\n            int[] result3 = ChargeCalculator.CalculateCharges(1, operations3);\n            Debug.Assert(result3[0] == 200);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MinimalSplitCost\n{\n    class Program\n    {\n        // CalculateMinimalSplitCost computes the minimal cost to split an array into 'k' parts,\n        // where the cost of each part is defined as the maximum element in that part multiplied by its length.\n        // The method uses dynamic programming to build a solution incrementally.\n        static int CalculateMinimalSplitCost(int[] a, int k)\n        {\n            int n = a.Length;\n            const int INF = int.MaxValue;\n            int[,] dp = new int[n + 1, k + 1];\n\n            // Initialize DP table with infinity\n            for (int i = 0; i <= n; i++)\n            {\n                for (int j = 0; j <= k; j++)\n                {\n                    dp[i, j] = INF;\n                }\n            }\n            dp[0, 0] = 0;\n\n            for (int j = 1; j <= k; j++)\n            {\n                for (int i = j; i <= n; i++)\n                {\n                    int minCandidate = INF;\n                    int currentMax = 0;\n\n                    // Iterate from the end of the current segment to the start to find the optimal split\n                    for (int m = i - 1; m >= j - 1; m--)\n                    {\n                        currentMax = Math.Max(currentMax, a[m]);\n                        int segmentCost = (i - m) * currentMax;\n                        if (dp[m, j - 1] != INF && dp[m, j - 1] + segmentCost < minCandidate)\n                        {\n                            minCandidate = dp[m, j - 1] + segmentCost;\n                        }\n                    }\n                    dp[i, j] = minCandidate;\n                }\n            }\n\n            return dp[n, k];\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Array: [1, 2, 3, 4], K: 2\nMinimal Split Cost: 12\nInput Array: [5, 6, 7, 0], K: 3\nMinimal Split Cost: 19\nInput Array: [0, 0, 0, 0], K: 1\nMinimal Split Cost: 0", "task_id": 17902, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MinimalSplitCost\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 1, 2, 3, 4 }, 2) == 12);\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 5, 6, 7, 0 }, 3) == 19);\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 0, 0, 0, 0 }, 1) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MinimalSplitCost\n{\n    class Program\n    {\n        // CalculateMinimalSplitCost computes the minimal cost to split an array into 'k' parts,\n        // where the cost of each part is defined as the maximum element in that part multiplied by its length.\n        // The method uses dynamic programming to build a solution incrementally.\n    public static int CalculateMinimalSplitCost(int[] a, int k)\n        {\n            int n = a.Length;\n            const int INF = int.MaxValue;\n            int[,] dp = new int[n + 1, k + 1];\n\n            // Initialize DP table with infinity\n            for (int i = 0; i <= n; i++)\n            {\n                for (int j = 0; j <= k; j++)\n                {\n                    dp[i, j] = INF;\n                }\n            }\n            dp[0, 0] = 0;\n\n            for (int j = 1; j <= k; j++)\n            {\n                for (int i = j; i <= n; i++)\n                {\n                    int minCandidate = INF;\n                    int currentMax = 0;\n\n                    // Iterate from the end of the current segment to the start to find the optimal split\n                    for (int m = i - 1; m >= j - 1; m--)\n                    {\n                        currentMax = Math.Max(currentMax, a[m]);\n                        int segmentCost = (i - m) * currentMax;\n                        if (dp[m, j - 1] != INF && dp[m, j - 1] + segmentCost < minCandidate)\n                        {\n                            minCandidate = dp[m, j - 1] + segmentCost;\n                        }\n                    }\n                    dp[i, j] = minCandidate;\n                }\n            }\n\n            return dp[n, k];\n        }\n    }\n}\n\nnamespace MinimalSplitCost\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 1, 2, 3, 4 }, 2) == 12);\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 5, 6, 7, 0 }, 3) == 19);\n            Debug.Assert(Program.CalculateMinimalSplitCost(new int[] { 0, 0, 0, 0 }, 1) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace TrackBallPositionFinder\n{\n    class PositionFinder\n    {\n        // CalculateFinalPositions computes the final positions of balls after time 't' based on their initial positions and velocities.\n        // It then sorts these positions and finds the rank of a specific tracked ball.\n        public static int FindTrackedBallPosition(int[] positions, int[] velocities, int trackedBallIndex, int time)\n        {\n            int n = positions.Length;\n            var finalPositions = new int[n];\n\n            // Calculate final positions for each ball\n            for (int i = 0; i < n; i++)\n            {\n                finalPositions[i] = positions[i] + velocities[i] * time;\n            }\n\n            // Create an array of tuples containing final positions and original indices\n            var positionIndexPairs = new (int Position, int Index)[n];\n            for (int i = 0; i < n; i++)\n            {\n                positionIndexPairs[i] = (finalPositions[i], i);\n            }\n\n            // Sort the pairs first by position, then by original index\n            var sortedPairs = positionIndexPairs.OrderBy(p => p.Position).ThenBy(p => p.Index).ToArray();\n\n            // Find the position of the tracked ball in the sorted array\n            for (int i = 0; i < n; i++)\n            {\n                if (sortedPairs[i].Index == trackedBallIndex)\n                {\n                    return i + 1; // Return 1-based rank\n                }\n            }\n\n            return -1; // Shouldn't happen if inputs are valid\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nPositions: [1, 2, 3]\nVelocities: [1, 0, -1]\nTracked Ball Index: 1\nTime: 2\nTracked Ball Position Rank: 2\n\nTest Case 2:\nPositions: [0, 5, 10]\nVelocities: [1, 0, -1]\nTracked Ball Index: 2\nTime: 5\nTracked Ball Position Rank: 3\n\nTest Case 3:\nPositions: [100]\nVelocities: [-5]\nTracked Ball Index: 0\nTime: 10\nTracked Ball Position Rank: 1", "task_id": 9894, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace TrackBallPositionFinder\n{\n    class TestPositionFinder\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Simple case with 3 balls\n            int[] positions1 = { 1, 2, 3 };\n            int[] velocities1 = { 1, 0, -1 };\n            int trackedBallIndex1 = 1; // 0-based index\n            int time1 = 2;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions1, velocities1, trackedBallIndex1, time1) == 2);\n\n            // Test case 2: Balls with same final position\n            int[] positions2 = { 0, 5, 10 };\n            int[] velocities2 = { 1, 0, -1 };\n            int trackedBallIndex2 = 2; // 0-based index\n            int time2 = 5;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions2, velocities2, trackedBallIndex2, time2) == 3);\n\n            // Test case 3: Single ball\n            int[] positions3 = { 100 };\n            int[] velocities3 = { -5 };\n            int trackedBallIndex3 = 0; // 0-based index\n            int time3 = 10;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions3, velocities3, trackedBallIndex3, time3) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace TrackBallPositionFinder\n{\n    class PositionFinder\n    {\n        // CalculateFinalPositions computes the final positions of balls after time 't' based on their initial positions and velocities.\n        // It then sorts these positions and finds the rank of a specific tracked ball.\n        public static int FindTrackedBallPosition(int[] positions, int[] velocities, int trackedBallIndex, int time)\n        {\n            int n = positions.Length;\n            var finalPositions = new int[n];\n\n            // Calculate final positions for each ball\n            for (int i = 0; i < n; i++)\n            {\n                finalPositions[i] = positions[i] + velocities[i] * time;\n            }\n\n            // Create an array of tuples containing final positions and original indices\n            var positionIndexPairs = new (int Position, int Index)[n];\n            for (int i = 0; i < n; i++)\n            {\n                positionIndexPairs[i] = (finalPositions[i], i);\n            }\n\n            // Sort the pairs first by position, then by original index\n            var sortedPairs = positionIndexPairs.OrderBy(p => p.Position).ThenBy(p => p.Index).ToArray();\n\n            // Find the position of the tracked ball in the sorted array\n            for (int i = 0; i < n; i++)\n            {\n                if (sortedPairs[i].Index == trackedBallIndex)\n                {\n                    return i + 1; // Return 1-based rank\n                }\n            }\n\n            return -1; // Shouldn't happen if inputs are valid\n        }\n    }\n}\n\nnamespace TrackBallPositionFinder\n{\n    class TestPositionFinder\n    {\n        public static void Main()\n        {\n            // Test case 1: Simple case with 3 balls\n            int[] positions1 = { 1, 2, 3 };\n            int[] velocities1 = { 1, 0, -1 };\n            int trackedBallIndex1 = 1; // 0-based index\n            int time1 = 2;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions1, velocities1, trackedBallIndex1, time1) == 2);\n\n            // Test case 2: Balls with same final position\n            int[] positions2 = { 0, 5, 10 };\n            int[] velocities2 = { 1, 0, -1 };\n            int trackedBallIndex2 = 2; // 0-based index\n            int time2 = 5;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions2, velocities2, trackedBallIndex2, time2) == 3);\n\n            // Test case 3: Single ball\n            int[] positions3 = { 100 };\n            int[] velocities3 = { -5 };\n            int trackedBallIndex3 = 0; // 0-based index\n            int time3 = 10;\n            Debug.Assert(PositionFinder.FindTrackedBallPosition(positions3, velocities3, trackedBallIndex3, time3) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ProcessFrequencyCalculator\n{\n    class Program\n    {\n        // CalculateProcessFrequency calculates the frequency of each process ID,\n        // sorts the IDs, and returns a list of tuples containing each ID, its frequency, and a constant value (1).\n        // The method takes an array of process IDs as input.\n        static List<(int Id, int Frequency, int Constant)> CalculateProcessFrequency(int[] processIds)\n        {\n            Dictionary<int, int> frequencyMap = new Dictionary<int, int>();\n            \n            // Calculate frequency of each process ID\n            foreach (int id in processIds)\n            {\n                if (frequencyMap.ContainsKey(id))\n                {\n                    frequencyMap[id]++;\n                }\n                else\n                {\n                    frequencyMap[id] = 1;\n                }\n            }\n            \n            // Sort the process IDs\n            var sortedIds = frequencyMap.Keys.OrderBy(id => id).ToList();\n            \n            // Prepare the result with each ID, its frequency, and a constant value (1)\n            var result = new List<(int, int, int)>();\n            foreach (var id in sortedIds)\n            {\n                result.Add((id, frequencyMap[id], 1));\n            }\n            \n            return result;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input IDs: 1, 2, 2, 3, 3, 3\nNumber of unique IDs: 3\nID: 1, Frequency: 1, Constant: 1\nID: 2, Frequency: 2, Constant: 1\nID: 3, Frequency: 3, Constant: 1\n\nInput IDs: 5, 5, 5, 5, 5\nNumber of unique IDs: 1\nID: 5, Frequency: 5, Constant: 1\n\nInput IDs: 10, 20, 30, 40, 50\nNumber of unique IDs: 5\nID: 10, Frequency: 1, Constant: 1\nID: 20, Frequency: 1, Constant: 1\nID: 30, Frequency: 1, Constant: 1\nID: 40, Frequency: 1, Constant: 1\nID: 50, Frequency: 1, Constant: 1", "task_id": 1839, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace ProcessFrequencyCalculator\n{\n    class TestProcessFrequency\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var result1 = Program.CalculateProcessFrequency(new int[] { 1, 2, 2, 3, 3, 3 });\n            Debug.Assert(result1.Count == 3);\n            Debug.Assert(result1[0] == (1, 1, 1));\n            Debug.Assert(result1[1] == (2, 2, 1));\n            Debug.Assert(result1[2] == (3, 3, 1));\n\n            // Test case 2\n            var result2 = Program.CalculateProcessFrequency(new int[] { 5, 5, 5, 5, 5 });\n            Debug.Assert(result2.Count == 1);\n            Debug.Assert(result2[0] == (5, 5, 1));\n\n            // Test case 3\n            var result3 = Program.CalculateProcessFrequency(new int[] { 10, 20, 30, 40, 50 });\n            Debug.Assert(result3.Count == 5);\n            Debug.Assert(result3[0] == (10, 1, 1));\n            Debug.Assert(result3[1] == (20, 1, 1));\n            Debug.Assert(result3[2] == (30, 1, 1));\n            Debug.Assert(result3[3] == (40, 1, 1));\n            Debug.Assert(result3[4] == (50, 1, 1));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace ProcessFrequencyCalculator\n{\n    class Program\n    {\n        // CalculateProcessFrequency calculates the frequency of each process ID,\n        // sorts the IDs, and returns a list of tuples containing each ID, its frequency, and a constant value (1).\n        // The method takes an array of process IDs as input.\n    public static List<(int Id, int Frequency, int Constant)> CalculateProcessFrequency(int[] processIds)\n        {\n            Dictionary<int, int> frequencyMap = new Dictionary<int, int>();\n            \n            // Calculate frequency of each process ID\n            foreach (int id in processIds)\n            {\n                if (frequencyMap.ContainsKey(id))\n                {\n                    frequencyMap[id]++;\n                }\n                else\n                {\n                    frequencyMap[id] = 1;\n                }\n            }\n            \n            // Sort the process IDs\n            var sortedIds = frequencyMap.Keys.OrderBy(id => id).ToList();\n            \n            // Prepare the result with each ID, its frequency, and a constant value (1)\n            var result = new List<(int, int, int)>();\n            foreach (var id in sortedIds)\n            {\n                result.Add((id, frequencyMap[id], 1));\n            }\n            \n            return result;\n        }\n    }\n}\n\nnamespace ProcessFrequencyCalculator\n{\n    class TestProcessFrequency\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var result1 = Program.CalculateProcessFrequency(new int[] { 1, 2, 2, 3, 3, 3 });\n            Debug.Assert(result1.Count == 3);\n            Debug.Assert(result1[0] == (1, 1, 1));\n            Debug.Assert(result1[1] == (2, 2, 1));\n            Debug.Assert(result1[2] == (3, 3, 1));\n\n            // Test case 2\n            var result2 = Program.CalculateProcessFrequency(new int[] { 5, 5, 5, 5, 5 });\n            Debug.Assert(result2.Count == 1);\n            Debug.Assert(result2[0] == (5, 5, 1));\n\n            // Test case 3\n            var result3 = Program.CalculateProcessFrequency(new int[] { 10, 20, 30, 40, 50 });\n            Debug.Assert(result3.Count == 5);\n            Debug.Assert(result3[0] == (10, 1, 1));\n            Debug.Assert(result3[1] == (20, 1, 1));\n            Debug.Assert(result3[2] == (30, 1, 1));\n            Debug.Assert(result3[3] == (40, 1, 1));\n            Debug.Assert(result3[4] == (50, 1, 1));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace BitmaskSubsetSum\n{\n    class Program\n    {\n        const int MOD = 1000000007;\n        const int MAX_MASK = 1 << 18;\n\n        // CalculateSubsetSum computes a special sum of subset combinations using bitmask operations\n        // It processes each number in the input array, maintains a state for all possible bitmask subsets,\n        // and accumulates the result based on previous states.\n        static int CalculateSubsetSum(int[] a)\n        {\n            int[] s = new int[MAX_MASK];\n            int ans = 0;\n\n            foreach (int x in a)\n            {\n                // Calculate current contribution\n                int sumPrev = s[x];\n                ans = (ans + sumPrev) % MOD;\n\n                // Generate all subsets and update dp and s\n                int dpX = (sumPrev + 1) % MOD;\n                int sub = x;\n                while (true)\n                {\n                    s[sub] = (s[sub] + dpX) % MOD;\n                    if (sub == 0)\n                    {\n                        break;\n                    }\n                    sub = (sub - 1) & x;\n                }\n            }\n\n            return ans % MOD;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3]\nResult: 0\nInput: [5]\nResult: 0\nInput: [0, 0, 0]\nResult: 4\nInput: [1, 3, 7]\nResult: 0\nInput: [2, 4, 8]\nResult: 0", "task_id": 18000, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BitmaskSubsetSum\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 1, 2, 3 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 5 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 0, 0, 0 }) == 4);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 1, 3, 7 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 2, 4, 8 }) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace BitmaskSubsetSum\n{\n    class Program\n    {\n        const int MOD = 1000000007;\n        const int MAX_MASK = 1 << 18;\n\n        // CalculateSubsetSum computes a special sum of subset combinations using bitmask operations\n        // It processes each number in the input array, maintains a state for all possible bitmask subsets,\n        // and accumulates the result based on previous states.\n    public static int CalculateSubsetSum(int[] a)\n        {\n            int[] s = new int[MAX_MASK];\n            int ans = 0;\n\n            foreach (int x in a)\n            {\n                // Calculate current contribution\n                int sumPrev = s[x];\n                ans = (ans + sumPrev) % MOD;\n\n                // Generate all subsets and update dp and s\n                int dpX = (sumPrev + 1) % MOD;\n                int sub = x;\n                while (true)\n                {\n                    s[sub] = (s[sub] + dpX) % MOD;\n                    if (sub == 0)\n                    {\n                        break;\n                    }\n                    sub = (sub - 1) & x;\n                }\n            }\n\n            return ans % MOD;\n        }\n    }\n}\n\nnamespace BitmaskSubsetSum\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 1, 2, 3 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 5 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 0, 0, 0 }) == 4);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 1, 3, 7 }) == 0);\n            Debug.Assert(Program.CalculateSubsetSum(new int[] { 2, 4, 8 }) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace TextAnalyzer\n{\n    class TextAnalyzer\n    {\n        // Splits the input text into sentences using punctuation marks '.', '!', '?' as delimiters.\n        // Returns a list of sentences with leading and trailing whitespace removed.\n        public static List<string> SplitIntoSentences(string text)\n        {\n            string[] splitSentences = Regex.Split(text, @\"[.!?]\");\n            List<string> sentences = new List<string>();\n            foreach (string sentence in splitSentences)\n            {\n                string trimmedSentence = sentence.Trim();\n                if (!string.IsNullOrEmpty(trimmedSentence))\n                {\n                    sentences.Add(trimmedSentence);\n                }\n            }\n            return sentences;\n        }\n\n        // Counts the frequency of each sentence in the given list of sentences.\n        public static Dictionary<string, int> CountSentenceFrequencies(List<string> sentences)\n        {\n            Dictionary<string, int> sentCounts = new Dictionary<string, int>();\n            foreach (string sentence in sentences)\n            {\n                if (sentCounts.ContainsKey(sentence))\n                {\n                    sentCounts[sentence]++;\n                }\n                else\n                {\n                    sentCounts[sentence] = 1;\n                }\n            }\n            return sentCounts;\n        }\n\n        // Splits all sentences into words and counts the frequency of each word.\n        public static Dictionary<string, int> CountWordFrequencies(List<string> sentences)\n        {\n            Dictionary<string, int> wordCounts = new Dictionary<string, int>();\n            foreach (string sentence in sentences)\n            {\n                string[] words = sentence.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string word in words)\n                {\n                    if (wordCounts.ContainsKey(word))\n                    {\n                        wordCounts[word]++;\n                    }\n                    else\n                    {\n                        wordCounts[word] = 1;\n                    }\n                }\n            }\n            return wordCounts;\n        }\n\n        // Calculates the number of words that appear at least 'n' times.\n        public static int CountWordsWithMinFrequency(Dictionary<string, int> wordCounts, int n)\n        {\n            return wordCounts.Count(kv => kv.Value >= n);\n        }\n\n        // Calculates the number of sentences that appear at least 'm' times.\n        public static int CountSentencesWithMinFrequency(Dictionary<string, int> sentCounts, int m)\n        {\n            return sentCounts.Count(kv => kv.Value >= m);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 2, m = 1, text = \"Hello world. Hello there. How are you? How are you doing?\"\nWords with frequency >= 2: 4, Sentences with frequency >= 1: 4\nInput: n = 1, m = 2, text = \"Repeat. Repeat. Repeat again. Again and again.\"\nWords with frequency >= 1: 4, Sentences with frequency >= 2: 1\nInput: n = 3, m = 1, text = \"One. Two. Three. One. Two. One.\"\nWords with frequency >= 3: 1, Sentences with frequency >= 1: 3", "task_id": 27178, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace TextAnalyzer\n{\n    class TestTextAnalyzer\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            string text1 = \"Hello world. Hello there. How are you? How are you doing?\";\n            List<string> sentences1 = TextAnalyzer.SplitIntoSentences(text1);\n            Dictionary<string, int> sentCounts1 = TextAnalyzer.CountSentenceFrequencies(sentences1);\n            Dictionary<string, int> wordCounts1 = TextAnalyzer.CountWordFrequencies(sentences1);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts1, 2) == 4);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts1, 1) == 4);\n\n            // Test case 2\n            string text2 = \"Repeat. Repeat. Repeat again. Again and again.\";\n            List<string> sentences2 = TextAnalyzer.SplitIntoSentences(text2);\n            Dictionary<string, int> sentCounts2 = TextAnalyzer.CountSentenceFrequencies(sentences2);\n            Dictionary<string, int> wordCounts2 = TextAnalyzer.CountWordFrequencies(sentences2);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts2, 1) == 4);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts2, 2) == 1);\n\n            // Test case 3\n            string text3 = \"One. Two. Three. One. Two. One.\";\n            List<string> sentences3 = TextAnalyzer.SplitIntoSentences(text3);\n            Dictionary<string, int> sentCounts3 = TextAnalyzer.CountSentenceFrequencies(sentences3);\n            Dictionary<string, int> wordCounts3 = TextAnalyzer.CountWordFrequencies(sentences3);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts3, 3) == 1);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts3, 1) == 3);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System;\n\nnamespace TextAnalyzer\n{\n    class TextAnalyzer\n    {\n        // Splits the input text into sentences using punctuation marks '.', '!', '?' as delimiters.\n        // Returns a list of sentences with leading and trailing whitespace removed.\n        public static List<string> SplitIntoSentences(string text)\n        {\n            string[] splitSentences = Regex.Split(text, @\"[.!?]\");\n            List<string> sentences = new List<string>();\n            foreach (string sentence in splitSentences)\n            {\n                string trimmedSentence = sentence.Trim();\n                if (!string.IsNullOrEmpty(trimmedSentence))\n                {\n                    sentences.Add(trimmedSentence);\n                }\n            }\n            return sentences;\n        }\n\n        // Counts the frequency of each sentence in the given list of sentences.\n        public static Dictionary<string, int> CountSentenceFrequencies(List<string> sentences)\n        {\n            Dictionary<string, int> sentCounts = new Dictionary<string, int>();\n            foreach (string sentence in sentences)\n            {\n                if (sentCounts.ContainsKey(sentence))\n                {\n                    sentCounts[sentence]++;\n                }\n                else\n                {\n                    sentCounts[sentence] = 1;\n                }\n            }\n            return sentCounts;\n        }\n\n        // Splits all sentences into words and counts the frequency of each word.\n        public static Dictionary<string, int> CountWordFrequencies(List<string> sentences)\n        {\n            Dictionary<string, int> wordCounts = new Dictionary<string, int>();\n            foreach (string sentence in sentences)\n            {\n                string[] words = sentence.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string word in words)\n                {\n                    if (wordCounts.ContainsKey(word))\n                    {\n                        wordCounts[word]++;\n                    }\n                    else\n                    {\n                        wordCounts[word] = 1;\n                    }\n                }\n            }\n            return wordCounts;\n        }\n\n        // Calculates the number of words that appear at least 'n' times.\n        public static int CountWordsWithMinFrequency(Dictionary<string, int> wordCounts, int n)\n        {\n            return wordCounts.Count(kv => kv.Value >= n);\n        }\n\n        // Calculates the number of sentences that appear at least 'm' times.\n        public static int CountSentencesWithMinFrequency(Dictionary<string, int> sentCounts, int m)\n        {\n            return sentCounts.Count(kv => kv.Value >= m);\n        }\n    }\n}\n\nnamespace TextAnalyzer\n{\n    class TestTextAnalyzer\n    {\n        public static void Main()\n        {\n            // Test case 1\n            string text1 = \"Hello world. Hello there. How are you? How are you doing?\";\n            List<string> sentences1 = TextAnalyzer.SplitIntoSentences(text1);\n            Dictionary<string, int> sentCounts1 = TextAnalyzer.CountSentenceFrequencies(sentences1);\n            Dictionary<string, int> wordCounts1 = TextAnalyzer.CountWordFrequencies(sentences1);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts1, 2) == 4);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts1, 1) == 4);\n\n            // Test case 2\n            string text2 = \"Repeat. Repeat. Repeat again. Again and again.\";\n            List<string> sentences2 = TextAnalyzer.SplitIntoSentences(text2);\n            Dictionary<string, int> sentCounts2 = TextAnalyzer.CountSentenceFrequencies(sentences2);\n            Dictionary<string, int> wordCounts2 = TextAnalyzer.CountWordFrequencies(sentences2);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts2, 1) == 4);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts2, 2) == 1);\n\n            // Test case 3\n            string text3 = \"One. Two. Three. One. Two. One.\";\n            List<string> sentences3 = TextAnalyzer.SplitIntoSentences(text3);\n            Dictionary<string, int> sentCounts3 = TextAnalyzer.CountSentenceFrequencies(sentences3);\n            Dictionary<string, int> wordCounts3 = TextAnalyzer.CountWordFrequencies(sentences3);\n            Debug.Assert(TextAnalyzer.CountWordsWithMinFrequency(wordCounts3, 3) == 1);\n            Debug.Assert(TextAnalyzer.CountSentencesWithMinFrequency(sentCounts3, 1) == 3);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace FrequencyFilter\n{\n    class Program\n    {\n        // Removes elements from an array whose frequency is larger than K.\n        // Uses a dictionary to count the frequency of each element in the array.\n        // Then filters out elements whose frequency exceeds K.\n        static int[] RemoveElementsByFrequency(int[] arr, int K)\n        {\n            if (arr == null || arr.Length == 0)\n            {\n                return new int[0];\n            }\n\n            // Count the frequency of each element in arr\n            Dictionary<int, int> freqCounter = new Dictionary<int, int>();\n            foreach (int num in arr)\n            {\n                if (freqCounter.ContainsKey(num))\n                {\n                    freqCounter[num]++;\n                }\n                else\n                {\n                    freqCounter[num] = 1;\n                }\n            }\n\n            // Filter out the elements whose frequency is greater than K\n            List<int> result = new List<int>();\n            foreach (int num in arr)\n            {\n                if (freqCounter[num] <= K)\n                {\n                    result.Add(num);\n                }\n            }\n\n            return result.ToArray();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Array: [1, 2, 2, 3, 3, 3, 4, 4, 4, 4], K: 2\nFiltered Array: [1, 2, 2]\nInput Array: [5, 5, 5, 5, 5], K: 1\nFiltered Array: []\nInput Array: [1, 1, 2, 2, 3, 3], K: 3\nFiltered Array: [1, 1, 2, 2, 3, 3]\nInput Array: [], K: 2\nFiltered Array: []\nInput Array: [1, 2, 3, 4, 5], K: 0\nFiltered Array: []", "task_id": 28208, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace FrequencyFilter\n{\n    class TestFrequencyFilter\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[] input1 = { 1, 2, 2, 3, 3, 3, 4, 4, 4, 4 };\n            int[] expected1 = { 1, 2, 2 };\n            Debug.Assert(Program.RemoveElementsByFrequency(input1, 2).SequenceEqual(expected1));\n\n            // Test case 2\n            int[] input2 = { 5, 5, 5, 5, 5 };\n            int[] expected2 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input2, 1).SequenceEqual(expected2));\n\n            // Test case 3\n            int[] input3 = { 1, 1, 2, 2, 3, 3 };\n            int[] expected3 = { 1, 1, 2, 2, 3, 3 };\n            Debug.Assert(Program.RemoveElementsByFrequency(input3, 3).SequenceEqual(expected3));\n\n            // Test case 4\n            int[] input4 = { };\n            int[] expected4 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input4, 2).SequenceEqual(expected4));\n\n            // Test case 5\n            int[] input5 = { 1, 2, 3, 4, 5 };\n            int[] expected5 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input5, 0).SequenceEqual(expected5));\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace FrequencyFilter\n{\n    class Program\n    {\n        // Removes elements from an array whose frequency is larger than K.\n        // Uses a dictionary to count the frequency of each element in the array.\n        // Then filters out elements whose frequency exceeds K.\n    public static int[] RemoveElementsByFrequency(int[] arr, int K)\n        {\n            if (arr == null || arr.Length == 0)\n            {\n                return new int[0];\n            }\n\n            // Count the frequency of each element in arr\n            Dictionary<int, int> freqCounter = new Dictionary<int, int>();\n            foreach (int num in arr)\n            {\n                if (freqCounter.ContainsKey(num))\n                {\n                    freqCounter[num]++;\n                }\n                else\n                {\n                    freqCounter[num] = 1;\n                }\n            }\n\n            // Filter out the elements whose frequency is greater than K\n            List<int> result = new List<int>();\n            foreach (int num in arr)\n            {\n                if (freqCounter[num] <= K)\n                {\n                    result.Add(num);\n                }\n            }\n\n            return result.ToArray();\n        }\n    }\n}\n\nnamespace FrequencyFilter\n{\n    class TestFrequencyFilter\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[] input1 = { 1, 2, 2, 3, 3, 3, 4, 4, 4, 4 };\n            int[] expected1 = { 1, 2, 2 };\n            Debug.Assert(Program.RemoveElementsByFrequency(input1, 2).SequenceEqual(expected1));\n\n            // Test case 2\n            int[] input2 = { 5, 5, 5, 5, 5 };\n            int[] expected2 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input2, 1).SequenceEqual(expected2));\n\n            // Test case 3\n            int[] input3 = { 1, 1, 2, 2, 3, 3 };\n            int[] expected3 = { 1, 1, 2, 2, 3, 3 };\n            Debug.Assert(Program.RemoveElementsByFrequency(input3, 3).SequenceEqual(expected3));\n\n            // Test case 4\n            int[] input4 = { };\n            int[] expected4 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input4, 2).SequenceEqual(expected4));\n\n            // Test case 5\n            int[] input5 = { 1, 2, 3, 4, 5 };\n            int[] expected5 = { };\n            Debug.Assert(Program.RemoveElementsByFrequency(input5, 0).SequenceEqual(expected5));\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace FriendshipPairs\n{\n    class Program\n    {\n        /// <summary>\n        /// Gets the number of unique friendship pairs and the list of those pairs.\n        /// </summary>\n        /// <param name=\"n\">Number of students.</param>\n        /// <param name=\"friendsList\">List of friendships for each student.</param>\n        /// <returns>A tuple containing the number of unique friendship pairs and a list of those pairs.</returns>\n        static (int NumberOfPairs, List<(int, int)> FriendshipPairs) GetFriendshipPairs(int n, List<string> friendsList)\n        {\n            HashSet<(int, int)> friendships = new HashSet<(int, int)>();\n\n            for (int i = 0; i < n; i++)\n            {\n                int studentId = i + 1;\n                string[] friends = friendsList[i].Split(',');\n                foreach (string friend in friends)\n                {\n                    if (!string.IsNullOrEmpty(friend))\n                    {\n                        int friendId = int.Parse(friend);\n                        // Add pairs in a sorted manner so (a, b) where a < b\n                        friendships.Add((Math.Min(studentId, friendId), Math.Max(studentId, friendId)));\n                    }\n                }\n            }\n\n            // Convert set to sorted list\n            List<(int, int)> sortedFriendships = friendships.OrderBy(pair => pair.Item1).ThenBy(pair => pair.Item2).ToList();\n            int numberOfPairs = sortedFriendships.Count;\n\n            return (numberOfPairs, sortedFriendships);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input:\nNumber of students: 3\nFriends list: [2,3, 1,3, 1,2]\nNumber of unique friendship pairs: 3\nFriendship pairs: [(1, 2), (1, 3), (2, 3)]\n\nInput:\nNumber of students: 4\nFriends list: [2, 1,3, 2,4, 3]\nNumber of unique friendship pairs: 3\nFriendship pairs: [(1, 2), (2, 3), (3, 4)]\n\nInput:\nNumber of students: 2\nFriends list: [, ]\nNumber of unique friendship pairs: 0\nFriendship pairs: []", "task_id": 19746, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace FriendshipPairs\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var testCase1 = (3, new List<string> { \"2,3\", \"1,3\", \"1,2\" });\n            var result1 = Program.GetFriendshipPairs(testCase1.Item1, testCase1.Item2);\n            Debug.Assert(result1.NumberOfPairs == 3);\n            Debug.Assert(result1.FriendshipPairs.SequenceEqual(new List<(int, int)> { (1, 2), (1, 3), (2, 3) }));\n\n            // Test case 2\n            var testCase2 = (4, new List<string> { \"2\", \"1,3\", \"2,4\", \"3\" });\n            var result2 = Program.GetFriendshipPairs(testCase2.Item1, testCase2.Item2);\n            Debug.Assert(result2.NumberOfPairs == 3);\n            Debug.Assert(result2.FriendshipPairs.SequenceEqual(new List<(int, int)> { (1, 2), (2, 3), (3, 4) }));\n\n            // Test case 3\n            var testCase3 = (2, new List<string> { \"\", \"\" });\n            var result3 = Program.GetFriendshipPairs(testCase3.Item1, testCase3.Item2);\n            Debug.Assert(result3.NumberOfPairs == 0);\n            Debug.Assert(result3.FriendshipPairs.Count == 0);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace FriendshipPairs\n{\n    class Program\n    {\n        /// <summary>\n        /// Gets the number of unique friendship pairs and the list of those pairs.\n        /// </summary>\n        /// <param name=\"n\">Number of students.</param>\n        /// <param name=\"friendsList\">List of friendships for each student.</param>\n        /// <returns>A tuple containing the number of unique friendship pairs and a list of those pairs.</returns>\n    public static (int NumberOfPairs, List<(int, int)> FriendshipPairs) GetFriendshipPairs(int n, List<string> friendsList)\n        {\n            HashSet<(int, int)> friendships = new HashSet<(int, int)>();\n\n            for (int i = 0; i < n; i++)\n            {\n                int studentId = i + 1;\n                string[] friends = friendsList[i].Split(',');\n                foreach (string friend in friends)\n                {\n                    if (!string.IsNullOrEmpty(friend))\n                    {\n                        int friendId = int.Parse(friend);\n                        // Add pairs in a sorted manner so (a, b) where a < b\n                        friendships.Add((Math.Min(studentId, friendId), Math.Max(studentId, friendId)));\n                    }\n                }\n            }\n\n            // Convert set to sorted list\n            List<(int, int)> sortedFriendships = friendships.OrderBy(pair => pair.Item1).ThenBy(pair => pair.Item2).ToList();\n            int numberOfPairs = sortedFriendships.Count;\n\n            return (numberOfPairs, sortedFriendships);\n        }\n    }\n}\n\nnamespace FriendshipPairs\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var testCase1 = (3, new List<string> { \"2,3\", \"1,3\", \"1,2\" });\n            var result1 = Program.GetFriendshipPairs(testCase1.Item1, testCase1.Item2);\n            Debug.Assert(result1.NumberOfPairs == 3);\n            Debug.Assert(result1.FriendshipPairs.SequenceEqual(new List<(int, int)> { (1, 2), (1, 3), (2, 3) }));\n\n            // Test case 2\n            var testCase2 = (4, new List<string> { \"2\", \"1,3\", \"2,4\", \"3\" });\n            var result2 = Program.GetFriendshipPairs(testCase2.Item1, testCase2.Item2);\n            Debug.Assert(result2.NumberOfPairs == 3);\n            Debug.Assert(result2.FriendshipPairs.SequenceEqual(new List<(int, int)> { (1, 2), (2, 3), (3, 4) }));\n\n            // Test case 3\n            var testCase3 = (2, new List<string> { \"\", \"\" });\n            var result3 = Program.GetFriendshipPairs(testCase3.Item1, testCase3.Item2);\n            Debug.Assert(result3.NumberOfPairs == 0);\n            Debug.Assert(result3.FriendshipPairs.Count == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Net;\nusing System.Threading.Tasks;\n\nnamespace SimpleHttpServer\n{\n    public class HttpServer\n    {\n        // Runs a simple HTTP server that serves files from the current directory\n        // port: The port number to listen on\n        public static async Task RunServer(int port)\n        {\n            HttpListener listener = new HttpListener();\n            listener.Prefixes.Add($\"http://*:{port}/\");\n            \n            try\n            {\n                listener.Start();\n                Console.WriteLine($\"Serving HTTP on 0.0.0.0 port {port} (http://0.0.0.0:{port}/) ...\");\n                \n                while (true)\n                {\n                    HttpListenerContext context = await listener.GetContextAsync();\n                    HttpListenerResponse response = context.Response;\n                    \n                    // In a real implementation, you would serve files here\n                    // For this example, we'll just return a simple response\n                    string responseString = \"<html><body>Simple HTTP Server is running</body></html>\";\n                    byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);\n                    \n                    response.ContentLength64 = buffer.Length;\n                    await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);\n                    response.Close();\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Server error: {ex.Message}\");\n            }\n            finally\n            {\n                listener.Stop();\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/48626107cbf44d439608c8d1d76c3a19/MyProject/Program.cs(64,47): warning SYSLIB0014: 'WebClient.WebClient()' is obsolete: 'WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.' (https://aka.ms/dotnet-warnings/SYSLIB0014) [/data/codes/c#/48626107cbf44d439608c8d1d76c3a19/MyProject/MyProject.csproj]\nStarting server on port 8080...\nServer error: Address already in use\nTest request failed for port 8080: The remote server returned an error: (404) NOT FOUND.\nCompleted test for port 8080\n\nStarting server on port 8081...\nServing HTTP on 0.0.0.0 port 8081 (http://0.0.0.0:8081/) ...\nServer response from port 8081: <html><body>Simple HTTP Server is running</body></html>\nCompleted test for port 8081\n\nStarting server on port 9000...\nServing HTTP on 0.0.0.0 port 9000 (http://0.0.0.0:9000/) ...\nServer response from port 9000: <html><body>Simple HTTP Server is running</body></html>\nCompleted test for port 9000\n\nAll tests completed", "task_id": 25549, "assertions": "using System;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Diagnostics;\n\nnamespace SimpleHttpServer\n{\n    class TestHttpServer\n    {\n        public static async Task RunTests()\n        {\n            // Test ports based on the original test cases\n            int[] testPorts = { 8081, 9000 };\n            \n            foreach (int port in testPorts)\n            {\n                Console.WriteLine($\"Testing server on port {port}...\");\n                \n                // Start the server in a separate task\n                var serverTask = HttpServer.RunServer(port);\n                \n                // Give the server a moment to start\n                await Task.Delay(1000);\n                \n                // Test the server by making a request\n                try\n                {\n                    using (WebClient client = new WebClient())\n                    {\n                        string response = client.DownloadString($\"http://localhost:{port}/\");\n                        Debug.Assert(response == \"<html><body>Simple HTTP Server is running</body></html>\");\n                        Console.WriteLine($\"Test passed for port {port}\");\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Test failed for port {port}: {ex.Message}\");\n                    Debug.Fail($\"Test failed for port {port}: {ex.Message}\");\n                }\n                \n                Console.WriteLine($\"Completed test for port {port}\\n\");\n            }\n            \n            Console.WriteLine(\"All tests completed\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System;\n\nnamespace SimpleHttpServer\n{\n    public class HttpServer\n    {\n        // Runs a simple HTTP server that serves files from the current directory\n        // port: The port number to listen on\n        public static async Task RunServer(int port)\n        {\n            HttpListener listener = new HttpListener();\n            listener.Prefixes.Add($\"http://*:{port}/\");\n            \n            try\n            {\n                listener.Start();\n                Console.WriteLine($\"Serving HTTP on 0.0.0.0 port {port} (http://0.0.0.0:{port}/) ...\");\n                \n                while (true)\n                {\n                    HttpListenerContext context = await listener.GetContextAsync();\n                    HttpListenerResponse response = context.Response;\n                    \n                    // In a real implementation, you would serve files here\n                    // For this example, we'll just return a simple response\n                    string responseString = \"<html><body>Simple HTTP Server is running</body></html>\";\n                    byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);\n                    \n                    response.ContentLength64 = buffer.Length;\n                    await response.OutputStream.WriteAsync(buffer, 0, buffer.Length);\n                    response.Close();\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Server error: {ex.Message}\");\n            }\n            finally\n            {\n                listener.Stop();\n            }\n        }\n    }\n}\n\nnamespace SimpleHttpServer\n{\n    class TestHttpServer\n    {\n        public static async Task RunTests()\n        {\n            // Test ports based on the original test cases\n            int[] testPorts = { 8081, 9000 };\n            \n            foreach (int port in testPorts)\n            {\n                Console.WriteLine($\"Testing server on port {port}...\");\n                \n                // Start the server in a separate task\n                var serverTask = HttpServer.RunServer(port);\n                \n                // Give the server a moment to start\n                await Task.Delay(1000);\n                \n                // Test the server by making a request\n                try\n                {\n                    using (WebClient client = new WebClient())\n                    {\n                        string response = client.DownloadString($\"http://localhost:{port}/\");\n                        Debug.Assert(response == \"<html><body>Simple HTTP Server is running</body></html>\");\n                        Console.WriteLine($\"Test passed for port {port}\");\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Test failed for port {port}: {ex.Message}\");\n                    Debug.Fail($\"Test failed for port {port}: {ex.Message}\");\n                }\n                \n                Console.WriteLine($\"Completed test for port {port}\\n\");\n            }\n            \n            Console.WriteLine(\"All tests completed\");\n        }\n    }\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace MaxDistanceFromRoot\n{\n    class Program\n    {\n        // MaxDistanceFromRoot calculates the maximum distance from the root node (node 1) in a tree.\n        // The tree is represented as an adjacency list constructed from the given edges.\n        // The method uses BFS to traverse the tree and find the maximum distance.\n        static int MaxDistanceFromRoot(int n, List<(int, int)> edges)\n        {\n            // Create adjacency list\n            Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\n            foreach (var edge in edges)\n            {\n                int u = edge.Item1;\n                int v = edge.Item2;\n                \n                if (!graph.ContainsKey(u))\n                {\n                    graph[u] = new List<int>();\n                }\n                graph[u].Add(v);\n                \n                if (!graph.ContainsKey(v))\n                {\n                    graph[v] = new List<int>();\n                }\n                graph[v].Add(u);\n            }\n            \n            // BFS to find the maximum distance from node 1\n            int Bfs(int start)\n            {\n                bool[] visited = new bool[n + 1];\n                Queue<(int, int)> queue = new Queue<(int, int)>();\n                queue.Enqueue((start, 0));\n                visited[start] = true;\n                int maxDist = 0;\n                \n                while (queue.Count > 0)\n                {\n                    var (current, dist) = queue.Dequeue();\n                    maxDist = dist;\n                    if (graph.ContainsKey(current))\n                    {\n                        foreach (int neighbor in graph[current])\n                        {\n                            if (!visited[neighbor])\n                            {\n                                visited[neighbor] = true;\n                                queue.Enqueue((neighbor, dist + 1));\n                            }\n                        }\n                    }\n                }\n                return maxDist;\n            }\n            \n            return Bfs(1);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 4, edges = [(1, 2), (1, 3), (2, 4)]\nMax Distance from Root: 2\nInput: n = 5, edges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nMax Distance from Root: 4\nInput: n = 3, edges = [(1, 2), (1, 3)]\nMax Distance from Root: 1", "task_id": 1302, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace MaxDistanceFromRoot\n{\n    class TestMaxDistanceFromRoot\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var edges1 = new List<(int, int)>\n            {\n                (1, 2),\n                (1, 3),\n                (2, 4)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(4, edges1) == 2);\n\n            // Test case 2\n            var edges2 = new List<(int, int)>\n            {\n                (1, 2),\n                (2, 3),\n                (3, 4),\n                (4, 5)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(5, edges2) == 4);\n\n            // Test case 3\n            var edges3 = new List<(int, int)>\n            {\n                (1, 2),\n                (1, 3)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(3, edges3) == 1);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace MaxDistanceFromRoot\n{\n    class Program\n    {\n        // MaxDistanceFromRoot calculates the maximum distance from the root node (node 1) in a tree.\n        // The tree is represented as an adjacency list constructed from the given edges.\n        // The method uses BFS to traverse the tree and find the maximum distance.\n    public static int MaxDistanceFromRoot(int n, List<(int, int)> edges)\n        {\n            // Create adjacency list\n            Dictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\n            foreach (var edge in edges)\n            {\n                int u = edge.Item1;\n                int v = edge.Item2;\n                \n                if (!graph.ContainsKey(u))\n                {\n                    graph[u] = new List<int>();\n                }\n                graph[u].Add(v);\n                \n                if (!graph.ContainsKey(v))\n                {\n                    graph[v] = new List<int>();\n                }\n                graph[v].Add(u);\n            }\n            \n            // BFS to find the maximum distance from node 1\n            int Bfs(int start)\n            {\n                bool[] visited = new bool[n + 1];\n                Queue<(int, int)> queue = new Queue<(int, int)>();\n                queue.Enqueue((start, 0));\n                visited[start] = true;\n                int maxDist = 0;\n                \n                while (queue.Count > 0)\n                {\n                    var (current, dist) = queue.Dequeue();\n                    maxDist = dist;\n                    if (graph.ContainsKey(current))\n                    {\n                        foreach (int neighbor in graph[current])\n                        {\n                            if (!visited[neighbor])\n                            {\n                                visited[neighbor] = true;\n                                queue.Enqueue((neighbor, dist + 1));\n                            }\n                        }\n                    }\n                }\n                return maxDist;\n            }\n            \n            return Bfs(1);\n        }\n    }\n}\n\nnamespace MaxDistanceFromRoot\n{\n    class TestMaxDistanceFromRoot\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var edges1 = new List<(int, int)>\n            {\n                (1, 2),\n                (1, 3),\n                (2, 4)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(4, edges1) == 2);\n\n            // Test case 2\n            var edges2 = new List<(int, int)>\n            {\n                (1, 2),\n                (2, 3),\n                (3, 4),\n                (4, 5)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(5, edges2) == 4);\n\n            // Test case 3\n            var edges3 = new List<(int, int)>\n            {\n                (1, 2),\n                (1, 3)\n            };\n            Debug.Assert(Program.MaxDistanceFromRoot(3, edges3) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace StatisticsCalculator\n{\n    public class StatisticsCalculator\n    {\n        // Computes the mean (average) of an array of numbers.\n        // Returns null for an empty array.\n        public static double? Mean(double[] values)\n        {\n            if (values.Length == 0)\n            {\n                return null;\n            }\n            return values.Average();\n        }\n\n        // Computes the median of an array of numbers.\n        // Returns null for an empty array.\n        public static double? Median(double[] values)\n        {\n            if (values.Length == 0)\n            {\n                return null;\n            }\n            var sortedValues = values.OrderBy(x => x).ToArray();\n            int length = sortedValues.Length;\n            int midpoint = length / 2;\n            if (length % 2 == 0)\n            {\n                return (sortedValues[midpoint - 1] + sortedValues[midpoint]) / 2.0;\n            }\n            else\n            {\n                return sortedValues[midpoint];\n            }\n        }\n\n        // Computes the sample standard deviation of an array of numbers.\n        // Returns null for arrays of length less than two.\n        public static double? StdDev(double[] values)\n        {\n            if (values.Length < 2)\n            {\n                return null;\n            }\n            double meanVal = values.Average();\n            double variance = values.Sum(x => Math.Pow(x - meanVal, 2)) / (values.Length - 1);\n            return Math.Sqrt(variance);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 5]\nMean: 3\nMedian: 3\nStdDev: 1.5811388300841898\n\nInput: [10, 20, 30, 40]\nMean: 25\nMedian: 25\nStdDev: 12.909944487358056\n\nInput: [5, 5, 5, 5, 5]\nMean: 5\nMedian: 5\nStdDev: 0\n\nInput: [1]\nMean: 1\nMedian: 1\nStdDev: null\n\nInput: []\nMean: null\nMedian: null\nStdDev: null", "task_id": 20531, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StatisticsCalculator\n{\n    public class TestStatisticsCalculator\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            double[] test1 = { 1, 2, 3, 4, 5 };\n            Debug.Assert(StatisticsCalculator.Mean(test1) == 3);\n            Debug.Assert(StatisticsCalculator.Median(test1) == 3);\n            Debug.Assert(Math.Abs(StatisticsCalculator.StdDev(test1).Value - 1.5811388300841898) < 0.000001);\n\n            // Test case 2\n            double[] test2 = { 10, 20, 30, 40 };\n            Debug.Assert(StatisticsCalculator.Mean(test2) == 25);\n            Debug.Assert(StatisticsCalculator.Median(test2) == 25);\n            Debug.Assert(Math.Abs(StatisticsCalculator.StdDev(test2).Value - 12.909944487358056) < 0.000001);\n\n            // Test case 3\n            double[] test3 = { 5, 5, 5, 5, 5 };\n            Debug.Assert(StatisticsCalculator.Mean(test3) == 5);\n            Debug.Assert(StatisticsCalculator.Median(test3) == 5);\n            Debug.Assert(StatisticsCalculator.StdDev(test3) == 0);\n\n            // Test case 4\n            double[] test4 = { 1 };\n            Debug.Assert(StatisticsCalculator.Mean(test4) == 1);\n            Debug.Assert(StatisticsCalculator.Median(test4) == 1);\n            Debug.Assert(StatisticsCalculator.StdDev(test4) == null);\n\n            // Test case 5\n            double[] test5 = { };\n            Debug.Assert(StatisticsCalculator.Mean(test5) == null);\n            Debug.Assert(StatisticsCalculator.Median(test5) == null);\n            Debug.Assert(StatisticsCalculator.StdDev(test5) == null);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace StatisticsCalculator\n{\n    public class StatisticsCalculator\n    {\n        // Computes the mean (average) of an array of numbers.\n        // Returns null for an empty array.\n        public static double? Mean(double[] values)\n        {\n            if (values.Length == 0)\n            {\n                return null;\n            }\n            return values.Average();\n        }\n\n        // Computes the median of an array of numbers.\n        // Returns null for an empty array.\n        public static double? Median(double[] values)\n        {\n            if (values.Length == 0)\n            {\n                return null;\n            }\n            var sortedValues = values.OrderBy(x => x).ToArray();\n            int length = sortedValues.Length;\n            int midpoint = length / 2;\n            if (length % 2 == 0)\n            {\n                return (sortedValues[midpoint - 1] + sortedValues[midpoint]) / 2.0;\n            }\n            else\n            {\n                return sortedValues[midpoint];\n            }\n        }\n\n        // Computes the sample standard deviation of an array of numbers.\n        // Returns null for arrays of length less than two.\n        public static double? StdDev(double[] values)\n        {\n            if (values.Length < 2)\n            {\n                return null;\n            }\n            double meanVal = values.Average();\n            double variance = values.Sum(x => Math.Pow(x - meanVal, 2)) / (values.Length - 1);\n            return Math.Sqrt(variance);\n        }\n    }\n}\n\nnamespace StatisticsCalculator\n{\n    public class TestStatisticsCalculator\n    {\n        public static void Main()\n        {\n            // Test case 1\n            double[] test1 = { 1, 2, 3, 4, 5 };\n            Debug.Assert(StatisticsCalculator.Mean(test1) == 3);\n            Debug.Assert(StatisticsCalculator.Median(test1) == 3);\n            Debug.Assert(Math.Abs(StatisticsCalculator.StdDev(test1).Value - 1.5811388300841898) < 0.000001);\n\n            // Test case 2\n            double[] test2 = { 10, 20, 30, 40 };\n            Debug.Assert(StatisticsCalculator.Mean(test2) == 25);\n            Debug.Assert(StatisticsCalculator.Median(test2) == 25);\n            Debug.Assert(Math.Abs(StatisticsCalculator.StdDev(test2).Value - 12.909944487358056) < 0.000001);\n\n            // Test case 3\n            double[] test3 = { 5, 5, 5, 5, 5 };\n            Debug.Assert(StatisticsCalculator.Mean(test3) == 5);\n            Debug.Assert(StatisticsCalculator.Median(test3) == 5);\n            Debug.Assert(StatisticsCalculator.StdDev(test3) == 0);\n\n            // Test case 4\n            double[] test4 = { 1 };\n            Debug.Assert(StatisticsCalculator.Mean(test4) == 1);\n            Debug.Assert(StatisticsCalculator.Median(test4) == 1);\n            Debug.Assert(StatisticsCalculator.StdDev(test4) == null);\n\n            // Test case 5\n            double[] test5 = { };\n            Debug.Assert(StatisticsCalculator.Mean(test5) == null);\n            Debug.Assert(StatisticsCalculator.Median(test5) == null);\n            Debug.Assert(StatisticsCalculator.StdDev(test5) == null);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace TreePlacementChecker\n{\n    class Program\n    {\n        // Determines if it's possible to place 'k' trees in an 'n x m' grid following a checkerboard pattern.\n        // Returns a tuple with a \"YES\" or \"NO\" string and the grid configuration if possible.\n        public static (string Result, char[][] Grid) CanPlaceTrees(int n, int m, int k)\n        {\n            // Calculate the maximum number of trees that can be placed in a checkerboard pattern\n            int maxTrees = (n * m + 1) / 2;\n\n            if (k > maxTrees)\n            {\n                return (\"NO\", null);\n            }\n            else\n            {\n                // Initialize the grid with '.' representing empty spots\n                char[][] grid = new char[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    grid[i] = new char[m];\n                    for (int j = 0; j < m; j++)\n                    {\n                        grid[i][j] = '.';\n                    }\n                }\n\n                // Place trees in a checkerboard pattern\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                {\n                    for (int j = 0; j < m; j++)\n                    {\n                        if ((i + j) % 2 == 0 && count < k)\n                        {\n                            grid[i][j] = 'T';\n                            count++;\n                        }\n                    }\n                }\n\n                return (\"YES\", grid);\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "/data/codes/c#/20ddf9d9fd78464997dfe83f6283db55/MyProject/Program.cs(16,24): warning CS8619: Nullability of reference types in value of type '(string, char[][]?)' doesn't match target type '(string Result, char[][] Grid)'. [/data/codes/c#/20ddf9d9fd78464997dfe83f6283db55/MyProject/MyProject.csproj]\nInput: n=2, m=2, k=2\nResult: YES\nGrid:\nT.\n.T\n\nInput: n=3, m=3, k=5\nResult: YES\nGrid:\nT.T\n.T.\nT.T\n\nInput: n=1, m=4, k=2\nResult: YES\nGrid:\nT.T.\n\nInput: n=4, m=4, k=8\nResult: YES\nGrid:\nT.T.\n.T.T\nT.T.\n.T.T\n\nInput: n=2, m=3, k=4\nResult: NO", "task_id": 709, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace TreePlacementChecker\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Should return YES\n            var result1 = Program.CanPlaceTrees(2, 2, 2);\n            Debug.Assert(result1.Result == \"YES\");\n            Debug.Assert(result1.Grid[0][0] == 'T');\n            Debug.Assert(result1.Grid[0][1] == '.');\n            Debug.Assert(result1.Grid[1][0] == '.');\n            Debug.Assert(result1.Grid[1][1] == 'T');\n\n            // Test case 2: Should return NO\n            var result2 = Program.CanPlaceTrees(3, 3, 5);\n            Debug.Assert(result2.Result == \"NO\");\n            Debug.Assert(result2.Grid == null);\n\n            // Test case 3: Should return YES\n            var result3 = Program.CanPlaceTrees(1, 4, 2);\n            Debug.Assert(result3.Result == \"YES\");\n            Debug.Assert(result3.Grid[0][0] == 'T');\n            Debug.Assert(result3.Grid[0][1] == '.');\n            Debug.Assert(result3.Grid[0][2] == 'T');\n            Debug.Assert(result3.Grid[0][3] == '.');\n\n            // Test case 4: Should return YES\n            var result4 = Program.CanPlaceTrees(4, 4, 8);\n            Debug.Assert(result4.Result == \"YES\");\n            Debug.Assert(result4.Grid[0][0] == 'T');\n            Debug.Assert(result4.Grid[0][1] == '.');\n            Debug.Assert(result4.Grid[0][2] == 'T');\n            Debug.Assert(result4.Grid[0][3] == '.');\n            Debug.Assert(result4.Grid[1][0] == '.');\n            Debug.Assert(result4.Grid[1][1] == 'T');\n            Debug.Assert(result4.Grid[1][2] == '.');\n            Debug.Assert(result4.Grid[1][3] == 'T');\n\n            // Test case 5: Should return NO\n            var result5 = Program.CanPlaceTrees(2, 3, 4);\n            Debug.Assert(result5.Result == \"NO\");\n            Debug.Assert(result5.Grid == null);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace TreePlacementChecker\n{\n    class Program\n    {\n        // Determines if it's possible to place 'k' trees in an 'n x m' grid following a checkerboard pattern.\n        // Returns a tuple with a \"YES\" or \"NO\" string and the grid configuration if possible.\n        public static (string Result, char[][] Grid) CanPlaceTrees(int n, int m, int k)\n        {\n            // Calculate the maximum number of trees that can be placed in a checkerboard pattern\n            int maxTrees = (n * m + 1) / 2;\n\n            if (k > maxTrees)\n            {\n                return (\"NO\", null);\n            }\n            else\n            {\n                // Initialize the grid with '.' representing empty spots\n                char[][] grid = new char[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    grid[i] = new char[m];\n                    for (int j = 0; j < m; j++)\n                    {\n                        grid[i][j] = '.';\n                    }\n                }\n\n                // Place trees in a checkerboard pattern\n                int count = 0;\n                for (int i = 0; i < n; i++)\n                {\n                    for (int j = 0; j < m; j++)\n                    {\n                        if ((i + j) % 2 == 0 && count < k)\n                        {\n                            grid[i][j] = 'T';\n                            count++;\n                        }\n                    }\n                }\n\n                return (\"YES\", grid);\n            }\n        }\n    }\n}\n\nnamespace TreePlacementChecker\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Should return YES\n            var result1 = Program.CanPlaceTrees(2, 2, 2);\n            Debug.Assert(result1.Result == \"YES\");\n            Debug.Assert(result1.Grid[0][0] == 'T');\n            Debug.Assert(result1.Grid[0][1] == '.');\n            Debug.Assert(result1.Grid[1][0] == '.');\n            Debug.Assert(result1.Grid[1][1] == 'T');\n\n            // Test case 2: Should return NO\n            var result2 = Program.CanPlaceTrees(3, 3, 5);\n            Debug.Assert(result2.Result == \"NO\");\n            Debug.Assert(result2.Grid == null);\n\n            // Test case 3: Should return YES\n            var result3 = Program.CanPlaceTrees(1, 4, 2);\n            Debug.Assert(result3.Result == \"YES\");\n            Debug.Assert(result3.Grid[0][0] == 'T');\n            Debug.Assert(result3.Grid[0][1] == '.');\n            Debug.Assert(result3.Grid[0][2] == 'T');\n            Debug.Assert(result3.Grid[0][3] == '.');\n\n            // Test case 4: Should return YES\n            var result4 = Program.CanPlaceTrees(4, 4, 8);\n            Debug.Assert(result4.Result == \"YES\");\n            Debug.Assert(result4.Grid[0][0] == 'T');\n            Debug.Assert(result4.Grid[0][1] == '.');\n            Debug.Assert(result4.Grid[0][2] == 'T');\n            Debug.Assert(result4.Grid[0][3] == '.');\n            Debug.Assert(result4.Grid[1][0] == '.');\n            Debug.Assert(result4.Grid[1][1] == 'T');\n            Debug.Assert(result4.Grid[1][2] == '.');\n            Debug.Assert(result4.Grid[1][3] == 'T');\n\n            // Test case 5: Should return NO\n            var result5 = Program.CanPlaceTrees(2, 3, 4);\n            Debug.Assert(result5.Result == \"NO\");\n            Debug.Assert(result5.Grid == null);\n        }\n    }\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "using System;\nusing System.Linq;\n\nnamespace KnapsackSolver\n{\n    class KnapsackSolver\n    {\n        // Solves the knapsack problem where items can be modified by replacing some of them with cheaper alternatives.\n        // The method sorts items by tastiness in descending order and then modifies the first m items to have the smallest costs.\n        // Then it applies the standard 0-1 knapsack dynamic programming approach to find the maximum tastiness within the given capacity.\n        public static int SolveKnapsack(int n, int C, int K, (int c, int t)[] items)\n        {\n            // Sort items by tastiness descending, then by cost ascending\n            var sortedItems = items.OrderByDescending(x => x.t).ThenBy(x => x.c).ToArray();\n\n            // Extract and sort the costs of all items\n            var cList = items.Select(x => x.c).OrderBy(x => x).ToArray();\n\n            // Determine the number of items to modify (m is the minimum of 2K and n)\n            int m = Math.Min(2 * K, n);\n\n            // Create new items list where the first m items have the smallest costs but retain their original tastiness\n            var newItems = new (int c, int t)[n];\n            for (int i = 0; i < n; i++)\n            {\n                if (i < m)\n                {\n                    newItems[i] = (cList[i], sortedItems[i].t);\n                }\n                else\n                {\n                    newItems[i] = sortedItems[i];\n                }\n            }\n\n            // Initialize DP array for 0-1 knapsack\n            int[] dp = new int[C + 1];\n\n            foreach (var item in newItems)\n            {\n                for (int w = C; w >= item.c; w--)\n                {\n                    if (dp[w - item.c] + item.t > dp[w])\n                    {\n                        dp[w] = dp[w - item.c] + item.t;\n                    }\n                }\n            }\n\n            return dp.Max();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n=3, C=10, K=1, items=[(5, 10), (3, 8), (4, 9)]\nMaximum tastiness: 27\n\nTest Case 2:\nInput: n=5, C=15, K=2, items=[(2, 5), (3, 7), (5, 10), (7, 12), (1, 3)]\nMaximum tastiness: 37\n\nTest Case 3:\nInput: n=4, C=8, K=0, items=[(2, 4), (3, 5), (4, 6), (5, 7)]\nMaximum tastiness: 12", "task_id": 6889, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace KnapsackSolver\n{\n    class TestKnapsackSolver\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Sample input from the problem statement\n            int n1 = 3, C1 = 10, K1 = 1;\n            var items1 = new (int c, int t)[] { (5, 10), (3, 8), (4, 9) };\n            int result1 = KnapsackSolver.SolveKnapsack(n1, C1, K1, items1);\n            Debug.Assert(result1 == 27);\n\n            // Test case 2: Larger capacity with more items\n            int n2 = 5, C2 = 15, K2 = 2;\n            var items2 = new (int c, int t)[] { (2, 5), (3, 7), (5, 10), (7, 12), (1, 3) };\n            int result2 = KnapsackSolver.SolveKnapsack(n2, C2, K2, items2);\n            Debug.Assert(result2 == 37);\n\n            // Test case 3: Edge case where K is 0 (no items modified)\n            int n3 = 4, C3 = 8, K3 = 0;\n            var items3 = new (int c, int t)[] { (2, 4), (3, 5), (4, 6), (5, 7) };\n            int result3 = KnapsackSolver.SolveKnapsack(n3, C3, K3, items3);\n            Debug.Assert(result3 == 12);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace KnapsackSolver\n{\n    class KnapsackSolver\n    {\n        // Solves the knapsack problem where items can be modified by replacing some of them with cheaper alternatives.\n        // The method sorts items by tastiness in descending order and then modifies the first m items to have the smallest costs.\n        // Then it applies the standard 0-1 knapsack dynamic programming approach to find the maximum tastiness within the given capacity.\n        public static int SolveKnapsack(int n, int C, int K, (int c, int t)[] items)\n        {\n            // Sort items by tastiness descending, then by cost ascending\n            var sortedItems = items.OrderByDescending(x => x.t).ThenBy(x => x.c).ToArray();\n\n            // Extract and sort the costs of all items\n            var cList = items.Select(x => x.c).OrderBy(x => x).ToArray();\n\n            // Determine the number of items to modify (m is the minimum of 2K and n)\n            int m = Math.Min(2 * K, n);\n\n            // Create new items list where the first m items have the smallest costs but retain their original tastiness\n            var newItems = new (int c, int t)[n];\n            for (int i = 0; i < n; i++)\n            {\n                if (i < m)\n                {\n                    newItems[i] = (cList[i], sortedItems[i].t);\n                }\n                else\n                {\n                    newItems[i] = sortedItems[i];\n                }\n            }\n\n            // Initialize DP array for 0-1 knapsack\n            int[] dp = new int[C + 1];\n\n            foreach (var item in newItems)\n            {\n                for (int w = C; w >= item.c; w--)\n                {\n                    if (dp[w - item.c] + item.t > dp[w])\n                    {\n                        dp[w] = dp[w - item.c] + item.t;\n                    }\n                }\n            }\n\n            return dp.Max();\n        }\n    }\n}\n\nnamespace KnapsackSolver\n{\n    class TestKnapsackSolver\n    {\n        public static void Main()\n        {\n            // Test case 1: Sample input from the problem statement\n            int n1 = 3, C1 = 10, K1 = 1;\n            var items1 = new (int c, int t)[] { (5, 10), (3, 8), (4, 9) };\n            int result1 = KnapsackSolver.SolveKnapsack(n1, C1, K1, items1);\n            Debug.Assert(result1 == 27);\n\n            // Test case 2: Larger capacity with more items\n            int n2 = 5, C2 = 15, K2 = 2;\n            var items2 = new (int c, int t)[] { (2, 5), (3, 7), (5, 10), (7, 12), (1, 3) };\n            int result2 = KnapsackSolver.SolveKnapsack(n2, C2, K2, items2);\n            Debug.Assert(result2 == 37);\n\n            // Test case 3: Edge case where K is 0 (no items modified)\n            int n3 = 4, C3 = 8, K3 = 0;\n            var items3 = new (int c, int t)[] { (2, 4), (3, 5), (4, 6), (5, 7) };\n            int result3 = KnapsackSolver.SolveKnapsack(n3, C3, K3, items3);\n            Debug.Assert(result3 == 12);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ShortestPathsCounter\n{\n    class Program\n    {\n        // Counts the number of shortest paths from node 1 to node n in a weighted undirected graph.\n        // Uses Dijkstra's algorithm to find shortest path distances and BFS to count paths.\n        static int CountShortestPaths(int n, int m, List<(int x, int y, int w)> edges)\n        {\n            // Build adjacency list\n            var graph = new Dictionary<int, List<(int node, int weight)>>();\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<(int node, int weight)>();\n            }\n            foreach (var edge in edges)\n            {\n                graph[edge.x].Add((edge.y, edge.w));\n                graph[edge.y].Add((edge.x, edge.w));\n            }\n\n            // Dijkstra's algorithm to find shortest path distances from node 1\n            int[] distances = Dijkstra(n, graph, 1);\n\n            // BFS to count the number of shortest paths\n            int[] pathCount = new int[n + 1];\n            pathCount[1] = 1;\n            var queue = new Queue<int>();\n            queue.Enqueue(1);\n\n            while (queue.Count > 0)\n            {\n                int u = queue.Dequeue();\n                foreach (var (v, weight) in graph[u])\n                {\n                    if (distances[u] + weight == distances[v])\n                    {\n                        if (pathCount[v] == 0)\n                        {\n                            queue.Enqueue(v);\n                        }\n                        pathCount[v] += pathCount[u];\n                    }\n                }\n            }\n\n            return pathCount[n];\n        }\n\n        // Dijkstra's algorithm to compute shortest distances from a source node\n        static int[] Dijkstra(int n, Dictionary<int, List<(int node, int weight)>> graph, int source)\n        {\n            int[] distances = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                distances[i] = int.MaxValue;\n            }\n            distances[source] = 0;\n\n            var minHeap = new SortedSet<(int distance, int node)>(\n                Comparer<(int distance, int node)>.Create((a, b) => \n                {\n                    int result = a.distance.CompareTo(b.distance);\n                    if (result == 0)\n                    {\n                        return a.node.CompareTo(b.node);\n                    }\n                    return result;\n                })\n            );\n            minHeap.Add((0, source));\n\n            while (minHeap.Count > 0)\n            {\n                var (currentDistance, u) = minHeap.Min;\n                minHeap.Remove(minHeap.Min);\n                if (currentDistance > distances[u])\n                {\n                    continue;\n                }\n                foreach (var (v, weight) in graph[u])\n                {\n                    int distance = currentDistance + weight;\n                    if (distance < distances[v])\n                    {\n                        distances[v] = distance;\n                        minHeap.Add((distance, v));\n                    }\n                }\n            }\n\n            return distances;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n=2, m=1, edges=[(1, 2, 1)]\nNumber of shortest paths: 1\n\nTest Case 2:\nInput: n=3, m=3, edges=[(1, 2, 1), (2, 3, 1), (1, 3, 2)]\nNumber of shortest paths: 2\n\nTest Case 3:\nInput: n=4, m=5, edges=[(1, 2, 1), (2, 4, 1), (1, 3, 1), (3, 4, 1), (2, 3, 1)]\nNumber of shortest paths: 2", "task_id": 29839, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ShortestPathsCounter\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Simple graph with 2 nodes and 1 edge\n            var edges1 = new List<(int x, int y, int w)> { (1, 2, 1) };\n            Debug.Assert(Program.CountShortestPaths(2, 1, edges1) == 1);\n\n            // Test case 2: Graph with 3 nodes and 3 edges forming a triangle\n            var edges2 = new List<(int x, int y, int w)> { (1, 2, 1), (2, 3, 1), (1, 3, 2) };\n            Debug.Assert(Program.CountShortestPaths(3, 3, edges2) == 2);\n\n            // Test case 3: Graph with 4 nodes and multiple paths\n            var edges3 = new List<(int x, int y, int w)> { (1, 2, 1), (2, 4, 1), (1, 3, 1), (3, 4, 1), (2, 3, 1) };\n            Debug.Assert(Program.CountShortestPaths(4, 5, edges3) == 2);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace ShortestPathsCounter\n{\n    class Program\n    {\n        // Counts the number of shortest paths from node 1 to node n in a weighted undirected graph.\n        // Uses Dijkstra's algorithm to find shortest path distances and BFS to count paths.\n    public static int CountShortestPaths(int n, int m, List<(int x, int y, int w)> edges)\n        {\n            // Build adjacency list\n            var graph = new Dictionary<int, List<(int node, int weight)>>();\n            for (int i = 1; i <= n; i++)\n            {\n                graph[i] = new List<(int node, int weight)>();\n            }\n            foreach (var edge in edges)\n            {\n                graph[edge.x].Add((edge.y, edge.w));\n                graph[edge.y].Add((edge.x, edge.w));\n            }\n\n            // Dijkstra's algorithm to find shortest path distances from node 1\n            int[] distances = Dijkstra(n, graph, 1);\n\n            // BFS to count the number of shortest paths\n            int[] pathCount = new int[n + 1];\n            pathCount[1] = 1;\n            var queue = new Queue<int>();\n            queue.Enqueue(1);\n\n            while (queue.Count > 0)\n            {\n                int u = queue.Dequeue();\n                foreach (var (v, weight) in graph[u])\n                {\n                    if (distances[u] + weight == distances[v])\n                    {\n                        if (pathCount[v] == 0)\n                        {\n                            queue.Enqueue(v);\n                        }\n                        pathCount[v] += pathCount[u];\n                    }\n                }\n            }\n\n            return pathCount[n];\n        }\n\n        // Dijkstra's algorithm to compute shortest distances from a source node\n    public static int[] Dijkstra(int n, Dictionary<int, List<(int node, int weight)>> graph, int source)\n        {\n            int[] distances = new int[n + 1];\n            for (int i = 1; i <= n; i++)\n            {\n                distances[i] = int.MaxValue;\n            }\n            distances[source] = 0;\n\n            var minHeap = new SortedSet<(int distance, int node)>(\n                Comparer<(int distance, int node)>.Create((a, b) => \n                {\n                    int result = a.distance.CompareTo(b.distance);\n                    if (result == 0)\n                    {\n                        return a.node.CompareTo(b.node);\n                    }\n                    return result;\n                })\n            );\n            minHeap.Add((0, source));\n\n            while (minHeap.Count > 0)\n            {\n                var (currentDistance, u) = minHeap.Min;\n                minHeap.Remove(minHeap.Min);\n                if (currentDistance > distances[u])\n                {\n                    continue;\n                }\n                foreach (var (v, weight) in graph[u])\n                {\n                    int distance = currentDistance + weight;\n                    if (distance < distances[v])\n                    {\n                        distances[v] = distance;\n                        minHeap.Add((distance, v));\n                    }\n                }\n            }\n\n            return distances;\n        }\n    }\n}\n\nnamespace ShortestPathsCounter\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: Simple graph with 2 nodes and 1 edge\n            var edges1 = new List<(int x, int y, int w)> { (1, 2, 1) };\n            Debug.Assert(Program.CountShortestPaths(2, 1, edges1) == 1);\n\n            // Test case 2: Graph with 3 nodes and 3 edges forming a triangle\n            var edges2 = new List<(int x, int y, int w)> { (1, 2, 1), (2, 3, 1), (1, 3, 2) };\n            Debug.Assert(Program.CountShortestPaths(3, 3, edges2) == 2);\n\n            // Test case 3: Graph with 4 nodes and multiple paths\n            var edges3 = new List<(int x, int y, int w)> { (1, 2, 1), (2, 4, 1), (1, 3, 1), (3, 4, 1), (2, 3, 1) };\n            Debug.Assert(Program.CountShortestPaths(4, 5, edges3) == 2);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace LogicGates\n{\n    class Program\n    {\n        // AndGate returns the result of an AND gate for the given inputs.\n        // An AND gate returns 1 only if both inputs are 1, otherwise it returns 0.\n        // Parameters:\n        //   input1 (int): The first input (0 or 1)\n        //   input2 (int): The second input (0 or 1)\n        // Returns:\n        //   int: 1 if both inputs are 1, otherwise 0\n        public static int AndGate(int input1, int input2)\n        {\n            return input1 & input2;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input1: 0, Input2: 0\nResult: 0\nInput1: 0, Input2: 1\nResult: 0\nInput1: 1, Input2: 0\nResult: 0\nInput1: 1, Input2: 1\nResult: 1", "task_id": 2216, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace LogicGates\n{\n    class TestLogicGates\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.AndGate(0, 0) == 0);\n            Debug.Assert(Program.AndGate(0, 1) == 0);\n            Debug.Assert(Program.AndGate(1, 0) == 0);\n            Debug.Assert(Program.AndGate(1, 1) == 1);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace LogicGates\n{\n    class Program\n    {\n        // AndGate returns the result of an AND gate for the given inputs.\n        // An AND gate returns 1 only if both inputs are 1, otherwise it returns 0.\n        // Parameters:\n        //   input1 (int): The first input (0 or 1)\n        //   input2 (int): The second input (0 or 1)\n        // Returns:\n        //   int: 1 if both inputs are 1, otherwise 0\n        public static int AndGate(int input1, int input2)\n        {\n            return input1 & input2;\n        }\n    }\n}\n\nnamespace LogicGates\n{\n    class TestLogicGates\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.AndGate(0, 0) == 0);\n            Debug.Assert(Program.AndGate(0, 1) == 0);\n            Debug.Assert(Program.AndGate(1, 0) == 0);\n            Debug.Assert(Program.AndGate(1, 1) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace EnhancedMovingAverageCalculator\n{\n    // EnhancedMovingAverage class calculates the moving average, maximum, and minimum values within a sliding window of a specified size.\n    public class EnhancedMovingAverage\n    {\n        private int size; // Size of the sliding window\n        private Queue<int> window; // Queue to hold the values in the current window\n        private double sum; // Sum of the values in the current window\n        private int currentMax; // Current maximum value in the window\n        private int currentMin; // Current minimum value in the window\n\n        // Constructor initializes the EnhancedMovingAverage with a specified window size.\n        public EnhancedMovingAverage(int size)\n        {\n            this.size = size;\n            this.window = new Queue<int>();\n            this.sum = 0;\n            this.currentMax = int.MinValue;\n            this.currentMin = int.MaxValue;\n        }\n\n        // Adds a new value to the window and returns the current moving average.\n        public double Next(int val)\n        {\n            // Add new value to the window and update sum\n            window.Enqueue(val);\n            sum += val;\n\n            // Update current max and min\n            if (val > currentMax)\n            {\n                currentMax = val;\n            }\n            if (val < currentMin)\n            {\n                currentMin = val;\n            }\n\n            // If window size exceeds the specified size, remove the oldest value\n            if (window.Count > size)\n            {\n                int removed = window.Dequeue();\n                sum -= removed;\n\n                // Recalculate max and min if the removed value was one of them\n                if (removed == currentMax || removed == currentMin)\n                {\n                    currentMax = int.MinValue;\n                    currentMin = int.MaxValue;\n                    foreach (int num in window)\n                    {\n                        if (num > currentMax)\n                        {\n                            currentMax = num;\n                        }\n                        if (num < currentMin)\n                        {\n                            currentMin = num;\n                        }\n                    }\n                }\n            }\n\n            return sum / window.Count;\n        }\n\n        // Returns the current maximum value in the window.\n        public int GetMax()\n        {\n            return currentMax;\n        }\n\n        // Returns the current minimum value in the window.\n        public int GetMin()\n        {\n            return currentMin;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nAdded 1, Moving Average: 1, Max: 1, Min: 1\nAdded 2, Moving Average: 1.5, Max: 2, Min: 1\nAdded 3, Moving Average: 2, Max: 3, Min: 1\nAdded 4, Moving Average: 3, Max: 4, Min: 2\nAdded 5, Moving Average: 4, Max: 5, Min: 3\nAdded 6, Moving Average: 5, Max: 6, Min: 4\nAdded 7, Moving Average: 6, Max: 7, Min: 5\nAdded 8, Moving Average: 7, Max: 8, Min: 6\nAdded 9, Moving Average: 8, Max: 9, Min: 7\nAdded 10, Moving Average: 9, Max: 10, Min: 8\n\nTest Case: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\nAdded 10, Moving Average: 10, Max: 10, Min: 10\nAdded 9, Moving Average: 9.5, Max: 10, Min: 9\nAdded 8, Moving Average: 9, Max: 10, Min: 8\nAdded 7, Moving Average: 8, Max: 9, Min: 7\nAdded 6, Moving Average: 7, Max: 8, Min: 6\nAdded 5, Moving Average: 6, Max: 7, Min: 5\nAdded 4, Moving Average: 5, Max: 6, Min: 4\nAdded 3, Moving Average: 4, Max: 5, Min: 3\nAdded 2, Moving Average: 3, Max: 4, Min: 2\nAdded 1, Moving Average: 2, Max: 3, Min: 1\n\nTest Case: 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\nAdded 5, Moving Average: 5, Max: 5, Min: 5\n\nTest Case: 1, 3, 2, 4, 1, 3, 2, 4, 1, 3\nAdded 1, Moving Average: 1, Max: 1, Min: 1\nAdded 3, Moving Average: 2, Max: 3, Min: 1\nAdded 2, Moving Average: 2, Max: 3, Min: 1\nAdded 4, Moving Average: 3, Max: 4, Min: 2\nAdded 1, Moving Average: 2.3333333333333335, Max: 4, Min: 1\nAdded 3, Moving Average: 2.6666666666666665, Max: 4, Min: 1\nAdded 2, Moving Average: 2, Max: 3, Min: 1\nAdded 4, Moving Average: 3, Max: 4, Min: 2\nAdded 1, Moving Average: 2.3333333333333335, Max: 4, Min: 1\nAdded 3, Moving Average: 2.6666666666666665, Max: 4, Min: 1", "task_id": 21396, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace EnhancedMovingAverageCalculator\n{\n    class TestEnhancedMovingAverage\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Increasing sequence\n            var ema1 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema1.Next(1) == 1.0);\n            Debug.Assert(ema1.GetMax() == 1 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(2) == 1.5);\n            Debug.Assert(ema1.GetMax() == 2 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(3) == 2.0);\n            Debug.Assert(ema1.GetMax() == 3 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(4) == 3.0);\n            Debug.Assert(ema1.GetMax() == 4 && ema1.GetMin() == 2);\n\n            // Test case 2: Decreasing sequence\n            var ema2 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema2.Next(10) == 10.0);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 10);\n            Debug.Assert(ema2.Next(9) == 9.5);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 9);\n            Debug.Assert(ema2.Next(8) == 9.0);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 8);\n            Debug.Assert(ema2.Next(7) == 8.0);\n            Debug.Assert(ema2.GetMax() == 9 && ema2.GetMin() == 7);\n\n            // Test case 3: Constant sequence\n            var ema3 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n\n            // Test case 4: Fluctuating sequence\n            var ema4 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema4.Next(1) == 1.0);\n            Debug.Assert(ema4.GetMax() == 1 && ema4.GetMin() == 1);\n            Debug.Assert(ema4.Next(3) == 2.0);\n            Debug.Assert(ema4.GetMax() == 3 && ema4.GetMin() == 1);\n            Debug.Assert(ema4.Next(2) == 2.0);\n            Debug.Assert(ema4.GetMax() == 3 && ema4.GetMin() == 1);\n            Debug.Assert(Math.Abs(ema4.Next(4) - 3.0) < 0.0001);\n            Debug.Assert(ema4.GetMax() == 4 && ema4.GetMin() == 2);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace EnhancedMovingAverageCalculator\n{\n    // EnhancedMovingAverage class calculates the moving average, maximum, and minimum values within a sliding window of a specified size.\n    public class EnhancedMovingAverage\n    {\n        private int size; // Size of the sliding window\n        private Queue<int> window; // Queue to hold the values in the current window\n        private double sum; // Sum of the values in the current window\n        private int currentMax; // Current maximum value in the window\n        private int currentMin; // Current minimum value in the window\n\n        // Constructor initializes the EnhancedMovingAverage with a specified window size.\n        public EnhancedMovingAverage(int size)\n        {\n            this.size = size;\n            this.window = new Queue<int>();\n            this.sum = 0;\n            this.currentMax = int.MinValue;\n            this.currentMin = int.MaxValue;\n        }\n\n        // Adds a new value to the window and returns the current moving average.\n        public double Next(int val)\n        {\n            // Add new value to the window and update sum\n            window.Enqueue(val);\n            sum += val;\n\n            // Update current max and min\n            if (val > currentMax)\n            {\n                currentMax = val;\n            }\n            if (val < currentMin)\n            {\n                currentMin = val;\n            }\n\n            // If window size exceeds the specified size, remove the oldest value\n            if (window.Count > size)\n            {\n                int removed = window.Dequeue();\n                sum -= removed;\n\n                // Recalculate max and min if the removed value was one of them\n                if (removed == currentMax || removed == currentMin)\n                {\n                    currentMax = int.MinValue;\n                    currentMin = int.MaxValue;\n                    foreach (int num in window)\n                    {\n                        if (num > currentMax)\n                        {\n                            currentMax = num;\n                        }\n                        if (num < currentMin)\n                        {\n                            currentMin = num;\n                        }\n                    }\n                }\n            }\n\n            return sum / window.Count;\n        }\n\n        // Returns the current maximum value in the window.\n        public int GetMax()\n        {\n            return currentMax;\n        }\n\n        // Returns the current minimum value in the window.\n        public int GetMin()\n        {\n            return currentMin;\n        }\n    }\n}\n\nnamespace EnhancedMovingAverageCalculator\n{\n    class TestEnhancedMovingAverage\n    {\n        public static void Main()\n        {\n            // Test case 1: Increasing sequence\n            var ema1 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema1.Next(1) == 1.0);\n            Debug.Assert(ema1.GetMax() == 1 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(2) == 1.5);\n            Debug.Assert(ema1.GetMax() == 2 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(3) == 2.0);\n            Debug.Assert(ema1.GetMax() == 3 && ema1.GetMin() == 1);\n            Debug.Assert(ema1.Next(4) == 3.0);\n            Debug.Assert(ema1.GetMax() == 4 && ema1.GetMin() == 2);\n\n            // Test case 2: Decreasing sequence\n            var ema2 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema2.Next(10) == 10.0);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 10);\n            Debug.Assert(ema2.Next(9) == 9.5);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 9);\n            Debug.Assert(ema2.Next(8) == 9.0);\n            Debug.Assert(ema2.GetMax() == 10 && ema2.GetMin() == 8);\n            Debug.Assert(ema2.Next(7) == 8.0);\n            Debug.Assert(ema2.GetMax() == 9 && ema2.GetMin() == 7);\n\n            // Test case 3: Constant sequence\n            var ema3 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n            Debug.Assert(ema3.Next(5) == 5.0);\n            Debug.Assert(ema3.GetMax() == 5 && ema3.GetMin() == 5);\n\n            // Test case 4: Fluctuating sequence\n            var ema4 = new EnhancedMovingAverage(3);\n            Debug.Assert(ema4.Next(1) == 1.0);\n            Debug.Assert(ema4.GetMax() == 1 && ema4.GetMin() == 1);\n            Debug.Assert(ema4.Next(3) == 2.0);\n            Debug.Assert(ema4.GetMax() == 3 && ema4.GetMin() == 1);\n            Debug.Assert(ema4.Next(2) == 2.0);\n            Debug.Assert(ema4.GetMax() == 3 && ema4.GetMin() == 1);\n            Debug.Assert(Math.Abs(ema4.Next(4) - 3.0) < 0.0001);\n            Debug.Assert(ema4.GetMax() == 4 && ema4.GetMin() == 2);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace MaxSumCalculator\n{\n    class Program\n    {\n        // CalculateMaxSum computes the maximum possible sum based on the given algorithm.\n        // The algorithm involves sorting arrays and selecting specific elements to sum.\n        public static long CalculateMaxSum(int[] a, int[] w)\n        {\n            int n = a.Length;\n            int k = w.Length;\n\n            Array.Sort(a);\n            int[] maxElements = new int[k];\n            Array.Copy(a, n - k, maxElements, 0, k);\n            long sumMax = maxElements.Sum();\n\n            int mZeros = w.Count(wi => wi == 1);\n            long sumZerosMin = mZeros > 0 ? maxElements.TakeLast(mZeros).Sum() : 0;\n\n            int[] nonZeroS = w.Where(wi => wi > 1).Select(wi => wi - 1).ToArray();\n            Array.Sort(nonZeroS);\n\n            int mPart = n - k;\n            int[] aPart = new int[mPart];\n            Array.Copy(a, 0, aPart, 0, mPart);\n\n            long sumNonZeros = 0;\n            foreach (int s in nonZeroS)\n            {\n                int idx = mPart - s;\n                sumNonZeros += aPart[idx];\n            }\n\n            return sumMax + sumZerosMin + sumNonZeros;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput a: [1, 2, 3, 4, 5]\nInput w: [1, 2]\nResult: 17\n\nTest Case 2:\nInput a: [5, 6, 7, 8, 9, 10]\nInput w: [1, 1, 3]\nResult: 52\n\nTest Case 3:\nInput a: [1, 1, 1, 1, 1]\nInput w: [2, 2]\nResult: 4", "task_id": 29791, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxSumCalculator\n{\n    class TestMaxSumCalculator\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            int[] a1 = { 1, 2, 3, 4, 5 };\n            int[] w1 = { 1, 2 };\n            Debug.Assert(Program.CalculateMaxSum(a1, w1) == 17);\n\n            // Test case 2\n            int[] a2 = { 5, 6, 7, 8, 9, 10 };\n            int[] w2 = { 1, 1, 3 };\n            Debug.Assert(Program.CalculateMaxSum(a2, w2) == 52);\n\n            // Test case 3\n            int[] a3 = { 1, 1, 1, 1, 1 };\n            int[] w3 = { 2, 2 };\n            Debug.Assert(Program.CalculateMaxSum(a3, w3) == 4);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace MaxSumCalculator\n{\n    class Program\n    {\n        // CalculateMaxSum computes the maximum possible sum based on the given algorithm.\n        // The algorithm involves sorting arrays and selecting specific elements to sum.\n        public static long CalculateMaxSum(int[] a, int[] w)\n        {\n            int n = a.Length;\n            int k = w.Length;\n\n            Array.Sort(a);\n            int[] maxElements = new int[k];\n            Array.Copy(a, n - k, maxElements, 0, k);\n            long sumMax = maxElements.Sum();\n\n            int mZeros = w.Count(wi => wi == 1);\n            long sumZerosMin = mZeros > 0 ? maxElements.TakeLast(mZeros).Sum() : 0;\n\n            int[] nonZeroS = w.Where(wi => wi > 1).Select(wi => wi - 1).ToArray();\n            Array.Sort(nonZeroS);\n\n            int mPart = n - k;\n            int[] aPart = new int[mPart];\n            Array.Copy(a, 0, aPart, 0, mPart);\n\n            long sumNonZeros = 0;\n            foreach (int s in nonZeroS)\n            {\n                int idx = mPart - s;\n                sumNonZeros += aPart[idx];\n            }\n\n            return sumMax + sumZerosMin + sumNonZeros;\n        }\n    }\n}\n\nnamespace MaxSumCalculator\n{\n    class TestMaxSumCalculator\n    {\n        public static void Main()\n        {\n            // Test case 1\n            int[] a1 = { 1, 2, 3, 4, 5 };\n            int[] w1 = { 1, 2 };\n            Debug.Assert(Program.CalculateMaxSum(a1, w1) == 17);\n\n            // Test case 2\n            int[] a2 = { 5, 6, 7, 8, 9, 10 };\n            int[] w2 = { 1, 1, 3 };\n            Debug.Assert(Program.CalculateMaxSum(a2, w2) == 52);\n\n            // Test case 3\n            int[] a3 = { 1, 1, 1, 1, 1 };\n            int[] w3 = { 2, 2 };\n            Debug.Assert(Program.CalculateMaxSum(a3, w3) == 4);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace PalindromeFinder\n{\n    class Program\n    {\n        // IsPalindrome checks if a given number is a palindrome.\n        // A number is a palindrome if it reads the same forwards and backwards.\n        static bool IsPalindrome(int n)\n        {\n            string numStr = n.ToString();\n            int left = 0;\n            int right = numStr.Length - 1;\n\n            while (left < right)\n            {\n                if (numStr[left] != numStr[right])\n                {\n                    return false;\n                }\n                left++;\n                right--;\n            }\n            return true;\n        }\n\n        // NextPalindrome finds the smallest palindrome number greater than the given number `n`.\n        // It increments the number until it finds a palindrome.\n        static int NextPalindrome(int n)\n        {\n            int m = n + 1;\n            while (!IsPalindrome(m))\n            {\n                m++;\n            }\n            return m;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: 123\nNext Palindrome: 131\nInput: 456\nNext Palindrome: 464\nInput: 789\nNext Palindrome: 797\nInput: 999\nNext Palindrome: 1001\nInput: 1001\nNext Palindrome: 1111", "task_id": 22525, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace PalindromeFinder\n{\n    class TestPalindromeFinder\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.NextPalindrome(123) == 131);\n            Debug.Assert(Program.NextPalindrome(456) == 464);\n            Debug.Assert(Program.NextPalindrome(789) == 797);\n            Debug.Assert(Program.NextPalindrome(999) == 1001);\n            Debug.Assert(Program.NextPalindrome(1001) == 1111);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace PalindromeFinder\n{\n    class Program\n    {\n        // IsPalindrome checks if a given number is a palindrome.\n        // A number is a palindrome if it reads the same forwards and backwards.\n    public static bool IsPalindrome(int n)\n        {\n            string numStr = n.ToString();\n            int left = 0;\n            int right = numStr.Length - 1;\n\n            while (left < right)\n            {\n                if (numStr[left] != numStr[right])\n                {\n                    return false;\n                }\n                left++;\n                right--;\n            }\n            return true;\n        }\n\n        // NextPalindrome finds the smallest palindrome number greater than the given number `n`.\n        // It increments the number until it finds a palindrome.\n    public static int NextPalindrome(int n)\n        {\n            int m = n + 1;\n            while (!IsPalindrome(m))\n            {\n                m++;\n            }\n            return m;\n        }\n    }\n}\n\nnamespace PalindromeFinder\n{\n    class TestPalindromeFinder\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.NextPalindrome(123) == 131);\n            Debug.Assert(Program.NextPalindrome(456) == 464);\n            Debug.Assert(Program.NextPalindrome(789) == 797);\n            Debug.Assert(Program.NextPalindrome(999) == 1001);\n            Debug.Assert(Program.NextPalindrome(1001) == 1111);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace WeekdayFinder\n{\n    class WeekdayUtils\n    {\n        // WeekdaysInRange returns the list of unique weekdays within the given date range inclusive.\n        // If the start date is after the end date, it returns an empty list.\n        // The method uses standard C# DateTime for date manipulation.\n        public static List<string> WeekdaysInRange(string startDate, string endDate)\n        {\n            DateTime start = DateTime.Parse(startDate);\n            DateTime end = DateTime.Parse(endDate);\n\n            if (start > end)\n            {\n                return new List<string>();\n            }\n\n            HashSet<string> weekdays = new HashSet<string>();\n            DateTime currentDate = start;\n\n            while (currentDate <= end)\n            {\n                string weekday = currentDate.DayOfWeek.ToString();\n                weekdays.Add(weekday);\n                currentDate = currentDate.AddDays(1);\n            }\n\n            return new List<string>(weekdays);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: StartDate = 2023-10-01, EndDate = 2023-10-07\nWeekdays: [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]\nInput: StartDate = 2023-10-02, EndDate = 2023-10-06\nWeekdays: [Monday, Tuesday, Wednesday, Thursday, Friday]\nInput: StartDate = 2023-10-07, EndDate = 2023-10-08\nWeekdays: [Saturday, Sunday]\nInput: StartDate = 2023-10-08, EndDate = 2023-10-01\nWeekdays: []", "task_id": 25336, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace WeekdayFinder\n{\n    class TestWeekdayUtils\n    {\n        public static void RunTests()\n        {\n            // Test full week\n            var result1 = WeekdayUtils.WeekdaysInRange(\"2023-10-01\", \"2023-10-07\");\n            Debug.Assert(result1.Count == 7);\n            Debug.Assert(result1.Contains(\"Sunday\"));\n            Debug.Assert(result1.Contains(\"Monday\"));\n            Debug.Assert(result1.Contains(\"Tuesday\"));\n            Debug.Assert(result1.Contains(\"Wednesday\"));\n            Debug.Assert(result1.Contains(\"Thursday\"));\n            Debug.Assert(result1.Contains(\"Friday\"));\n            Debug.Assert(result1.Contains(\"Saturday\"));\n\n            // Test weekdays only\n            var result2 = WeekdayUtils.WeekdaysInRange(\"2023-10-02\", \"2023-10-06\");\n            Debug.Assert(result2.Count == 5);\n            Debug.Assert(result2.Contains(\"Monday\"));\n            Debug.Assert(result2.Contains(\"Tuesday\"));\n            Debug.Assert(result2.Contains(\"Wednesday\"));\n            Debug.Assert(result2.Contains(\"Thursday\"));\n            Debug.Assert(result2.Contains(\"Friday\"));\n            Debug.Assert(!result2.Contains(\"Saturday\"));\n            Debug.Assert(!result2.Contains(\"Sunday\"));\n\n            // Test weekend only\n            var result3 = WeekdayUtils.WeekdaysInRange(\"2023-10-07\", \"2023-10-08\");\n            Debug.Assert(result3.Count == 2);\n            Debug.Assert(result3.Contains(\"Saturday\"));\n            Debug.Assert(result3.Contains(\"Sunday\"));\n            Debug.Assert(!result3.Contains(\"Monday\"));\n\n            // Test invalid range\n            var result4 = WeekdayUtils.WeekdaysInRange(\"2023-10-08\", \"2023-10-01\");\n            Debug.Assert(result4.Count == 0);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace WeekdayFinder\n{\n    class WeekdayUtils\n    {\n        // WeekdaysInRange returns the list of unique weekdays within the given date range inclusive.\n        // If the start date is after the end date, it returns an empty list.\n        // The method uses standard C# DateTime for date manipulation.\n        public static List<string> WeekdaysInRange(string startDate, string endDate)\n        {\n            DateTime start = DateTime.Parse(startDate);\n            DateTime end = DateTime.Parse(endDate);\n\n            if (start > end)\n            {\n                return new List<string>();\n            }\n\n            HashSet<string> weekdays = new HashSet<string>();\n            DateTime currentDate = start;\n\n            while (currentDate <= end)\n            {\n                string weekday = currentDate.DayOfWeek.ToString();\n                weekdays.Add(weekday);\n                currentDate = currentDate.AddDays(1);\n            }\n\n            return new List<string>(weekdays);\n        }\n    }\n}\n\nnamespace WeekdayFinder\n{\n    class TestWeekdayUtils\n    {\n        public static void Main()\n        {\n            // Test full week\n            var result1 = WeekdayUtils.WeekdaysInRange(\"2023-10-01\", \"2023-10-07\");\n            Debug.Assert(result1.Count == 7);\n            Debug.Assert(result1.Contains(\"Sunday\"));\n            Debug.Assert(result1.Contains(\"Monday\"));\n            Debug.Assert(result1.Contains(\"Tuesday\"));\n            Debug.Assert(result1.Contains(\"Wednesday\"));\n            Debug.Assert(result1.Contains(\"Thursday\"));\n            Debug.Assert(result1.Contains(\"Friday\"));\n            Debug.Assert(result1.Contains(\"Saturday\"));\n\n            // Test weekdays only\n            var result2 = WeekdayUtils.WeekdaysInRange(\"2023-10-02\", \"2023-10-06\");\n            Debug.Assert(result2.Count == 5);\n            Debug.Assert(result2.Contains(\"Monday\"));\n            Debug.Assert(result2.Contains(\"Tuesday\"));\n            Debug.Assert(result2.Contains(\"Wednesday\"));\n            Debug.Assert(result2.Contains(\"Thursday\"));\n            Debug.Assert(result2.Contains(\"Friday\"));\n            Debug.Assert(!result2.Contains(\"Saturday\"));\n            Debug.Assert(!result2.Contains(\"Sunday\"));\n\n            // Test weekend only\n            var result3 = WeekdayUtils.WeekdaysInRange(\"2023-10-07\", \"2023-10-08\");\n            Debug.Assert(result3.Count == 2);\n            Debug.Assert(result3.Contains(\"Saturday\"));\n            Debug.Assert(result3.Contains(\"Sunday\"));\n            Debug.Assert(!result3.Contains(\"Monday\"));\n\n            // Test invalid range\n            var result4 = WeekdayUtils.WeekdaysInRange(\"2023-10-08\", \"2023-10-01\");\n            Debug.Assert(result4.Count == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace MaximumSumCalculator\n{\n    class Program\n    {\n        // CalculateMaximumSum calculates the maximum possible sum based on the given rules.\n        // The rules are:\n        // 1. Start with the sum of all 'B' elements in the array.\n        // 2. Add the maximum prefix or suffix sum of the transformed array where 'B' elements are negated.\n        static int CalculateMaximumSum(int[] p, string s)\n        {\n            int n = p.Length;\n            int sumB = 0;\n            int[] d = new int[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                if (s[i] == 'B')\n                {\n                    sumB += p[i];\n                    d[i] = -p[i];\n                }\n                else\n                {\n                    d[i] = p[i];\n                }\n            }\n\n            int maxPrefix = 0;\n            int currentPrefix = 0;\n            foreach (int num in d)\n            {\n                currentPrefix += num;\n                if (currentPrefix > maxPrefix)\n                {\n                    maxPrefix = currentPrefix;\n                }\n            }\n\n            int maxSuffix = 0;\n            int currentSuffix = 0;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                currentSuffix += d[i];\n                if (currentSuffix > maxSuffix)\n                {\n                    maxSuffix = currentSuffix;\n                }\n            }\n\n            return sumB + Math.Max(maxPrefix, Math.Max(maxSuffix, 0));\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input p: [1, 2, 3, 4], s: \"ABBA\"\nResult: 9\nInput p: [5, 6, 7, 0], s: \"BBAB\"\nResult: 18\nInput p: [0, 0, 0, 0], s: \"AAAA\"\nResult: 0\nInput p: [10, 20, 30, 40], s: \"BBBB\"\nResult: 100\nInput p: [5, 3, 2, 8], s: \"ABAB\"\nResult: 16", "task_id": 26392, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaximumSumCalculator\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 1, 2, 3, 4 }, \"ABBA\") == 9);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 5, 6, 7, 0 }, \"BBAB\") == 18);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 0, 0, 0, 0 }, \"AAAA\") == 0);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 10, 20, 30, 40 }, \"BBBB\") == 100);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 5, 3, 2, 8 }, \"ABAB\") == 16);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace MaximumSumCalculator\n{\n    class Program\n    {\n        // CalculateMaximumSum calculates the maximum possible sum based on the given rules.\n        // The rules are:\n        // 1. Start with the sum of all 'B' elements in the array.\n        // 2. Add the maximum prefix or suffix sum of the transformed array where 'B' elements are negated.\n    public static int CalculateMaximumSum(int[] p, string s)\n        {\n            int n = p.Length;\n            int sumB = 0;\n            int[] d = new int[n];\n\n            for (int i = 0; i < n; i++)\n            {\n                if (s[i] == 'B')\n                {\n                    sumB += p[i];\n                    d[i] = -p[i];\n                }\n                else\n                {\n                    d[i] = p[i];\n                }\n            }\n\n            int maxPrefix = 0;\n            int currentPrefix = 0;\n            foreach (int num in d)\n            {\n                currentPrefix += num;\n                if (currentPrefix > maxPrefix)\n                {\n                    maxPrefix = currentPrefix;\n                }\n            }\n\n            int maxSuffix = 0;\n            int currentSuffix = 0;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                currentSuffix += d[i];\n                if (currentSuffix > maxSuffix)\n                {\n                    maxSuffix = currentSuffix;\n                }\n            }\n\n            return sumB + Math.Max(maxPrefix, Math.Max(maxSuffix, 0));\n        }\n    }\n}\n\nnamespace MaximumSumCalculator\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 1, 2, 3, 4 }, \"ABBA\") == 9);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 5, 6, 7, 0 }, \"BBAB\") == 18);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 0, 0, 0, 0 }, \"AAAA\") == 0);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 10, 20, 30, 40 }, \"BBBB\") == 100);\n            Debug.Assert(Program.CalculateMaximumSum(new int[] { 5, 3, 2, 8 }, \"ABAB\") == 16);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace PostfixEvaluator\n{\n    class Program\n    {\n        // Evaluates a postfix (Reverse Polish) expression and returns the result as an integer.\n        // The expression is provided as a string where operands and operators are separated by spaces.\n        // Supported operators are +, -, *, / (integer division truncating toward zero).\n        public static int EvaluatePostfix(string expr)\n        {\n            Stack<int> stack = new Stack<int>();\n            string[] tokens = expr.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (string token in tokens)\n            {\n                if (int.TryParse(token, out int number))\n                {\n                    stack.Push(number);\n                }\n                else if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\")\n                {\n                    int b = stack.Pop();\n                    int a = stack.Pop();\n                    int result = 0;\n\n                    switch (token)\n                    {\n                        case \"+\":\n                            result = a + b;\n                            break;\n                        case \"-\":\n                            result = a - b;\n                            break;\n                        case \"*\":\n                            result = a * b;\n                            break;\n                        case \"/\":\n                            result = a / b; // performs integer division truncating toward zero\n                            break;\n                    }\n\n                    stack.Push(result);\n                }\n                else\n                {\n                    throw new ArgumentException($\"Invalid token: {token}\");\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: 3 4 +\nResult: 7\nInput: 5 2 -\nResult: 3\nInput: 4 5 *\nResult: 20\nInput: 20 5 /\nResult: 4\nInput: 10 6 9 3 + - *\nResult: -60\nInput: 2 3 1 * + 9 -\nResult: -4", "task_id": 2630, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace PostfixEvaluator\n{\n    class TestPostfixEvaluator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.EvaluatePostfix(\"3 4 +\") == 7);\n            Debug.Assert(Program.EvaluatePostfix(\"5 2 -\") == 3);\n            Debug.Assert(Program.EvaluatePostfix(\"4 5 *\") == 20);\n            Debug.Assert(Program.EvaluatePostfix(\"20 5 /\") == 4);\n            Debug.Assert(Program.EvaluatePostfix(\"10 6 9 3 + - *\") == -60);\n            Debug.Assert(Program.EvaluatePostfix(\"2 3 1 * + 9 -\") == -4);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace PostfixEvaluator\n{\n    class Program\n    {\n        // Evaluates a postfix (Reverse Polish) expression and returns the result as an integer.\n        // The expression is provided as a string where operands and operators are separated by spaces.\n        // Supported operators are +, -, *, / (integer division truncating toward zero).\n        public static int EvaluatePostfix(string expr)\n        {\n            Stack<int> stack = new Stack<int>();\n            string[] tokens = expr.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\n\n            foreach (string token in tokens)\n            {\n                if (int.TryParse(token, out int number))\n                {\n                    stack.Push(number);\n                }\n                else if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\")\n                {\n                    int b = stack.Pop();\n                    int a = stack.Pop();\n                    int result = 0;\n\n                    switch (token)\n                    {\n                        case \"+\":\n                            result = a + b;\n                            break;\n                        case \"-\":\n                            result = a - b;\n                            break;\n                        case \"*\":\n                            result = a * b;\n                            break;\n                        case \"/\":\n                            result = a / b; // performs integer division truncating toward zero\n                            break;\n                    }\n\n                    stack.Push(result);\n                }\n                else\n                {\n                    throw new ArgumentException($\"Invalid token: {token}\");\n                }\n            }\n\n            return stack.Pop();\n        }\n    }\n}\n\nnamespace PostfixEvaluator\n{\n    class TestPostfixEvaluator\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.EvaluatePostfix(\"3 4 +\") == 7);\n            Debug.Assert(Program.EvaluatePostfix(\"5 2 -\") == 3);\n            Debug.Assert(Program.EvaluatePostfix(\"4 5 *\") == 20);\n            Debug.Assert(Program.EvaluatePostfix(\"20 5 /\") == 4);\n            Debug.Assert(Program.EvaluatePostfix(\"10 6 9 3 + - *\") == -60);\n            Debug.Assert(Program.EvaluatePostfix(\"2 3 1 * + 9 -\") == -4);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace ProductCalculator\n{\n    class Program\n    {\n        // ProductOfList calculates the product of all numbers in the given array.\n        // If the array is empty, it returns 1.\n        public static int ProductOfList(int[] numbers)\n        {\n            if (numbers.Length == 0)\n            {\n                return 1;\n            }\n            int product = 1;\n            foreach (int number in numbers)\n            {\n                product *= number;\n            }\n            return product;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nProduct: 24\nInput: [5, 6, 7, 0]\nProduct: 0\nInput: []\nProduct: 1\nInput: [10, -2, 3]\nProduct: -60", "task_id": 15122, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ProductCalculator\n{\n    class TestProductCalculator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.ProductOfList(new int[] { 1, 2, 3, 4 }) == 24);\n            Debug.Assert(Program.ProductOfList(new int[] { 5, 6, 7, 0 }) == 0);\n            Debug.Assert(Program.ProductOfList(new int[] { }) == 1);\n            Debug.Assert(Program.ProductOfList(new int[] { 10, -2, 3 }) == -60);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace ProductCalculator\n{\n    class Program\n    {\n        // ProductOfList calculates the product of all numbers in the given array.\n        // If the array is empty, it returns 1.\n        public static int ProductOfList(int[] numbers)\n        {\n            if (numbers.Length == 0)\n            {\n                return 1;\n            }\n            int product = 1;\n            foreach (int number in numbers)\n            {\n                product *= number;\n            }\n            return product;\n        }\n    }\n}\n\nnamespace ProductCalculator\n{\n    class TestProductCalculator\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.ProductOfList(new int[] { 1, 2, 3, 4 }) == 24);\n            Debug.Assert(Program.ProductOfList(new int[] { 5, 6, 7, 0 }) == 0);\n            Debug.Assert(Program.ProductOfList(new int[] { }) == 1);\n            Debug.Assert(Program.ProductOfList(new int[] { 10, -2, 3 }) == -60);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ProcessSimulator\n{\n    class Program\n    {\n        /// <summary>\n        /// Finds the maximum number of processes running simultaneously given their start and end times.\n        /// </summary>\n        /// <param name=\"n\">The number of processes.</param>\n        /// <param name=\"intervals\">Array of tuples where each tuple contains start and end times of a process.</param>\n        /// <returns>The maximum number of processes running simultaneously.</returns>\n        static int MaxSimultaneousProcesses(int n, (int Start, int End)[] intervals)\n        {\n            // Create a list to store all events (start and end times)\n            List<(int Time, string EventType)> events = new List<(int, string)>();\n\n            // Populate the events list with start and end events\n            foreach (var interval in intervals)\n            {\n                events.Add((interval.Start, \"start\"));\n                events.Add((interval.End, \"end\"));\n            }\n\n            // Sort the events based on time. If times are equal, end events come before start events.\n            events = events.OrderBy(e => e.Time).ThenBy(e => e.EventType).ToList();\n\n            int maxProcesses = 0;\n            int currentProcesses = 0;\n\n            // Iterate through each event to calculate the maximum number of simultaneous processes\n            foreach (var evt in events)\n            {\n                if (evt.EventType == \"start\")\n                {\n                    currentProcesses++;\n                    maxProcesses = Math.Max(maxProcesses, currentProcesses);\n                }\n                else\n                {\n                    currentProcesses--;\n                }\n            }\n\n            return maxProcesses;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: N = 3, Intervals = [(1, 4), (2, 5), (3, 6)]\nMaximum simultaneous processes: 3\n\nInput: N = 4, Intervals = [(1, 3), (2, 4), (5, 7), (6, 8)]\nMaximum simultaneous processes: 2\n\nInput: N = 2, Intervals = [(1, 10), (5, 6)]\nMaximum simultaneous processes: 2\n\nInput: N = 1, Intervals = [(1, 2)]\nMaximum simultaneous processes: 1", "task_id": 20256, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace ProcessSimulator\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var intervals1 = new[] { (1, 4), (2, 5), (3, 6) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(3, intervals1) == 3);\n\n            // Test case 2\n            var intervals2 = new[] { (1, 3), (2, 4), (5, 7), (6, 8) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(4, intervals2) == 2);\n\n            // Test case 3\n            var intervals3 = new[] { (1, 10), (5, 6) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(2, intervals3) == 2);\n\n            // Test case 4\n            var intervals4 = new[] { (1, 2) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(1, intervals4) == 1);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace ProcessSimulator\n{\n    class Program\n    {\n        /// <summary>\n        /// Finds the maximum number of processes running simultaneously given their start and end times.\n        /// </summary>\n        /// <param name=\"n\">The number of processes.</param>\n        /// <param name=\"intervals\">Array of tuples where each tuple contains start and end times of a process.</param>\n        /// <returns>The maximum number of processes running simultaneously.</returns>\n    public static int MaxSimultaneousProcesses(int n, (int Start, int End)[] intervals)\n        {\n            // Create a list to store all events (start and end times)\n            List<(int Time, string EventType)> events = new List<(int, string)>();\n\n            // Populate the events list with start and end events\n            foreach (var interval in intervals)\n            {\n                events.Add((interval.Start, \"start\"));\n                events.Add((interval.End, \"end\"));\n            }\n\n            // Sort the events based on time. If times are equal, end events come before start events.\n            events = events.OrderBy(e => e.Time).ThenBy(e => e.EventType).ToList();\n\n            int maxProcesses = 0;\n            int currentProcesses = 0;\n\n            // Iterate through each event to calculate the maximum number of simultaneous processes\n            foreach (var evt in events)\n            {\n                if (evt.EventType == \"start\")\n                {\n                    currentProcesses++;\n                    maxProcesses = Math.Max(maxProcesses, currentProcesses);\n                }\n                else\n                {\n                    currentProcesses--;\n                }\n            }\n\n            return maxProcesses;\n        }\n    }\n}\n\nnamespace ProcessSimulator\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var intervals1 = new[] { (1, 4), (2, 5), (3, 6) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(3, intervals1) == 3);\n\n            // Test case 2\n            var intervals2 = new[] { (1, 3), (2, 4), (5, 7), (6, 8) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(4, intervals2) == 2);\n\n            // Test case 3\n            var intervals3 = new[] { (1, 10), (5, 6) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(2, intervals3) == 2);\n\n            // Test case 4\n            var intervals4 = new[] { (1, 2) };\n            Debug.Assert(Program.MaxSimultaneousProcesses(1, intervals4) == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace Solution\n{\n    class Program\n    {\n        // Determines the result based on the values of S and K.\n        // The logic is as follows:\n        // - If K is 1, the result is 1 if S is odd, otherwise 0.\n        // - If K is even, the result depends on S modulo (K + 1).\n        // - If K is odd and greater than 1, the result is 1 if S is odd, otherwise 0.\n        static int Solve(int S, int K)\n        {\n            if (K == 1)\n            {\n                return S % 2 == 1 ? 1 : 0;\n            }\n            else if (K % 2 == 0)\n            {\n                int mod = K + 1;\n                int modResult = S % mod;\n                if (modResult == 0)\n                {\n                    return 0;\n                }\n                else if (modResult == 1)\n                {\n                    return 1;\n                }\n                else if (modResult == K)\n                {\n                    return K <= S ? K : 0;\n                }\n                else\n                {\n                    return 0;\n                }\n            }\n            else // K is odd and greater than 1\n            {\n                return S % 2 == 0 ? 0 : 1;\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: S = 5, K = 1\nResult: 1\nInput: S = 4, K = 1\nResult: 0\nInput: S = 7, K = 2\nResult: 1\nInput: S = 6, K = 2\nResult: 0\nInput: S = 8, K = 4\nResult: 0\nInput: S = 5, K = 3\nResult: 1\nInput: S = 6, K = 3\nResult: 0", "task_id": 20594, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace Solution\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.Solve(5, 1) == 1);\n            Debug.Assert(Program.Solve(4, 1) == 0);\n            Debug.Assert(Program.Solve(7, 2) == 1);\n            Debug.Assert(Program.Solve(6, 2) == 0);\n            Debug.Assert(Program.Solve(8, 4) == 0);\n            Debug.Assert(Program.Solve(5, 3) == 1);\n            Debug.Assert(Program.Solve(6, 3) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace Solution\n{\n    class Program\n    {\n        // Determines the result based on the values of S and K.\n        // The logic is as follows:\n        // - If K is 1, the result is 1 if S is odd, otherwise 0.\n        // - If K is even, the result depends on S modulo (K + 1).\n        // - If K is odd and greater than 1, the result is 1 if S is odd, otherwise 0.\n    public static int Solve(int S, int K)\n        {\n            if (K == 1)\n            {\n                return S % 2 == 1 ? 1 : 0;\n            }\n            else if (K % 2 == 0)\n            {\n                int mod = K + 1;\n                int modResult = S % mod;\n                if (modResult == 0)\n                {\n                    return 0;\n                }\n                else if (modResult == 1)\n                {\n                    return 1;\n                }\n                else if (modResult == K)\n                {\n                    return K <= S ? K : 0;\n                }\n                else\n                {\n                    return 0;\n                }\n            }\n            else // K is odd and greater than 1\n            {\n                return S % 2 == 0 ? 0 : 1;\n            }\n        }\n    }\n}\n\nnamespace Solution\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.Solve(5, 1) == 1);\n            Debug.Assert(Program.Solve(4, 1) == 0);\n            Debug.Assert(Program.Solve(7, 2) == 1);\n            Debug.Assert(Program.Solve(6, 2) == 0);\n            Debug.Assert(Program.Solve(8, 4) == 0);\n            Debug.Assert(Program.Solve(5, 3) == 1);\n            Debug.Assert(Program.Solve(6, 3) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace SquaredDifferenceCalculator\n{\n    class SquaredDifferenceCalculator\n    {\n        // Calculates the squared difference between the optimal partitioning and the total sum of squares\n        public static double CalculateSquaredDifference(int[] a)\n        {\n            double sumASq = 0;\n            foreach (int x in a)\n            {\n                sumASq += x * x;\n            }\n            double sumTSqTotal = sumASq / 4.0;\n\n            var stack = new Stack<(double sumT, double sumT2, int lenInterval, double avg)>();\n\n            foreach (int ai in a)\n            {\n                double ti = ai / 2.0;\n                double sumT = ti;\n                double sumT2 = ti * ti;\n                int lenInterval = 1;\n                double avg = ti;\n                stack.Push((sumT, sumT2, lenInterval, avg));\n\n                while (stack.Count >= 2)\n                {\n                    var curr = stack.Pop();\n                    var prev = stack.Pop();\n                    if (prev.avg <= curr.avg)\n                    {\n                        stack.Push(prev);\n                        stack.Push(curr);\n                        break;\n                    }\n                    double mergedSumT = prev.sumT + curr.sumT;\n                    double mergedSumT2 = prev.sumT2 + curr.sumT2;\n                    int mergedLen = prev.lenInterval + curr.lenInterval;\n                    double mergedAvg = mergedSumT / mergedLen;\n                    stack.Push((mergedSumT, mergedSumT2, mergedLen, mergedAvg));\n                }\n            }\n\n            double totalSquaredDiff = 0.0;\n            foreach (var item in stack)\n            {\n                totalSquaredDiff += item.sumT2 - (item.sumT * item.sumT) / item.lenInterval;\n            }\n\n            return totalSquaredDiff - sumTSqTotal;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4]\nResult: -7.5000000\n\nInput array: [4, 4, 4, 4]\nResult: -16.0000000\n\nInput array: [10, 20, 30, 40]\nResult: -750.0000000\n\nInput array: [5, 1, 8, 6]\nResult: -29.0000000", "task_id": 28940, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace SquaredDifferenceCalculator\n{\n    class TestSquaredDifferenceCalculator\n    {\n        public static void RunTests()\n        {\n            // Test cases with expected results from the test case results\n            int[] testCase1 = { 1, 2, 3, 4 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase1) - (-7.5)) < 0.0001);\n\n            int[] testCase2 = { 4, 4, 4, 4 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase2) - (-16.0)) < 0.0001);\n\n            int[] testCase3 = { 10, 20, 30, 40 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase3) - (-750.0)) < 0.0001);\n\n            int[] testCase4 = { 5, 1, 8, 6 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase4) - (-29.0)) < 0.0001);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace SquaredDifferenceCalculator\n{\n    class SquaredDifferenceCalculator\n    {\n        // Calculates the squared difference between the optimal partitioning and the total sum of squares\n        public static double CalculateSquaredDifference(int[] a)\n        {\n            double sumASq = 0;\n            foreach (int x in a)\n            {\n                sumASq += x * x;\n            }\n            double sumTSqTotal = sumASq / 4.0;\n\n            var stack = new Stack<(double sumT, double sumT2, int lenInterval, double avg)>();\n\n            foreach (int ai in a)\n            {\n                double ti = ai / 2.0;\n                double sumT = ti;\n                double sumT2 = ti * ti;\n                int lenInterval = 1;\n                double avg = ti;\n                stack.Push((sumT, sumT2, lenInterval, avg));\n\n                while (stack.Count >= 2)\n                {\n                    var curr = stack.Pop();\n                    var prev = stack.Pop();\n                    if (prev.avg <= curr.avg)\n                    {\n                        stack.Push(prev);\n                        stack.Push(curr);\n                        break;\n                    }\n                    double mergedSumT = prev.sumT + curr.sumT;\n                    double mergedSumT2 = prev.sumT2 + curr.sumT2;\n                    int mergedLen = prev.lenInterval + curr.lenInterval;\n                    double mergedAvg = mergedSumT / mergedLen;\n                    stack.Push((mergedSumT, mergedSumT2, mergedLen, mergedAvg));\n                }\n            }\n\n            double totalSquaredDiff = 0.0;\n            foreach (var item in stack)\n            {\n                totalSquaredDiff += item.sumT2 - (item.sumT * item.sumT) / item.lenInterval;\n            }\n\n            return totalSquaredDiff - sumTSqTotal;\n        }\n    }\n}\n\nnamespace SquaredDifferenceCalculator\n{\n    class TestSquaredDifferenceCalculator\n    {\n        public static void Main()\n        {\n            // Test cases with expected results from the test case results\n            int[] testCase1 = { 1, 2, 3, 4 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase1) - (-7.5)) < 0.0001);\n\n            int[] testCase2 = { 4, 4, 4, 4 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase2) - (-16.0)) < 0.0001);\n\n            int[] testCase3 = { 10, 20, 30, 40 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase3) - (-750.0)) < 0.0001);\n\n            int[] testCase4 = { 5, 1, 8, 6 };\n            Debug.Assert(Math.Abs(SquaredDifferenceCalculator.CalculateSquaredDifference(testCase4) - (-29.0)) < 0.0001);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace SunlightViewBuildings\n{\n    class Program\n    {\n        // Determines which buildings have a sunlight view from the left.\n        // A building has a sunlight view if it is taller than all buildings to its left.\n        // Returns a list of indices of buildings that have the sunlight view.\n        public static List<int> BuildingsWithSunlightView(int[] heights)\n        {\n            int maxHeight = -1;\n            List<int> indices = new List<int>();\n            \n            for (int i = 0; i < heights.Length; i++)\n            {\n                if (heights[i] > maxHeight)\n                {\n                    indices.Add(i);\n                    maxHeight = heights[i];\n                }\n            }\n            \n            return indices;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Heights: 1, 2, 3, 4\nBuildings with Sunlight View: 0, 1, 2, 3\n\nInput Heights: 4, 3, 2, 1\nBuildings with Sunlight View: 0\n\nInput Heights: 2, 1, 3, 4\nBuildings with Sunlight View: 0, 2, 3\n\nInput Heights: 1, 1, 1, 1\nBuildings with Sunlight View: 0\n\nInput Heights: 5, 2, 4, 3, 6\nBuildings with Sunlight View: 0, 4", "task_id": 29504, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace SunlightViewBuildings\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1: All buildings have sunlight view\n            var result1 = Program.BuildingsWithSunlightView(new int[] { 1, 2, 3, 4 });\n            Debug.Assert(result1.Count == 4 && result1[0] == 0 && result1[1] == 1 && result1[2] == 2 && result1[3] == 3);\n\n            // Test case 2: Only the first building has sunlight view\n            var result2 = Program.BuildingsWithSunlightView(new int[] { 4, 3, 2, 1 });\n            Debug.Assert(result2.Count == 1 && result2[0] == 0);\n\n            // Test case 3: Buildings at indices 0, 2, 3 have sunlight view\n            var result3 = Program.BuildingsWithSunlightView(new int[] { 2, 1, 3, 4 });\n            Debug.Assert(result3.Count == 3 && result3[0] == 0 && result3[1] == 2 && result3[2] == 3);\n\n            // Test case 4: Only the first building has sunlight view\n            var result4 = Program.BuildingsWithSunlightView(new int[] { 1, 1, 1, 1 });\n            Debug.Assert(result4.Count == 1 && result4[0] == 0);\n\n            // Test case 5: Buildings at indices 0, 4 have sunlight view\n            var result5 = Program.BuildingsWithSunlightView(new int[] { 5, 2, 4, 3, 6 });\n            Debug.Assert(result5.Count == 2 && result5[0] == 0 && result5[1] == 4);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace SunlightViewBuildings\n{\n    class Program\n    {\n        // Determines which buildings have a sunlight view from the left.\n        // A building has a sunlight view if it is taller than all buildings to its left.\n        // Returns a list of indices of buildings that have the sunlight view.\n        public static List<int> BuildingsWithSunlightView(int[] heights)\n        {\n            int maxHeight = -1;\n            List<int> indices = new List<int>();\n            \n            for (int i = 0; i < heights.Length; i++)\n            {\n                if (heights[i] > maxHeight)\n                {\n                    indices.Add(i);\n                    maxHeight = heights[i];\n                }\n            }\n            \n            return indices;\n        }\n    }\n}\n\nnamespace SunlightViewBuildings\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1: All buildings have sunlight view\n            var result1 = Program.BuildingsWithSunlightView(new int[] { 1, 2, 3, 4 });\n            Debug.Assert(result1.Count == 4 && result1[0] == 0 && result1[1] == 1 && result1[2] == 2 && result1[3] == 3);\n\n            // Test case 2: Only the first building has sunlight view\n            var result2 = Program.BuildingsWithSunlightView(new int[] { 4, 3, 2, 1 });\n            Debug.Assert(result2.Count == 1 && result2[0] == 0);\n\n            // Test case 3: Buildings at indices 0, 2, 3 have sunlight view\n            var result3 = Program.BuildingsWithSunlightView(new int[] { 2, 1, 3, 4 });\n            Debug.Assert(result3.Count == 3 && result3[0] == 0 && result3[1] == 2 && result3[2] == 3);\n\n            // Test case 4: Only the first building has sunlight view\n            var result4 = Program.BuildingsWithSunlightView(new int[] { 1, 1, 1, 1 });\n            Debug.Assert(result4.Count == 1 && result4[0] == 0);\n\n            // Test case 5: Buildings at indices 0, 4 have sunlight view\n            var result5 = Program.BuildingsWithSunlightView(new int[] { 5, 2, 4, 3, 6 });\n            Debug.Assert(result5.Count == 2 && result5[0] == 0 && result5[1] == 4);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MaxContiguousSubsequenceWeight\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum possible weight a contiguous subsequence of rocks can have\n        /// without exceeding the given weight limit W.\n        /// </summary>\n        /// <param name=\"n\">Number of rocks</param>\n        /// <param name=\"W\">Maximum weight the sack can carry</param>\n        /// <param name=\"weights\">Array containing weights of the rocks</param>\n        /// <returns>Maximum weight without exceeding W</returns>\n        public static int MaxWeight(int n, int W, int[] weights)\n        {\n            int maxWeightFound = 0;\n            int currentSum = 0;\n            int start = 0;\n            \n            for (int end = 0; end < n; end++)\n            {\n                currentSum += weights[end];\n                \n                while (currentSum > W)\n                {\n                    currentSum -= weights[start];\n                    start++;\n                }\n                \n                maxWeightFound = Math.Max(maxWeightFound, currentSum);\n            }\n            \n            return maxWeightFound;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 5, W = 10, weights = [1, 2, 3, 4, 5]\nMaximum weight without exceeding W: 10\n\nInput: n = 4, W = 8, weights = [5, 2, 1, 6]\nMaximum weight without exceeding W: 8\n\nInput: n = 3, W = 5, weights = [6, 7, 8]\nMaximum weight without exceeding W: 0\n\nInput: n = 6, W = 15, weights = [10, 5, 3, 7, 2, 8]\nMaximum weight without exceeding W: 15", "task_id": 18502, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxContiguousSubsequenceWeight\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.MaxWeight(5, 10, new int[] { 1, 2, 3, 4, 5 }) == 10);\n            Debug.Assert(Program.MaxWeight(4, 8, new int[] { 5, 2, 1, 6 }) == 8);\n            Debug.Assert(Program.MaxWeight(3, 5, new int[] { 6, 7, 8 }) == 0);\n            Debug.Assert(Program.MaxWeight(6, 15, new int[] { 10, 5, 3, 7, 2, 8 }) == 15);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MaxContiguousSubsequenceWeight\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum possible weight a contiguous subsequence of rocks can have\n        /// without exceeding the given weight limit W.\n        /// </summary>\n        /// <param name=\"n\">Number of rocks</param>\n        /// <param name=\"W\">Maximum weight the sack can carry</param>\n        /// <param name=\"weights\">Array containing weights of the rocks</param>\n        /// <returns>Maximum weight without exceeding W</returns>\n        public static int MaxWeight(int n, int W, int[] weights)\n        {\n            int maxWeightFound = 0;\n            int currentSum = 0;\n            int start = 0;\n            \n            for (int end = 0; end < n; end++)\n            {\n                currentSum += weights[end];\n                \n                while (currentSum > W)\n                {\n                    currentSum -= weights[start];\n                    start++;\n                }\n                \n                maxWeightFound = Math.Max(maxWeightFound, currentSum);\n            }\n            \n            return maxWeightFound;\n        }\n    }\n}\n\nnamespace MaxContiguousSubsequenceWeight\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.MaxWeight(5, 10, new int[] { 1, 2, 3, 4, 5 }) == 10);\n            Debug.Assert(Program.MaxWeight(4, 8, new int[] { 5, 2, 1, 6 }) == 8);\n            Debug.Assert(Program.MaxWeight(3, 5, new int[] { 6, 7, 8 }) == 0);\n            Debug.Assert(Program.MaxWeight(6, 15, new int[] { 10, 5, 3, 7, 2, 8 }) == 15);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace MinAssemblyTimeCalculator\n{\n    class Program\n    {\n        // CalculateMinAssemblyTime computes the minimum total time required to assemble all components.\n        // The components are assembled two at a time, and each assembly operation's time is the sum of the two components' complexities.\n        // The method uses a min-heap to always pick the two smallest complexities for the next assembly to minimize the total time.\n        public static int CalculateMinAssemblyTime(int[] complexities)\n        {\n            if (complexities.Length == 1)\n            {\n                return 0;\n            }\n\n            var minHeap = new PriorityQueue<int, int>();\n            foreach (var complexity in complexities)\n            {\n                minHeap.Enqueue(complexity, complexity);\n            }\n\n            int totalTime = 0;\n            while (minHeap.Count > 1)\n            {\n                int a = minHeap.Dequeue();\n                int b = minHeap.Dequeue();\n                int time = a + b;\n                totalTime += time;\n                minHeap.Enqueue(time, time);\n            }\n\n            return totalTime;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: [1, 2, 9]\nMinimum Assembly Time: 15\n\nTest Case 2:\nInput: [1, 2, 3, 4]\nMinimum Assembly Time: 19\n\nTest Case 3:\nInput: [5]\nMinimum Assembly Time: 0\n\nTest Case 4:\nInput: [3, 3, 3]\nMinimum Assembly Time: 15", "task_id": 12916, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace MinAssemblyTimeCalculator\n{\n    class TestMinAssemblyTime\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Provided example with complexities [1, 2, 9]\n            int[] testCase1 = { 1, 2, 9 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase1) == 15);\n\n            // Test case 2: Another example with complexities [1, 2, 3, 4]\n            int[] testCase2 = { 1, 2, 3, 4 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase2) == 19);\n\n            // Test case 3: Edge case with a single component [5]\n            int[] testCase3 = { 5 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase3) == 0);\n\n            // Test case 4: All components have the same complexity [3, 3, 3]\n            int[] testCase4 = { 3, 3, 3 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase4) == 15);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace MinAssemblyTimeCalculator\n{\n    class Program\n    {\n        // CalculateMinAssemblyTime computes the minimum total time required to assemble all components.\n        // The components are assembled two at a time, and each assembly operation's time is the sum of the two components' complexities.\n        // The method uses a min-heap to always pick the two smallest complexities for the next assembly to minimize the total time.\n        public static int CalculateMinAssemblyTime(int[] complexities)\n        {\n            if (complexities.Length == 1)\n            {\n                return 0;\n            }\n\n            var minHeap = new PriorityQueue<int, int>();\n            foreach (var complexity in complexities)\n            {\n                minHeap.Enqueue(complexity, complexity);\n            }\n\n            int totalTime = 0;\n            while (minHeap.Count > 1)\n            {\n                int a = minHeap.Dequeue();\n                int b = minHeap.Dequeue();\n                int time = a + b;\n                totalTime += time;\n                minHeap.Enqueue(time, time);\n            }\n\n            return totalTime;\n        }\n    }\n}\n\nnamespace MinAssemblyTimeCalculator\n{\n    class TestMinAssemblyTime\n    {\n        public static void Main()\n        {\n            // Test case 1: Provided example with complexities [1, 2, 9]\n            int[] testCase1 = { 1, 2, 9 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase1) == 15);\n\n            // Test case 2: Another example with complexities [1, 2, 3, 4]\n            int[] testCase2 = { 1, 2, 3, 4 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase2) == 19);\n\n            // Test case 3: Edge case with a single component [5]\n            int[] testCase3 = { 5 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase3) == 0);\n\n            // Test case 4: All components have the same complexity [3, 3, 3]\n            int[] testCase4 = { 3, 3, 3 };\n            Debug.Assert(Program.CalculateMinAssemblyTime(testCase4) == 15);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ArrayOperationSimulator\n{\n    class ArrayOperations\n    {\n        // Simulates the operations on the array and returns the value at position 'p' after all operations.\n        // The operations are processed in reverse order to find the last operation that affects 'p'.\n        public static int SimulateArrayOperations(int n, int m, int[] a, List<(int Type, int Left, int Right)> ops, int p)\n        {\n            // Find the last operation that covers 'p'\n            (int Type, int Left, int Right)? lastOp = null;\n            for (int i = ops.Count - 1; i >= 0; i--)\n            {\n                var op = ops[i];\n                if (op.Left <= p && p <= op.Right)\n                {\n                    lastOp = op;\n                    break;\n                }\n            }\n\n            if (lastOp == null)\n            {\n                return a[p - 1];\n            }\n            else\n            {\n                var (type, l, r) = lastOp.Value;\n                var sub = a.Skip(l - 1).Take(r - l + 1).ToArray();\n                int[] sortedSub;\n                if (type == 0)\n                {\n                    sortedSub = sub.OrderBy(x => x).ToArray();\n                }\n                else\n                {\n                    sortedSub = sub.OrderByDescending(x => x).ToArray();\n                }\n                int pos = type == 0 ? p - l : r - p;\n                return sortedSub[pos];\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n=5, m=2, a=[1, 2, 3, 4, 5], ops=[(0, 1, 3), (1, 4, 5)], p=3\nResult: 3\n\nTest Case 2:\nInput: n=5, m=3, a=[5, 4, 3, 2, 1], ops=[(1, 1, 5), (0, 2, 4), (0, 1, 3)], p=2\nResult: 4\n\nTest Case 3:\nInput: n=6, m=2, a=[10, 20, 30, 40, 50, 60], ops=[(0, 1, 4), (1, 2, 5)], p=4\nResult: 40", "task_id": 5739, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace ArrayOperationSimulator\n{\n    class TestArrayOperations\n    {\n        public static void RunTests()\n        {\n            // Test Case 1: No operation affects 'p'\n            int n1 = 5;\n            int m1 = 2;\n            int[] a1 = { 1, 2, 3, 4, 5 };\n            var ops1 = new List<(int Type, int Left, int Right)>\n            {\n                (0, 1, 3),\n                (1, 4, 5)\n            };\n            int p1 = 3;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n1, m1, a1, ops1, p1) == 3);\n\n            // Test Case 2: Last operation affects 'p' (ascending sort)\n            int n2 = 5;\n            int m2 = 3;\n            int[] a2 = { 5, 4, 3, 2, 1 };\n            var ops2 = new List<(int Type, int Left, int Right)>\n            {\n                (1, 1, 5),\n                (0, 2, 4),\n                (0, 1, 3)\n            };\n            int p2 = 2;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n2, m2, a2, ops2, p2) == 4);\n\n            // Test Case 3: Last operation affects 'p' (descending sort)\n            int n3 = 6;\n            int m3 = 2;\n            int[] a3 = { 10, 20, 30, 40, 50, 60 };\n            var ops3 = new List<(int Type, int Left, int Right)>\n            {\n                (0, 1, 4),\n                (1, 2, 5)\n            };\n            int p3 = 4;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n3, m3, a3, ops3, p3) == 40);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace ArrayOperationSimulator\n{\n    class ArrayOperations\n    {\n        // Simulates the operations on the array and returns the value at position 'p' after all operations.\n        // The operations are processed in reverse order to find the last operation that affects 'p'.\n        public static int SimulateArrayOperations(int n, int m, int[] a, List<(int Type, int Left, int Right)> ops, int p)\n        {\n            // Find the last operation that covers 'p'\n            (int Type, int Left, int Right)? lastOp = null;\n            for (int i = ops.Count - 1; i >= 0; i--)\n            {\n                var op = ops[i];\n                if (op.Left <= p && p <= op.Right)\n                {\n                    lastOp = op;\n                    break;\n                }\n            }\n\n            if (lastOp == null)\n            {\n                return a[p - 1];\n            }\n            else\n            {\n                var (type, l, r) = lastOp.Value;\n                var sub = a.Skip(l - 1).Take(r - l + 1).ToArray();\n                int[] sortedSub;\n                if (type == 0)\n                {\n                    sortedSub = sub.OrderBy(x => x).ToArray();\n                }\n                else\n                {\n                    sortedSub = sub.OrderByDescending(x => x).ToArray();\n                }\n                int pos = type == 0 ? p - l : r - p;\n                return sortedSub[pos];\n            }\n        }\n    }\n}\n\nnamespace ArrayOperationSimulator\n{\n    class TestArrayOperations\n    {\n        public static void Main()\n        {\n            // Test Case 1: No operation affects 'p'\n            int n1 = 5;\n            int m1 = 2;\n            int[] a1 = { 1, 2, 3, 4, 5 };\n            var ops1 = new List<(int Type, int Left, int Right)>\n            {\n                (0, 1, 3),\n                (1, 4, 5)\n            };\n            int p1 = 3;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n1, m1, a1, ops1, p1) == 3);\n\n            // Test Case 2: Last operation affects 'p' (ascending sort)\n            int n2 = 5;\n            int m2 = 3;\n            int[] a2 = { 5, 4, 3, 2, 1 };\n            var ops2 = new List<(int Type, int Left, int Right)>\n            {\n                (1, 1, 5),\n                (0, 2, 4),\n                (0, 1, 3)\n            };\n            int p2 = 2;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n2, m2, a2, ops2, p2) == 4);\n\n            // Test Case 3: Last operation affects 'p' (descending sort)\n            int n3 = 6;\n            int m3 = 2;\n            int[] a3 = { 10, 20, 30, 40, 50, 60 };\n            var ops3 = new List<(int Type, int Left, int Right)>\n            {\n                (0, 1, 4),\n                (1, 2, 5)\n            };\n            int p3 = 4;\n            Debug.Assert(ArrayOperations.SimulateArrayOperations(n3, m3, a3, ops3, p3) == 40);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace DistinctCharactersCounter\n{\n    class Program\n    {\n        // CountDistinctCharacters calculates the number of distinct characters in the input string.\n        // It uses a HashSet to efficiently determine the unique characters.\n        public static int CountDistinctCharacters(string s)\n        {\n            if (string.IsNullOrEmpty(s))\n            {\n                return 0;\n            }\n            return s.Distinct().Count();\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: \"hello\"\nDistinct Characters: 4\nInput: \"world\"\nDistinct Characters: 5\nInput: \"programming\"\nDistinct Characters: 8\nInput: \"aabbcc\"\nDistinct Characters: 3\nInput: \"\"\nDistinct Characters: 0", "task_id": 9087, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace DistinctCharactersCounter\n{\n    class TestDistinctCharactersCounter\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CountDistinctCharacters(\"hello\") == 4);\n            Debug.Assert(Program.CountDistinctCharacters(\"world\") == 5);\n            Debug.Assert(Program.CountDistinctCharacters(\"programming\") == 8);\n            Debug.Assert(Program.CountDistinctCharacters(\"aabbcc\") == 3);\n            Debug.Assert(Program.CountDistinctCharacters(\"\") == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace DistinctCharactersCounter\n{\n    class Program\n    {\n        // CountDistinctCharacters calculates the number of distinct characters in the input string.\n        // It uses a HashSet to efficiently determine the unique characters.\n        public static int CountDistinctCharacters(string s)\n        {\n            if (string.IsNullOrEmpty(s))\n            {\n                return 0;\n            }\n            return s.Distinct().Count();\n        }\n    }\n}\n\nnamespace DistinctCharactersCounter\n{\n    class TestDistinctCharactersCounter\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CountDistinctCharacters(\"hello\") == 4);\n            Debug.Assert(Program.CountDistinctCharacters(\"world\") == 5);\n            Debug.Assert(Program.CountDistinctCharacters(\"programming\") == 8);\n            Debug.Assert(Program.CountDistinctCharacters(\"aabbcc\") == 3);\n            Debug.Assert(Program.CountDistinctCharacters(\"\") == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace MaxValueCountChecker\n{\n    class Program\n    {\n        // Determines whether the count of the maximum value in the array is odd.\n        // If the count is odd, returns \"YES\"; otherwise, returns \"NO\".\n        public static string IsMaxCountOdd(int[] array)\n        {\n            if (array.Length == 0)\n            {\n                return \"NO\";\n            }\n\n            int maxVal = array.Max();\n            int count = array.Count(x => x == maxVal);\n            return count % 2 == 1 ? \"YES\" : \"NO\";\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: 2, 1\nResult: YES\nInput: 1, 1\nResult: NO\nInput: 3, 3, 3\nResult: YES\nInput: 3, 3, 4, 4\nResult: NO\nInput: 1, 2, 2, 2\nResult: YES", "task_id": 25276, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxValueCountChecker\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 2, 1 }) == \"YES\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 1, 1 }) == \"NO\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 3, 3, 3 }) == \"YES\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 3, 3, 4, 4 }) == \"NO\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 1, 2, 2, 2 }) == \"YES\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace MaxValueCountChecker\n{\n    class Program\n    {\n        // Determines whether the count of the maximum value in the array is odd.\n        // If the count is odd, returns \"YES\"; otherwise, returns \"NO\".\n        public static string IsMaxCountOdd(int[] array)\n        {\n            if (array.Length == 0)\n            {\n                return \"NO\";\n            }\n\n            int maxVal = array.Max();\n            int count = array.Count(x => x == maxVal);\n            return count % 2 == 1 ? \"YES\" : \"NO\";\n        }\n    }\n}\n\nnamespace MaxValueCountChecker\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 2, 1 }) == \"YES\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 1, 1 }) == \"NO\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 3, 3, 3 }) == \"YES\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 3, 3, 4, 4 }) == \"NO\");\n            Debug.Assert(Program.IsMaxCountOdd(new int[] { 1, 2, 2, 2 }) == \"YES\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace StoneCollector\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum number of unique stone types Jim can collect without exceeding the total type value X.\n        /// </summary>\n        /// <param name=\"N\">The number of stone types available (unused in the logic but kept for context).</param>\n        /// <param name=\"X\">The maximum total type value Jim can collect.</param>\n        /// <param name=\"typeValues\">An array of integers representing the type values of each stone.</param>\n        /// <returns>The maximum number of unique stones Jim can collect without exceeding X.</returns>\n        static int MaxUniqueStones(int N, int X, int[] typeValues)\n        {\n            // Sort the type values in ascending order to prioritize collecting stones with lower values first.\n            Array.Sort(typeValues);\n            int totalValue = 0;\n            int uniqueStones = 0;\n            \n            foreach (int value in typeValues)\n            {\n                if (totalValue + value <= X)\n                {\n                    totalValue += value;\n                    uniqueStones++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            return uniqueStones;\n        }\n    }\n}", "test_cases": "", "test_case_results": "N: 5, X: 10, TypeValues: [1, 3, 3, 2, 6]\nMaximum unique stones: 4\n\nN: 4, X: 5, TypeValues: [2, 2, 2, 2]\nMaximum unique stones: 2\n\nN: 3, X: 1, TypeValues: [2, 3, 4]\nMaximum unique stones: 0\n\nN: 6, X: 15, TypeValues: [1, 2, 3, 4, 5, 6]\nMaximum unique stones: 5", "task_id": 21871, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace StoneCollector\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            Debug.Assert(Program.MaxUniqueStones(5, 10, new int[] { 1, 3, 3, 2, 6 }) == 4);\n            \n            // Test case 2\n            Debug.Assert(Program.MaxUniqueStones(4, 5, new int[] { 2, 2, 2, 2 }) == 2);\n            \n            // Test case 3\n            Debug.Assert(Program.MaxUniqueStones(3, 1, new int[] { 2, 3, 4 }) == 0);\n            \n            // Test case 4\n            Debug.Assert(Program.MaxUniqueStones(6, 15, new int[] { 1, 2, 3, 4, 5, 6 }) == 5);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace StoneCollector\n{\n    class Program\n    {\n        /// <summary>\n        /// Determines the maximum number of unique stone types Jim can collect without exceeding the total type value X.\n        /// </summary>\n        /// <param name=\"N\">The number of stone types available (unused in the logic but kept for context).</param>\n        /// <param name=\"X\">The maximum total type value Jim can collect.</param>\n        /// <param name=\"typeValues\">An array of integers representing the type values of each stone.</param>\n        /// <returns>The maximum number of unique stones Jim can collect without exceeding X.</returns>\n    public static int MaxUniqueStones(int N, int X, int[] typeValues)\n        {\n            // Sort the type values in ascending order to prioritize collecting stones with lower values first.\n            Array.Sort(typeValues);\n            int totalValue = 0;\n            int uniqueStones = 0;\n            \n            foreach (int value in typeValues)\n            {\n                if (totalValue + value <= X)\n                {\n                    totalValue += value;\n                    uniqueStones++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n            \n            return uniqueStones;\n        }\n    }\n}\n\nnamespace StoneCollector\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            Debug.Assert(Program.MaxUniqueStones(5, 10, new int[] { 1, 3, 3, 2, 6 }) == 4);\n            \n            // Test case 2\n            Debug.Assert(Program.MaxUniqueStones(4, 5, new int[] { 2, 2, 2, 2 }) == 2);\n            \n            // Test case 3\n            Debug.Assert(Program.MaxUniqueStones(3, 1, new int[] { 2, 3, 4 }) == 0);\n            \n            // Test case 4\n            Debug.Assert(Program.MaxUniqueStones(6, 15, new int[] { 1, 2, 3, 4, 5, 6 }) == 5);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace TallestTreesCombiner\n{\n    class Program\n    {\n        // CombinedHeightOfTallestTrees calculates the sum of the tallest trees for each unique tree type.\n        // For each tree type in the input array, it finds the maximum height and then sums these maximum heights.\n        // Parameters:\n        //   n: The number of trees (length of the heights and types arrays).\n        //   heights: An array of integers representing the heights of the trees.\n        //   types: An array of integers representing the types of the trees.\n        // Returns:\n        //   The sum of the tallest trees for each unique tree type.\n        public static int CombinedHeightOfTallestTrees(int n, int[] heights, int[] types)\n        {\n            Dictionary<int, int> typeToHeight = new Dictionary<int, int>();\n            \n            for (int i = 0; i < n; i++)\n            {\n                int treeType = types[i];\n                int height = heights[i];\n                \n                if (typeToHeight.ContainsKey(treeType))\n                {\n                    if (height > typeToHeight[treeType])\n                    {\n                        typeToHeight[treeType] = height;\n                    }\n                }\n                else\n                {\n                    typeToHeight.Add(treeType, height);\n                }\n            }\n            \n            int sum = 0;\n            foreach (var height in typeToHeight.Values)\n            {\n                sum += height;\n            }\n            \n            return sum;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input Heights: 4, 7, 6, 2, 5\nInput Types: 1, 2, 2, 1, 3\nCombined Height of Tallest Trees: 16\n\nInput Heights: 10, 20, 30\nInput Types: 1, 1, 1\nCombined Height of Tallest Trees: 30\n\nInput Heights: 5, 5, 5, 5\nInput Types: 1, 2, 3, 4\nCombined Height of Tallest Trees: 20", "task_id": 10916, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace TallestTreesCombiner\n{\n    class TestTallestTreesCombiner\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            int[] heights1 = { 4, 7, 6, 2, 5 };\n            int[] types1 = { 1, 2, 2, 1, 3 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(5, heights1, types1) == 16);\n\n            // Test Case 2\n            int[] heights2 = { 10, 20, 30 };\n            int[] types2 = { 1, 1, 1 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(3, heights2, types2) == 30);\n\n            // Test Case 3\n            int[] heights3 = { 5, 5, 5, 5 };\n            int[] types3 = { 1, 2, 3, 4 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(4, heights3, types3) == 20);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace TallestTreesCombiner\n{\n    class Program\n    {\n        // CombinedHeightOfTallestTrees calculates the sum of the tallest trees for each unique tree type.\n        // For each tree type in the input array, it finds the maximum height and then sums these maximum heights.\n        // Parameters:\n        //   n: The number of trees (length of the heights and types arrays).\n        //   heights: An array of integers representing the heights of the trees.\n        //   types: An array of integers representing the types of the trees.\n        // Returns:\n        //   The sum of the tallest trees for each unique tree type.\n        public static int CombinedHeightOfTallestTrees(int n, int[] heights, int[] types)\n        {\n            Dictionary<int, int> typeToHeight = new Dictionary<int, int>();\n            \n            for (int i = 0; i < n; i++)\n            {\n                int treeType = types[i];\n                int height = heights[i];\n                \n                if (typeToHeight.ContainsKey(treeType))\n                {\n                    if (height > typeToHeight[treeType])\n                    {\n                        typeToHeight[treeType] = height;\n                    }\n                }\n                else\n                {\n                    typeToHeight.Add(treeType, height);\n                }\n            }\n            \n            int sum = 0;\n            foreach (var height in typeToHeight.Values)\n            {\n                sum += height;\n            }\n            \n            return sum;\n        }\n    }\n}\n\nnamespace TallestTreesCombiner\n{\n    class TestTallestTreesCombiner\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            int[] heights1 = { 4, 7, 6, 2, 5 };\n            int[] types1 = { 1, 2, 2, 1, 3 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(5, heights1, types1) == 16);\n\n            // Test Case 2\n            int[] heights2 = { 10, 20, 30 };\n            int[] types2 = { 1, 1, 1 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(3, heights2, types2) == 30);\n\n            // Test Case 3\n            int[] heights3 = { 5, 5, 5, 5 };\n            int[] types3 = { 1, 2, 3, 4 };\n            Debug.Assert(Program.CombinedHeightOfTallestTrees(4, heights3, types3) == 20);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace EncodeDecodeString\n{\n    class Program\n    {\n        // Encodes a string using Run-Length Encoding (RLE).\n        // For example, \"aaabbc\" is encoded as \"a3b2c1\".\n        static string Encode(string s)\n        {\n            string encoding = \"\";\n            int i = 0;\n            while (i < s.Length)\n            {\n                char currentChar = s[i];\n                int count = 1;\n                while (i + 1 < s.Length && s[i] == s[i + 1])\n                {\n                    i++;\n                    count++;\n                }\n                encoding += currentChar.ToString() + count.ToString();\n                i++;\n            }\n            return encoding;\n        }\n\n        // Decodes a Run-Length Encoded (RLE) string.\n        // For example, \"a3b2c1\" is decoded as \"aaabbc\".\n        static string Decode(string rle)\n        {\n            string decoding = \"\";\n            int i = 0;\n            while (i < rle.Length)\n            {\n                char ch = rle[i];\n                int count = int.Parse(rle[i + 1].ToString());\n                decoding += new string(ch, count);\n                i += 2;\n            }\n            return decoding;\n        }\n\n        // Encodes and decodes a given string using RLE.\n        // Returns a tuple containing the encoded string and the decoded string.\n        static (string EncodedString, string DecodedString) EncodeDecodeString(string inputString)\n        {\n            string encodedString = Encode(inputString);\n            string decodedString = Decode(encodedString);\n            return (encodedString, decodedString);\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: aaabbc\nEncoded: a3b2c1\nDecoded: aaabbc\nInput: a\nEncoded: a1\nDecoded: a\nInput: abcd\nEncoded: a1b1c1d1\nDecoded: abcd\nInput: \nEncoded: \nDecoded:", "task_id": 4187, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace EncodeDecodeString\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var result1 = Program.EncodeDecodeString(\"aaabbc\");\n            Debug.Assert(result1.EncodedString == \"a3b2c1\");\n            Debug.Assert(result1.DecodedString == \"aaabbc\");\n\n            // Test case 2\n            var result2 = Program.EncodeDecodeString(\"a\");\n            Debug.Assert(result2.EncodedString == \"a1\");\n            Debug.Assert(result2.DecodedString == \"a\");\n\n            // Test case 3\n            var result3 = Program.EncodeDecodeString(\"abcd\");\n            Debug.Assert(result3.EncodedString == \"a1b1c1d1\");\n            Debug.Assert(result3.DecodedString == \"abcd\");\n\n            // Test case 4\n            var result4 = Program.EncodeDecodeString(\"\");\n            Debug.Assert(result4.EncodedString == \"\");\n            Debug.Assert(result4.DecodedString == \"\");\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace EncodeDecodeString\n{\n    class Program\n    {\n        // Encodes a string using Run-Length Encoding (RLE).\n        // For example, \"aaabbc\" is encoded as \"a3b2c1\".\n    public static string Encode(string s)\n        {\n            string encoding = \"\";\n            int i = 0;\n            while (i < s.Length)\n            {\n                char currentChar = s[i];\n                int count = 1;\n                while (i + 1 < s.Length && s[i] == s[i + 1])\n                {\n                    i++;\n                    count++;\n                }\n                encoding += currentChar.ToString() + count.ToString();\n                i++;\n            }\n            return encoding;\n        }\n\n        // Decodes a Run-Length Encoded (RLE) string.\n        // For example, \"a3b2c1\" is decoded as \"aaabbc\".\n    public static string Decode(string rle)\n        {\n            string decoding = \"\";\n            int i = 0;\n            while (i < rle.Length)\n            {\n                char ch = rle[i];\n                int count = int.Parse(rle[i + 1].ToString());\n                decoding += new string(ch, count);\n                i += 2;\n            }\n            return decoding;\n        }\n\n        // Encodes and decodes a given string using RLE.\n        // Returns a tuple containing the encoded string and the decoded string.\n    public static (string EncodedString, string DecodedString) EncodeDecodeString(string inputString)\n        {\n            string encodedString = Encode(inputString);\n            string decodedString = Decode(encodedString);\n            return (encodedString, decodedString);\n        }\n    }\n}\n\nnamespace EncodeDecodeString\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var result1 = Program.EncodeDecodeString(\"aaabbc\");\n            Debug.Assert(result1.EncodedString == \"a3b2c1\");\n            Debug.Assert(result1.DecodedString == \"aaabbc\");\n\n            // Test case 2\n            var result2 = Program.EncodeDecodeString(\"a\");\n            Debug.Assert(result2.EncodedString == \"a1\");\n            Debug.Assert(result2.DecodedString == \"a\");\n\n            // Test case 3\n            var result3 = Program.EncodeDecodeString(\"abcd\");\n            Debug.Assert(result3.EncodedString == \"a1b1c1d1\");\n            Debug.Assert(result3.DecodedString == \"abcd\");\n\n            // Test case 4\n            var result4 = Program.EncodeDecodeString(\"\");\n            Debug.Assert(result4.EncodedString == \"\");\n            Debug.Assert(result4.DecodedString == \"\");\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace NameScoreCalculator\n{\n    class NameScoreCalculator\n    {\n        // CalculateNameScore computes the score of a name based on its position in a sorted list and its alphabetical value.\n        // The score is calculated as the product of the 1-based index of the name in the sorted list and the sum of the alphabetical positions of its characters.\n        public static int CalculateNameScore(string name, string[] sortedNames)\n        {\n            // Find the 1-based index of the name in the sorted list\n            int index = Array.IndexOf(sortedNames, name) + 1;\n            \n            // Calculate the alphabetical value of the name\n            int alphabeticalValue = name.Sum(c => c - 'A' + 1);\n            \n            // The score is index multiplied by alphabetical value\n            return index * alphabeticalValue;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Sorted Names: ALICE, BOB, CHARLIE, DAVID\nQuery: BOB\nScore: 38\nQuery: CHARLIE\nScore: 168\nQuery: DAVID\nScore: 160\nQuery: ALICE\nScore: 30", "task_id": 28632, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace NameScoreCalculator\n{\n    class TestNameScoreCalculator\n    {\n        public static void RunTests()\n        {\n            string[] names = { \"ALICE\", \"BOB\", \"CHARLIE\", \"DAVID\" };\n            string[] sortedNames = names.OrderBy(n => n).ToArray();\n            \n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"BOB\", sortedNames) == 38);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"CHARLIE\", sortedNames) == 168);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"DAVID\", sortedNames) == 160);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"ALICE\", sortedNames) == 30);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace NameScoreCalculator\n{\n    class NameScoreCalculator\n    {\n        // CalculateNameScore computes the score of a name based on its position in a sorted list and its alphabetical value.\n        // The score is calculated as the product of the 1-based index of the name in the sorted list and the sum of the alphabetical positions of its characters.\n        public static int CalculateNameScore(string name, string[] sortedNames)\n        {\n            // Find the 1-based index of the name in the sorted list\n            int index = Array.IndexOf(sortedNames, name) + 1;\n            \n            // Calculate the alphabetical value of the name\n            int alphabeticalValue = name.Sum(c => c - 'A' + 1);\n            \n            // The score is index multiplied by alphabetical value\n            return index * alphabeticalValue;\n        }\n    }\n}\n\nnamespace NameScoreCalculator\n{\n    class TestNameScoreCalculator\n    {\n        public static void Main()\n        {\n            string[] names = { \"ALICE\", \"BOB\", \"CHARLIE\", \"DAVID\" };\n            string[] sortedNames = names.OrderBy(n => n).ToArray();\n            \n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"BOB\", sortedNames) == 38);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"CHARLIE\", sortedNames) == 168);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"DAVID\", sortedNames) == 160);\n            Debug.Assert(NameScoreCalculator.CalculateNameScore(\"ALICE\", sortedNames) == 30);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace UniqueSubstringsCounter\n{\n    class Program\n    {\n        /// <summary>\n        /// Counts the number of unique substrings in a given string.\n        /// </summary>\n        /// <param name=\"n\">The length of the string.</param>\n        /// <param name=\"s\">The input string containing lowercase English letters.</param>\n        /// <returns>The count of unique substrings.</returns>\n        static int CountUniqueSubstrings(int n, string s)\n        {\n            HashSet<string> substrings = new HashSet<string>();\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = i + 1; j <= n; j++)\n                {\n                    substrings.Add(s.Substring(i, j - i));\n                }\n            }\n            return substrings.Count;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input string: \"abcd\", Length: 4\nNumber of unique substrings: 10\nInput string: \"aaa\", Length: 3\nNumber of unique substrings: 3\nInput string: \"abcde\", Length: 5\nNumber of unique substrings: 15\nInput string: \"a\", Length: 1\nNumber of unique substrings: 1", "task_id": 27412, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace UniqueSubstringsCounter\n{\n    class TestUniqueSubstringsCounter\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CountUniqueSubstrings(4, \"abcd\") == 10);\n            Debug.Assert(Program.CountUniqueSubstrings(3, \"aaa\") == 3);\n            Debug.Assert(Program.CountUniqueSubstrings(5, \"abcde\") == 15);\n            Debug.Assert(Program.CountUniqueSubstrings(1, \"a\") == 1);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace UniqueSubstringsCounter\n{\n    class Program\n    {\n        /// <summary>\n        /// Counts the number of unique substrings in a given string.\n        /// </summary>\n        /// <param name=\"n\">The length of the string.</param>\n        /// <param name=\"s\">The input string containing lowercase English letters.</param>\n        /// <returns>The count of unique substrings.</returns>\n    public static int CountUniqueSubstrings(int n, string s)\n        {\n            HashSet<string> substrings = new HashSet<string>();\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = i + 1; j <= n; j++)\n                {\n                    substrings.Add(s.Substring(i, j - i));\n                }\n            }\n            return substrings.Count;\n        }\n    }\n}\n\nnamespace UniqueSubstringsCounter\n{\n    class TestUniqueSubstringsCounter\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CountUniqueSubstrings(4, \"abcd\") == 10);\n            Debug.Assert(Program.CountUniqueSubstrings(3, \"aaa\") == 3);\n            Debug.Assert(Program.CountUniqueSubstrings(5, \"abcde\") == 15);\n            Debug.Assert(Program.CountUniqueSubstrings(1, \"a\") == 1);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Text.RegularExpressions;\n\nnamespace MaxNumberFinder\n{\n    class MaxNumberFinder\n    {\n        // FindMaxNumber extracts all numeric sequences from each string in the input array,\n        // converts them to integers, and returns the maximum number found.\n        // If no numbers are found, it returns 0.\n        public static int FindMaxNumber(string[] strings)\n        {\n            int maxNum = 0;\n            Regex regex = new Regex(@\"\\d+\");\n\n            foreach (string s in strings)\n            {\n                MatchCollection matches = regex.Matches(s);\n                foreach (Match match in matches)\n                {\n                    int currentNum = int.Parse(match.Value);\n                    if (currentNum > maxNum)\n                    {\n                        maxNum = currentNum;\n                    }\n                }\n            }\n\n            return maxNum;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [abc123def, 123, 456ghi, 789jklmno]\nMax number: 789\nInput: [no numbers here, still none, nope]\nMax number: 0\nInput: [1, 2, 3, 1000, 999]\nMax number: 1000\nInput: [abc1000xyz, 2000, 3000pqr, 4000]\nMax number: 4000", "task_id": 11647, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxNumberFinder\n{\n    class TestMaxNumberFinder\n    {\n        public static void RunTests()\n        {\n            // Test case 1: Multiple numbers in various strings\n            string[] testCase1 = { \"abc123def\", \"123\", \"456ghi\", \"789jklmno\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase1) == 789);\n\n            // Test case 2: No numbers in any string\n            string[] testCase2 = { \"no numbers here\", \"still none\", \"nope\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase2) == 0);\n\n            // Test case 3: Single numbers in each string\n            string[] testCase3 = { \"1\", \"2\", \"3\", \"1000\", \"999\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase3) == 1000);\n\n            // Test case 4: Larger numbers mixed with text\n            string[] testCase4 = { \"abc1000xyz\", \"2000\", \"3000pqr\", \"4000\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase4) == 4000);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Text.RegularExpressions;\nusing System;\n\nnamespace MaxNumberFinder\n{\n    class MaxNumberFinder\n    {\n        // FindMaxNumber extracts all numeric sequences from each string in the input array,\n        // converts them to integers, and returns the maximum number found.\n        // If no numbers are found, it returns 0.\n        public static int FindMaxNumber(string[] strings)\n        {\n            int maxNum = 0;\n            Regex regex = new Regex(@\"\\d+\");\n\n            foreach (string s in strings)\n            {\n                MatchCollection matches = regex.Matches(s);\n                foreach (Match match in matches)\n                {\n                    int currentNum = int.Parse(match.Value);\n                    if (currentNum > maxNum)\n                    {\n                        maxNum = currentNum;\n                    }\n                }\n            }\n\n            return maxNum;\n        }\n    }\n}\n\nnamespace MaxNumberFinder\n{\n    class TestMaxNumberFinder\n    {\n        public static void Main()\n        {\n            // Test case 1: Multiple numbers in various strings\n            string[] testCase1 = { \"abc123def\", \"123\", \"456ghi\", \"789jklmno\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase1) == 789);\n\n            // Test case 2: No numbers in any string\n            string[] testCase2 = { \"no numbers here\", \"still none\", \"nope\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase2) == 0);\n\n            // Test case 3: Single numbers in each string\n            string[] testCase3 = { \"1\", \"2\", \"3\", \"1000\", \"999\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase3) == 1000);\n\n            // Test case 4: Larger numbers mixed with text\n            string[] testCase4 = { \"abc1000xyz\", \"2000\", \"3000pqr\", \"4000\" };\n            Debug.Assert(MaxNumberFinder.FindMaxNumber(testCase4) == 4000);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace CycleDetection\n{\n    class Program\n    {\n        // Checks if the list contains a cycle.\n        // A cycle exists if following the indices leads to an infinite loop.\n        // Parameters:\n        //   lst: An array of integers where each integer points to an index in the array.\n        // Returns:\n        //   True if there is a cycle, False otherwise.\n        public static bool HasCycle(int[] lst)\n        {\n            int n = lst.Length;\n            bool[] visited = new bool[n];\n            \n            for (int i = 0; i < n; i++)\n            {\n                int current = i;\n                while (current >= 0 && current < n)\n                {\n                    if (visited[current])\n                    {\n                        return true;\n                    }\n                    visited[current] = true;\n                    current = lst[current];\n                }\n                // Reset visited for next starting point\n                Array.Fill(visited, false);\n            }\n            return false;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 0]\nHasCycle: True\nInput: [1, 2, 3, -1]\nHasCycle: False\nInput: [1, 0]\nHasCycle: True\nInput: [1, 2, 3, 4, 5, 6, 7]\nHasCycle: False\nInput: [1, 2, 3, 4, 5, 6, 4]\nHasCycle: True", "task_id": 28945, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace CycleDetection\n{\n    class TestCycleDetection\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 0 }) == true);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, -1 }) == false);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 0 }) == true);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 5, 6, 7 }) == false);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 5, 6, 4 }) == true);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace CycleDetection\n{\n    class Program\n    {\n        // Checks if the list contains a cycle.\n        // A cycle exists if following the indices leads to an infinite loop.\n        // Parameters:\n        //   lst: An array of integers where each integer points to an index in the array.\n        // Returns:\n        //   True if there is a cycle, False otherwise.\n        public static bool HasCycle(int[] lst)\n        {\n            int n = lst.Length;\n            bool[] visited = new bool[n];\n            \n            for (int i = 0; i < n; i++)\n            {\n                int current = i;\n                while (current >= 0 && current < n)\n                {\n                    if (visited[current])\n                    {\n                        return true;\n                    }\n                    visited[current] = true;\n                    current = lst[current];\n                }\n                // Reset visited for next starting point\n                Array.Fill(visited, false);\n            }\n            return false;\n        }\n    }\n}\n\nnamespace CycleDetection\n{\n    class TestCycleDetection\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 0 }) == true);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, -1 }) == false);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 0 }) == true);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 5, 6, 7 }) == false);\n            Debug.Assert(Program.HasCycle(new int[] { 1, 2, 3, 4, 5, 6, 4 }) == true);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace NonSpecialSequenceCounter\n{\n    class NonSpecialSequenceCounter\n    {\n        // Counts the number of non-special sequences of length n\n        // A sequence is non-special if no three consecutive elements are all distinct\n        // Elements can be 0, 1, or 2\n        public static int CountNonSpecial(int n)\n        {\n            if (n == 1)\n                return 3;\n            if (n == 2)\n                return 9;\n                \n            // Initialize DP for i=2. prev[a][b] represents the pair (a, b) with count 1 each\n            int[,] prev = new int[3, 3];\n            for (int a = 0; a < 3; a++)\n                for (int b = 0; b < 3; b++)\n                    prev[a, b] = 1;\n                    \n            for (int i = 3; i <= n; i++)\n            {\n                int[,] current = new int[3, 3];\n                for (int aPrev = 0; aPrev < 3; aPrev++)\n                {\n                    for (int bPrev = 0; bPrev < 3; bPrev++)\n                    {\n                        int cnt = prev[aPrev, bPrev];\n                        if (cnt == 0)\n                            continue;\n                            \n                        for (int c = 0; c < 3; c++)\n                        {\n                            // Check if {aPrev, bPrev, c} has all distinct elements\n                            if (aPrev != bPrev && bPrev != c && aPrev != c)\n                                continue;\n                                \n                            current[bPrev, c] += cnt;\n                        }\n                    }\n                }\n                prev = current;\n            }\n            \n            int total = 0;\n            for (int a = 0; a < 3; a++)\n                for (int b = 0; b < 3; b++)\n                    total += prev[a, b];\n                    \n            return total;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 1\nNumber of non-special sequences: 3\n\nInput: n = 2\nNumber of non-special sequences: 9\n\nInput: n = 3\nNumber of non-special sequences: 21\n\nInput: n = 4\nNumber of non-special sequences: 51\n\nInput: n = 5\nNumber of non-special sequences: 123", "task_id": 15459, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace NonSpecialSequenceCounter\n{\n    class TestNonSpecialSequenceCounter\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(1) == 3);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(2) == 9);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(3) == 21);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(4) == 51);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(5) == 123);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace NonSpecialSequenceCounter\n{\n    class NonSpecialSequenceCounter\n    {\n        // Counts the number of non-special sequences of length n\n        // A sequence is non-special if no three consecutive elements are all distinct\n        // Elements can be 0, 1, or 2\n        public static int CountNonSpecial(int n)\n        {\n            if (n == 1)\n                return 3;\n            if (n == 2)\n                return 9;\n                \n            // Initialize DP for i=2. prev[a][b] represents the pair (a, b) with count 1 each\n            int[,] prev = new int[3, 3];\n            for (int a = 0; a < 3; a++)\n                for (int b = 0; b < 3; b++)\n                    prev[a, b] = 1;\n                    \n            for (int i = 3; i <= n; i++)\n            {\n                int[,] current = new int[3, 3];\n                for (int aPrev = 0; aPrev < 3; aPrev++)\n                {\n                    for (int bPrev = 0; bPrev < 3; bPrev++)\n                    {\n                        int cnt = prev[aPrev, bPrev];\n                        if (cnt == 0)\n                            continue;\n                            \n                        for (int c = 0; c < 3; c++)\n                        {\n                            // Check if {aPrev, bPrev, c} has all distinct elements\n                            if (aPrev != bPrev && bPrev != c && aPrev != c)\n                                continue;\n                                \n                            current[bPrev, c] += cnt;\n                        }\n                    }\n                }\n                prev = current;\n            }\n            \n            int total = 0;\n            for (int a = 0; a < 3; a++)\n                for (int b = 0; b < 3; b++)\n                    total += prev[a, b];\n                    \n            return total;\n        }\n    }\n}\n\nnamespace NonSpecialSequenceCounter\n{\n    class TestNonSpecialSequenceCounter\n    {\n        public static void Main()\n        {\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(1) == 3);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(2) == 9);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(3) == 21);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(4) == 51);\n            Debug.Assert(NonSpecialSequenceCounter.CountNonSpecial(5) == 123);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Collections.Generic;\n\nnamespace KnapsackSolver\n{\n    class KnapsackSolver\n    {\n        // Solves the knapsack problem with bundled items using binary splitting.\n        // The method takes the maximum weight capacity and a list of items (each with weight, value, and count).\n        // It returns the maximum performance (sum of values) achievable without exceeding the weight capacity.\n        public static int SolveKnapsack(int capacity, List<(int Weight, int Value, int Count)> items)\n        {\n            // Step 1: Split items into bundles using binary splitting\n            List<(int Weight, int Value)> bundles = new List<(int Weight, int Value)>();\n            foreach (var item in items)\n            {\n                int remaining = item.Count;\n                int k = 1;\n                while (remaining > 0)\n                {\n                    int take = Math.Min(k, remaining);\n                    bundles.Add((item.Weight * take, item.Value * take));\n                    remaining -= take;\n                    k *= 2;\n                }\n            }\n\n            // Step 2: Initialize DP array\n            int[] maxPerformance = new int[capacity + 1];\n\n            // Step 3: Perform dynamic programming to find the maximum performance\n            foreach (var bundle in bundles)\n            {\n                for (int j = capacity; j >= bundle.Value; j--)\n                {\n                    if (maxPerformance[j - bundle.Value] + bundle.Weight > maxPerformance[j])\n                    {\n                        maxPerformance[j] = maxPerformance[j - bundle.Value] + bundle.Weight;\n                    }\n                }\n            }\n\n            // Step 4: Return the maximum performance found\n            int maxPerf = 0;\n            for (int j = 0; j <= capacity; j++)\n            {\n                if (maxPerformance[j] > maxPerf)\n                {\n                    maxPerf = maxPerformance[j];\n                }\n            }\n            return maxPerf;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nItems: (Weight, Value, Count)\n(2, 3, 2)\n(1, 2, 3)\n(3, 4, 1)\nCapacity: 5\nMaximum Performance: 3\n\nTest Case 2:\nItems: (Weight, Value, Count)\n(1, 5, 2)\n(2, 3, 2)\nCapacity: 6\nMaximum Performance: 4\n\nTest Case 3:\nItems: (Weight, Value, Count)\n(5, 10, 1)\n(4, 8, 1)\nCapacity: 3\nMaximum Performance: 0", "task_id": 23929, "assertions": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nnamespace KnapsackSolver\n{\n    class TestKnapsackSolver\n    {\n        public static void RunTests()\n        {\n            // Test case 1\n            var items1 = new List<(int Weight, int Value, int Count)>\n            {\n                (2, 3, 2),\n                (1, 2, 3),\n                (3, 4, 1)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(5, items1) == 3);\n\n            // Test case 2\n            var items2 = new List<(int Weight, int Value, int Count)>\n            {\n                (1, 5, 2),\n                (2, 3, 2)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(6, items2) == 4);\n\n            // Test case 3\n            var items3 = new List<(int Weight, int Value, int Count)>\n            {\n                (5, 10, 1),\n                (4, 8, 1)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(3, items3) == 0);\n        }\n    }\n}", "all_code": "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System;\n\nnamespace KnapsackSolver\n{\n    class KnapsackSolver\n    {\n        // Solves the knapsack problem with bundled items using binary splitting.\n        // The method takes the maximum weight capacity and a list of items (each with weight, value, and count).\n        // It returns the maximum performance (sum of values) achievable without exceeding the weight capacity.\n        public static int SolveKnapsack(int capacity, List<(int Weight, int Value, int Count)> items)\n        {\n            // Step 1: Split items into bundles using binary splitting\n            List<(int Weight, int Value)> bundles = new List<(int Weight, int Value)>();\n            foreach (var item in items)\n            {\n                int remaining = item.Count;\n                int k = 1;\n                while (remaining > 0)\n                {\n                    int take = Math.Min(k, remaining);\n                    bundles.Add((item.Weight * take, item.Value * take));\n                    remaining -= take;\n                    k *= 2;\n                }\n            }\n\n            // Step 2: Initialize DP array\n            int[] maxPerformance = new int[capacity + 1];\n\n            // Step 3: Perform dynamic programming to find the maximum performance\n            foreach (var bundle in bundles)\n            {\n                for (int j = capacity; j >= bundle.Value; j--)\n                {\n                    if (maxPerformance[j - bundle.Value] + bundle.Weight > maxPerformance[j])\n                    {\n                        maxPerformance[j] = maxPerformance[j - bundle.Value] + bundle.Weight;\n                    }\n                }\n            }\n\n            // Step 4: Return the maximum performance found\n            int maxPerf = 0;\n            for (int j = 0; j <= capacity; j++)\n            {\n                if (maxPerformance[j] > maxPerf)\n                {\n                    maxPerf = maxPerformance[j];\n                }\n            }\n            return maxPerf;\n        }\n    }\n}\n\nnamespace KnapsackSolver\n{\n    class TestKnapsackSolver\n    {\n        public static void Main()\n        {\n            // Test case 1\n            var items1 = new List<(int Weight, int Value, int Count)>\n            {\n                (2, 3, 2),\n                (1, 2, 3),\n                (3, 4, 1)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(5, items1) == 3);\n\n            // Test case 2\n            var items2 = new List<(int Weight, int Value, int Count)>\n            {\n                (1, 5, 2),\n                (2, 3, 2)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(6, items2) == 4);\n\n            // Test case 3\n            var items3 = new List<(int Weight, int Value, int Count)>\n            {\n                (5, 10, 1),\n                (4, 8, 1)\n            };\n            Debug.Assert(KnapsackSolver.SolveKnapsack(3, items3) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace DynamicProgrammingGame\n{\n    class OptimalGameDifference\n    {\n        // CalculateOptimalDifference computes the maximum difference in scores that the first player\n        // can achieve over the second player when both play optimally.\n        // The method uses dynamic programming to fill a table where dp[i,j] represents the maximum\n        // difference for the subarray from index i to j.\n        public static int CalculateOptimalDifference(int[] a)\n        {\n            int n = a.Length;\n            int[,] dp = new int[n, n];\n\n            // Initialize the DP table for subarrays of length 1\n            for (int i = 0; i < n; i++)\n            {\n                dp[i, i] = a[i];\n            }\n\n            // Fill the DP table for subarrays of longer lengths\n            for (int length = 2; length <= n; length++)\n            {\n                for (int i = 0; i <= n - length; i++)\n                {\n                    int j = i + length - 1;\n                    dp[i, j] = Math.Max(a[i] - dp[i + 1, j], a[j] - dp[i, j - 1]);\n                }\n            }\n\n            return dp[0, n - 1];\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nOptimal Difference: 2\nInput: [5, 6, 7, 0]\nOptimal Difference: 6\nInput: [0, 0, 0, 0]\nOptimal Difference: 0\nInput: [1, 100, 2]\nOptimal Difference: -97", "task_id": 10528, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace DynamicProgrammingGame\n{\n    class TestOptimalGameDifference\n    {\n        public static void RunTests()\n        {\n            int[] testCase1 = { 1, 2, 3, 4 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase1) == 2);\n\n            int[] testCase2 = { 5, 6, 7, 0 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase2) == 6);\n\n            int[] testCase3 = { 0, 0, 0, 0 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase3) == 0);\n\n            int[] testCase4 = { 1, 100, 2 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase4) == -97);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace DynamicProgrammingGame\n{\n    class OptimalGameDifference\n    {\n        // CalculateOptimalDifference computes the maximum difference in scores that the first player\n        // can achieve over the second player when both play optimally.\n        // The method uses dynamic programming to fill a table where dp[i,j] represents the maximum\n        // difference for the subarray from index i to j.\n        public static int CalculateOptimalDifference(int[] a)\n        {\n            int n = a.Length;\n            int[,] dp = new int[n, n];\n\n            // Initialize the DP table for subarrays of length 1\n            for (int i = 0; i < n; i++)\n            {\n                dp[i, i] = a[i];\n            }\n\n            // Fill the DP table for subarrays of longer lengths\n            for (int length = 2; length <= n; length++)\n            {\n                for (int i = 0; i <= n - length; i++)\n                {\n                    int j = i + length - 1;\n                    dp[i, j] = Math.Max(a[i] - dp[i + 1, j], a[j] - dp[i, j - 1]);\n                }\n            }\n\n            return dp[0, n - 1];\n        }\n    }\n}\n\nnamespace DynamicProgrammingGame\n{\n    class TestOptimalGameDifference\n    {\n        public static void Main()\n        {\n            int[] testCase1 = { 1, 2, 3, 4 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase1) == 2);\n\n            int[] testCase2 = { 5, 6, 7, 0 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase2) == 6);\n\n            int[] testCase3 = { 0, 0, 0, 0 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase3) == 0);\n\n            int[] testCase4 = { 1, 100, 2 };\n            Debug.Assert(OptimalGameDifference.CalculateOptimalDifference(testCase4) == -97);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace MaxGCDCalculator\n{\n    class Program\n    {\n        // CalculateGCD computes the greatest common divisor (GCD) of two integers.\n        static int CalculateGCD(int a, int b)\n        {\n            while (b != 0)\n            {\n                int temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        // CalculateMaxGCD returns the maximum GCD achievable after removing exactly one integer from the list.\n        // It uses prefix and suffix GCD arrays to efficiently compute the result.\n        static int CalculateMaxGCD(int[] nums)\n        {\n            int n = nums.Length;\n            \n            if (n == 2)\n            {\n                return Math.Max(nums[0], nums[1]);\n            }\n            \n            int[] prefixGCD = new int[n];\n            int[] suffixGCD = new int[n];\n            \n            prefixGCD[0] = nums[0];\n            for (int i = 1; i < n; i++)\n            {\n                prefixGCD[i] = CalculateGCD(prefixGCD[i - 1], nums[i]);\n            }\n            \n            suffixGCD[n - 1] = nums[n - 1];\n            for (int i = n - 2; i >= 0; i--)\n            {\n                suffixGCD[i] = CalculateGCD(suffixGCD[i + 1], nums[i]);\n            }\n            \n            int maxGCD = Math.Max(suffixGCD[1], prefixGCD[n - 2]); // considering removing the first or the last element\n            for (int i = 1; i < n - 1; i++)\n            {\n                maxGCD = Math.Max(maxGCD, CalculateGCD(prefixGCD[i - 1], suffixGCD[i + 1]));\n            }\n            \n            return maxGCD;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nMaximum GCD after removing one element: 1\nInput: [5, 10, 15, 20]\nMaximum GCD after removing one element: 5\nInput: [8, 16, 24, 32]\nMaximum GCD after removing one element: 8\nInput: [7, 14, 21, 28]\nMaximum GCD after removing one element: 7", "task_id": 11617, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace MaxGCDCalculator\n{\n    class TestMaxGCDCalculator\n    {\n        public static void RunTests()\n        {\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 1, 2, 3, 4 }) == 1);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 5, 10, 15, 20 }) == 5);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 8, 16, 24, 32 }) == 8);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 7, 14, 21, 28 }) == 7);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace MaxGCDCalculator\n{\n    class Program\n    {\n        // CalculateGCD computes the greatest common divisor (GCD) of two integers.\n    public static int CalculateGCD(int a, int b)\n        {\n            while (b != 0)\n            {\n                int temp = b;\n                b = a % b;\n                a = temp;\n            }\n            return a;\n        }\n\n        // CalculateMaxGCD returns the maximum GCD achievable after removing exactly one integer from the list.\n        // It uses prefix and suffix GCD arrays to efficiently compute the result.\n    public static int CalculateMaxGCD(int[] nums)\n        {\n            int n = nums.Length;\n            \n            if (n == 2)\n            {\n                return Math.Max(nums[0], nums[1]);\n            }\n            \n            int[] prefixGCD = new int[n];\n            int[] suffixGCD = new int[n];\n            \n            prefixGCD[0] = nums[0];\n            for (int i = 1; i < n; i++)\n            {\n                prefixGCD[i] = CalculateGCD(prefixGCD[i - 1], nums[i]);\n            }\n            \n            suffixGCD[n - 1] = nums[n - 1];\n            for (int i = n - 2; i >= 0; i--)\n            {\n                suffixGCD[i] = CalculateGCD(suffixGCD[i + 1], nums[i]);\n            }\n            \n            int maxGCD = Math.Max(suffixGCD[1], prefixGCD[n - 2]); // considering removing the first or the last element\n            for (int i = 1; i < n - 1; i++)\n            {\n                maxGCD = Math.Max(maxGCD, CalculateGCD(prefixGCD[i - 1], suffixGCD[i + 1]));\n            }\n            \n            return maxGCD;\n        }\n    }\n}\n\nnamespace MaxGCDCalculator\n{\n    class TestMaxGCDCalculator\n    {\n        public static void Main()\n        {\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 1, 2, 3, 4 }) == 1);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 5, 10, 15, 20 }) == 5);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 8, 16, 24, 32 }) == 8);\n            Debug.Assert(Program.CalculateMaxGCD(new int[] { 7, 14, 21, 28 }) == 7);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\nusing System.Linq;\n\nnamespace PointsCoordinateSum\n{\n    class Program\n    {\n        // CalculateTotalCoordinateSum calculates the total sum of differences between pairs of points\n        // for each coordinate up to k dimensions. The points are sorted in descending order for each\n        // coordinate, and then paired to calculate the differences.\n        static int CalculateTotalCoordinateSum(int n, int k, int[][] points)\n        {\n            int total = 0;\n            for (int p = 0; p < k; p++)\n            {\n                // Extract the p-th coordinate of all points\n                int[] arr = points.Select(pt => pt[p]).ToArray();\n                // Sort in descending order\n                Array.Sort(arr);\n                Array.Reverse(arr);\n                \n                int res = 0;\n                for (int i = 0; i < n; i++)\n                {\n                    res += (arr[2 * i] - arr[2 * i + 1]);\n                }\n                \n                total += res;\n            }\n            \n            return total;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 2, k: 2\nPoints:\n1, 2\n3, 4\n5, 6\n7, 8\nTotal: 8\n\nTest Case 2:\nn: 1, k: 3\nPoints:\n10, 20, 30\n40, 50, 60\nTotal: 90\n\nTest Case 3:\nn: 3, k: 1\nPoints:\n1\n2\n3\n4\n5\n6\nTotal: 3", "task_id": 4469, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace PointsCoordinateSum\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            // Test Case 1\n            int n1 = 2;\n            int k1 = 2;\n            int[][] points1 = new int[][]\n            {\n                new int[] { 1, 2 },\n                new int[] { 3, 4 },\n                new int[] { 5, 6 },\n                new int[] { 7, 8 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n1, k1, points1) == 8);\n\n            // Test Case 2\n            int n2 = 1;\n            int k2 = 3;\n            int[][] points2 = new int[][]\n            {\n                new int[] { 10, 20, 30 },\n                new int[] { 40, 50, 60 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n2, k2, points2) == 90);\n\n            // Test Case 3\n            int n3 = 3;\n            int k3 = 1;\n            int[][] points3 = new int[][]\n            {\n                new int[] { 1 },\n                new int[] { 2 },\n                new int[] { 3 },\n                new int[] { 4 },\n                new int[] { 5 },\n                new int[] { 6 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n3, k3, points3) == 3);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System.Linq;\nusing System;\n\nnamespace PointsCoordinateSum\n{\n    class Program\n    {\n        // CalculateTotalCoordinateSum calculates the total sum of differences between pairs of points\n        // for each coordinate up to k dimensions. The points are sorted in descending order for each\n        // coordinate, and then paired to calculate the differences.\n    public static int CalculateTotalCoordinateSum(int n, int k, int[][] points)\n        {\n            int total = 0;\n            for (int p = 0; p < k; p++)\n            {\n                // Extract the p-th coordinate of all points\n                int[] arr = points.Select(pt => pt[p]).ToArray();\n                // Sort in descending order\n                Array.Sort(arr);\n                Array.Reverse(arr);\n                \n                int res = 0;\n                for (int i = 0; i < n; i++)\n                {\n                    res += (arr[2 * i] - arr[2 * i + 1]);\n                }\n                \n                total += res;\n            }\n            \n            return total;\n        }\n    }\n}\n\nnamespace PointsCoordinateSum\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            // Test Case 1\n            int n1 = 2;\n            int k1 = 2;\n            int[][] points1 = new int[][]\n            {\n                new int[] { 1, 2 },\n                new int[] { 3, 4 },\n                new int[] { 5, 6 },\n                new int[] { 7, 8 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n1, k1, points1) == 8);\n\n            // Test Case 2\n            int n2 = 1;\n            int k2 = 3;\n            int[][] points2 = new int[][]\n            {\n                new int[] { 10, 20, 30 },\n                new int[] { 40, 50, 60 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n2, k2, points2) == 90);\n\n            // Test Case 3\n            int n3 = 3;\n            int k3 = 1;\n            int[][] points3 = new int[][]\n            {\n                new int[] { 1 },\n                new int[] { 2 },\n                new int[] { 3 },\n                new int[] { 4 },\n                new int[] { 5 },\n                new int[] { 6 }\n            };\n            Debug.Assert(Program.CalculateTotalCoordinateSum(n3, k3, points3) == 3);\n        }\n    }\n}", "exec_outcome": "PASSED"}
{"code": "using System;\n\nnamespace BitwiseXORProblem\n{\n    class Program\n    {\n        // ComputeAnswer calculates the answer based on the XOR of subarrays of the input array.\n        // The method takes an array of integers and a threshold value m.\n        // It returns the computed answer after processing each bit from 30 down to 0.\n        public static int ComputeAnswer(int[] a, int m)\n        {\n            int n = a.Length;\n            int[] preXor = new int[n + 1];\n            preXor[0] = 0;\n            for (int i = 0; i < n; i++)\n            {\n                preXor[i + 1] = preXor[i] ^ a[i];\n            }\n\n            int mask = 0;\n            int ans = 0;\n\n            for (int bit = 30; bit >= 0; bit--)\n            {\n                int maskCandidate = mask | (1 << bit);\n                int total = preXor[n];\n\n                if ((total & maskCandidate) != 0)\n                {\n                    ans |= (1 << bit);\n                    continue;\n                }\n\n                int cnt = 0;\n                foreach (int x in preXor)\n                {\n                    if ((x & maskCandidate) == 0)\n                    {\n                        cnt++;\n                        if (cnt >= m + 1)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (cnt >= m + 1)\n                {\n                    mask = maskCandidate;\n                }\n                else\n                {\n                    ans |= (1 << bit);\n                }\n            }\n\n            return ans;\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4], m: 2\nAnswer: 4\nInput array: [5, 6, 7, 0], m: 1\nAnswer: 4\nInput array: [0, 0, 0, 0], m: 3\nAnswer: 0", "task_id": 25940, "assertions": "using System;\nusing System.Diagnostics;\n\nnamespace BitwiseXORProblem\n{\n    class TestProgram\n    {\n        public static void RunTests()\n        {\n            int[] a1 = { 1, 2, 3, 4 };\n            int m1 = 2;\n            Debug.Assert(Program.ComputeAnswer(a1, m1) == 4);\n\n            int[] a2 = { 5, 6, 7, 0 };\n            int m2 = 1;\n            Debug.Assert(Program.ComputeAnswer(a2, m2) == 4);\n\n            int[] a3 = { 0, 0, 0, 0 };\n            int m3 = 3;\n            Debug.Assert(Program.ComputeAnswer(a3, m3) == 0);\n        }\n    }\n}", "all_code": "using System.Diagnostics;\nusing System;\n\nnamespace BitwiseXORProblem\n{\n    class Program\n    {\n        // ComputeAnswer calculates the answer based on the XOR of subarrays of the input array.\n        // The method takes an array of integers and a threshold value m.\n        // It returns the computed answer after processing each bit from 30 down to 0.\n        public static int ComputeAnswer(int[] a, int m)\n        {\n            int n = a.Length;\n            int[] preXor = new int[n + 1];\n            preXor[0] = 0;\n            for (int i = 0; i < n; i++)\n            {\n                preXor[i + 1] = preXor[i] ^ a[i];\n            }\n\n            int mask = 0;\n            int ans = 0;\n\n            for (int bit = 30; bit >= 0; bit--)\n            {\n                int maskCandidate = mask | (1 << bit);\n                int total = preXor[n];\n\n                if ((total & maskCandidate) != 0)\n                {\n                    ans |= (1 << bit);\n                    continue;\n                }\n\n                int cnt = 0;\n                foreach (int x in preXor)\n                {\n                    if ((x & maskCandidate) == 0)\n                    {\n                        cnt++;\n                        if (cnt >= m + 1)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (cnt >= m + 1)\n                {\n                    mask = maskCandidate;\n                }\n                else\n                {\n                    ans |= (1 << bit);\n                }\n            }\n\n            return ans;\n        }\n    }\n}\n\nnamespace BitwiseXORProblem\n{\n    class TestProgram\n    {\n        public static void Main()\n        {\n            int[] a1 = { 1, 2, 3, 4 };\n            int m1 = 2;\n            Debug.Assert(Program.ComputeAnswer(a1, m1) == 4);\n\n            int[] a2 = { 5, 6, 7, 0 };\n            int m2 = 1;\n            Debug.Assert(Program.ComputeAnswer(a2, m2) == 4);\n\n            int[] a3 = { 0, 0, 0, 0 };\n            int m3 = 3;\n            Debug.Assert(Program.ComputeAnswer(a3, m3) == 0);\n        }\n    }\n}", "exec_outcome": "PASSED"}
