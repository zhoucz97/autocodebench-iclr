{"code": "(in-package :cl-user)\n\n; rename-on-conflict generates a new filename by appending a counter to the original name if it conflicts with existing files.\n; \n; Parameters:\n;   existing-files - a list of strings representing existing filenames\n;   new-file - a string representing the desired new filename\n;\n; Returns:\n;   A string representing the new filename, either the original if no conflict exists,\n;   or the original with a counter appended if conflicts are found.\n(defun rename-on-conflict (existing-files new-file)\n  (if (not (member new-file existing-files :test #'string=))\n      new-file\n      (let ((counter 1))\n        (loop while (member (format nil \"~a~d\" new-file counter) existing-files :test #'string=)\n              do (incf counter))\n        (format nil \"~a~d\" new-file counter))))", "test_cases": "", "test_case_results": "Existing files: (file1 file2 file3)\nDesired filename: file4\nResult: file4\n\nExisting files: (file1 file2 file3)\nDesired filename: file1\nResult: file11\n\nExisting files: (file1 file11 file12)\nDesired filename: file1\nResult: file13\n\nExisting files: NIL\nDesired filename: file1\nResult: file1", "task_id": 2317, "assertions": "(defpackage :file-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :file-utils-test)\n\n(defun run-tests ()\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file4\") \"file4\") \n          () \"No conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file1\") \"file11\") \n          () \"Simple conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file11\" \"file12\") \"file1\") \"file13\") \n          () \"Multiple conflicts case failed\")\n  (assert (string= (rename-on-conflict nil \"file1\") \"file1\") \n          () \"Empty existing files case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :file-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :file-utils-test)\n\n(defun run-tests ()\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file4\") \"file4\") \n          () \"No conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file1\") \"file11\") \n          () \"Simple conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file11\" \"file12\") \"file1\") \"file13\") \n          () \"Multiple conflicts case failed\")\n  (assert (string= (rename-on-conflict nil \"file1\") \"file1\") \n          () \"Empty existing files case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "rename-on-conflict"}, "all_code": "(defpackage :file-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :file-utils-test)\n\n(defun rename-on-conflict (existing-files new-file)\n  (if (not (member new-file existing-files :test #'string=))\n      new-file\n      (let ((counter 1))\n        (loop while (member (format nil \"~a~d\" new-file counter) existing-files :test #'string=)\n              do (incf counter))\n        (format nil \"~a~d\" new-file counter))))\n\n\n(defun run-tests ()\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file4\") \"file4\") \n          () \"No conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file2\" \"file3\") \"file1\") \"file11\") \n          () \"Simple conflict case failed\")\n  (assert (string= (rename-on-conflict '(\"file1\" \"file11\" \"file12\") \"file1\") \"file13\") \n          () \"Multiple conflicts case failed\")\n  (assert (string= (rename-on-conflict nil \"file1\") \"file1\") \n          () \"Empty existing files case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; count-unique-vowels returns the count of unique vowels in the given string.\n; Vowels are considered case insensitively (both uppercase and lowercase are treated the same).\n; The function checks each character in the string, converts it to lowercase,\n; and checks if it's one of the vowels 'a', 'e', 'i', 'o', or 'u'.\n; It then counts how many unique vowels were found.\n(defun count-unique-vowels (s)\n  (let ((vowels '(#\\a #\\e #\\i #\\o #\\u))\n        (unique-vowels (make-hash-table :test 'equal)))\n    (loop for char across s\n          for lower-char = (char-downcase char)\n          when (member lower-char vowels :test #'char=)\n          do (setf (gethash lower-char unique-vowels) t))\n    (hash-table-count unique-vowels)))", "test_cases": "", "test_case_results": "Input: \"Hello World\"\nUnique vowels: 2\nInput: \"Common Lisp\"\nUnique vowels: 2\nInput: \"AEIOUaeiou\"\nUnique vowels: 5\nInput: \"xyz\"\nUnique vowels: 0\nInput: \"\"\nUnique vowels: 0", "task_id": 9175, "assertions": "(defpackage :vowel-count-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :vowel-count-test)\n\n(defun run-tests ()\n  (assert (= (count-unique-vowels \"Hello World\") 2) () \"Should count 2 unique vowels in 'Hello World'\")\n  (assert (= (count-unique-vowels \"Common Lisp\") 2) () \"Should count 2 unique vowels in 'Common Lisp'\")\n  (assert (= (count-unique-vowels \"AEIOUaeiou\") 5) () \"Should count 5 unique vowels in 'AEIOUaeiou'\")\n  (assert (= (count-unique-vowels \"xyz\") 0) () \"Should count 0 unique vowels in 'xyz'\")\n  (assert (= (count-unique-vowels \"\") 0) () \"Should count 0 unique vowels in empty string\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :vowel-count-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :vowel-count-test)\n\n(defun run-tests ()\n  (assert (= (count-unique-vowels \"Hello World\") 2) () \"Should count 2 unique vowels in 'Hello World'\")\n  (assert (= (count-unique-vowels \"Common Lisp\") 2) () \"Should count 2 unique vowels in 'Common Lisp'\")\n  (assert (= (count-unique-vowels \"AEIOUaeiou\") 5) () \"Should count 5 unique vowels in 'AEIOUaeiou'\")\n  (assert (= (count-unique-vowels \"xyz\") 0) () \"Should count 0 unique vowels in 'xyz'\")\n  (assert (= (count-unique-vowels \"\") 0) () \"Should count 0 unique vowels in empty string\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "count-unique-vowels"}, "all_code": "(defpackage :vowel-count-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :vowel-count-test)\n\n(defun count-unique-vowels (s)\n  (let ((vowels '(#\\a #\\e #\\i #\\o #\\u))\n        (unique-vowels (make-hash-table :test 'equal)))\n    (loop for char across s\n          for lower-char = (char-downcase char)\n          when (member lower-char vowels :test #'char=)\n          do (setf (gethash lower-char unique-vowels) t))\n    (hash-table-count unique-vowels)))\n\n\n(defun run-tests ()\n  (assert (= (count-unique-vowels \"Hello World\") 2) () \"Should count 2 unique vowels in 'Hello World'\")\n  (assert (= (count-unique-vowels \"Common Lisp\") 2) () \"Should count 2 unique vowels in 'Common Lisp'\")\n  (assert (= (count-unique-vowels \"AEIOUaeiou\") 5) () \"Should count 5 unique vowels in 'AEIOUaeiou'\")\n  (assert (= (count-unique-vowels \"xyz\") 0) () \"Should count 0 unique vowels in 'xyz'\")\n  (assert (= (count-unique-vowels \"\") 0) () \"Should count 0 unique vowels in empty string\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :subarray-utils\n  (:use :cl)\n  (:export :num-special-subarrays))\n\n(in-package :subarray-utils)\n\n(defun num-special-subarrays (arr k)\n  \"Calculates the number of special subarrays where the product of all elements is less than k.\nUses a sliding window approach for efficient computation.\"\n  (if (<= k 1)\n      0\n      (let ((product 1)\n            (result 0)\n            (left 0))\n        (loop for right from 0 below (length arr)\n              for value = (nth right arr)\n              do (setf product (* product value))\n              (loop while (>= product k)\n                    do (setf product (/ product (nth left arr)))\n                    (incf left))\n              (incf result (- right left -1)))\n        result)))", "test_cases": "", "test_case_results": "Input array: (10 5 2 6), k: 100\nResult: 8\nInput array: (1 2 3), k: 0\nResult: 0\nInput array: (1 1 1), k: 1\nResult: 0\nInput array: (1 2 3 4), k: 10\nResult: 7", "task_id": 14447, "assertions": "(defpackage :subarray-utils-test\n  (:use :cl :subarray-utils)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun run-tests ()\n  \"Tests the num-special-subarrays function with various test cases.\"\n  (assert (= (num-special-subarrays '(10 5 2 6) 100) 8) () \n          \"Test case 1 failed: Expected 8 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3) 0) 0) () \n          \"Test case 2 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 1 1) 1) 0) () \n          \"Test case 3 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3 4) 10) 7) () \n          \"Test case 4 failed: Expected 7 subarrays\")\n  (format t \"All tests passed successfully!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :subarray-utils-test\n  (:use :cl :subarray-utils)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun run-tests ()\n  \"Tests the num-special-subarrays function with various test cases.\"\n  (assert (= (num-special-subarrays '(10 5 2 6) 100) 8) () \n          \"Test case 1 failed: Expected 8 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3) 0) 0) () \n          \"Test case 2 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 1 1) 1) 0) () \n          \"Test case 3 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3 4) 10) 7) () \n          \"Test case 4 failed: Expected 7 subarrays\")\n  (format t \"All tests passed successfully!~%\"))\n\n(run-tests)", "output": "num-special-subarrays"}, "all_code": "(defpackage :subarray-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun num-special-subarrays (arr k)\n  \"Calculates the number of special subarrays where the product of all elements is less than k.\nUses a sliding window approach for efficient computation.\"\n  (if (<= k 1)\n      0\n      (let ((product 1)\n            (result 0)\n            (left 0))\n        (loop for right from 0 below (length arr)\n              for value = (nth right arr)\n              do (setf product (* product value))\n              (loop while (>= product k)\n                    do (setf product (/ product (nth left arr)))\n                    (incf left))\n              (incf result (- right left -1)))\n        result)))\n\n\n(defun run-tests ()\n  \"Tests the num-special-subarrays function with various test cases.\"\n  (assert (= (num-special-subarrays '(10 5 2 6) 100) 8) () \n          \"Test case 1 failed: Expected 8 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3) 0) 0) () \n          \"Test case 2 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 1 1) 1) 0) () \n          \"Test case 3 failed: Expected 0 subarrays\")\n  (assert (= (num-special-subarrays '(1 2 3 4) 10) 7) () \n          \"Test case 4 failed: Expected 7 subarrays\")\n  (format t \"All tests passed successfully!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :kth-occurrence\n  (:use :cl)\n  (:export :find-kth-occurrence :process-test-cases))\n\n(in-package :kth-occurrence)\n\n(defun find-kth-occurrence (n arr x k)\n  (let ((count 0)\n        (position -1))\n    (dotimes (idx n position)\n      (when (= (nth idx arr) x)\n        (incf count)\n        (when (= count k)\n          (setf position (1+ idx))\n          (return position))))))\n\n(defun process-test-cases (t-cases test-cases)\n  (let ((results '()))\n    (dotimes (i t-cases (reverse results))\n      (let* ((case (nth i test-cases))\n             (n (first case))\n             (arr (second case))\n             (x (third case))\n             (k (fourth case)))\n        (push (find-kth-occurrence n arr x k) results)))))", "test_cases": "", "test_case_results": "Testing find-kth-occurrence:\n\nInput: n=5, arr=(1 2 3 4 2), x=2, k=2\nResult: 5\n\nInput: n=6, arr=(1 1 1 1 1 1), x=1, k=7\nResult: -1\n\nInput: n=4, arr=(5 3 5 7), x=5, k=1\nResult: 1\n\nInput: n=4, arr=(5 3 5 7), x=5, k=2\nResult: 3\n\nInput: n=4, arr=(5 3 5 7), x=9, k=1\nResult: -1", "task_id": 16192, "assertions": "(defpackage :kth-occurrence-test\n  (:use :cl :kth-occurrence)\n  (:export :run-tests))\n\n(in-package :kth-occurrence-test)\n\n(defun run-tests ()\n  (assert (= (find-kth-occurrence 5 '(1 2 3 4 2) 2 2) 5) () \"2nd occurrence of 2 should be at position 5\")\n  (assert (= (find-kth-occurrence 6 '(1 1 1 1 1 1) 1 7) -1) () \"7th occurrence of 1 should not exist\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 1) 1) () \"1st occurrence of 5 should be at position 1\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 2) 3) () \"2nd occurrence of 5 should be at position 3\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 9 1) -1) () \"1st occurrence of 9 should not exist\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :kth-occurrence-test\n  (:use :cl :kth-occurrence)\n  (:export :run-tests))\n\n(in-package :kth-occurrence-test)\n\n(defun run-tests ()\n  (assert (= (find-kth-occurrence 5 '(1 2 3 4 2) 2 2) 5) () \"2nd occurrence of 2 should be at position 5\")\n  (assert (= (find-kth-occurrence 6 '(1 1 1 1 1 1) 1 7) -1) () \"7th occurrence of 1 should not exist\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 1) 1) () \"1st occurrence of 5 should be at position 1\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 2) 3) () \"2nd occurrence of 5 should be at position 3\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 9 1) -1) () \"1st occurrence of 9 should not exist\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-kth-occurrence"}, "all_code": "(defpackage :kth-occurrence-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :kth-occurrence-test)\n\n(defun find-kth-occurrence (n arr x k)\n  (let ((count 0)\n        (position -1))\n    (dotimes (idx n position)\n      (when (= (nth idx arr) x)\n        (incf count)\n        (when (= count k)\n          (setf position (1+ idx))\n          (return position))))))\n(defun process-test-cases (t-cases test-cases)\n  (let ((results '()))\n    (dotimes (i t-cases (reverse results))\n      (let* ((case (nth i test-cases))\n             (n (first case))\n             (arr (second case))\n             (x (third case))\n             (k (fourth case)))\n        (push (find-kth-occurrence n arr x k) results)))))\n\n\n(defun run-tests ()\n  (assert (= (find-kth-occurrence 5 '(1 2 3 4 2) 2 2) 5) () \"2nd occurrence of 2 should be at position 5\")\n  (assert (= (find-kth-occurrence 6 '(1 1 1 1 1 1) 1 7) -1) () \"7th occurrence of 1 should not exist\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 1) 1) () \"1st occurrence of 5 should be at position 1\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 5 2) 3) () \"2nd occurrence of 5 should be at position 3\")\n  (assert (= (find-kth-occurrence 4 '(5 3 5 7) 9 1) -1) () \"1st occurrence of 9 should not exist\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; count-swaps-to-sort calculates the minimum number of indices where elements need to be swapped\n; to make the list sorted in non-decreasing order.\n; It does this by comparing the original list with a sorted version of the list and counting\n; the positions where the elements differ.\n(defun count-swaps-to-sort (heights)\n  (let ((sorted-heights (sort (copy-list heights) #'<))\n        (out-of-place-count 0))\n    (dotimes (i (length heights) out-of-place-count)\n      (when (not (equal (nth i heights) (nth i sorted-heights)))\n        (incf out-of-place-count)))))", "test_cases": "", "test_case_results": "Input: (3 2 1)\nSwaps needed: 2\n\nInput: (1 2 3)\nSwaps needed: 0\n\nInput: (5 1 3 2 4)\nSwaps needed: 4\n\nInput: (1)\nSwaps needed: 0\n\nInput: (2 2 2 2)\nSwaps needed: 0", "task_id": 17898, "assertions": "(defpackage :swap-count-test\n  (:use :cl :cl-user)\n  (:export :run-swap-tests))\n\n(in-package :swap-count-test)\n\n(defun run-swap-tests ()\n  (assert (= (count-swaps-to-sort '(3 2 1)) 2) () \"Test case (3 2 1) should need 2 swaps\")\n  (assert (= (count-swaps-to-sort '(1 2 3)) 0) () \"Test case (1 2 3) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(5 1 3 2 4)) 4) () \"Test case (5 1 3 2 4) should need 4 swaps\")\n  (assert (= (count-swaps-to-sort '(1)) 0) () \"Test case (1) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(2 2 2 2)) 0) () \"Test case (2 2 2 2) should need 0 swaps\")\n  (format t \"All swap count tests passed!~%\"))\n\n(run-swap-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :swap-count-test\n  (:use :cl :cl-user)\n  (:export :run-swap-tests))\n\n(in-package :swap-count-test)\n\n(defun run-swap-tests ()\n  (assert (= (count-swaps-to-sort '(3 2 1)) 2) () \"Test case (3 2 1) should need 2 swaps\")\n  (assert (= (count-swaps-to-sort '(1 2 3)) 0) () \"Test case (1 2 3) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(5 1 3 2 4)) 4) () \"Test case (5 1 3 2 4) should need 4 swaps\")\n  (assert (= (count-swaps-to-sort '(1)) 0) () \"Test case (1) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(2 2 2 2)) 0) () \"Test case (2 2 2 2) should need 0 swaps\")\n  (format t \"All swap count tests passed!~%\"))\n\n(run-swap-tests)", "output": "count-swaps-to-sort"}, "all_code": "(defpackage :swap-count-test\n  (:use :cl)\n  (:export :run-swap-tests))\n\n(in-package :swap-count-test)\n\n(defun count-swaps-to-sort (heights)\n  (let ((sorted-heights (sort (copy-list heights) #'<))\n        (out-of-place-count 0))\n    (dotimes (i (length heights) out-of-place-count)\n      (when (not (equal (nth i heights) (nth i sorted-heights)))\n        (incf out-of-place-count)))))\n\n\n(defun run-swap-tests ()\n  (assert (= (count-swaps-to-sort '(3 2 1)) 2) () \"Test case (3 2 1) should need 2 swaps\")\n  (assert (= (count-swaps-to-sort '(1 2 3)) 0) () \"Test case (1 2 3) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(5 1 3 2 4)) 4) () \"Test case (5 1 3 2 4) should need 4 swaps\")\n  (assert (= (count-swaps-to-sort '(1)) 0) () \"Test case (1) should need 0 swaps\")\n  (assert (= (count-swaps-to-sort '(2 2 2 2)) 0) () \"Test case (2 2 2 2) should need 0 swaps\")\n  (format t \"All swap count tests passed!~%\"))\n\n(run-swap-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; find-min-abs-difference-split calculates the optimal split point in an array\n;;; that minimizes the absolute difference between the sums of the two parts.\n;;; It takes a list of test cases, where each test case is a cons of (n . array),\n;;; and returns a list of optimal split positions (1-based index).\n(defun find-min-abs-difference-split (test-cases)\n  (mapcar \n   (lambda (test-case)\n     (let* ((n (car test-case))\n            (array (cdr test-case))\n            (total-sum (apply #'+ array))\n            (min-diff most-positive-fixnum)\n            (sum-A 0)\n            best-k)\n       (dotimes (k (1- n) best-k)\n         (incf sum-A (nth k array))\n         (let* ((sum-B (- total-sum sum-A))\n                (diff (abs (- sum-A sum-B))))\n           (when (< diff min-diff)\n             (setf min-diff diff\n                   best-k (1+ k)))))))  ; Using 1-based index as in Python\n   test-cases))", "test_cases": "", "test_case_results": "Test cases:\n  Input: n=4, array=(3 1 2 4)\n  Input: n=5, array=(1 2 3 4 5)\n  Input: n=3, array=(10 20 30)\n  Input: n=2, array=(5 5)\nResults:\n  Test case 1: optimal split at position 2\n  Test case 2: optimal split at position 3\n  Test case 3: optimal split at position 2\n  Test case 4: optimal split at position 1", "task_id": 19929, "assertions": "(defpackage :min-abs-diff-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-abs-diff-test)\n\n(defun run-tests ()\n  (let ((test-cases '((4 . (3 1 2 4))\n                      (5 . (1 2 3 4 5))\n                      (3 . (10 20 30))\n                      (2 . (5 5)))))\n    (let ((results (cl-user::find-min-abs-difference-split test-cases)))\n      (assert (= (nth 0 results) 2) () \"Test case 1 failed\")\n      (assert (= (nth 1 results) 3) () \"Test case 2 failed\")\n      (assert (= (nth 2 results) 2) () \"Test case 3 failed\")\n      (assert (= (nth 3 results) 1) () \"Test case 4 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :min-abs-diff-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-abs-diff-test)\n\n(defun run-tests ()\n  (let ((test-cases '((4 . (3 1 2 4))\n                      (5 . (1 2 3 4 5))\n                      (3 . (10 20 30))\n                      (2 . (5 5)))))\n    (let ((results (cl-user::find-min-abs-difference-split test-cases)))\n      (assert (= (nth 0 results) 2) () \"Test case 1 failed\")\n      (assert (= (nth 1 results) 3) () \"Test case 2 failed\")\n      (assert (= (nth 2 results) 2) () \"Test case 3 failed\")\n      (assert (= (nth 3 results) 1) () \"Test case 4 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "output": "find-min-abs-difference-split"}, "all_code": "(defpackage :min-abs-diff-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :min-abs-diff-test)\n\n(defun find-min-abs-difference-split (test-cases)\n  (mapcar \n   (lambda (test-case)\n     (let* ((n (car test-case))\n            (array (cdr test-case))\n            (total-sum (apply #'+ array))\n            (min-diff most-positive-fixnum)\n            (sum-A 0)\n            best-k)\n       (dotimes (k (1- n) best-k)\n         (incf sum-A (nth k array))\n         (let* ((sum-B (- total-sum sum-A))\n                (diff (abs (- sum-A sum-B))))\n           (when (< diff min-diff)\n             (setf min-diff diff\n                   best-k (1+ k)))))))  ; Using 1-based index as in Python\n   test-cases))\n\n\n(defun run-tests ()\n  (let ((test-cases '((4 . (3 1 2 4))\n                      (5 . (1 2 3 4 5))\n                      (3 . (10 20 30))\n                      (2 . (5 5)))))\n    (let ((results (cl-user::find-min-abs-difference-split test-cases)))\n      (assert (= (nth 0 results) 2) () \"Test case 1 failed\")\n      (assert (= (nth 1 results) 3) () \"Test case 2 failed\")\n      (assert (= (nth 2 results) 2) () \"Test case 3 failed\")\n      (assert (= (nth 3 results) 1) () \"Test case 4 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; find-maximum-total-distance calculates the total distance covered by all animals\n; based on their segments and velocities.\n; Parameters:\n; - n: number of animals (unused in the calculation, but kept for interface consistency)\n; - k: number of segments\n; - segment-lengths: list of lengths for each segment\n; - animals: list of animal data, where each animal is represented as (start-segment end-segment velocity)\n; Returns the sum of the total distance covered by all animals across all segments.\n(defun find-maximum-total-distance (n k segment-lengths animals)\n  (let ((distance-covered (make-list k :initial-element 0)))\n    (dolist (animal animals)\n      (destructuring-bind (si ei vi) animal\n        (loop for segment from (1- si) below ei\n              do (incf (nth segment distance-covered)\n                       (* (nth segment segment-lengths) vi)))))\n    (apply #'+ distance-covered)))", "test_cases": "", "test_case_results": "Inputs:\nn: 3, k: 5\nsegment-lengths: (2 1 3 2 4)\nanimals: ((1 3 2) (2 5 1) (3 4 3))\nResult: 37", "task_id": 1169, "assertions": "(in-package :cl-user)\n\n(defun test-find-maximum-total-distance ()\n  (let ((n 3)\n        (k 5)\n        (segment-lengths '(2 1 3 2 4))\n        (animals '((1 3 2) (2 5 1) (3 4 3)))\n        (expected-result 37))\n    (assert (= (find-maximum-total-distance n k segment-lengths animals) expected-result)\n            () \n            \"Test failed: Expected ~a but got ~a\"\n            expected-result\n            (find-maximum-total-distance n k segment-lengths animals))\n    (format t \"Test passed successfully!~%\")))\n\n(test-find-maximum-total-distance)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-find-maximum-total-distance ()\n  (let ((n 3)\n        (k 5)\n        (segment-lengths '(2 1 3 2 4))\n        (animals '((1 3 2) (2 5 1) (3 4 3)))\n        (expected-result 37))\n    (assert (= (find-maximum-total-distance n k segment-lengths animals) expected-result)\n            () \n            \"Test failed: Expected ~a but got ~a\"\n            expected-result\n            (find-maximum-total-distance n k segment-lengths animals))\n    (format t \"Test passed successfully!~%\")))\n\n(test-find-maximum-total-distance)", "output": "find-maximum-total-distance"}, "all_code": "(in-package :cl-user)\n\n(defun find-maximum-total-distance (n k segment-lengths animals)\n  (let ((distance-covered (make-list k :initial-element 0)))\n    (dolist (animal animals)\n      (destructuring-bind (si ei vi) animal\n        (loop for segment from (1- si) below ei\n              do (incf (nth segment distance-covered)\n                       (* (nth segment segment-lengths) vi)))))\n    (apply #'+ distance-covered)))\n\n\n(defun test-find-maximum-total-distance ()\n  (let ((n 3)\n        (k 5)\n        (segment-lengths '(2 1 3 2 4))\n        (animals '((1 3 2) (2 5 1) (3 4 3)))\n        (expected-result 37))\n    (assert (= (find-maximum-total-distance n k segment-lengths animals) expected-result)\n            () \n            \"Test failed: Expected ~a but got ~a\"\n            expected-result\n            (find-maximum-total-distance n k segment-lengths animals))\n    (format t \"Test passed successfully!~%\")))\n\n(test-find-maximum-total-distance)", "exec_outcome": "PASSED"}
{"code": "(defpackage :ab-substring\n  (:use :cl)\n  (:export :longest-ab-substring))\n\n(in-package :ab-substring)\n\n(defun longest-ab-substring (s)\n  (let ((balance-map (make-hash-table))\n        (balance 0)\n        (max-len 0)\n        (start-idx -1))\n    (setf (gethash 0 balance-map) -1)\n    (loop for idx from 0 below (length s)\n          for char = (char s idx)\n          do (cond ((char= char #\\A) (incf balance))\n                   ((char= char #\\B) (decf balance)))\n          do (if (gethash balance balance-map)\n                 (let ((prev-idx (gethash balance balance-map)))\n                   (when (> (- idx prev-idx) max-len)\n                     (setf max-len (- idx prev-idx)\n                           start-idx (1+ prev-idx))))\n                 (setf (gethash balance balance-map) idx)))\n    (if (> max-len 0)\n        (subseq s start-idx (+ start-idx max-len))\n        \"\")))", "test_cases": "", "test_case_results": "Input: ABAAB\nResult: BAAB\nInput: AAABBB\nResult: AAABBB\nInput: AABBBAA\nResult: AABBBA\nInput: AAAA\nResult: \nInput: BBBB\nResult: \nInput: ABABAB\nResult: ABABAB", "task_id": 22340, "assertions": "(defpackage :ab-substring-test\n  (:use :cl :ab-substring)\n  (:export :run-tests))\n\n(in-package :ab-substring-test)\n\n(defun run-tests ()\n  (assert (string= (longest-ab-substring \"ABAAB\") \"BAAB\") () \"Test case 1 failed\")\n  (assert (string= (longest-ab-substring \"AAABBB\") \"AAABBB\") () \"Test case 2 failed\")\n  (assert (string= (longest-ab-substring \"AABBBAA\") \"AABBBA\") () \"Test case 3 failed\")\n  (assert (string= (longest-ab-substring \"AAAA\") \"\") () \"Test case 4 failed\")\n  (assert (string= (longest-ab-substring \"BBBB\") \"\") () \"Test case 5 failed\")\n  (assert (string= (longest-ab-substring \"ABABAB\") \"ABABAB\") () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :ab-substring-test\n  (:use :cl :ab-substring)\n  (:export :run-tests))\n\n(in-package :ab-substring-test)\n\n(defun run-tests ()\n  (assert (string= (longest-ab-substring \"ABAAB\") \"BAAB\") () \"Test case 1 failed\")\n  (assert (string= (longest-ab-substring \"AAABBB\") \"AAABBB\") () \"Test case 2 failed\")\n  (assert (string= (longest-ab-substring \"AABBBAA\") \"AABBBA\") () \"Test case 3 failed\")\n  (assert (string= (longest-ab-substring \"AAAA\") \"\") () \"Test case 4 failed\")\n  (assert (string= (longest-ab-substring \"BBBB\") \"\") () \"Test case 5 failed\")\n  (assert (string= (longest-ab-substring \"ABABAB\") \"ABABAB\") () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "longest-ab-substring"}, "all_code": "(defpackage :ab-substring-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :ab-substring-test)\n\n(defun longest-ab-substring (s)\n  (let ((balance-map (make-hash-table))\n        (balance 0)\n        (max-len 0)\n        (start-idx -1))\n    (setf (gethash 0 balance-map) -1)\n    (loop for idx from 0 below (length s)\n          for char = (char s idx)\n          do (cond ((char= char #\\A) (incf balance))\n                   ((char= char #\\B) (decf balance)))\n          do (if (gethash balance balance-map)\n                 (let ((prev-idx (gethash balance balance-map)))\n                   (when (> (- idx prev-idx) max-len)\n                     (setf max-len (- idx prev-idx)\n                           start-idx (1+ prev-idx))))\n                 (setf (gethash balance balance-map) idx)))\n    (if (> max-len 0)\n        (subseq s start-idx (+ start-idx max-len))\n        \"\")))\n\n\n(defun run-tests ()\n  (assert (string= (longest-ab-substring \"ABAAB\") \"BAAB\") () \"Test case 1 failed\")\n  (assert (string= (longest-ab-substring \"AAABBB\") \"AAABBB\") () \"Test case 2 failed\")\n  (assert (string= (longest-ab-substring \"AABBBAA\") \"AABBBA\") () \"Test case 3 failed\")\n  (assert (string= (longest-ab-substring \"AAAA\") \"\") () \"Test case 4 failed\")\n  (assert (string= (longest-ab-substring \"BBBB\") \"\") () \"Test case 5 failed\")\n  (assert (string= (longest-ab-substring \"ABABAB\") \"ABABAB\") () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :string-utils\n  (:use :cl)\n  (:export :closest-string :string-similarity))\n\n(in-package :string-utils)\n\n(defun closest-string (strings target)\n  (let ((closest nil)\n        (min-distance most-positive-double-float))\n    (dolist (string strings closest)\n      (let* ((distance (string-similarity string target))\n             (actual-distance (- 1.0 distance)))\n        (when (< actual-distance min-distance)\n          (setf min-distance actual-distance\n                closest string))))))\n\n(defun string-similarity (str1 str2)\n  (let ((len1 (length str1))\n        (len2 (length str2)))\n    (if (or (zerop len1) (zerop len2))\n        0.0\n        (let ((max-length (max len1 len2))\n              (matches 0))\n          (dotimes (i (min len1 len2) (/ (float matches) max-length))\n            (when (char= (char str1 i) (char str2 i))\n              (incf matches)))))))", "test_cases": "", "test_case_results": "Input strings: (hello world hell hallo)\nTarget string: hello\nClosest string: hello\n\nInput strings: (apple banana orange applet)\nTarget string: hello\nClosest string: apple\n\nInput strings: (cat dog bat rat)\nTarget string: hello\nClosest string: cat", "task_id": 9648, "assertions": "(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (let ((test-cases '((\"hello\" \"world\" \"hell\" \"hallo\") \n                      (\"apple\" \"banana\" \"orange\" \"applet\") \n                      (\"cat\" \"dog\" \"bat\" \"rat\"))))\n    (assert (string= (closest-string (first test-cases) \"hello\") \"hello\") \n            () \"First test case failed\")\n    (assert (string= (closest-string (second test-cases) \"hello\") \"apple\") \n            () \"Second test case failed\")\n    (assert (string= (closest-string (third test-cases) \"hello\") \"cat\") \n            () \"Third test case failed\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (let ((test-cases '((\"hello\" \"world\" \"hell\" \"hallo\") \n                      (\"apple\" \"banana\" \"orange\" \"applet\") \n                      (\"cat\" \"dog\" \"bat\" \"rat\"))))\n    (assert (string= (closest-string (first test-cases) \"hello\") \"hello\") \n            () \"First test case failed\")\n    (assert (string= (closest-string (second test-cases) \"hello\") \"apple\") \n            () \"Second test case failed\")\n    (assert (string= (closest-string (third test-cases) \"hello\") \"cat\") \n            () \"Third test case failed\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "closest-string"}, "all_code": "(defpackage :string-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun closest-string (strings target)\n  (let ((closest nil)\n        (min-distance most-positive-double-float))\n    (dolist (string strings closest)\n      (let* ((distance (string-similarity string target))\n             (actual-distance (- 1.0 distance)))\n        (when (< actual-distance min-distance)\n          (setf min-distance actual-distance\n                closest string))))))\n(defun string-similarity (str1 str2)\n  (let ((len1 (length str1))\n        (len2 (length str2)))\n    (if (or (zerop len1) (zerop len2))\n        0.0\n        (let ((max-length (max len1 len2))\n              (matches 0))\n          (dotimes (i (min len1 len2) (/ (float matches) max-length))\n            (when (char= (char str1 i) (char str2 i))\n              (incf matches)))))))\n\n\n(defun run-tests ()\n  (let ((test-cases '((\"hello\" \"world\" \"hell\" \"hallo\") \n                      (\"apple\" \"banana\" \"orange\" \"applet\") \n                      (\"cat\" \"dog\" \"bat\" \"rat\"))))\n    (assert (string= (closest-string (first test-cases) \"hello\") \"hello\") \n            () \"First test case failed\")\n    (assert (string= (closest-string (second test-cases) \"hello\") \"apple\") \n            () \"Second test case failed\")\n    (assert (string= (closest-string (third test-cases) \"hello\") \"cat\") \n            () \"Third test case failed\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-peak-activity-hour determines the hour when the user is most active based on the number of posts.\n; The input is a list of 24 integers representing the number of posts in each hour.\n; If there are multiple hours with the same maximum activity, it returns the earliest hour.\n(defun find-peak-activity-hour (posts)\n  (let ((max-posts (apply #'max posts)))\n    (position max-posts posts)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)\nPeak hour: 23\n\nInput: (24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)\nPeak hour: 0\n\nInput: (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)\nPeak hour: 0\n\nInput: (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)\nPeak hour: 23\n\nInput: (5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)\nPeak hour: 0", "task_id": 3115, "assertions": "(defpackage :peak-activity-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :peak-activity-test)\n\n(defun run-tests ()\n  (assert (= (find-peak-activity-hour '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)) 0)\n          () \"Peak should be hour 0\")\n  (assert (= (find-peak-activity-hour '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 0)\n          () \"Peak should be hour 0 (all equal)\")\n  (assert (= (find-peak-activity-hour '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 0)\n          () \"Peak should be hour 0 (first occurrence)\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :peak-activity-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :peak-activity-test)\n\n(defun run-tests ()\n  (assert (= (find-peak-activity-hour '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)) 0)\n          () \"Peak should be hour 0\")\n  (assert (= (find-peak-activity-hour '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 0)\n          () \"Peak should be hour 0 (all equal)\")\n  (assert (= (find-peak-activity-hour '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 0)\n          () \"Peak should be hour 0 (first occurrence)\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-peak-activity-hour"}, "all_code": "(defpackage :peak-activity-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :peak-activity-test)\n\n(defun find-peak-activity-hour (posts)\n  (let ((max-posts (apply #'max posts)))\n    (position max-posts posts)))\n\n\n(defun run-tests ()\n  (assert (= (find-peak-activity-hour '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)) 0)\n          () \"Peak should be hour 0\")\n  (assert (= (find-peak-activity-hour '(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)) 0)\n          () \"Peak should be hour 0 (all equal)\")\n  (assert (= (find-peak-activity-hour '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 23)\n          () \"Peak should be hour 23\")\n  (assert (= (find-peak-activity-hour '(5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5)) 0)\n          () \"Peak should be hour 0 (first occurrence)\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; partition-count calculates the number of ways to partition the integer n into non-negative integers.\n;; It uses dynamic programming to build a solution iteratively.\n;; The function initializes a 2D array (dp) where dp[i][j] represents the number of ways to partition j using integers up to i.\n;; The base case is that there's exactly one way to partition 0 (the empty partition).\n;; For each integer i from 1 to n, and for each j from 1 to n, the function updates dp[i][j] based on whether j >= i.\n;; If j >= i, dp[i][j] is the sum of dp[i-1][j] (exclude i) and dp[i][j-i] (include i).\n;; Otherwise, dp[i][j] is simply dp[i-1][j].\n(defun partition-count (n)\n  (let ((dp (make-array (list (1+ n) (1+ n)) :initial-element 0)))\n    ;; Base case: one way to partition 0\n    (dotimes (i (1+ n))\n      (setf (aref dp i 0) 1))\n    ;; Populate the dp table\n    (dotimes (i (1+ n))\n      (dotimes (j (1+ n))\n        (when (and (>= i 1) (>= j 1))\n          (if (>= j i)\n              (setf (aref dp i j) (+ (aref dp (1- i) j) (aref dp i (- j i))))\n              (setf (aref dp i j) (aref dp (1- i) j))))))\n    (aref dp n n)))", "test_cases": "", "test_case_results": "Input: 1\nPartitions: 1\n\nInput: 2\nPartitions: 2\n\nInput: 3\nPartitions: 3\n\nInput: 4\nPartitions: 5\n\nInput: 5\nPartitions: 7", "task_id": 22981, "assertions": "(defpackage :partition-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :partition-test)\n\n(defun run-tests ()\n  (assert (= (partition-count 1) 1) () \"Partition count for 1 should be 1\")\n  (assert (= (partition-count 2) 2) () \"Partition count for 2 should be 2\")\n  (assert (= (partition-count 3) 3) () \"Partition count for 3 should be 3\")\n  (assert (= (partition-count 4) 5) () \"Partition count for 4 should be 5\")\n  (assert (= (partition-count 5) 7) () \"Partition count for 5 should be 7\")\n  (format t \"All partition-count tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :partition-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :partition-test)\n\n(defun run-tests ()\n  (assert (= (partition-count 1) 1) () \"Partition count for 1 should be 1\")\n  (assert (= (partition-count 2) 2) () \"Partition count for 2 should be 2\")\n  (assert (= (partition-count 3) 3) () \"Partition count for 3 should be 3\")\n  (assert (= (partition-count 4) 5) () \"Partition count for 4 should be 5\")\n  (assert (= (partition-count 5) 7) () \"Partition count for 5 should be 7\")\n  (format t \"All partition-count tests passed!~%\"))\n\n(run-tests)", "output": "partition-count"}, "all_code": "(defpackage :partition-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :partition-test)\n\n(defun partition-count (n)\n  (let ((dp (make-array (list (1+ n) (1+ n)) :initial-element 0)))\n    ;; Base case: one way to partition 0\n    (dotimes (i (1+ n))\n      (setf (aref dp i 0) 1))\n    ;; Populate the dp table\n    (dotimes (i (1+ n))\n      (dotimes (j (1+ n))\n        (when (and (>= i 1) (>= j 1))\n          (if (>= j i)\n              (setf (aref dp i j) (+ (aref dp (1- i) j) (aref dp i (- j i))))\n              (setf (aref dp i j) (aref dp (1- i) j))))))\n    (aref dp n n)))\n\n\n(defun run-tests ()\n  (assert (= (partition-count 1) 1) () \"Partition count for 1 should be 1\")\n  (assert (= (partition-count 2) 2) () \"Partition count for 2 should be 2\")\n  (assert (= (partition-count 3) 3) () \"Partition count for 3 should be 3\")\n  (assert (= (partition-count 4) 5) () \"Partition count for 4 should be 5\")\n  (assert (= (partition-count 5) 7) () \"Partition count for 5 should be 7\")\n  (format t \"All partition-count tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n(defun longest-subsequence (nums)\n  \"Calculates the length of the longest subsequence where adjacent elements differ by exactly 1.\n  Returns 0 for empty lists.\"\n  (if (null nums)\n      0\n      (let ((max-length 1)\n            (curr-length 1))\n        (loop for i from 1 below (length nums)\n              do (if (= (abs (- (nth i nums) (nth (1- i) nums))) 1)\n                     (progn\n                       (incf curr-length)\n                       (setf max-length (max max-length curr-length)))\n                     (setf curr-length 1)))\n        max-length)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5)\nResult: 5\n\nInput: (5 4 3 2 1)\nResult: 5\n\nInput: (1 3 5 7 9)\nResult: 1\n\nInput: (1 2 1 2 3 2 3 4)\nResult: 8\n\nInput: NIL\nResult: 0\n\nInput: (1)\nResult: 1\n\nInput: (1 2 0 1 2 3 4 3)\nResult: 6", "task_id": 1715, "assertions": "(defpackage :subsequence-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :subsequence-test)\n\n(defun run-tests ()\n  (assert (= (longest-subsequence '(1 2 3 4 5)) 5) () \"Test case 1 failed\")\n  (assert (= (longest-subsequence '(5 4 3 2 1)) 5) () \"Test case 2 failed\")\n  (assert (= (longest-subsequence '(1 3 5 7 9)) 1) () \"Test case 3 failed\")\n  (assert (= (longest-subsequence '(1 2 1 2 3 2 3 4)) 8) () \"Test case 4 failed\")\n  (assert (= (longest-subsequence nil) 0) () \"Test case 5 failed\")\n  (assert (= (longest-subsequence '(1)) 1) () \"Test case 6 failed\")\n  (assert (= (longest-subsequence '(1 2 0 1 2 3 4 3)) 6) () \"Test case 7 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :subsequence-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :subsequence-test)\n\n(defun run-tests ()\n  (assert (= (longest-subsequence '(1 2 3 4 5)) 5) () \"Test case 1 failed\")\n  (assert (= (longest-subsequence '(5 4 3 2 1)) 5) () \"Test case 2 failed\")\n  (assert (= (longest-subsequence '(1 3 5 7 9)) 1) () \"Test case 3 failed\")\n  (assert (= (longest-subsequence '(1 2 1 2 3 2 3 4)) 8) () \"Test case 4 failed\")\n  (assert (= (longest-subsequence nil) 0) () \"Test case 5 failed\")\n  (assert (= (longest-subsequence '(1)) 1) () \"Test case 6 failed\")\n  (assert (= (longest-subsequence '(1 2 0 1 2 3 4 3)) 6) () \"Test case 7 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "longest-subsequence"}, "all_code": "(defpackage :subsequence-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :subsequence-test)\n\n(defun longest-subsequence (nums)\n  \"Calculates the length of the longest subsequence where adjacent elements differ by exactly 1.\n  Returns 0 for empty lists.\"\n  (if (null nums)\n      0\n      (let ((max-length 1)\n            (curr-length 1))\n        (loop for i from 1 below (length nums)\n              do (if (= (abs (- (nth i nums) (nth (1- i) nums))) 1)\n                     (progn\n                       (incf curr-length)\n                       (setf max-length (max max-length curr-length)))\n                     (setf curr-length 1)))\n        max-length)))\n\n\n(defun run-tests ()\n  (assert (= (longest-subsequence '(1 2 3 4 5)) 5) () \"Test case 1 failed\")\n  (assert (= (longest-subsequence '(5 4 3 2 1)) 5) () \"Test case 2 failed\")\n  (assert (= (longest-subsequence '(1 3 5 7 9)) 1) () \"Test case 3 failed\")\n  (assert (= (longest-subsequence '(1 2 1 2 3 2 3 4)) 8) () \"Test case 4 failed\")\n  (assert (= (longest-subsequence nil) 0) () \"Test case 5 failed\")\n  (assert (= (longest-subsequence '(1)) 1) () \"Test case 6 failed\")\n  (assert (= (longest-subsequence '(1 2 0 1 2 3 4 3)) 6) () \"Test case 7 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; pivot-index finds the pivot index in a list of numbers where the sum of elements \n;; to the left is equal to the sum of elements to the right.\n;; If no such index exists, it returns -1.\n;; The function first calculates the total sum of the list, then iterates through \n;; the list while maintaining a running sum of the left elements.\n;; For each element, it checks if the left sum equals the total sum minus the \n;; left sum and the current element.\n(defun pivot-index (nums)\n  (let ((total-sum (apply #'+ nums))\n        (left-sum 0))\n    (dotimes (i (length nums) -1)\n      (let ((num (nth i nums)))\n        (if (= left-sum (- total-sum left-sum num))\n            (return i)\n            (incf left-sum num))))))", "test_cases": "", "test_case_results": "Input: (1 7 3 6 5 6)\nPivot index: 3\n\nInput: (1 2 3)\nPivot index: -1\n\nInput: (2 1 -1)\nPivot index: 0\n\nInput: NIL\nPivot index: -1\n\nInput: (0 0 0 0 0)\nPivot index: 0", "task_id": 29486, "assertions": "(defpackage :pivot-index-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :pivot-index-test)\n\n(defun run-tests ()\n  (assert (= (pivot-index '(1 7 3 6 5 6)) 3) () \"Pivot index should be 3\")\n  (assert (= (pivot-index '(1 2 3)) -1) () \"Pivot index should be -1\")\n  (assert (= (pivot-index '(2 1 -1)) 0) () \"Pivot index should be 0\")\n  (assert (= (pivot-index nil) -1) () \"Empty list should return -1\")\n  (assert (= (pivot-index '(0 0 0 0 0)) 0) () \"All zeros should return 0\")\n  (format t \"All pivot-index tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :pivot-index-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :pivot-index-test)\n\n(defun run-tests ()\n  (assert (= (pivot-index '(1 7 3 6 5 6)) 3) () \"Pivot index should be 3\")\n  (assert (= (pivot-index '(1 2 3)) -1) () \"Pivot index should be -1\")\n  (assert (= (pivot-index '(2 1 -1)) 0) () \"Pivot index should be 0\")\n  (assert (= (pivot-index nil) -1) () \"Empty list should return -1\")\n  (assert (= (pivot-index '(0 0 0 0 0)) 0) () \"All zeros should return 0\")\n  (format t \"All pivot-index tests passed!~%\"))\n\n(run-tests)", "output": "pivot-index"}, "all_code": "(defpackage :pivot-index-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :pivot-index-test)\n\n(defun pivot-index (nums)\n  (let ((total-sum (apply #'+ nums))\n        (left-sum 0))\n    (dotimes (i (length nums) -1)\n      (let ((num (nth i nums)))\n        (if (= left-sum (- total-sum left-sum num))\n            (return i)\n            (incf left-sum num))))))\n\n\n(defun run-tests ()\n  (assert (= (pivot-index '(1 7 3 6 5 6)) 3) () \"Pivot index should be 3\")\n  (assert (= (pivot-index '(1 2 3)) -1) () \"Pivot index should be -1\")\n  (assert (= (pivot-index '(2 1 -1)) 0) () \"Pivot index should be 0\")\n  (assert (= (pivot-index nil) -1) () \"Empty list should return -1\")\n  (assert (= (pivot-index '(0 0 0 0 0)) 0) () \"All zeros should return 0\")\n  (format t \"All pivot-index tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; min-changes-to-sort-heights calculates the minimum number of changes required\n; to make a list of heights non-decreasing. It does this by finding the length\n; of the longest common subsequence (LCS) between the original list and its sorted\n; version, then subtracting this from the total length of the list.\n(defun min-changes-to-sort-heights (heights)\n  (let* ((n (length heights))\n         (sorted-heights (sort (copy-list heights) #'<))\n         (dp (make-array (list (1+ n) (1+ n)) :initial-element 0)))\n    (if (zerop n)\n        0\n        (progn\n          (dotimes (i n)\n            (dotimes (j n)\n              (if (equal (nth i heights) (nth j sorted-heights))\n                  (setf (aref dp (1+ i) (1+ j)) (1+ (aref dp i j)))\n                  (setf (aref dp (1+ i) (1+ j)) \n                        (max (aref dp (1+ i) j) (aref dp i (1+ j)))))))\n          (- n (aref dp n n))))))", "test_cases": "", "test_case_results": "Input: (3 1 2 4)\nResult: 1\n\nInput: (5 4 3 2 1)\nResult: 4\n\nInput: (1 2 3 4 5)\nResult: 0\n\nInput: NIL\nResult: 0\n\nInput: (1 1 1 1)\nResult: 0", "task_id": 9522, "assertions": "(defpackage :height-sort-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :height-sort-test)\n\n(defun run-tests ()\n  (assert (= (min-changes-to-sort-heights '(3 1 2 4)) 1) () \"Test case 1 failed\")\n  (assert (= (min-changes-to-sort-heights '(5 4 3 2 1)) 4) () \"Test case 2 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 2 3 4 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-changes-to-sort-heights '()) 0) () \"Test case 4 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 1 1 1)) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :height-sort-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :height-sort-test)\n\n(defun run-tests ()\n  (assert (= (min-changes-to-sort-heights '(3 1 2 4)) 1) () \"Test case 1 failed\")\n  (assert (= (min-changes-to-sort-heights '(5 4 3 2 1)) 4) () \"Test case 2 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 2 3 4 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-changes-to-sort-heights '()) 0) () \"Test case 4 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 1 1 1)) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-changes-to-sort-heights"}, "all_code": "(defpackage :height-sort-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :height-sort-test)\n\n(defun min-changes-to-sort-heights (heights)\n  (let* ((n (length heights))\n         (sorted-heights (sort (copy-list heights) #'<))\n         (dp (make-array (list (1+ n) (1+ n)) :initial-element 0)))\n    (if (zerop n)\n        0\n        (progn\n          (dotimes (i n)\n            (dotimes (j n)\n              (if (equal (nth i heights) (nth j sorted-heights))\n                  (setf (aref dp (1+ i) (1+ j)) (1+ (aref dp i j)))\n                  (setf (aref dp (1+ i) (1+ j)) \n                        (max (aref dp (1+ i) j) (aref dp i (1+ j)))))))\n          (- n (aref dp n n))))))\n\n\n(defun run-tests ()\n  (assert (= (min-changes-to-sort-heights '(3 1 2 4)) 1) () \"Test case 1 failed\")\n  (assert (= (min-changes-to-sort-heights '(5 4 3 2 1)) 4) () \"Test case 2 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 2 3 4 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-changes-to-sort-heights '()) 0) () \"Test case 4 failed\")\n  (assert (= (min-changes-to-sort-heights '(1 1 1 1)) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; rotate-wheel calculates the final configuration of an encoder wheel after applying a series of rotation operations.\n; The wheel is rotated by the net rotation (sum of all operations modulo n), and the result is constructed by\n; concatenating the last 'net-rotation' elements with the rest of the wheel.\n; Parameters:\n;   n - number of positions on the wheel (integer)\n;   wheel - initial configuration of the wheel (list of integers)\n;   operations - list of rotation operations (list of integers)\n; Returns:\n;   The final configuration of the wheel (list of integers)\n(defun rotate-wheel (n wheel operations)\n  (let* ((net-rotation (mod (apply #'+ operations) n))\n         (net-rotation (if (minusp net-rotation) (+ net-rotation n) net-rotation)))\n    (append (subseq wheel (- (length wheel) net-rotation))\n            (subseq wheel 0 (- (length wheel) net-rotation)))))\n\n; process-test-cases processes multiple test cases by applying rotate-wheel to each one.\n; Parameters:\n;   test-cases - a list of test cases, where each test case is a list of (n wheel operations)\n; Returns:\n;   A list of final wheel configurations for each test case (list of lists of integers)\n(defun process-test-cases (test-cases)\n  (mapcar (lambda (test-case)\n            (destructuring-bind (n wheel operations) test-case\n              (rotate-wheel n wheel operations)))\n          test-cases))", "test_cases": "", "test_case_results": "Testing rotate-wheel and process-test-cases:\nInput: n=5, wheel=(1 2 3 4 5), operations=(1 1 1)\nOutput: (3 4 5 1 2)\nInput: n=4, wheel=(10 20 30 40), operations=(-1 2 -1)\nOutput: (10 20 30 40)\nInput: n=3, wheel=(100 200 300), operations=(5 -4)\nOutput: (300 100 200)\n\nTesting process-test-cases with all test cases:\nOutput: ((3 4 5 1 2) (10 20 30 40) (300 100 200))", "task_id": 26636, "assertions": "(defpackage :wheel-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :wheel-test)\n\n(defun run-tests ()\n  (let ((test-cases '((5 (1 2 3 4 5) (1 1 1))\n                      (4 (10 20 30 40) (-1 2 -1))\n                      (3 (100 200 300) (5 -4)))))\n    (assert (equal (cl-user:rotate-wheel 5 '(1 2 3 4 5) '(1 1 1)) \n                   '(3 4 5 1 2)) () \"Test case 1 failed\")\n    (assert (equal (cl-user:rotate-wheel 4 '(10 20 30 40) '(-1 2 -1)) \n                   '(10 20 30 40)) () \"Test case 2 failed\")\n    (assert (equal (cl-user:rotate-wheel 3 '(100 200 300) '(5 -4)) \n                   '(300 100 200)) () \"Test case 3 failed\")\n    (assert (equal (cl-user:process-test-cases test-cases) \n                   '((3 4 5 1 2) (10 20 30 40) (300 100 200))) () \"Process-test-cases failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :wheel-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :wheel-test)\n\n(defun run-tests ()\n  (let ((test-cases '((5 (1 2 3 4 5) (1 1 1))\n                      (4 (10 20 30 40) (-1 2 -1))\n                      (3 (100 200 300) (5 -4)))))\n    (assert (equal (cl-user:rotate-wheel 5 '(1 2 3 4 5) '(1 1 1)) \n                   '(3 4 5 1 2)) () \"Test case 1 failed\")\n    (assert (equal (cl-user:rotate-wheel 4 '(10 20 30 40) '(-1 2 -1)) \n                   '(10 20 30 40)) () \"Test case 2 failed\")\n    (assert (equal (cl-user:rotate-wheel 3 '(100 200 300) '(5 -4)) \n                   '(300 100 200)) () \"Test case 3 failed\")\n    (assert (equal (cl-user:process-test-cases test-cases) \n                   '((3 4 5 1 2) (10 20 30 40) (300 100 200))) () \"Process-test-cases failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "rotate-wheel"}, "all_code": "(defpackage :wheel-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :wheel-test)\n\n(defun rotate-wheel (n wheel operations)\n  (let* ((net-rotation (mod (apply #'+ operations) n))\n         (net-rotation (if (minusp net-rotation) (+ net-rotation n) net-rotation)))\n    (append (subseq wheel (- (length wheel) net-rotation))\n            (subseq wheel 0 (- (length wheel) net-rotation)))))\n\n; process-test-cases processes multiple test cases by applying rotate-wheel to each one.\n; Parameters:\n;   test-cases - a list of test cases, where each test case is a list of (n wheel operations)\n; Returns:\n;   A list of final wheel configurations for each test case (list of lists of integers)\n(defun process-test-cases (test-cases)\n  (mapcar (lambda (test-case)\n            (destructuring-bind (n wheel operations) test-case\n              (rotate-wheel n wheel operations)))\n          test-cases))\n\n\n(defun run-tests ()\n  (let ((test-cases '((5 (1 2 3 4 5) (1 1 1))\n                      (4 (10 20 30 40) (-1 2 -1))\n                      (3 (100 200 300) (5 -4)))))\n    (assert (equal (rotate-wheel 5 '(1 2 3 4 5) '(1 1 1)) \n                   '(3 4 5 1 2)) () \"Test case 1 failed\")\n    (assert (equal (rotate-wheel 4 '(10 20 30 40) '(-1 2 -1)) \n                   '(10 20 30 40)) () \"Test case 2 failed\")\n    (assert (equal (rotate-wheel 3 '(100 200 300) '(5 -4)) \n                   '(300 100 200)) () \"Test case 3 failed\")\n    (assert (equal (process-test-cases test-cases) \n                   '((3 4 5 1 2) (10 20 30 40) (300 100 200))) () \"Process-test-cases failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; min-steps calculates the minimum number of steps required to reach the bottom-right corner\n; of the maze from the top-left corner. The maze is represented as a list of lists where\n; '0' represents a passable cell and '1' represents a blocked cell.\n; If the destination is unreachable, it returns -1.\n(defun min-steps (maze)\n  (if (or (null maze) (null (first maze)) \n          (char= (aref (first maze) 0) #\\1) \n          (char= (aref (first (last maze)) (1- (length (first maze)))) #\\1))\n      -1\n      (let* ((rows (length maze))\n             (cols (length (first maze)))\n             (directions '((1 0) (-1 0) (0 1) (0 -1))) ; Down, Up, Right, Left\n             (queue (list (list 0 0 0))) ; (row col steps)\n             (visited (make-hash-table :test 'equal)))\n        (setf (gethash '(0 0) visited) t)\n        (loop while queue do\n          (let* ((current (pop queue))\n                 (row (first current))\n                 (col (second current))\n                 (steps (third current)))\n            (when (and (= row (1- rows)) (= col (1- cols)))\n              (return-from min-steps steps))\n            (dolist (dir directions)\n              (let* ((dr (first dir))\n                     (dc (second dir))\n                     (r (+ row dr))\n                     (c (+ col dc)))\n                (when (and (>= r 0) (< r rows) (>= c 0) (< c cols)\n                           (char= (aref (nth r maze) c) #\\0)\n                           (not (gethash (list r c) visited)))\n                  (setf (gethash (list r c) visited) t)\n                  (setq queue (append queue (list (list r c (1+ steps))))))))))\n        -1)))", "test_cases": "", "test_case_results": "Maze: (000 010 000)\nMin steps: 4\nMaze: (000 011 010)\nMin steps: -1\nMaze: (0000 0101 0000)\nMin steps: 5\nMaze: (01 10)\nMin steps: -1", "task_id": 27079, "assertions": "(in-package :cl-user)\n\n(defun test-min-steps ()\n  (assert (= (min-steps '(\"000\" \"010\" \"000\")) 4) () \"Test case 1 failed\")\n  (assert (= (min-steps '(\"000\" \"011\" \"010\")) -1) () \"Test case 2 failed\")\n  (assert (= (min-steps '(\"0000\" \"0101\" \"0000\")) 5) () \"Test case 3 failed\")\n  (assert (= (min-steps '(\"01\" \"10\")) -1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-steps)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-min-steps ()\n  (assert (= (min-steps '(\"000\" \"010\" \"000\")) 4) () \"Test case 1 failed\")\n  (assert (= (min-steps '(\"000\" \"011\" \"010\")) -1) () \"Test case 2 failed\")\n  (assert (= (min-steps '(\"0000\" \"0101\" \"0000\")) 5) () \"Test case 3 failed\")\n  (assert (= (min-steps '(\"01\" \"10\")) -1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-steps)", "output": "min-steps"}, "all_code": "(in-package :cl-user)\n\n(defun min-steps (maze)\n  (if (or (null maze) (null (first maze)) \n          (char= (aref (first maze) 0) #\\1) \n          (char= (aref (first (last maze)) (1- (length (first maze)))) #\\1))\n      -1\n      (let* ((rows (length maze))\n             (cols (length (first maze)))\n             (directions '((1 0) (-1 0) (0 1) (0 -1))) ; Down, Up, Right, Left\n             (queue (list (list 0 0 0))) ; (row col steps)\n             (visited (make-hash-table :test 'equal)))\n        (setf (gethash '(0 0) visited) t)\n        (loop while queue do\n          (let* ((current (pop queue))\n                 (row (first current))\n                 (col (second current))\n                 (steps (third current)))\n            (when (and (= row (1- rows)) (= col (1- cols)))\n              (return-from min-steps steps))\n            (dolist (dir directions)\n              (let* ((dr (first dir))\n                     (dc (second dir))\n                     (r (+ row dr))\n                     (c (+ col dc)))\n                (when (and (>= r 0) (< r rows) (>= c 0) (< c cols)\n                           (char= (aref (nth r maze) c) #\\0)\n                           (not (gethash (list r c) visited)))\n                  (setf (gethash (list r c) visited) t)\n                  (setq queue (append queue (list (list r c (1+ steps))))))))))\n        -1)))\n\n\n(defun test-min-steps ()\n  (assert (= (min-steps '(\"000\" \"010\" \"000\")) 4) () \"Test case 1 failed\")\n  (assert (= (min-steps '(\"000\" \"011\" \"010\")) -1) () \"Test case 2 failed\")\n  (assert (= (min-steps '(\"0000\" \"0101\" \"0000\")) 5) () \"Test case 3 failed\")\n  (assert (= (min-steps '(\"01\" \"10\")) -1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-steps)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-adjacent-pair checks if there exists a pair of adjacent elements in a list of numbers\n; that add up to the given target value. \n; It iterates through the list, checking each adjacent pair.\n; Returns T if such a pair is found, otherwise NIL.\n(defun find-adjacent-pair (numbers target)\n  (loop for i from 0 below (1- (length numbers))\n        when (= (+ (nth i numbers) (nth (1+ i) numbers)) target)\n          do (return-from find-adjacent-pair t))\n  nil)", "test_cases": "", "test_case_results": "Numbers: (1 2 3 4), Target: 5, Result: T\nNumbers: (5 6 7 8), Target: 15, Result: T\nNumbers: (0 0 0 0), Target: 1, Result: NIL\nNumbers: (10 20 30), Target: 50, Result: T", "task_id": 14450, "assertions": "(defpackage :find-adjacent-pair-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :find-adjacent-pair-test)\n\n(defun run-tests ()\n  (assert (find-adjacent-pair '(1 2 3 4) 5) () \"Test case 1 failed\")\n  (assert (find-adjacent-pair '(5 6 7 8) 15) () \"Test case 2 failed\")\n  (assert (not (find-adjacent-pair '(0 0 0 0) 1)) () \"Test case 3 failed\")\n  (assert (find-adjacent-pair '(10 20 30) 50) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :find-adjacent-pair-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :find-adjacent-pair-test)\n\n(defun run-tests ()\n  (assert (find-adjacent-pair '(1 2 3 4) 5) () \"Test case 1 failed\")\n  (assert (find-adjacent-pair '(5 6 7 8) 15) () \"Test case 2 failed\")\n  (assert (not (find-adjacent-pair '(0 0 0 0) 1)) () \"Test case 3 failed\")\n  (assert (find-adjacent-pair '(10 20 30) 50) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-adjacent-pair"}, "all_code": "(defpackage :find-adjacent-pair-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :find-adjacent-pair-test)\n\n(defun find-adjacent-pair (numbers target)\n  (loop for i from 0 below (1- (length numbers))\n        when (= (+ (nth i numbers) (nth (1+ i) numbers)) target)\n          do (return-from find-adjacent-pair t))\n  nil)\n\n\n(defun run-tests ()\n  (assert (find-adjacent-pair '(1 2 3 4) 5) () \"Test case 1 failed\")\n  (assert (find-adjacent-pair '(5 6 7 8) 15) () \"Test case 2 failed\")\n  (assert (not (find-adjacent-pair '(0 0 0 0) 1)) () \"Test case 3 failed\")\n  (assert (find-adjacent-pair '(10 20 30) 50) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; Password Complexity Checker in Common Lisp\n\n;;; check-password-complexity evaluates the complexity of a given password.\n;;; It checks the length, presence of letters, digits, and special characters.\n;;; Returns \"Weak\", \"Moderate\", or \"Strong\" based on the criteria.\n(defun check-password-complexity (password)\n  (let ((length-ok (>= (length password) 8))\n        (has-letter (some #'alpha-char-p password))\n        (has-digit (some #'digit-char-p password))\n        (has-special (some (lambda (c) (find c \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\")) password)))\n    (cond\n      ((not length-ok) \"Weak\")\n      ((and has-letter has-digit has-special) \"Strong\")\n      ((and has-letter has-digit) \"Moderate\")\n      (t \"Weak\"))))\n\n;;; suggest-password-improvements provides suggestions to improve password complexity.\n;;; Returns a list of suggestions based on what the password lacks.\n(defun suggest-password-improvements (password)\n  (let ((suggestions nil))\n    (when (< (length password) 8)\n      (push \"Use at least 8 characters\" suggestions))\n    (unless (some #'digit-char-p password)\n      (push \"Include digits\" suggestions))\n    (unless (some #'alpha-char-p password)\n      (push \"Include letters\" suggestions))\n    (unless (some (lambda (c) (find c \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\")) password)\n      (push \"Include special characters\" suggestions))\n    (nreverse suggestions)))", "test_cases": "", "test_case_results": "Testing Password Complexity:\n\nPassword: short\nComplexity: Weak\nSuggestions: (Use at least 8 characters Include digits\n              Include special characters)\n\nPassword: longenough\nComplexity: Weak\nSuggestions: (Include digits Include special characters)\n\nPassword: with123\nComplexity: Weak\nSuggestions: (Use at least 8 characters Include special characters)\n\nPassword: with!@#\nComplexity: Weak\nSuggestions: (Use at least 8 characters Include digits)\n\nPassword: perfect123!\nComplexity: Strong\nSuggestions: NIL\n\nPassword: 12345678\nComplexity: Weak\nSuggestions: (Include letters Include special characters)\n\nPassword: !@#$%^&*\nComplexity: Weak\nSuggestions: (Include digits Include letters)\n\nPassword: lettersOnly\nComplexity: Weak\nSuggestions: (Include digits Include special characters)", "task_id": 7103, "assertions": "(defpackage :password-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun run-tests ()\n  ;; Test check-password-complexity\n  (assert (string= (check-password-complexity \"short\") \"Weak\") () \"short should be Weak\")\n  (assert (string= (check-password-complexity \"longenough\") \"Weak\") () \"longenough should be Weak\")\n  (assert (string= (check-password-complexity \"with123\") \"Weak\") () \"with123 should be Weak\")\n  (assert (string= (check-password-complexity \"with!@#\") \"Weak\") () \"with!@# should be Weak\")\n  (assert (string= (check-password-complexity \"perfect123!\") \"Strong\") () \"perfect123! should be Strong\")\n  (assert (string= (check-password-complexity \"12345678\") \"Weak\") () \"12345678 should be Weak\")\n  (assert (string= (check-password-complexity \"!@#$%^&*\") \"Weak\") () \"!@#$%^&* should be Weak\")\n  (assert (string= (check-password-complexity \"lettersOnly\") \"Weak\") () \"lettersOnly should be Weak\")\n\n  ;; Test suggest-password-improvements\n  (assert (equal (suggest-password-improvements \"short\") \n                '(\"Use at least 8 characters\" \"Include digits\" \"Include special characters\")) \n          () \"short suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"longenough\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"longenough suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with123\") \n                '(\"Use at least 8 characters\" \"Include special characters\")) \n          () \"with123 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with!@#\") \n                '(\"Use at least 8 characters\" \"Include digits\")) \n          () \"with!@# suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"perfect123!\") nil) \n          () \"perfect123! suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"12345678\") \n                '(\"Include letters\" \"Include special characters\")) \n          () \"12345678 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"!@#$%^&*\") \n                '(\"Include digits\" \"Include letters\")) \n          () \"!@#$%^&* suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"lettersOnly\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"lettersOnly suggestions incorrect\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :password-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun run-tests ()\n  ;; Test check-password-complexity\n  (assert (string= (check-password-complexity \"short\") \"Weak\") () \"short should be Weak\")\n  (assert (string= (check-password-complexity \"longenough\") \"Weak\") () \"longenough should be Weak\")\n  (assert (string= (check-password-complexity \"with123\") \"Weak\") () \"with123 should be Weak\")\n  (assert (string= (check-password-complexity \"with!@#\") \"Weak\") () \"with!@# should be Weak\")\n  (assert (string= (check-password-complexity \"perfect123!\") \"Strong\") () \"perfect123! should be Strong\")\n  (assert (string= (check-password-complexity \"12345678\") \"Weak\") () \"12345678 should be Weak\")\n  (assert (string= (check-password-complexity \"!@#$%^&*\") \"Weak\") () \"!@#$%^&* should be Weak\")\n  (assert (string= (check-password-complexity \"lettersOnly\") \"Weak\") () \"lettersOnly should be Weak\")\n\n  ;; Test suggest-password-improvements\n  (assert (equal (suggest-password-improvements \"short\") \n                '(\"Use at least 8 characters\" \"Include digits\" \"Include special characters\")) \n          () \"short suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"longenough\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"longenough suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with123\") \n                '(\"Use at least 8 characters\" \"Include special characters\")) \n          () \"with123 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with!@#\") \n                '(\"Use at least 8 characters\" \"Include digits\")) \n          () \"with!@# suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"perfect123!\") nil) \n          () \"perfect123! suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"12345678\") \n                '(\"Include letters\" \"Include special characters\")) \n          () \"12345678 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"!@#$%^&*\") \n                '(\"Include digits\" \"Include letters\")) \n          () \"!@#$%^&* suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"lettersOnly\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"lettersOnly suggestions incorrect\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "The functions being tested are:\ncheck-password-complexity\nsuggest-password-improvements"}, "all_code": "(defpackage :password-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun check-password-complexity (password)\n  (let ((length-ok (>= (length password) 8))\n        (has-letter (some #'alpha-char-p password))\n        (has-digit (some #'digit-char-p password))\n        (has-special (some (lambda (c) (find c \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\")) password)))\n    (cond\n      ((not length-ok) \"Weak\")\n      ((and has-letter has-digit has-special) \"Strong\")\n      ((and has-letter has-digit) \"Moderate\")\n      (t \"Weak\"))))\n\n;;; suggest-password-improvements provides suggestions to improve password complexity.\n;;; Returns a list of suggestions based on what the password lacks.\n(defun suggest-password-improvements (password)\n  (let ((suggestions nil))\n    (when (< (length password) 8)\n      (push \"Use at least 8 characters\" suggestions))\n    (unless (some #'digit-char-p password)\n      (push \"Include digits\" suggestions))\n    (unless (some #'alpha-char-p password)\n      (push \"Include letters\" suggestions))\n    (unless (some (lambda (c) (find c \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\")) password)\n      (push \"Include special characters\" suggestions))\n    (nreverse suggestions)))\n\n\n(defun run-tests ()\n  ;; Test check-password-complexity\n  (assert (string= (check-password-complexity \"short\") \"Weak\") () \"short should be Weak\")\n  (assert (string= (check-password-complexity \"longenough\") \"Weak\") () \"longenough should be Weak\")\n  (assert (string= (check-password-complexity \"with123\") \"Weak\") () \"with123 should be Weak\")\n  (assert (string= (check-password-complexity \"with!@#\") \"Weak\") () \"with!@# should be Weak\")\n  (assert (string= (check-password-complexity \"perfect123!\") \"Strong\") () \"perfect123! should be Strong\")\n  (assert (string= (check-password-complexity \"12345678\") \"Weak\") () \"12345678 should be Weak\")\n  (assert (string= (check-password-complexity \"!@#$%^&*\") \"Weak\") () \"!@#$%^&* should be Weak\")\n  (assert (string= (check-password-complexity \"lettersOnly\") \"Weak\") () \"lettersOnly should be Weak\")\n\n  ;; Test suggest-password-improvements\n  (assert (equal (suggest-password-improvements \"short\") \n                '(\"Use at least 8 characters\" \"Include digits\" \"Include special characters\")) \n          () \"short suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"longenough\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"longenough suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with123\") \n                '(\"Use at least 8 characters\" \"Include special characters\")) \n          () \"with123 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"with!@#\") \n                '(\"Use at least 8 characters\" \"Include digits\")) \n          () \"with!@# suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"perfect123!\") nil) \n          () \"perfect123! suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"12345678\") \n                '(\"Include letters\" \"Include special characters\")) \n          () \"12345678 suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"!@#$%^&*\") \n                '(\"Include digits\" \"Include letters\")) \n          () \"!@#$%^&* suggestions incorrect\")\n  (assert (equal (suggest-password-improvements \"lettersOnly\") \n                '(\"Include digits\" \"Include special characters\")) \n          () \"lettersOnly suggestions incorrect\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; min-moves-to-equal-candies calculates the minimum number of moves to make all elements of the list equal.\n;; Each move consists of giving one candy from one child to another.\n;; The function first sorts the list to find the median value, then calculates the sum of absolute differences\n;; between each element and the median.\n(defun min-moves-to-equal-candies (candies)\n  (let* ((sorted-candies (sort (copy-list candies) #'<))\n         (n (length sorted-candies))\n         (median (nth (floor n 2) sorted-candies)))\n    (reduce #'+ (mapcar (lambda (x) (abs (- x median))) sorted-candies))))", "test_cases": "", "test_case_results": "Input: (1 2 3)\nMoves: 2\n\nInput: (1 1 1)\nMoves: 0\n\nInput: (1 2 3 4 5)\nMoves: 6\n\nInput: (5 2 3 1 4)\nMoves: 6", "task_id": 25416, "assertions": "(defpackage :candy-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :candy-test)\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-candies '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 1 1)) 0) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 2 3 4 5)) 6) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-candies '(5 2 3 1 4)) 6) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :candy-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :candy-test)\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-candies '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 1 1)) 0) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 2 3 4 5)) 6) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-candies '(5 2 3 1 4)) 6) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-moves-to-equal-candies"}, "all_code": "(defpackage :candy-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :candy-test)\n\n(defun min-moves-to-equal-candies (candies)\n  (let* ((sorted-candies (sort (copy-list candies) #'<))\n         (n (length sorted-candies))\n         (median (nth (floor n 2) sorted-candies)))\n    (reduce #'+ (mapcar (lambda (x) (abs (- x median))) sorted-candies))))\n\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-candies '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 1 1)) 0) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-candies '(1 2 3 4 5)) 6) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-candies '(5 2 3 1 4)) 6) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; is-valid-chessboard-square checks whether a given integer n is a valid chessboard square.\n; A valid chessboard square is an integer between 1 and 64 inclusive.\n; Returns T (true) if n is valid, NIL (false) otherwise.\n(defun is-valid-chessboard-square (n)\n  (and (integerp n)\n       (>= n 1)\n       (<= n 64)))", "test_cases": "", "test_case_results": "Input: 0\nValid: NIL\nInput: 1\nValid: T\nInput: 32\nValid: T\nInput: 64\nValid: T\nInput: 65\nValid: NIL", "task_id": 12586, "assertions": "(in-package :cl-user)\n\n(defun test-is-valid-chessboard-square ()\n  (assert (not (is-valid-chessboard-square 0)) () \"0 should be invalid\")\n  (assert (is-valid-chessboard-square 1) () \"1 should be valid\")\n  (assert (is-valid-chessboard-square 32) () \"32 should be valid\")\n  (assert (is-valid-chessboard-square 64) () \"64 should be valid\")\n  (assert (not (is-valid-chessboard-square 65)) () \"65 should be invalid\")\n  (format t \"All tests passed!~%\"))\n\n(test-is-valid-chessboard-square)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-is-valid-chessboard-square ()\n  (assert (not (is-valid-chessboard-square 0)) () \"0 should be invalid\")\n  (assert (is-valid-chessboard-square 1) () \"1 should be valid\")\n  (assert (is-valid-chessboard-square 32) () \"32 should be valid\")\n  (assert (is-valid-chessboard-square 64) () \"64 should be valid\")\n  (assert (not (is-valid-chessboard-square 65)) () \"65 should be invalid\")\n  (format t \"All tests passed!~%\"))\n\n(test-is-valid-chessboard-square)", "output": "is-valid-chessboard-square"}, "all_code": "(in-package :cl-user)\n\n(defun is-valid-chessboard-square (n)\n  (and (integerp n)\n       (>= n 1)\n       (<= n 64)))\n\n\n(defun test-is-valid-chessboard-square ()\n  (assert (not (is-valid-chessboard-square 0)) () \"0 should be invalid\")\n  (assert (is-valid-chessboard-square 1) () \"1 should be valid\")\n  (assert (is-valid-chessboard-square 32) () \"32 should be valid\")\n  (assert (is-valid-chessboard-square 64) () \"64 should be valid\")\n  (assert (not (is-valid-chessboard-square 65)) () \"65 should be invalid\")\n  (format t \"All tests passed!~%\"))\n\n(test-is-valid-chessboard-square)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; Binary Heap implementation in Common Lisp\n;;; This module provides functions to create and manipulate a binary heap,\n;;; including insertion, removal of the minimum element, and removal of the k smallest elements.\n\n(defun heap-insert (heap key)\n  (let ((new-heap (cons key heap)))\n    (heapify-up new-heap (1- (length new-heap)))))\n\n(defun heapify-up (heap index)\n  (if (zerop index)\n      heap\n      (let ((parent-index (floor (1- index) 2)))\n        (if (< (nth index heap) (nth parent-index heap))\n            (heapify-up (swap heap index parent-index) parent-index)\n            heap))))\n\n(defun heap-remove-min (heap)\n  (if (null heap)\n      (values nil nil)\n      (let ((min (first heap))\n            (new-heap (append (last heap) (cdr heap))))\n        (values min (heapify-down new-heap 0)))))\n\n(defun heapify-down (heap index)\n  (let* ((left-child (+ (* 2 index) 1))\n         (right-child (+ (* 2 index) 2))\n         (smallest index)\n         (heap-size (length heap)))\n    (when (and (< left-child heap-size)\n               (< (nth left-child heap) (nth smallest heap)))\n      (setf smallest left-child))\n    (when (and (< right-child heap-size)\n               (< (nth right-child heap) (nth smallest heap)))\n      (setf smallest right-child))\n    (if (/= smallest index)\n        (heapify-down (swap heap index smallest) smallest)\n        heap)))\n\n(defun swap (heap i j)\n  (let ((new-heap (copy-list heap)))\n    (rotatef (nth i new-heap) (nth j new-heap))\n    new-heap))\n\n(defun heap-remove-k-min (heap k)\n  (let ((result '())\n        (current-heap heap))\n    (dotimes (i k (values (reverse result) current-heap))\n      (multiple-value-bind (min new-heap) (heap-remove-min current-heap)\n        (push min result)\n        (setf current-heap new-heap)))))", "test_cases": "", "test_case_results": "Inserting elements: 5, 3, 7, 1, 2\nHeap after insertions: (2 1 5 3 7)\nRemoved min: 2\nHeap after removal: (1 3 5 7 7)\nRemoving 2 smallest elements\nRemoved elements: (1 3)\nHeap after removal: (5 7 7 7 7)", "task_id": 21080, "assertions": "(defpackage :binary-heap-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :binary-heap-test)\n\n(defun run-tests ()\n  (let ((heap nil))\n    ;; Test insertion\n    (setf heap (heap-insert heap 5))\n    (setf heap (heap-insert heap 3))\n    (setf heap (heap-insert heap 7))\n    (setf heap (heap-insert heap 1))\n    (setf heap (heap-insert heap 2))\n    (assert (equal heap '(2 1 5 3 7)) () \"Heap after insertions should be (2 1 5 3 7)\")\n\n    ;; Test remove-min\n    (multiple-value-bind (min new-heap) (heap-remove-min heap)\n      (assert (= min 2) () \"Removed min should be 2\")\n      (assert (equal new-heap '(1 3 5 7 7)) () \"Heap after removal should be (1 3 5 7 7)\")\n      (setf heap new-heap))\n\n    ;; Test remove-k-min\n    (multiple-value-bind (k-mins new-heap) (heap-remove-k-min heap 2)\n      (assert (equal k-mins '(1 3)) () \"Removed elements should be (1 3)\")\n      (assert (equal new-heap '(5 7 7 7 7)) () \"Heap after removal should be (5 7 7 7 7)\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :binary-heap-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :binary-heap-test)\n\n(defun run-tests ()\n  (let ((heap nil))\n    ;; Test insertion\n    (setf heap (heap-insert heap 5))\n    (setf heap (heap-insert heap 3))\n    (setf heap (heap-insert heap 7))\n    (setf heap (heap-insert heap 1))\n    (setf heap (heap-insert heap 2))\n    (assert (equal heap '(2 1 5 3 7)) () \"Heap after insertions should be (2 1 5 3 7)\")\n\n    ;; Test remove-min\n    (multiple-value-bind (min new-heap) (heap-remove-min heap)\n      (assert (= min 2) () \"Removed min should be 2\")\n      (assert (equal new-heap '(1 3 5 7 7)) () \"Heap after removal should be (1 3 5 7 7)\")\n      (setf heap new-heap))\n\n    ;; Test remove-k-min\n    (multiple-value-bind (k-mins new-heap) (heap-remove-k-min heap 2)\n      (assert (equal k-mins '(1 3)) () \"Removed elements should be (1 3)\")\n      (assert (equal new-heap '(5 7 7 7 7)) () \"Heap after removal should be (5 7 7 7 7)\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "heap-insert"}, "all_code": "(defpackage :binary-heap-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :binary-heap-test)\n\n(defun heap-insert (heap key)\n  (let ((new-heap (cons key heap)))\n    (heapify-up new-heap (1- (length new-heap)))))\n(defun heapify-up (heap index)\n  (if (zerop index)\n      heap\n      (let ((parent-index (floor (1- index) 2)))\n        (if (< (nth index heap) (nth parent-index heap))\n            (heapify-up (swap heap index parent-index) parent-index)\n            heap))))\n(defun heap-remove-min (heap)\n  (if (null heap)\n      (values nil nil)\n      (let ((min (first heap))\n            (new-heap (append (last heap) (cdr heap))))\n        (values min (heapify-down new-heap 0)))))\n(defun heapify-down (heap index)\n  (let* ((left-child (+ (* 2 index) 1))\n         (right-child (+ (* 2 index) 2))\n         (smallest index)\n         (heap-size (length heap)))\n    (when (and (< left-child heap-size)\n               (< (nth left-child heap) (nth smallest heap)))\n      (setf smallest left-child))\n    (when (and (< right-child heap-size)\n               (< (nth right-child heap) (nth smallest heap)))\n      (setf smallest right-child))\n    (if (/= smallest index)\n        (heapify-down (swap heap index smallest) smallest)\n        heap)))\n(defun swap (heap i j)\n  (let ((new-heap (copy-list heap)))\n    (rotatef (nth i new-heap) (nth j new-heap))\n    new-heap))\n(defun heap-remove-k-min (heap k)\n  (let ((result '())\n        (current-heap heap))\n    (dotimes (i k (values (reverse result) current-heap))\n      (multiple-value-bind (min new-heap) (heap-remove-min current-heap)\n        (push min result)\n        (setf current-heap new-heap)))))\n\n\n(defun run-tests ()\n  (let ((heap nil))\n    ;; Test insertion\n    (setf heap (heap-insert heap 5))\n    (setf heap (heap-insert heap 3))\n    (setf heap (heap-insert heap 7))\n    (setf heap (heap-insert heap 1))\n    (setf heap (heap-insert heap 2))\n    (assert (equal heap '(2 1 5 3 7)) () \"Heap after insertions should be (2 1 5 3 7)\")\n\n    ;; Test remove-min\n    (multiple-value-bind (min new-heap) (heap-remove-min heap)\n      (assert (= min 2) () \"Removed min should be 2\")\n      (assert (equal new-heap '(1 3 5 7 7)) () \"Heap after removal should be (1 3 5 7 7)\")\n      (setf heap new-heap))\n\n    ;; Test remove-k-min\n    (multiple-value-bind (k-mins new-heap) (heap-remove-k-min heap 2)\n      (assert (equal k-mins '(1 3)) () \"Removed elements should be (1 3)\")\n      (assert (equal new-heap '(5 7 7 7 7)) () \"Heap after removal should be (5 7 7 7 7)\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; multiply-scalar-to-columns-for-years multiplies a given scalar value to specific columns in a dataset\n;; for a given list of years. The dataset is represented as a list of lists, where each sublist is a row.\n;; The first row is assumed to be the header (column names), and the first column is assumed to be the year.\n;;\n;; Parameters:\n;; data: The input dataset as a list of lists.\n;; years: A list of years (as integers) to be modified.\n;; columns: A list of column names (as strings) to be modified.\n;; scalar: The scalar value (as a number) to multiply with.\n;;\n;; Returns:\n;; The modified dataset as a list of lists.\n(defun multiply-scalar-to-columns-for-years (data years columns scalar)\n  (let* ((header (first data))\n         (rows (rest data))\n         (valid-columns (intersection columns header :test #'string=))\n         (column-indices (mapcar (lambda (col) (position col header :test #'string=)) valid-columns))\n         (modified-rows \n           (mapcar \n             (lambda (row) \n               (let ((year (first row)))\n                 (if (member year years)\n                     (append \n                       (list year)\n                       (mapcar \n                         (lambda (idx val) \n                           (if (member idx column-indices)\n                               (* val scalar)\n                               val))\n                         (iota (length (rest row)) :start 0)\n                         (rest row)))\n                     row)))\n             rows)))\n    (cons header modified-rows)))\n\n;; Helper function to create a range of numbers (similar to Python's range)\n(defun iota (count &key (start 0) (step 1))\n  (loop for i from start below (+ start (* count step)) by step collect i))", "test_cases": "", "test_case_results": "Input Dataset:\n((Year GDP Population Area) (2000 1000 500 200) (2001 1100 510 200)\n (2002 1200 520 200) (2003 1300 530 200))\n\nYears: (2000 2002)\nColumns: (GDP Population)\nScalar: 2\n\nResulting Dataset:\n((Year GDP Population Area) (2000 1000 1000 400) (2001 1100 510 200)\n (2002 1200 1040 400) (2003 1300 530 200))", "task_id": 15562, "assertions": "(defpackage :dataset-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dataset-utils-test)\n\n(defun run-tests ()\n  (let ((test-dataset '((\"Year\" \"GDP\" \"Population\" \"Area\")\n                        (2000 1000 500 200)\n                        (2001 1100 510 200)\n                        (2002 1200 520 200)\n                        (2003 1300 530 200))))\n    (let ((result (cl-user::multiply-scalar-to-columns-for-years \n                   test-dataset '(2000 2002) '(\"GDP\" \"Population\") 2)))\n      (assert (equal result \n                     '((\"Year\" \"GDP\" \"Population\" \"Area\") \n                       (2000 2000 1000 200) \n                       (2001 1100 510 200) \n                       (2002 2400 1040 200) \n                       (2003 1300 530 200)))\n              () \"Test case 1 failed\"))\n      (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :dataset-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dataset-utils-test)\n\n(defun run-tests ()\n  (let ((test-dataset '((\"Year\" \"GDP\" \"Population\" \"Area\")\n                        (2000 1000 500 200)\n                        (2001 1100 510 200)\n                        (2002 1200 520 200)\n                        (2003 1300 530 200))))\n    (let ((result (cl-user::multiply-scalar-to-columns-for-years \n                   test-dataset '(2000 2002) '(\"GDP\" \"Population\") 2)))\n      (assert (equal result \n                     '((\"Year\" \"GDP\" \"Population\" \"Area\") \n                       (2000 2000 1000 200) \n                       (2001 1100 510 200) \n                       (2002 2400 1040 200) \n                       (2003 1300 530 200)))\n              () \"Test case 1 failed\"))\n      (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "multiply-scalar-to-columns-for-years"}, "all_code": "(defpackage :dataset-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :dataset-utils-test)\n\n(defun multiply-scalar-to-columns-for-years (data years columns scalar)\n  (let* ((header (first data))\n         (rows (rest data))\n         (valid-columns (intersection columns header :test #'string=))\n         (column-indices (mapcar (lambda (col) (position col header :test #'string=)) valid-columns))\n         (modified-rows \n           (mapcar \n             (lambda (row) \n               (let ((year (first row)))\n                 (if (member year years)\n                     (append \n                       (list year)\n                       (mapcar \n                         (lambda (idx val) \n                           (if (member idx column-indices)\n                               (* val scalar)\n                               val))\n                         (iota (length (rest row)) :start 0)\n                         (rest row)))\n                     row)))\n             rows)))\n    (cons header modified-rows)))\n\n;; Helper function to create a range of numbers (similar to Python's range)\n(defun iota (count &key (start 0) (step 1))\n  (loop for i from start below (+ start (* count step)) by step collect i))\n\n\n(defun run-tests ()\n  (let ((test-dataset '((\"Year\" \"GDP\" \"Population\" \"Area\")\n                        (2000 1000 500 200)\n                        (2001 1100 510 200)\n                        (2002 1200 520 200)\n                        (2003 1300 530 200))))\n    (let ((result (cl-user::multiply-scalar-to-columns-for-years \n                   test-dataset '(2000 2002) '(\"GDP\" \"Population\") 2)))\n      (assert (equal result \n                     '((\"Year\" \"GDP\" \"Population\" \"Area\") \n                       (2000 2000 1000 200) \n                       (2001 1100 510 200) \n                       (2002 2400 1040 200) \n                       (2003 1300 530 200)))\n              () \"Test case 1 failed\"))\n      (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; sum-of-factorial-digits calculates the sum of all digits in the factorial of a given number n.\n; It first computes the factorial of n, then converts it to a string to process each digit,\n; converts each digit back to an integer, and sums them up.\n(defun sum-of-factorial-digits (n)\n  (let* ((factorial (factorial n))\n         (digits (map 'list #'digit-char-p (prin1-to-string factorial))))\n    (apply #'+ digits)))\n\n; factorial computes the factorial of a non-negative integer n.\n; It uses a recursive approach with tail recursion optimization.\n(defun factorial (n)\n  (labels ((fact-iter (n acc)\n             (if (<= n 1)\n                 acc\n                 (fact-iter (1- n) (* n acc)))))\n    (fact-iter n 1)))", "test_cases": "", "test_case_results": "Input: 5\nSum of factorial digits: 3\nInput: 10\nSum of factorial digits: 27\nInput: 15\nSum of factorial digits: 45\nInput: 20\nSum of factorial digits: 54", "task_id": 28035, "assertions": "(defpackage :factorial-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :factorial-test)\n\n(defun run-tests ()\n  (assert (= (sum-of-factorial-digits 5) 3) () \"Sum of factorial digits for 5 should be 3\")\n  (assert (= (sum-of-factorial-digits 10) 27) () \"Sum of factorial digits for 10 should be 27\")\n  (assert (= (sum-of-factorial-digits 15) 45) () \"Sum of factorial digits for 15 should be 45\")\n  (assert (= (sum-of-factorial-digits 20) 54) () \"Sum of factorial digits for 20 should be 54\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :factorial-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :factorial-test)\n\n(defun run-tests ()\n  (assert (= (sum-of-factorial-digits 5) 3) () \"Sum of factorial digits for 5 should be 3\")\n  (assert (= (sum-of-factorial-digits 10) 27) () \"Sum of factorial digits for 10 should be 27\")\n  (assert (= (sum-of-factorial-digits 15) 45) () \"Sum of factorial digits for 15 should be 45\")\n  (assert (= (sum-of-factorial-digits 20) 54) () \"Sum of factorial digits for 20 should be 54\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "sum-of-factorial-digits"}, "all_code": "(defpackage :factorial-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :factorial-test)\n\n(defun sum-of-factorial-digits (n)\n  (let* ((factorial (factorial n))\n         (digits (map 'list #'digit-char-p (prin1-to-string factorial))))\n    (apply #'+ digits)))\n\n; factorial computes the factorial of a non-negative integer n.\n; It uses a recursive approach with tail recursion optimization.\n(defun factorial (n)\n  (labels ((fact-iter (n acc)\n             (if (<= n 1)\n                 acc\n                 (fact-iter (1- n) (* n acc)))))\n    (fact-iter n 1)))\n\n\n(defun run-tests ()\n  (assert (= (sum-of-factorial-digits 5) 3) () \"Sum of factorial digits for 5 should be 3\")\n  (assert (= (sum-of-factorial-digits 10) 27) () \"Sum of factorial digits for 10 should be 27\")\n  (assert (= (sum-of-factorial-digits 15) 45) () \"Sum of factorial digits for 15 should be 45\")\n  (assert (= (sum-of-factorial-digits 20) 54) () \"Sum of factorial digits for 20 should be 54\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; circular-array-rotation performs a circular rotation on an array and returns the elements at specified query positions.\n;; Parameters:\n;;   arr - the input list of integers to be rotated\n;;   k   - the number of positions to rotate the array (right rotation)\n;;   queries - a list of indices to query after rotation\n;; Returns:\n;;   A list of elements from the rotated array at the specified query positions\n(defun circular-array-rotation (arr k queries)\n  (let* ((n (length arr))\n         (k (mod k n)) ; Avoid unnecessary full rotations\n         (rotated-array (append (subseq arr (- n k)) (subseq arr 0 (- n k)))))\n    (mapcar (lambda (q) (nth q rotated-array)) queries)))", "test_cases": "", "test_case_results": "Input array: (1 2 3)\nRotation count: 2\nQuery indices: (0 1 2)\nResult: (2 3 1)\n\nInput array: (4 5 6 7)\nRotation count: 3\nQuery indices: (1 3)\nResult: (6 4)\n\nInput array: (10 20 30 40 50)\nRotation count: 8\nQuery indices: (0 2)\nResult: (30 50)", "task_id": 14365, "assertions": "(defpackage :circular-array-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :circular-array-test)\n\n(defun run-tests ()\n  ;; Test case 1: Rotate [1,2,3] right by 2, query all indices\n  (assert (equal (circular-array-rotation '(1 2 3) 2 '(0 1 2)) '(2 3 1))\n          () \"Test case 1 failed\")\n  \n  ;; Test case 2: Rotate [4,5,6,7] right by 3, query indices 1 and 3\n  (assert (equal (circular-array-rotation '(4 5 6 7) 3 '(1 3)) '(6 4))\n          () \"Test case 2 failed\")\n  \n  ;; Test case 3: Rotate [10,20,30,40,50] right by 8 (equivalent to 3), query indices 0 and 2\n  (assert (equal (circular-array-rotation '(10 20 30 40 50) 8 '(0 2)) '(30 50))\n          () \"Test case 3 failed\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :circular-array-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :circular-array-test)\n\n(defun run-tests ()\n  ;; Test case 1: Rotate [1,2,3] right by 2, query all indices\n  (assert (equal (circular-array-rotation '(1 2 3) 2 '(0 1 2)) '(2 3 1))\n          () \"Test case 1 failed\")\n  \n  ;; Test case 2: Rotate [4,5,6,7] right by 3, query indices 1 and 3\n  (assert (equal (circular-array-rotation '(4 5 6 7) 3 '(1 3)) '(6 4))\n          () \"Test case 2 failed\")\n  \n  ;; Test case 3: Rotate [10,20,30,40,50] right by 8 (equivalent to 3), query indices 0 and 2\n  (assert (equal (circular-array-rotation '(10 20 30 40 50) 8 '(0 2)) '(30 50))\n          () \"Test case 3 failed\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "circular-array-rotation"}, "all_code": "(defpackage :circular-array-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :circular-array-test)\n\n(defun circular-array-rotation (arr k queries)\n  (let* ((n (length arr))\n         (k (mod k n)) ; Avoid unnecessary full rotations\n         (rotated-array (append (subseq arr (- n k)) (subseq arr 0 (- n k)))))\n    (mapcar (lambda (q) (nth q rotated-array)) queries)))\n\n\n(defun run-tests ()\n  ;; Test case 1: Rotate [1,2,3] right by 2, query all indices\n  (assert (equal (circular-array-rotation '(1 2 3) 2 '(0 1 2)) '(2 3 1))\n          () \"Test case 1 failed\")\n  \n  ;; Test case 2: Rotate [4,5,6,7] right by 3, query indices 1 and 3\n  (assert (equal (circular-array-rotation '(4 5 6 7) 3 '(1 3)) '(6 4))\n          () \"Test case 2 failed\")\n  \n  ;; Test case 3: Rotate [10,20,30,40,50] right by 8 (equivalent to 3), query indices 0 and 2\n  (assert (equal (circular-array-rotation '(10 20 30 40 50) 8 '(0 2)) '(30 50))\n          () \"Test case 3 failed\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; update-inventory updates the current inventory of books based on a list of transactions.\n; current-inventory is an association list (alist) where each element is a cons cell (title . quantity).\n; transactions is a list of cons cells (title . change), where change can be positive or negative.\n; The function modifies the current-inventory alist in place and removes any entries with quantity <= 0.\n(defun update-inventory (current-inventory transactions)\n  (dolist (transaction transactions)\n    (let* ((title (car transaction))\n           (change (cdr transaction))\n           (existing-entry (assoc title current-inventory)))\n      (if existing-entry\n          (progn\n            (incf (cdr existing-entry) change)\n            (when (<= (cdr existing-entry) 0)\n              (setf current-inventory (remove existing-entry current-inventory))))\n          (when (> change 0)\n            (push (cons title change) current-inventory)))))\n  current-inventory)", "test_cases": "", "test_case_results": "Initial inventory: ((BOOK1 . 10) (BOOK2 . 5))\nTransactions: ((BOOK1 . -2) (BOOK2 . 3) (BOOK3 . 4))\nUpdated inventory: ((BOOK3 . 4) (BOOK1 . 8) (BOOK2 . 8))\n\nInitial inventory: ((BOOK1 . 3) (BOOK2 . 2))\nTransactions: ((BOOK1 . -3) (BOOK2 . -2) (BOOK3 . 1))\nUpdated inventory: ((BOOK3 . 1))\n\nInitial inventory: ((BOOK1 . 1))\nTransactions: ((BOOK1 . -1) (BOOK2 . 5))\nUpdated inventory: ((BOOK2 . 5))", "task_id": 19037, "assertions": "(defpackage :inventory-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :inventory-test)\n\n(defun run-tests ()\n  (let ((test-case1-initial '((:book1 . 10) (:book2 . 5)))\n        (test-case1-transactions '((:book1 . -2) (:book2 . 3) (:book3 . 4)))\n        (test-case2-initial '((:book1 . 3) (:book2 . 2)))\n        (test-case2-transactions '((:book1 . -3) (:book2 . -2) (:book3 . 1)))\n        (test-case3-initial '((:book1 . 1)))\n        (test-case3-transactions '((:book1 . -1) (:book2 . 5))))\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case1-initial) test-case1-transactions)\n                   '((:book3 . 4) (:book1 . 8) (:book2 . 8)))\n            () \"Test case 1 failed\")\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case2-initial) test-case2-transactions)\n                   '((:book3 . 1)))\n            () \"Test case 2 failed\")\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case3-initial) test-case3-transactions)\n                   '((:book2 . 5)))\n            () \"Test case 3 failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :inventory-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :inventory-test)\n\n(defun run-tests ()\n  (let ((test-case1-initial '((:book1 . 10) (:book2 . 5)))\n        (test-case1-transactions '((:book1 . -2) (:book2 . 3) (:book3 . 4)))\n        (test-case2-initial '((:book1 . 3) (:book2 . 2)))\n        (test-case2-transactions '((:book1 . -3) (:book2 . -2) (:book3 . 1)))\n        (test-case3-initial '((:book1 . 1)))\n        (test-case3-transactions '((:book1 . -1) (:book2 . 5))))\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case1-initial) test-case1-transactions)\n                   '((:book3 . 4) (:book1 . 8) (:book2 . 8)))\n            () \"Test case 1 failed\")\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case2-initial) test-case2-transactions)\n                   '((:book3 . 1)))\n            () \"Test case 2 failed\")\n    \n    (assert (equal (cl-user:update-inventory (copy-alist test-case3-initial) test-case3-transactions)\n                   '((:book2 . 5)))\n            () \"Test case 3 failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "update-inventory"}, "all_code": "(defpackage :inventory-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :inventory-test)\n\n(defun update-inventory (current-inventory transactions)\n  (dolist (transaction transactions)\n    (let* ((title (car transaction))\n           (change (cdr transaction))\n           (existing-entry (assoc title current-inventory)))\n      (if existing-entry\n          (progn\n            (incf (cdr existing-entry) change)\n            (when (<= (cdr existing-entry) 0)\n              (setf current-inventory (remove existing-entry current-inventory))))\n          (when (> change 0)\n            (push (cons title change) current-inventory)))))\n  current-inventory)\n\n\n(defun run-tests ()\n  (let ((test-case1-initial '((:book1 . 10) (:book2 . 5)))\n        (test-case1-transactions '((:book1 . -2) (:book2 . 3) (:book3 . 4)))\n        (test-case2-initial '((:book1 . 3) (:book2 . 2)))\n        (test-case2-transactions '((:book1 . -3) (:book2 . -2) (:book3 . 1)))\n        (test-case3-initial '((:book1 . 1)))\n        (test-case3-transactions '((:book1 . -1) (:book2 . 5))))\n    \n    (assert (equal (update-inventory (copy-alist test-case1-initial) test-case1-transactions)\n                   '((:book3 . 4) (:book1 . 8) (:book2 . 8)))\n            () \"Test case 1 failed\")\n    \n    (assert (equal (update-inventory (copy-alist test-case2-initial) test-case2-transactions)\n                   '((:book3 . 1)))\n            () \"Test case 2 failed\")\n    \n    (assert (equal (update-inventory (copy-alist test-case3-initial) test-case3-transactions)\n                   '((:book2 . 5)))\n            () \"Test case 3 failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :tree-query-processor\n  (:use :cl)\n  (:export :process-queries))\n\n(in-package :tree-query-processor)\n\n(defun process-queries (n q values edges queries)\n  (let ((graph (make-hash-table))  ; adjacency list for the tree\n        (subtree-values (make-hash-table)))  ; stores sorted subtree values\n\n    ; Build the adjacency list from edges\n    (dolist (edge edges)\n      (let ((u (first edge))\n            (v (second edge)))\n        (push v (gethash u graph '()))\n        (push u (gethash v graph '()))))\n\n    ; DFS to collect and sort subtree values\n    (labels ((dfs (node parent)\n               (let ((subtree-nodes (list (nth (1- node) values))))  ; 1-indexed to 0-indexed\n                 (dolist (neighbor (gethash node graph '()))\n                   (unless (eql neighbor parent)\n                     (setf subtree-nodes (nconc subtree-nodes (dfs neighbor node)))))\n                 (setf (gethash node subtree-values)\n                       (sort subtree-nodes #'>))  ; sort in descending order\n                 subtree-nodes)))\n      (dfs 1 nil))  ; start DFS from root node 1\n\n    ; Process each query\n    (mapcar (lambda (query)\n              (let* ((v (first query))\n                     (k (second query))\n                     (subtree-val-list (gethash v subtree-values)))\n                (count-if (lambda (val) (>= val k)) subtree-val-list)))\n            queries)))", "test_cases": "", "test_case_results": "Values: (10 5 15 3 7)\nEdges: ((1 2) (1 3) (2 4) (2 5))\nQueries: ((1 6) (2 4) (3 10))\nResults: (3 2 1)", "task_id": 29457, "assertions": "(defpackage :tree-query-processor-test\n  (:use :cl :tree-query-processor)\n  (:export :run-tests))\n\n(in-package :tree-query-processor-test)\n\n(defun run-tests ()\n  (let ((n 5)\n        (q 3)\n        (values '(10 5 15 3 7))\n        (edges '((1 2) (1 3) (2 4) (2 5)))\n        (queries '((1 6) (2 4) (3 10))))\n    (assert (equal (process-queries n q values edges queries) '(3 2 1)) \n            () \"Test case failed: Expected (3 2 1) as results\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :tree-query-processor-test\n  (:use :cl :tree-query-processor)\n  (:export :run-tests))\n\n(in-package :tree-query-processor-test)\n\n(defun run-tests ()\n  (let ((n 5)\n        (q 3)\n        (values '(10 5 15 3 7))\n        (edges '((1 2) (1 3) (2 4) (2 5)))\n        (queries '((1 6) (2 4) (3 10))))\n    (assert (equal (process-queries n q values edges queries) '(3 2 1)) \n            () \"Test case failed: Expected (3 2 1) as results\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "process-queries"}, "all_code": "(defpackage :tree-query-processor-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :tree-query-processor-test)\n\n(defun process-queries (n q values edges queries)\n  (let ((graph (make-hash-table))  ; adjacency list for the tree\n        (subtree-values (make-hash-table)))  ; stores sorted subtree values\n\n    ; Build the adjacency list from edges\n    (dolist (edge edges)\n      (let ((u (first edge))\n            (v (second edge)))\n        (push v (gethash u graph '()))\n        (push u (gethash v graph '()))))\n\n    ; DFS to collect and sort subtree values\n    (labels ((dfs (node parent)\n               (let ((subtree-nodes (list (nth (1- node) values))))  ; 1-indexed to 0-indexed\n                 (dolist (neighbor (gethash node graph '()))\n                   (unless (eql neighbor parent)\n                     (setf subtree-nodes (nconc subtree-nodes (dfs neighbor node)))))\n                 (setf (gethash node subtree-values)\n                       (sort subtree-nodes #'>))  ; sort in descending order\n                 subtree-nodes)))\n      (dfs 1 nil))  ; start DFS from root node 1\n\n    ; Process each query\n    (mapcar (lambda (query)\n              (let* ((v (first query))\n                     (k (second query))\n                     (subtree-val-list (gethash v subtree-values)))\n                (count-if (lambda (val) (>= val k)) subtree-val-list)))\n            queries)))\n\n\n(defun run-tests ()\n  (let ((n 5)\n        (q 3)\n        (values '(10 5 15 3 7))\n        (edges '((1 2) (1 3) (2 4) (2 5)))\n        (queries '((1 6) (2 4) (3 10))))\n    (assert (equal (process-queries n q values edges queries) '(3 2 1)) \n            () \"Test case failed: Expected (3 2 1) as results\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :string-utils\n  (:use :cl)\n  (:export :min-operations-to-make-distinct))\n\n(in-package :string-utils)\n\n(defun min-operations-to-make-distinct (S)\n  (let ((char-count (make-hash-table)))\n    ; Count frequency of each character\n    (loop for char across S\n          do (incf (gethash char char-count 0)))\n    ; Calculate total operations needed\n    (loop for count being the hash-values of char-count\n          sum (if (> count 1) (1- count) 0))))", "test_cases": "", "test_case_results": "Input: \"aab\"\nResult: 1\nInput: \"abc\"\nResult: 0\nInput: \"aaabbb\"\nResult: 4\nInput: \"\"\nResult: 0\nInput: \"a\"\nResult: 0", "task_id": 23658, "assertions": "(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-operations-to-make-distinct \"aab\") 1) () \"Test case 'aab' failed\")\n  (assert (= (min-operations-to-make-distinct \"abc\") 0) () \"Test case 'abc' failed\")\n  (assert (= (min-operations-to-make-distinct \"aaabbb\") 4) () \"Test case 'aaabbb' failed\")\n  (assert (= (min-operations-to-make-distinct \"\") 0) () \"Test case empty string failed\")\n  (assert (= (min-operations-to-make-distinct \"a\") 0) () \"Test case 'a' failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-operations-to-make-distinct \"aab\") 1) () \"Test case 'aab' failed\")\n  (assert (= (min-operations-to-make-distinct \"abc\") 0) () \"Test case 'abc' failed\")\n  (assert (= (min-operations-to-make-distinct \"aaabbb\") 4) () \"Test case 'aaabbb' failed\")\n  (assert (= (min-operations-to-make-distinct \"\") 0) () \"Test case empty string failed\")\n  (assert (= (min-operations-to-make-distinct \"a\") 0) () \"Test case 'a' failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-operations-to-make-distinct"}, "all_code": "(defpackage :string-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun min-operations-to-make-distinct (S)\n  (let ((char-count (make-hash-table)))\n    ; Count frequency of each character\n    (loop for char across S\n          do (incf (gethash char char-count 0)))\n    ; Calculate total operations needed\n    (loop for count being the hash-values of char-count\n          sum (if (> count 1) (1- count) 0))))\n\n\n(defun run-tests ()\n  (assert (= (min-operations-to-make-distinct \"aab\") 1) () \"Test case 'aab' failed\")\n  (assert (= (min-operations-to-make-distinct \"abc\") 0) () \"Test case 'abc' failed\")\n  (assert (= (min-operations-to-make-distinct \"aaabbb\") 4) () \"Test case 'aaabbb' failed\")\n  (assert (= (min-operations-to-make-distinct \"\") 0) () \"Test case empty string failed\")\n  (assert (= (min-operations-to-make-distinct \"a\") 0) () \"Test case 'a' failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; split-string splits the input string s into a list of substrings based on given delimiters.\n; If the delimiters string is empty, it returns the entire string as one element in the list.\n; The function processes each character in the input string, checking if it is a delimiter.\n; Non-delimiter characters are accumulated into the current word until a delimiter is encountered,\n; at which point the current word is added to the result list.\n(defun split-string (s delimiters)\n  (if (string= delimiters \"\")\n      (list s)\n      (let ((result '())\n            (current-word (make-array 0 :element-type 'character :adjustable t :fill-pointer 0))\n            (delimiters-set (coerce delimiters 'list)))\n        (loop for char across s\n              do (if (member char delimiters-set :test #'char=)\n                     (when (> (length current-word) 0)\n                       (push (copy-seq current-word) result)\n                       (setf (fill-pointer current-word) 0))\n                     (vector-push-extend char current-word)))\n        (when (> (length current-word) 0)\n          (push (copy-seq current-word) result))\n        (nreverse result))))", "test_cases": "", "test_case_results": "Input: \"hello,world;this|is-a.test\", Delimiters: \",;|-.\"\nResult: (\"hello\" \"world\" \"this\" \"is\" \"a\" \"test\")\nInput: \"no-delimiters-here\", Delimiters: \"\"\nResult: (\"no-delimiters-here\")\nInput: \"multiple   spaces\", Delimiters: \" \"\nResult: (\"multiple\" \"spaces\")\nInput: \"empty\", Delimiters: \"xyz\"\nResult: (\"empt\")", "task_id": 3367, "assertions": "(defpackage :split-string-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :split-string-test)\n\n(defun run-tests ()\n  (assert (equal (split-string \"hello,world;this|is-a.test\" \",;|-.\")\n                 '(\"hello\" \"world\" \"this\" \"is\" \"a\" \"test\"))\n          () \"Test case 1 failed\")\n  (assert (equal (split-string \"no-delimiters-here\" \"\")\n                 '(\"no-delimiters-here\"))\n          () \"Test case 2 failed\")\n  (assert (equal (split-string \"multiple   spaces\" \" \")\n                 '(\"multiple\" \"spaces\"))\n          () \"Test case 3 failed\")\n  (assert (equal (split-string \"empty\" \"xyz\")\n                 '(\"empt\"))\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :split-string-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :split-string-test)\n\n(defun run-tests ()\n  (assert (equal (split-string \"hello,world;this|is-a.test\" \",;|-.\")\n                 '(\"hello\" \"world\" \"this\" \"is\" \"a\" \"test\"))\n          () \"Test case 1 failed\")\n  (assert (equal (split-string \"no-delimiters-here\" \"\")\n                 '(\"no-delimiters-here\"))\n          () \"Test case 2 failed\")\n  (assert (equal (split-string \"multiple   spaces\" \" \")\n                 '(\"multiple\" \"spaces\"))\n          () \"Test case 3 failed\")\n  (assert (equal (split-string \"empty\" \"xyz\")\n                 '(\"empt\"))\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "split-string"}, "all_code": "(defpackage :split-string-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :split-string-test)\n\n(defun split-string (s delimiters)\n  (if (string= delimiters \"\")\n      (list s)\n      (let ((result '())\n            (current-word (make-array 0 :element-type 'character :adjustable t :fill-pointer 0))\n            (delimiters-set (coerce delimiters 'list)))\n        (loop for char across s\n              do (if (member char delimiters-set :test #'char=)\n                     (when (> (length current-word) 0)\n                       (push (copy-seq current-word) result)\n                       (setf (fill-pointer current-word) 0))\n                     (vector-push-extend char current-word)))\n        (when (> (length current-word) 0)\n          (push (copy-seq current-word) result))\n        (nreverse result))))\n\n\n(defun run-tests ()\n  (assert (equal (split-string \"hello,world;this|is-a.test\" \",;|-.\")\n                 '(\"hello\" \"world\" \"this\" \"is\" \"a\" \"test\"))\n          () \"Test case 1 failed\")\n  (assert (equal (split-string \"no-delimiters-here\" \"\")\n                 '(\"no-delimiters-here\"))\n          () \"Test case 2 failed\")\n  (assert (equal (split-string \"multiple   spaces\" \" \")\n                 '(\"multiple\" \"spaces\"))\n          () \"Test case 3 failed\")\n  (assert (equal (split-string \"empty\" \"xyz\")\n                 '(\"empt\"))\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :cyclic-utils\n  (:use :cl)\n  (:export :is-cyclic-permutation :check-cyclic-permutations))\n\n(in-package :cyclic-utils)\n\n(defun is-cyclic-permutation (s)\n  (if (<= (length s) 1)\n      t\n      (string= (concatenate 'string (subseq s 1) (subseq s 0 1)) s)))\n\n(defun check-cyclic-permutations (strings)\n  (mapcar (lambda (s) (if (is-cyclic-permutation s) \"YES\" \"NO\")) strings))", "test_cases": "", "test_case_results": "Input: (a ab abc aaa baab)\nResult: (YES NO NO YES NO)\n\nInput: (x xy xyz xx xyyx)\nResult: (YES NO NO YES NO)\n\nInput: NIL\nResult: NIL\n\nInput: (z)\nResult: (YES)", "task_id": 3381, "assertions": "(defpackage :cyclic-utils-test\n  (:use :cl :cyclic-utils)\n  (:export :run-tests))\n\n(in-package :cyclic-utils-test)\n\n(defun run-tests ()\n  (assert (equal (check-cyclic-permutations '(\"a\" \"ab\" \"abc\" \"aaa\" \"baab\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"First test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"x\" \"xy\" \"xyz\" \"xx\" \"xyyx\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"Second test case failed\")\n  (assert (equal (check-cyclic-permutations nil) nil) () \"Empty list test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"z\")) '(\"YES\")) () \"Single character test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :cyclic-utils-test\n  (:use :cl :cyclic-utils)\n  (:export :run-tests))\n\n(in-package :cyclic-utils-test)\n\n(defun run-tests ()\n  (assert (equal (check-cyclic-permutations '(\"a\" \"ab\" \"abc\" \"aaa\" \"baab\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"First test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"x\" \"xy\" \"xyz\" \"xx\" \"xyyx\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"Second test case failed\")\n  (assert (equal (check-cyclic-permutations nil) nil) () \"Empty list test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"z\")) '(\"YES\")) () \"Single character test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "check-cyclic-permutations"}, "all_code": "(defpackage :cyclic-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :cyclic-utils-test)\n\n(defun is-cyclic-permutation (s)\n  (if (<= (length s) 1)\n      t\n      (string= (concatenate 'string (subseq s 1) (subseq s 0 1)) s)))\n(defun check-cyclic-permutations (strings)\n  (mapcar (lambda (s) (if (is-cyclic-permutation s) \"YES\" \"NO\")) strings))\n\n\n(defun run-tests ()\n  (assert (equal (check-cyclic-permutations '(\"a\" \"ab\" \"abc\" \"aaa\" \"baab\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"First test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"x\" \"xy\" \"xyz\" \"xx\" \"xyyx\"))\n                 '(\"YES\" \"NO\" \"NO\" \"YES\" \"NO\")) () \"Second test case failed\")\n  (assert (equal (check-cyclic-permutations nil) nil) () \"Empty list test case failed\")\n  (assert (equal (check-cyclic-permutations '(\"z\")) '(\"YES\")) () \"Single character test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :next-bigger-number\n  (:use :cl)\n  (:export :next-bigger))\n\n(in-package :next-bigger-number)\n\n(defun next-bigger (num)\n  (let* ((digits (map 'list #'digit-char-p (prin1-to-string num)))\n         (length (length digits))\n         (i (- length 2)))\n    ; Step 1: Find the first digit from the right that is smaller than the next digit\n    (loop while (and (>= i 0) (>= (nth i digits) (nth (1+ i) digits)))\n          do (decf i))\n    ; If no such digit is found, return -1\n    (when (= i -1)\n      (return-from next-bigger -1))\n    ; Step 2: Find the smallest digit on the right side of digits[i] that is larger than digits[i]\n    (let ((j (- length 1)))\n      (loop while (<= (nth j digits) (nth i digits))\n            do (decf j))\n      ; Step 3: Swap digits[i] and digits[j]\n      (rotatef (nth i digits) (nth j digits))\n      ; Step 4: Sort the digits after index i in ascending order\n      (setf (cdr (nthcdr i digits)) (sort (cdr (nthcdr i digits)) #'<))\n      ; Convert the list of digits back to a number\n      (parse-integer (map 'string #'(lambda (d) (code-char (+ d 48))) digits)))))", "test_cases": "", "test_case_results": "Input: 12\nResult: 21\n\nInput: 513\nResult: 531\n\nInput: 2017\nResult: 2071\n\nInput: 9\nResult: -1\n\nInput: 111\nResult: -1\n\nInput: 531\nResult: -1\n\nInput: 1234567908\nResult: 1234567980", "task_id": 26103, "assertions": "(defpackage :next-bigger-number-test\n  (:use :cl :next-bigger-number)\n  (:export :run-tests))\n\n(in-package :next-bigger-number-test)\n\n(defun run-tests ()\n  (assert (= (next-bigger 12) 21) () \"Next bigger after 12 should be 21\")\n  (assert (= (next-bigger 513) 531) () \"Next bigger after 513 should be 531\")\n  (assert (= (next-bigger 2017) 2071) () \"Next bigger after 2017 should be 2071\")\n  (assert (= (next-bigger 9) -1) () \"Next bigger after 9 should be -1\")\n  (assert (= (next-bigger 111) -1) () \"Next bigger after 111 should be -1\")\n  (assert (= (next-bigger 531) -1) () \"Next bigger after 531 should be -1\")\n  (assert (= (next-bigger 1234567908) 1234567980) () \"Next bigger after 1234567908 should be 1234567980\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :next-bigger-number-test\n  (:use :cl :next-bigger-number)\n  (:export :run-tests))\n\n(in-package :next-bigger-number-test)\n\n(defun run-tests ()\n  (assert (= (next-bigger 12) 21) () \"Next bigger after 12 should be 21\")\n  (assert (= (next-bigger 513) 531) () \"Next bigger after 513 should be 531\")\n  (assert (= (next-bigger 2017) 2071) () \"Next bigger after 2017 should be 2071\")\n  (assert (= (next-bigger 9) -1) () \"Next bigger after 9 should be -1\")\n  (assert (= (next-bigger 111) -1) () \"Next bigger after 111 should be -1\")\n  (assert (= (next-bigger 531) -1) () \"Next bigger after 531 should be -1\")\n  (assert (= (next-bigger 1234567908) 1234567980) () \"Next bigger after 1234567908 should be 1234567980\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "next-bigger"}, "all_code": "(defpackage :next-bigger-number-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :next-bigger-number-test)\n\n(defun next-bigger (num)\n  (let* ((digits (map 'list #'digit-char-p (prin1-to-string num)))\n         (length (length digits))\n         (i (- length 2)))\n    ; Step 1: Find the first digit from the right that is smaller than the next digit\n    (loop while (and (>= i 0) (>= (nth i digits) (nth (1+ i) digits)))\n          do (decf i))\n    ; If no such digit is found, return -1\n    (when (= i -1)\n      (return-from next-bigger -1))\n    ; Step 2: Find the smallest digit on the right side of digits[i] that is larger than digits[i]\n    (let ((j (- length 1)))\n      (loop while (<= (nth j digits) (nth i digits))\n            do (decf j))\n      ; Step 3: Swap digits[i] and digits[j]\n      (rotatef (nth i digits) (nth j digits))\n      ; Step 4: Sort the digits after index i in ascending order\n      (setf (cdr (nthcdr i digits)) (sort (cdr (nthcdr i digits)) #'<))\n      ; Convert the list of digits back to a number\n      (parse-integer (map 'string #'(lambda (d) (code-char (+ d 48))) digits)))))\n\n\n(defun run-tests ()\n  (assert (= (next-bigger 12) 21) () \"Next bigger after 12 should be 21\")\n  (assert (= (next-bigger 513) 531) () \"Next bigger after 513 should be 531\")\n  (assert (= (next-bigger 2017) 2071) () \"Next bigger after 2017 should be 2071\")\n  (assert (= (next-bigger 9) -1) () \"Next bigger after 9 should be -1\")\n  (assert (= (next-bigger 111) -1) () \"Next bigger after 111 should be -1\")\n  (assert (= (next-bigger 531) -1) () \"Next bigger after 531 should be -1\")\n  (assert (= (next-bigger 1234567908) 1234567980) () \"Next bigger after 1234567908 should be 1234567980\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; is-palindrome checks if a given number is a palindrome.\n; A number is a palindrome if it reads the same forwards and backwards.\n; The function converts the number to a string and compares it with its reverse.\n(defun is-palindrome (number)\n  (let ((num-str (write-to-string number)))\n    (string= num-str (reverse num-str))))\n\n; product-palindrome-check checks if the product of integers in each test case is a palindrome.\n; Each test case is a list where the first element is ignored (assuming it's a case identifier),\n; and the rest are the numbers to be multiplied.\n; The function returns a list of \"Yes\" or \"No\" strings indicating whether the product is a palindrome.\n(defun product-palindrome-check (test-cases)\n  (mapcar (lambda (case)\n            (let ((product (apply #'* (rest case))))\n              (if (is-palindrome product) \"Yes\" \"No\")))\n          test-cases))", "test_cases": "", "test_case_results": "Test Cases: ((1 2 3) (2 11 11) (3 5 7 9) (4 1 1 1 1) (5 10 20))\nResults: (Yes Yes No Yes No)", "task_id": 16160, "assertions": "(defpackage :palindrome-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :palindrome-test)\n\n(defun run-tests ()\n  (let ((test-cases '((1 2 3)        ; Product: 6 -> No\n                      (2 11 11)      ; Product: 121 -> Yes\n                      (3 5 7 9)      ; Product: 315 -> No\n                      (4 1 1 1 1)    ; Product: 1 -> Yes\n                      (5 10 20))))   ; Product: 200 -> No\n    (assert (equal (cl-user:product-palindrome-check test-cases) \n                   '(\"No\" \"Yes\" \"No\" \"Yes\" \"No\")) \n            () \"Test case 1 failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :palindrome-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :palindrome-test)\n\n(defun run-tests ()\n  (let ((test-cases '((1 2 3)        ; Product: 6 -> No\n                      (2 11 11)      ; Product: 121 -> Yes\n                      (3 5 7 9)      ; Product: 315 -> No\n                      (4 1 1 1 1)    ; Product: 1 -> Yes\n                      (5 10 20))))   ; Product: 200 -> No\n    (assert (equal (cl-user:product-palindrome-check test-cases) \n                   '(\"No\" \"Yes\" \"No\" \"Yes\" \"No\")) \n            () \"Test case 1 failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "product-palindrome-check"}, "all_code": "(defpackage :palindrome-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :palindrome-test)\n\n(defun is-palindrome (number)\n  (let ((num-str (write-to-string number)))\n    (string= num-str (reverse num-str))))\n\n; product-palindrome-check checks if the product of integers in each test case is a palindrome.\n; Each test case is a list where the first element is ignored (assuming it's a case identifier),\n; and the rest are the numbers to be multiplied.\n; The function returns a list of \"Yes\" or \"No\" strings indicating whether the product is a palindrome.\n(defun product-palindrome-check (test-cases)\n  (mapcar (lambda (case)\n            (let ((product (apply #'* (rest case))))\n              (if (is-palindrome product) \"Yes\" \"No\")))\n          test-cases))\n\n\n(defun run-tests ()\n  (let ((test-cases '((1 2 3)        ; Product: 6 -> No\n                      (2 11 11)      ; Product: 121 -> Yes\n                      (3 5 7 9)      ; Product: 315 -> No\n                      (4 1 1 1 1)    ; Product: 1 -> Yes\n                      (5 10 20))))   ; Product: 200 -> No\n    (assert (equal (product-palindrome-check test-cases) \n                   '(\"No\" \"Yes\" \"No\" \"Yes\" \"No\")) \n            () \"Test case 1 failed\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n;; minimum-trees calculates the minimum number of trees required to ensure that there are at least k paths\n;; between any two trees in an m x n grid. If it is impossible, it returns -1.\n;; \n;; Parameters:\n;;   m - number of rows in the grid\n;;   n - number of columns in the grid\n;;   k - minimum number of paths required between any two trees\n;;\n;; Returns:\n;;   The minimum number of trees required or -1 if it is impossible.\n(defun minimum-trees (m n k)\n  (if (or (< m 2) (< n 2) (> k (min m n)))\n      -1\n      k))", "test_cases": "", "test_case_results": "Input: m=2, n=2, k=1\nResult: 1\nInput: m=3, n=3, k=3\nResult: 3\nInput: m=1, n=5, k=2\nResult: -1\nInput: m=4, n=2, k=5\nResult: -1\nInput: m=5, n=5, k=2\nResult: 2", "task_id": 26270, "assertions": "(in-package :cl-user)\n\n(defun test-minimum-trees ()\n  (assert (= (minimum-trees 2 2 1) 1) () \"Test case (2 2 1) failed\")\n  (assert (= (minimum-trees 3 3 3) 3) () \"Test case (3 3 3) failed\")\n  (assert (= (minimum-trees 1 5 2) -1) () \"Test case (1 5 2) failed\")\n  (assert (= (minimum-trees 4 2 5) -1) () \"Test case (4 2 5) failed\")\n  (assert (= (minimum-trees 5 5 2) 2) () \"Test case (5 5 2) failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-minimum-trees)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-minimum-trees ()\n  (assert (= (minimum-trees 2 2 1) 1) () \"Test case (2 2 1) failed\")\n  (assert (= (minimum-trees 3 3 3) 3) () \"Test case (3 3 3) failed\")\n  (assert (= (minimum-trees 1 5 2) -1) () \"Test case (1 5 2) failed\")\n  (assert (= (minimum-trees 4 2 5) -1) () \"Test case (4 2 5) failed\")\n  (assert (= (minimum-trees 5 5 2) 2) () \"Test case (5 5 2) failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-minimum-trees)", "output": "minimum-trees"}, "all_code": "(in-package :cl-user)\n\n(defun minimum-trees (m n k)\n  (if (or (< m 2) (< n 2) (> k (min m n)))\n      -1\n      k))\n\n\n(defun test-minimum-trees ()\n  (assert (= (minimum-trees 2 2 1) 1) () \"Test case (2 2 1) failed\")\n  (assert (= (minimum-trees 3 3 3) 3) () \"Test case (3 3 3) failed\")\n  (assert (= (minimum-trees 1 5 2) -1) () \"Test case (1 5 2) failed\")\n  (assert (= (minimum-trees 4 2 5) -1) () \"Test case (4 2 5) failed\")\n  (assert (= (minimum-trees 5 5 2) 2) () \"Test case (5 5 2) failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-minimum-trees)", "exec_outcome": "PASSED"}
{"code": "(defpackage :string-utils\n  (:use :cl)\n  (:export :common-characters))\n\n(in-package :string-utils)\n\n(defun common-characters (str1 str2)\n  (let ((set1 (coerce str1 'list))\n        (set2 (coerce str2 'list)))\n    (length (intersection set1 set2 :test #'char=))))", "test_cases": "", "test_case_results": "Strings: hello and world\nCommon characters: 3\nStrings: abc and def\nCommon characters: 0\nStrings: common and characters\nCommon characters: 1\nStrings: lisp and clisp\nCommon characters: 4", "task_id": 3942, "assertions": "(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (assert (= (common-characters \"hello\" \"world\") 3) () \"hello and world should have 3 common characters\")\n  (assert (= (common-characters \"abc\" \"def\") 0) () \"abc and def should have 0 common characters\")\n  (assert (= (common-characters \"common\" \"characters\") 1) () \"common and characters should have 1 common character\")\n  (assert (= (common-characters \"lisp\" \"clisp\") 4) () \"lisp and clisp should have 4 common characters\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-utils-test\n  (:use :cl :string-utils)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (assert (= (common-characters \"hello\" \"world\") 3) () \"hello and world should have 3 common characters\")\n  (assert (= (common-characters \"abc\" \"def\") 0) () \"abc and def should have 0 common characters\")\n  (assert (= (common-characters \"common\" \"characters\") 1) () \"common and characters should have 1 common character\")\n  (assert (= (common-characters \"lisp\" \"clisp\") 4) () \"lisp and clisp should have 4 common characters\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "common-characters"}, "all_code": "(defpackage :string-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun common-characters (str1 str2)\n  (let ((set1 (coerce str1 'list))\n        (set2 (coerce str2 'list)))\n    (length (intersection set1 set2 :test #'char=))))\n\n\n(defun run-tests ()\n  (assert (= (common-characters \"hello\" \"world\") 3) () \"hello and world should have 3 common characters\")\n  (assert (= (common-characters \"abc\" \"def\") 0) () \"abc and def should have 0 common characters\")\n  (assert (= (common-characters \"common\" \"characters\") 1) () \"common and characters should have 1 common character\")\n  (assert (= (common-characters \"lisp\" \"clisp\") 4) () \"lisp and clisp should have 4 common characters\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; almost-sorted-sort sorts a list of numbers where the ith number is at most i positions away\n;; from its correct position. It performs a modified bubble sort that only checks nearby elements.\n(defun almost-sorted-sort (arr)\n  (let ((n (length arr)))\n    (dotimes (i n arr)  ; Return the array after processing\n      (let ((j (max 0 (- i i))))  ; Position where element arr[i] should start checking from\n        (do () ((>= j (min n (+ i i 1))))  ; While j < min(n, i + i + 1)\n          (when (> (nth j arr) (nth i arr))\n            (rotatef (nth i arr) (nth j arr)))  ; Swap elements\n          (incf j))))))", "test_cases": "", "test_case_results": "Input: (3 2 1 4 6 5)\nOutput: (1 2 3 4 5 6)\n\nInput: (1 2 3 4 5 6)\nOutput: (1 2 3 4 5 6)\n\nInput: (6 5 4 3 2 1)\nOutput: (1 2 3 4 5 6)\n\nInput: (1)\nOutput: (1)\n\nInput: (2 1)\nOutput: (1 2)\n\nInput: (1 3 2 4 6 5)\nOutput: (1 2 3 4 5 6)", "task_id": 23363, "assertions": "(defpackage :almost-sorted-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :almost-sorted-test)\n\n(defun run-tests ()\n  (assert (equal (almost-sorted-sort '(3 2 1 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 1 failed\")\n  (assert (equal (almost-sorted-sort '(1 2 3 4 5 6)) '(1 2 3 4 5 6)) () \"Test case 2 failed\")\n  (assert (equal (almost-sorted-sort '(6 5 4 3 2 1)) '(1 2 3 4 5 6)) () \"Test case 3 failed\")\n  (assert (equal (almost-sorted-sort '(1)) '(1)) () \"Test case 4 failed\")\n  (assert (equal (almost-sorted-sort '(2 1)) '(1 2)) () \"Test case 5 failed\")\n  (assert (equal (almost-sorted-sort '(1 3 2 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :almost-sorted-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :almost-sorted-test)\n\n(defun run-tests ()\n  (assert (equal (almost-sorted-sort '(3 2 1 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 1 failed\")\n  (assert (equal (almost-sorted-sort '(1 2 3 4 5 6)) '(1 2 3 4 5 6)) () \"Test case 2 failed\")\n  (assert (equal (almost-sorted-sort '(6 5 4 3 2 1)) '(1 2 3 4 5 6)) () \"Test case 3 failed\")\n  (assert (equal (almost-sorted-sort '(1)) '(1)) () \"Test case 4 failed\")\n  (assert (equal (almost-sorted-sort '(2 1)) '(1 2)) () \"Test case 5 failed\")\n  (assert (equal (almost-sorted-sort '(1 3 2 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "almost-sorted-sort"}, "all_code": "(defpackage :almost-sorted-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :almost-sorted-test)\n\n(defun almost-sorted-sort (arr)\n  (let ((n (length arr)))\n    (dotimes (i n arr)  ; Return the array after processing\n      (let ((j (max 0 (- i i))))  ; Position where element arr[i] should start checking from\n        (do () ((>= j (min n (+ i i 1))))  ; While j < min(n, i + i + 1)\n          (when (> (nth j arr) (nth i arr))\n            (rotatef (nth i arr) (nth j arr)))  ; Swap elements\n          (incf j))))))\n\n\n(defun run-tests ()\n  (assert (equal (almost-sorted-sort '(3 2 1 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 1 failed\")\n  (assert (equal (almost-sorted-sort '(1 2 3 4 5 6)) '(1 2 3 4 5 6)) () \"Test case 2 failed\")\n  (assert (equal (almost-sorted-sort '(6 5 4 3 2 1)) '(1 2 3 4 5 6)) () \"Test case 3 failed\")\n  (assert (equal (almost-sorted-sort '(1)) '(1)) () \"Test case 4 failed\")\n  (assert (equal (almost-sorted-sort '(2 1)) '(1 2)) () \"Test case 5 failed\")\n  (assert (equal (almost-sorted-sort '(1 3 2 4 6 5)) '(1 2 3 4 5 6)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; binary-search-extended performs an extended binary search to find the number of occurrences of a query in a sorted array.\n; It uses two helper functions, find-left-index and find-right-index, to determine the leftmost and rightmost positions of the query.\n; If the query is not found, it returns 0.\n(defun binary-search-extended (array query)\n  (labels ((find-left-index ()\n             (let ((lo 0)\n                   (hi (length array)))\n               (loop while (< lo hi) do\n                 (let ((mid (floor (+ lo hi) 2)))\n                   (if (< (aref array mid) query)\n                       (setf lo (1+ mid))\n                       (setf hi mid))))\n               lo))\n           (find-right-index ()\n             (let ((lo 0)\n                   (hi (length array)))\n               (loop while (< lo hi) do\n                 (let ((mid (floor (+ lo hi) 2)))\n                   (if (<= (aref array mid) query)\n                       (setf lo (1+ mid))\n                       (setf hi mid))))\n               lo)))\n    (let ((left-index (find-left-index))\n          (right-index (find-right-index)))\n      (if (or (= left-index (length array))\n              (/= (aref array left-index) query))\n          0\n          (- right-index left-index)))))", "test_cases": "", "test_case_results": "Array: (1 2 2 3 4), Query: 2\nCount: 2\nArray: (1 2 3 4 5), Query: 3\nCount: 1\nArray: (1 1 1 1 1), Query: 1\nCount: 5\nArray: (2 4 6 8 10), Query: 5\nCount: 0\nArray: NIL, Query: 1\nCount: 0", "task_id": 21338, "assertions": "(defpackage :binary-search-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :binary-search-test)\n\n(defun run-tests ()\n  (let ((test-array-1 (make-array 5 :initial-contents '(1 2 2 3 4)))\n        (test-array-2 (make-array 5 :initial-contents '(1 2 3 4 5)))\n        (test-array-3 (make-array 5 :initial-contents '(1 1 1 1 1)))\n        (test-array-4 (make-array 5 :initial-contents '(2 4 6 8 10)))\n        (test-array-5 (make-array 0 :initial-contents '())))\n    \n    (assert (= (binary-search-extended test-array-1 2) 2) () \"Count of 2 should be 2\")\n    (assert (= (binary-search-extended test-array-2 3) 1) () \"Count of 3 should be 1\")\n    (assert (= (binary-search-extended test-array-3 1) 5) () \"Count of 1 should be 5\")\n    (assert (= (binary-search-extended test-array-4 5) 0) () \"Count of 5 should be 0\")\n    (assert (= (binary-search-extended test-array-5 1) 0) () \"Count in empty array should be 0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :binary-search-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :binary-search-test)\n\n(defun run-tests ()\n  (let ((test-array-1 (make-array 5 :initial-contents '(1 2 2 3 4)))\n        (test-array-2 (make-array 5 :initial-contents '(1 2 3 4 5)))\n        (test-array-3 (make-array 5 :initial-contents '(1 1 1 1 1)))\n        (test-array-4 (make-array 5 :initial-contents '(2 4 6 8 10)))\n        (test-array-5 (make-array 0 :initial-contents '())))\n    \n    (assert (= (binary-search-extended test-array-1 2) 2) () \"Count of 2 should be 2\")\n    (assert (= (binary-search-extended test-array-2 3) 1) () \"Count of 3 should be 1\")\n    (assert (= (binary-search-extended test-array-3 1) 5) () \"Count of 1 should be 5\")\n    (assert (= (binary-search-extended test-array-4 5) 0) () \"Count of 5 should be 0\")\n    (assert (= (binary-search-extended test-array-5 1) 0) () \"Count in empty array should be 0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "binary-search-extended"}, "all_code": "(defpackage :binary-search-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :binary-search-test)\n\n(defun binary-search-extended (array query)\n  (labels ((find-left-index ()\n             (let ((lo 0)\n                   (hi (length array)))\n               (loop while (< lo hi) do\n                 (let ((mid (floor (+ lo hi) 2)))\n                   (if (< (aref array mid) query)\n                       (setf lo (1+ mid))\n                       (setf hi mid))))\n               lo))\n           (find-right-index ()\n             (let ((lo 0)\n                   (hi (length array)))\n               (loop while (< lo hi) do\n                 (let ((mid (floor (+ lo hi) 2)))\n                   (if (<= (aref array mid) query)\n                       (setf lo (1+ mid))\n                       (setf hi mid))))\n               lo)))\n    (let ((left-index (find-left-index))\n          (right-index (find-right-index)))\n      (if (or (= left-index (length array))\n              (/= (aref array left-index) query))\n          0\n          (- right-index left-index)))))\n\n\n(defun run-tests ()\n  (let ((test-array-1 (make-array 5 :initial-contents '(1 2 2 3 4)))\n        (test-array-2 (make-array 5 :initial-contents '(1 2 3 4 5)))\n        (test-array-3 (make-array 5 :initial-contents '(1 1 1 1 1)))\n        (test-array-4 (make-array 5 :initial-contents '(2 4 6 8 10)))\n        (test-array-5 (make-array 0 :initial-contents '())))\n    \n    (assert (= (binary-search-extended test-array-1 2) 2) () \"Count of 2 should be 2\")\n    (assert (= (binary-search-extended test-array-2 3) 1) () \"Count of 3 should be 1\")\n    (assert (= (binary-search-extended test-array-3 1) 5) () \"Count of 1 should be 5\")\n    (assert (= (binary-search-extended test-array-4 5) 0) () \"Count of 5 should be 0\")\n    (assert (= (binary-search-extended test-array-5 1) 0) () \"Count in empty array should be 0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; A network path representation with nodes and connections between them.\n;;; The connections are bidirectional with associated latencies.\n\n(defstruct network-path\n  (nodes (make-hash-table :test 'equal)) ; Set of nodes\n  (connections (make-hash-table :test 'equal))) ; Connections between nodes\n\n;;; add-node adds a new node to the network.\n;;; Raises an error if the node already exists.\n(defun add-node (network node)\n  (when (gethash node (network-path-nodes network))\n    (error \"Node ~a already exists.\" node))\n  (setf (gethash node (network-path-nodes network)) t)\n  (setf (gethash node (network-path-connections network)) (make-hash-table :test 'equal)))\n\n;;; connect-nodes connects two nodes with a given latency.\n;;; Raises an error if either node doesn't exist or if latency is not positive.\n(defun connect-nodes (network node1 node2 latency)\n  (validate-network network node1 node2)\n  (when (<= latency 0)\n    (error \"Latency must be a positive number.\"))\n  (setf (gethash node2 (gethash node1 (network-path-connections network))) latency)\n  (setf (gethash node1 (gethash node2 (network-path-connections network))) latency))\n\n;;; calculate-latency computes the total latency along a given path.\n;;; Raises an error if the path is invalid or if nodes are not directly connected.\n(defun calculate-latency (network path)\n  (let ((total-latency 0.0))\n    (loop for i from 0 below (1- (length path)) do\n      (let ((node1 (nth i path))\n            (node2 (nth (1+ i) path)))\n        (validate-network network node1 node2)\n        (unless (gethash node2 (gethash node1 (network-path-connections network)))\n          (error \"No direct connection between ~a and ~a.\" node1 node2))\n        (incf total-latency (gethash node2 (gethash node1 (network-path-connections network))))))\n    total-latency))\n\n;;; validate-network checks if all given nodes exist in the network.\n;;; Raises an error if any node doesn't exist.\n(defun validate-network (network &rest nodes)\n  (dolist (node nodes)\n    (unless (gethash node (network-path-nodes network))\n      (error \"Node ~a does not exist.\" node))))", "test_cases": "", "test_case_results": "Path: (A B C D)\nTotal latency: 4.5\nPath: (A D)\nTotal latency: 4.0\nPath: (A B C)\nTotal latency: 3.0", "task_id": 24173, "assertions": "(defpackage :network-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :network-test)\n\n(defun run-tests ()\n  (let ((network (make-network-path)))\n    ;; Setup network\n    (add-node network \"A\")\n    (add-node network \"B\")\n    (add-node network \"C\")\n    (add-node network \"D\")\n    \n    (connect-nodes network \"A\" \"B\" 1.0)\n    (connect-nodes network \"B\" \"C\" 2.0)\n    (connect-nodes network \"C\" \"D\" 1.5)\n    (connect-nodes network \"A\" \"D\" 4.0)\n    \n    ;; Test cases\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\" \"D\")) 4.5) () \"Path A-B-C-D should have latency 4.5\")\n    (assert (= (calculate-latency network '(\"A\" \"D\")) 4.0) () \"Path A-D should have latency 4.0\")\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\")) 3.0) () \"Path A-B-C should have latency 3.0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :network-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :network-test)\n\n(defun run-tests ()\n  (let ((network (make-network-path)))\n    ;; Setup network\n    (add-node network \"A\")\n    (add-node network \"B\")\n    (add-node network \"C\")\n    (add-node network \"D\")\n    \n    (connect-nodes network \"A\" \"B\" 1.0)\n    (connect-nodes network \"B\" \"C\" 2.0)\n    (connect-nodes network \"C\" \"D\" 1.5)\n    (connect-nodes network \"A\" \"D\" 4.0)\n    \n    ;; Test cases\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\" \"D\")) 4.5) () \"Path A-B-C-D should have latency 4.5\")\n    (assert (= (calculate-latency network '(\"A\" \"D\")) 4.0) () \"Path A-D should have latency 4.0\")\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\")) 3.0) () \"Path A-B-C should have latency 3.0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "calculate-latency"}, "all_code": "(defpackage :network-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :network-test)\n\n(defun add-node (network node)\n  (when (gethash node (network-path-nodes network))\n    (error \"Node ~a already exists.\" node))\n  (setf (gethash node (network-path-nodes network)) t)\n  (setf (gethash node (network-path-connections network)) (make-hash-table :test 'equal)))\n\n;;; connect-nodes connects two nodes with a given latency.\n;;; Raises an error if either node doesn't exist or if latency is not positive.\n(defun connect-nodes (network node1 node2 latency)\n  (validate-network network node1 node2)\n  (when (<= latency 0)\n    (error \"Latency must be a positive number.\"))\n  (setf (gethash node2 (gethash node1 (network-path-connections network))) latency)\n  (setf (gethash node1 (gethash node2 (network-path-connections network))) latency))\n\n;;; calculate-latency computes the total latency along a given path.\n;;; Raises an error if the path is invalid or if nodes are not directly connected.\n(defun calculate-latency (network path)\n  (let ((total-latency 0.0))\n    (loop for i from 0 below (1- (length path)) do\n      (let ((node1 (nth i path))\n            (node2 (nth (1+ i) path)))\n        (validate-network network node1 node2)\n        (unless (gethash node2 (gethash node1 (network-path-connections network)))\n          (error \"No direct connection between ~a and ~a.\" node1 node2))\n        (incf total-latency (gethash node2 (gethash node1 (network-path-connections network))))))\n    total-latency))\n\n;;; validate-network checks if all given nodes exist in the network.\n;;; Raises an error if any node doesn't exist.\n(defun validate-network (network &rest nodes)\n  (dolist (node nodes)\n    (unless (gethash node (network-path-nodes network))\n      (error \"Node ~a does not exist.\" node))))\n\n\n(defun run-tests ()\n  (let ((network (make-network-path)))\n    ;; Setup network\n    (add-node network \"A\")\n    (add-node network \"B\")\n    (add-node network \"C\")\n    (add-node network \"D\")\n    \n    (connect-nodes network \"A\" \"B\" 1.0)\n    (connect-nodes network \"B\" \"C\" 2.0)\n    (connect-nodes network \"C\" \"D\" 1.5)\n    (connect-nodes network \"A\" \"D\" 4.0)\n    \n    ;; Test cases\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\" \"D\")) 4.5) () \"Path A-B-C-D should have latency 4.5\")\n    (assert (= (calculate-latency network '(\"A\" \"D\")) 4.0) () \"Path A-D should have latency 4.0\")\n    (assert (= (calculate-latency network '(\"A\" \"B\" \"C\")) 3.0) () \"Path A-B-C should have latency 3.0\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; pad-vectors pads all vectors to the maximum length among the vectors, replacing 'NIL' values\n; with the minimum possible absolute value except zero. If there are no non-zero values,\n; use -1 for padding.\n; \n; Parameters:\n;   vectors - a list of lists (vectors) containing numbers or NILs\n;\n; Returns:\n;   a list of padded vectors with NILs replaced and all vectors of equal length\n(defun pad-vectors (vectors)\n  (let* ((max-len (apply #'max (mapcar #'length vectors)))\n         (non-zero-abs-vals (loop for vec in vectors\n                                  for x in vec\n                                  when (and x (not (zerop x)))\n                                    collect (abs x)))\n         (min-abs-val (if non-zero-abs-vals \n                        (apply #'min non-zero-abs-vals) \n                        -1)))\n    (mapcar (lambda (vec)\n              (let* ((num-pads (- max-len (length vec)))\n                     (replaced-vec (mapcar (lambda (x) (if x x min-abs-val)) vec)))\n                (append replaced-vec (make-list num-pads :initial-element min-abs-val))))\n            vectors)))", "test_cases": "", "test_case_results": "Input: ((1 2 NIL 4) (5 NIL 7 0) (NIL NIL NIL))\nPadded: ((1 2 -1 4) (5 -1 7 0) (-1 -1 -1 -1))\n\nInput: ((1 2 3) (4 5))\nPadded: ((1 2 3) (4 5 -1))\n\nInput: ((0 0 NIL) (NIL NIL NIL NIL))\nPadded: ((0 0 -1 -1) (-1 -1 -1 -1))", "task_id": 18650, "assertions": "(defpackage :pad-vectors-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :pad-vectors-test)\n\n(defun run-tests ()\n  (assert (equal (pad-vectors '((1 2 NIL 4) (5 NIL 7 0) (NIL NIL NIL)))\n                 '((1 2 -1 4) (5 -1 7 0) (-1 -1 -1 -1)))\n          () \"First test case failed\")\n  (assert (equal (pad-vectors '((1 2 3) (4 5)))\n                 '((1 2 3) (4 5 -1)))\n          () \"Second test case failed\")\n  (assert (equal (pad-vectors '((0 0 NIL) (NIL NIL NIL NIL)))\n                 '((0 0 -1 -1) (-1 -1 -1 -1)))\n          () \"Third test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :pad-vectors-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :pad-vectors-test)\n\n(defun run-tests ()\n  (assert (equal (pad-vectors '((1 2 NIL 4) (5 NIL 7 0) (NIL NIL NIL)))\n                 '((1 2 -1 4) (5 -1 7 0) (-1 -1 -1 -1)))\n          () \"First test case failed\")\n  (assert (equal (pad-vectors '((1 2 3) (4 5)))\n                 '((1 2 3) (4 5 -1)))\n          () \"Second test case failed\")\n  (assert (equal (pad-vectors '((0 0 NIL) (NIL NIL NIL NIL)))\n                 '((0 0 -1 -1) (-1 -1 -1 -1)))\n          () \"Third test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "pad-vectors"}, "all_code": "(defpackage :pad-vectors-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :pad-vectors-test)\n\n(defun pad-vectors (vectors)\n  (let* ((max-len (apply #'max (mapcar #'length vectors)))\n         (non-zero-abs-vals (loop for vec in vectors\n                                  for x in vec\n                                  when (and x (not (zerop x)))\n                                    collect (abs x)))\n         (min-abs-val (if non-zero-abs-vals \n                        (apply #'min non-zero-abs-vals) \n                        -1)))\n    (mapcar (lambda (vec)\n              (let* ((num-pads (- max-len (length vec)))\n                     (replaced-vec (mapcar (lambda (x) (if x x min-abs-val)) vec)))\n                (append replaced-vec (make-list num-pads :initial-element min-abs-val))))\n            vectors)))\n\n\n(defun run-tests ()\n  (assert (equal (pad-vectors '((1 2 NIL 4) (5 NIL 7 0) (NIL NIL NIL)))\n                 '((1 2 -1 4) (5 -1 7 0) (-1 -1 -1 -1)))\n          () \"First test case failed\")\n  (assert (equal (pad-vectors '((1 2 3) (4 5)))\n                 '((1 2 3) (4 5 -1)))\n          () \"Second test case failed\")\n  (assert (equal (pad-vectors '((0 0 NIL) (NIL NIL NIL NIL)))\n                 '((0 0 -1 -1) (-1 -1 -1 -1)))\n          () \"Third test case failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-triplet-numbers returns a sorted list of integers that appear at least three times in the input list.\n; It uses a hash table to count occurrences of each number in the list.\n; The function then filters numbers with counts >= 3 and sorts the result.\n(defun find-triplet-numbers (lst)\n  (let ((count-table (make-hash-table)))\n    ; Count occurrences of each number\n    (dolist (num lst)\n      (incf (gethash num count-table 0)))\n    ; Collect numbers with count >= 3\n    (let ((result '()))\n      (maphash (lambda (num count)\n                 (when (>= count 3)\n                   (push num result)))\n               count-table)\n      ; Sort the result\n      (sort result #'<))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5)\nResult: NIL\n\nInput: (1 1 2 2 3 3 4 4 4 5 5 5 5)\nResult: (4 5)\n\nInput: (1 1 1 2 2)\nResult: (1)\n\nInput: (1 1 1 1 1)\nResult: (1)\n\nInput: NIL\nResult: NIL", "task_id": 22049, "assertions": "(defpackage :triplet-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :triplet-test)\n\n(defun run-tests ()\n  (assert (null (find-triplet-numbers '(1 2 3 4 5))) () \"No triplets should be found\")\n  (assert (equal (find-triplet-numbers '(1 1 2 2 3 3 4 4 4 5 5 5 5)) '(4 5)) () \"Should find 4 and 5 as triplets\")\n  (assert (equal (find-triplet-numbers '(1 1 1 2 2)) '(1)) () \"Should find 1 as triplet\")\n  (assert (equal (find-triplet-numbers '(1 1 1 1 1)) '(1)) () \"Should find 1 as triplet (more than 3 occurrences)\")\n  (assert (null (find-triplet-numbers nil)) () \"Empty list should return NIL\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :triplet-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :triplet-test)\n\n(defun run-tests ()\n  (assert (null (find-triplet-numbers '(1 2 3 4 5))) () \"No triplets should be found\")\n  (assert (equal (find-triplet-numbers '(1 1 2 2 3 3 4 4 4 5 5 5 5)) '(4 5)) () \"Should find 4 and 5 as triplets\")\n  (assert (equal (find-triplet-numbers '(1 1 1 2 2)) '(1)) () \"Should find 1 as triplet\")\n  (assert (equal (find-triplet-numbers '(1 1 1 1 1)) '(1)) () \"Should find 1 as triplet (more than 3 occurrences)\")\n  (assert (null (find-triplet-numbers nil)) () \"Empty list should return NIL\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-triplet-numbers"}, "all_code": "(defpackage :triplet-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :triplet-test)\n\n(defun find-triplet-numbers (lst)\n  (let ((count-table (make-hash-table)))\n    ; Count occurrences of each number\n    (dolist (num lst)\n      (incf (gethash num count-table 0)))\n    ; Collect numbers with count >= 3\n    (let ((result '()))\n      (maphash (lambda (num count)\n                 (when (>= count 3)\n                   (push num result)))\n               count-table)\n      ; Sort the result\n      (sort result #'<))))\n\n\n(defun run-tests ()\n  (assert (null (find-triplet-numbers '(1 2 3 4 5))) () \"No triplets should be found\")\n  (assert (equal (find-triplet-numbers '(1 1 2 2 3 3 4 4 4 5 5 5 5)) '(4 5)) () \"Should find 4 and 5 as triplets\")\n  (assert (equal (find-triplet-numbers '(1 1 1 2 2)) '(1)) () \"Should find 1 as triplet\")\n  (assert (equal (find-triplet-numbers '(1 1 1 1 1)) '(1)) () \"Should find 1 as triplet (more than 3 occurrences)\")\n  (assert (null (find-triplet-numbers nil)) () \"Empty list should return NIL\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; min-largest-split calculates the smallest possible largest substring length when splitting a string s into k parts.\n; It uses binary search to efficiently determine the minimal maximum length.\n; The function first checks if it's possible to divide the string into k parts with a given maximum length.\n(defun min-largest-split (s k)\n  (labels ((can-divide (max-length)\n             (let ((chunks 1)\n                   (current-length 0))\n               (loop for char across s do\n                 (incf current-length)\n                 (when (> current-length max-length)\n                   (incf chunks)\n                   (setf current-length 1)\n                   (when (> chunks k)\n                     (return-from can-divide nil))))\n               t)))\n    (let ((left (max (floor (length s) k) 1))\n          (right (length s)))\n      (loop while (< left right) do\n        (let ((mid (floor (+ left right) 2)))\n          (if (can-divide mid)\n              (setf right mid)\n              (setf left (1+ mid)))))\n      left)))", "test_cases": "", "test_case_results": "Input: abcde, k: 2\nResult: 3\nInput: abcdefghij, k: 3\nResult: 4\nInput: a, k: 1\nResult: 1\nInput: aaaaa, k: 5\nResult: 1", "task_id": 3651, "assertions": "(defpackage :split-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :split-test)\n\n(defun run-tests ()\n  (assert (= (min-largest-split \"abcde\" 2) 3) () \"Test case 1 failed\")\n  (assert (= (min-largest-split \"abcdefghij\" 3) 4) () \"Test case 2 failed\")\n  (assert (= (min-largest-split \"a\" 1) 1) () \"Test case 3 failed\")\n  (assert (= (min-largest-split \"aaaaa\" 5) 1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :split-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :split-test)\n\n(defun run-tests ()\n  (assert (= (min-largest-split \"abcde\" 2) 3) () \"Test case 1 failed\")\n  (assert (= (min-largest-split \"abcdefghij\" 3) 4) () \"Test case 2 failed\")\n  (assert (= (min-largest-split \"a\" 1) 1) () \"Test case 3 failed\")\n  (assert (= (min-largest-split \"aaaaa\" 5) 1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-largest-split"}, "all_code": "(defpackage :split-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :split-test)\n\n(defun min-largest-split (s k)\n  (labels ((can-divide (max-length)\n             (let ((chunks 1)\n                   (current-length 0))\n               (loop for char across s do\n                 (incf current-length)\n                 (when (> current-length max-length)\n                   (incf chunks)\n                   (setf current-length 1)\n                   (when (> chunks k)\n                     (return-from can-divide nil))))\n               t)))\n    (let ((left (max (floor (length s) k) 1))\n          (right (length s)))\n      (loop while (< left right) do\n        (let ((mid (floor (+ left right) 2)))\n          (if (can-divide mid)\n              (setf right mid)\n              (setf left (1+ mid)))))\n      left)))\n\n\n(defun run-tests ()\n  (assert (= (min-largest-split \"abcde\" 2) 3) () \"Test case 1 failed\")\n  (assert (= (min-largest-split \"abcdefghij\" 3) 4) () \"Test case 2 failed\")\n  (assert (= (min-largest-split \"a\" 1) 1) () \"Test case 3 failed\")\n  (assert (= (min-largest-split \"aaaaa\" 5) 1) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; can-complete-routes checks if the given delivery routes can be completed without an infinite loop.\n; The function uses depth-first search (DFS) to detect cycles in the directed graph represented by the routes.\n; If a cycle is found, it returns NIL, indicating the routes cannot be completed without an infinite loop.\n; Otherwise, it returns T, indicating the routes can be completed successfully.\n(defun can-complete-routes (routes)\n  (let ((graph (make-hash-table :test #'equal))\n        (visited (make-hash-table :test #'equal))\n        (rec-stack (make-hash-table :test #'equal)))\n    \n    ; Build the graph as an adjacency list\n    (dolist (route routes)\n      (let ((start (first route))\n            (end (second route)))\n        (unless (gethash start graph)\n          (setf (gethash start graph) '()))\n        (push end (gethash start graph))))\n    \n    ; Define the DFS function for cycle detection\n    (labels ((dfs (node)\n               (setf (gethash node visited) t)\n               (setf (gethash node rec-stack) t)\n               \n               (dolist (neighbor (gethash node graph '()))\n                 (unless (gethash neighbor visited)\n                   (when (dfs neighbor)\n                     (return-from dfs t)))\n                 (when (gethash neighbor rec-stack)\n                   (return-from dfs t)))\n               \n               (remhash node rec-stack)\n               nil))\n      \n      ; Check each node in the graph for cycles\n      (maphash (lambda (node _)\n                 (unless (gethash node visited)\n                   (when (dfs node)\n                     (return-from can-complete-routes nil))))\n               graph)\n      \n      t)))", "test_cases": "", "test_case_results": "Input: (((A B) (B C) (C A)) ((A B) (B C) (C D)) ((A B) (B A))\n        ((A B) (B C) (A C)) ((A B) (B C) (C B)))\nResult: T", "task_id": 11322, "assertions": "(defpackage :route-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :route-utils-test)\n\n(defun run-tests ()\n  (let ((test-cases '((((a b) (b c) (c a)) nil)         ; Cycle: a -> b -> c -> a\n                      (((a b) (b c) (c d)) t)          ; No cycle\n                      (((a b) (b a)) nil)              ; Cycle: a -> b -> a\n                      (((a b) (b c) (a c)) t)          ; No cycle\n                      (((a b) (b c) (c b)) nil))))     ; Cycle: b -> c -> b\n    (dolist (test-case test-cases)\n      (let ((routes (first test-case))\n            (expected (second test-case)))\n        (assert (eq (cl-user:can-complete-routes routes) expected)\n                () \"Test failed for routes ~a. Expected ~a but got ~a\"\n                routes expected (not expected)))))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :route-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :route-utils-test)\n\n(defun run-tests ()\n  (let ((test-cases '((((a b) (b c) (c a)) nil)         ; Cycle: a -> b -> c -> a\n                      (((a b) (b c) (c d)) t)          ; No cycle\n                      (((a b) (b a)) nil)              ; Cycle: a -> b -> a\n                      (((a b) (b c) (a c)) t)          ; No cycle\n                      (((a b) (b c) (c b)) nil))))     ; Cycle: b -> c -> b\n    (dolist (test-case test-cases)\n      (let ((routes (first test-case))\n            (expected (second test-case)))\n        (assert (eq (cl-user:can-complete-routes routes) expected)\n                () \"Test failed for routes ~a. Expected ~a but got ~a\"\n                routes expected (not expected)))))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "The function being tested is:\n\n`can-complete-routes`"}, "all_code": "(defpackage :route-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :route-utils-test)\n\n(defun can-complete-routes (routes)\n  (let ((graph (make-hash-table :test #'equal))\n        (visited (make-hash-table :test #'equal))\n        (rec-stack (make-hash-table :test #'equal)))\n    \n    ; Build the graph as an adjacency list\n    (dolist (route routes)\n      (let ((start (first route))\n            (end (second route)))\n        (unless (gethash start graph)\n          (setf (gethash start graph) '()))\n        (push end (gethash start graph))))\n    \n    ; Define the DFS function for cycle detection\n    (labels ((dfs (node)\n               (setf (gethash node visited) t)\n               (setf (gethash node rec-stack) t)\n               \n               (dolist (neighbor (gethash node graph '()))\n                 (unless (gethash neighbor visited)\n                   (when (dfs neighbor)\n                     (return-from dfs t)))\n                 (when (gethash neighbor rec-stack)\n                   (return-from dfs t)))\n               \n               (remhash node rec-stack)\n               nil))\n      \n      ; Check each node in the graph for cycles\n      (maphash (lambda (node _)\n                 (unless (gethash node visited)\n                   (when (dfs node)\n                     (return-from can-complete-routes nil))))\n               graph)\n      \n      t)))\n\n\n(defun run-tests ()\n  (let ((test-cases '((((a b) (b c) (c a)) nil)         ; Cycle: a -> b -> c -> a\n                      (((a b) (b c) (c d)) t)          ; No cycle\n                      (((a b) (b a)) nil)              ; Cycle: a -> b -> a\n                      (((a b) (b c) (a c)) t)          ; No cycle\n                      (((a b) (b c) (c b)) nil))))     ; Cycle: b -> c -> b\n    (dolist (test-case test-cases)\n      (let ((routes (first test-case))\n            (expected (second test-case)))\n        (assert (eq (can-complete-routes routes) expected)\n                () \"Test failed for routes ~a. Expected ~a but got ~a\"\n                routes expected (not expected)))))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; sum-unique-values calculates the sum of unique values in a list of integers.\n; A value is considered unique if it appears exactly once in the list.\n; The function uses a hash table to count the frequency of each number.\n(defun sum-unique-values (nums)\n  (let ((count-table (make-hash-table)))\n    ; Count the frequency of each number\n    (dolist (num nums)\n      (incf (gethash num count-table 0)))\n    ; Sum numbers that appear exactly once\n    (loop for num being the hash-keys of count-table\n          for freq = (gethash num count-table)\n          when (= freq 1)\n          sum num)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4)\nSum of unique values: 10\n\nInput: (1 2 2 3 3 4)\nSum of unique values: 5\n\nInput: (5 5 5 5)\nSum of unique values: 0\n\nInput: NIL\nSum of unique values: 0", "task_id": 13793, "assertions": "(defpackage :sum-unique-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :sum-unique-test)\n\n(defun run-tests ()\n  (assert (= (sum-unique-values '(1 2 3 4)) 10) () \n          \"Test 1 failed: Expected 10 for input (1 2 3 4)\")\n  (assert (= (sum-unique-values '(1 2 2 3 3 4)) 5) () \n          \"Test 2 failed: Expected 5 for input (1 2 2 3 3 4)\")\n  (assert (= (sum-unique-values '(5 5 5 5)) 0) () \n          \"Test 3 failed: Expected 0 for input (5 5 5 5)\")\n  (assert (= (sum-unique-values nil) 0) () \n          \"Test 4 failed: Expected 0 for empty list\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :sum-unique-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :sum-unique-test)\n\n(defun run-tests ()\n  (assert (= (sum-unique-values '(1 2 3 4)) 10) () \n          \"Test 1 failed: Expected 10 for input (1 2 3 4)\")\n  (assert (= (sum-unique-values '(1 2 2 3 3 4)) 5) () \n          \"Test 2 failed: Expected 5 for input (1 2 2 3 3 4)\")\n  (assert (= (sum-unique-values '(5 5 5 5)) 0) () \n          \"Test 3 failed: Expected 0 for input (5 5 5 5)\")\n  (assert (= (sum-unique-values nil) 0) () \n          \"Test 4 failed: Expected 0 for empty list\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "sum-unique-values"}, "all_code": "(defpackage :sum-unique-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :sum-unique-test)\n\n(defun sum-unique-values (nums)\n  (let ((count-table (make-hash-table)))\n    ; Count the frequency of each number\n    (dolist (num nums)\n      (incf (gethash num count-table 0)))\n    ; Sum numbers that appear exactly once\n    (loop for num being the hash-keys of count-table\n          for freq = (gethash num count-table)\n          when (= freq 1)\n          sum num)))\n\n\n(defun run-tests ()\n  (assert (= (sum-unique-values '(1 2 3 4)) 10) () \n          \"Test 1 failed: Expected 10 for input (1 2 3 4)\")\n  (assert (= (sum-unique-values '(1 2 2 3 3 4)) 5) () \n          \"Test 2 failed: Expected 5 for input (1 2 2 3 3 4)\")\n  (assert (= (sum-unique-values '(5 5 5 5)) 0) () \n          \"Test 3 failed: Expected 0 for input (5 5 5 5)\")\n  (assert (= (sum-unique-values nil) 0) () \n          \"Test 4 failed: Expected 0 for empty list\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :consecutive-odds\n  (:use :cl)\n  (:export :contains-three-consecutive-odds))\n\n(in-package :consecutive-odds)\n\n(defun contains-three-consecutive-odds (arr)\n  (let ((count 0))\n    (dolist (num arr)\n      (if (oddp num)\n          (progn\n            (incf count)\n            (when (>= count 3)\n              (return-from contains-three-consecutive-odds t)))\n          (setf count 0))))\n  nil)", "test_cases": "", "test_case_results": "Input: (1 3 5 7)\nResult: T\n\nInput: (2 4 6 8)\nResult: NIL\n\nInput: (1 2 3 5 7)\nResult: T\n\nInput: (1 2 3 4 5 7 9)\nResult: T\n\nInput: (1 2 1 2 1 2 1)\nResult: NIL\n\nInput: (1 3 2 5 7 9 4)\nResult: T", "task_id": 20422, "assertions": "(defpackage :consecutive-odds-test\n  (:use :cl :consecutive-odds)\n  (:export :run-tests))\n\n(in-package :consecutive-odds-test)\n\n(defun run-tests ()\n  (assert (contains-three-consecutive-odds '(1 3 5 7)) () \"Test case 1 failed\")\n  (assert (not (contains-three-consecutive-odds '(2 4 6 8))) () \"Test case 2 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 5 7)) () \"Test case 3 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 4 5 7 9)) () \"Test case 4 failed\")\n  (assert (not (contains-three-consecutive-odds '(1 2 1 2 1 2 1))) () \"Test case 5 failed\")\n  (assert (contains-three-consecutive-odds '(1 3 2 5 7 9 4)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :consecutive-odds-test\n  (:use :cl :consecutive-odds)\n  (:export :run-tests))\n\n(in-package :consecutive-odds-test)\n\n(defun run-tests ()\n  (assert (contains-three-consecutive-odds '(1 3 5 7)) () \"Test case 1 failed\")\n  (assert (not (contains-three-consecutive-odds '(2 4 6 8))) () \"Test case 2 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 5 7)) () \"Test case 3 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 4 5 7 9)) () \"Test case 4 failed\")\n  (assert (not (contains-three-consecutive-odds '(1 2 1 2 1 2 1))) () \"Test case 5 failed\")\n  (assert (contains-three-consecutive-odds '(1 3 2 5 7 9 4)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "contains-three-consecutive-odds"}, "all_code": "(defpackage :consecutive-odds-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :consecutive-odds-test)\n\n(defun contains-three-consecutive-odds (arr)\n  (let ((count 0))\n    (dolist (num arr)\n      (if (oddp num)\n          (progn\n            (incf count)\n            (when (>= count 3)\n              (return-from contains-three-consecutive-odds t)))\n          (setf count 0))))\n  nil)\n\n\n(defun run-tests ()\n  (assert (contains-three-consecutive-odds '(1 3 5 7)) () \"Test case 1 failed\")\n  (assert (not (contains-three-consecutive-odds '(2 4 6 8))) () \"Test case 2 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 5 7)) () \"Test case 3 failed\")\n  (assert (contains-three-consecutive-odds '(1 2 3 4 5 7 9)) () \"Test case 4 failed\")\n  (assert (not (contains-three-consecutive-odds '(1 2 1 2 1 2 1))) () \"Test case 5 failed\")\n  (assert (contains-three-consecutive-odds '(1 3 2 5 7 9 4)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; tsp-min-cost calculates the minimum possible sum of the distances for the shortest route\n;; that visits every destination exactly once and returns to the starting point.\n;; \n;; Args:\n;; N: integer : Number of destinations\n;; distances: list of lists : NxN matrix where (nth i (nth j distances)) is the distance \n;;                            from destination i to destination j.\n;;\n;; Returns:\n;; integer: Minimum route distance\n(defun tsp-min-cost (N distances)\n  (let ((min-cost most-positive-fixnum))\n    (labels ((permute (lst)\n               (if (null lst)\n                   (list nil)\n                   (loop for elem in lst\n                         append (mapcar (lambda (p) (cons elem p))\n                                       (permute (remove elem lst)))))))\n      (dolist (tour (permute (loop for i from 1 below N collect i)) min-cost)\n        (let ((current-cost 0)\n              (current-position 0))\n          (dolist (next-position tour)\n            (incf current-cost (nth current-position (nth next-position distances)))\n            (setf current-position next-position))\n          (incf current-cost (nth current-position (nth 0 distances)))\n          (when (< current-cost min-cost)\n            (setf min-cost current-cost)))))))", "test_cases": "", "test_case_results": "N: 4\nDistances: ((0 10 15 20) (10 0 35 25) (15 35 0 30) (20 25 30 0))\nMinimum cost: 80\n\nN: 3\nDistances: ((0 5 10) (5 0 8) (10 8 0))\nMinimum cost: 23", "task_id": 17021, "assertions": "(defpackage :tsp-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :tsp-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '(4 ((0 10 15 20)\n                         (10 0 35 25)\n                         (15 35 0 30)\n                         (20 25 30 0))))\n        (test-case-2 '(3 ((0 5 10)\n                         (5 0 8)\n                         (10 8 0)))))\n    (assert (= (tsp-min-cost (first test-case-1) (second test-case-1)) 80)\n            () \"Test case 1 failed: Expected 80\")\n    (assert (= (tsp-min-cost (first test-case-2) (second test-case-2)) 23)\n            () \"Test case 2 failed: Expected 23\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :tsp-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :tsp-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '(4 ((0 10 15 20)\n                         (10 0 35 25)\n                         (15 35 0 30)\n                         (20 25 30 0))))\n        (test-case-2 '(3 ((0 5 10)\n                         (5 0 8)\n                         (10 8 0)))))\n    (assert (= (tsp-min-cost (first test-case-1) (second test-case-1)) 80)\n            () \"Test case 1 failed: Expected 80\")\n    (assert (= (tsp-min-cost (first test-case-2) (second test-case-2)) 23)\n            () \"Test case 2 failed: Expected 23\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "tsp-min-cost"}, "all_code": "(defpackage :tsp-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :tsp-test)\n\n(defun tsp-min-cost (N distances)\n  (let ((min-cost most-positive-fixnum))\n    (labels ((permute (lst)\n               (if (null lst)\n                   (list nil)\n                   (loop for elem in lst\n                         append (mapcar (lambda (p) (cons elem p))\n                                       (permute (remove elem lst)))))))\n      (dolist (tour (permute (loop for i from 1 below N collect i)) min-cost)\n        (let ((current-cost 0)\n              (current-position 0))\n          (dolist (next-position tour)\n            (incf current-cost (nth current-position (nth next-position distances)))\n            (setf current-position next-position))\n          (incf current-cost (nth current-position (nth 0 distances)))\n          (when (< current-cost min-cost)\n            (setf min-cost current-cost)))))))\n\n\n(defun run-tests ()\n  (let ((test-case-1 '(4 ((0 10 15 20)\n                         (10 0 35 25)\n                         (15 35 0 30)\n                         (20 25 30 0))))\n        (test-case-2 '(3 ((0 5 10)\n                         (5 0 8)\n                         (10 8 0)))))\n    (assert (= (tsp-min-cost (first test-case-1) (second test-case-1)) 80)\n            () \"Test case 1 failed: Expected 80\")\n    (assert (= (tsp-min-cost (first test-case-2) (second test-case-2)) 23)\n            () \"Test case 2 failed: Expected 23\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :subarray-utils\n  (:use :cl)\n  (:export :longest-subarray-with-sum))\n\n(in-package :subarray-utils)\n\n(defun longest-subarray-with-sum (arr S)\n  (let ((max-length 0)\n        (start-index 0)\n        (curr-sum 0)\n        (sum-dict (make-hash-table)))\n    (loop for i from 0 below (length arr) do\n      (incf curr-sum (nth i arr))\n      (cond\n        ((= curr-sum S)\n         (when (> (1+ i) max-length)\n           (setf max-length (1+ i))\n           (setf start-index 0)))\n        ((gethash (- curr-sum S) sum-dict)\n         (let ((prev-index (gethash (- curr-sum S) sum-dict)))\n           (when (> (- i prev-index) max-length)\n             (setf max-length (- i prev-index))\n             (setf start-index (1+ prev-index))))))\n      (unless (gethash curr-sum sum-dict)\n        (setf (gethash curr-sum sum-dict) i)))\n    (if (zerop max-length)\n        '()\n        (subseq arr start-index (+ start-index max-length)))))", "test_cases": "", "test_case_results": "Input array: (1 2 3 4 5), Target sum: 9\nLongest subarray: (2 3 4)\nInput array: (1 -1 5 -2 3), Target sum: 3\nLongest subarray: (1 -1 5 -2)\nInput array: (2 3 7 1 5), Target sum: 8\nLongest subarray: (7 1)\nInput array: (1 2 3 4), Target sum: 10\nLongest subarray: (1 2 3 4)\nInput array: (1 2 3 4), Target sum: 0\nLongest subarray: NIL", "task_id": 29072, "assertions": "(defpackage :subarray-utils-test\n  (:use :cl :subarray-utils)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun run-tests ()\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4 5) 9) '(2 3 4)) \n          () \"Test case 1 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 -1 5 -2 3) 3) '(1 -1 5 -2))\n          () \"Test case 2 failed\")\n  (assert (equal (longest-subarray-with-sum '(2 3 7 1 5) 8) '(7 1))\n          () \"Test case 3 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 10) '(1 2 3 4))\n          () \"Test case 4 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 0) '())\n          () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :subarray-utils-test\n  (:use :cl :subarray-utils)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun run-tests ()\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4 5) 9) '(2 3 4)) \n          () \"Test case 1 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 -1 5 -2 3) 3) '(1 -1 5 -2))\n          () \"Test case 2 failed\")\n  (assert (equal (longest-subarray-with-sum '(2 3 7 1 5) 8) '(7 1))\n          () \"Test case 3 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 10) '(1 2 3 4))\n          () \"Test case 4 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 0) '())\n          () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "longest-subarray-with-sum"}, "all_code": "(defpackage :subarray-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :subarray-utils-test)\n\n(defun longest-subarray-with-sum (arr S)\n  (let ((max-length 0)\n        (start-index 0)\n        (curr-sum 0)\n        (sum-dict (make-hash-table)))\n    (loop for i from 0 below (length arr) do\n      (incf curr-sum (nth i arr))\n      (cond\n        ((= curr-sum S)\n         (when (> (1+ i) max-length)\n           (setf max-length (1+ i))\n           (setf start-index 0)))\n        ((gethash (- curr-sum S) sum-dict)\n         (let ((prev-index (gethash (- curr-sum S) sum-dict)))\n           (when (> (- i prev-index) max-length)\n             (setf max-length (- i prev-index))\n             (setf start-index (1+ prev-index))))))\n      (unless (gethash curr-sum sum-dict)\n        (setf (gethash curr-sum sum-dict) i)))\n    (if (zerop max-length)\n        '()\n        (subseq arr start-index (+ start-index max-length)))))\n\n\n(defun run-tests ()\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4 5) 9) '(2 3 4)) \n          () \"Test case 1 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 -1 5 -2 3) 3) '(1 -1 5 -2))\n          () \"Test case 2 failed\")\n  (assert (equal (longest-subarray-with-sum '(2 3 7 1 5) 8) '(7 1))\n          () \"Test case 3 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 10) '(1 2 3 4))\n          () \"Test case 4 failed\")\n  (assert (equal (longest-subarray-with-sum '(1 2 3 4) 0) '())\n          () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; preprocess takes a string, converts it to lowercase, removes non-alphabetic characters,\n; and returns the characters sorted alphabetically.\n; This is used as a key for grouping anagrams.\n(defun preprocess (word)\n  (let* ((lower-word (string-downcase word))\n         (cleaned-word (remove-if-not #'alpha-char-p lower-word)))\n    (sort (copy-seq cleaned-word) #'char<)))\n\n; find-anagrams takes a list of strings and returns a list of strings that are anagrams of each other.\n; Anagrams are grouped by their preprocessed keys (sorted lowercase letters).\n; Only groups with more than one word are included in the result.\n(defun find-anagrams (words)\n  (let ((anagram-groups (make-hash-table :test 'equal)))\n    (dolist (word words)\n      (let ((key (preprocess word)))\n        (push word (gethash key anagram-groups))))\n    (let ((result '()))\n      (maphash (lambda (key group)\n                 (declare (ignore key))\n                 (when (> (length group) 1)\n                   (setf result (append result group))))\n               anagram-groups)\n      result)))", "test_cases": "", "test_case_results": "Input: (listen silent enlist hello world)\nAnagrams: (enlist silent listen)\nInput: (debitcard badcredit elvis lives money)\nAnagrams: (badcredit debitcard lives elvis)\nInput: (a b c d e)\nAnagrams: NIL", "task_id": 26737, "assertions": "(defpackage :anagram-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :anagram-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '(\"listen\" \"silent\" \"enlist\" \"hello\" \"world\"))\n        (test-case-2 '(\"debitcard\" \"badcredit\" \"elvis\" \"lives\" \"money\"))\n        (test-case-3 '(\"a\" \"b\" \"c\" \"d\" \"e\")))\n    \n    (assert (equal (cl-user:find-anagrams test-case-1) \n                   '(\"enlist\" \"silent\" \"listen\"))\n            () \"First test case failed\")\n    \n    (assert (equal (cl-user:find-anagrams test-case-2) \n                   '(\"badcredit\" \"debitcard\" \"lives\" \"elvis\"))\n            () \"Second test case failed\")\n    \n    (assert (null (cl-user:find-anagrams test-case-3))\n            () \"Third test case failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :anagram-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :anagram-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '(\"listen\" \"silent\" \"enlist\" \"hello\" \"world\"))\n        (test-case-2 '(\"debitcard\" \"badcredit\" \"elvis\" \"lives\" \"money\"))\n        (test-case-3 '(\"a\" \"b\" \"c\" \"d\" \"e\")))\n    \n    (assert (equal (cl-user:find-anagrams test-case-1) \n                   '(\"enlist\" \"silent\" \"listen\"))\n            () \"First test case failed\")\n    \n    (assert (equal (cl-user:find-anagrams test-case-2) \n                   '(\"badcredit\" \"debitcard\" \"lives\" \"elvis\"))\n            () \"Second test case failed\")\n    \n    (assert (null (cl-user:find-anagrams test-case-3))\n            () \"Third test case failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "find-anagrams"}, "all_code": "(defpackage :anagram-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :anagram-test)\n\n(defun preprocess (word)\n  (let* ((lower-word (string-downcase word))\n         (cleaned-word (remove-if-not #'alpha-char-p lower-word)))\n    (sort (copy-seq cleaned-word) #'char<)))\n\n; find-anagrams takes a list of strings and returns a list of strings that are anagrams of each other.\n; Anagrams are grouped by their preprocessed keys (sorted lowercase letters).\n; Only groups with more than one word are included in the result.\n(defun find-anagrams (words)\n  (let ((anagram-groups (make-hash-table :test 'equal)))\n    (dolist (word words)\n      (let ((key (preprocess word)))\n        (push word (gethash key anagram-groups))))\n    (let ((result '()))\n      (maphash (lambda (key group)\n                 (declare (ignore key))\n                 (when (> (length group) 1)\n                   (setf result (append result group))))\n               anagram-groups)\n      result)))\n\n\n(defun run-tests ()\n  (let ((test-case-1 '(\"listen\" \"silent\" \"enlist\" \"hello\" \"world\"))\n        (test-case-2 '(\"debitcard\" \"badcredit\" \"elvis\" \"lives\" \"money\"))\n        (test-case-3 '(\"a\" \"b\" \"c\" \"d\" \"e\")))\n    \n    (assert (equal (find-anagrams test-case-1) \n                   '(\"enlist\" \"silent\" \"listen\"))\n            () \"First test case failed\")\n    \n    (assert (equal (find-anagrams test-case-2) \n                   '(\"badcredit\" \"debitcard\" \"lives\" \"elvis\"))\n            () \"Second test case failed\")\n    \n    (assert (null (find-anagrams test-case-3))\n            () \"Third test case failed\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; This function generates all permutations of a list.\n;;; It is used to generate all possible paths for the traveling salesman problem.\n(defun permutations (lst)\n  (if (null lst)\n      (list nil)\n      (loop for element in lst\n            append (mapcar (lambda (perm) (cons element perm))\n                          (permutations (remove element lst :count 1))))))\n\n;;; minimum-travel-cost calculates the minimum cost to travel all cities and return to the starting city.\n;;; It uses permutations to explore all possible paths and finds the one with the minimum cost.\n;;; The first city is assumed to be the starting point (city 0).\n;;; The cost matrix is a 2D list where costs[i][j] represents the cost from city i to city j.\n(defun minimum-travel-cost (n costs)\n  (let ((cities (loop for i from 0 below n collect i))\n        (min-cost most-positive-fixnum))\n    (dolist (perm (permutations cities))\n      (when (eql (first perm) 0) ; Assuming city 0 as the starting point\n        (let ((current-cost 0))\n          (loop for i from 0 below (1- n)\n                do (incf current-cost (nth (nth i perm) (nth (nth (1+ i) perm) costs))))\n          (incf current-cost (nth (nth (1- n) perm) (nth (first perm) costs))) ; Return to starting city\n          (when (< current-cost min-cost)\n            (setf min-cost current-cost)))))\n    min-cost))", "test_cases": "", "test_case_results": "Input: 4 cities, Cost matrix: ((0 10 15 20) (10 0 35 25) (15 35 0 30)\n                               (20 25 30 0))\nMinimum travel cost: 80\nInput: 3 cities, Cost matrix: ((0 1 2) (1 0 3) (2 3 0))\nMinimum travel cost: 6", "task_id": 26546, "assertions": "(defpackage :traveling-salesman-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :traveling-salesman-test)\n\n(defun run-tests ()\n  ;; Test case 1: 4 cities\n  (assert (= (minimum-travel-cost 4 '((0 10 15 20)\n                                     (10 0 35 25)\n                                     (15 35 0 30)\n                                     (20 25 30 0)))\n             80)\n            () \"Test case 1 failed: Expected minimum cost 80\")\n  \n  ;; Test case 2: 3 cities\n  (assert (= (minimum-travel-cost 3 '((0 1 2)\n                                     (1 0 3)\n                                     (2 3 0)))\n             6)\n            () \"Test case 2 failed: Expected minimum cost 6\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :traveling-salesman-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :traveling-salesman-test)\n\n(defun run-tests ()\n  ;; Test case 1: 4 cities\n  (assert (= (minimum-travel-cost 4 '((0 10 15 20)\n                                     (10 0 35 25)\n                                     (15 35 0 30)\n                                     (20 25 30 0)))\n             80)\n            () \"Test case 1 failed: Expected minimum cost 80\")\n  \n  ;; Test case 2: 3 cities\n  (assert (= (minimum-travel-cost 3 '((0 1 2)\n                                     (1 0 3)\n                                     (2 3 0)))\n             6)\n            () \"Test case 2 failed: Expected minimum cost 6\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "minimum-travel-cost"}, "all_code": "(defpackage :traveling-salesman-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :traveling-salesman-test)\n\n(defun permutations (lst)\n  (if (null lst)\n      (list nil)\n      (loop for element in lst\n            append (mapcar (lambda (perm) (cons element perm))\n                          (permutations (remove element lst :count 1))))))\n\n;;; minimum-travel-cost calculates the minimum cost to travel all cities and return to the starting city.\n;;; It uses permutations to explore all possible paths and finds the one with the minimum cost.\n;;; The first city is assumed to be the starting point (city 0).\n;;; The cost matrix is a 2D list where costs[i][j] represents the cost from city i to city j.\n(defun minimum-travel-cost (n costs)\n  (let ((cities (loop for i from 0 below n collect i))\n        (min-cost most-positive-fixnum))\n    (dolist (perm (permutations cities))\n      (when (eql (first perm) 0) ; Assuming city 0 as the starting point\n        (let ((current-cost 0))\n          (loop for i from 0 below (1- n)\n                do (incf current-cost (nth (nth i perm) (nth (nth (1+ i) perm) costs))))\n          (incf current-cost (nth (nth (1- n) perm) (nth (first perm) costs))) ; Return to starting city\n          (when (< current-cost min-cost)\n            (setf min-cost current-cost)))))\n    min-cost))\n\n\n(defun run-tests ()\n  ;; Test case 1: 4 cities\n  (assert (= (minimum-travel-cost 4 '((0 10 15 20)\n                                     (10 0 35 25)\n                                     (15 35 0 30)\n                                     (20 25 30 0)))\n             80)\n            () \"Test case 1 failed: Expected minimum cost 80\")\n  \n  ;; Test case 2: 3 cities\n  (assert (= (minimum-travel-cost 3 '((0 1 2)\n                                     (1 0 3)\n                                     (2 3 0)))\n             6)\n            () \"Test case 2 failed: Expected minimum cost 6\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; max-depth calculates the maximum depth of a binary tree represented as a nested list.\n; The tree is structured such that each node is a list of its children.\n; If the input is not a list or is an empty list, it is considered a leaf node with depth 0.\n(defun max-depth (tree)\n  (if (and (listp tree) tree)\n      (1+ (apply #'max (mapcar #'max-depth tree)))\n      0))", "test_cases": "", "test_case_results": "Tree: NIL\nMax Depth: 0\n\nTree: (1)\nMax Depth: 1\n\nTree: (1 (2) (3))\nMax Depth: 2\n\nTree: (1 (2 (3 (4))) (5))\nMax Depth: 4\n\nTree: (1 (2 (3) (4 (5 (6)))) (7 (8)))\nMax Depth: 5", "task_id": 7422, "assertions": "(defpackage :max-depth-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :max-depth-test)\n\n(defun run-tests ()\n  (assert (= (max-depth nil) 0) () \"Empty tree should have depth 0\")\n  (assert (= (max-depth '(1)) 1) () \"Single node tree should have depth 1\")\n  (assert (= (max-depth '(1 (2) (3))) 2) () \"Two-level tree should have depth 2\")\n  (assert (= (max-depth '(1 (2 (3 (4))) (5))) 4) () \"Four-level tree should have depth 4\")\n  (assert (= (max-depth '(1 (2 (3) (4 (5 (6)))) (7 (8)))) 5) () \"Complex tree should have depth 5\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :max-depth-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :max-depth-test)\n\n(defun run-tests ()\n  (assert (= (max-depth nil) 0) () \"Empty tree should have depth 0\")\n  (assert (= (max-depth '(1)) 1) () \"Single node tree should have depth 1\")\n  (assert (= (max-depth '(1 (2) (3))) 2) () \"Two-level tree should have depth 2\")\n  (assert (= (max-depth '(1 (2 (3 (4))) (5))) 4) () \"Four-level tree should have depth 4\")\n  (assert (= (max-depth '(1 (2 (3) (4 (5 (6)))) (7 (8)))) 5) () \"Complex tree should have depth 5\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "max-depth"}, "all_code": "(defpackage :max-depth-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :max-depth-test)\n\n(defun max-depth (tree)\n  (if (and (listp tree) tree)\n      (1+ (apply #'max (mapcar #'max-depth tree)))\n      0))\n\n\n(defun run-tests ()\n  (assert (= (max-depth nil) 0) () \"Empty tree should have depth 0\")\n  (assert (= (max-depth '(1)) 1) () \"Single node tree should have depth 1\")\n  (assert (= (max-depth '(1 (2) (3))) 2) () \"Two-level tree should have depth 2\")\n  (assert (= (max-depth '(1 (2 (3 (4))) (5))) 4) () \"Four-level tree should have depth 4\")\n  (assert (= (max-depth '(1 (2 (3) (4 (5 (6)))) (7 (8)))) 5) () \"Complex tree should have depth 5\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; max-width-ramp calculates the maximum width of a ramp in a list of numbers.\n;; A ramp is defined as a pair of indices (i, j) where i <= j and arr[i] <= arr[j].\n;; The width of such a ramp is j - i.\n;; The function uses a stack to efficiently find the maximum width ramp.\n(defun max-width-ramp (arr)\n  (let* ((n (length arr))\n         (stack '())\n         (max-width 0))\n    ;; Build a stack of indices of elements in decreasing order\n    (dotimes (i n)\n      (when (or (null stack) (> (nth (car stack) arr) (nth i arr)))\n        (push i stack)))\n    ;; Traverse from the end of the list to find the maximum width ramp\n    (loop for j from (1- n) downto 0 do\n      (loop while (and stack (<= (nth (car stack) arr) (nth j arr))) do\n        (setf max-width (max max-width (- j (pop stack))))))\n    max-width))", "test_cases": "", "test_case_results": "Input: (6 0 8 2 1 5)\nResult: 4\n\nInput: (9 8 1 0 1 9 4)\nResult: 5\n\nInput: (1 2 3 4)\nResult: 3\n\nInput: (4 3 2 1)\nResult: 0\n\nInput: (1 1 1 1)\nResult: 3", "task_id": 25300, "assertions": "(defpackage :max-width-ramp-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :max-width-ramp-test)\n\n(defun run-tests ()\n  (assert (= (max-width-ramp '(6 0 8 2 1 5)) 4) () \"Test case 1 failed\")\n  (assert (= (max-width-ramp '(9 8 1 0 1 9 4)) 5) () \"Test case 2 failed\")\n  (assert (= (max-width-ramp '(1 2 3 4)) 3) () \"Test case 3 failed\")\n  (assert (= (max-width-ramp '(4 3 2 1)) 0) () \"Test case 4 failed\")\n  (assert (= (max-width-ramp '(1 1 1 1)) 3) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :max-width-ramp-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :max-width-ramp-test)\n\n(defun run-tests ()\n  (assert (= (max-width-ramp '(6 0 8 2 1 5)) 4) () \"Test case 1 failed\")\n  (assert (= (max-width-ramp '(9 8 1 0 1 9 4)) 5) () \"Test case 2 failed\")\n  (assert (= (max-width-ramp '(1 2 3 4)) 3) () \"Test case 3 failed\")\n  (assert (= (max-width-ramp '(4 3 2 1)) 0) () \"Test case 4 failed\")\n  (assert (= (max-width-ramp '(1 1 1 1)) 3) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "max-width-ramp"}, "all_code": "(defpackage :max-width-ramp-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :max-width-ramp-test)\n\n(defun max-width-ramp (arr)\n  (let* ((n (length arr))\n         (stack '())\n         (max-width 0))\n    ;; Build a stack of indices of elements in decreasing order\n    (dotimes (i n)\n      (when (or (null stack) (> (nth (car stack) arr) (nth i arr)))\n        (push i stack)))\n    ;; Traverse from the end of the list to find the maximum width ramp\n    (loop for j from (1- n) downto 0 do\n      (loop while (and stack (<= (nth (car stack) arr) (nth j arr))) do\n        (setf max-width (max max-width (- j (pop stack))))))\n    max-width))\n\n\n(defun run-tests ()\n  (assert (= (max-width-ramp '(6 0 8 2 1 5)) 4) () \"Test case 1 failed\")\n  (assert (= (max-width-ramp '(9 8 1 0 1 9 4)) 5) () \"Test case 2 failed\")\n  (assert (= (max-width-ramp '(1 2 3 4)) 3) () \"Test case 3 failed\")\n  (assert (= (max-width-ramp '(4 3 2 1)) 0) () \"Test case 4 failed\")\n  (assert (= (max-width-ramp '(1 1 1 1)) 3) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :quadratic-solver\n  (:use :cl)\n  (:export :solve-quadratic))\n\n(in-package :quadratic-solver)\n\n(defun solve-quadratic (a b c)\n  (if (zerop a)\n      (if (zerop b)\n          (if (zerop c)\n              \"Infinite solutions\"\n              \"No solution\")\n          (/ (- c) b))\n      (let ((discriminant (- (* b b) (* 4 a c))))\n        (cond\n          ((> discriminant 0)\n           (let ((root1 (/ (+ (- b) (sqrt discriminant)) (* 2 a)))\n                 (root2 (/ (- (- b) (sqrt discriminant)) (* 2 a))))\n             (values root1 root2)))\n          ((zerop discriminant)\n           (/ (- b) (* 2 a)))\n          (t\n           (let ((real-part (/ (- b) (* 2 a)))\n                 (imaginary-part (/ (sqrt (- discriminant)) (* 2 a))))\n             (complex real-part imaginary-part)))))))", "test_cases": "", "test_case_results": "Equation: 1x^2 + -3x + 2 = 0\nSolution: 2.0\nEquation: 1x^2 + 2x + 1 = 0\nSolution: -1\nEquation: 1x^2 + 0x + 1 = 0\nSolution: #C(0.0 1.0)\nEquation: 0x^2 + 2x + 4 = 0\nSolution: -2\nEquation: 0x^2 + 0x + 1 = 0\nSolution: No solution\nEquation: 0x^2 + 0x + 0 = 0\nSolution: Infinite solutions", "task_id": 1073, "assertions": "(defpackage :quadratic-solver-test\n  (:use :cl :quadratic-solver)\n  (:export :run-tests))\n\n(in-package :quadratic-solver-test)\n\n(defun run-tests ()\n  ;; Test quadratic equation with two real roots\n  (multiple-value-bind (root1 root2) (solve-quadratic 1 -3 2)\n    (assert (and (= root1 2.0) (= root2 1.0)) () \"x²-3x+2=0 should have roots 2.0 and 1.0\"))\n  \n  ;; Test quadratic equation with one real root\n  (assert (= (solve-quadratic 1 2 1) -1) () \"x²+2x+1=0 should have root -1\")\n  \n  ;; Test quadratic equation with complex roots\n  (let ((result (solve-quadratic 1 0 1)))\n    (assert (and (= (realpart result) 0.0) (= (imagpart result) 1.0)) () \"x²+1=0 should have complex roots 0±1i\"))\n  \n  ;; Test linear equation\n  (assert (= (solve-quadratic 0 2 4) -2) () \"2x+4=0 should have root -2\")\n  \n  ;; Test no solution case\n  (assert (string= (solve-quadratic 0 0 1) \"No solution\") () \"0x+1=0 should have no solution\")\n  \n  ;; Test infinite solutions case\n  (assert (string= (solve-quadratic 0 0 0) \"Infinite solutions\") () \"0x+0=0 should have infinite solutions\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :quadratic-solver-test\n  (:use :cl :quadratic-solver)\n  (:export :run-tests))\n\n(in-package :quadratic-solver-test)\n\n(defun run-tests ()\n  ;; Test quadratic equation with two real roots\n  (multiple-value-bind (root1 root2) (solve-quadratic 1 -3 2)\n    (assert (and (= root1 2.0) (= root2 1.0)) () \"x²-3x+2=0 should have roots 2.0 and 1.0\"))\n  \n  ;; Test quadratic equation with one real root\n  (assert (= (solve-quadratic 1 2 1) -1) () \"x²+2x+1=0 should have root -1\")\n  \n  ;; Test quadratic equation with complex roots\n  (let ((result (solve-quadratic 1 0 1)))\n    (assert (and (= (realpart result) 0.0) (= (imagpart result) 1.0)) () \"x²+1=0 should have complex roots 0±1i\"))\n  \n  ;; Test linear equation\n  (assert (= (solve-quadratic 0 2 4) -2) () \"2x+4=0 should have root -2\")\n  \n  ;; Test no solution case\n  (assert (string= (solve-quadratic 0 0 1) \"No solution\") () \"0x+1=0 should have no solution\")\n  \n  ;; Test infinite solutions case\n  (assert (string= (solve-quadratic 0 0 0) \"Infinite solutions\") () \"0x+0=0 should have infinite solutions\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "solve-quadratic"}, "all_code": "(defpackage :quadratic-solver-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :quadratic-solver-test)\n\n(defun solve-quadratic (a b c)\n  (if (zerop a)\n      (if (zerop b)\n          (if (zerop c)\n              \"Infinite solutions\"\n              \"No solution\")\n          (/ (- c) b))\n      (let ((discriminant (- (* b b) (* 4 a c))))\n        (cond\n          ((> discriminant 0)\n           (let ((root1 (/ (+ (- b) (sqrt discriminant)) (* 2 a)))\n                 (root2 (/ (- (- b) (sqrt discriminant)) (* 2 a))))\n             (values root1 root2)))\n          ((zerop discriminant)\n           (/ (- b) (* 2 a)))\n          (t\n           (let ((real-part (/ (- b) (* 2 a)))\n                 (imaginary-part (/ (sqrt (- discriminant)) (* 2 a))))\n             (complex real-part imaginary-part)))))))\n\n\n(defun run-tests ()\n  ;; Test quadratic equation with two real roots\n  (multiple-value-bind (root1 root2) (solve-quadratic 1 -3 2)\n    (assert (and (= root1 2.0) (= root2 1.0)) () \"x²-3x+2=0 should have roots 2.0 and 1.0\"))\n  \n  ;; Test quadratic equation with one real root\n  (assert (= (solve-quadratic 1 2 1) -1) () \"x²+2x+1=0 should have root -1\")\n  \n  ;; Test quadratic equation with complex roots\n  (let ((result (solve-quadratic 1 0 1)))\n    (assert (and (= (realpart result) 0.0) (= (imagpart result) 1.0)) () \"x²+1=0 should have complex roots 0±1i\"))\n  \n  ;; Test linear equation\n  (assert (= (solve-quadratic 0 2 4) -2) () \"2x+4=0 should have root -2\")\n  \n  ;; Test no solution case\n  (assert (string= (solve-quadratic 0 0 1) \"No solution\") () \"0x+1=0 should have no solution\")\n  \n  ;; Test infinite solutions case\n  (assert (string= (solve-quadratic 0 0 0) \"Infinite solutions\") () \"0x+0=0 should have infinite solutions\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :palindrome-utils\n  (:use :cl)\n  (:export :find-palindrome))\n\n(in-package :palindrome-utils)\n\n(defun find-palindrome (s)\n  (let ((n (length s)))\n    (if (zerop n)\n        \"\"\n        (let ((start 0)\n              (max-length 1))\n          (loop for i from 1 below n do\n            ; Check for even length palindromes\n            (let ((low (1- i))\n                  (high i))\n              (loop while (and (>= low 0) (< high n) (char= (char s low) (char s high)))\n                    do (when (> (- high low 1) max-length)\n                         (setf start low\n                               max-length (- high low 1)))\n                    (decf low)\n                    (incf high)))\n            ; Check for odd length palindromes\n            (let ((low (1- i))\n                  (high (1+ i)))\n              (loop while (and (>= low 0) (< high n) (char= (char s low) (char s high)))\n                    do (when (> (- high low 1) max-length)\n                         (setf start low\n                               max-length (- high low 1)))\n                    (decf low)\n                    (incf high))))\n          (subseq s start (+ start max-length))))))", "test_cases": "", "test_case_results": "Input: babad\nLongest palindromic substring: b\nInput: cbbd\nLongest palindromic substring: c\nInput: a\nLongest palindromic substring: a\nInput: ac\nLongest palindromic substring: a\nInput: \nLongest palindromic substring:", "task_id": 12763, "assertions": "(defpackage :palindrome-utils-test\n  (:use :cl :palindrome-utils)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun run-tests ()\n  (assert (string= (find-palindrome \"babad\") \"bab\") () \"Test case 'babad' failed\")\n  (assert (string= (find-palindrome \"cbbd\") \"bb\") () \"Test case 'cbbd' failed\")\n  (assert (string= (find-palindrome \"a\") \"a\") () \"Test case 'a' failed\")\n  (assert (string= (find-palindrome \"ac\") \"a\") () \"Test case 'ac' failed\")\n  (assert (string= (find-palindrome \"\") \"\") () \"Test case empty string failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :palindrome-utils-test\n  (:use :cl :palindrome-utils)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun run-tests ()\n  (assert (string= (find-palindrome \"babad\") \"bab\") () \"Test case 'babad' failed\")\n  (assert (string= (find-palindrome \"cbbd\") \"bb\") () \"Test case 'cbbd' failed\")\n  (assert (string= (find-palindrome \"a\") \"a\") () \"Test case 'a' failed\")\n  (assert (string= (find-palindrome \"ac\") \"a\") () \"Test case 'ac' failed\")\n  (assert (string= (find-palindrome \"\") \"\") () \"Test case empty string failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-palindrome"}, "all_code": "(defpackage :palindrome-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun find-palindrome (s)\n  (let ((n (length s)))\n    (if (zerop n)\n        \"\"\n        (let ((start 0)\n              (max-length 1))\n          (loop for i from 1 below n do\n            ; Check for even length palindromes\n            (let ((low (1- i))\n                  (high i))\n              (loop while (and (>= low 0) (< high n) (char= (char s low) (char s high)))\n                    do (when (> (- high low 1) max-length)\n                         (setf start low\n                               max-length (- high low 1)))\n                    (decf low)\n                    (incf high)))\n            ; Check for odd length palindromes\n            (let ((low (1- i))\n                  (high (1+ i)))\n              (loop while (and (>= low 0) (< high n) (char= (char s low) (char s high)))\n                    do (when (> (- high low 1) max-length)\n                         (setf start low\n                               max-length (- high low 1)))\n                    (decf low)\n                    (incf high))))\n          (subseq s start (+ start max-length))))))\n\n\n(defun run-tests ()\n  (assert (string= (find-palindrome \"babad\") \"bab\") () \"Test case 'babad' failed\")\n  (assert (string= (find-palindrome \"cbbd\") \"bb\") () \"Test case 'cbbd' failed\")\n  (assert (string= (find-palindrome \"a\") \"a\") () \"Test case 'a' failed\")\n  (assert (string= (find-palindrome \"ac\") \"a\") () \"Test case 'ac' failed\")\n  (assert (string= (find-palindrome \"\") \"\") () \"Test case empty string failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(defpackage :palindrome-utils\n  (:use :cl)\n  (:export :lcs :min-insertions))\n\n(in-package :palindrome-utils)\n\n(defun lcs (X Y)\n  (let* ((m (length X))\n         (n (length Y))\n         (L (make-array (list (1+ m) (1+ n)) :initial-element 0)))\n    (loop for i from 0 to m do\n      (loop for j from 0 to n do\n        (cond\n          ((or (zerop i) (zerop j)) (setf (aref L i j) 0))\n          ((char= (char X (1- i)) (char Y (1- j)))\n           (setf (aref L i j) (1+ (aref L (1- i) (1- j)))))\n          (t (setf (aref L i j) (max (aref L (1- i) j) (aref L i (1- j))))))))\n    (aref L m n)))\n\n(defun min-insertions (s)\n  (let* ((rev-s (reverse s))\n         (lcs-length (lcs s rev-s)))\n    (- (length s) lcs-length)))", "test_cases": "", "test_case_results": "Input: abca\nResult: 1\n\nInput: abcd\nResult: 3\n\nInput: a\nResult: 0\n\nInput: aa\nResult: 0\n\nInput: abcba\nResult: 0", "task_id": 14540, "assertions": "(defpackage :palindrome-utils-test\n  (:use :cl :palindrome-utils)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-insertions \"abca\") 1) () \"abca should need 1 insertion\")\n  (assert (= (min-insertions \"abcd\") 3) () \"abcd should need 3 insertions\")\n  (assert (= (min-insertions \"a\") 0) () \"single character should need 0 insertions\")\n  (assert (= (min-insertions \"aa\") 0) () \"palindrome should need 0 insertions\")\n  (assert (= (min-insertions \"abcba\") 0) () \"palindrome should need 0 insertions\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :palindrome-utils-test\n  (:use :cl :palindrome-utils)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-insertions \"abca\") 1) () \"abca should need 1 insertion\")\n  (assert (= (min-insertions \"abcd\") 3) () \"abcd should need 3 insertions\")\n  (assert (= (min-insertions \"a\") 0) () \"single character should need 0 insertions\")\n  (assert (= (min-insertions \"aa\") 0) () \"palindrome should need 0 insertions\")\n  (assert (= (min-insertions \"abcba\") 0) () \"palindrome should need 0 insertions\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-insertions"}, "all_code": "(defpackage :palindrome-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :palindrome-utils-test)\n\n(defun lcs (X Y)\n  (let* ((m (length X))\n         (n (length Y))\n         (L (make-array (list (1+ m) (1+ n)) :initial-element 0)))\n    (loop for i from 0 to m do\n      (loop for j from 0 to n do\n        (cond\n          ((or (zerop i) (zerop j)) (setf (aref L i j) 0))\n          ((char= (char X (1- i)) (char Y (1- j)))\n           (setf (aref L i j) (1+ (aref L (1- i) (1- j)))))\n          (t (setf (aref L i j) (max (aref L (1- i) j) (aref L i (1- j))))))))\n    (aref L m n)))\n(defun min-insertions (s)\n  (let* ((rev-s (reverse s))\n         (lcs-length (lcs s rev-s)))\n    (- (length s) lcs-length)))\n\n\n(defun run-tests ()\n  (assert (= (min-insertions \"abca\") 1) () \"abca should need 1 insertion\")\n  (assert (= (min-insertions \"abcd\") 3) () \"abcd should need 3 insertions\")\n  (assert (= (min-insertions \"a\") 0) () \"single character should need 0 insertions\")\n  (assert (= (min-insertions \"aa\") 0) () \"palindrome should need 0 insertions\")\n  (assert (= (min-insertions \"abcba\") 0) () \"palindrome should need 0 insertions\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :max-points-utils\n  (:use :cl)\n  (:export :max-points))\n\n(in-package :max-points-utils)\n\n;; max-points calculates the maximum possible points a participant can earn by solving problems in an optimal order.\n;; The optimal order is determined by solving key problems in the specified order and other problems in any order.\n;;\n;; Parameters:\n;;   n - integer, total number of problems\n;;   m - integer, number of key problems\n;;   points - list of integers, points for each problem\n;;   key-problems - list of integers, 1-based indices of key problems in the specified order\n;;\n;; Returns:\n;;   integer, the maximum possible points\n(defun max-points (n m points key-problems)\n  (let ((max-points 0)\n        (key-index 0)\n        ;; Convert 1-based key-problems to 0-based\n        (key-problems (mapcar #'1- key-problems)))\n    (dotimes (i n max-points)\n      (if (and (< key-index m) (= i (nth key-index key-problems)))\n          (progn\n            (incf max-points (nth i points))\n            (incf key-index))\n          (incf max-points (nth i points))))))", "test_cases": "", "test_case_results": "Input: n=5, m=3, points=(10 20 30 40 50), key-problems=(1 3 5)\nMax points: 150\nInput: n=4, m=2, points=(5 10 15 20), key-problems=(2 4)\nMax points: 50\nInput: n=3, m=1, points=(1 2 3), key-problems=(2)\nMax points: 6\nInput: n=1, m=1, points=(100), key-problems=(1)\nMax points: 100", "task_id": 12286, "assertions": "(defpackage :max-points-test\n  (:use :cl :max-points-utils)\n  (:export :run-tests))\n\n(in-package :max-points-test)\n\n(defun run-tests ()\n  (assert (= (max-points 5 3 '(10 20 30 40 50) '(1 3 5)) 150) () \n          \"Test case 1 failed: Expected 150\")\n  (assert (= (max-points 4 2 '(5 10 15 20) '(2 4)) 50) () \n          \"Test case 2 failed: Expected 50\")\n  (assert (= (max-points 3 1 '(1 2 3) '(2)) 6) () \n          \"Test case 3 failed: Expected 6\")\n  (assert (= (max-points 1 1 '(100) '(1)) 100) () \n          \"Test case 4 failed: Expected 100\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :max-points-test\n  (:use :cl :max-points-utils)\n  (:export :run-tests))\n\n(in-package :max-points-test)\n\n(defun run-tests ()\n  (assert (= (max-points 5 3 '(10 20 30 40 50) '(1 3 5)) 150) () \n          \"Test case 1 failed: Expected 150\")\n  (assert (= (max-points 4 2 '(5 10 15 20) '(2 4)) 50) () \n          \"Test case 2 failed: Expected 50\")\n  (assert (= (max-points 3 1 '(1 2 3) '(2)) 6) () \n          \"Test case 3 failed: Expected 6\")\n  (assert (= (max-points 1 1 '(100) '(1)) 100) () \n          \"Test case 4 failed: Expected 100\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "max-points"}, "all_code": "(defpackage :max-points-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :max-points-test)\n\n(defun max-points (n m points key-problems)\n  (let ((max-points 0)\n        (key-index 0)\n        ;; Convert 1-based key-problems to 0-based\n        (key-problems (mapcar #'1- key-problems)))\n    (dotimes (i n max-points)\n      (if (and (< key-index m) (= i (nth key-index key-problems)))\n          (progn\n            (incf max-points (nth i points))\n            (incf key-index))\n          (incf max-points (nth i points))))))\n\n\n(defun run-tests ()\n  (assert (= (max-points 5 3 '(10 20 30 40 50) '(1 3 5)) 150) () \n          \"Test case 1 failed: Expected 150\")\n  (assert (= (max-points 4 2 '(5 10 15 20) '(2 4)) 50) () \n          \"Test case 2 failed: Expected 50\")\n  (assert (= (max-points 3 1 '(1 2 3) '(2)) 6) () \n          \"Test case 3 failed: Expected 6\")\n  (assert (= (max-points 1 1 '(100) '(1)) 100) () \n          \"Test case 4 failed: Expected 100\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; generate-matrix generates an n x n matrix filled with random integers between min-value and max-value.\n;; It uses Common Lisp's built-in random function to generate the values.\n(defun generate-matrix (n min-value max-value)\n  (loop repeat n\n        collect (loop repeat n\n                      collect (+ min-value (random (- max-value min-value -1))))))\n\n;; extract-diagonal extracts the diagonal elements starting at (i, j) in the matrix.\n;; The diagonal is extracted by incrementing both row and column indices until they exceed the matrix size.\n(defun extract-diagonal (matrix i j)\n  (let ((n (length matrix))\n        (diagonal '()))\n    (loop while (and (< i n) (< j n))\n          do (push (nth j (nth i matrix)) diagonal)\n             (incf i)\n             (incf j))\n    (reverse diagonal)))\n\n;; replace-diagonal replaces the diagonal elements starting at (i, j) in the matrix with the sorted values.\n;; The values are taken from the sorted list and placed back into the matrix along the diagonal.\n(defun replace-diagonal (matrix i j sorted-values)\n  (let ((n (length matrix))\n        (idx 0))\n    (loop while (and (< i n) (< j n))\n          do (setf (nth j (nth i matrix)) (nth idx sorted-values))\n             (incf i)\n             (incf j)\n             (incf idx)))\n  matrix)\n\n;; sort-diagonal sorts the diagonal starting at (i, j) in the matrix.\n;; It extracts the diagonal, sorts it, and then replaces it back into the matrix.\n(defun sort-diagonal (matrix i j)\n  (let* ((diagonal (extract-diagonal matrix i j))\n         (sorted-diagonal (sort diagonal #'<)))\n    (replace-diagonal matrix i j sorted-diagonal)))\n\n;; generate-and-sort-matrix generates an n x n matrix with random integers between min-value and max-value,\n;; and then sorts each diagonal in non-decreasing order.\n;; It first generates the matrix, then sorts diagonals starting from the first row and first column.\n(defun generate-and-sort-matrix (n min-value max-value)\n  (let ((matrix (generate-matrix n min-value max-value)))\n    ;; Sort diagonals starting from each element in the first row\n    (loop for j from 0 below n\n          do (sort-diagonal matrix 0 j))\n    ;; Sort diagonals starting from each element in the first column (excluding [0,0])\n    (loop for i from 1 below n\n          do (sort-diagonal matrix i 0))\n    matrix))", "test_cases": "", "test_case_results": "Input: n=3, min-value=1, max-value=10\nResult: ((4 6 6) (1 7 10) (5 2 8))\nInput: n=4, min-value=0, max-value=5\nResult: ((2 1 2 1) (1 3 2 2) (0 1 4 3) (4 5 1 4))\nInput: n=2, min-value=100, max-value=200\nResult: ((143 107) (145 146))", "task_id": 28285, "assertions": "(defpackage :matrix-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :matrix-test)\n\n(defun run-tests ()\n  ;; Test 1: Verify diagonal sorting for 3x3 matrix\n  (let ((matrix (generate-and-sort-matrix 3 1 10)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 2: Verify diagonal sorting for 4x4 matrix\n  (let ((matrix (generate-and-sort-matrix 4 0 5)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 3: Verify diagonal sorting for 2x2 matrix\n  (let ((matrix (generate-and-sort-matrix 2 100 200)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"Upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"Lower diagonal should be sorted\"))\n\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :matrix-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :matrix-test)\n\n(defun run-tests ()\n  ;; Test 1: Verify diagonal sorting for 3x3 matrix\n  (let ((matrix (generate-and-sort-matrix 3 1 10)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 2: Verify diagonal sorting for 4x4 matrix\n  (let ((matrix (generate-and-sort-matrix 4 0 5)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 3: Verify diagonal sorting for 2x2 matrix\n  (let ((matrix (generate-and-sort-matrix 2 100 200)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"Upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"Lower diagonal should be sorted\"))\n\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "generate-and-sort-matrix"}, "all_code": "(defpackage :matrix-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :matrix-test)\n\n(defun generate-matrix (n min-value max-value)\n  (loop repeat n\n        collect (loop repeat n\n                      collect (+ min-value (random (- max-value min-value -1))))))\n\n;; extract-diagonal extracts the diagonal elements starting at (i, j) in the matrix.\n;; The diagonal is extracted by incrementing both row and column indices until they exceed the matrix size.\n(defun extract-diagonal (matrix i j)\n  (let ((n (length matrix))\n        (diagonal '()))\n    (loop while (and (< i n) (< j n))\n          do (push (nth j (nth i matrix)) diagonal)\n             (incf i)\n             (incf j))\n    (reverse diagonal)))\n\n;; replace-diagonal replaces the diagonal elements starting at (i, j) in the matrix with the sorted values.\n;; The values are taken from the sorted list and placed back into the matrix along the diagonal.\n(defun replace-diagonal (matrix i j sorted-values)\n  (let ((n (length matrix))\n        (idx 0))\n    (loop while (and (< i n) (< j n))\n          do (setf (nth j (nth i matrix)) (nth idx sorted-values))\n             (incf i)\n             (incf j)\n             (incf idx)))\n  matrix)\n\n;; sort-diagonal sorts the diagonal starting at (i, j) in the matrix.\n;; It extracts the diagonal, sorts it, and then replaces it back into the matrix.\n(defun sort-diagonal (matrix i j)\n  (let* ((diagonal (extract-diagonal matrix i j))\n         (sorted-diagonal (sort diagonal #'<)))\n    (replace-diagonal matrix i j sorted-diagonal)))\n\n;; generate-and-sort-matrix generates an n x n matrix with random integers between min-value and max-value,\n;; and then sorts each diagonal in non-decreasing order.\n;; It first generates the matrix, then sorts diagonals starting from the first row and first column.\n(defun generate-and-sort-matrix (n min-value max-value)\n  (let ((matrix (generate-matrix n min-value max-value)))\n    ;; Sort diagonals starting from each element in the first row\n    (loop for j from 0 below n\n          do (sort-diagonal matrix 0 j))\n    ;; Sort diagonals starting from each element in the first column (excluding [0,0])\n    (loop for i from 1 below n\n          do (sort-diagonal matrix i 0))\n    matrix))\n\n\n(defun run-tests ()\n  ;; Test 1: Verify diagonal sorting for 3x3 matrix\n  (let ((matrix (generate-and-sort-matrix 3 1 10)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 2: Verify diagonal sorting for 4x4 matrix\n  (let ((matrix (generate-and-sort-matrix 4 0 5)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"First upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"First lower diagonal should be sorted\"))\n\n  ;; Test 3: Verify diagonal sorting for 2x2 matrix\n  (let ((matrix (generate-and-sort-matrix 2 100 200)))\n    (assert (every #'<= (extract-diagonal matrix 0 0)) () \"Main diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 0 1)) () \"Upper diagonal should be sorted\")\n    (assert (every #'<= (extract-diagonal matrix 1 0)) () \"Lower diagonal should be sorted\"))\n\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :platform-calculator\n  (:use :cl)\n  (:export :convert-time-to-minutes :find-minimum-platforms))\n\n(in-package :platform-calculator)\n\n(defun convert-time-to-minutes (time)\n  (let* ((colon-pos (position #\\: time))\n         (hours (parse-integer (subseq time 0 colon-pos)))\n         (minutes (parse-integer (subseq time (1+ colon-pos)))))\n    (+ (* hours 60) minutes)))\n\n(defun find-minimum-platforms (arrivals departures)\n  (let* ((n (length arrivals))\n         (arrival-times (sort (mapcar #'convert-time-to-minutes arrivals) #'<))\n         (departure-times (sort (mapcar #'convert-time-to-minutes departures) #'<))\n         (platform-needed 0)\n         (max-platforms 0)\n         (i 0)\n         (j 0))\n    (loop while (and (< i n) (< j n)) do\n      (if (<= (nth i arrival-times) (nth j departure-times))\n          (progn\n            (incf platform-needed)\n            (setf max-platforms (max max-platforms platform-needed))\n            (incf i))\n          (progn\n            (decf platform-needed)\n            (incf j))))\n    max-platforms))", "test_cases": "", "test_case_results": "Arrivals: (09:00 09:40 09:50 11:00 15:00 18:00)\nDepartures: (09:10 12:00 11:20 11:30 19:00 20:00)\nMinimum platforms needed: 3\n\nArrivals: (10:00 10:20 10:30 10:40)\nDepartures: (10:10 10:25 10:35 10:45)\nMinimum platforms needed: 1\n\nArrivals: (00:00 23:59)\nDepartures: (00:01 00:02)\nMinimum platforms needed: 1", "task_id": 17149, "assertions": "(defpackage :platform-calculator-test\n  (:use :cl :platform-calculator)\n  (:export :run-tests))\n\n(in-package :platform-calculator-test)\n\n(defun run-tests ()\n  (assert (= (find-minimum-platforms '(\"09:00\" \"09:40\" \"09:50\" \"11:00\" \"15:00\" \"18:00\")\n                                     '(\"09:10\" \"12:00\" \"11:20\" \"11:30\" \"19:00\" \"20:00\")) \n             3)\n            () \"First test case should return 3 platforms\")\n  \n  (assert (= (find-minimum-platforms '(\"10:00\" \"10:20\" \"10:30\" \"10:40\")\n                                     '(\"10:10\" \"10:25\" \"10:35\" \"10:45\")) \n             1)\n            () \"Second test case should return 1 platform\")\n  \n  (assert (= (find-minimum-platforms '(\"00:00\" \"23:59\")\n                                     '(\"00:01\" \"00:02\")) \n             1)\n            () \"Third test case should return 1 platform\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :platform-calculator-test\n  (:use :cl :platform-calculator)\n  (:export :run-tests))\n\n(in-package :platform-calculator-test)\n\n(defun run-tests ()\n  (assert (= (find-minimum-platforms '(\"09:00\" \"09:40\" \"09:50\" \"11:00\" \"15:00\" \"18:00\")\n                                     '(\"09:10\" \"12:00\" \"11:20\" \"11:30\" \"19:00\" \"20:00\")) \n             3)\n            () \"First test case should return 3 platforms\")\n  \n  (assert (= (find-minimum-platforms '(\"10:00\" \"10:20\" \"10:30\" \"10:40\")\n                                     '(\"10:10\" \"10:25\" \"10:35\" \"10:45\")) \n             1)\n            () \"Second test case should return 1 platform\")\n  \n  (assert (= (find-minimum-platforms '(\"00:00\" \"23:59\")\n                                     '(\"00:01\" \"00:02\")) \n             1)\n            () \"Third test case should return 1 platform\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-minimum-platforms"}, "all_code": "(defpackage :platform-calculator-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :platform-calculator-test)\n\n(defun convert-time-to-minutes (time)\n  (let* ((colon-pos (position #\\: time))\n         (hours (parse-integer (subseq time 0 colon-pos)))\n         (minutes (parse-integer (subseq time (1+ colon-pos)))))\n    (+ (* hours 60) minutes)))\n(defun find-minimum-platforms (arrivals departures)\n  (let* ((n (length arrivals))\n         (arrival-times (sort (mapcar #'convert-time-to-minutes arrivals) #'<))\n         (departure-times (sort (mapcar #'convert-time-to-minutes departures) #'<))\n         (platform-needed 0)\n         (max-platforms 0)\n         (i 0)\n         (j 0))\n    (loop while (and (< i n) (< j n)) do\n      (if (<= (nth i arrival-times) (nth j departure-times))\n          (progn\n            (incf platform-needed)\n            (setf max-platforms (max max-platforms platform-needed))\n            (incf i))\n          (progn\n            (decf platform-needed)\n            (incf j))))\n    max-platforms))\n\n\n(defun run-tests ()\n  (assert (= (find-minimum-platforms '(\"09:00\" \"09:40\" \"09:50\" \"11:00\" \"15:00\" \"18:00\")\n                                     '(\"09:10\" \"12:00\" \"11:20\" \"11:30\" \"19:00\" \"20:00\")) \n             3)\n            () \"First test case should return 3 platforms\")\n  \n  (assert (= (find-minimum-platforms '(\"10:00\" \"10:20\" \"10:30\" \"10:40\")\n                                     '(\"10:10\" \"10:25\" \"10:35\" \"10:45\")) \n             1)\n            () \"Second test case should return 1 platform\")\n  \n  (assert (= (find-minimum-platforms '(\"00:00\" \"23:59\")\n                                     '(\"00:01\" \"00:02\")) \n             1)\n            () \"Third test case should return 1 platform\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-package-weights determines if it's possible to create a set of package weights\n; such that each truck's capacity can be exactly matched by a sum of these weights.\n; The weights are powers of 2, and the number of weights needed is the ceiling of log2(max_capacity + 1).\n; If the input list is empty, it returns \"IMPOSSIBLE\".\n; Otherwise, it returns \"POSSIBLE\", the number of weights, and the list of weights.\n(defun find-package-weights (truck-capacities)\n  (if (null truck-capacities)\n      \"IMPOSSIBLE\"\n      (let* ((max-capacity (apply #'max truck-capacities))\n             (num-weights (ceiling (log (+ max-capacity 1) 2)))\n             (weights (loop for i from 0 below num-weights\n                            collect (expt 2 i))))\n        (values \"POSSIBLE\" num-weights weights))))", "test_cases": "", "test_case_results": "Input: (10 20 30)\nPOSSIBLE 5 (1 2 4 8 16)\nInput: (5 15 25)\nPOSSIBLE 5 (1 2 4 8 16)\nInput: NIL\nIMPOSSIBLE\nInput: (1 3 7)\nPOSSIBLE 3 (1 2 4)", "task_id": 9689, "assertions": "(in-package :cl-user)\n\n(defun test-find-package-weights ()\n  (multiple-value-bind (status1 num-weights1 weights1) (find-package-weights '(10 20 30))\n    (assert (equal status1 \"POSSIBLE\") () \"Test case 1 status failed\")\n    (assert (= num-weights1 5) () \"Test case 1 num-weights failed\")\n    (assert (equal weights1 '(1 2 4 8 16)) () \"Test case 1 weights failed\"))\n  \n  (multiple-value-bind (status2 num-weights2 weights2) (find-package-weights '(5 15 25))\n    (assert (equal status2 \"POSSIBLE\") () \"Test case 2 status failed\")\n    (assert (= num-weights2 5) () \"Test case 2 num-weights failed\")\n    (assert (equal weights2 '(1 2 4 8 16)) () \"Test case 2 weights failed\"))\n  \n  (assert (equal (find-package-weights nil) \"IMPOSSIBLE\") () \"Test case 3 failed\")\n  \n  (multiple-value-bind (status4 num-weights4 weights4) (find-package-weights '(1 3 7))\n    (assert (equal status4 \"POSSIBLE\") () \"Test case 4 status failed\")\n    (assert (= num-weights4 3) () \"Test case 4 num-weights failed\")\n    (assert (equal weights4 '(1 2 4)) () \"Test case 4 weights failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(test-find-package-weights)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-find-package-weights ()\n  (multiple-value-bind (status1 num-weights1 weights1) (find-package-weights '(10 20 30))\n    (assert (equal status1 \"POSSIBLE\") () \"Test case 1 status failed\")\n    (assert (= num-weights1 5) () \"Test case 1 num-weights failed\")\n    (assert (equal weights1 '(1 2 4 8 16)) () \"Test case 1 weights failed\"))\n  \n  (multiple-value-bind (status2 num-weights2 weights2) (find-package-weights '(5 15 25))\n    (assert (equal status2 \"POSSIBLE\") () \"Test case 2 status failed\")\n    (assert (= num-weights2 5) () \"Test case 2 num-weights failed\")\n    (assert (equal weights2 '(1 2 4 8 16)) () \"Test case 2 weights failed\"))\n  \n  (assert (equal (find-package-weights nil) \"IMPOSSIBLE\") () \"Test case 3 failed\")\n  \n  (multiple-value-bind (status4 num-weights4 weights4) (find-package-weights '(1 3 7))\n    (assert (equal status4 \"POSSIBLE\") () \"Test case 4 status failed\")\n    (assert (= num-weights4 3) () \"Test case 4 num-weights failed\")\n    (assert (equal weights4 '(1 2 4)) () \"Test case 4 weights failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(test-find-package-weights)", "output": "find-package-weights"}, "all_code": "(in-package :cl-user)\n\n(defun find-package-weights (truck-capacities)\n  (if (null truck-capacities)\n      \"IMPOSSIBLE\"\n      (let* ((max-capacity (apply #'max truck-capacities))\n             (num-weights (ceiling (log (+ max-capacity 1) 2)))\n             (weights (loop for i from 0 below num-weights\n                            collect (expt 2 i))))\n        (values \"POSSIBLE\" num-weights weights))))\n\n\n(defun test-find-package-weights ()\n  (multiple-value-bind (status1 num-weights1 weights1) (find-package-weights '(10 20 30))\n    (assert (equal status1 \"POSSIBLE\") () \"Test case 1 status failed\")\n    (assert (= num-weights1 5) () \"Test case 1 num-weights failed\")\n    (assert (equal weights1 '(1 2 4 8 16)) () \"Test case 1 weights failed\"))\n  \n  (multiple-value-bind (status2 num-weights2 weights2) (find-package-weights '(5 15 25))\n    (assert (equal status2 \"POSSIBLE\") () \"Test case 2 status failed\")\n    (assert (= num-weights2 5) () \"Test case 2 num-weights failed\")\n    (assert (equal weights2 '(1 2 4 8 16)) () \"Test case 2 weights failed\"))\n  \n  (assert (equal (find-package-weights nil) \"IMPOSSIBLE\") () \"Test case 3 failed\")\n  \n  (multiple-value-bind (status4 num-weights4 weights4) (find-package-weights '(1 3 7))\n    (assert (equal status4 \"POSSIBLE\") () \"Test case 4 status failed\")\n    (assert (= num-weights4 3) () \"Test case 4 num-weights failed\")\n    (assert (equal weights4 '(1 2 4)) () \"Test case 4 weights failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(test-find-package-weights)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; min-tasks-for-badges calculates the minimum number of tasks required to collect the specified number of Gold, Silver, and Bronze badges.\n; The calculation is based on the following rules:\n; - Each Gold badge requires 100 tasks.\n; - Each Silver badge requires 50 tasks.\n; - Each Bronze badge requires 20 tasks.\n; The minimum number of tasks required is the maximum of the tasks calculated for each badge type.\n; Parameters:\n; gold - Number of Gold badges required.\n; silver - Number of Silver badges required.\n; bronze - Number of Bronze badges required.\n; Returns:\n; The minimum number of tasks required as an integer.\n(defun min-tasks-for-badges (gold silver bronze)\n  (let ((tasks-for-gold (* gold 100))\n        (tasks-for-silver (* silver 50))\n        (tasks-for-bronze (* bronze 20)))\n    (max tasks-for-gold tasks-for-silver tasks-for-bronze)))", "test_cases": "", "test_case_results": "Input: Gold=1, Silver=0, Bronze=0\nResult: 100\nInput: Gold=0, Silver=1, Bronze=0\nResult: 50\nInput: Gold=0, Silver=0, Bronze=1\nResult: 20\nInput: Gold=2, Silver=3, Bronze=5\nResult: 200\nInput: Gold=0, Silver=0, Bronze=0\nResult: 0", "task_id": 26235, "assertions": "(defpackage :badge-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :badge-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-tasks-for-badges 1 0 0) 100) () \"1 gold badge should require 100 tasks\")\n  (assert (= (min-tasks-for-badges 0 1 0) 50) () \"1 silver badge should require 50 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 1) 20) () \"1 bronze badge should require 20 tasks\")\n  (assert (= (min-tasks-for-badges 2 3 5) 200) () \"2 gold, 3 silver, 5 bronze should require 200 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 0) 0) () \"0 badges should require 0 tasks\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :badge-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :badge-utils-test)\n\n(defun run-tests ()\n  (assert (= (min-tasks-for-badges 1 0 0) 100) () \"1 gold badge should require 100 tasks\")\n  (assert (= (min-tasks-for-badges 0 1 0) 50) () \"1 silver badge should require 50 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 1) 20) () \"1 bronze badge should require 20 tasks\")\n  (assert (= (min-tasks-for-badges 2 3 5) 200) () \"2 gold, 3 silver, 5 bronze should require 200 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 0) 0) () \"0 badges should require 0 tasks\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-tasks-for-badges"}, "all_code": "(defpackage :badge-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :badge-utils-test)\n\n(defun min-tasks-for-badges (gold silver bronze)\n  (let ((tasks-for-gold (* gold 100))\n        (tasks-for-silver (* silver 50))\n        (tasks-for-bronze (* bronze 20)))\n    (max tasks-for-gold tasks-for-silver tasks-for-bronze)))\n\n\n(defun run-tests ()\n  (assert (= (min-tasks-for-badges 1 0 0) 100) () \"1 gold badge should require 100 tasks\")\n  (assert (= (min-tasks-for-badges 0 1 0) 50) () \"1 silver badge should require 50 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 1) 20) () \"1 bronze badge should require 20 tasks\")\n  (assert (= (min-tasks-for-badges 2 3 5) 200) () \"2 gold, 3 silver, 5 bronze should require 200 tasks\")\n  (assert (= (min-tasks-for-badges 0 0 0) 0) () \"0 badges should require 0 tasks\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; does-drone-visit determines if the drone visits specified positions based on a series of commands.\n; The drone starts at (0, 0) and moves according to the commands ('U', 'D', 'L', 'R').\n; It tracks all positions visited during the movement.\n; For each query (a position), it checks if the position was visited.\n; Returns a list of booleans indicating whether each query position was visited.\n(defun does-drone-visit (n commands queries)\n  (let ((x 0)\n        (y 0)\n        (visited-positions (make-hash-table :test 'equal)))\n    ; Mark the initial position as visited\n    (setf (gethash (list x y) visited-positions) t)\n    ; Process each command to update the drone's position\n    (loop for command across commands do\n      (cond\n        ((char= command #\\U) (incf y))\n        ((char= command #\\D) (decf y))\n        ((char= command #\\L) (decf x))\n        ((char= command #\\R) (incf x)))\n      ; Mark the new position as visited\n      (setf (gethash (list x y) visited-positions) t))\n    ; Check each query against the visited positions\n    (mapcar (lambda (query) (gethash query visited-positions)) queries)))", "test_cases": "", "test_case_results": "Commands: URDR\nQueries: ((0 0) (1 1) (2 0) (1 0))\nResults: (T T T T)\nCommands: UUU\nQueries: ((0 0) (0 1) (0 2) (0 3))\nResults: (T T T T)\nCommands: LRLR\nQueries: ((-1 0) (0 0) (1 0) (0 1))\nResults: (T T NIL NIL)", "task_id": 22574, "assertions": "(in-package :cl-user)\n\n(defun test-does-drone-visit ()\n  (assert (equal (does-drone-visit 5 \"URDR\" '((0 0) (1 1) (2 0) (1 0)))\n                 '(T T T T))\n          () \"Test case 1 failed\")\n  (assert (equal (does-drone-visit 3 \"UUU\" '((0 0) (0 1) (0 2) (0 3)))\n                 '(T T T T))\n          () \"Test case 2 failed\")\n  (assert (equal (does-drone-visit 4 \"LRLR\" '((-1 0) (0 0) (1 0) (0 1)))\n                 '(T T NIL NIL))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-does-drone-visit)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-does-drone-visit ()\n  (assert (equal (does-drone-visit 5 \"URDR\" '((0 0) (1 1) (2 0) (1 0)))\n                 '(T T T T))\n          () \"Test case 1 failed\")\n  (assert (equal (does-drone-visit 3 \"UUU\" '((0 0) (0 1) (0 2) (0 3)))\n                 '(T T T T))\n          () \"Test case 2 failed\")\n  (assert (equal (does-drone-visit 4 \"LRLR\" '((-1 0) (0 0) (1 0) (0 1)))\n                 '(T T NIL NIL))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-does-drone-visit)", "output": "does-drone-visit"}, "all_code": "(in-package :cl-user)\n\n(defun does-drone-visit (n commands queries)\n  (let ((x 0)\n        (y 0)\n        (visited-positions (make-hash-table :test 'equal)))\n    ; Mark the initial position as visited\n    (setf (gethash (list x y) visited-positions) t)\n    ; Process each command to update the drone's position\n    (loop for command across commands do\n      (cond\n        ((char= command #\\U) (incf y))\n        ((char= command #\\D) (decf y))\n        ((char= command #\\L) (decf x))\n        ((char= command #\\R) (incf x)))\n      ; Mark the new position as visited\n      (setf (gethash (list x y) visited-positions) t))\n    ; Check each query against the visited positions\n    (mapcar (lambda (query) (gethash query visited-positions)) queries)))\n\n\n(defun test-does-drone-visit ()\n  (assert (equal (does-drone-visit 5 \"URDR\" '((0 0) (1 1) (2 0) (1 0)))\n                 '(T T T T))\n          () \"Test case 1 failed\")\n  (assert (equal (does-drone-visit 3 \"UUU\" '((0 0) (0 1) (0 2) (0 3)))\n                 '(T T T T))\n          () \"Test case 2 failed\")\n  (assert (equal (does-drone-visit 4 \"LRLR\" '((-1 0) (0 0) (1 0) (0 1)))\n                 '(T T NIL NIL))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-does-drone-visit)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; unique-permutations generates all unique permutations of a string of length k in lexicographical order.\n; It first generates all possible permutations, removes duplicates, sorts them, and returns the result.\n; \n; Args:\n; s (string): The input string.\n; k (integer): The length of each permutation.\n;\n; Returns:\n; A sorted list of all unique permutations of length k in lexicographical order.\n(defun unique-permutations (s k)\n  (let* ((chars (coerce s 'list))\n         (perms (permutations chars k))\n         (unique-perms (remove-duplicates perms :test #'equal))\n         (string-perms (mapcar (lambda (p) (coerce p 'string)) unique-perms)))\n    (sort string-perms #'string<)))\n\n; Helper function to generate all permutations of a list of length k.\n; This is a recursive implementation that builds permutations step by step.\n;\n; Args:\n; lst (list): The list of elements to permute.\n; k (integer): The length of each permutation.\n;\n; Returns:\n; A list of all permutations of lst of length k.\n(defun permutations (lst k)\n  (if (zerop k)\n      '(())\n      (loop for elem in lst\n            append (mapcar (lambda (p) (cons elem p))\n                          (permutations (remove elem lst :count 1) (1- k))))))", "test_cases": "", "test_case_results": "Input: abc, k: 2\nPermutations: (ab ac ba bc ca cb)\nInput: aab, k: 2\nPermutations: (aa ab ba)\nInput: abcd, k: 1\nPermutations: (a b c d)", "task_id": 2934, "assertions": "(defpackage :permutations-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :permutations-test)\n\n(defun run-tests ()\n  (let ((result1 (cl-user::unique-permutations \"abc\" 2))\n        (expected1 '(\"ab\" \"ac\" \"ba\" \"bc\" \"ca\" \"cb\"))\n        (result2 (cl-user::unique-permutations \"aab\" 2))\n        (expected2 '(\"aa\" \"ab\" \"ba\"))\n        (result3 (cl-user::unique-permutations \"abcd\" 1))\n        (expected3 '(\"a\" \"b\" \"c\" \"d\")))\n    \n    (assert (equal result1 expected1) () \"Test case 1 failed: (unique-permutations \\\"abc\\\" 2)\")\n    (assert (equal result2 expected2) () \"Test case 2 failed: (unique-permutations \\\"aab\\\" 2)\")\n    (assert (equal result3 expected3) () \"Test case 3 failed: (unique-permutations \\\"abcd\\\" 1)\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :permutations-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :permutations-test)\n\n(defun run-tests ()\n  (let ((result1 (cl-user::unique-permutations \"abc\" 2))\n        (expected1 '(\"ab\" \"ac\" \"ba\" \"bc\" \"ca\" \"cb\"))\n        (result2 (cl-user::unique-permutations \"aab\" 2))\n        (expected2 '(\"aa\" \"ab\" \"ba\"))\n        (result3 (cl-user::unique-permutations \"abcd\" 1))\n        (expected3 '(\"a\" \"b\" \"c\" \"d\")))\n    \n    (assert (equal result1 expected1) () \"Test case 1 failed: (unique-permutations \\\"abc\\\" 2)\")\n    (assert (equal result2 expected2) () \"Test case 2 failed: (unique-permutations \\\"aab\\\" 2)\")\n    (assert (equal result3 expected3) () \"Test case 3 failed: (unique-permutations \\\"abcd\\\" 1)\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "unique-permutations"}, "all_code": "(defpackage :permutations-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :permutations-test)\n\n(defun unique-permutations (s k)\n  (let* ((chars (coerce s 'list))\n         (perms (permutations chars k))\n         (unique-perms (remove-duplicates perms :test #'equal))\n         (string-perms (mapcar (lambda (p) (coerce p 'string)) unique-perms)))\n    (sort string-perms #'string<)))\n\n; Helper function to generate all permutations of a list of length k.\n; This is a recursive implementation that builds permutations step by step.\n;\n; Args:\n; lst (list): The list of elements to permute.\n; k (integer): The length of each permutation.\n;\n; Returns:\n; A list of all permutations of lst of length k.\n(defun permutations (lst k)\n  (if (zerop k)\n      '(())\n      (loop for elem in lst\n            append (mapcar (lambda (p) (cons elem p))\n                          (permutations (remove elem lst :count 1) (1- k))))))\n\n\n(defun run-tests ()\n  (let ((result1 (cl-user::unique-permutations \"abc\" 2))\n        (expected1 '(\"ab\" \"ac\" \"ba\" \"bc\" \"ca\" \"cb\"))\n        (result2 (cl-user::unique-permutations \"aab\" 2))\n        (expected2 '(\"aa\" \"ab\" \"ba\"))\n        (result3 (cl-user::unique-permutations \"abcd\" 1))\n        (expected3 '(\"a\" \"b\" \"c\" \"d\")))\n    \n    (assert (equal result1 expected1) () \"Test case 1 failed: (unique-permutations \\\"abc\\\" 2)\")\n    (assert (equal result2 expected2) () \"Test case 2 failed: (unique-permutations \\\"aab\\\" 2)\")\n    (assert (equal result3 expected3) () \"Test case 3 failed: (unique-permutations \\\"abcd\\\" 1)\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(defpackage :grid-utils\n  (:use :cl)\n  (:export :generate-final-grid))\n\n(in-package :grid-utils)\n\n;; generate-final-grid creates an N x N grid initialized with 'W' characters,\n;; then applies operations to modify specific cells based on the input.\n;; Each operation is a tuple (X Y C) where:\n;; - X and Y are 1-based coordinates\n;; - C determines the cell value (1 becomes 'B', anything else becomes 'W')\n;; Returns the grid as a list of strings.\n(defun generate-final-grid (n m operations)\n  (let ((grid (make-array (list n n) :initial-element #\\W)))\n    (dolist (op operations)\n      (destructuring-bind (x y c) op\n        (setf (aref grid (1- x) (1- y)) (if (= c 1) #\\B #\\W))))\n    (loop for i below n collect\n         (coerce (loop for j below n collect (aref grid i j)) 'string))))", "test_cases": "", "test_case_results": "=== Testing Grid Functions ===\n\nTest Case 1: Single operation on 2x2 grid\nInput: N=2, M=1, Operations=((1 1 1))\nResult: (BW WW)\n\nTest Case 2: Multiple operations on 3x3 grid\nInput: N=3, M=3, Operations=((1 1 1) (2 2 0) (3 3 1))\nResult: (BWW WWW WWB)\n\nTest Case 3: Empty operations on 1x1 grid\nInput: N=1, M=0, Operations=NIL\nResult: (W)", "task_id": 27484, "assertions": "(defpackage :grid-utils-test\n  (:use :cl :grid-utils)\n  (:export :run-tests))\n\n(in-package :grid-utils-test)\n\n(defun run-tests ()\n  ;; Test Case 1: Simple 2x2 grid with one operation\n  (assert (equal (generate-final-grid 2 1 '((1 1 1)))\n                 '(\"BW\" \"WW\"))\n          () \"Test Case 1 failed: Single operation on 2x2 grid\")\n  \n  ;; Test Case 2: 3x3 grid with multiple operations\n  (assert (equal (generate-final-grid 3 3 '((1 1 1) (2 2 0) (3 3 1)))\n                 '(\"BWW\" \"WWW\" \"WWB\"))\n          () \"Test Case 2 failed: Multiple operations on 3x3 grid\")\n  \n  ;; Test Case 3: Edge case - empty operations on 1x1 grid\n  (assert (equal (generate-final-grid 1 0 nil)\n                 '(\"W\"))\n          () \"Test Case 3 failed: Empty operations on 1x1 grid\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :grid-utils-test\n  (:use :cl :grid-utils)\n  (:export :run-tests))\n\n(in-package :grid-utils-test)\n\n(defun run-tests ()\n  ;; Test Case 1: Simple 2x2 grid with one operation\n  (assert (equal (generate-final-grid 2 1 '((1 1 1)))\n                 '(\"BW\" \"WW\"))\n          () \"Test Case 1 failed: Single operation on 2x2 grid\")\n  \n  ;; Test Case 2: 3x3 grid with multiple operations\n  (assert (equal (generate-final-grid 3 3 '((1 1 1) (2 2 0) (3 3 1)))\n                 '(\"BWW\" \"WWW\" \"WWB\"))\n          () \"Test Case 2 failed: Multiple operations on 3x3 grid\")\n  \n  ;; Test Case 3: Edge case - empty operations on 1x1 grid\n  (assert (equal (generate-final-grid 1 0 nil)\n                 '(\"W\"))\n          () \"Test Case 3 failed: Empty operations on 1x1 grid\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "generate-final-grid"}, "all_code": "(defpackage :grid-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :grid-utils-test)\n\n(defun generate-final-grid (n m operations)\n  (let ((grid (make-array (list n n) :initial-element #\\W)))\n    (dolist (op operations)\n      (destructuring-bind (x y c) op\n        (setf (aref grid (1- x) (1- y)) (if (= c 1) #\\B #\\W))))\n    (loop for i below n collect\n         (coerce (loop for j below n collect (aref grid i j)) 'string))))\n\n\n(defun run-tests ()\n  ;; Test Case 1: Simple 2x2 grid with one operation\n  (assert (equal (generate-final-grid 2 1 '((1 1 1)))\n                 '(\"BW\" \"WW\"))\n          () \"Test Case 1 failed: Single operation on 2x2 grid\")\n  \n  ;; Test Case 2: 3x3 grid with multiple operations\n  (assert (equal (generate-final-grid 3 3 '((1 1 1) (2 2 0) (3 3 1)))\n                 '(\"BWW\" \"WWW\" \"WWB\"))\n          () \"Test Case 2 failed: Multiple operations on 3x3 grid\")\n  \n  ;; Test Case 3: Edge case - empty operations on 1x1 grid\n  (assert (equal (generate-final-grid 1 0 nil)\n                 '(\"W\"))\n          () \"Test Case 3 failed: Empty operations on 1x1 grid\")\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :isbn-utils\n  (:use :cl)\n  (:export :valid-isbn10))\n\n(in-package :isbn-utils)\n\n(defun valid-isbn10 (isbn)\n  \"Determines if the given string is a valid ISBN-10.\n   Returns T if valid, NIL otherwise.\"\n  (unless (= (length isbn) 10)\n    (return-from valid-isbn10 nil))\n  \n  (let ((total 0))\n    (dotimes (i 10)\n      (let ((char (char isbn i)))\n        (cond\n          ((char= char #\\X)\n           (if (= i 9)\n               (incf total (* 10 (- 10 i)))\n               (return-from valid-isbn10 nil)))\n          ((digit-char-p char)\n           (incf total (* (digit-char-p char) (- 10 i))))\n          (t (return-from valid-isbn10 nil)))))\n    (zerop (mod total 11))))", "test_cases": "", "test_case_results": "ISBN: 1112223339, Valid: T\nISBN: 111222333X, Valid: NIL\nISBN: 123456789X, Valid: T\nISBN: 1234567890, Valid: NIL\nISBN: 123456789, Valid: NIL\nISBN: 12345678901, Valid: NIL\nISBN: ABCDEFGHIJ, Valid: NIL\nISBN: X123456789, Valid: NIL", "task_id": 26477, "assertions": "(defpackage :isbn-utils-test\n  (:use :cl :isbn-utils)\n  (:export :run-tests))\n\n(in-package :isbn-utils-test)\n\n(defun run-tests ()\n  (assert (valid-isbn10 \"1112223339\") () \"1112223339 should be valid\")\n  (assert (not (valid-isbn10 \"111222333X\")) () \"111222333X should be invalid\")\n  (assert (valid-isbn10 \"123456789X\") () \"123456789X should be valid\")\n  (assert (not (valid-isbn10 \"1234567890\")) () \"1234567890 should be invalid\")\n  (assert (not (valid-isbn10 \"123456789\")) () \"Short ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"12345678901\")) () \"Long ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"ABCDEFGHIJ\")) () \"Non-digit ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"X123456789\")) () \"X in wrong position should be invalid\")\n  (format t \"All ISBN-10 tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :isbn-utils-test\n  (:use :cl :isbn-utils)\n  (:export :run-tests))\n\n(in-package :isbn-utils-test)\n\n(defun run-tests ()\n  (assert (valid-isbn10 \"1112223339\") () \"1112223339 should be valid\")\n  (assert (not (valid-isbn10 \"111222333X\")) () \"111222333X should be invalid\")\n  (assert (valid-isbn10 \"123456789X\") () \"123456789X should be valid\")\n  (assert (not (valid-isbn10 \"1234567890\")) () \"1234567890 should be invalid\")\n  (assert (not (valid-isbn10 \"123456789\")) () \"Short ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"12345678901\")) () \"Long ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"ABCDEFGHIJ\")) () \"Non-digit ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"X123456789\")) () \"X in wrong position should be invalid\")\n  (format t \"All ISBN-10 tests passed!~%\"))\n\n(run-tests)", "output": "valid-isbn10"}, "all_code": "(defpackage :isbn-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :isbn-utils-test)\n\n(defun valid-isbn10 (isbn)\n  \"Determines if the given string is a valid ISBN-10.\n   Returns T if valid, NIL otherwise.\"\n  (unless (= (length isbn) 10)\n    (return-from valid-isbn10 nil))\n  \n  (let ((total 0))\n    (dotimes (i 10)\n      (let ((char (char isbn i)))\n        (cond\n          ((char= char #\\X)\n           (if (= i 9)\n               (incf total (* 10 (- 10 i)))\n               (return-from valid-isbn10 nil)))\n          ((digit-char-p char)\n           (incf total (* (digit-char-p char) (- 10 i))))\n          (t (return-from valid-isbn10 nil)))))\n    (zerop (mod total 11))))\n\n\n(defun run-tests ()\n  (assert (valid-isbn10 \"1112223339\") () \"1112223339 should be valid\")\n  (assert (not (valid-isbn10 \"111222333X\")) () \"111222333X should be invalid\")\n  (assert (valid-isbn10 \"123456789X\") () \"123456789X should be valid\")\n  (assert (not (valid-isbn10 \"1234567890\")) () \"1234567890 should be invalid\")\n  (assert (not (valid-isbn10 \"123456789\")) () \"Short ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"12345678901\")) () \"Long ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"ABCDEFGHIJ\")) () \"Non-digit ISBN should be invalid\")\n  (assert (not (valid-isbn10 \"X123456789\")) () \"X in wrong position should be invalid\")\n  (format t \"All ISBN-10 tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; min-moves-to-equal-sticks calculates the minimum number of moves required to make all sticks equal in length.\n; The optimal length to adjust all sticks to is the median of the sorted list.\n; The function sorts the input list, finds the median, and sums the absolute differences between each stick's length and the median.\n; If the input list is empty, it returns 0.\n(defun min-moves-to-equal-sticks (sticks)\n  (if (null sticks)\n      0\n      (let* ((sorted-sticks (sort (copy-list sticks) #'<))\n             (median (nth (floor (length sorted-sticks) 2) sorted-sticks))\n             (total-moves (reduce #'+ (mapcar (lambda (x) (abs (- x median))) sorted-sticks))))\n        total-moves)))", "test_cases": "", "test_case_results": "Input: (1 2 3)\nMoves: 2\n\nInput: (4 6 8 10)\nMoves: 8\n\nInput: (5 5 5 5)\nMoves: 0\n\nInput: (1 5 3 9 7)\nMoves: 12\n\nInput: NIL\nMoves: 0", "task_id": 11301, "assertions": "(defpackage :sticks-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :sticks-test)\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-sticks '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-sticks '(4 6 8 10)) 8) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-sticks '(5 5 5 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-sticks '(1 5 3 9 7)) 12) () \"Test case 4 failed\")\n  (assert (= (min-moves-to-equal-sticks nil) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :sticks-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :sticks-test)\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-sticks '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-sticks '(4 6 8 10)) 8) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-sticks '(5 5 5 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-sticks '(1 5 3 9 7)) 12) () \"Test case 4 failed\")\n  (assert (= (min-moves-to-equal-sticks nil) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-moves-to-equal-sticks"}, "all_code": "(defpackage :sticks-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :sticks-test)\n\n(defun min-moves-to-equal-sticks (sticks)\n  (if (null sticks)\n      0\n      (let* ((sorted-sticks (sort (copy-list sticks) #'<))\n             (median (nth (floor (length sorted-sticks) 2) sorted-sticks))\n             (total-moves (reduce #'+ (mapcar (lambda (x) (abs (- x median))) sorted-sticks))))\n        total-moves)))\n\n\n(defun run-tests ()\n  (assert (= (min-moves-to-equal-sticks '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (min-moves-to-equal-sticks '(4 6 8 10)) 8) () \"Test case 2 failed\")\n  (assert (= (min-moves-to-equal-sticks '(5 5 5 5)) 0) () \"Test case 3 failed\")\n  (assert (= (min-moves-to-equal-sticks '(1 5 3 9 7)) 12) () \"Test case 4 failed\")\n  (assert (= (min-moves-to-equal-sticks nil) 0) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; normalize-dict-keys converts all keys in a dictionary (represented as an alist) to lowercase.\n;; It takes an alist (association list) where each element is a cons cell (key . value).\n;; Returns a new alist with all keys converted to lowercase strings.\n(defun normalize-dict-keys (alist)\n  (mapcar (lambda (pair)\n            (cons (string-downcase (car pair)) (cdr pair)))\n          alist))", "test_cases": "", "test_case_results": "Input: ((Key1 . 1) (KEY2 . 2) (kEy3 . 3))\nOutput: ((key1 . 1) (key2 . 2) (key3 . 3))\nInput: ((ABC . abc) (DEF . def))\nOutput: ((abc . abc) (def . def))\nInput: ((Single . element))\nOutput: ((single . element))", "task_id": 25231, "assertions": "(defpackage :dict-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dict-utils-test)\n\n(defun run-tests ()\n  (assert (equal (normalize-dict-keys '(( \"Key1\" . 1) ( \"KEY2\" . 2) ( \"kEy3\" . 3)))\n                 '(( \"key1\" . 1) ( \"key2\" . 2) ( \"key3\" . 3)))\n          () \"Test case 1 failed\")\n  (assert (equal (normalize-dict-keys '(( \"ABC\" . \"abc\") ( \"DEF\" . \"def\")))\n                 '(( \"abc\" . \"abc\") ( \"def\" . \"def\")))\n          () \"Test case 2 failed\")\n  (assert (equal (normalize-dict-keys '(( \"Single\" . \"element\")))\n                 '(( \"single\" . \"element\")))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :dict-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dict-utils-test)\n\n(defun run-tests ()\n  (assert (equal (normalize-dict-keys '(( \"Key1\" . 1) ( \"KEY2\" . 2) ( \"kEy3\" . 3)))\n                 '(( \"key1\" . 1) ( \"key2\" . 2) ( \"key3\" . 3)))\n          () \"Test case 1 failed\")\n  (assert (equal (normalize-dict-keys '(( \"ABC\" . \"abc\") ( \"DEF\" . \"def\")))\n                 '(( \"abc\" . \"abc\") ( \"def\" . \"def\")))\n          () \"Test case 2 failed\")\n  (assert (equal (normalize-dict-keys '(( \"Single\" . \"element\")))\n                 '(( \"single\" . \"element\")))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "normalize-dict-keys"}, "all_code": "(defpackage :dict-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :dict-utils-test)\n\n(defun normalize-dict-keys (alist)\n  (mapcar (lambda (pair)\n            (cons (string-downcase (car pair)) (cdr pair)))\n          alist))\n\n\n(defun run-tests ()\n  (assert (equal (normalize-dict-keys '(( \"Key1\" . 1) ( \"KEY2\" . 2) ( \"kEy3\" . 3)))\n                 '(( \"key1\" . 1) ( \"key2\" . 2) ( \"key3\" . 3)))\n          () \"Test case 1 failed\")\n  (assert (equal (normalize-dict-keys '(( \"ABC\" . \"abc\") ( \"DEF\" . \"def\")))\n                 '(( \"abc\" . \"abc\") ( \"def\" . \"def\")))\n          () \"Test case 2 failed\")\n  (assert (equal (normalize-dict-keys '(( \"Single\" . \"element\")))\n                 '(( \"single\" . \"element\")))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; is-perfect-square recursively checks if a number n is a perfect square.\n; It starts checking from the 'start' value (defaults to 1) and increments until it finds a match or exceeds n.\n; \n; Parameters:\n; n - The number to check.\n; start - The current number to test from (defaults to 1).\n;\n; Returns:\n; t if n is a perfect square, nil otherwise.\n(defun is-perfect-square (n &optional (start 1))\n  (cond\n    ((< n 0) nil) ; Negative numbers cannot be perfect squares\n    ((or (= n 0) (= n 1)) t) ; 0 and 1 are perfect squares\n    (t (let ((current-square (* start start)))\n         (cond\n           ((> current-square n) nil) ; Exceeded n without finding a perfect square\n           ((= current-square n) t) ; Found a perfect square\n           (t (is-perfect-square n (1+ start)))))))) ; Recur with next integer", "test_cases": "", "test_case_results": "Input: -1\nResult: NIL\nInput: 0\nResult: T\nInput: 1\nResult: T\nInput: 2\nResult: NIL\nInput: 4\nResult: T\nInput: 9\nResult: T\nInput: 10\nResult: NIL\nInput: 16\nResult: T\nInput: 25\nResult: T\nInput: 26\nResult: NIL", "task_id": 0, "assertions": "(defpackage :perfect-square-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :perfect-square-test)\n\n(defun run-tests ()\n  (assert (not (is-perfect-square -1)) () \"-1 should not be a perfect square\")\n  (assert (is-perfect-square 0) () \"0 should be a perfect square\")\n  (assert (is-perfect-square 1) () \"1 should be a perfect square\")\n  (assert (not (is-perfect-square 2)) () \"2 should not be a perfect square\")\n  (assert (is-perfect-square 4) () \"4 should be a perfect square\")\n  (assert (is-perfect-square 9) () \"9 should be a perfect square\")\n  (assert (not (is-perfect-square 10)) () \"10 should not be a perfect square\")\n  (assert (is-perfect-square 16) () \"16 should be a perfect square\")\n  (assert (is-perfect-square 25) () \"25 should be a perfect square\")\n  (assert (not (is-perfect-square 26)) () \"26 should not be a perfect square\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :perfect-square-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :perfect-square-test)\n\n(defun run-tests ()\n  (assert (not (is-perfect-square -1)) () \"-1 should not be a perfect square\")\n  (assert (is-perfect-square 0) () \"0 should be a perfect square\")\n  (assert (is-perfect-square 1) () \"1 should be a perfect square\")\n  (assert (not (is-perfect-square 2)) () \"2 should not be a perfect square\")\n  (assert (is-perfect-square 4) () \"4 should be a perfect square\")\n  (assert (is-perfect-square 9) () \"9 should be a perfect square\")\n  (assert (not (is-perfect-square 10)) () \"10 should not be a perfect square\")\n  (assert (is-perfect-square 16) () \"16 should be a perfect square\")\n  (assert (is-perfect-square 25) () \"25 should be a perfect square\")\n  (assert (not (is-perfect-square 26)) () \"26 should not be a perfect square\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "is-perfect-square"}, "all_code": "(defpackage :perfect-square-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :perfect-square-test)\n\n\n\n(defun run-tests ()\n  (assert (not (is-perfect-square -1)) () \"-1 should not be a perfect square\")\n  (assert (is-perfect-square 0) () \"0 should be a perfect square\")\n  (assert (is-perfect-square 1) () \"1 should be a perfect square\")\n  (assert (not (is-perfect-square 2)) () \"2 should not be a perfect square\")\n  (assert (is-perfect-square 4) () \"4 should be a perfect square\")\n  (assert (is-perfect-square 9) () \"9 should be a perfect square\")\n  (assert (not (is-perfect-square 10)) () \"10 should not be a perfect square\")\n  (assert (is-perfect-square 16) () \"16 should be a perfect square\")\n  (assert (is-perfect-square 25) () \"25 should be a perfect square\")\n  (assert (not (is-perfect-square 26)) () \"26 should not be a perfect square\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n;;; Dijkstra's algorithm implementation in Common Lisp\n\n;;; A priority queue implementation using a list and sorting\n(defun priority-queue-push (queue item)\n  \"Push an item into the priority queue and maintain order.\"\n  (merge 'list (list item) queue #'< :key #'car))\n\n(defun priority-queue-pop (queue)\n  \"Pop the smallest item from the priority queue.\"\n  (values (car queue) (cdr queue)))\n\n;;; dijkstra calculates the shortest paths from the start node to all other nodes in the graph.\n;;; graph is an association list where each node maps to a list of (neighbor . weight) pairs.\n;;; start is the starting node.\n;;; Returns an association list of (node . distance) pairs.\n(defun dijkstra (graph start)\n  (let ((priority-queue (list (cons 0 start)))\n        (distances (loop for (node) in graph collect (cons node most-positive-fixnum) into dists\n                         finally (return (progn (setf (cdr (assoc start dists)) 0) dists)))))\n    (loop while priority-queue\n          do (multiple-value-bind (current-item remaining-queue) (priority-queue-pop priority-queue)\n               (setf priority-queue remaining-queue)\n               (let ((current-distance (car current-item))\n                     (current-node (cdr current-item)))\n                 (when (<= current-distance (cdr (assoc current-node distances)))\n                   (dolist (edge (cdr (assoc current-node graph)))\n                     (let* ((neighbor (car edge))\n                            (weight (cdr edge))\n                            (distance (+ current-distance weight))\n                            (neighbor-distance (cdr (assoc neighbor distances))))\n                       (when (< distance neighbor-distance)\n                         (setf (cdr (assoc neighbor distances)) distance)\n                         (setf priority-queue (priority-queue-push priority-queue (cons distance neighbor))))))))))\n    distances))", "test_cases": "", "test_case_results": "Graph: ((A (B . 7) (C . 9) (F . 14)) (B (A . 7) (C . 10) (D . 15))\n        (C (A . 9) (B . 10) (D . 11) (F . 2)) (D (B . 15) (C . 11) (E . 6))\n        (E (D . 6) (F . 9)) (F (A . 14) (C . 2) (E . 9)))\nStart node: A\nDistances: ((A . 0) (B . 7) (C . 9) (D . 20) (E . 20) (F . 11))\n\nGraph: ((X (Y . 4) (Z . 8)) (Y (X . 4) (Z . 3)) (Z (X . 8) (Y . 3)))\nStart node: X\nDistances: ((X . 0) (Y . 4) (Z . 7))", "task_id": 20128, "assertions": "(defpackage :dijkstra-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dijkstra-test)\n\n(defun run-tests ()\n  (let ((graph1 '((a (b . 7) (c . 9) (f . 14))\n                  (b (a . 7) (c . 10) (d . 15))\n                  (c (a . 9) (b . 10) (d . 11) (f . 2))\n                  (d (b . 15) (c . 11) (e . 6))\n                  (e (d . 6) (f . 9))\n                  (f (a . 14) (c . 2) (e . 9))))\n        (graph2 '((x (y . 4) (z . 8))\n                  (y (x . 4) (z . 3))\n                  (z (x . 8) (y . 3)))))\n    \n    ;; Test case 1\n    (let ((result (cl-user::dijkstra graph1 'a)))\n      (assert (equal (cdr (assoc 'a result)) 0) () \"Distance to A should be 0\")\n      (assert (equal (cdr (assoc 'b result)) 7) () \"Distance to B should be 7\")\n      (assert (equal (cdr (assoc 'c result)) 9) () \"Distance to C should be 9\")\n      (assert (equal (cdr (assoc 'd result)) 20) () \"Distance to D should be 20\")\n      (assert (equal (cdr (assoc 'e result)) 20) () \"Distance to E should be 20\")\n      (assert (equal (cdr (assoc 'f result)) 11) () \"Distance to F should be 11\"))\n    \n    ;; Test case 2\n    (let ((result (cl-user::dijkstra graph2 'x)))\n      (assert (equal (cdr (assoc 'x result)) 0) () \"Distance to X should be 0\")\n      (assert (equal (cdr (assoc 'y result)) 4) () \"Distance to Y should be 4\")\n      (assert (equal (cdr (assoc 'z result)) 7) () \"Distance to Z should be 7\"))\n    \n    (format t \"All Dijkstra algorithm tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :dijkstra-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :dijkstra-test)\n\n(defun run-tests ()\n  (let ((graph1 '((a (b . 7) (c . 9) (f . 14))\n                  (b (a . 7) (c . 10) (d . 15))\n                  (c (a . 9) (b . 10) (d . 11) (f . 2))\n                  (d (b . 15) (c . 11) (e . 6))\n                  (e (d . 6) (f . 9))\n                  (f (a . 14) (c . 2) (e . 9))))\n        (graph2 '((x (y . 4) (z . 8))\n                  (y (x . 4) (z . 3))\n                  (z (x . 8) (y . 3)))))\n    \n    ;; Test case 1\n    (let ((result (cl-user::dijkstra graph1 'a)))\n      (assert (equal (cdr (assoc 'a result)) 0) () \"Distance to A should be 0\")\n      (assert (equal (cdr (assoc 'b result)) 7) () \"Distance to B should be 7\")\n      (assert (equal (cdr (assoc 'c result)) 9) () \"Distance to C should be 9\")\n      (assert (equal (cdr (assoc 'd result)) 20) () \"Distance to D should be 20\")\n      (assert (equal (cdr (assoc 'e result)) 20) () \"Distance to E should be 20\")\n      (assert (equal (cdr (assoc 'f result)) 11) () \"Distance to F should be 11\"))\n    \n    ;; Test case 2\n    (let ((result (cl-user::dijkstra graph2 'x)))\n      (assert (equal (cdr (assoc 'x result)) 0) () \"Distance to X should be 0\")\n      (assert (equal (cdr (assoc 'y result)) 4) () \"Distance to Y should be 4\")\n      (assert (equal (cdr (assoc 'z result)) 7) () \"Distance to Z should be 7\"))\n    \n    (format t \"All Dijkstra algorithm tests passed!~%\")))\n\n(run-tests)", "output": "dijkstra"}, "all_code": "(defpackage :dijkstra-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :dijkstra-test)\n\n(defun priority-queue-push (queue item)\n  \"Push an item into the priority queue and maintain order.\"\n  (merge 'list (list item) queue #'< :key #'car))\n(defun priority-queue-pop (queue)\n  \"Pop the smallest item from the priority queue.\"\n  (values (car queue) (cdr queue)))\n\n;;; dijkstra calculates the shortest paths from the start node to all other nodes in the graph.\n;;; graph is an association list where each node maps to a list of (neighbor . weight) pairs.\n;;; start is the starting node.\n;;; Returns an association list of (node . distance) pairs.\n(defun dijkstra (graph start)\n  (let ((priority-queue (list (cons 0 start)))\n        (distances (loop for (node) in graph collect (cons node most-positive-fixnum) into dists\n                         finally (return (progn (setf (cdr (assoc start dists)) 0) dists)))))\n    (loop while priority-queue\n          do (multiple-value-bind (current-item remaining-queue) (priority-queue-pop priority-queue)\n               (setf priority-queue remaining-queue)\n               (let ((current-distance (car current-item))\n                     (current-node (cdr current-item)))\n                 (when (<= current-distance (cdr (assoc current-node distances)))\n                   (dolist (edge (cdr (assoc current-node graph)))\n                     (let* ((neighbor (car edge))\n                            (weight (cdr edge))\n                            (distance (+ current-distance weight))\n                            (neighbor-distance (cdr (assoc neighbor distances))))\n                       (when (< distance neighbor-distance)\n                         (setf (cdr (assoc neighbor distances)) distance)\n                         (setf priority-queue (priority-queue-push priority-queue (cons distance neighbor))))))))))\n    distances))\n\n\n(defun run-tests ()\n  (let ((graph1 '((a (b . 7) (c . 9) (f . 14))\n                  (b (a . 7) (c . 10) (d . 15))\n                  (c (a . 9) (b . 10) (d . 11) (f . 2))\n                  (d (b . 15) (c . 11) (e . 6))\n                  (e (d . 6) (f . 9))\n                  (f (a . 14) (c . 2) (e . 9))))\n        (graph2 '((x (y . 4) (z . 8))\n                  (y (x . 4) (z . 3))\n                  (z (x . 8) (y . 3)))))\n    \n    ;; Test case 1\n    (let ((result (cl-user::dijkstra graph1 'a)))\n      (assert (equal (cdr (assoc 'a result)) 0) () \"Distance to A should be 0\")\n      (assert (equal (cdr (assoc 'b result)) 7) () \"Distance to B should be 7\")\n      (assert (equal (cdr (assoc 'c result)) 9) () \"Distance to C should be 9\")\n      (assert (equal (cdr (assoc 'd result)) 20) () \"Distance to D should be 20\")\n      (assert (equal (cdr (assoc 'e result)) 20) () \"Distance to E should be 20\")\n      (assert (equal (cdr (assoc 'f result)) 11) () \"Distance to F should be 11\"))\n    \n    ;; Test case 2\n    (let ((result (cl-user::dijkstra graph2 'x)))\n      (assert (equal (cdr (assoc 'x result)) 0) () \"Distance to X should be 0\")\n      (assert (equal (cdr (assoc 'y result)) 4) () \"Distance to Y should be 4\")\n      (assert (equal (cdr (assoc 'z result)) 7) () \"Distance to Z should be 7\"))\n    \n    (format t \"All Dijkstra algorithm tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n;; minimum-delivery-cost calculates the minimum total cost required for trucks to deliver packages to all cities\n;; from the depot and back. The depot is assumed to be city 0.\n;; The cost is calculated as the sum of 2 * cost from depot to each city (round trip).\n;;\n;; Parameters:\n;; - n: integer, number of cities including the depot\n;; - cost-matrix: list of lists, n x n matrix where (nth i (nth j cost-matrix)) is the cost from city i to city j\n;;\n;; Returns:\n;; - integer, minimum total cost for the trucks to deliver packages to every city\n(defun minimum-delivery-cost (n cost-matrix)\n  (let ((total-cost 0))\n    ;; Iterate over all cities excluding the depot (city 0)\n    (loop for i from 1 below n\n          do (incf total-cost (* 2 (nth i (first cost-matrix)))))\n    total-cost))", "test_cases": "", "test_case_results": "Cost Matrix: ((0 1 2 3) (1 0 4 5) (2 4 0 6) (3 5 6 0))\nMinimum Delivery Cost: 12\nCost Matrix: ((0 10) (10 0))\nMinimum Delivery Cost: 20\nCost Matrix: ((0 1 1) (1 0 1) (1 1 0))\nMinimum Delivery Cost: 4", "task_id": 26617, "assertions": "(defpackage :delivery-cost-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :delivery-cost-test)\n\n(defun run-tests ()\n  (assert (= (minimum-delivery-cost 4 '((0 1 2 3) (1 0 4 5) (2 4 0 6) (3 5 6 0))) 12)\n          () \"Test case 1 failed\")\n  (assert (= (minimum-delivery-cost 2 '((0 10) (10 0))) 20)\n          () \"Test case 2 failed\")\n  (assert (= (minimum-delivery-cost 3 '((0 1 1) (1 0 1) (1 1 0))) 4)\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :delivery-cost-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :delivery-cost-test)\n\n(defun run-tests ()\n  (assert (= (minimum-delivery-cost 4 '((0 1 2 3) (1 0 4 5) (2 4 0 6) (3 5 6 0))) 12)\n          () \"Test case 1 failed\")\n  (assert (= (minimum-delivery-cost 2 '((0 10) (10 0))) 20)\n          () \"Test case 2 failed\")\n  (assert (= (minimum-delivery-cost 3 '((0 1 1) (1 0 1) (1 1 0))) 4)\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "minimum-delivery-cost"}, "all_code": "(defpackage :delivery-cost-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :delivery-cost-test)\n\n(defun minimum-delivery-cost (n cost-matrix)\n  (let ((total-cost 0))\n    ;; Iterate over all cities excluding the depot (city 0)\n    (loop for i from 1 below n\n          do (incf total-cost (* 2 (nth i (first cost-matrix)))))\n    total-cost))\n\n\n(defun run-tests ()\n  (assert (= (minimum-delivery-cost 4 '((0 1 2 3) (1 0 4 5) (2 4 0 6) (3 5 6 0))) 12)\n          () \"Test case 1 failed\")\n  (assert (= (minimum-delivery-cost 2 '((0 10) (10 0))) 20)\n          () \"Test case 2 failed\")\n  (assert (= (minimum-delivery-cost 3 '((0 1 1) (1 0 1) (1 1 0))) 4)\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :bit-manipulation\n  (:use :cl)\n  (:export :get-bit :set-bit :clear-bit :update-bit :bit-manipulations))\n\n(in-package :bit-manipulation)\n\n;; get-bit returns the value (0 or 1) of the i-th bit in number n\n(defun get-bit (n i)\n  (logand (ash n (- i)) 1))\n\n;; set-bit sets the i-th bit in number n to 1 and returns the result\n(defun set-bit (n i)\n  (logior n (ash 1 i)))\n\n;; clear-bit clears the i-th bit in number n (sets to 0) and returns the result\n(defun clear-bit (n i)\n  (logand n (lognot (ash 1 i))))\n\n;; update-bit updates the i-th bit in number n to the specified value (0 or 1)\n(defun update-bit (n i bit)\n  (logior (logand n (lognot (ash 1 i))) (ash bit i)))\n\n;; bit-manipulations performs a series of bit operations on a number\n;; operations is a list where each element is either:\n;; ('get i) - gets the i-th bit\n;; ('set i) - sets the i-th bit\n;; ('clear i) - clears the i-th bit\n;; ('update i bit) - updates the i-th bit to specified value\n;; Returns either a list of get results or the final number\n(defun bit-manipulations (num operations)\n  (let ((current-num num)\n        (result '()))\n    (dolist (op operations)\n      (case (car op)\n        ('get (push (get-bit current-num (cadr op)) result))\n        ('set (setf current-num (set-bit current-num (cadr op))))\n        ('clear (setf current-num (clear-bit current-num (cadr op))))\n        ('update (setf current-num (update-bit current-num (cadr op) (caddr op))))))\n    (if (some (lambda (op) (eq (car op) 'get)) operations)\n        (reverse result)  ; reverse to maintain order since we used push\n        current-num)))", "test_cases": "", "test_case_results": "Input number: 5\nOperations: ((GET 0) (GET 1) (GET 2))\nResult: (1 0 1)\n\nInput number: 0\nOperations: ((SET 1) (SET 3) (GET 0) (GET 1) (GET 3))\nResult: (0 1 1)\n\nInput number: 15\nOperations: ((CLEAR 0) (CLEAR 2) (GET 0) (GET 1) (GET 2) (GET 3))\nResult: (0 1 0 1)\n\nInput number: 8\nOperations: ((UPDATE 0 1) (UPDATE 1 1) (GET 0) (GET 1) (GET 3))\nResult: (1 1 1)\n\nInput number: 3\nOperations: ((SET 2) (CLEAR 0) (UPDATE 1 0))\nResult: 4", "task_id": 24277, "assertions": "(defpackage :bit-manipulation-test\n  (:use :cl :bit-manipulation)\n  (:export :run-tests))\n\n(in-package :bit-manipulation-test)\n\n(defun run-tests ()\n  ;; Test case 1: Getting bits from 5 (101)\n  (assert (equal (bit-manipulations 5 '((get 0) (get 1) (get 2))) '(1 0 1))\n          () \"Test case 1 failed: Getting bits from 5\")\n  \n  ;; Test case 2: Setting bits on 0 and getting results\n  (assert (equal (bit-manipulations 0 '((set 1) (set 3) (get 0) (get 1) (get 3))) '(0 1 1))\n          () \"Test case 2 failed: Setting bits on 0\")\n  \n  ;; Test case 3: Clearing bits from 15 (1111) and getting results\n  (assert (equal (bit-manipulations 15 '((clear 0) (clear 2) (get 0) (get 1) (get 2) (get 3))) '(0 1 0 1))\n          () \"Test case 3 failed: Clearing bits from 15\")\n  \n  ;; Test case 4: Updating bits on 8 (1000) and getting results\n  (assert (equal (bit-manipulations 8 '((update 0 1) (update 1 1) (get 0) (get 1) (get 3))) '(1 1 1))\n          () \"Test case 4 failed: Updating bits on 8\")\n  \n  ;; Test case 5: Mixed operations on 3 (11)\n  (assert (= (bit-manipulations 3 '((set 2) (clear 0) (update 1 0))) 4)\n          () \"Test case 5 failed: Mixed operations on 3\")\n  \n  (format t \"All bit manipulation tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :bit-manipulation-test\n  (:use :cl :bit-manipulation)\n  (:export :run-tests))\n\n(in-package :bit-manipulation-test)\n\n(defun run-tests ()\n  ;; Test case 1: Getting bits from 5 (101)\n  (assert (equal (bit-manipulations 5 '((get 0) (get 1) (get 2))) '(1 0 1))\n          () \"Test case 1 failed: Getting bits from 5\")\n  \n  ;; Test case 2: Setting bits on 0 and getting results\n  (assert (equal (bit-manipulations 0 '((set 1) (set 3) (get 0) (get 1) (get 3))) '(0 1 1))\n          () \"Test case 2 failed: Setting bits on 0\")\n  \n  ;; Test case 3: Clearing bits from 15 (1111) and getting results\n  (assert (equal (bit-manipulations 15 '((clear 0) (clear 2) (get 0) (get 1) (get 2) (get 3))) '(0 1 0 1))\n          () \"Test case 3 failed: Clearing bits from 15\")\n  \n  ;; Test case 4: Updating bits on 8 (1000) and getting results\n  (assert (equal (bit-manipulations 8 '((update 0 1) (update 1 1) (get 0) (get 1) (get 3))) '(1 1 1))\n          () \"Test case 4 failed: Updating bits on 8\")\n  \n  ;; Test case 5: Mixed operations on 3 (11)\n  (assert (= (bit-manipulations 3 '((set 2) (clear 0) (update 1 0))) 4)\n          () \"Test case 5 failed: Mixed operations on 3\")\n  \n  (format t \"All bit manipulation tests passed!~%\"))\n\n(run-tests)", "output": "bit-manipulations"}, "all_code": "(defpackage :bit-manipulation-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :bit-manipulation-test)\n\n(defun get-bit (n i)\n  (logand (ash n (- i)) 1))\n\n;; set-bit sets the i-th bit in number n to 1 and returns the result\n(defun set-bit (n i)\n  (logior n (ash 1 i)))\n\n;; clear-bit clears the i-th bit in number n (sets to 0) and returns the result\n(defun clear-bit (n i)\n  (logand n (lognot (ash 1 i))))\n\n;; update-bit updates the i-th bit in number n to the specified value (0 or 1)\n(defun update-bit (n i bit)\n  (logior (logand n (lognot (ash 1 i))) (ash bit i)))\n\n;; bit-manipulations performs a series of bit operations on a number\n;; operations is a list where each element is either:\n;; ('get i) - gets the i-th bit\n;; ('set i) - sets the i-th bit\n;; ('clear i) - clears the i-th bit\n;; ('update i bit) - updates the i-th bit to specified value\n;; Returns either a list of get results or the final number\n(defun bit-manipulations (num operations)\n  (let ((current-num num)\n        (result '()))\n    (dolist (op operations)\n      (case (car op)\n        ('get (push (get-bit current-num (cadr op)) result))\n        ('set (setf current-num (set-bit current-num (cadr op))))\n        ('clear (setf current-num (clear-bit current-num (cadr op))))\n        ('update (setf current-num (update-bit current-num (cadr op) (caddr op))))))\n    (if (some (lambda (op) (eq (car op) 'get)) operations)\n        (reverse result)  ; reverse to maintain order since we used push\n        current-num)))\n\n\n(defun run-tests ()\n  ;; Test case 1: Getting bits from 5 (101)\n  (assert (equal (bit-manipulations 5 '((get 0) (get 1) (get 2))) '(1 0 1))\n          () \"Test case 1 failed: Getting bits from 5\")\n  \n  ;; Test case 2: Setting bits on 0 and getting results\n  (assert (equal (bit-manipulations 0 '((set 1) (set 3) (get 0) (get 1) (get 3))) '(0 1 1))\n          () \"Test case 2 failed: Setting bits on 0\")\n  \n  ;; Test case 3: Clearing bits from 15 (1111) and getting results\n  (assert (equal (bit-manipulations 15 '((clear 0) (clear 2) (get 0) (get 1) (get 2) (get 3))) '(0 1 0 1))\n          () \"Test case 3 failed: Clearing bits from 15\")\n  \n  ;; Test case 4: Updating bits on 8 (1000) and getting results\n  (assert (equal (bit-manipulations 8 '((update 0 1) (update 1 1) (get 0) (get 1) (get 3))) '(1 1 1))\n          () \"Test case 4 failed: Updating bits on 8\")\n  \n  ;; Test case 5: Mixed operations on 3 (11)\n  (assert (= (bit-manipulations 3 '((set 2) (clear 0) (update 1 0))) 4)\n          () \"Test case 5 failed: Mixed operations on 3\")\n  \n  (format t \"All bit manipulation tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; sum-of-digits calculates the sum of the digits in a string representation of a number.\n;;; It converts each character in the string to a digit and sums them up.\n(defun sum-of-digits (s)\n  (loop for d across s\n        sum (digit-char-p d)))\n\n;;; custom-sort-book-ids sorts a list of book IDs based on three criteria:\n;;; 1. The sum of the digits in the ID (ascending)\n;;; 2. The length of the ID (ascending)\n;;; 3. The ID itself (lexicographical order, ascending)\n(defun custom-sort-book-ids (book-ids)\n  (sort (copy-list book-ids)\n        (lambda (x y)\n          (let ((sum-x (sum-of-digits x))\n                (sum-y (sum-of-digits y)))\n            (cond\n              ((< sum-x sum-y) t)\n              ((> sum-x sum-y) nil)\n              (t (let ((len-x (length x))\n                       (len-y (length y)))\n                   (cond\n                     ((< len-x len-y) t)\n                     ((> len-x len-y) nil)\n                     (t (string< x y))))))))))\n\n;;; organize-books processes multiple test cases of book IDs and returns a list of sorted book IDs.\n;;; Each test case consists of a count N and a list of N book IDs.\n;;; The function sorts each list of book IDs using custom-sort-book-ids.\n(defun organize-books (test-cases)\n  (mapcar (lambda (test-case)\n            (let ((n (first test-case))\n                  (book-ids (second test-case)))\n              (custom-sort-book-ids book-ids)))\n          test-cases))", "test_cases": "", "test_case_results": "Input: (3 (123 111 90))\nOutput: (111 123 90)\n\nInput: (4 (100 1 010 001))\nOutput: (1 001 010 100)\n\nInput: (2 (999 111111))\nOutput: (111111 999)", "task_id": 21413, "assertions": "(in-package :cl-user)\n\n(defun test-organize-books ()\n  (let ((test-case1 '(3 (\"123\" \"111\" \"90\")))\n        (test-case2 '(4 (\"100\" \"1\" \"010\" \"001\")))\n        (test-case3 '(2 (\"999\" \"111111\"))))\n    \n    ;; Test case 1\n    (let ((result1 (first (organize-books (list test-case1)))))\n      (assert (equal result1 '(\"111\" \"123\" \"90\")) () \"Test case 1 failed\"))\n    \n    ;; Test case 2\n    (let ((result2 (first (organize-books (list test-case2)))))\n      (assert (equal result2 '(\"1\" \"001\" \"010\" \"100\")) () \"Test case 2 failed\"))\n    \n    ;; Test case 3\n    (let ((result3 (first (organize-books (list test-case3)))))\n      (assert (equal result3 '(\"111111\" \"999\")) () \"Test case 3 failed\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(test-organize-books)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-organize-books ()\n  (let ((test-case1 '(3 (\"123\" \"111\" \"90\")))\n        (test-case2 '(4 (\"100\" \"1\" \"010\" \"001\")))\n        (test-case3 '(2 (\"999\" \"111111\"))))\n    \n    ;; Test case 1\n    (let ((result1 (first (organize-books (list test-case1)))))\n      (assert (equal result1 '(\"111\" \"123\" \"90\")) () \"Test case 1 failed\"))\n    \n    ;; Test case 2\n    (let ((result2 (first (organize-books (list test-case2)))))\n      (assert (equal result2 '(\"1\" \"001\" \"010\" \"100\")) () \"Test case 2 failed\"))\n    \n    ;; Test case 3\n    (let ((result3 (first (organize-books (list test-case3)))))\n      (assert (equal result3 '(\"111111\" \"999\")) () \"Test case 3 failed\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(test-organize-books)", "output": "organize-books"}, "all_code": "(in-package :cl-user)\n\n(defun sum-of-digits (s)\n  (loop for d across s\n        sum (digit-char-p d)))\n\n;;; custom-sort-book-ids sorts a list of book IDs based on three criteria:\n;;; 1. The sum of the digits in the ID (ascending)\n;;; 2. The length of the ID (ascending)\n;;; 3. The ID itself (lexicographical order, ascending)\n(defun custom-sort-book-ids (book-ids)\n  (sort (copy-list book-ids)\n        (lambda (x y)\n          (let ((sum-x (sum-of-digits x))\n                (sum-y (sum-of-digits y)))\n            (cond\n              ((< sum-x sum-y) t)\n              ((> sum-x sum-y) nil)\n              (t (let ((len-x (length x))\n                       (len-y (length y)))\n                   (cond\n                     ((< len-x len-y) t)\n                     ((> len-x len-y) nil)\n                     (t (string< x y))))))))))\n\n;;; organize-books processes multiple test cases of book IDs and returns a list of sorted book IDs.\n;;; Each test case consists of a count N and a list of N book IDs.\n;;; The function sorts each list of book IDs using custom-sort-book-ids.\n(defun organize-books (test-cases)\n  (mapcar (lambda (test-case)\n            (let ((n (first test-case))\n                  (book-ids (second test-case)))\n              (custom-sort-book-ids book-ids)))\n          test-cases))\n\n\n(defun test-organize-books ()\n  (let ((test-case1 '(3 (\"123\" \"111\" \"90\")))\n        (test-case2 '(4 (\"100\" \"1\" \"010\" \"001\")))\n        (test-case3 '(2 (\"999\" \"111111\"))))\n    \n    ;; Test case 1\n    (let ((result1 (first (organize-books (list test-case1)))))\n      (assert (equal result1 '(\"111\" \"123\" \"90\")) () \"Test case 1 failed\"))\n    \n    ;; Test case 2\n    (let ((result2 (first (organize-books (list test-case2)))))\n      (assert (equal result2 '(\"1\" \"001\" \"010\" \"100\")) () \"Test case 2 failed\"))\n    \n    ;; Test case 3\n    (let ((result3 (first (organize-books (list test-case3)))))\n      (assert (equal result3 '(\"111111\" \"999\")) () \"Test case 3 failed\"))\n    \n    (format t \"All tests passed!~%\")))\n\n(test-organize-books)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; filter-words-by-length filters a list of words and returns those that have the specified length.\n; Parameters:\n; - n: a positive integer representing the desired word length\n; - words: a list of strings to be filtered\n; Returns:\n; - a list of strings from the input list that have length exactly equal to n\n(defun filter-words-by-length (n words)\n  (remove-if-not (lambda (word) (= (length word) n)) words))", "test_cases": "", "test_case_results": "Input - Length: 3, Words: (cat dog elephant fox ant)\nOutput: (cat dog fox ant)\n\nInput - Length: 5, Words: (apple banana pear grape kiwi)\nOutput: (apple grape)\n\nInput - Length: 2, Words: (it is a test of)\nOutput: (it is of)", "task_id": 5337, "assertions": "(defpackage :word-filter-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :word-filter-test)\n\n(defun run-tests ()\n  (assert (equal (cl-user::filter-words-by-length 3 '(\"cat\" \"dog\" \"elephant\" \"fox\" \"ant\"))\n                 '(\"cat\" \"dog\" \"fox\" \"ant\"))\n          () \"Test case 1 failed\")\n  (assert (equal (cl-user::filter-words-by-length 5 '(\"apple\" \"banana\" \"pear\" \"grape\" \"kiwi\"))\n                 '(\"apple\" \"grape\"))\n          () \"Test case 2 failed\")\n  (assert (equal (cl-user::filter-words-by-length 2 '(\"it\" \"is\" \"a\" \"test\" \"of\"))\n                 '(\"it\" \"is\" \"of\"))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :word-filter-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :word-filter-test)\n\n(defun run-tests ()\n  (assert (equal (cl-user::filter-words-by-length 3 '(\"cat\" \"dog\" \"elephant\" \"fox\" \"ant\"))\n                 '(\"cat\" \"dog\" \"fox\" \"ant\"))\n          () \"Test case 1 failed\")\n  (assert (equal (cl-user::filter-words-by-length 5 '(\"apple\" \"banana\" \"pear\" \"grape\" \"kiwi\"))\n                 '(\"apple\" \"grape\"))\n          () \"Test case 2 failed\")\n  (assert (equal (cl-user::filter-words-by-length 2 '(\"it\" \"is\" \"a\" \"test\" \"of\"))\n                 '(\"it\" \"is\" \"of\"))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "filter-words-by-length"}, "all_code": "(defpackage :word-filter-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :word-filter-test)\n\n(defun filter-words-by-length (n words)\n  (remove-if-not (lambda (word) (= (length word) n)) words))\n\n\n(defun run-tests ()\n  (assert (equal (cl-user::filter-words-by-length 3 '(\"cat\" \"dog\" \"elephant\" \"fox\" \"ant\"))\n                 '(\"cat\" \"dog\" \"fox\" \"ant\"))\n          () \"Test case 1 failed\")\n  (assert (equal (cl-user::filter-words-by-length 5 '(\"apple\" \"banana\" \"pear\" \"grape\" \"kiwi\"))\n                 '(\"apple\" \"grape\"))\n          () \"Test case 2 failed\")\n  (assert (equal (cl-user::filter-words-by-length 2 '(\"it\" \"is\" \"a\" \"test\" \"of\"))\n                 '(\"it\" \"is\" \"of\"))\n          () \"Test case 3 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; can-arrange-balloons checks if it's possible to arrange balloons such that no two consecutive \n; balloons have the same color at any segment position.\n; Parameters:\n;   n - number of balloons\n;   balloons - list of balloon color segment strings\n; Returns: \"YES\" if arrangement possible, \"NO\" otherwise\n(defun can-arrange-balloons (n balloons)\n  (let ((perms (permutations balloons)))\n    (dolist (perm perms \"NO\")\n      (let ((valid t))\n        (dotimes (i (1- n) (return-from can-arrange-balloons \"YES\"))\n          (dotimes (j (length (first balloons)))\n            (when (char= (char (nth i perm) j) (char (nth (1+ i) perm) j))\n              (setf valid nil)\n              (return)))\n          (unless valid (return)))))))\n\n; Helper function to generate all permutations of a list\n(defun permutations (lst)\n  (if (null lst)\n      (list nil)\n      (mapcan (lambda (x)\n                (mapcar (lambda (y) (cons x y))\n                        (permutations (remove x lst :count 1))))\n              lst)))", "test_cases": "", "test_case_results": "Input: n=3, balloons=(RGB GRB BRG)\nResult: NO\nInput: n=2, balloons=(RR RR)\nResult: NO\nInput: n=3, balloons=(ABC DEF GHI)\nResult: YES\nInput: n=2, balloons=(AB BA)\nResult: YES", "task_id": 2190, "assertions": "(defpackage :balloon-arrangement-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :balloon-arrangement-test)\n\n(defun run-tests ()\n  (assert (string= (can-arrange-balloons 3 '(\"RGB\" \"GRB\" \"BRG\")) \"NO\") \n          () \"Test case 1 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"RR\" \"RR\")) \"NO\") \n          () \"Test case 2 failed\")\n  (assert (string= (can-arrange-balloons 3 '(\"ABC\" \"DEF\" \"GHI\")) \"YES\") \n          () \"Test case 3 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"AB\" \"BA\")) \"YES\") \n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :balloon-arrangement-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :balloon-arrangement-test)\n\n(defun run-tests ()\n  (assert (string= (can-arrange-balloons 3 '(\"RGB\" \"GRB\" \"BRG\")) \"NO\") \n          () \"Test case 1 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"RR\" \"RR\")) \"NO\") \n          () \"Test case 2 failed\")\n  (assert (string= (can-arrange-balloons 3 '(\"ABC\" \"DEF\" \"GHI\")) \"YES\") \n          () \"Test case 3 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"AB\" \"BA\")) \"YES\") \n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "can-arrange-balloons"}, "all_code": "(defpackage :balloon-arrangement-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :balloon-arrangement-test)\n\n(defun can-arrange-balloons (n balloons)\n  (let ((perms (permutations balloons)))\n    (dolist (perm perms \"NO\")\n      (let ((valid t))\n        (dotimes (i (1- n) (return-from can-arrange-balloons \"YES\"))\n          (dotimes (j (length (first balloons)))\n            (when (char= (char (nth i perm) j) (char (nth (1+ i) perm) j))\n              (setf valid nil)\n              (return)))\n          (unless valid (return)))))))\n\n; Helper function to generate all permutations of a list\n(defun permutations (lst)\n  (if (null lst)\n      (list nil)\n      (mapcan (lambda (x)\n                (mapcar (lambda (y) (cons x y))\n                        (permutations (remove x lst :count 1))))\n              lst)))\n\n\n(defun run-tests ()\n  (assert (string= (can-arrange-balloons 3 '(\"RGB\" \"GRB\" \"BRG\")) \"NO\") \n          () \"Test case 1 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"RR\" \"RR\")) \"NO\") \n          () \"Test case 2 failed\")\n  (assert (string= (can-arrange-balloons 3 '(\"ABC\" \"DEF\" \"GHI\")) \"YES\") \n          () \"Test case 3 failed\")\n  (assert (string= (can-arrange-balloons 2 '(\"AB\" \"BA\")) \"YES\") \n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; remove-elements returns a new list with every second element removed.\n; If the length of the original list is odd, the middle element is also removed.\n; The function uses Common Lisp's loop construct to filter elements and handle the middle element removal.\n(defun remove-elements (lst)\n  (let* ((filtered-list (loop for element in lst\n                              for i from 0\n                              when (evenp i)\n                              collect element))\n         (filtered-length (length filtered-list))\n         (original-length (length lst)))\n    (if (oddp original-length)\n        (let ((middle-pos (floor filtered-length 2)))\n          (append (subseq filtered-list 0 middle-pos)\n                  (subseq filtered-list (1+ middle-pos))))\n        filtered-list)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5)\nOutput: (1 5)\n\nInput: (1 2 3 4 5 6 7 8)\nOutput: (1 3 5 7)\n\nInput: NIL\nOutput: NIL\n\nInput: (1)\nOutput: NIL\n\nInput: (1 2 3)\nOutput: (1)", "task_id": 28467, "assertions": "(in-package :cl-user)\n\n(defun test-remove-elements ()\n  (assert (equal (remove-elements '(1 2 3 4 5)) '(1 5)) () \"Test case 1 failed\")\n  (assert (equal (remove-elements '(1 2 3 4 5 6 7 8)) '(1 3 5 7)) () \"Test case 2 failed\")\n  (assert (equal (remove-elements nil) nil) () \"Test case 3 failed\")\n  (assert (equal (remove-elements '(1)) nil) () \"Test case 4 failed\")\n  (assert (equal (remove-elements '(1 2 3)) '(1)) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-remove-elements)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-remove-elements ()\n  (assert (equal (remove-elements '(1 2 3 4 5)) '(1 5)) () \"Test case 1 failed\")\n  (assert (equal (remove-elements '(1 2 3 4 5 6 7 8)) '(1 3 5 7)) () \"Test case 2 failed\")\n  (assert (equal (remove-elements nil) nil) () \"Test case 3 failed\")\n  (assert (equal (remove-elements '(1)) nil) () \"Test case 4 failed\")\n  (assert (equal (remove-elements '(1 2 3)) '(1)) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-remove-elements)", "output": "remove-elements"}, "all_code": "(in-package :cl-user)\n\n(defun remove-elements (lst)\n  (let* ((filtered-list (loop for element in lst\n                              for i from 0\n                              when (evenp i)\n                              collect element))\n         (filtered-length (length filtered-list))\n         (original-length (length lst)))\n    (if (oddp original-length)\n        (let ((middle-pos (floor filtered-length 2)))\n          (append (subseq filtered-list 0 middle-pos)\n                  (subseq filtered-list (1+ middle-pos))))\n        filtered-list)))\n\n\n(defun test-remove-elements ()\n  (assert (equal (remove-elements '(1 2 3 4 5)) '(1 5)) () \"Test case 1 failed\")\n  (assert (equal (remove-elements '(1 2 3 4 5 6 7 8)) '(1 3 5 7)) () \"Test case 2 failed\")\n  (assert (equal (remove-elements nil) nil) () \"Test case 3 failed\")\n  (assert (equal (remove-elements '(1)) nil) () \"Test case 4 failed\")\n  (assert (equal (remove-elements '(1 2 3)) '(1)) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-remove-elements)", "exec_outcome": "PASSED"}
{"code": "(defpackage :distance-utils\n  (:use :cl)\n  (:export :kth-smallest-pair-distance))\n\n(in-package :distance-utils)\n\n;;; kth-smallest-pair-distance calculates the kth smallest pair distance in a list of numbers.\n;;; The function first sorts the input list, then computes all possible pair distances,\n;;; sorts these distances, and finally returns the kth smallest one (1-based index).\n;;; \n;;; Parameters:\n;;;   arr - a list of numbers\n;;;   k - an integer representing the 1-based index of the desired smallest distance\n;;;\n;;; Returns:\n;;;   The kth smallest pair distance as a number\n(defun kth-smallest-pair-distance (arr k)\n  (let* ((sorted-arr (sort (copy-list arr) #'<))\n         (n (length sorted-arr))\n         (pair-distances '()))\n    (dotimes (i n)\n      (do ((j (1+ i) (1+ j)))\n          ((>= j n))\n        (push (abs (- (nth i sorted-arr) (nth j sorted-arr))) pair-distances)))\n    (nth (1- k) (sort pair-distances #'<))))", "test_cases": "", "test_case_results": "Test case 1: Small array, k=1\nInput array: (1 3 1), k: 1\nResult: 0\n\nTest case 2: Small array, k=2\nInput array: (1 3 1), k: 2\nResult: 2\n\nTest case 3: Larger array, k=3\nInput array: (6 2 9 1 7), k: 3\nResult: 2\n\nTest case 4: All elements equal, k=2\nInput array: (5 5 5 5), k: 2\nResult: 0", "task_id": 6661, "assertions": "(defpackage :distance-utils-test\n  (:use :cl :distance-utils)\n  (:export :run-tests))\n\n(in-package :distance-utils-test)\n\n(defun run-tests ()\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 1) 0) () \"Test case 1 failed: Expected 0\")\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 2) 2) () \"Test case 2 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(6 2 9 1 7) 3) 2) () \"Test case 3 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(5 5 5 5) 2) 0) () \"Test case 4 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :distance-utils-test\n  (:use :cl :distance-utils)\n  (:export :run-tests))\n\n(in-package :distance-utils-test)\n\n(defun run-tests ()\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 1) 0) () \"Test case 1 failed: Expected 0\")\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 2) 2) () \"Test case 2 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(6 2 9 1 7) 3) 2) () \"Test case 3 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(5 5 5 5) 2) 0) () \"Test case 4 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "kth-smallest-pair-distance"}, "all_code": "(defpackage :distance-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :distance-utils-test)\n\n(defun kth-smallest-pair-distance (arr k)\n  (let* ((sorted-arr (sort (copy-list arr) #'<))\n         (n (length sorted-arr))\n         (pair-distances '()))\n    (dotimes (i n)\n      (do ((j (1+ i) (1+ j)))\n          ((>= j n))\n        (push (abs (- (nth i sorted-arr) (nth j sorted-arr))) pair-distances)))\n    (nth (1- k) (sort pair-distances #'<))))\n\n\n(defun run-tests ()\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 1) 0) () \"Test case 1 failed: Expected 0\")\n  (assert (= (kth-smallest-pair-distance '(1 3 1) 2) 2) () \"Test case 2 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(6 2 9 1 7) 3) 2) () \"Test case 3 failed: Expected 2\")\n  (assert (= (kth-smallest-pair-distance '(5 5 5 5) 2) 0) () \"Test case 4 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n(defun min-additional-connections (n connections)\n  (let ((graph (make-hash-table))\n        (visited (make-hash-table))\n        (components 0))\n    \n    ; Build the adjacency list\n    (dolist (conn connections)\n      (let ((a (car conn))\n            (b (cadr conn)))\n        (push b (gethash a graph '()))\n        (push a (gethash b graph '()))))\n    \n    ; Define a local DFS function\n    (labels ((dfs (node)\n               (let ((stack (list node)))\n                 (loop while stack do\n                   (let ((curr (pop stack)))\n                     (dolist (neighbor (gethash curr graph '()))\n                       (unless (gethash neighbor visited)\n                         (setf (gethash neighbor visited) t)\n                         (push neighbor stack))))))))\n      \n      ; Iterate over all nodes to find connected components\n      (loop for node from 1 to n do\n        (unless (gethash node visited)\n          (setf (gethash node visited) t)\n          (dfs node)\n          (incf components)))\n      \n      ; The result is the number of components minus one\n      (1- components))))", "test_cases": "", "test_case_results": "Input: n=4, connections=((1 2) (2 3))\nResult: 1\nInput: n=5, connections=((1 2) (3 4))\nResult: 2\nInput: n=3, connections=((1 2) (2 3) (1 3))\nResult: 0", "task_id": 306, "assertions": "(in-package :cl-user)\n\n(defun test-min-additional-connections ()\n  (assert (= (min-additional-connections 4 '((1 2) (2 3))) 1)\n          () \"Test case 1 failed: Expected 1 additional connection\")\n  (assert (= (min-additional-connections 5 '((1 2) (3 4))) 2)\n          () \"Test case 2 failed: Expected 2 additional connections\")\n  (assert (= (min-additional-connections 3 '((1 2) (2 3) (1 3))) 0)\n          () \"Test case 3 failed: Expected 0 additional connections\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-additional-connections)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-min-additional-connections ()\n  (assert (= (min-additional-connections 4 '((1 2) (2 3))) 1)\n          () \"Test case 1 failed: Expected 1 additional connection\")\n  (assert (= (min-additional-connections 5 '((1 2) (3 4))) 2)\n          () \"Test case 2 failed: Expected 2 additional connections\")\n  (assert (= (min-additional-connections 3 '((1 2) (2 3) (1 3))) 0)\n          () \"Test case 3 failed: Expected 0 additional connections\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-additional-connections)", "output": "min-additional-connections"}, "all_code": "(in-package :cl-user)\n\n(defun min-additional-connections (n connections)\n  (let ((graph (make-hash-table))\n        (visited (make-hash-table))\n        (components 0))\n    \n    ; Build the adjacency list\n    (dolist (conn connections)\n      (let ((a (car conn))\n            (b (cadr conn)))\n        (push b (gethash a graph '()))\n        (push a (gethash b graph '()))))\n    \n    ; Define a local DFS function\n    (labels ((dfs (node)\n               (let ((stack (list node)))\n                 (loop while stack do\n                   (let ((curr (pop stack)))\n                     (dolist (neighbor (gethash curr graph '()))\n                       (unless (gethash neighbor visited)\n                         (setf (gethash neighbor visited) t)\n                         (push neighbor stack))))))))\n      \n      ; Iterate over all nodes to find connected components\n      (loop for node from 1 to n do\n        (unless (gethash node visited)\n          (setf (gethash node visited) t)\n          (dfs node)\n          (incf components)))\n      \n      ; The result is the number of components minus one\n      (1- components))))\n\n\n(defun test-min-additional-connections ()\n  (assert (= (min-additional-connections 4 '((1 2) (2 3))) 1)\n          () \"Test case 1 failed: Expected 1 additional connection\")\n  (assert (= (min-additional-connections 5 '((1 2) (3 4))) 2)\n          () \"Test case 2 failed: Expected 2 additional connections\")\n  (assert (= (min-additional-connections 3 '((1 2) (2 3) (1 3))) 0)\n          () \"Test case 3 failed: Expected 0 additional connections\")\n  (format t \"All tests passed!~%\"))\n\n(test-min-additional-connections)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; has-all-unique-chars checks if a string contains all unique characters.\n; The check is case insensitive and ignores spaces.\n; It returns T if all characters are unique, NIL otherwise.\n(defun has-all-unique-chars (s)\n  (let* ((clean-str (remove #\\Space (string-downcase s)))\n         (len (length clean-str)))\n    (loop for i from 0 below len\n          do (loop for j from (1+ i) below len\n                   when (char= (char clean-str i) (char clean-str j))\n                   do (return-from has-all-unique-chars nil)))\n    t))", "test_cases": "", "test_case_results": "Input: \"abcde\"\nResult: T\n\nInput: \"hello\"\nResult: NIL\n\nInput: \"AaBbCc\"\nResult: NIL\n\nInput: \"  a b c  \"\nResult: T\n\nInput: \"\"\nResult: T", "task_id": 29007, "assertions": "(defpackage :unique-chars-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :unique-chars-test)\n\n(defun run-tests ()\n  (assert (has-all-unique-chars \"abcde\") () \"Test failed: 'abcde' should return T\")\n  (assert (not (has-all-unique-chars \"hello\")) () \"Test failed: 'hello' should return NIL\")\n  (assert (not (has-all-unique-chars \"AaBbCc\")) () \"Test failed: 'AaBbCc' should return NIL\")\n  (assert (has-all-unique-chars \"  a b c  \") () \"Test failed: '  a b c  ' should return T\")\n  (assert (has-all-unique-chars \"\") () \"Test failed: empty string should return T\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :unique-chars-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :unique-chars-test)\n\n(defun run-tests ()\n  (assert (has-all-unique-chars \"abcde\") () \"Test failed: 'abcde' should return T\")\n  (assert (not (has-all-unique-chars \"hello\")) () \"Test failed: 'hello' should return NIL\")\n  (assert (not (has-all-unique-chars \"AaBbCc\")) () \"Test failed: 'AaBbCc' should return NIL\")\n  (assert (has-all-unique-chars \"  a b c  \") () \"Test failed: '  a b c  ' should return T\")\n  (assert (has-all-unique-chars \"\") () \"Test failed: empty string should return T\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "has-all-unique-chars"}, "all_code": "(defpackage :unique-chars-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :unique-chars-test)\n\n(defun has-all-unique-chars (s)\n  (let* ((clean-str (remove #\\Space (string-downcase s)))\n         (len (length clean-str)))\n    (loop for i from 0 below len\n          do (loop for j from (1+ i) below len\n                   when (char= (char clean-str i) (char clean-str j))\n                   do (return-from has-all-unique-chars nil)))\n    t))\n\n\n(defun run-tests ()\n  (assert (has-all-unique-chars \"abcde\") () \"Test failed: 'abcde' should return T\")\n  (assert (not (has-all-unique-chars \"hello\")) () \"Test failed: 'hello' should return NIL\")\n  (assert (not (has-all-unique-chars \"AaBbCc\")) () \"Test failed: 'AaBbCc' should return NIL\")\n  (assert (has-all-unique-chars \"  a b c  \") () \"Test failed: '  a b c  ' should return T\")\n  (assert (has-all-unique-chars \"\") () \"Test failed: empty string should return T\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; lexicographically-smallest-string finds the smallest string in a list of strings,\n;; considering both the original string and its reverse for each string.\n;; The function takes a list of test cases, where each test case is a cons cell (n . strings),\n;; with n being the number of strings and strings being the list of strings.\n;; It returns a list of the smallest strings for each test case.\n(defun lexicographically-smallest-string (test-cases)\n  (mapcar \n    (lambda (case)\n      (let* ((strings (cdr case))\n             (min-string (reduce \n                          (lambda (a b) \n                            (let ((a-min (if (string< a (reverse a)) a (reverse a)))\n                                  (b-min (if (string< b (reverse b)) b (reverse b))))\n                              (if (string< a-min b-min) a-min b-min)))\n                          strings\n                          :initial-value (car strings))))\n        min-string))\n    test-cases))", "test_cases": "", "test_case_results": "Test Cases:\nInput Strings: (abc def ghi)\nSmallest String: abc\nInput Strings: (cba fed)\nSmallest String: abc\nInput Strings: (xyz zyx abc cba)\nSmallest String: abc", "task_id": 24844, "assertions": "(defpackage :string-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (let ((test-case1 '((3 . (\"abc\" \"def\" \"ghi\"))))\n        (test-case2 '((2 . (\"cba\" \"fed\"))))\n        (test-case3 '((4 . (\"xyz\" \"zyx\" \"abc\" \"cba\")))))\n    \n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case1)) \"abc\")\n            () \"Test case 1 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case2)) \"abc\")\n            () \"Test case 2 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case3)) \"abc\")\n            () \"Test case 3 failed: Expected 'abc'\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-utils-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun run-tests ()\n  (let ((test-case1 '((3 . (\"abc\" \"def\" \"ghi\"))))\n        (test-case2 '((2 . (\"cba\" \"fed\"))))\n        (test-case3 '((4 . (\"xyz\" \"zyx\" \"abc\" \"cba\")))))\n    \n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case1)) \"abc\")\n            () \"Test case 1 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case2)) \"abc\")\n            () \"Test case 2 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case3)) \"abc\")\n            () \"Test case 3 failed: Expected 'abc'\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "lexicographically-smallest-string"}, "all_code": "(defpackage :string-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-utils-test)\n\n(defun lexicographically-smallest-string (test-cases)\n  (mapcar \n    (lambda (case)\n      (let* ((strings (cdr case))\n             (min-string (reduce \n                          (lambda (a b) \n                            (let ((a-min (if (string< a (reverse a)) a (reverse a)))\n                                  (b-min (if (string< b (reverse b)) b (reverse b))))\n                              (if (string< a-min b-min) a-min b-min)))\n                          strings\n                          :initial-value (car strings))))\n        min-string))\n    test-cases))\n\n\n(defun run-tests ()\n  (let ((test-case1 '((3 . (\"abc\" \"def\" \"ghi\"))))\n        (test-case2 '((2 . (\"cba\" \"fed\"))))\n        (test-case3 '((4 . (\"xyz\" \"zyx\" \"abc\" \"cba\")))))\n    \n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case1)) \"abc\")\n            () \"Test case 1 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case2)) \"abc\")\n            () \"Test case 2 failed: Expected 'abc'\")\n    (assert (string= (car (cl-user::lexicographically-smallest-string test-case3)) \"abc\")\n            () \"Test case 3 failed: Expected 'abc'\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; check-string checks if the string s contains exactly two 'A's and exactly three 'B's.\n; The input string must be exactly 5 characters long and consist only of characters 'A', 'B', or 'C'.\n; Returns \"YES\" if the conditions are met, otherwise \"NO\".\n(defun check-string (s)\n  (if (and (= (count #\\A s) 2)\n           (= (count #\\B s) 3))\n      \"YES\"\n      \"NO\"))", "test_cases": "", "test_case_results": "Input: AABBB\nResult: YES\nInput: ABABB\nResult: YES\nInput: BBABA\nResult: YES\nInput: ABCAB\nResult: NO\nInput: AAAAA\nResult: NO\nInput: BBBBB\nResult: NO\nInput: CCCCC\nResult: NO", "task_id": 17681, "assertions": "(defpackage :check-string-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :check-string-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user:check-string \"AABBB\") \"YES\") () \"AABBB should return YES\")\n  (assert (string= (cl-user:check-string \"ABABB\") \"YES\") () \"ABABB should return YES\")\n  (assert (string= (cl-user:check-string \"BBABA\") \"YES\") () \"BBABA should return YES\")\n  (assert (string= (cl-user:check-string \"ABCAB\") \"NO\") () \"ABCAB should return NO\")\n  (assert (string= (cl-user:check-string \"AAAAA\") \"NO\") () \"AAAAA should return NO\")\n  (assert (string= (cl-user:check-string \"BBBBB\") \"NO\") () \"BBBBB should return NO\")\n  (assert (string= (cl-user:check-string \"CCCCC\") \"NO\") () \"CCCCC should return NO\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :check-string-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :check-string-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user:check-string \"AABBB\") \"YES\") () \"AABBB should return YES\")\n  (assert (string= (cl-user:check-string \"ABABB\") \"YES\") () \"ABABB should return YES\")\n  (assert (string= (cl-user:check-string \"BBABA\") \"YES\") () \"BBABA should return YES\")\n  (assert (string= (cl-user:check-string \"ABCAB\") \"NO\") () \"ABCAB should return NO\")\n  (assert (string= (cl-user:check-string \"AAAAA\") \"NO\") () \"AAAAA should return NO\")\n  (assert (string= (cl-user:check-string \"BBBBB\") \"NO\") () \"BBBBB should return NO\")\n  (assert (string= (cl-user:check-string \"CCCCC\") \"NO\") () \"CCCCC should return NO\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "check-string"}, "all_code": "(defpackage :check-string-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :check-string-test)\n\n(defun check-string (s)\n  (if (and (= (count #\\A s) 2)\n           (= (count #\\B s) 3))\n      \"YES\"\n      \"NO\"))\n\n\n(defun run-tests ()\n  (assert (string= (check-string \"AABBB\") \"YES\") () \"AABBB should return YES\")\n  (assert (string= (check-string \"ABABB\") \"YES\") () \"ABABB should return YES\")\n  (assert (string= (check-string \"BBABA\") \"YES\") () \"BBABA should return YES\")\n  (assert (string= (check-string \"ABCAB\") \"NO\") () \"ABCAB should return NO\")\n  (assert (string= (check-string \"AAAAA\") \"NO\") () \"AAAAA should return NO\")\n  (assert (string= (check-string \"BBBBB\") \"NO\") () \"BBBBB should return NO\")\n  (assert (string= (check-string \"CCCCC\") \"NO\") () \"CCCCC should return NO\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; get-distance-to-nearest-mineral calculates the Manhattan distance from the cell (r, c) \n;;; to the nearest cell with a mineral deposit (which contains 1).\n;;; grid: a 2D list representing the grid\n;;; n: number of rows in the grid\n;;; m: number of columns in the grid\n;;; r: current row position\n;;; c: current column position\n;;; Returns the minimum Manhattan distance to the nearest mineral deposit.\n(defun get-distance-to-nearest-mineral (grid n m r c)\n  (let ((min-distance most-positive-fixnum))\n    (dotimes (i n min-distance)\n      (dotimes (j m)\n        (when (= (nth j (nth i grid)) 1)\n          (let ((distance (+ (abs (- r i)) (abs (- c j)))))\n            (when (< distance min-distance)\n              (setf min-distance distance))))))))\n\n;;; process-queries processes a list of queries on the grid.\n;;; n: number of rows in the grid\n;;; m: number of columns in the grid\n;;; grid: a 2D list representing the grid\n;;; queries: a list of queries where each query is either (1 row col) for movement or (2) for distance calculation\n;;; Returns a list of distances calculated for type 2 queries.\n(defun process-queries (n m grid queries)\n  (let ((results '())\n        (current-position '(0 0)))\n    (dolist (query queries (reverse results))\n      (if (= (first query) 1)\n          (setf current-position (list (second query) (third query)))\n          (let ((distance (get-distance-to-nearest-mineral grid n m (first current-position) (second current-position))))\n            (push distance results))))))", "test_cases": "", "test_case_results": "Grid: ((0 1 0) (1 0 0) (0 0 1))\nQueries: ((1 1 1) (2) (1 2 2) (2))\nResults: (1 0)", "task_id": 3896, "assertions": "(defpackage :mineral-distance-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :mineral-distance-test)\n\n(defun run-tests ()\n  (let* ((grid '((0 1 0)\n                 (1 0 0)\n                 (0 0 1)))\n         (n 3)\n         (m 3)\n         (queries '((1 1 1) \n                    (2) \n                    (1 2 2) \n                    (2))))\n    (assert (equal (process-queries n m grid queries) '(1 0)) \n            () \"Test failed: Expected results (1 0) not matched\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :mineral-distance-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :mineral-distance-test)\n\n(defun run-tests ()\n  (let* ((grid '((0 1 0)\n                 (1 0 0)\n                 (0 0 1)))\n         (n 3)\n         (m 3)\n         (queries '((1 1 1) \n                    (2) \n                    (1 2 2) \n                    (2))))\n    (assert (equal (process-queries n m grid queries) '(1 0)) \n            () \"Test failed: Expected results (1 0) not matched\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "process-queries"}, "all_code": "(defpackage :mineral-distance-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :mineral-distance-test)\n\n(defun get-distance-to-nearest-mineral (grid n m r c)\n  (let ((min-distance most-positive-fixnum))\n    (dotimes (i n min-distance)\n      (dotimes (j m)\n        (when (= (nth j (nth i grid)) 1)\n          (let ((distance (+ (abs (- r i)) (abs (- c j)))))\n            (when (< distance min-distance)\n              (setf min-distance distance))))))))\n\n;;; process-queries processes a list of queries on the grid.\n;;; n: number of rows in the grid\n;;; m: number of columns in the grid\n;;; grid: a 2D list representing the grid\n;;; queries: a list of queries where each query is either (1 row col) for movement or (2) for distance calculation\n;;; Returns a list of distances calculated for type 2 queries.\n(defun process-queries (n m grid queries)\n  (let ((results '())\n        (current-position '(0 0)))\n    (dolist (query queries (reverse results))\n      (if (= (first query) 1)\n          (setf current-position (list (second query) (third query)))\n          (let ((distance (get-distance-to-nearest-mineral grid n m (first current-position) (second current-position))))\n            (push distance results))))))\n\n\n(defun run-tests ()\n  (let* ((grid '((0 1 0)\n                 (1 0 0)\n                 (0 0 1)))\n         (n 3)\n         (m 3)\n         (queries '((1 1 1) \n                    (2) \n                    (1 2 2) \n                    (2))))\n    (assert (equal (process-queries n m grid queries) '(1 0)) \n            () \"Test failed: Expected results (1 0) not matched\"))\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :product-utils\n  (:use :cl)\n  (:export :product-except-self))\n\n(in-package :product-utils)\n\n(defun product-except-self (nums)\n  (let ((length (length nums)))\n    (if (zerop length)\n        '()\n        (let ((result (make-list length :initial-element 1)))\n          ;; Calculate prefix products\n          (let ((prefix-product 1))\n            (dotimes (i length)\n              (setf (nth i result) prefix-product)\n              (setf prefix-product (* prefix-product (nth i nums)))))\n          ;; Calculate suffix products and multiply with prefix products\n          (let ((suffix-product 1))\n            (loop for i from (1- length) downto 0 do\n              (setf (nth i result) (* (nth i result) suffix-product))\n              (setf suffix-product (* suffix-product (nth i nums)))))\n          result))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4)\nResult: (24 12 8 6)\n\nInput: (5 6 7 0)\nResult: (0 0 0 210)\n\nInput: (0 0 0 0)\nResult: (0 0 0 0)\n\nInput: (1 1 1 1)\nResult: (1 1 1 1)\n\nInput: NIL\nResult: NIL", "task_id": 17344, "assertions": "(defpackage :product-utils-test\n  (:use :cl :product-utils)\n  (:export :run-tests))\n\n(in-package :product-utils-test)\n\n(defun run-tests ()\n  (assert (equal (product-except-self '(1 2 3 4)) '(24 12 8 6)) () \"Test case 1 failed\")\n  (assert (equal (product-except-self '(5 6 7 0)) '(0 0 0 210)) () \"Test case 2 failed\")\n  (assert (equal (product-except-self '(0 0 0 0)) '(0 0 0 0)) () \"Test case 3 failed\")\n  (assert (equal (product-except-self '(1 1 1 1)) '(1 1 1 1)) () \"Test case 4 failed\")\n  (assert (equal (product-except-self '()) '()) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :product-utils-test\n  (:use :cl :product-utils)\n  (:export :run-tests))\n\n(in-package :product-utils-test)\n\n(defun run-tests ()\n  (assert (equal (product-except-self '(1 2 3 4)) '(24 12 8 6)) () \"Test case 1 failed\")\n  (assert (equal (product-except-self '(5 6 7 0)) '(0 0 0 210)) () \"Test case 2 failed\")\n  (assert (equal (product-except-self '(0 0 0 0)) '(0 0 0 0)) () \"Test case 3 failed\")\n  (assert (equal (product-except-self '(1 1 1 1)) '(1 1 1 1)) () \"Test case 4 failed\")\n  (assert (equal (product-except-self '()) '()) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "product-except-self"}, "all_code": "(defpackage :product-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :product-utils-test)\n\n(defun product-except-self (nums)\n  (let ((length (length nums)))\n    (if (zerop length)\n        '()\n        (let ((result (make-list length :initial-element 1)))\n          ;; Calculate prefix products\n          (let ((prefix-product 1))\n            (dotimes (i length)\n              (setf (nth i result) prefix-product)\n              (setf prefix-product (* prefix-product (nth i nums)))))\n          ;; Calculate suffix products and multiply with prefix products\n          (let ((suffix-product 1))\n            (loop for i from (1- length) downto 0 do\n              (setf (nth i result) (* (nth i result) suffix-product))\n              (setf suffix-product (* suffix-product (nth i nums)))))\n          result))))\n\n\n(defun run-tests ()\n  (assert (equal (product-except-self '(1 2 3 4)) '(24 12 8 6)) () \"Test case 1 failed\")\n  (assert (equal (product-except-self '(5 6 7 0)) '(0 0 0 210)) () \"Test case 2 failed\")\n  (assert (equal (product-except-self '(0 0 0 0)) '(0 0 0 0)) () \"Test case 3 failed\")\n  (assert (equal (product-except-self '(1 1 1 1)) '(1 1 1 1)) () \"Test case 4 failed\")\n  (assert (equal (product-except-self '()) '()) () \"Test case 5 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; choose-k-integers determines if it's possible to choose k integers from the array such that \n;; their sum is greater than or equal to m. If possible, it returns the chosen k integers; \n;; otherwise, it returns -1.\n;; The function first sorts the array in descending order and then selects the first k elements.\n;; It checks if their sum meets or exceeds m.\n(defun choose-k-integers (n k m arr)\n  (let* ((sorted-arr (sort (copy-list arr) #'>))\n         (chosen (subseq sorted-arr 0 k))\n         (sum (apply #'+ chosen)))\n    (if (>= sum m)\n        chosen\n        -1)))", "test_cases": "", "test_case_results": "Input: n=5, k=2, m=10, arr=(5 8 3 1 6)\nResult: (8 6)\nInput: n=4, k=3, m=20, arr=(10 5 2 1)\nResult: -1\nInput: n=6, k=4, m=15, arr=(4 6 2 7 3 1)\nResult: (7 6 4 3)\nInput: n=3, k=2, m=5, arr=(1 2 3)\nResult: (3 2)", "task_id": 18224, "assertions": "(in-package :cl-user)\n\n(defun test-choose-k-integers ()\n  (assert (equal (choose-k-integers 5 2 10 '(5 8 3 1 6)) '(8 6))\n          () \"Test case 1 failed: Expected (8 6)\")\n  (assert (equal (choose-k-integers 4 3 20 '(10 5 2 1)) -1)\n          () \"Test case 2 failed: Expected -1\")\n  (assert (equal (choose-k-integers 6 4 15 '(4 6 2 7 3 1)) '(7 6 4 3))\n          () \"Test case 3 failed: Expected (7 6 4 3)\")\n  (assert (equal (choose-k-integers 3 2 5 '(1 2 3)) '(3 2))\n          () \"Test case 4 failed: Expected (3 2)\")\n  (format t \"All tests passed!~%\"))\n\n(test-choose-k-integers)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-choose-k-integers ()\n  (assert (equal (choose-k-integers 5 2 10 '(5 8 3 1 6)) '(8 6))\n          () \"Test case 1 failed: Expected (8 6)\")\n  (assert (equal (choose-k-integers 4 3 20 '(10 5 2 1)) -1)\n          () \"Test case 2 failed: Expected -1\")\n  (assert (equal (choose-k-integers 6 4 15 '(4 6 2 7 3 1)) '(7 6 4 3))\n          () \"Test case 3 failed: Expected (7 6 4 3)\")\n  (assert (equal (choose-k-integers 3 2 5 '(1 2 3)) '(3 2))\n          () \"Test case 4 failed: Expected (3 2)\")\n  (format t \"All tests passed!~%\"))\n\n(test-choose-k-integers)", "output": "choose-k-integers"}, "all_code": "(in-package :cl-user)\n\n(defun choose-k-integers (n k m arr)\n  (let* ((sorted-arr (sort (copy-list arr) #'>))\n         (chosen (subseq sorted-arr 0 k))\n         (sum (apply #'+ chosen)))\n    (if (>= sum m)\n        chosen\n        -1)))\n\n\n(defun test-choose-k-integers ()\n  (assert (equal (choose-k-integers 5 2 10 '(5 8 3 1 6)) '(8 6))\n          () \"Test case 1 failed: Expected (8 6)\")\n  (assert (equal (choose-k-integers 4 3 20 '(10 5 2 1)) -1)\n          () \"Test case 2 failed: Expected -1\")\n  (assert (equal (choose-k-integers 6 4 15 '(4 6 2 7 3 1)) '(7 6 4 3))\n          () \"Test case 3 failed: Expected (7 6 4 3)\")\n  (assert (equal (choose-k-integers 3 2 5 '(1 2 3)) '(3 2))\n          () \"Test case 4 failed: Expected (3 2)\")\n  (format t \"All tests passed!~%\"))\n\n(test-choose-k-integers)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; is-prime-p checks if a given number is a prime.\n; It returns T if the number is prime, NIL otherwise.\n; The function uses trial division optimized for primes greater than 3.\n(defun is-prime-p (num)\n  (cond\n    ((<= num 1) nil)\n    ((<= num 3) t)\n    ((or (zerop (mod num 2)) (zerop (mod num 3))) nil)\n    (t (loop for i from 5 to (isqrt num) by 6\n             when (or (zerop (mod num i))\n                      (zerop (mod num (+ i 2))))\n             return nil\n             finally (return t)))))\n\n; prime-pairs-sequence generates a list of n pairs of consecutive prime numbers that are exactly 2 apart (twin primes).\n; It returns a list of cons cells (pairs) where each pair consists of two primes (p, p+2).\n(defun prime-pairs-sequence (n)\n  (let ((primes '())\n        (prime-pairs '())\n        (current 2)) ; start from the smallest prime number\n    (loop while (< (length prime-pairs) n) do\n      (when (is-prime-p current)\n        (push current primes)\n        (when (>= (length primes) 2)\n          (let ((last-prime (first primes))\n                (second-last-prime (second primes)))\n            (when (= last-prime (+ second-last-prime 2))\n              (push (cons second-last-prime last-prime) prime-pairs)))))\n      (incf current))\n    (reverse prime-pairs)))", "test_cases": "", "test_case_results": "Input n: 1\nPrime pairs: ((3 . 5))\nInput n: 3\nPrime pairs: ((3 . 5) (5 . 7) (11 . 13))\nInput n: 5\nPrime pairs: ((3 . 5) (5 . 7) (11 . 13) (17 . 19) (29 . 31))", "task_id": 27806, "assertions": "(defpackage :prime-pairs-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :prime-pairs-test)\n\n(defun run-tests ()\n  (let ((test-case-1 (prime-pairs-sequence 1))\n        (test-case-3 (prime-pairs-sequence 3))\n        (test-case-5 (prime-pairs-sequence 5)))\n    \n    (assert (equal test-case-1 '((3 . 5))) () \"Failed test case 1\")\n    (assert (equal test-case-3 '((3 . 5) (5 . 7) (11 . 13))) () \"Failed test case 3\")\n    (assert (equal test-case-5 '((3 . 5) (5 . 7) (11 . 13) (17 . 19) (29 . 31))) () \"Failed test case 5\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :prime-pairs-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :prime-pairs-test)\n\n(defun run-tests ()\n  (let ((test-case-1 (prime-pairs-sequence 1))\n        (test-case-3 (prime-pairs-sequence 3))\n        (test-case-5 (prime-pairs-sequence 5)))\n    \n    (assert (equal test-case-1 '((3 . 5))) () \"Failed test case 1\")\n    (assert (equal test-case-3 '((3 . 5) (5 . 7) (11 . 13))) () \"Failed test case 3\")\n    (assert (equal test-case-5 '((3 . 5) (5 . 7) (11 . 13) (17 . 19) (29 . 31))) () \"Failed test case 5\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "prime-pairs-sequence"}, "all_code": "(defpackage :prime-pairs-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :prime-pairs-test)\n\n(defun is-prime-p (num)\n  (cond\n    ((<= num 1) nil)\n    ((<= num 3) t)\n    ((or (zerop (mod num 2)) (zerop (mod num 3))) nil)\n    (t (loop for i from 5 to (isqrt num) by 6\n             when (or (zerop (mod num i))\n                      (zerop (mod num (+ i 2))))\n             return nil\n             finally (return t)))))\n\n; prime-pairs-sequence generates a list of n pairs of consecutive prime numbers that are exactly 2 apart (twin primes).\n; It returns a list of cons cells (pairs) where each pair consists of two primes (p, p+2).\n(defun prime-pairs-sequence (n)\n  (let ((primes '())\n        (prime-pairs '())\n        (current 2)) ; start from the smallest prime number\n    (loop while (< (length prime-pairs) n) do\n      (when (is-prime-p current)\n        (push current primes)\n        (when (>= (length primes) 2)\n          (let ((last-prime (first primes))\n                (second-last-prime (second primes)))\n            (when (= last-prime (+ second-last-prime 2))\n              (push (cons second-last-prime last-prime) prime-pairs)))))\n      (incf current))\n    (reverse prime-pairs)))\n\n\n(defun run-tests ()\n  (let ((test-case-1 (prime-pairs-sequence 1))\n        (test-case-3 (prime-pairs-sequence 3))\n        (test-case-5 (prime-pairs-sequence 5)))\n    \n    (assert (equal test-case-1 '((3 . 5))) () \"Failed test case 1\")\n    (assert (equal test-case-3 '((3 . 5) (5 . 7) (11 . 13))) () \"Failed test case 3\")\n    (assert (equal test-case-5 '((3 . 5) (5 . 7) (11 . 13) (17 . 19) (29 . 31))) () \"Failed test case 5\")\n    \n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; max-non-overlapping-subarrays finds the maximum number of non-overlapping subarrays \n;; in a list of integers that sum up to a given target.\n;; The function uses a set to keep track of sums encountered so far and resets the sum \n;; and the set whenever a valid subarray is found.\n;; \n;; Parameters:\n;;   arr - A list of integers representing the input array.\n;;   target - An integer representing the target sum for subarrays.\n;;\n;; Returns:\n;;   An integer representing the maximum number of non-overlapping subarrays with sum equal to target.\n(defun max-non-overlapping-subarrays (arr target)\n  (let ((sum-so-far 0)\n        (count 0)\n        (seen-sums (list 0)))\n    (dolist (num arr)\n      (setf sum-so-far (+ sum-so-far num))\n      (if (member (- sum-so-far target) seen-sums :test #'=)\n          (progn\n            (incf count)\n            (setf sum-so-far 0)\n            (setf seen-sums (list 0)))\n          (push sum-so-far seen-sums)))\n    count))", "test_cases": "", "test_case_results": "Input array: (1 1 1 1 1), Target: 2\nMax non-overlapping subarrays: 2\nInput array: (1 2 3 4 5), Target: 5\nMax non-overlapping subarrays: 2\nInput array: (1 -1 1 -1 1 -1), Target: 0\nMax non-overlapping subarrays: 3\nInput array: (1 2 3 4 5 6), Target: 100\nMax non-overlapping subarrays: 0", "task_id": 14112, "assertions": "(in-package :cl-user)\n\n(defun test-max-non-overlapping-subarrays ()\n  (assert (= (max-non-overlapping-subarrays '(1 1 1 1 1) 2) 2)\n          () \"Test case 1 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5) 5) 2)\n          () \"Test case 2 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 -1 1 -1 1 -1) 0) 3)\n          () \"Test case 3 failed: Expected 3 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5 6) 100) 0)\n          () \"Test case 4 failed: Expected 0 subarrays\")\n  (format t \"All tests passed!~%\"))\n\n(test-max-non-overlapping-subarrays)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-max-non-overlapping-subarrays ()\n  (assert (= (max-non-overlapping-subarrays '(1 1 1 1 1) 2) 2)\n          () \"Test case 1 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5) 5) 2)\n          () \"Test case 2 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 -1 1 -1 1 -1) 0) 3)\n          () \"Test case 3 failed: Expected 3 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5 6) 100) 0)\n          () \"Test case 4 failed: Expected 0 subarrays\")\n  (format t \"All tests passed!~%\"))\n\n(test-max-non-overlapping-subarrays)", "output": "max-non-overlapping-subarrays"}, "all_code": "(in-package :cl-user)\n\n(defun max-non-overlapping-subarrays (arr target)\n  (let ((sum-so-far 0)\n        (count 0)\n        (seen-sums (list 0)))\n    (dolist (num arr)\n      (setf sum-so-far (+ sum-so-far num))\n      (if (member (- sum-so-far target) seen-sums :test #'=)\n          (progn\n            (incf count)\n            (setf sum-so-far 0)\n            (setf seen-sums (list 0)))\n          (push sum-so-far seen-sums)))\n    count))\n\n\n(defun test-max-non-overlapping-subarrays ()\n  (assert (= (max-non-overlapping-subarrays '(1 1 1 1 1) 2) 2)\n          () \"Test case 1 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5) 5) 2)\n          () \"Test case 2 failed: Expected 2 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 -1 1 -1 1 -1) 0) 3)\n          () \"Test case 3 failed: Expected 3 subarrays\")\n  (assert (= (max-non-overlapping-subarrays '(1 2 3 4 5 6) 100) 0)\n          () \"Test case 4 failed: Expected 0 subarrays\")\n  (format t \"All tests passed!~%\"))\n\n(test-max-non-overlapping-subarrays)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; longest-increasing-sequence calculates the longest strictly increasing subsequence \n;;; of timestamps for each test case using dynamic programming.\n;;; \n;;; Parameters:\n;;;   t - number of test cases\n;;;   test-cases - a list of test cases, where each test case is a list (n timestamps)\n;;;                where n is the number of photos and timestamps is a list of numbers\n;;;\n;;; Returns:\n;;;   A list of integers representing the length of the longest increasing sequence for each test case.\n(defun longest-increasing-sequence (t-cases test-cases)\n  (let ((results '()))\n    (dotimes (i t-cases results)\n      (let* ((current-case (nth i test-cases))\n             (n (first current-case))\n             (timestamps (second current-case)))\n        (if (zerop n)\n            (setf results (cons 0 results))\n            (let ((dp (make-list n :initial-element 1)))\n              (loop for j from 1 below n do\n                (loop for k from 0 below j do\n                  (when (< (nth k timestamps) (nth j timestamps))\n                    (setf (nth j dp) (max (nth j dp) (1+ (nth k dp)))))))\n              (setf results (cons (apply #'max dp) results))))))))", "test_cases": "", "test_case_results": "Test Cases:\nInput: (5 (1 2 3 4 5))\nResult: 5\n\nInput: (5 (5 4 3 2 1))\nResult: 1\n\nInput: (6 (1 3 2 4 6 5))\nResult: 4\n\nInput: (0 NIL)\nResult: 0\n\nInput: (3 (1 1 1))\nResult: 1", "task_id": 13990, "assertions": "(in-package :cl-user)\n\n(defun test-longest-increasing-sequence ()\n  (let ((test-cases '((5 (1 2 3 4 5))       ; Test case 1: strictly increasing\n                      (5 (5 4 3 2 1))       ; Test case 2: strictly decreasing\n                      (6 (1 3 2 4 6 5))     ; Test case 3: mixed order\n                      (0 nil)               ; Test case 4: no photos\n                      (3 (1 1 1)))))        ; Test case 5: all equal\n        (t-cases (length test-cases)))\n    (let ((results (longest-increasing-sequence t-cases test-cases)))\n      (assert (= (nth 0 results) 5) () \"Test case 1 failed: Expected 5\")\n      (assert (= (nth 1 results) 1) () \"Test case 2 failed: Expected 1\")\n      (assert (= (nth 2 results) 4) () \"Test case 3 failed: Expected 4\")\n      (assert (= (nth 3 results) 0) () \"Test case 4 failed: Expected 0\")\n      (assert (= (nth 4 results) 1) () \"Test case 5 failed: Expected 1\")\n      (format t \"All tests passed!~%\"))))\n\n(test-longest-increasing-sequence)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-longest-increasing-sequence ()\n  (let ((test-cases '((5 (1 2 3 4 5))       ; Test case 1: strictly increasing\n                      (5 (5 4 3 2 1))       ; Test case 2: strictly decreasing\n                      (6 (1 3 2 4 6 5))     ; Test case 3: mixed order\n                      (0 nil)               ; Test case 4: no photos\n                      (3 (1 1 1)))))        ; Test case 5: all equal\n        (t-cases (length test-cases)))\n    (let ((results (longest-increasing-sequence t-cases test-cases)))\n      (assert (= (nth 0 results) 5) () \"Test case 1 failed: Expected 5\")\n      (assert (= (nth 1 results) 1) () \"Test case 2 failed: Expected 1\")\n      (assert (= (nth 2 results) 4) () \"Test case 3 failed: Expected 4\")\n      (assert (= (nth 3 results) 0) () \"Test case 4 failed: Expected 0\")\n      (assert (= (nth 4 results) 1) () \"Test case 5 failed: Expected 1\")\n      (format t \"All tests passed!~%\"))))\n\n(test-longest-increasing-sequence)", "output": "longest-increasing-sequence"}, "all_code": "(in-package :cl-user)\n\n(defun longest-increasing-sequence (t-cases test-cases)\n  (let ((results '()))\n    (dotimes (i t-cases results)\n      (let* ((current-case (nth i test-cases))\n             (n (first current-case))\n             (timestamps (second current-case)))\n        (if (zerop n)\n            (setf results (cons 0 results))\n            (let ((dp (make-list n :initial-element 1)))\n              (loop for j from 1 below n do\n                (loop for k from 0 below j do\n                  (when (< (nth k timestamps) (nth j timestamps))\n                    (setf (nth j dp) (max (nth j dp) (1+ (nth k dp)))))))\n              (setf results (cons (apply #'max dp) results))))))))\n\n\n(defun test-longest-increasing-sequence ()\n  (let ((test-cases '((5 (1 2 3 4 5))       ; Test case 1: strictly increasing\n                      (5 (5 4 3 2 1))       ; Test case 2: strictly decreasing\n                      (6 (1 3 2 4 6 5))     ; Test case 3: mixed order\n                      (0 nil)               ; Test case 4: no photos\n                      (3 (1 1 1)))))        ; Test case 5: all equal\n        (t-cases (length test-cases)))\n    (let ((results (longest-increasing-sequence t-cases test-cases)))\n      (assert (= (nth 0 results) 5) () \"Test case 1 failed: Expected 5\")\n      (assert (= (nth 1 results) 1) () \"Test case 2 failed: Expected 1\")\n      (assert (= (nth 2 results) 4) () \"Test case 3 failed: Expected 4\")\n      (assert (= (nth 3 results) 0) () \"Test case 4 failed: Expected 0\")\n      (assert (= (nth 4 results) 1) () \"Test case 5 failed: Expected 1\")\n      (format t \"All tests passed!~%\"))))\n\n(test-longest-increasing-sequence)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(defpackage :sequence-utils\n  (:use :cl)\n  (:export :count-amazing-sequences))\n\n(in-package :sequence-utils)\n\n(defun count-amazing-sequences (n s)\n  (let ((count 0))\n    (loop for length from 2 to n by 2 do ; Amazing sequences can only be of even length\n      (loop for i from 0 to (- n length) do\n        (let ((substr (subseq s i (+ i length))))\n          (when (= (count #\\H substr) (count #\\T substr))\n            (incf count)))))\n    count))", "test_cases": "", "test_case_results": "Input: HTHT, Length: 4\nCount: 4\nInput: HTTH, Length: 4\nCount: 3\nInput: HHHTTT, Length: 6\nCount: 3\nInput: HHTT, Length: 4\nCount: 2", "task_id": 19176, "assertions": "(defpackage :sequence-utils-test\n  (:use :cl :sequence-utils)\n  (:export :run-tests))\n\n(in-package :sequence-utils-test)\n\n(defun run-tests ()\n  (assert (= (count-amazing-sequences 4 \"HTHT\") 4) () \"HTHT should have 4 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HTTH\") 3) () \"HTTH should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 6 \"HHHTTT\") 3) () \"HHHTTT should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HHTT\") 2) () \"HHTT should have 2 amazing sequences\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :sequence-utils-test\n  (:use :cl :sequence-utils)\n  (:export :run-tests))\n\n(in-package :sequence-utils-test)\n\n(defun run-tests ()\n  (assert (= (count-amazing-sequences 4 \"HTHT\") 4) () \"HTHT should have 4 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HTTH\") 3) () \"HTTH should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 6 \"HHHTTT\") 3) () \"HHHTTT should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HHTT\") 2) () \"HHTT should have 2 amazing sequences\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "count-amazing-sequences"}, "all_code": "(defpackage :sequence-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :sequence-utils-test)\n\n(defun count-amazing-sequences (n s)\n  (let ((count 0))\n    (loop for length from 2 to n by 2 do ; Amazing sequences can only be of even length\n      (loop for i from 0 to (- n length) do\n        (let ((substr (subseq s i (+ i length))))\n          (when (= (count #\\H substr) (count #\\T substr))\n            (incf count)))))\n    count))\n\n\n(defun run-tests ()\n  (assert (= (count-amazing-sequences 4 \"HTHT\") 4) () \"HTHT should have 4 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HTTH\") 3) () \"HTTH should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 6 \"HHHTTT\") 3) () \"HHHTTT should have 3 amazing sequences\")\n  (assert (= (count-amazing-sequences 4 \"HHTT\") 2) () \"HHTT should have 2 amazing sequences\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; max-aesthetic-appeal calculates the maximum aesthetic appeal achievable within a given budget\n;;; by strategically planting plants in a grid. It uses a knapsack-like approach with backtracking.\n;;; \n;;; Parameters:\n;;;   budget - the total available budget\n;;;   n - number of rows in the grid\n;;;   m - number of columns in the grid\n;;;   plants - list of plant specifications (cost, appeal, locations)\n;;;\n;;; Returns:\n;;;   The maximum aesthetic appeal achievable within the budget\n\n(defun max-aesthetic-appeal (budget n m plants)\n  (labels ((knapsack (k current-budget planted great-aesthetic)\n             (cond\n               ((or (>= k (length plants)) (< current-budget 0)) 0)\n               (t\n                (let* ((plant (nth k plants))\n                       (cost (first plant))\n                       (appeal (second plant))\n                       (locations (third plant))\n                       (max-appeal (knapsack (1+ k) current-budget planted great-aesthetic)))\n                  (dolist (loc locations max-appeal)\n                    (let ((row (first loc))\n                          (col (second loc)))\n                      (unless (aref planted row col)\n                        (when (>= current-budget cost)\n                          (setf (aref planted row col) t)\n                          (let ((temp-appeal (+ (knapsack (1+ k) \n                                                         (- current-budget cost) \n                                                         planted \n                                                         (+ great-aesthetic appeal)) \n                                              appeal)))\n                            (setf max-appeal (max max-appeal temp-appeal)))\n                          (setf (aref planted row col) nil))))))))))\n    \n    ;; Sort plants by appeal-to-cost ratio in descending order\n    (let ((sorted-plants (sort (copy-list plants) \n                              #'> \n                              :key (lambda (x) (/ (second x) (first x))))))\n      (knapsack 0 budget (make-array (list n m) :initial-element nil) 0))))", "test_cases": "", "test_case_results": "Test Case 1:\nBudget: 10, Grid: 2x2, Plants: ((5 3 ((0 0))))\nMax Appeal: 3\n\nTest Case 2:\nBudget: 15, Grid: 3x3, Plants: ((5 3 ((0 0) (1 1))) (7 5 ((0 0) (2 2)))\n                                (3 2 ((1 1))))\nMax Appeal: 10\n\nTest Case 3:\nBudget: 2, Grid: 2x2, Plants: ((5 3 ((0 0))) (4 2 ((1 1))))\nMax Appeal: 0", "task_id": 22346, "assertions": "(defpackage :aesthetic-appeal-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :aesthetic-appeal-test)\n\n(defun run-tests ()\n  ;; Test Case 1: Simple case with one plant that fits in budget\n  (let ((result1 (max-aesthetic-appeal 10 2 2 '((5 3 ((0 0)))))))\n    (assert (= result1 3) () \"Test Case 1 failed: Expected 3, got ~a\" result1))\n  \n  ;; Test Case 2: Multiple plants with overlapping locations\n  (let ((result2 (max-aesthetic-appeal 15 3 3 '((5 3 ((0 0) (1 1)))\n                                               (7 5 ((0 0) (2 2)))\n                                               (3 2 ((1 1))))))))\n    (assert (= result2 10) () \"Test Case 2 failed: Expected 10, got ~a\" result2))\n  \n  ;; Test Case 3: Budget too small for any plant\n  (let ((result3 (max-aesthetic-appeal 2 2 2 '((5 3 ((0 0)))\n                                              (4 2 ((1 1))))))))\n    (assert (= result3 0) () \"Test Case 3 failed: Expected 0, got ~a\" result3))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :aesthetic-appeal-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :aesthetic-appeal-test)\n\n(defun run-tests ()\n  ;; Test Case 1: Simple case with one plant that fits in budget\n  (let ((result1 (max-aesthetic-appeal 10 2 2 '((5 3 ((0 0)))))))\n    (assert (= result1 3) () \"Test Case 1 failed: Expected 3, got ~a\" result1))\n  \n  ;; Test Case 2: Multiple plants with overlapping locations\n  (let ((result2 (max-aesthetic-appeal 15 3 3 '((5 3 ((0 0) (1 1)))\n                                               (7 5 ((0 0) (2 2)))\n                                               (3 2 ((1 1))))))))\n    (assert (= result2 10) () \"Test Case 2 failed: Expected 10, got ~a\" result2))\n  \n  ;; Test Case 3: Budget too small for any plant\n  (let ((result3 (max-aesthetic-appeal 2 2 2 '((5 3 ((0 0)))\n                                              (4 2 ((1 1))))))))\n    (assert (= result3 0) () \"Test Case 3 failed: Expected 0, got ~a\" result3))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "max-aesthetic-appeal"}, "all_code": "(defpackage :aesthetic-appeal-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :aesthetic-appeal-test)\n\n(defun max-aesthetic-appeal (budget n m plants)\n  (labels ((knapsack (k current-budget planted great-aesthetic)\n             (cond\n               ((or (>= k (length plants)) (< current-budget 0)) 0)\n               (t\n                (let* ((plant (nth k plants))\n                       (cost (first plant))\n                       (appeal (second plant))\n                       (locations (third plant))\n                       (max-appeal (knapsack (1+ k) current-budget planted great-aesthetic)))\n                  (dolist (loc locations max-appeal)\n                    (let ((row (first loc))\n                          (col (second loc)))\n                      (unless (aref planted row col)\n                        (when (>= current-budget cost)\n                          (setf (aref planted row col) t)\n                          (let ((temp-appeal (+ (knapsack (1+ k) \n                                                         (- current-budget cost) \n                                                         planted \n                                                         (+ great-aesthetic appeal)) \n                                              appeal)))\n                            (setf max-appeal (max max-appeal temp-appeal)))\n                          (setf (aref planted row col) nil))))))))))\n    \n    ;; Sort plants by appeal-to-cost ratio in descending order\n    (let ((sorted-plants (sort (copy-list plants) \n                              #'> \n                              :key (lambda (x) (/ (second x) (first x))))))\n      (knapsack 0 budget (make-array (list n m) :initial-element nil) 0))))\n\n\n(defun run-tests ()\n  ;; Test Case 1: Simple case with one plant that fits in budget\n  (let ((result1 (max-aesthetic-appeal 10 2 2 '((5 3 ((0 0)))))))\n    (assert (= result1 3) () \"Test Case 1 failed: Expected 3, got ~a\" result1))\n  \n  ;; Test Case 2: Multiple plants with overlapping locations\n  (let ((result2 (max-aesthetic-appeal 15 3 3 '((5 3 ((0 0) (1 1)))\n                                               (7 5 ((0 0) (2 2)))\n                                               (3 2 ((1 1))))))))\n    (assert (= result2 10) () \"Test Case 2 failed: Expected 10, got ~a\" result2))\n  \n  ;; Test Case 3: Budget too small for any plant\n  (let ((result3 (max-aesthetic-appeal 2 2 2 '((5 3 ((0 0)))\n                                              (4 2 ((1 1))))))))\n    (assert (= result3 0) () \"Test Case 3 failed: Expected 0, got ~a\" result3))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; is-match checks if a string s matches a pattern p, where '?' in p can match any single lowercase letter.\n; Returns \"YES\" if they match, otherwise \"NO\".\n; The match is determined by comparing each character in s and p, with '?' in p matching any character in s.\n; The strings must be of the same length to match.\n(defun is-match (s p)\n  (if (/= (length s) (length p))\n      \"NO\"\n      (loop for s-char across s\n            for p-char across p\n            unless (or (char= p-char #\\?) (char= s-char p-char))\n            do (return-from is-match \"NO\")\n            finally (return \"YES\"))))", "test_cases": "", "test_case_results": "String: abc, Pattern: a?c, Result: YES\nString: abcd, Pattern: a?c?, Result: YES\nString: hello, Pattern: h?llo, Result: YES\nString: world, Pattern: w?rld, Result: YES\nString: mismatch, Pattern: m?smat?h, Result: YES\nString: short, Pattern: longer, Result: NO", "task_id": 3436, "assertions": "(defpackage :match-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :match-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user:is-match \"abc\" \"a?c\") \"YES\") () \"Test 1 failed\")\n  (assert (string= (cl-user:is-match \"abcd\" \"a?c?\") \"YES\") () \"Test 2 failed\")\n  (assert (string= (cl-user:is-match \"hello\" \"h?llo\") \"YES\") () \"Test 3 failed\")\n  (assert (string= (cl-user:is-match \"world\" \"w?rld\") \"YES\") () \"Test 4 failed\")\n  (assert (string= (cl-user:is-match \"mismatch\" \"m?smat?h\") \"YES\") () \"Test 5 failed\")\n  (assert (string= (cl-user:is-match \"short\" \"longer\") \"NO\") () \"Test 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :match-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :match-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user:is-match \"abc\" \"a?c\") \"YES\") () \"Test 1 failed\")\n  (assert (string= (cl-user:is-match \"abcd\" \"a?c?\") \"YES\") () \"Test 2 failed\")\n  (assert (string= (cl-user:is-match \"hello\" \"h?llo\") \"YES\") () \"Test 3 failed\")\n  (assert (string= (cl-user:is-match \"world\" \"w?rld\") \"YES\") () \"Test 4 failed\")\n  (assert (string= (cl-user:is-match \"mismatch\" \"m?smat?h\") \"YES\") () \"Test 5 failed\")\n  (assert (string= (cl-user:is-match \"short\" \"longer\") \"NO\") () \"Test 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "is-match"}, "all_code": "(defpackage :match-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :match-test)\n\n(defun is-match (s p)\n  (if (/= (length s) (length p))\n      \"NO\"\n      (loop for s-char across s\n            for p-char across p\n            unless (or (char= p-char #\\?) (char= s-char p-char))\n            do (return-from is-match \"NO\")\n            finally (return \"YES\"))))\n\n\n(defun run-tests ()\n  (assert (string= (is-match \"abc\" \"a?c\") \"YES\") () \"Test 1 failed\")\n  (assert (string= (is-match \"abcd\" \"a?c?\") \"YES\") () \"Test 2 failed\")\n  (assert (string= (is-match \"hello\" \"h?llo\") \"YES\") () \"Test 3 failed\")\n  (assert (string= (is-match \"world\" \"w?rld\") \"YES\") () \"Test 4 failed\")\n  (assert (string= (is-match \"mismatch\" \"m?smat?h\") \"YES\") () \"Test 5 failed\")\n  (assert (string= (is-match \"short\" \"longer\") \"NO\") () \"Test 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-min-difference-indices returns two distinct indices i and j such that the absolute difference \n; between a[i] and a[j] is minimized. If multiple solutions exist, any one is returned.\n; \n; Parameters:\n;   n - the length of the list a\n;   a - a list of numbers\n;\n; Returns:\n;   Two values: the indices i and j with the minimal absolute difference.\n(defun find-min-difference-indices (n a)\n  (let* ((indexed-a (loop for i from 1 to n \n                          for x in a \n                          collect (cons x i))) ; Create (value . index) pairs\n         (sorted-indexed-a (sort (copy-list indexed-a) #'< :key #'car)) ; Sort by value\n         (min-diff most-positive-fixnum)\n         (min-i -1)\n         (min-j -1))\n    (loop for k from 0 to (- n 2) ; Iterate through adjacent pairs\n          for current = (nth k sorted-indexed-a)\n          for next = (nth (1+ k) sorted-indexed-a)\n          for diff = (abs (- (car next) (car current)))\n          when (< diff min-diff)\n            do (setf min-diff diff\n                     min-i (cdr current)\n                     min-j (cdr next)))\n    (values min-i min-j)))", "test_cases": "", "test_case_results": "Input: (1 3 5 9)\nIndices: (1 2)\nInput: (10 20 30 40 50)\nIndices: (1 2)\nInput: (5 1 3 7 2)\nIndices: (2 5)", "task_id": 11974, "assertions": "(defpackage :min-diff-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-diff-test)\n\n(defun run-tests ()\n  (multiple-value-bind (i j) (find-min-difference-indices 4 '(1 3 5 9))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 1 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(10 20 30 40 50))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 2 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(5 1 3 7 2))\n    (assert (and (or (= i 2) (= i 5))\n                 (or (= j 2) (= j 5))\n                 (/= i j)) () \"Test case 3 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :min-diff-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-diff-test)\n\n(defun run-tests ()\n  (multiple-value-bind (i j) (find-min-difference-indices 4 '(1 3 5 9))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 1 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(10 20 30 40 50))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 2 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(5 1 3 7 2))\n    (assert (and (or (= i 2) (= i 5))\n                 (or (= j 2) (= j 5))\n                 (/= i j)) () \"Test case 3 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-min-difference-indices"}, "all_code": "(defpackage :min-diff-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :min-diff-test)\n\n(defun find-min-difference-indices (n a)\n  (let* ((indexed-a (loop for i from 1 to n \n                          for x in a \n                          collect (cons x i))) ; Create (value . index) pairs\n         (sorted-indexed-a (sort (copy-list indexed-a) #'< :key #'car)) ; Sort by value\n         (min-diff most-positive-fixnum)\n         (min-i -1)\n         (min-j -1))\n    (loop for k from 0 to (- n 2) ; Iterate through adjacent pairs\n          for current = (nth k sorted-indexed-a)\n          for next = (nth (1+ k) sorted-indexed-a)\n          for diff = (abs (- (car next) (car current)))\n          when (< diff min-diff)\n            do (setf min-diff diff\n                     min-i (cdr current)\n                     min-j (cdr next)))\n    (values min-i min-j)))\n\n\n(defun run-tests ()\n  (multiple-value-bind (i j) (find-min-difference-indices 4 '(1 3 5 9))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 1 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(10 20 30 40 50))\n    (assert (and (or (= i 1) (= i 2))\n                 (or (= j 1) (= j 2))\n                 (/= i j)) () \"Test case 2 failed\"))\n  \n  (multiple-value-bind (i j) (find-min-difference-indices 5 '(5 1 3 7 2))\n    (assert (and (or (= i 2) (= i 5))\n                 (or (= j 2) (= j 5))\n                 (/= i j)) () \"Test case 3 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; convert-vowels replaces all vowels in the input string with their respective positions in the alphabet.\n; The function maintains the case sensitivity of the original string.\n; The vowel positions are as follows:\n; a/A -> 1, e/E -> 5, i/I -> 9, o/O -> 15, u/U -> 21\n(defun convert-vowels (s)\n  (let ((vowel-map '((#\\a . \"1\") (#\\A . \"1\")\n                     (#\\e . \"5\") (#\\E . \"5\")\n                     (#\\i . \"9\") (#\\I . \"9\")\n                     (#\\o . \"15\") (#\\O . \"15\")\n                     (#\\u . \"21\") (#\\U . \"21\"))))\n    (with-output-to-string (result)\n      (loop for char across s\n            do (let ((replacement (cdr (assoc char vowel-map :test #'char=))))\n                 (if replacement\n                     (princ replacement result)\n                     (princ char result)))))))", "test_cases": "", "test_case_results": "Input: Hello World\nResult: H5ll15 W15rld\n\nInput: Common Lisp\nResult: C15mm15n L9sp\n\nInput: AEIOUaeiou\nResult: 15915211591521\n\nInput: No vowels here!\nResult: N15 v15w5ls h5r5!", "task_id": 5421, "assertions": "(defpackage :vowel-converter-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :vowel-converter-test)\n\n(defun run-tests ()\n  (assert (string= (convert-vowels \"Hello World\") \"H5ll15 W15rld\") () \"Test 1 failed\")\n  (assert (string= (convert-vowels \"Common Lisp\") \"C15mm15n L9sp\") () \"Test 2 failed\")\n  (assert (string= (convert-vowels \"AEIOUaeiou\") \"15915211591521\") () \"Test 3 failed\")\n  (assert (string= (convert-vowels \"No vowels here!\") \"N15 v15w5ls h5r5!\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :vowel-converter-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :vowel-converter-test)\n\n(defun run-tests ()\n  (assert (string= (convert-vowels \"Hello World\") \"H5ll15 W15rld\") () \"Test 1 failed\")\n  (assert (string= (convert-vowels \"Common Lisp\") \"C15mm15n L9sp\") () \"Test 2 failed\")\n  (assert (string= (convert-vowels \"AEIOUaeiou\") \"15915211591521\") () \"Test 3 failed\")\n  (assert (string= (convert-vowels \"No vowels here!\") \"N15 v15w5ls h5r5!\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "convert-vowels"}, "all_code": "(defpackage :vowel-converter-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :vowel-converter-test)\n\n(defun convert-vowels (s)\n  (let ((vowel-map '((#\\a . \"1\") (#\\A . \"1\")\n                     (#\\e . \"5\") (#\\E . \"5\")\n                     (#\\i . \"9\") (#\\I . \"9\")\n                     (#\\o . \"15\") (#\\O . \"15\")\n                     (#\\u . \"21\") (#\\U . \"21\"))))\n    (with-output-to-string (result)\n      (loop for char across s\n            do (let ((replacement (cdr (assoc char vowel-map :test #'char=))))\n                 (if replacement\n                     (princ replacement result)\n                     (princ char result)))))))\n\n\n(defun run-tests ()\n  (assert (string= (convert-vowels \"Hello World\") \"H5ll15 W15rld\") () \"Test 1 failed\")\n  (assert (string= (convert-vowels \"Common Lisp\") \"C15mm15n L9sp\") () \"Test 2 failed\")\n  (assert (string= (convert-vowels \"AEIOUaeiou\") \"15915211591521\") () \"Test 3 failed\")\n  (assert (string= (convert-vowels \"No vowels here!\") \"N15 v15w5ls h5r5!\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; perform-operations processes a string and a list of queries, performing operations on the string.\n; The operations include:\n; - Type 1: Change a character at a specified position.\n; - Type 2: Check if a substring is a palindrome.\n; The function returns a list of results for the type 2 queries.\n(defun perform-operations (s queries)\n  (let ((s (coerce s 'list))  ; Convert the string to a list for mutability\n        (results '()))\n    (dolist (query queries)\n      (case (first query)\n        (1  ; Type 1 query: change character at position i to c\n         (let ((i (1- (second query)))\n               (c (third query)))\n           (setf (nth i s) c)))\n        (2  ; Type 2 query: check if substring from l to r is a palindrome\n         (let* ((l (1- (second query)))\n                (r (third query))\n                (substring (subseq s l r))\n                (reversed-substring (reverse substring)))\n           (if (equal substring reversed-substring)\n               (push \"YES\" results)\n               (push \"NO\" results))))))\n    (reverse results)))  ; Reverse to maintain the order of results", "test_cases": "", "test_case_results": "Initial string: abcde\nQueries: ((1 2 'X) (2 1 3) (1 3 'Y) (2 1 5))\nResults: (NO NO)", "task_id": 27444, "assertions": "(defpackage :string-operations-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-operations-test)\n\n(defun run-tests ()\n  (let ((test-string \"abcde\")\n        (test-queries '((1 2 'x) (2 1 3) (1 3 'y) (2 1 5))))\n    (let ((results (perform-operations test-string test-queries)))\n      (assert (equal results '(\"NO\" \"NO\")) () \"Test case 1 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-operations-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-operations-test)\n\n(defun run-tests ()\n  (let ((test-string \"abcde\")\n        (test-queries '((1 2 'x) (2 1 3) (1 3 'y) (2 1 5))))\n    (let ((results (perform-operations test-string test-queries)))\n      (assert (equal results '(\"NO\" \"NO\")) () \"Test case 1 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "output": "perform-operations"}, "all_code": "(defpackage :string-operations-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-operations-test)\n\n\n\n(defun run-tests ()\n  (let ((test-string \"abcde\")\n        (test-queries '((1 2 'x) (2 1 3) (1 3 'y) (2 1 5))))\n    (let ((results (perform-operations test-string test-queries)))\n      (assert (equal results '(\"NO\" \"NO\")) () \"Test case 1 failed\")\n      (format t \"All tests passed!~%\"))))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; rotate-array rotates a list counter-clockwise by a specified number of positions.\n; If the input list is empty, it returns the empty list.\n; For non-empty lists, it handles positions greater than the list length by using modulo arithmetic.\n; The rotation is performed by concatenating the sublist from the rotation position to the end \n; with the sublist from the beginning up to the rotation position.\n(defun rotate-array (arr positions)\n  (if (null arr)\n      arr\n      (let* ((n (length arr))\n             (effective-pos (mod positions n)))\n        (append (subseq arr effective-pos) (subseq arr 0 effective-pos)))))", "test_cases": "", "test_case_results": "Rotate 2 positions\nInput: (1 2 3 4 5), Positions: 2\nResult: (3 4 5 1 2)\n\nRotate 5 positions (greater than list length)\nInput: (10 20 30 40), Positions: 5\nResult: (20 30 40 10)\n\nEmpty list\nInput: NIL, Positions: 3\nResult: NIL\n\nRotate 0 positions\nInput: (7 8 9), Positions: 0\nResult: (7 8 9)", "task_id": 2867, "assertions": "(defpackage :rotate-array-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :rotate-array-test)\n\n(defun run-tests ()\n  (assert (equal (rotate-array '(1 2 3 4 5) 2) '(3 4 5 1 2)) () \"Rotation by 2 positions failed\")\n  (assert (equal (rotate-array '(10 20 30 40) 5) '(20 30 40 10)) () \"Rotation by 5 positions (greater than list length) failed\")\n  (assert (equal (rotate-array nil 3) nil) () \"Empty list rotation failed\")\n  (assert (equal (rotate-array '(7 8 9) 0) '(7 8 9)) () \"Rotation by 0 positions failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :rotate-array-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :rotate-array-test)\n\n(defun run-tests ()\n  (assert (equal (rotate-array '(1 2 3 4 5) 2) '(3 4 5 1 2)) () \"Rotation by 2 positions failed\")\n  (assert (equal (rotate-array '(10 20 30 40) 5) '(20 30 40 10)) () \"Rotation by 5 positions (greater than list length) failed\")\n  (assert (equal (rotate-array nil 3) nil) () \"Empty list rotation failed\")\n  (assert (equal (rotate-array '(7 8 9) 0) '(7 8 9)) () \"Rotation by 0 positions failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "rotate-array"}, "all_code": "(defpackage :rotate-array-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :rotate-array-test)\n\n(defun rotate-array (arr positions)\n  (if (null arr)\n      arr\n      (let* ((n (length arr))\n             (effective-pos (mod positions n)))\n        (append (subseq arr effective-pos) (subseq arr 0 effective-pos)))))\n\n\n(defun run-tests ()\n  (assert (equal (rotate-array '(1 2 3 4 5) 2) '(3 4 5 1 2)) () \"Rotation by 2 positions failed\")\n  (assert (equal (rotate-array '(10 20 30 40) 5) '(20 30 40 10)) () \"Rotation by 5 positions (greater than list length) failed\")\n  (assert (equal (rotate-array nil 3) nil) () \"Empty list rotation failed\")\n  (assert (equal (rotate-array '(7 8 9) 0) '(7 8 9)) () \"Rotation by 0 positions failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; unique-paths calculates the number of unique paths from the top-left corner to the bottom-right corner\n; of an x by y grid, moving only right or down. It uses memoization to optimize the recursive solution.\n; The function takes two integers x and y, and an optional memoization table (defaults to an empty hash table).\n; Returns the number of unique paths as an integer.\n(defun unique-paths (x y &optional (memo (make-hash-table :test 'equal)))\n  (let ((key (list x y)))\n    (when (gethash key memo)\n      (return-from unique-paths (gethash key memo)))\n    (if (or (= x 1) (= y 1))\n        (setf (gethash key memo) 1)\n        (setf (gethash key memo) \n              (+ (unique-paths (1- x) y memo) \n                 (unique-paths x (1- y) memo))))))", "test_cases": "", "test_case_results": "Input: (1 1)\nUnique Paths: 1\nInput: (2 2)\nUnique Paths: 2\nInput: (3 2)\nUnique Paths: 3\nInput: (3 3)\nUnique Paths: 6\nInput: (4 4)\nUnique Paths: 20", "task_id": 4765, "assertions": "(in-package :cl-user)\n\n(defun test-unique-paths ()\n  (assert (= (unique-paths 1 1) 1) () \"1x1 grid should have 1 path\")\n  (assert (= (unique-paths 2 2) 2) () \"2x2 grid should have 2 paths\")\n  (assert (= (unique-paths 3 2) 3) () \"3x2 grid should have 3 paths\")\n  (assert (= (unique-paths 3 3) 6) () \"3x3 grid should have 6 paths\")\n  (assert (= (unique-paths 4 4) 20) () \"4x4 grid should have 20 paths\")\n  (format t \"All unique-paths tests passed!~%\"))\n\n(test-unique-paths)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-unique-paths ()\n  (assert (= (unique-paths 1 1) 1) () \"1x1 grid should have 1 path\")\n  (assert (= (unique-paths 2 2) 2) () \"2x2 grid should have 2 paths\")\n  (assert (= (unique-paths 3 2) 3) () \"3x2 grid should have 3 paths\")\n  (assert (= (unique-paths 3 3) 6) () \"3x3 grid should have 6 paths\")\n  (assert (= (unique-paths 4 4) 20) () \"4x4 grid should have 20 paths\")\n  (format t \"All unique-paths tests passed!~%\"))\n\n(test-unique-paths)", "output": "unique-paths"}, "all_code": "(in-package :cl-user)\n\n(defun unique-paths (x y &optional (memo (make-hash-table :test 'equal)))\n  (let ((key (list x y)))\n    (when (gethash key memo)\n      (return-from unique-paths (gethash key memo)))\n    (if (or (= x 1) (= y 1))\n        (setf (gethash key memo) 1)\n        (setf (gethash key memo) \n              (+ (unique-paths (1- x) y memo) \n                 (unique-paths x (1- y) memo))))))\n\n\n(defun test-unique-paths ()\n  (assert (= (unique-paths 1 1) 1) () \"1x1 grid should have 1 path\")\n  (assert (= (unique-paths 2 2) 2) () \"2x2 grid should have 2 paths\")\n  (assert (= (unique-paths 3 2) 3) () \"3x2 grid should have 3 paths\")\n  (assert (= (unique-paths 3 3) 6) () \"3x3 grid should have 6 paths\")\n  (assert (= (unique-paths 4 4) 20) () \"4x4 grid should have 20 paths\")\n  (format t \"All unique-paths tests passed!~%\"))\n\n(test-unique-paths)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; check-password-strength checks if given passwords meet the specified criteria for a valid password.\n; A valid password must:\n; - Be at least 8 characters long\n; - Contain at least one lowercase letter\n; - Contain at least one uppercase letter\n; - Contain at least one digit\n; - Contain at least one special character from [!@#$%^&*()\\-+]\n; The function returns a list of booleans where each element is T if the corresponding password is valid, otherwise NIL.\n(defun check-password-strength (passwords)\n  (mapcar (lambda (password)\n            (and (>= (length password) 8)\n                 (some #'lower-case-p password)\n                 (some #'upper-case-p password)\n                 (some #'digit-char-p password)\n                 (some (lambda (c) (find c \"!@#$%^&*()-+\")) password)))\n          passwords))", "test_cases": "", "test_case_results": "Input: (Passw0rd! password PASSWORD1@ Pass@123 Pass1234 1234!abcd)\nResult: (! NIL NIL @ NIL NIL)", "task_id": 20347, "assertions": "(defpackage :password-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun run-tests ()\n  (let ((test-cases '((\"Passw0rd!\" . T) \n                      (\"password\" . NIL) \n                      (\"PASSWORD1@\" . NIL) \n                      (\"Pass@123\" . T) \n                      (\"Pass1234\" . NIL) \n                      (\"1234!abcd\" . NIL))))\n    (dolist (case test-cases)\n      (let ((input (car case))\n            (expected (cdr case))\n            (actual (car (cl-user:check-password-strength (list (car case))))))\n        (assert (eq actual expected) () \n                \"Test failed for ~a: expected ~a but got ~a\" input expected actual)))\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :password-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun run-tests ()\n  (let ((test-cases '((\"Passw0rd!\" . T) \n                      (\"password\" . NIL) \n                      (\"PASSWORD1@\" . NIL) \n                      (\"Pass@123\" . T) \n                      (\"Pass1234\" . NIL) \n                      (\"1234!abcd\" . NIL))))\n    (dolist (case test-cases)\n      (let ((input (car case))\n            (expected (cdr case))\n            (actual (car (cl-user:check-password-strength (list (car case))))))\n        (assert (eq actual expected) () \n                \"Test failed for ~a: expected ~a but got ~a\" input expected actual)))\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "check-password-strength"}, "all_code": "(defpackage :password-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :password-test)\n\n(defun check-password-strength (passwords)\n  (mapcar (lambda (password)\n            (and (>= (length password) 8)\n                 (some #'lower-case-p password)\n                 (some #'upper-case-p password)\n                 (some #'digit-char-p password)\n                 (some (lambda (c) (find c \"!@#$%^&*()-+\")) password)))\n          passwords))\n\n\n(defun run-tests ()\n  (let ((test-cases '((\"Passw0rd!\" . T) \n                      (\"password\" . NIL) \n                      (\"PASSWORD1@\" . NIL) \n                      (\"Pass@123\" . T) \n                      (\"Pass1234\" . NIL) \n                      (\"1234!abcd\" . NIL))))\n    (dolist (case test-cases)\n      (let ((input (car case))\n            (expected (cdr case))\n            (actual (car (check-password-strength (list (car case))))))\n        (assert (eq actual expected) () \n                \"Test failed for ~a: expected ~a but got ~a\" input expected actual)))\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n;; minimize-max-difficulty calculates the minimum possible value of the maximum difficulty Petya will encounter.\n;; The function first sorts the list of difficulties and then returns the middle element (or the left-middle for even lengths).\n;; This is based on the observation that the optimal solution is the median of the sorted list.\n;;\n;; Parameters:\n;;   n - the number of elements in the difficulties list\n;;   difficulties - a list of integers representing the difficulties\n;;\n;; Returns:\n;;   The minimum possible value of the maximum difficulty after optimal arrangement.\n(defun minimize-max-difficulty (n difficulties)\n  (let ((sorted-difficulties (sort (copy-list difficulties) #'<)))\n    (nth (floor (1- n) 2) sorted-difficulties)))", "test_cases": "", "test_case_results": "Input (n=3, difficulties=(1 2 3)): 2\nInput (n=4, difficulties=(5 1 3 2)): 2\nInput (n=1, difficulties=(10)): 10\nInput (n=5, difficulties=(4 2 6 1 5)): 4", "task_id": 16115, "assertions": "(defpackage :minimize-difficulty-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :minimize-difficulty-test)\n\n(defun run-tests ()\n  (assert (= (minimize-max-difficulty 3 '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (minimize-max-difficulty 4 '(5 1 3 2)) 2) () \"Test case 2 failed\")\n  (assert (= (minimize-max-difficulty 1 '(10)) 10) () \"Test case 3 failed\")\n  (assert (= (minimize-max-difficulty 5 '(4 2 6 1 5)) 4) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :minimize-difficulty-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :minimize-difficulty-test)\n\n(defun run-tests ()\n  (assert (= (minimize-max-difficulty 3 '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (minimize-max-difficulty 4 '(5 1 3 2)) 2) () \"Test case 2 failed\")\n  (assert (= (minimize-max-difficulty 1 '(10)) 10) () \"Test case 3 failed\")\n  (assert (= (minimize-max-difficulty 5 '(4 2 6 1 5)) 4) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "minimize-max-difficulty"}, "all_code": "(defpackage :minimize-difficulty-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :minimize-difficulty-test)\n\n(defun minimize-max-difficulty (n difficulties)\n  (let ((sorted-difficulties (sort (copy-list difficulties) #'<)))\n    (nth (floor (1- n) 2) sorted-difficulties)))\n\n\n(defun run-tests ()\n  (assert (= (minimize-max-difficulty 3 '(1 2 3)) 2) () \"Test case 1 failed\")\n  (assert (= (minimize-max-difficulty 4 '(5 1 3 2)) 2) () \"Test case 2 failed\")\n  (assert (= (minimize-max-difficulty 1 '(10)) 10) () \"Test case 3 failed\")\n  (assert (= (minimize-max-difficulty 5 '(4 2 6 1 5)) 4) () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :travel-time\n  (:use :cl)\n  (:export :calculate-travel-time :parse-time))\n\n(in-package :travel-time)\n\n; calculate-travel-time calculates the total travel time in minutes from the first departure\n; to the last arrival in a train schedule.\n; The schedule is a list of stops, where each stop is represented as a plist with :arrival and :departure keys.\n; Times are expected to be in \"HH:MM\" format as strings.\n; Returns the total travel time in minutes as an integer.\n(defun calculate-travel-time (schedule)\n  (let ((first-departure-time nil)\n        (last-arrival-time nil))\n    ; Find first departure and last arrival times\n    (dolist (stop schedule)\n      (when (and (getf stop :departure) (null first-departure-time))\n        (setf first-departure-time (getf stop :departure)))\n      (when (getf stop :arrival)\n        (setf last-arrival-time (getf stop :arrival))))\n    \n    ; Parse time strings and calculate difference\n    (let* ((departure-time (parse-time first-departure-time))\n           (arrival-time (parse-time last-arrival-time))\n           (time-diff (- arrival-time departure-time)))\n      ; Convert seconds to minutes\n      (/ time-diff 60))))\n\n; Helper function to parse \"HH:MM\" time strings into total seconds since midnight\n(defun parse-time (time-string)\n  (let* ((colon-pos (position #\\: time-string))\n         (hour (parse-integer (subseq time-string 0 colon-pos)))\n         (minute (parse-integer (subseq time-string (1+ colon-pos)))))\n    (+ (* hour 3600) (* minute 60))))", "test_cases": "", "test_case_results": "Testing calculate-travel-time:\n\nInput schedule:\n  Arrival: 08:00, Departure: 08:05\n  Arrival: 08:30, Departure: NIL\nTotal travel time: 25 minutes\n\nInput schedule:\n  Arrival: 09:00, Departure: 09:10\n  Arrival: 09:45, Departure: 09:50\n  Arrival: 10:30, Departure: NIL\nTotal travel time: 80 minutes\n\nInput schedule:\n  Arrival: 12:00, Departure: 12:15\n  Arrival: 01:00, Departure: 01:05\n  Arrival: 02:00, Departure: NIL\nTotal travel time: -615 minutes", "task_id": 6531, "assertions": "(defpackage :travel-time-test\n  (:use :cl :travel-time)\n  (:export :run-tests))\n\n(in-package :travel-time-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '((:arrival \"08:00\" :departure \"08:05\")\n                       (:arrival \"08:30\" :departure nil)))\n        (test-case-2 '((:arrival \"09:00\" :departure \"09:10\")\n                       (:arrival \"09:45\" :departure \"09:50\")\n                       (:arrival \"10:30\" :departure nil)))\n        (test-case-3 '((:arrival \"12:00\" :departure \"12:15\")\n                       (:arrival \"01:00\" :departure \"01:05\")\n                       (:arrival \"02:00\" :departure nil))))\n    \n    (assert (= (calculate-travel-time test-case-1) 25) () \n            \"Test case 1 failed: Expected 25 minutes\")\n    (assert (= (calculate-travel-time test-case-2) 80) () \n            \"Test case 2 failed: Expected 80 minutes\")\n    (assert (= (calculate-travel-time test-case-3) -615) () \n            \"Test case 3 failed: Expected -615 minutes\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :travel-time-test\n  (:use :cl :travel-time)\n  (:export :run-tests))\n\n(in-package :travel-time-test)\n\n(defun run-tests ()\n  (let ((test-case-1 '((:arrival \"08:00\" :departure \"08:05\")\n                       (:arrival \"08:30\" :departure nil)))\n        (test-case-2 '((:arrival \"09:00\" :departure \"09:10\")\n                       (:arrival \"09:45\" :departure \"09:50\")\n                       (:arrival \"10:30\" :departure nil)))\n        (test-case-3 '((:arrival \"12:00\" :departure \"12:15\")\n                       (:arrival \"01:00\" :departure \"01:05\")\n                       (:arrival \"02:00\" :departure nil))))\n    \n    (assert (= (calculate-travel-time test-case-1) 25) () \n            \"Test case 1 failed: Expected 25 minutes\")\n    (assert (= (calculate-travel-time test-case-2) 80) () \n            \"Test case 2 failed: Expected 80 minutes\")\n    (assert (= (calculate-travel-time test-case-3) -615) () \n            \"Test case 3 failed: Expected -615 minutes\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "output": "calculate-travel-time"}, "all_code": "(defpackage :travel-time-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :travel-time-test)\n\n(defun calculate-travel-time (schedule)\n  (let ((first-departure-time nil)\n        (last-arrival-time nil))\n    ; Find first departure and last arrival times\n    (dolist (stop schedule)\n      (when (and (getf stop :departure) (null first-departure-time))\n        (setf first-departure-time (getf stop :departure)))\n      (when (getf stop :arrival)\n        (setf last-arrival-time (getf stop :arrival))))\n    \n    ; Parse time strings and calculate difference\n    (let* ((departure-time (parse-time first-departure-time))\n           (arrival-time (parse-time last-arrival-time))\n           (time-diff (- arrival-time departure-time)))\n      ; Convert seconds to minutes\n      (/ time-diff 60))))\n\n; Helper function to parse \"HH:MM\" time strings into total seconds since midnight\n(defun parse-time (time-string)\n  (let* ((colon-pos (position #\\: time-string))\n         (hour (parse-integer (subseq time-string 0 colon-pos)))\n         (minute (parse-integer (subseq time-string (1+ colon-pos)))))\n    (+ (* hour 3600) (* minute 60))))\n\n\n(defun run-tests ()\n  (let ((test-case-1 '((:arrival \"08:00\" :departure \"08:05\")\n                       (:arrival \"08:30\" :departure nil)))\n        (test-case-2 '((:arrival \"09:00\" :departure \"09:10\")\n                       (:arrival \"09:45\" :departure \"09:50\")\n                       (:arrival \"10:30\" :departure nil)))\n        (test-case-3 '((:arrival \"12:00\" :departure \"12:15\")\n                       (:arrival \"01:00\" :departure \"01:05\")\n                       (:arrival \"02:00\" :departure nil))))\n    \n    (assert (= (calculate-travel-time test-case-1) 25) () \n            \"Test case 1 failed: Expected 25 minutes\")\n    (assert (= (calculate-travel-time test-case-2) 80) () \n            \"Test case 2 failed: Expected 80 minutes\")\n    (assert (= (calculate-travel-time test-case-3) -615) () \n            \"Test case 3 failed: Expected -615 minutes\")\n    (format t \"All tests passed!~%\")))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(defpackage :unique-utils\n  (:use :cl)\n  (:export :find-unique-elements))\n\n(in-package :unique-utils)\n\n(defun find-unique-elements (numbers)\n  \"Takes a sorted list of integers and returns a new list containing all unique \n   integers from the input list, preserving the original order.\"\n  (if (null numbers)\n      '()\n      (let ((unique-elements (list (first numbers))))\n        (loop for i from 1 below (length numbers)\n              do (when (not (equal (nth i numbers) (nth (1- i) numbers)))\n                   (setf unique-elements (append unique-elements (list (nth i numbers))))))\n        unique-elements)))", "test_cases": "", "test_case_results": "Input: (1 1 2 3 3 3 4 5 5)\nUnique elements: (1 2 3 4 5)\n\nInput: (0 0 0 0)\nUnique elements: (0)\n\nInput: (1 2 3 4 5)\nUnique elements: (1 2 3 4 5)\n\nInput: NIL\nUnique elements: NIL", "task_id": 7325, "assertions": "(defpackage :unique-utils-test\n  (:use :cl :unique-utils)\n  (:export :run-tests))\n\n(in-package :unique-utils-test)\n\n(defun run-tests ()\n  (assert (equal (find-unique-elements '(1 1 2 3 3 3 4 5 5)) '(1 2 3 4 5))\n          () \"Test case 1 failed\")\n  (assert (equal (find-unique-elements '(0 0 0 0)) '(0))\n          () \"Test case 2 failed\")\n  (assert (equal (find-unique-elements '(1 2 3 4 5)) '(1 2 3 4 5))\n          () \"Test case 3 failed\")\n  (assert (equal (find-unique-elements '()) '())\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :unique-utils-test\n  (:use :cl :unique-utils)\n  (:export :run-tests))\n\n(in-package :unique-utils-test)\n\n(defun run-tests ()\n  (assert (equal (find-unique-elements '(1 1 2 3 3 3 4 5 5)) '(1 2 3 4 5))\n          () \"Test case 1 failed\")\n  (assert (equal (find-unique-elements '(0 0 0 0)) '(0))\n          () \"Test case 2 failed\")\n  (assert (equal (find-unique-elements '(1 2 3 4 5)) '(1 2 3 4 5))\n          () \"Test case 3 failed\")\n  (assert (equal (find-unique-elements '()) '())\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-unique-elements"}, "all_code": "(defpackage :unique-utils-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :unique-utils-test)\n\n(defun find-unique-elements (numbers)\n  \"Takes a sorted list of integers and returns a new list containing all unique \n   integers from the input list, preserving the original order.\"\n  (if (null numbers)\n      '()\n      (let ((unique-elements (list (first numbers))))\n        (loop for i from 1 below (length numbers)\n              do (when (not (equal (nth i numbers) (nth (1- i) numbers)))\n                   (setf unique-elements (append unique-elements (list (nth i numbers))))))\n        unique-elements)))\n\n\n(defun run-tests ()\n  (assert (equal (find-unique-elements '(1 1 2 3 3 3 4 5 5)) '(1 2 3 4 5))\n          () \"Test case 1 failed\")\n  (assert (equal (find-unique-elements '(0 0 0 0)) '(0))\n          () \"Test case 2 failed\")\n  (assert (equal (find-unique-elements '(1 2 3 4 5)) '(1 2 3 4 5))\n          () \"Test case 3 failed\")\n  (assert (equal (find-unique-elements '()) '())\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; length-of-longest-distinct-subarray calculates the length of the longest subarray \n; with all distinct elements in the given list of numbers.\n; It uses a sliding window approach with a hash table to keep track of the last seen \n; positions of elements to efficiently update the window boundaries.\n(defun length-of-longest-distinct-subarray (nums)\n  (let ((n (length nums))\n        (max-length 0)\n        (left 0)\n        (seen (make-hash-table)))\n    (if (zerop n)\n        0\n        (progn\n          (loop for right from 0 below n do\n            (let ((current (nth right nums)))\n              (when (and (gethash current seen) (>= (gethash current seen) left))\n                (setf left (1+ (gethash current seen))))\n              (setf (gethash current seen) right)\n              (setf max-length (max max-length (- right left 1)))))\n          max-length))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 1 2 3 4)\nLength: 2\nInput: (1 2 1 3 4 5 6 7 8 9)\nLength: 7\nInput: (1 1 1 1 1)\nLength: 0\nInput: (1 2 3 4 5 6 7 8 9)\nLength: 7\nInput: NIL\nLength: 0", "task_id": 11134, "assertions": "(defpackage :distinct-subarray-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :distinct-subarray-test)\n\n(defun run-tests ()\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 1 2 3 4)) 2) () \n          \"Test case 1 failed: Expected 2\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 1 3 4 5 6 7 8 9)) 7) () \n          \"Test case 2 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '(1 1 1 1 1)) 0) () \n          \"Test case 3 failed: Expected 0\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 5 6 7 8 9)) 7) () \n          \"Test case 4 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '()) 0) () \n          \"Test case 5 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :distinct-subarray-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :distinct-subarray-test)\n\n(defun run-tests ()\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 1 2 3 4)) 2) () \n          \"Test case 1 failed: Expected 2\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 1 3 4 5 6 7 8 9)) 7) () \n          \"Test case 2 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '(1 1 1 1 1)) 0) () \n          \"Test case 3 failed: Expected 0\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 5 6 7 8 9)) 7) () \n          \"Test case 4 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '()) 0) () \n          \"Test case 5 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "length-of-longest-distinct-subarray"}, "all_code": "(defpackage :distinct-subarray-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :distinct-subarray-test)\n\n(defun length-of-longest-distinct-subarray (nums)\n  (let ((n (length nums))\n        (max-length 0)\n        (left 0)\n        (seen (make-hash-table)))\n    (if (zerop n)\n        0\n        (progn\n          (loop for right from 0 below n do\n            (let ((current (nth right nums)))\n              (when (and (gethash current seen) (>= (gethash current seen) left))\n                (setf left (1+ (gethash current seen))))\n              (setf (gethash current seen) right)\n              (setf max-length (max max-length (- right left 1)))))\n          max-length))))\n\n\n(defun run-tests ()\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 1 2 3 4)) 2) () \n          \"Test case 1 failed: Expected 2\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 1 3 4 5 6 7 8 9)) 7) () \n          \"Test case 2 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '(1 1 1 1 1)) 0) () \n          \"Test case 3 failed: Expected 0\")\n  (assert (= (length-of-longest-distinct-subarray '(1 2 3 4 5 6 7 8 9)) 7) () \n          \"Test case 4 failed: Expected 7\")\n  (assert (= (length-of-longest-distinct-subarray '()) 0) () \n          \"Test case 5 failed: Expected 0\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; min-time-cost calculates the minimum time cost for each query range of segments.\n;; \n;; Parameters:\n;; - n: Number of segments (unused in the function but kept for interface consistency)\n;; - q: Number of queries (unused in the function but kept for interface consistency)\n;; - time-costs: List of time costs for each segment\n;; - queries: List of query tuples indicating the range of segments in the form (l r)\n;;\n;; Returns a list of minimum time costs for each query range.\n(defun min-time-cost (n q time-costs queries)\n  (mapcar (lambda (query)\n            (let ((l (first query))\n                  (r (second query)))\n              (apply #'min (subseq time-costs (1- l) r))))\n          queries))", "test_cases": "", "test_case_results": "Test Case 1:\nTime Costs: (5 3 7 2 8 6)\nQueries: ((1 3) (2 5) (4 6))\nResults: (3 2 2)\n\nTest Case 2:\nTime Costs: (10 20 30 40 50)\nQueries: ((1 5) (2 4) (3 3))\nResults: (10 20 30)", "task_id": 24623, "assertions": "(defpackage :min-time-cost-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-time-cost-test)\n\n(defun run-tests ()\n  ;; Test Case 1\n  (let ((result1 (min-time-cost 6 3 '(5 3 7 2 8 6) '((1 3) (2 5) (4 6)))))\n    (assert (equal result1 '(3 2 2)) () \"Test Case 1 failed\"))\n  \n  ;; Test Case 2\n  (let ((result2 (min-time-cost 5 3 '(10 20 30 40 50) '((1 5) (2 4) (3 3)))))\n    (assert (equal result2 '(10 20 30)) () \"Test Case 2 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :min-time-cost-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :min-time-cost-test)\n\n(defun run-tests ()\n  ;; Test Case 1\n  (let ((result1 (min-time-cost 6 3 '(5 3 7 2 8 6) '((1 3) (2 5) (4 6)))))\n    (assert (equal result1 '(3 2 2)) () \"Test Case 1 failed\"))\n  \n  ;; Test Case 2\n  (let ((result2 (min-time-cost 5 3 '(10 20 30 40 50) '((1 5) (2 4) (3 3)))))\n    (assert (equal result2 '(10 20 30)) () \"Test Case 2 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "min-time-cost"}, "all_code": "(defpackage :min-time-cost-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :min-time-cost-test)\n\n(defun min-time-cost (n q time-costs queries)\n  (mapcar (lambda (query)\n            (let ((l (first query))\n                  (r (second query)))\n              (apply #'min (subseq time-costs (1- l) r))))\n          queries))\n\n\n(defun run-tests ()\n  ;; Test Case 1\n  (let ((result1 (min-time-cost 6 3 '(5 3 7 2 8 6) '((1 3) (2 5) (4 6)))))\n    (assert (equal result1 '(3 2 2)) () \"Test Case 1 failed\"))\n  \n  ;; Test Case 2\n  (let ((result2 (min-time-cost 5 3 '(10 20 30 40 50) '((1 5) (2 4) (3 3)))))\n    (assert (equal result2 '(10 20 30)) () \"Test Case 2 failed\"))\n  \n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;; interesting-sequence generates a sequence of the first n powers of 2.\n;; If n is less than 1, it returns the string \"impossible\".\n;; The sequence is returned as a space-separated string of numbers.\n(defun interesting-sequence (n)\n  (if (< n 1)\n      \"impossible\"\n      (format nil \"~{~a~^ ~}\" (loop for i from 0 below n collect (expt 2 i)))))", "test_cases": "", "test_case_results": "Input: 0\nSequence: impossible\n\nInput: 1\nSequence: 1\n\nInput: 5\nSequence: 1 2 4 8 16\n\nInput: 10\nSequence: 1 2 4 8 16 32 64 128 256 512", "task_id": 17204, "assertions": "(in-package :cl-user)\n\n(defun test-interesting-sequence ()\n  (assert (string= (interesting-sequence 0) \"impossible\") () \"Test case 0 failed\")\n  (assert (string= (interesting-sequence 1) \"1\") () \"Test case 1 failed\")\n  (assert (string= (interesting-sequence 5) \"1 2 4 8 16\") () \"Test case 5 failed\")\n  (assert (string= (interesting-sequence 10) \"1 2 4 8 16 32 64 128 256 512\") () \"Test case 10 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-interesting-sequence)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(in-package :cl-user)\n\n(defun test-interesting-sequence ()\n  (assert (string= (interesting-sequence 0) \"impossible\") () \"Test case 0 failed\")\n  (assert (string= (interesting-sequence 1) \"1\") () \"Test case 1 failed\")\n  (assert (string= (interesting-sequence 5) \"1 2 4 8 16\") () \"Test case 5 failed\")\n  (assert (string= (interesting-sequence 10) \"1 2 4 8 16 32 64 128 256 512\") () \"Test case 10 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-interesting-sequence)", "output": "interesting-sequence"}, "all_code": "(in-package :cl-user)\n\n(defun interesting-sequence (n)\n  (if (< n 1)\n      \"impossible\"\n      (format nil \"~{~a~^ ~}\" (loop for i from 0 below n collect (expt 2 i)))))\n\n\n(defun test-interesting-sequence ()\n  (assert (string= (interesting-sequence 0) \"impossible\") () \"Test case 0 failed\")\n  (assert (string= (interesting-sequence 1) \"1\") () \"Test case 1 failed\")\n  (assert (string= (interesting-sequence 5) \"1 2 4 8 16\") () \"Test case 5 failed\")\n  (assert (string= (interesting-sequence 10) \"1 2 4 8 16 32 64 128 256 512\") () \"Test case 10 failed\")\n  (format t \"All tests passed!~%\"))\n\n(test-interesting-sequence)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n;;; longest-consecutive-sequence calculates the length of the longest consecutive sequence in a grid.\n;;; A consecutive sequence is defined as adjacent cells (up, down, left, right) where each subsequent cell's value is 1 greater than the previous.\n;;; The function uses depth-first search (DFS) with memoization to optimize repeated calculations.\n;;; \n;;; Parameters:\n;;;   grid - A 2D list of numbers representing the grid.\n;;; Returns:\n;;;   The length of the longest consecutive sequence found in the grid.\n\n(defun longest-consecutive-sequence (grid)\n  (if (or (null grid) (null (first grid)))\n      0\n      (let ((memo (make-hash-table :test 'equal)))\n        (labels ((dfs (x y)\n                   (let ((key (cons x y)))\n                     (if (gethash key memo)\n                         (gethash key memo)\n                         (let ((max-len 1))\n                           (dolist (dir '((-1 0) (1 0) (0 -1) (0 1)) max-len)\n                             (let* ((dx (first dir))\n                                    (dy (second dir))\n                                    (nx (+ x dx))\n                                    (ny (+ y dy)))\n                               (when (and (<= 0 nx (1- (length grid)))\n                                          (<= 0 ny (1- (length (first grid))))\n                                          (= (aref (make-array (list (length grid) (length (first grid)))\n                                                               :initial-contents grid)\n                                                  nx ny)\n                                             (1+ (aref (make-array (list (length grid) (length (first grid)))\n                                                                   :initial-contents grid)\n                                                       x y))))\n                                 (setf max-len (max max-len (1+ (dfs nx ny)))))))\n                           (setf (gethash key memo) max-len))))))\n          (loop for x from 0 below (length grid)\n                maximize (loop for y from 0 below (length (first grid))\n                              maximize (dfs x y)))))))", "test_cases": "", "test_case_results": "Input: ((3 2 5) (4 1 6) (7 0 9))\nLongest consecutive sequence: 5\nInput: ((1 2 3) (8 9 4) (7 6 5))\nLongest consecutive sequence: 9\nInput: ((1 2) (4 3))\nLongest consecutive sequence: 4\nInput: NIL\nLongest consecutive sequence: 0", "task_id": 17443, "assertions": "(defpackage :longest-sequence-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :longest-sequence-test)\n\n(defun run-tests ()\n  (assert (= (longest-consecutive-sequence '((3 2 5) (4 1 6) (7 0 9))) 5)\n          () \"Test case 1 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2 3) (8 9 4) (7 6 5))) 9)\n          () \"Test case 2 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2) (4 3))) 4)\n          () \"Test case 3 failed\")\n  (assert (= (longest-consecutive-sequence nil) 0)\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :longest-sequence-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :longest-sequence-test)\n\n(defun run-tests ()\n  (assert (= (longest-consecutive-sequence '((3 2 5) (4 1 6) (7 0 9))) 5)\n          () \"Test case 1 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2 3) (8 9 4) (7 6 5))) 9)\n          () \"Test case 2 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2) (4 3))) 4)\n          () \"Test case 3 failed\")\n  (assert (= (longest-consecutive-sequence nil) 0)\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "longest-consecutive-sequence"}, "all_code": "(defpackage :longest-sequence-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :longest-sequence-test)\n\n(defun longest-consecutive-sequence (grid)\n  (if (or (null grid) (null (first grid)))\n      0\n      (let ((memo (make-hash-table :test 'equal)))\n        (labels ((dfs (x y)\n                   (let ((key (cons x y)))\n                     (if (gethash key memo)\n                         (gethash key memo)\n                         (let ((max-len 1))\n                           (dolist (dir '((-1 0) (1 0) (0 -1) (0 1)) max-len)\n                             (let* ((dx (first dir))\n                                    (dy (second dir))\n                                    (nx (+ x dx))\n                                    (ny (+ y dy)))\n                               (when (and (<= 0 nx (1- (length grid)))\n                                          (<= 0 ny (1- (length (first grid))))\n                                          (= (aref (make-array (list (length grid) (length (first grid)))\n                                                               :initial-contents grid)\n                                                  nx ny)\n                                             (1+ (aref (make-array (list (length grid) (length (first grid)))\n                                                                   :initial-contents grid)\n                                                       x y))))\n                                 (setf max-len (max max-len (1+ (dfs nx ny)))))))\n                           (setf (gethash key memo) max-len))))))\n          (loop for x from 0 below (length grid)\n                maximize (loop for y from 0 below (length (first grid))\n                              maximize (dfs x y)))))))\n\n\n(defun run-tests ()\n  (assert (= (longest-consecutive-sequence '((3 2 5) (4 1 6) (7 0 9))) 5)\n          () \"Test case 1 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2 3) (8 9 4) (7 6 5))) 9)\n          () \"Test case 2 failed\")\n  (assert (= (longest-consecutive-sequence '((1 2) (4 3))) 4)\n          () \"Test case 3 failed\")\n  (assert (= (longest-consecutive-sequence nil) 0)\n          () \"Test case 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; string-reorder reorders the characters in a string according to the given indices.\n; It takes a string and a list of indices, then constructs a new string where each character\n; from the original string is placed at the corresponding index in the indices list.\n; If the indices list is shorter than the string, the behavior is undefined.\n(defun string-reorder (s indices)\n  (let* ((len (length s))\n         (result (make-array len :element-type 'character :initial-element #\\Space)))\n    (loop for i from 0 below (length indices)\n          for index = (nth i indices)\n          do (setf (aref result index) (char s i)))\n    (coerce result 'string)))", "test_cases": "", "test_case_results": "Input string: abc\nIndices: (0 1 2)\nReordered string: abc\n\nInput string: abc\nIndices: (2 1 0)\nReordered string: cba\n\nInput string: hello\nIndices: (4 3 2 1 0)\nReordered string: olleh\n\nInput string: world\nIndices: (1 0 2 3 4)\nReordered string: owrld", "task_id": 24253, "assertions": "(defpackage :string-reorder-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-reorder-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user::string-reorder \"abc\" '(0 1 2)) \"abc\") () \"Test 1 failed\")\n  (assert (string= (cl-user::string-reorder \"abc\" '(2 1 0)) \"cba\") () \"Test 2 failed\")\n  (assert (string= (cl-user::string-reorder \"hello\" '(4 3 2 1 0)) \"olleh\") () \"Test 3 failed\")\n  (assert (string= (cl-user::string-reorder \"world\" '(1 0 2 3 4)) \"owrld\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :string-reorder-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :string-reorder-test)\n\n(defun run-tests ()\n  (assert (string= (cl-user::string-reorder \"abc\" '(0 1 2)) \"abc\") () \"Test 1 failed\")\n  (assert (string= (cl-user::string-reorder \"abc\" '(2 1 0)) \"cba\") () \"Test 2 failed\")\n  (assert (string= (cl-user::string-reorder \"hello\" '(4 3 2 1 0)) \"olleh\") () \"Test 3 failed\")\n  (assert (string= (cl-user::string-reorder \"world\" '(1 0 2 3 4)) \"owrld\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "string-reorder"}, "all_code": "(defpackage :string-reorder-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :string-reorder-test)\n\n(defun string-reorder (s indices)\n  (let* ((len (length s))\n         (result (make-array len :element-type 'character :initial-element #\\Space)))\n    (loop for i from 0 below (length indices)\n          for index = (nth i indices)\n          do (setf (aref result index) (char s i)))\n    (coerce result 'string)))\n\n\n(defun run-tests ()\n  (assert (string= (cl-user::string-reorder \"abc\" '(0 1 2)) \"abc\") () \"Test 1 failed\")\n  (assert (string= (cl-user::string-reorder \"abc\" '(2 1 0)) \"cba\") () \"Test 2 failed\")\n  (assert (string= (cl-user::string-reorder \"hello\" '(4 3 2 1 0)) \"olleh\") () \"Test 3 failed\")\n  (assert (string= (cl-user::string-reorder \"world\" '(1 0 2 3 4)) \"owrld\") () \"Test 4 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "RUNTIME_ERROR"}
{"code": "(in-package :cl-user)\n\n; fibonacci generates a list of the first n Fibonacci numbers.\n; The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones.\n; Args:\n;   n - The number of Fibonacci numbers to generate.\n; Returns:\n;   A list of the first n Fibonacci numbers.\n(defun fibonacci (n)\n  (let ((a 0)\n        (b 1)\n        (fib-sequence '()))\n    (dotimes (i n fib-sequence)\n      (push a fib-sequence)\n      (psetf a b\n             b (+ a b)))\n    (reverse fib-sequence)))", "test_cases": "", "test_case_results": "Input n: 0\nFibonacci sequence: NIL\n\nInput n: 1\nFibonacci sequence: (0)\n\nInput n: 5\nFibonacci sequence: (0 1 1 2 3)\n\nInput n: 10\nFibonacci sequence: (0 1 1 2 3 5 8 13 21 34)", "task_id": 7163, "assertions": "(defpackage :fibonacci-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :fibonacci-test)\n\n(defun run-tests ()\n  (assert (equal (fibonacci 0) nil) () \"0 Fibonacci numbers should be NIL\")\n  (assert (equal (fibonacci 1) '(0)) () \"1 Fibonacci number should be (0)\")\n  (assert (equal (fibonacci 5) '(0 1 1 2 3)) () \"5 Fibonacci numbers should be (0 1 1 2 3)\")\n  (assert (equal (fibonacci 10) '(0 1 1 2 3 5 8 13 21 34)) () \"10 Fibonacci numbers should be (0 1 1 2 3 5 8 13 21 34)\")\n  (format t \"All Fibonacci tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :fibonacci-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :fibonacci-test)\n\n(defun run-tests ()\n  (assert (equal (fibonacci 0) nil) () \"0 Fibonacci numbers should be NIL\")\n  (assert (equal (fibonacci 1) '(0)) () \"1 Fibonacci number should be (0)\")\n  (assert (equal (fibonacci 5) '(0 1 1 2 3)) () \"5 Fibonacci numbers should be (0 1 1 2 3)\")\n  (assert (equal (fibonacci 10) '(0 1 1 2 3 5 8 13 21 34)) () \"10 Fibonacci numbers should be (0 1 1 2 3 5 8 13 21 34)\")\n  (format t \"All Fibonacci tests passed!~%\"))\n\n(run-tests)", "output": "fibonacci"}, "all_code": "(defpackage :fibonacci-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :fibonacci-test)\n\n(defun fibonacci (n)\n  (let ((a 0)\n        (b 1)\n        (fib-sequence '()))\n    (dotimes (i n fib-sequence)\n      (push a fib-sequence)\n      (psetf a b\n             b (+ a b)))\n    (reverse fib-sequence)))\n\n\n(defun run-tests ()\n  (assert (equal (fibonacci 0) nil) () \"0 Fibonacci numbers should be NIL\")\n  (assert (equal (fibonacci 1) '(0)) () \"1 Fibonacci number should be (0)\")\n  (assert (equal (fibonacci 5) '(0 1 1 2 3)) () \"5 Fibonacci numbers should be (0 1 1 2 3)\")\n  (assert (equal (fibonacci 10) '(0 1 1 2 3 5 8 13 21 34)) () \"10 Fibonacci numbers should be (0 1 1 2 3 5 8 13 21 34)\")\n  (format t \"All Fibonacci tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
{"code": "(in-package :cl-user)\n\n; find-mode computes the mode(s) of a given list of numbers.\n; The mode is the value that appears most frequently in the dataset.\n; If there are multiple values with the same maximum frequency, all are returned.\n; The returned modes are sorted in ascending order.\n; If the input list is empty, an empty list is returned.\n(defun find-mode (data)\n  (if (null data)\n      '()\n      (let* ((frequency-table (make-hash-table))\n             (max-frequency 0)\n             (modes '()))\n        ; Count frequencies of each number in the data\n        (dolist (number data)\n          (incf (gethash number frequency-table 0)))\n        ; Find the maximum frequency\n        (maphash (lambda (number freq)\n                   (when (> freq max-frequency)\n                     (setf max-frequency freq)))\n                 frequency-table)\n        ; Collect all numbers with max frequency\n        (maphash (lambda (number freq)\n                   (when (= freq max-frequency)\n                     (push number modes)))\n                 frequency-table)\n        ; Return sorted modes\n        (sort modes #'<))))", "test_cases": "", "test_case_results": "Input: (1 2 2 3 4)\nModes: (2)\n\nInput: (5 5 6 6 7)\nModes: (5 6)\n\nInput: (0 0 0 0)\nModes: (0)\n\nInput: (1 2 3 4)\nModes: (1 2 3 4)\n\nInput: NIL\nModes: NIL\n\nInput: (1 1 2 2 3 3 4)\nModes: (1 2 3)", "task_id": 19046, "assertions": "(defpackage :mode-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :mode-test)\n\n(defun run-tests ()\n  (assert (equal (find-mode '(1 2 2 3 4)) '(2)) () \"Test case 1 failed\")\n  (assert (equal (find-mode '(5 5 6 6 7)) '(5 6)) () \"Test case 2 failed\")\n  (assert (equal (find-mode '(0 0 0 0)) '(0)) () \"Test case 3 failed\")\n  (assert (equal (find-mode '(1 2 3 4)) '(1 2 3 4)) () \"Test case 4 failed\")\n  (assert (equal (find-mode '()) '()) () \"Test case 5 failed\")\n  (assert (equal (find-mode '(1 1 2 2 3 3 4)) '(1 2 3)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\n(defpackage :mode-test\n  (:use :cl :cl-user)\n  (:export :run-tests))\n\n(in-package :mode-test)\n\n(defun run-tests ()\n  (assert (equal (find-mode '(1 2 2 3 4)) '(2)) () \"Test case 1 failed\")\n  (assert (equal (find-mode '(5 5 6 6 7)) '(5 6)) () \"Test case 2 failed\")\n  (assert (equal (find-mode '(0 0 0 0)) '(0)) () \"Test case 3 failed\")\n  (assert (equal (find-mode '(1 2 3 4)) '(1 2 3 4)) () \"Test case 4 failed\")\n  (assert (equal (find-mode '()) '()) () \"Test case 5 failed\")\n  (assert (equal (find-mode '(1 1 2 2 3 3 4)) '(1 2 3)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "output": "find-mode"}, "all_code": "(defpackage :mode-test\n  (:use :cl)\n  (:export :run-tests))\n\n(in-package :mode-test)\n\n(defun find-mode (data)\n  (if (null data)\n      '()\n      (let* ((frequency-table (make-hash-table))\n             (max-frequency 0)\n             (modes '()))\n        ; Count frequencies of each number in the data\n        (dolist (number data)\n          (incf (gethash number frequency-table 0)))\n        ; Find the maximum frequency\n        (maphash (lambda (number freq)\n                   (when (> freq max-frequency)\n                     (setf max-frequency freq)))\n                 frequency-table)\n        ; Collect all numbers with max frequency\n        (maphash (lambda (number freq)\n                   (when (= freq max-frequency)\n                     (push number modes)))\n                 frequency-table)\n        ; Return sorted modes\n        (sort modes #'<))))\n\n\n(defun run-tests ()\n  (assert (equal (find-mode '(1 2 2 3 4)) '(2)) () \"Test case 1 failed\")\n  (assert (equal (find-mode '(5 5 6 6 7)) '(5 6)) () \"Test case 2 failed\")\n  (assert (equal (find-mode '(0 0 0 0)) '(0)) () \"Test case 3 failed\")\n  (assert (equal (find-mode '(1 2 3 4)) '(1 2 3 4)) () \"Test case 4 failed\")\n  (assert (equal (find-mode '()) '()) () \"Test case 5 failed\")\n  (assert (equal (find-mode '(1 1 2 2 3 3 4)) '(1 2 3)) () \"Test case 6 failed\")\n  (format t \"All tests passed!~%\"))\n\n(run-tests)", "exec_outcome": "PASSED"}
