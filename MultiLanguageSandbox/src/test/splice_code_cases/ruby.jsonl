{"code": "require 'set'\n\ndef find_anagrams(strs)\n  anagrams = Hash.new { |h, k| h[k] = [] }\n  \n  strs.each do |s|\n    key = s.chars.sort.join\n    anagrams[key] << s\n  end\n  \n  anagrams.values.to_a\nend", "test_cases": "", "test_case_results": "Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\nAnagrams: [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\nInput: [\"\"]\nAnagrams: [[\"\"]]\nInput: [\"a\"]\nAnagrams: [[\"a\"]]\nInput: [\"listen\", \"silent\", \"enlist\", \"hello\", \"world\"]\nAnagrams: [[\"listen\", \"silent\", \"enlist\"], [\"hello\"], [\"world\"]]", "task_id": 23886, "assertions": "def test_find_anagrams()\n  raise unless find_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n  raise unless find_anagrams([\"\"]) == [[\"\"]]\n  raise unless find_anagrams([\"a\"]) == [[\"a\"]]\n  raise unless find_anagrams([\"listen\", \"silent\", \"enlist\", \"hello\", \"world\"]) == [[\"listen\", \"silent\", \"enlist\"], [\"hello\"], [\"world\"]]\nend\n\ntest_find_anagrams()", "all_code": "require 'set'\n\ndef find_anagrams(strs)\n  anagrams = Hash.new { |h, k| h[k] = [] }\n  \n  strs.each do |s|\n    key = s.chars.sort.join\n    anagrams[key] << s\n  end\n  \n  anagrams.values.to_a\nend\ndef test_find_anagrams()\n  raise unless find_anagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]) == [[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]\n  raise unless find_anagrams([\"\"]) == [[\"\"]]\n  raise unless find_anagrams([\"a\"]) == [[\"a\"]]\n  raise unless find_anagrams([\"listen\", \"silent\", \"enlist\", \"hello\", \"world\"]) == [[\"listen\", \"silent\", \"enlist\"], [\"hello\"], [\"world\"]]\nend\n\ntest_find_anagrams()", "exec_outcome": "PASSED"}
{"code": "# calculate_rpn evaluates an expression in Reverse Polish Notation (RPN).\n# The expression is given as a string with tokens separated by spaces.\n# Valid tokens are integers and the operators +, -, *, /.\n# Division uses integer division (rounded down).\n# Returns the result as an integer, or nil if the expression is invalid.\n# An invalid expression can be due to:\n# - Empty expression\n# - Insufficient operands for an operator\n# - Division by zero\n# - Non-integer/non-operator tokens\n# - More than one value left on the stack after evaluation\ndef calculate_rpn(expression)\n  return nil if expression.nil? || expression.strip.empty?\n\n  stack = []\n  tokens = expression.split\n\n  tokens.each do |token|\n    if %w[+ - * /].include?(token)\n      return nil if stack.size < 2\n\n      b = stack.pop\n      a = stack.pop\n\n      result = case token\n               when '+' then a + b\n               when '-' then a - b\n               when '*' then a * b\n               when '/'\n                 return nil if b == 0\n                 a / b  # Integer division in Ruby\n               end\n      stack.push(result)\n    else\n      # Try to convert token to integer\n      begin\n        stack.push(Integer(token))\n      rescue ArgumentError\n        return nil\n      end\n    end\n  end\n\n  stack.size == 1 ? stack.pop : nil\nend", "test_cases": "", "test_case_results": "Input: \"3 4 +\"\nResult: 7\nInput: \"5 2 -\"\nResult: 3\nInput: \"4 5 *\"\nResult: 20\nInput: \"20 5 /\"\nResult: 4\nInput: \"20 0 /\"\nResult: nil\nInput: \"3 4 + 5 *\"\nResult: 35\nInput: \"7 2 3 + -\"\nResult: 2\nInput: \"3 4 + 5\"\nResult: nil\nInput: \"3 4 + *\"\nResult: nil\nInput: \"3 4 + 5 * 2 /\"\nResult: 17\nInput: \"a 4 +\"\nResult: nil\nInput: \"\"\nResult: nil\nInput: \"   \"\nResult: nil\nInput: \"5\"\nResult: 5\nInput: \"+\"\nResult: nil", "task_id": 18307, "assertions": "def test_calculate_rpn()\n  raise unless calculate_rpn(\"3 4 +\") == 7\n  raise unless calculate_rpn(\"5 2 -\") == 3\n  raise unless calculate_rpn(\"4 5 *\") == 20\n  raise unless calculate_rpn(\"20 5 /\") == 4\n  raise unless calculate_rpn(\"20 0 /\").nil?\n  raise unless calculate_rpn(\"3 4 + 5 *\") == 35\n  raise unless calculate_rpn(\"7 2 3 + -\") == 2\n  raise unless calculate_rpn(\"3 4 + 5\").nil?\n  raise unless calculate_rpn(\"3 4 + *\").nil?\n  raise unless calculate_rpn(\"3 4 + 5 * 2 /\") == 17\n  raise unless calculate_rpn(\"a 4 +\").nil?\n  raise unless calculate_rpn(\"\").nil?\n  raise unless calculate_rpn(\"   \").nil?\n  raise unless calculate_rpn(\"5\") == 5\n  raise unless calculate_rpn(\"+\").nil?\nend\n\ntest_calculate_rpn()", "all_code": "# calculate_rpn evaluates an expression in Reverse Polish Notation (RPN).\n# The expression is given as a string with tokens separated by spaces.\n# Valid tokens are integers and the operators +, -, *, /.\n# Division uses integer division (rounded down).\n# Returns the result as an integer, or nil if the expression is invalid.\n# An invalid expression can be due to:\n# - Empty expression\n# - Insufficient operands for an operator\n# - Division by zero\n# - Non-integer/non-operator tokens\n# - More than one value left on the stack after evaluation\ndef calculate_rpn(expression)\n  return nil if expression.nil? || expression.strip.empty?\n\n  stack = []\n  tokens = expression.split\n\n  tokens.each do |token|\n    if %w[+ - * /].include?(token)\n      return nil if stack.size < 2\n\n      b = stack.pop\n      a = stack.pop\n\n      result = case token\n               when '+' then a + b\n               when '-' then a - b\n               when '*' then a * b\n               when '/'\n                 return nil if b == 0\n                 a / b  # Integer division in Ruby\n               end\n      stack.push(result)\n    else\n      # Try to convert token to integer\n      begin\n        stack.push(Integer(token))\n      rescue ArgumentError\n        return nil\n      end\n    end\n  end\n\n  stack.size == 1 ? stack.pop : nil\nend\ndef test_calculate_rpn()\n  raise unless calculate_rpn(\"3 4 +\") == 7\n  raise unless calculate_rpn(\"5 2 -\") == 3\n  raise unless calculate_rpn(\"4 5 *\") == 20\n  raise unless calculate_rpn(\"20 5 /\") == 4\n  raise unless calculate_rpn(\"20 0 /\").nil?\n  raise unless calculate_rpn(\"3 4 + 5 *\") == 35\n  raise unless calculate_rpn(\"7 2 3 + -\") == 2\n  raise unless calculate_rpn(\"3 4 + 5\").nil?\n  raise unless calculate_rpn(\"3 4 + *\").nil?\n  raise unless calculate_rpn(\"3 4 + 5 * 2 /\") == 17\n  raise unless calculate_rpn(\"a 4 +\").nil?\n  raise unless calculate_rpn(\"\").nil?\n  raise unless calculate_rpn(\"   \").nil?\n  raise unless calculate_rpn(\"5\") == 5\n  raise unless calculate_rpn(\"+\").nil?\nend\n\ntest_calculate_rpn()", "exec_outcome": "PASSED"}
{"code": "# two_sum finds two distinct numbers in the array that add up to the target and returns them sorted in ascending order.\n# If multiple pairs exist, it returns the pair with the smallest first number.\n# If no such pair exists, it returns an empty array.\n#\n# @param nums [Array<Integer>] the input array of numbers\n# @param target [Integer] the target sum to find\n# @return [Array<Integer>] the pair of numbers that sum to the target, or an empty array if no such pair exists\ndef two_sum(nums, target)\n  seen = {}\n  smallest_pair = nil\n\n  nums.each do |num|\n    complement = target - num\n    if seen.key?(complement)\n      current_pair = [num, complement].sort\n      if smallest_pair.nil? || current_pair[0] < smallest_pair[0]\n        smallest_pair = current_pair\n      end\n    end\n    seen[num] = true\n  end\n\n  smallest_pair || []\nend", "test_cases": "", "test_case_results": "Input: nums = [2, 7, 11, 15], target = 9\nResult: [2, 7]\n---\nInput: nums = [3, 2, 4], target = 6\nResult: [2, 4]\n---\nInput: nums = [3, 3], target = 6\nResult: [3, 3]\n---\nInput: nums = [1, 2, 3, 4], target = 10\nResult: []\n---\nInput: nums = [5, 1, 4, 2, 3], target = 6\nResult: [1, 5]\n---", "task_id": 29053, "assertions": "def test_two_sum()\n  raise \"Test case 1 failed\" unless two_sum([2, 7, 11, 15], 9) == [2, 7]\n  raise \"Test case 2 failed\" unless two_sum([3, 2, 4], 6) == [2, 4]\n  raise \"Test case 3 failed\" unless two_sum([3, 3], 6) == [3, 3]\n  raise \"Test case 4 failed\" unless two_sum([1, 2, 3, 4], 10) == []\n  raise \"Test case 5 failed\" unless two_sum([5, 1, 4, 2, 3], 6) == [1, 5]\n  puts \"All tests passed!\"\nend\n\ntest_two_sum()", "all_code": "# two_sum finds two distinct numbers in the array that add up to the target and returns them sorted in ascending order.\n# If multiple pairs exist, it returns the pair with the smallest first number.\n# If no such pair exists, it returns an empty array.\n#\n# @param nums [Array<Integer>] the input array of numbers\n# @param target [Integer] the target sum to find\n# @return [Array<Integer>] the pair of numbers that sum to the target, or an empty array if no such pair exists\ndef two_sum(nums, target)\n  seen = {}\n  smallest_pair = nil\n\n  nums.each do |num|\n    complement = target - num\n    if seen.key?(complement)\n      current_pair = [num, complement].sort\n      if smallest_pair.nil? || current_pair[0] < smallest_pair[0]\n        smallest_pair = current_pair\n      end\n    end\n    seen[num] = true\n  end\n\n  smallest_pair || []\nend\ndef test_two_sum()\n  raise \"Test case 1 failed\" unless two_sum([2, 7, 11, 15], 9) == [2, 7]\n  raise \"Test case 2 failed\" unless two_sum([3, 2, 4], 6) == [2, 4]\n  raise \"Test case 3 failed\" unless two_sum([3, 3], 6) == [3, 3]\n  raise \"Test case 4 failed\" unless two_sum([1, 2, 3, 4], 10) == []\n  raise \"Test case 5 failed\" unless two_sum([5, 1, 4, 2, 3], 6) == [1, 5]\n  puts \"All tests passed!\"\nend\n\ntest_two_sum()", "exec_outcome": "PASSED"}
{"code": "# rearrange_list takes an array of integers and a pivot value k.\n# It rearranges the array such that all numbers less than or equal to k\n# come before numbers greater than k, while preserving the relative order of elements.\n# The method does this by iterating through the input array and separating elements\n# into two sub-arrays: one for elements <= k and another for elements > k.\n# These sub-arrays are then concatenated to produce the final result.\ndef rearrange_list(nums, k)\n  less_or_equal = []\n  greater = []\n\n  nums.each do |num|\n    if num <= k\n      less_or_equal << num\n    else\n      greater << num\n    end\n  end\n\n  less_or_equal + greater\nend", "test_cases": "", "test_case_results": "Input array: [1, 4, 3, 2, 5, 2], Pivot k: 3\nRearranged array: [1, 3, 2, 2, 4, 5]\nInput array: [5, 6, 7, 8, 9], Pivot k: 4\nRearranged array: [5, 6, 7, 8, 9]\nInput array: [10, 20, 30, 40], Pivot k: 50\nRearranged array: [10, 20, 30, 40]\nInput array: [], Pivot k: 5\nRearranged array: []", "task_id": 27898, "assertions": "def test_rearrange_list()\n  raise unless rearrange_list([1, 4, 3, 2, 5, 2], 3) == [1, 3, 2, 2, 4, 5]\n  raise unless rearrange_list([5, 6, 7, 8, 9], 4) == [5, 6, 7, 8, 9]\n  raise unless rearrange_list([10, 20, 30, 40], 50) == [10, 20, 30, 40]\n  raise unless rearrange_list([], 5) == []\nend\n\ntest_rearrange_list()", "all_code": "# rearrange_list takes an array of integers and a pivot value k.\n# It rearranges the array such that all numbers less than or equal to k\n# come before numbers greater than k, while preserving the relative order of elements.\n# The method does this by iterating through the input array and separating elements\n# into two sub-arrays: one for elements <= k and another for elements > k.\n# These sub-arrays are then concatenated to produce the final result.\ndef rearrange_list(nums, k)\n  less_or_equal = []\n  greater = []\n\n  nums.each do |num|\n    if num <= k\n      less_or_equal << num\n    else\n      greater << num\n    end\n  end\n\n  less_or_equal + greater\nend\ndef test_rearrange_list()\n  raise unless rearrange_list([1, 4, 3, 2, 5, 2], 3) == [1, 3, 2, 2, 4, 5]\n  raise unless rearrange_list([5, 6, 7, 8, 9], 4) == [5, 6, 7, 8, 9]\n  raise unless rearrange_list([10, 20, 30, 40], 50) == [10, 20, 30, 40]\n  raise unless rearrange_list([], 5) == []\nend\n\ntest_rearrange_list()", "exec_outcome": "PASSED"}
{"code": "# Rotates the array `arr` to the left by `k` positions.\n# If the array is empty, it returns the array as-is.\n# The rotation count `k` is adjusted using modulo operation to handle cases where `k` is larger than the array size.\ndef rotate_left(arr, k)\n  return arr if arr.empty?\n  k = k % arr.size\n  arr[k..-1] + arr[0...k]\nend\n\n# Rotates the array `arr` to the right by `k` positions.\n# If the array is empty, it returns the array as-is.\n# The rotation count `k` is adjusted using modulo operation to handle cases where `k` is larger than the array size.\ndef rotate_right(arr, k)\n  return arr if arr.empty?\n  k = k % arr.size\n  arr[-k..-1] + arr[0...-k]\nend\n\n# Rotates the array `arr` to the right by `n` times.\n# This is a convenience method that simply calls `rotate_right`.\ndef n_rotations(arr, n)\n  rotate_right(arr, n)\nend", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4, 5], Rotate left by 2 positions\nRotated array: [3, 4, 5, 1, 2]\n---\nInput array: [1, 2, 3, 4, 5], Rotate right by 2 positions\nRotated array: [4, 5, 1, 2, 3]\n---\nInput array: [1, 2, 3, 4, 5], Rotate left by 7 positions\nRotated array: [3, 4, 5, 1, 2]\n---\nInput array: [], Rotate right by 3 positions\nRotated array: []\n---\nInput array: [10, 20, 30], Rotate left by 0 positions\nRotated array: [10, 20, 30]\n---\nInput array: [10, 20, 30], Rotate right by 3 positions\nRotated array: [10, 20, 30]\n---\nTesting n_rotations method:\nInput array: [1, 2, 3, 4, 5], Rotate right by 2 times\nRotated array: [4, 5, 1, 2, 3]", "task_id": 2464, "assertions": "def test_rotation_functions\n  # Test rotate_left\n  raise \"rotate_left test 1 failed\" unless rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2]\n  raise \"rotate_left test 2 failed\" unless rotate_left([1, 2, 3, 4, 5], 7) == [3, 4, 5, 1, 2]\n  raise \"rotate_left test 3 failed\" unless rotate_left([10, 20, 30], 0) == [10, 20, 30]\n  \n  # Test rotate_right\n  raise \"rotate_right test 1 failed\" unless rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\n  raise \"rotate_right test 2 failed\" unless rotate_right([], 3) == []\n  raise \"rotate_right test 3 failed\" unless rotate_right([10, 20, 30], 3) == [10, 20, 30]\n  \n  # Test n_rotations\n  raise \"n_rotations test failed\" unless n_rotations([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\n  \n  puts \"All tests passed successfully!\"\nend\n\ntest_rotation_functions", "all_code": "# Rotates the array `arr` to the left by `k` positions.\n# If the array is empty, it returns the array as-is.\n# The rotation count `k` is adjusted using modulo operation to handle cases where `k` is larger than the array size.\ndef rotate_left(arr, k)\n  return arr if arr.empty?\n  k = k % arr.size\n  arr[k..-1] + arr[0...k]\nend\n\n# Rotates the array `arr` to the right by `k` positions.\n# If the array is empty, it returns the array as-is.\n# The rotation count `k` is adjusted using modulo operation to handle cases where `k` is larger than the array size.\ndef rotate_right(arr, k)\n  return arr if arr.empty?\n  k = k % arr.size\n  arr[-k..-1] + arr[0...-k]\nend\n\n# Rotates the array `arr` to the right by `n` times.\n# This is a convenience method that simply calls `rotate_right`.\ndef n_rotations(arr, n)\n  rotate_right(arr, n)\nend\ndef test_rotation_functions\n  # Test rotate_left\n  raise \"rotate_left test 1 failed\" unless rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2]\n  raise \"rotate_left test 2 failed\" unless rotate_left([1, 2, 3, 4, 5], 7) == [3, 4, 5, 1, 2]\n  raise \"rotate_left test 3 failed\" unless rotate_left([10, 20, 30], 0) == [10, 20, 30]\n  \n  # Test rotate_right\n  raise \"rotate_right test 1 failed\" unless rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\n  raise \"rotate_right test 2 failed\" unless rotate_right([], 3) == []\n  raise \"rotate_right test 3 failed\" unless rotate_right([10, 20, 30], 3) == [10, 20, 30]\n  \n  # Test n_rotations\n  raise \"n_rotations test failed\" unless n_rotations([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\n  \n  puts \"All tests passed successfully!\"\nend\n\ntest_rotation_functions", "exec_outcome": "PASSED"}
{"code": "# This method calculates the number of distinct subsequences of a given string.\n# It uses dynamic programming to efficiently compute the result by tracking the last occurrence of each character.\n# The algorithm avoids counting duplicate subsequences by adjusting the count based on previous occurrences.\ndef num_distinct_subsequences(s)\n  n = s.length\n  dp = Array.new(n + 1, 1)  # Initialize dp array with 1's, dp[0] represents empty subsequence\n  last_occurrence = {}       # Hash to store the last index where each character appeared\n\n  (1..n).each do |i|\n    dp[i] = 2 * dp[i - 1]    # Each new character doubles the number of subsequences\n    if last_occurrence.key?(s[i - 1])\n      # Subtract the count of subsequences that would lead to duplicates\n      dp[i] -= dp[last_occurrence[s[i - 1]] - 1]\n    end\n    last_occurrence[s[i - 1]] = i  # Update the last occurrence of the current character\n  end\n\n  dp[n]  # The last element of dp contains the total number of distinct subsequences\nend", "test_cases": "", "test_case_results": "Input: 'abc'\nNumber of distinct subsequences: 8\nInput: 'aaa'\nNumber of distinct subsequences: 4\nInput: 'abab'\nNumber of distinct subsequences: 12\nInput: ''\nNumber of distinct subsequences: 1\nInput: 'a'\nNumber of distinct subsequences: 2", "task_id": 10176, "assertions": "def test_num_distinct_subsequences()\n  raise \"Test case 1 failed\" unless num_distinct_subsequences(\"abc\") == 8\n  raise \"Test case 2 failed\" unless num_distinct_subsequences(\"aaa\") == 4\n  raise \"Test case 3 failed\" unless num_distinct_subsequences(\"abab\") == 12\n  raise \"Test case 4 failed\" unless num_distinct_subsequences(\"\") == 1\n  raise \"Test case 5 failed\" unless num_distinct_subsequences(\"a\") == 2\n  puts \"All test cases passed!\"\nend\n\ntest_num_distinct_subsequences()", "all_code": "# This method calculates the number of distinct subsequences of a given string.\n# It uses dynamic programming to efficiently compute the result by tracking the last occurrence of each character.\n# The algorithm avoids counting duplicate subsequences by adjusting the count based on previous occurrences.\ndef num_distinct_subsequences(s)\n  n = s.length\n  dp = Array.new(n + 1, 1)  # Initialize dp array with 1's, dp[0] represents empty subsequence\n  last_occurrence = {}       # Hash to store the last index where each character appeared\n\n  (1..n).each do |i|\n    dp[i] = 2 * dp[i - 1]    # Each new character doubles the number of subsequences\n    if last_occurrence.key?(s[i - 1])\n      # Subtract the count of subsequences that would lead to duplicates\n      dp[i] -= dp[last_occurrence[s[i - 1]] - 1]\n    end\n    last_occurrence[s[i - 1]] = i  # Update the last occurrence of the current character\n  end\n\n  dp[n]  # The last element of dp contains the total number of distinct subsequences\nend\ndef test_num_distinct_subsequences()\n  raise \"Test case 1 failed\" unless num_distinct_subsequences(\"abc\") == 8\n  raise \"Test case 2 failed\" unless num_distinct_subsequences(\"aaa\") == 4\n  raise \"Test case 3 failed\" unless num_distinct_subsequences(\"abab\") == 12\n  raise \"Test case 4 failed\" unless num_distinct_subsequences(\"\") == 1\n  raise \"Test case 5 failed\" unless num_distinct_subsequences(\"a\") == 2\n  puts \"All test cases passed!\"\nend\n\ntest_num_distinct_subsequences()", "exec_outcome": "PASSED"}
{"code": "# Require necessary standard libraries\nrequire 'date'\n\n# Global counters\n$author_counter = 1\n$post_counter = 1\n\n# Global storage\n$authors = {}\n$posts = {}\n\n# Custom exception classes\nclass AuthorExistsError < StandardError; end\nclass AuthorNotFoundError < StandardError; end\nclass InvalidInputError < StandardError; end\n\n# Adds a new author to the global authors hash.\n# Validates the presence of name and email, and checks for duplicate emails.\n# Returns the newly created author hash.\ndef add_author(name, email)\n  if name.nil? || name.empty? || email.nil? || email.empty?\n    raise InvalidInputError, \"Name and email are required fields.\"\n  end\n\n  # Check if the email is already present\n  $authors.each_value do |author|\n    if author[:email] == email\n      raise AuthorExistsError, \"Author with email #{email} already exists.\"\n    end\n  end\n\n  author_id = $author_counter\n  $authors[author_id] = {\n    id: author_id,\n    name: name,\n    email: email\n  }\n\n  $author_counter += 1\n  $authors[author_id]\nend\n\n# Creates a new post and adds it to the global posts hash.\n# Validates all required fields and checks if the author exists.\n# Returns the newly created post hash with a UTC timestamp.\ndef create_post(author_id, title, content, tags)\n  if author_id.nil? || title.nil? || title.empty? || content.nil? || content.empty? || tags.nil?\n    raise InvalidInputError, \"Author ID, title, content, and tags are required fields.\"\n  end\n\n  # Check if the author exists\n  unless $authors.key?(author_id)\n    raise AuthorNotFoundError, \"Author with ID #{author_id} does not exist.\"\n  end\n\n  post_id = $post_counter\n  timestamp = DateTime.now.to_s\n\n  $posts[post_id] = {\n    id: post_id,\n    author_id: author_id,\n    title: title,\n    content: content,\n    tags: tags,\n    timestamp: timestamp\n  }\n\n  $post_counter += 1\n  $posts[post_id]\nend", "test_cases": "", "test_case_results": "Test case 1: Add a new author\nInput: name='John Doe', email='john@example.com'\nResult: {:id=>1, :name=>\"John Doe\", :email=>\"john@example.com\"}\n\nTest case 2: Add another author\nInput: name='Jane Smith', email='jane@example.com'\nResult: {:id=>2, :name=>\"Jane Smith\", :email=>\"jane@example.com\"}\n\nTest case 3: Create a post\nInput: author_id=1, title='First Post', content='Hello World!', tags=['ruby', 'programming']\nResult: {:id=>1, :author_id=>1, :title=>\"First Post\", :content=>\"Hello World!\", :tags=>[\"ruby\", \"programming\"], :timestamp=>\"2025-06-04T11:52:29+08:00\"}\n\nTest case 4: Create another post\nInput: author_id=2, title='Second Post', content='Ruby is great!', tags=['ruby', 'testing']\nResult: {:id=>2, :author_id=>2, :title=>\"Second Post\", :content=>\"Ruby is great!\", :tags=>[\"ruby\", \"testing\"], :timestamp=>\"2025-06-04T11:52:29+08:00\"}\n\nTest case 5: Try to add duplicate email\nInput: name='John Doe Jr.', email='john@example.com'\nError: AuthorExistsError: Author with email john@example.com already exists.\n\nTest ca", "task_id": 2938, "assertions": "require 'date'\n\ndef test_author_and_post_operations\n  # Reset globals for testing\n  $author_counter = 1\n  $post_counter = 1\n  $authors = {}\n  $posts = {}\n\n  # Test adding authors\n  author1 = add_author(\"John Doe\", \"john@example.com\")\n  raise \"Test failed: Author1 not created correctly\" unless author1 == {\n    id: 1,\n    name: \"John Doe\",\n    email: \"john@example.com\"\n  }\n\n  author2 = add_author(\"Jane Smith\", \"jane@example.com\")\n  raise \"Test failed: Author2 not created correctly\" unless author2 == {\n    id: 2,\n    name: \"Jane Smith\",\n    email: \"jane@example.com\"\n  }\n\n  # Test creating posts (timestamp will be checked separately)\n  post1 = create_post(1, \"First Post\", \"Hello World!\", [\"ruby\", \"programming\"])\n  raise \"Test failed: Post1 ID incorrect\" unless post1[:id] == 1\n  raise \"Test failed: Post1 author_id incorrect\" unless post1[:author_id] == 1\n  raise \"Test failed: Post1 title incorrect\" unless post1[:title] == \"First Post\"\n  raise \"Test failed: Post1 content incorrect\" unless post1[:content] == \"Hello World!\"\n  raise \"Test failed: Post1 tags incorrect\" unless post1[:tags] == [\"ruby\", \"programming\"]\n  raise \"Test failed: Post1 timestamp missing\" unless post1[:timestamp].is_a?(String)\n\n  post2 = create_post(2, \"Second Post\", \"Ruby is great!\", [\"ruby\", \"testing\"])\n  raise \"Test failed: Post2 ID incorrect\" unless post2[:id] == 2\n  raise \"Test failed: Post2 author_id incorrect\" unless post2[:author_id] == 2\n  raise \"Test failed: Post2 title incorrect\" unless post2[:title] == \"Second Post\"\n  raise \"Test failed: Post2 content incorrect\" unless post2[:content] == \"Ruby is great!\"\n  raise \"Test failed: Post2 tags incorrect\" unless post2[:tags] == [\"ruby\", \"testing\"]\n  raise \"Test failed: Post2 timestamp missing\" unless post2[:timestamp].is_a?(String)\n\n  # Test error cases\n  begin\n    add_author(\"John Doe Jr.\", \"john@example.com\")\n    raise \"Test failed: Duplicate email not detected\"\n  rescue AuthorExistsError => e\n    # Expected\n  end\n\n  begin\n    create_post(99, \"Invalid Post\", \"This should fail\", [\"error\"])\n    raise \"Test failed: Invalid author not detected\"\n  rescue AuthorNotFoundError => e\n    # Expected\n  end\n\n  begin\n    create_post(1, \"\", \"Missing title\", [\"error\"])\n    raise \"Test failed: Missing title not detected\"\n  rescue InvalidInputError => e\n    # Expected\n  end\n\n  puts \"All tests passed successfully!\"\nend\n\ntest_author_and_post_operations", "all_code": "# Require necessary standard libraries\nrequire 'date'\n\n# Global counters\n$author_counter = 1\n$post_counter = 1\n\n# Global storage\n$authors = {}\n$posts = {}\n\n# Custom exception classes\nclass AuthorExistsError < StandardError; end\nclass AuthorNotFoundError < StandardError; end\nclass InvalidInputError < StandardError; end\n\n# Adds a new author to the global authors hash.\n# Validates the presence of name and email, and checks for duplicate emails.\n# Returns the newly created author hash.\ndef add_author(name, email)\n  if name.nil? || name.empty? || email.nil? || email.empty?\n    raise InvalidInputError, \"Name and email are required fields.\"\n  end\n\n  # Check if the email is already present\n  $authors.each_value do |author|\n    if author[:email] == email\n      raise AuthorExistsError, \"Author with email #{email} already exists.\"\n    end\n  end\n\n  author_id = $author_counter\n  $authors[author_id] = {\n    id: author_id,\n    name: name,\n    email: email\n  }\n\n  $author_counter += 1\n  $authors[author_id]\nend\n\n# Creates a new post and adds it to the global posts hash.\n# Validates all required fields and checks if the author exists.\n# Returns the newly created post hash with a UTC timestamp.\ndef create_post(author_id, title, content, tags)\n  if author_id.nil? || title.nil? || title.empty? || content.nil? || content.empty? || tags.nil?\n    raise InvalidInputError, \"Author ID, title, content, and tags are required fields.\"\n  end\n\n  # Check if the author exists\n  unless $authors.key?(author_id)\n    raise AuthorNotFoundError, \"Author with ID #{author_id} does not exist.\"\n  end\n\n  post_id = $post_counter\n  timestamp = DateTime.now.to_s\n\n  $posts[post_id] = {\n    id: post_id,\n    author_id: author_id,\n    title: title,\n    content: content,\n    tags: tags,\n    timestamp: timestamp\n  }\n\n  $post_counter += 1\n  $posts[post_id]\nend\nrequire 'date'\n\ndef test_author_and_post_operations\n  # Reset globals for testing\n  $author_counter = 1\n  $post_counter = 1\n  $authors = {}\n  $posts = {}\n\n  # Test adding authors\n  author1 = add_author(\"John Doe\", \"john@example.com\")\n  raise \"Test failed: Author1 not created correctly\" unless author1 == {\n    id: 1,\n    name: \"John Doe\",\n    email: \"john@example.com\"\n  }\n\n  author2 = add_author(\"Jane Smith\", \"jane@example.com\")\n  raise \"Test failed: Author2 not created correctly\" unless author2 == {\n    id: 2,\n    name: \"Jane Smith\",\n    email: \"jane@example.com\"\n  }\n\n  # Test creating posts (timestamp will be checked separately)\n  post1 = create_post(1, \"First Post\", \"Hello World!\", [\"ruby\", \"programming\"])\n  raise \"Test failed: Post1 ID incorrect\" unless post1[:id] == 1\n  raise \"Test failed: Post1 author_id incorrect\" unless post1[:author_id] == 1\n  raise \"Test failed: Post1 title incorrect\" unless post1[:title] == \"First Post\"\n  raise \"Test failed: Post1 content incorrect\" unless post1[:content] == \"Hello World!\"\n  raise \"Test failed: Post1 tags incorrect\" unless post1[:tags] == [\"ruby\", \"programming\"]\n  raise \"Test failed: Post1 timestamp missing\" unless post1[:timestamp].is_a?(String)\n\n  post2 = create_post(2, \"Second Post\", \"Ruby is great!\", [\"ruby\", \"testing\"])\n  raise \"Test failed: Post2 ID incorrect\" unless post2[:id] == 2\n  raise \"Test failed: Post2 author_id incorrect\" unless post2[:author_id] == 2\n  raise \"Test failed: Post2 title incorrect\" unless post2[:title] == \"Second Post\"\n  raise \"Test failed: Post2 content incorrect\" unless post2[:content] == \"Ruby is great!\"\n  raise \"Test failed: Post2 tags incorrect\" unless post2[:tags] == [\"ruby\", \"testing\"]\n  raise \"Test failed: Post2 timestamp missing\" unless post2[:timestamp].is_a?(String)\n\n  # Test error cases\n  begin\n    add_author(\"John Doe Jr.\", \"john@example.com\")\n    raise \"Test failed: Duplicate email not detected\"\n  rescue AuthorExistsError => e\n    # Expected\n  end\n\n  begin\n    create_post(99, \"Invalid Post\", \"This should fail\", [\"error\"])\n    raise \"Test failed: Invalid author not detected\"\n  rescue AuthorNotFoundError => e\n    # Expected\n  end\n\n  begin\n    create_post(1, \"\", \"Missing title\", [\"error\"])\n    raise \"Test failed: Missing title not detected\"\n  rescue InvalidInputError => e\n    # Expected\n  end\n\n  puts \"All tests passed successfully!\"\nend\n\ntest_author_and_post_operations", "exec_outcome": "PASSED"}
{"code": "# This method checks if a given word is a \"magic word\" based on specific criteria.\n# A word is considered magic if at least half of the characters in the first half\n# of the word have matching counts in the second half.\n#\n# The method splits the word into two halves (first half and second half).\n# For even-length words, the split is exactly in the middle.\n# For odd-length words, the first half includes the middle character.\n#\n# It then counts the occurrences of each character in both halves and checks\n# if at least half of the characters in the first half have matching counts\n# in the second half.\n#\n# @param word [String] the word to check\n# @return [String] \"YES\" if the word is magic, \"NO\" otherwise\ndef is_magic_word(word)\n  length = word.length\n\n  if length.even?\n    first_half = word[0, length / 2]\n    second_half = word[length / 2, length / 2]\n  else\n    first_half = word[0, length / 2 + 1]\n    second_half = word[length / 2, length / 2 + 1]\n  end\n\n  char_count = {}\n  first_half.each_char do |char|\n    if char_count.key?(char)\n      char_count[char][0] += 1\n    else\n      char_count[char] = [1, 0]\n    end\n  end\n\n  second_half.each_char do |char|\n    if char_count.key?(char)\n      char_count[char][1] += 1\n    else\n      char_count[char] = [0, 1]\n    end\n  end\n\n  matching_chars = 0\n  total_chars = first_half.length\n\n  char_count.each_value do |counts|\n    matching_chars += 1 if counts[0] == counts[1]\n  end\n\n  matching_chars >= total_chars / 2.0 ? \"YES\" : \"NO\"\nend\n\n# This method checks multiple words to see if they are magic words.\n# It takes an array of words and returns an array of results (\"YES\" or \"NO\")\n# indicating whether each word is magic.\n#\n# @param test_cases [Array<String>] an array of words to check\n# @return [Array<String>] an array of results (\"YES\" or \"NO\") for each word\ndef check_magic_words(test_cases)\n  test_cases.map { |word| is_magic_word(word) }\nend", "test_cases": "", "test_case_results": "Input: abba\nResult: YES\n---\nInput: abcba\nResult: YES\n---\nInput: aabb\nResult: NO\n---\nInput: abcd\nResult: NO\n---\nInput: aaaa\nResult: YES\n---", "task_id": 21522, "assertions": "def test_magic_words()\n  test_cases = [\n    [\"abba\", \"YES\"],\n    [\"abcba\", \"YES\"],\n    [\"aabb\", \"NO\"],\n    [\"abcd\", \"NO\"],\n    [\"aaaa\", \"YES\"]\n  ]\n\n  test_cases.each do |word, expected|\n    result = is_magic_word(word)\n    raise \"Test failed for #{word}. Expected #{expected}, got #{result}\" unless result == expected\n  end\nend\n\ntest_magic_words()", "all_code": "# This method checks if a given word is a \"magic word\" based on specific criteria.\n# A word is considered magic if at least half of the characters in the first half\n# of the word have matching counts in the second half.\n#\n# The method splits the word into two halves (first half and second half).\n# For even-length words, the split is exactly in the middle.\n# For odd-length words, the first half includes the middle character.\n#\n# It then counts the occurrences of each character in both halves and checks\n# if at least half of the characters in the first half have matching counts\n# in the second half.\n#\n# @param word [String] the word to check\n# @return [String] \"YES\" if the word is magic, \"NO\" otherwise\ndef is_magic_word(word)\n  length = word.length\n\n  if length.even?\n    first_half = word[0, length / 2]\n    second_half = word[length / 2, length / 2]\n  else\n    first_half = word[0, length / 2 + 1]\n    second_half = word[length / 2, length / 2 + 1]\n  end\n\n  char_count = {}\n  first_half.each_char do |char|\n    if char_count.key?(char)\n      char_count[char][0] += 1\n    else\n      char_count[char] = [1, 0]\n    end\n  end\n\n  second_half.each_char do |char|\n    if char_count.key?(char)\n      char_count[char][1] += 1\n    else\n      char_count[char] = [0, 1]\n    end\n  end\n\n  matching_chars = 0\n  total_chars = first_half.length\n\n  char_count.each_value do |counts|\n    matching_chars += 1 if counts[0] == counts[1]\n  end\n\n  matching_chars >= total_chars / 2.0 ? \"YES\" : \"NO\"\nend\n\n# This method checks multiple words to see if they are magic words.\n# It takes an array of words and returns an array of results (\"YES\" or \"NO\")\n# indicating whether each word is magic.\n#\n# @param test_cases [Array<String>] an array of words to check\n# @return [Array<String>] an array of results (\"YES\" or \"NO\") for each word\ndef check_magic_words(test_cases)\n  test_cases.map { |word| is_magic_word(word) }\nend\ndef test_magic_words()\n  test_cases = [\n    [\"abba\", \"YES\"],\n    [\"abcba\", \"YES\"],\n    [\"aabb\", \"NO\"],\n    [\"abcd\", \"NO\"],\n    [\"aaaa\", \"YES\"]\n  ]\n\n  test_cases.each do |word, expected|\n    result = is_magic_word(word)\n    raise \"Test failed for #{word}. Expected #{expected}, got #{result}\" unless result == expected\n  end\nend\n\ntest_magic_words()", "exec_outcome": "PASSED"}
{"code": "# find_first_peak returns the value of the first peak element in the array.\n# A peak element is defined as an element that is greater than its neighbors.\n# For edge elements (first or last), only one neighbor is considered.\n# If no peak is found, it returns nil.\ndef find_first_peak(arr)\n  n = arr.size\n\n  arr.each_with_index do |val, i|\n    left_ok = (i == 0) || (val > arr[i-1])\n    right_ok = (i == n-1) || (val > arr[i+1])\n    return val if left_ok && right_ok\n  end\n\n  nil\nend", "test_cases": "", "test_case_results": "Input: [1, 3, 2, 4, 5]\nFirst peak: 3\nInput: [5, 10, 20, 15]\nFirst peak: 20\nInput: [10, 20, 15, 2]\nFirst peak: 20\nInput: [1, 2, 3, 4]\nFirst peak: 4\nInput: [4, 3, 2, 1]\nFirst peak: 4\nInput: [1]\nFirst peak: 1\nInput: []\nFirst peak: nil", "task_id": 6200, "assertions": "def test_find_first_peak()\n  raise \"Test case 1 failed\" unless find_first_peak([1, 3, 2, 4, 5]) == 3\n  raise \"Test case 2 failed\" unless find_first_peak([5, 10, 20, 15]) == 20\n  raise \"Test case 3 failed\" unless find_first_peak([10, 20, 15, 2]) == 20\n  raise \"Test case 4 failed\" unless find_first_peak([1, 2, 3, 4]) == 4\n  raise \"Test case 5 failed\" unless find_first_peak([4, 3, 2, 1]) == 4\n  raise \"Test case 6 failed\" unless find_first_peak([1]) == 1\n  raise \"Test case 7 failed\" unless find_first_peak([]) == nil\n  puts \"All tests passed!\"\nend\n\ntest_find_first_peak()", "all_code": "# find_first_peak returns the value of the first peak element in the array.\n# A peak element is defined as an element that is greater than its neighbors.\n# For edge elements (first or last), only one neighbor is considered.\n# If no peak is found, it returns nil.\ndef find_first_peak(arr)\n  n = arr.size\n\n  arr.each_with_index do |val, i|\n    left_ok = (i == 0) || (val > arr[i-1])\n    right_ok = (i == n-1) || (val > arr[i+1])\n    return val if left_ok && right_ok\n  end\n\n  nil\nend\ndef test_find_first_peak()\n  raise \"Test case 1 failed\" unless find_first_peak([1, 3, 2, 4, 5]) == 3\n  raise \"Test case 2 failed\" unless find_first_peak([5, 10, 20, 15]) == 20\n  raise \"Test case 3 failed\" unless find_first_peak([10, 20, 15, 2]) == 20\n  raise \"Test case 4 failed\" unless find_first_peak([1, 2, 3, 4]) == 4\n  raise \"Test case 5 failed\" unless find_first_peak([4, 3, 2, 1]) == 4\n  raise \"Test case 6 failed\" unless find_first_peak([1]) == 1\n  raise \"Test case 7 failed\" unless find_first_peak([]) == nil\n  puts \"All tests passed!\"\nend\n\ntest_find_first_peak()", "exec_outcome": "PASSED"}
{"code": "# This method generates all palindromic numbers between a given range [a, b] (inclusive).\n# A palindromic number reads the same forwards and backwards.\n# The method checks each number in the range by converting it to a string and comparing it with its reverse.\n# If no palindromic numbers are found, it returns a message indicating so.\ndef generate_palindromic_numbers(a, b)\n  palindromic_numbers = []\n\n  (a..b).each do |num|\n    if num.to_s == num.to_s.reverse\n      palindromic_numbers << num\n    end\n  end\n\n  palindromic_numbers.empty? ? \"No palindromic numbers\" : palindromic_numbers\nend", "test_cases": "", "test_case_results": "Input range: 10 to 20\nResult: [11]\nInput range: 100 to 150\nResult: [101, 111, 121, 131, 141]\nInput range: 1000 to 1010\nResult: [1001]\nInput range: 200 to 210\nResult: [202]\nInput range: 5 to 10\nResult: [5, 6, 7, 8, 9]", "task_id": 19319, "assertions": "def test_generate_palindromic_numbers()\n  raise unless generate_palindromic_numbers(10, 20) == [11]\n  raise unless generate_palindromic_numbers(100, 150) == [101, 111, 121, 131, 141]\n  raise unless generate_palindromic_numbers(1000, 1010) == [1001]\n  raise unless generate_palindromic_numbers(200, 210) == [202]\n  raise unless generate_palindromic_numbers(5, 10) == [5, 6, 7, 8, 9]\nend\n\ntest_generate_palindromic_numbers()", "all_code": "# This method generates all palindromic numbers between a given range [a, b] (inclusive).\n# A palindromic number reads the same forwards and backwards.\n# The method checks each number in the range by converting it to a string and comparing it with its reverse.\n# If no palindromic numbers are found, it returns a message indicating so.\ndef generate_palindromic_numbers(a, b)\n  palindromic_numbers = []\n\n  (a..b).each do |num|\n    if num.to_s == num.to_s.reverse\n      palindromic_numbers << num\n    end\n  end\n\n  palindromic_numbers.empty? ? \"No palindromic numbers\" : palindromic_numbers\nend\ndef test_generate_palindromic_numbers()\n  raise unless generate_palindromic_numbers(10, 20) == [11]\n  raise unless generate_palindromic_numbers(100, 150) == [101, 111, 121, 131, 141]\n  raise unless generate_palindromic_numbers(1000, 1010) == [1001]\n  raise unless generate_palindromic_numbers(200, 210) == [202]\n  raise unless generate_palindromic_numbers(5, 10) == [5, 6, 7, 8, 9]\nend\n\ntest_generate_palindromic_numbers()", "exec_outcome": "PASSED"}
{"code": "def analyze_hex(hex_string)\n  return [0, 0] if hex_string.empty?\n  num_digits = hex_string.length\n  sum_values = hex_string.chars.sum { |digit| digit.to_i(16) }\n  [num_digits, sum_values]\nend", "test_cases": "", "test_case_results": "Input: \"1A3\"\nNumber of digits: 3, Sum of values: 14\nInput: \"FF\"\nNumber of digits: 2, Sum of values: 30\nInput: \"0\"\nNumber of digits: 1, Sum of values: 0\nInput: \"\"\nNumber of digits: 0, Sum of values: 0\nInput: \"1X2\"\nNumber of digits: 3, Sum of values: 3", "task_id": 5397, "assertions": "def test_analyze_hex()\n  raise unless analyze_hex(\"1A3\") == [3, 14]\n  raise unless analyze_hex(\"FF\") == [2, 30]\n  raise unless analyze_hex(\"0\") == [1, 0]\n  raise unless analyze_hex(\"\") == [0, 0]\n  raise unless analyze_hex(\"1X2\") == [3, 3]\nend\n\ntest_analyze_hex()", "all_code": "def analyze_hex(hex_string)\n  return [0, 0] if hex_string.empty?\n  num_digits = hex_string.length\n  sum_values = hex_string.chars.sum { |digit| digit.to_i(16) }\n  [num_digits, sum_values]\nend\ndef test_analyze_hex()\n  raise unless analyze_hex(\"1A3\") == [3, 14]\n  raise unless analyze_hex(\"FF\") == [2, 30]\n  raise unless analyze_hex(\"0\") == [1, 0]\n  raise unless analyze_hex(\"\") == [0, 0]\n  raise unless analyze_hex(\"1X2\") == [3, 3]\nend\n\ntest_analyze_hex()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef contains_permutation(s, t)\n  len_s = s.length\n  len_t = t.length\n\n  return false if len_t > len_s\n\n  t_counter = Hash.new(0)\n  t.each_char { |c| t_counter[c] += 1 }\n\n  window_counter = Hash.new(0)\n  s[0...len_t].each_char { |c| window_counter[c] += 1 }\n\n  (0..len_s - len_t).each do |i|\n    return true if window_counter == t_counter\n\n    if i + len_t < len_s\n      left_char = s[i]\n      window_counter[left_char] -= 1\n      window_counter.delete(left_char) if window_counter[left_char] == 0\n\n      right_char = s[i + len_t]\n      window_counter[right_char] += 1\n    end\n  end\n\n  false\nend", "test_cases": "", "test_case_results": "Input: s = eidbaooo, t = ab\nContains permutation: true\nInput: s = eidbaooo, t = abc\nContains permutation: false\nInput: s = dcda, t = adc\nContains permutation: true\nInput: s = ooolleoooleh, t = hello\nContains permutation: false\nInput: s = properties, t = prosperity\nContains permutation: false", "task_id": 29836, "assertions": "def test_contains_permutation()\n  raise \"Test case 1 failed\" unless contains_permutation(\"eidbaooo\", \"ab\") == true\n  raise \"Test case 2 failed\" unless contains_permutation(\"eidbaooo\", \"abc\") == false\n  raise \"Test case 3 failed\" unless contains_permutation(\"dcda\", \"adc\") == true\n  raise \"Test case 4 failed\" unless contains_permutation(\"ooolleoooleh\", \"hello\") == false\n  raise \"Test case 5 failed\" unless contains_permutation(\"properties\", \"prosperity\") == false\n  puts \"All test cases passed\"\nend\n\ntest_contains_permutation()", "all_code": "require 'set'\n\ndef contains_permutation(s, t)\n  len_s = s.length\n  len_t = t.length\n\n  return false if len_t > len_s\n\n  t_counter = Hash.new(0)\n  t.each_char { |c| t_counter[c] += 1 }\n\n  window_counter = Hash.new(0)\n  s[0...len_t].each_char { |c| window_counter[c] += 1 }\n\n  (0..len_s - len_t).each do |i|\n    return true if window_counter == t_counter\n\n    if i + len_t < len_s\n      left_char = s[i]\n      window_counter[left_char] -= 1\n      window_counter.delete(left_char) if window_counter[left_char] == 0\n\n      right_char = s[i + len_t]\n      window_counter[right_char] += 1\n    end\n  end\n\n  false\nend\ndef test_contains_permutation()\n  raise \"Test case 1 failed\" unless contains_permutation(\"eidbaooo\", \"ab\") == true\n  raise \"Test case 2 failed\" unless contains_permutation(\"eidbaooo\", \"abc\") == false\n  raise \"Test case 3 failed\" unless contains_permutation(\"dcda\", \"adc\") == true\n  raise \"Test case 4 failed\" unless contains_permutation(\"ooolleoooleh\", \"hello\") == false\n  raise \"Test case 5 failed\" unless contains_permutation(\"properties\", \"prosperity\") == false\n  puts \"All test cases passed\"\nend\n\ntest_contains_permutation()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef find_critical_nodes(n, edges)\n  dfs = lambda do |node, parent, discovery_time, low_time, visited, time, graph, articulation_points|\n    visited[node] = true\n    discovery_time[node] = low_time[node] = time[0]\n    time[0] += 1\n    child_count = 0\n    is_articulation = false\n\n    graph[node].each do |neighbor|\n      next if neighbor == parent\n\n      unless visited[neighbor]\n        dfs.call(neighbor, node, discovery_time, low_time, visited, time, graph, articulation_points)\n        child_count += 1\n\n        if low_time[neighbor] >= discovery_time[node]\n          is_articulation = true\n        end\n        low_time[node] = [low_time[node], low_time[neighbor]].min\n      else\n        low_time[node] = [low_time[node], discovery_time[neighbor]].min\n      end\n    end\n\n    if (parent == -1 && child_count > 1) || (parent != -1 && is_articulation)\n      articulation_points.add(node)\n    end\n  end\n\n  graph = Array.new(n) { [] }\n  edges.each do |u, v|\n    graph[u] << v\n    graph[v] << u\n  end\n\n  discovery_time = Array.new(n, -1)\n  low_time = Array.new(n, -1)\n  visited = Array.new(n, false)\n  articulation_points = Set.new\n  time = [0]\n\n  (0...n).each do |i|\n    unless visited[i]\n      dfs.call(i, -1, discovery_time, low_time, visited, time, graph, articulation_points)\n    end\n  end\n\n  articulation_points.to_a.sort\nend", "test_cases": "", "test_case_results": "Input: n = 7, edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]\nCritical Nodes: [2, 3, 5]\nInput: n = 4, edges = [[0, 1], [1, 2], [2, 3]]\nCritical Nodes: [1, 2]\nInput: n = 5, edges = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1]]\nCritical Nodes: [1]", "task_id": 16485, "assertions": "require 'set'\n\ndef test_find_critical_nodes()\n  raise unless find_critical_nodes(7, [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]) == [2, 3, 5]\n  raise unless find_critical_nodes(4, [[0, 1], [1, 2], [2, 3]]) == [1, 2]\n  raise unless find_critical_nodes(5, [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1]]) == [1]\nend\n\ntest_find_critical_nodes()", "all_code": "require 'set'\n\ndef find_critical_nodes(n, edges)\n  dfs = lambda do |node, parent, discovery_time, low_time, visited, time, graph, articulation_points|\n    visited[node] = true\n    discovery_time[node] = low_time[node] = time[0]\n    time[0] += 1\n    child_count = 0\n    is_articulation = false\n\n    graph[node].each do |neighbor|\n      next if neighbor == parent\n\n      unless visited[neighbor]\n        dfs.call(neighbor, node, discovery_time, low_time, visited, time, graph, articulation_points)\n        child_count += 1\n\n        if low_time[neighbor] >= discovery_time[node]\n          is_articulation = true\n        end\n        low_time[node] = [low_time[node], low_time[neighbor]].min\n      else\n        low_time[node] = [low_time[node], discovery_time[neighbor]].min\n      end\n    end\n\n    if (parent == -1 && child_count > 1) || (parent != -1 && is_articulation)\n      articulation_points.add(node)\n    end\n  end\n\n  graph = Array.new(n) { [] }\n  edges.each do |u, v|\n    graph[u] << v\n    graph[v] << u\n  end\n\n  discovery_time = Array.new(n, -1)\n  low_time = Array.new(n, -1)\n  visited = Array.new(n, false)\n  articulation_points = Set.new\n  time = [0]\n\n  (0...n).each do |i|\n    unless visited[i]\n      dfs.call(i, -1, discovery_time, low_time, visited, time, graph, articulation_points)\n    end\n  end\n\n  articulation_points.to_a.sort\nend\nrequire 'set'\n\ndef test_find_critical_nodes()\n  raise unless find_critical_nodes(7, [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]) == [2, 3, 5]\n  raise unless find_critical_nodes(4, [[0, 1], [1, 2], [2, 3]]) == [1, 2]\n  raise unless find_critical_nodes(5, [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1]]) == [1]\nend\n\ntest_find_critical_nodes()", "exec_outcome": "PASSED"}
{"code": "require 'json'\nrequire 'thread'\n\n# KeyValueStore is a thread-safe key-value store that persists data to a file.\n# It supports basic operations like put, get, and delete.\nclass KeyValueStore\n  # Initializes the KeyValueStore with a filename to persist data.\n  # Loads the existing state from the file if it exists.\n  def initialize(filename)\n    @filename = filename\n    @lock = Mutex.new\n    @store = load_state\n  end\n\n  # Loads the state from the file if it exists, otherwise returns an empty hash.\n  # Handles file corruption or read errors gracefully.\n  def load_state\n    if File.exist?(@filename)\n      begin\n        File.open(@filename, 'r') do |file|\n          JSON.load(file)\n        end\n      rescue JSON::ParserError, IOError\n        {}\n      end\n    else\n      {}\n    end\n  end\n\n  # Saves the current state to the file.\n  def save_state\n    File.open(@filename, 'w') do |file|\n      JSON.dump(@store, file)\n    end\n  end\n\n  # Puts the key-value pair into the store and saves the state.\n  # Uses a mutex to ensure thread safety.\n  def put(key, value)\n    @lock.synchronize do\n      @store[key] = value\n      save_state\n    end\n  end\n\n  # Gets the value associated with the key. Returns nil if the key does not exist.\n  # Uses a mutex to ensure thread safety.\n  def get(key)\n    @lock.synchronize do\n      @store[key]\n    end\n  end\n\n  # Deletes the key from the store if it exists and saves the state.\n  # Uses a mutex to ensure thread safety.\n  def delete(key)\n    @lock.synchronize do\n      @store.delete(key)\n      save_state\n    end\n  end\nend", "test_cases": "", "test_case_results": "Putting key: 'name', value: 'Alice'\nGetting value for key: 'name'\nValue: Alice\nDeleting key: 'name'\nGetting value for key: 'name' after deletion\nValue:", "task_id": 25477, "assertions": "def test_key_value_store\n  # Create a temporary file for testing\n  filename = 'test_key_value_store.json'\n  \n  # Initialize the KeyValueStore\n  store = KeyValueStore.new(filename)\n\n  # Test put operation\n  store.put('name', 'Alice')\n  raise \"Put operation failed\" unless store.get('name') == 'Alice'\n\n  # Test delete operation\n  store.delete('name')\n  raise \"Delete operation failed\" unless store.get('name').nil?\n\n  # Clean up the temporary file\n  File.delete(filename) if File.exist?(filename)\n  \n  puts \"All tests passed successfully.\"\nend\n\ntest_key_value_store", "all_code": "require 'json'\nrequire 'thread'\n\n# KeyValueStore is a thread-safe key-value store that persists data to a file.\n# It supports basic operations like put, get, and delete.\nclass KeyValueStore\n  # Initializes the KeyValueStore with a filename to persist data.\n  # Loads the existing state from the file if it exists.\n  def initialize(filename)\n    @filename = filename\n    @lock = Mutex.new\n    @store = load_state\n  end\n\n  # Loads the state from the file if it exists, otherwise returns an empty hash.\n  # Handles file corruption or read errors gracefully.\n  def load_state\n    if File.exist?(@filename)\n      begin\n        File.open(@filename, 'r') do |file|\n          JSON.load(file)\n        end\n      rescue JSON::ParserError, IOError\n        {}\n      end\n    else\n      {}\n    end\n  end\n\n  # Saves the current state to the file.\n  def save_state\n    File.open(@filename, 'w') do |file|\n      JSON.dump(@store, file)\n    end\n  end\n\n  # Puts the key-value pair into the store and saves the state.\n  # Uses a mutex to ensure thread safety.\n  def put(key, value)\n    @lock.synchronize do\n      @store[key] = value\n      save_state\n    end\n  end\n\n  # Gets the value associated with the key. Returns nil if the key does not exist.\n  # Uses a mutex to ensure thread safety.\n  def get(key)\n    @lock.synchronize do\n      @store[key]\n    end\n  end\n\n  # Deletes the key from the store if it exists and saves the state.\n  # Uses a mutex to ensure thread safety.\n  def delete(key)\n    @lock.synchronize do\n      @store.delete(key)\n      save_state\n    end\n  end\nend\ndef test_key_value_store\n  # Create a temporary file for testing\n  filename = 'test_key_value_store.json'\n  \n  # Initialize the KeyValueStore\n  store = KeyValueStore.new(filename)\n\n  # Test put operation\n  store.put('name', 'Alice')\n  raise \"Put operation failed\" unless store.get('name') == 'Alice'\n\n  # Test delete operation\n  store.delete('name')\n  raise \"Delete operation failed\" unless store.get('name').nil?\n\n  # Clean up the temporary file\n  File.delete(filename) if File.exist?(filename)\n  \n  puts \"All tests passed successfully.\"\nend\n\ntest_key_value_store", "exec_outcome": "PASSED"}
{"code": "def max_depth(level_order)\n  return 0 if level_order.empty? || level_order[0].nil?\n\n  index = 0\n  level = 0\n  queue = [index]\n\n  until queue.empty?\n    level += 1\n    current_level_size = queue.size\n\n    current_level_size.times do\n      idx = queue.shift\n      left_child_idx = 2 * idx + 1\n      right_child_idx = 2 * idx + 2\n\n      queue << left_child_idx if left_child_idx < level_order.size && !level_order[left_child_idx].nil?\n      queue << right_child_idx if right_child_idx < level_order.size && !level_order[right_child_idx].nil?\n    end\n  end\n\n  level\nend", "test_cases": "", "test_case_results": "Input: [3, 9, 20, nil, nil, 15, 7]\nMax Depth: 3\nInput: [1, nil, 2]\nMax Depth: 2\nInput: []\nMax Depth: 0\nInput: [1]\nMax Depth: 1\nInput: [1, 2, 3, 4, 5, 6, 7]\nMax Depth: 3", "task_id": 26160, "assertions": "def test_max_depth()\n  raise \"Test case 1 failed\" unless max_depth([3, 9, 20, nil, nil, 15, 7]) == 3\n  raise \"Test case 2 failed\" unless max_depth([1, nil, 2]) == 2\n  raise \"Test case 3 failed\" unless max_depth([]) == 0\n  raise \"Test case 4 failed\" unless max_depth([1]) == 1\n  raise \"Test case 5 failed\" unless max_depth([1, 2, 3, 4, 5, 6, 7]) == 3\n  puts \"All tests passed!\"\nend\n\ntest_max_depth()", "all_code": "def max_depth(level_order)\n  return 0 if level_order.empty? || level_order[0].nil?\n\n  index = 0\n  level = 0\n  queue = [index]\n\n  until queue.empty?\n    level += 1\n    current_level_size = queue.size\n\n    current_level_size.times do\n      idx = queue.shift\n      left_child_idx = 2 * idx + 1\n      right_child_idx = 2 * idx + 2\n\n      queue << left_child_idx if left_child_idx < level_order.size && !level_order[left_child_idx].nil?\n      queue << right_child_idx if right_child_idx < level_order.size && !level_order[right_child_idx].nil?\n    end\n  end\n\n  level\nend\ndef test_max_depth()\n  raise \"Test case 1 failed\" unless max_depth([3, 9, 20, nil, nil, 15, 7]) == 3\n  raise \"Test case 2 failed\" unless max_depth([1, nil, 2]) == 2\n  raise \"Test case 3 failed\" unless max_depth([]) == 0\n  raise \"Test case 4 failed\" unless max_depth([1]) == 1\n  raise \"Test case 5 failed\" unless max_depth([1, 2, 3, 4, 5, 6, 7]) == 3\n  puts \"All tests passed!\"\nend\n\ntest_max_depth()", "exec_outcome": "PASSED"}
{"code": "# process_queries processes two types of queries on an array of flowerbeds.\n# The first type of query (1) updates a flowerbed at a given position to a new flower type.\n# The second type of query (2) counts the number of flowerbeds of a specific type within a range.\n# The method returns an array of results for the second type of queries.\n#\n# Parameters:\n# n - The number of flowerbeds (unused in the method but kept for interface consistency).\n# m - The number of queries (unused in the method but kept for interface consistency).\n# flowerbeds - An array representing the type of flowers in each flowerbed.\n# queries - An array of queries, where each query is an array specifying the query type and parameters.\n#\n# Returns:\n# An array of integers representing the results of the second type of queries.\ndef process_queries(n, m, flowerbeds, queries)\n  results = []\n\n  queries.each do |query|\n    if query[0] == 1\n      # Update query: change the flower type at the specified position\n      position = query[1] - 1  # Convert to one-based index to zero-based\n      type_of_flower = query[2]\n      flowerbeds[position] = type_of_flower\n    elsif query[0] == 2\n      # Count query: count the number of flowerbeds of the specified type in the range\n      left = query[1] - 1  # Convert to one-based index to zero-based\n      right = query[2] - 1  # Convert to one-based index to zero-based\n      flower_type = query[3]\n      count = flowerbeds[left..right].count { |type| type == flower_type }\n      results << count\n    end\n  end\n\n  results\nend", "test_cases": "", "test_case_results": "Input:\nn: 5, m: 3\nflowerbeds: [1, 2, 3, 4, 5]\nqueries: [[2, 1, 5, 3], [1, 3, 6], [2, 1, 5, 3]]\nResults: [1, 0]\n\nInput:\nn: 4, m: 2\nflowerbeds: [1, 1, 1, 1]\nqueries: [[2, 1, 4, 1], [1, 2, 2], [2, 1, 4, 1]]\nResults: [4, 3]", "task_id": 16128, "assertions": "def test_process_queries()\n  # Test Case 1\n  flowerbeds = [1, 2, 3, 4, 5]\n  queries = [\n    [2, 1, 5, 3],\n    [1, 3, 6],\n    [2, 1, 5, 3]\n  ]\n  results = process_queries(5, 3, flowerbeds, queries)\n  raise \"Test Case 1 Failed\" unless results == [1, 0]\n\n  # Test Case 2\n  flowerbeds = [1, 1, 1, 1]\n  queries = [\n    [2, 1, 4, 1],\n    [1, 2, 2],\n    [2, 1, 4, 1]\n  ]\n  results = process_queries(4, 2, flowerbeds, queries)\n  raise \"Test Case 2 Failed\" unless results == [4, 3]\n\n  puts \"All test cases passed!\"\nend\n\ntest_process_queries()", "all_code": "# process_queries processes two types of queries on an array of flowerbeds.\n# The first type of query (1) updates a flowerbed at a given position to a new flower type.\n# The second type of query (2) counts the number of flowerbeds of a specific type within a range.\n# The method returns an array of results for the second type of queries.\n#\n# Parameters:\n# n - The number of flowerbeds (unused in the method but kept for interface consistency).\n# m - The number of queries (unused in the method but kept for interface consistency).\n# flowerbeds - An array representing the type of flowers in each flowerbed.\n# queries - An array of queries, where each query is an array specifying the query type and parameters.\n#\n# Returns:\n# An array of integers representing the results of the second type of queries.\ndef process_queries(n, m, flowerbeds, queries)\n  results = []\n\n  queries.each do |query|\n    if query[0] == 1\n      # Update query: change the flower type at the specified position\n      position = query[1] - 1  # Convert to one-based index to zero-based\n      type_of_flower = query[2]\n      flowerbeds[position] = type_of_flower\n    elsif query[0] == 2\n      # Count query: count the number of flowerbeds of the specified type in the range\n      left = query[1] - 1  # Convert to one-based index to zero-based\n      right = query[2] - 1  # Convert to one-based index to zero-based\n      flower_type = query[3]\n      count = flowerbeds[left..right].count { |type| type == flower_type }\n      results << count\n    end\n  end\n\n  results\nend\ndef test_process_queries()\n  # Test Case 1\n  flowerbeds = [1, 2, 3, 4, 5]\n  queries = [\n    [2, 1, 5, 3],\n    [1, 3, 6],\n    [2, 1, 5, 3]\n  ]\n  results = process_queries(5, 3, flowerbeds, queries)\n  raise \"Test Case 1 Failed\" unless results == [1, 0]\n\n  # Test Case 2\n  flowerbeds = [1, 1, 1, 1]\n  queries = [\n    [2, 1, 4, 1],\n    [1, 2, 2],\n    [2, 1, 4, 1]\n  ]\n  results = process_queries(4, 2, flowerbeds, queries)\n  raise \"Test Case 2 Failed\" unless results == [4, 3]\n\n  puts \"All test cases passed!\"\nend\n\ntest_process_queries()", "exec_outcome": "PASSED"}
{"code": "# Determines if a robot returns to its starting position after a sequence of moves.\n# The robot starts at the origin (0, 0) and moves according to the given sequence.\n# The method checks the final position after all moves to determine if it's back at the origin.\n#\n# Parameters:\n# - n : Integer representing the length of the move sequence.\n# - s : String representing the sequence of moves ('U', 'D', 'L', 'R').\n#\n# Returns:\n# - String \"YES\" if the robot returns to the starting position, otherwise \"NO\".\ndef does_robot_return_to_origin(n, s)\n  x, y = 0, 0  # Initialize starting position at origin\n\n  s.each_char do |move|\n    case move\n    when 'U'\n      y += 1\n    when 'D'\n      y -= 1\n    when 'L'\n      x -= 1\n    when 'R'\n      x += 1\n    end\n  end\n\n  x == 0 && y == 0 ? \"YES\" : \"NO\"\nend", "test_cases": "", "test_case_results": "Input: n=4, s='UDLR'\nYES\nInput: n=4, s='UUUU'\nNO\nInput: n=6, s='UDLRUD'\nYES\nInput: n=2, s='UD'\nYES\nInput: n=3, s='UDR'\nNO", "task_id": 22108, "assertions": "def test_does_robot_return_to_origin\n  raise \"Test case 1 failed\" unless does_robot_return_to_origin(4, \"UDLR\") == \"YES\"\n  raise \"Test case 2 failed\" unless does_robot_return_to_origin(4, \"UUUU\") == \"NO\"\n  raise \"Test case 3 failed\" unless does_robot_return_to_origin(6, \"UDLRUD\") == \"YES\"\n  raise \"Test case 4 failed\" unless does_robot_return_to_origin(2, \"UD\") == \"YES\"\n  raise \"Test case 5 failed\" unless does_robot_return_to_origin(3, \"UDR\") == \"NO\"\n  puts \"All test cases passed\"\nend\n\ntest_does_robot_return_to_origin", "all_code": "# Determines if a robot returns to its starting position after a sequence of moves.\n# The robot starts at the origin (0, 0) and moves according to the given sequence.\n# The method checks the final position after all moves to determine if it's back at the origin.\n#\n# Parameters:\n# - n : Integer representing the length of the move sequence.\n# - s : String representing the sequence of moves ('U', 'D', 'L', 'R').\n#\n# Returns:\n# - String \"YES\" if the robot returns to the starting position, otherwise \"NO\".\ndef does_robot_return_to_origin(n, s)\n  x, y = 0, 0  # Initialize starting position at origin\n\n  s.each_char do |move|\n    case move\n    when 'U'\n      y += 1\n    when 'D'\n      y -= 1\n    when 'L'\n      x -= 1\n    when 'R'\n      x += 1\n    end\n  end\n\n  x == 0 && y == 0 ? \"YES\" : \"NO\"\nend\ndef test_does_robot_return_to_origin\n  raise \"Test case 1 failed\" unless does_robot_return_to_origin(4, \"UDLR\") == \"YES\"\n  raise \"Test case 2 failed\" unless does_robot_return_to_origin(4, \"UUUU\") == \"NO\"\n  raise \"Test case 3 failed\" unless does_robot_return_to_origin(6, \"UDLRUD\") == \"YES\"\n  raise \"Test case 4 failed\" unless does_robot_return_to_origin(2, \"UD\") == \"YES\"\n  raise \"Test case 5 failed\" unless does_robot_return_to_origin(3, \"UDR\") == \"NO\"\n  puts \"All test cases passed\"\nend\n\ntest_does_robot_return_to_origin", "exec_outcome": "PASSED"}
{"code": "# Require necessary standard libraries\n# We use 'regexp' from Ruby's standard library for regular expression operations.\n\n# reverse_words reverses the words in a given string while keeping the order of special characters intact.\n# It splits the string into words and special characters, reverses only the alphanumeric words, and joins them back.\n# \n# @param s [String] the input string to process\n# @return [String] the string with words reversed and special characters intact\ndef reverse_words(s)\n  # Split the string to extract words and special characters using a regular expression\n  # The regex /(\\W+)/ matches non-word characters (special characters) and includes them in the result\n  words = s.split(/(\\W+)/)\n  \n  # Reverse the alphanumeric words in the list of words\n  reversed_words = words.map do |word|\n    # Check if the word consists only of alphanumeric characters\n    if word.match?(/^\\w+$/)\n      word.reverse\n    else\n      word\n    end\n  end\n  \n  # Join the list back into a single string\n  reversed_words.join\nend", "test_cases": "", "test_case_results": "Input: 'hello world!'\nResult: 'olleh dlrow!'\n----------------------------------------\nInput: 'This is a test.'\nResult: 'sihT si a tset.'\n----------------------------------------\nInput: '123 abc 456 def'\nResult: '321 cba 654 fed'\n----------------------------------------\nInput: 'special@chars#here'\nResult: 'laiceps@srahc#ereh'\n----------------------------------------\nInput: '  leading and trailing spaces  '\nResult: '  gnidael dna gniliart secaps  '\n----------------------------------------", "task_id": 17398, "assertions": "def test_reverse_words()\n  raise unless reverse_words(\"hello world!\") == \"olleh dlrow!\"\n  raise unless reverse_words(\"This is a test.\") == \"sihT si a tset.\"\n  raise unless reverse_words(\"123 abc 456 def\") == \"321 cba 654 fed\"\n  raise unless reverse_words(\"special@chars#here\") == \"laiceps@srahc#ereh\"\n  raise unless reverse_words(\"  leading and trailing spaces  \") == \"  gnidael dna gniliart secaps  \"\nend\n\ntest_reverse_words()", "all_code": "# Require necessary standard libraries\n# We use 'regexp' from Ruby's standard library for regular expression operations.\n\n# reverse_words reverses the words in a given string while keeping the order of special characters intact.\n# It splits the string into words and special characters, reverses only the alphanumeric words, and joins them back.\n# \n# @param s [String] the input string to process\n# @return [String] the string with words reversed and special characters intact\ndef reverse_words(s)\n  # Split the string to extract words and special characters using a regular expression\n  # The regex /(\\W+)/ matches non-word characters (special characters) and includes them in the result\n  words = s.split(/(\\W+)/)\n  \n  # Reverse the alphanumeric words in the list of words\n  reversed_words = words.map do |word|\n    # Check if the word consists only of alphanumeric characters\n    if word.match?(/^\\w+$/)\n      word.reverse\n    else\n      word\n    end\n  end\n  \n  # Join the list back into a single string\n  reversed_words.join\nend\ndef test_reverse_words()\n  raise unless reverse_words(\"hello world!\") == \"olleh dlrow!\"\n  raise unless reverse_words(\"This is a test.\") == \"sihT si a tset.\"\n  raise unless reverse_words(\"123 abc 456 def\") == \"321 cba 654 fed\"\n  raise unless reverse_words(\"special@chars#here\") == \"laiceps@srahc#ereh\"\n  raise unless reverse_words(\"  leading and trailing spaces  \") == \"  gnidael dna gniliart secaps  \"\nend\n\ntest_reverse_words()", "exec_outcome": "PASSED"}
{"code": "def calculate(s)\n  evaluate = lambda do |tokens|\n    stack = []\n    num = 0\n    sign = 1\n    while tokens.any?\n      token = tokens.shift\n      if token.match?(/\\d/)\n        num = token.to_i\n        while tokens.any? && tokens.first.match?(/\\d/)\n          num = num * 10 + tokens.shift.to_i\n        end\n        stack << sign * num\n        num = 0\n      elsif token == '+'\n        sign = 1\n      elsif token == '-'\n        sign = -1\n      elsif token == '('\n        num = evaluate.call(tokens)\n        stack << sign * num\n        num = 0\n      elsif token == ')'\n        break\n      end\n    end\n    stack.sum\n  end\n\n  tokens = s.gsub(/\\s/, '').chars\n  evaluate.call(tokens)\nend", "test_cases": "", "test_case_results": "Input: 1 + 1\nResult: 2\nInput:  2-1 + 2 \nResult: 3\nInput: (1+(4+5+2)-3)+(6+8)\nResult: 23\nInput: 1 + (2 - (3 + 4))\nResult: -4\nInput: 123\nResult: 123\nInput: - (3 + (4 + 5))\nResult: -12", "task_id": 14218, "assertions": "def test_calculate()\n  raise unless calculate(\"1 + 1\") == 2\n  raise unless calculate(\" 2-1 + 2 \") == 3\n  raise unless calculate(\"(1+(4+5+2)-3)+(6+8)\") == 23\n  raise unless calculate(\"1 + (2 - (3 + 4))\") == -4\n  raise unless calculate(\"123\") == 123\n  raise unless calculate(\"- (3 + (4 + 5))\") == -12\nend\n\ntest_calculate()", "all_code": "def calculate(s)\n  evaluate = lambda do |tokens|\n    stack = []\n    num = 0\n    sign = 1\n    while tokens.any?\n      token = tokens.shift\n      if token.match?(/\\d/)\n        num = token.to_i\n        while tokens.any? && tokens.first.match?(/\\d/)\n          num = num * 10 + tokens.shift.to_i\n        end\n        stack << sign * num\n        num = 0\n      elsif token == '+'\n        sign = 1\n      elsif token == '-'\n        sign = -1\n      elsif token == '('\n        num = evaluate.call(tokens)\n        stack << sign * num\n        num = 0\n      elsif token == ')'\n        break\n      end\n    end\n    stack.sum\n  end\n\n  tokens = s.gsub(/\\s/, '').chars\n  evaluate.call(tokens)\nend\ndef test_calculate()\n  raise unless calculate(\"1 + 1\") == 2\n  raise unless calculate(\" 2-1 + 2 \") == 3\n  raise unless calculate(\"(1+(4+5+2)-3)+(6+8)\") == 23\n  raise unless calculate(\"1 + (2 - (3 + 4))\") == -4\n  raise unless calculate(\"123\") == 123\n  raise unless calculate(\"- (3 + (4 + 5))\") == -12\nend\n\ntest_calculate()", "exec_outcome": "PASSED"}
{"code": "# Rotates a given 2D grid (image) 90 degrees clockwise in-place.\n# The method first transposes the grid and then reverses each row.\n# Transposing swaps elements across the diagonal, and reversing each row completes the rotation.\n#\n# @param grid [Array<Array<Integer>>] The 2D grid to be rotated\n# @return [nil] The grid is modified in-place, so no return value is needed\ndef rotate_image(grid)\n  n = grid.size\n  # Transpose the grid\n  (0...n).each do |i|\n    (i...n).each do |j|\n      grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    end\n  end\n\n  # Reverse each row\n  grid.each(&:reverse!)\nend", "test_cases": "", "test_case_results": "Original grid:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\nRotated grid:\n[7, 4, 1]\n[8, 5, 2]\n[9, 6, 3]\n------------------\nOriginal grid:\n[5, 1, 9, 11]\n[2, 4, 8, 10]\n[13, 3, 6, 7]\n[15, 14, 12, 16]\nRotated grid:\n[15, 13, 2, 5]\n[14, 3, 4, 1]\n[12, 6, 8, 9]\n[16, 7, 10, 11]\n------------------\nOriginal grid:\n[1, 2]\n[3, 4]\nRotated grid:\n[3, 1]\n[4, 2]\n------------------", "task_id": 24851, "assertions": "def test_rotate_image()\n  # Test case 1\n  grid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  rotate_image(grid1)\n  raise unless grid1 == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n  ]\n\n  # Test case 2\n  grid2 = [\n    [5, 1, 9, 11],\n    [2, 4, 8, 10],\n    [13, 3, 6, 7],\n    [15, 14, 12, 16]\n  ]\n  rotate_image(grid2)\n  raise unless grid2 == [\n    [15, 13, 2, 5],\n    [14, 3, 4, 1],\n    [12, 6, 8, 9],\n    [16, 7, 10, 11]\n  ]\n\n  # Test case 3\n  grid3 = [\n    [1, 2],\n    [3, 4]\n  ]\n  rotate_image(grid3)\n  raise unless grid3 == [\n    [3, 1],\n    [4, 2]\n  ]\nend\n\ntest_rotate_image()", "all_code": "# Rotates a given 2D grid (image) 90 degrees clockwise in-place.\n# The method first transposes the grid and then reverses each row.\n# Transposing swaps elements across the diagonal, and reversing each row completes the rotation.\n#\n# @param grid [Array<Array<Integer>>] The 2D grid to be rotated\n# @return [nil] The grid is modified in-place, so no return value is needed\ndef rotate_image(grid)\n  n = grid.size\n  # Transpose the grid\n  (0...n).each do |i|\n    (i...n).each do |j|\n      grid[i][j], grid[j][i] = grid[j][i], grid[i][j]\n    end\n  end\n\n  # Reverse each row\n  grid.each(&:reverse!)\nend\ndef test_rotate_image()\n  # Test case 1\n  grid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  rotate_image(grid1)\n  raise unless grid1 == [\n    [7, 4, 1],\n    [8, 5, 2],\n    [9, 6, 3]\n  ]\n\n  # Test case 2\n  grid2 = [\n    [5, 1, 9, 11],\n    [2, 4, 8, 10],\n    [13, 3, 6, 7],\n    [15, 14, 12, 16]\n  ]\n  rotate_image(grid2)\n  raise unless grid2 == [\n    [15, 13, 2, 5],\n    [14, 3, 4, 1],\n    [12, 6, 8, 9],\n    [16, 7, 10, 11]\n  ]\n\n  # Test case 3\n  grid3 = [\n    [1, 2],\n    [3, 4]\n  ]\n  rotate_image(grid3)\n  raise unless grid3 == [\n    [3, 1],\n    [4, 2]\n  ]\nend\n\ntest_rotate_image()", "exec_outcome": "PASSED"}
{"code": "# print_diamond prints a diamond pattern using asterisks ('*') with 2n-1 rows.\n# Each row contains exactly 2n-1 characters.\n# The method first determines the number of stars and spaces for each row.\n# For rows in the upper half (i <= n), the number of stars increases.\n# For rows in the lower half (i > n), the number of stars decreases.\n# The spaces are calculated to center the stars in each row.\ndef print_diamond(n)\n  (1..2 * n - 1).each do |i|\n    if i <= n\n      stars = 2 * i - 1\n    else\n      stars = 2 * (2 * n - i) - 1\n    end\n    spaces = n - (stars / 2) - 1\n    puts (' ' * spaces) + ('*' * stars) + (' ' * spaces)\n  end\nend", "test_cases": "", "test_case_results": "Input: 1\n*\n\nInput: 2\n * \n***\n * \n\nInput: 3\n  *  \n *** \n*****\n *** \n  *  \n\nInput: 4\n   *   \n  ***  \n ***** \n*******\n ***** \n  ***  \n   *", "task_id": 6433, "assertions": "def test_print_diamond()\n  # Test case for n = 1\n  expected1 = \"*\\n\"\n  raise \"Test case 1 failed\" unless print_diamond(1) == expected1\n\n  # Test case for n = 2\n  expected2 = \" * \\n***\\n * \\n\"\n  raise \"Test case 2 failed\" unless print_diamond(2) == expected2\n\n  # Test case for n = 3\n  expected3 = \"  *  \\n *** \\n*****\\n *** \\n  *  \\n\"\n  raise \"Test case 3 failed\" unless print_diamond(3) == expected3\n\n  # Test case for n = 4\n  expected4 = \"   *   \\n  ***  \\n ***** \\n*******\\n ***** \\n  ***  \\n   *   \\n\"\n  raise \"Test case 4 failed\" unless print_diamond(4) == expected4\nend\n\ntest_print_diamond()", "all_code": "# print_diamond prints a diamond pattern using asterisks ('*') with 2n-1 rows.\n# Each row contains exactly 2n-1 characters.\n# The method first determines the number of stars and spaces for each row.\n# For rows in the upper half (i <= n), the number of stars increases.\n# For rows in the lower half (i > n), the number of stars decreases.\n# The spaces are calculated to center the stars in each row.\ndef print_diamond(n)\n  (1..2 * n - 1).each do |i|\n    if i <= n\n      stars = 2 * i - 1\n    else\n      stars = 2 * (2 * n - i) - 1\n    end\n    spaces = n - (stars / 2) - 1\n    puts (' ' * spaces) + ('*' * stars) + (' ' * spaces)\n  end\nend\ndef test_print_diamond()\n  # Test case for n = 1\n  expected1 = \"*\\n\"\n  raise \"Test case 1 failed\" unless print_diamond(1) == expected1\n\n  # Test case for n = 2\n  expected2 = \" * \\n***\\n * \\n\"\n  raise \"Test case 2 failed\" unless print_diamond(2) == expected2\n\n  # Test case for n = 3\n  expected3 = \"  *  \\n *** \\n*****\\n *** \\n  *  \\n\"\n  raise \"Test case 3 failed\" unless print_diamond(3) == expected3\n\n  # Test case for n = 4\n  expected4 = \"   *   \\n  ***  \\n ***** \\n*******\\n ***** \\n  ***  \\n   *   \\n\"\n  raise \"Test case 4 failed\" unless print_diamond(4) == expected4\nend\n\ntest_print_diamond()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# find_pair searches for two distinct integers in an array that add up to a target value.\n# It uses a hash to store each number's index and checks for the complement (target - current number).\n# If found, it returns the indices of the pair in ascending order; otherwise, it returns an empty array.\n#\n# @param arr [Array<Integer>] the input array of integers\n# @param target [Integer] the target sum to find\n# @return [Array<Integer>] the indices of the pair in ascending order, or empty array if not found\ndef find_pair(arr, target)\n  num_to_index = {}\n  arr.each_with_index do |num, i|\n    complement = target - num\n    if num_to_index.key?(complement)\n      return [num_to_index[complement], i].sort\n    end\n    num_to_index[num] = i\n  end\n  []\nend", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4], Target: 5\nResult: [1, 2]\n---\nInput array: [5, 6, 7, 0], Target: 5\nResult: [0, 3]\n---\nInput array: [0, 0, 0, 0], Target: 0\nResult: [0, 1]\n---\nInput array: [1, 2, 3, 4], Target: 10\nResult: []\n---", "task_id": 19545, "assertions": "def test_find_pair()\n  raise unless find_pair([1, 2, 3, 4], 5) == [1, 2]\n  raise unless find_pair([5, 6, 7, 0], 5) == [0, 3]\n  raise unless find_pair([0, 0, 0, 0], 0) == [0, 1]\n  raise unless find_pair([1, 2, 3, 4], 10) == []\nend\n\ntest_find_pair()", "all_code": "# find_pair searches for two distinct integers in an array that add up to a target value.\n# It uses a hash to store each number's index and checks for the complement (target - current number).\n# If found, it returns the indices of the pair in ascending order; otherwise, it returns an empty array.\n#\n# @param arr [Array<Integer>] the input array of integers\n# @param target [Integer] the target sum to find\n# @return [Array<Integer>] the indices of the pair in ascending order, or empty array if not found\ndef find_pair(arr, target)\n  num_to_index = {}\n  arr.each_with_index do |num, i|\n    complement = target - num\n    if num_to_index.key?(complement)\n      return [num_to_index[complement], i].sort\n    end\n    num_to_index[num] = i\n  end\n  []\nend\ndef test_find_pair()\n  raise unless find_pair([1, 2, 3, 4], 5) == [1, 2]\n  raise unless find_pair([5, 6, 7, 0], 5) == [0, 3]\n  raise unless find_pair([0, 0, 0, 0], 0) == [0, 1]\n  raise unless find_pair([1, 2, 3, 4], 10) == []\nend\n\ntest_find_pair()", "exec_outcome": "PASSED"}
{"code": "def count_occurrences(lst)\n  occurrences = {}\n  lst.each do |item|\n    if occurrences.key?(item)\n      occurrences[item] += 1\n    else\n      occurrences[item] = 1\n    end\n  end\n  occurrences\nend", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 1, 2, 1]\nOccurrences: {1=>3, 2=>2, 3=>1, 4=>1}\nInput: [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]\nOccurrences: {\"apple\"=>3, \"banana\"=>2, \"orange\"=>1}\nInput: [true, false, true, true, false]\nOccurrences: {true=>3, false=>2}\nInput: []\nOccurrences: {}\nInput: [1, \"apple\", true, 1, \"apple\", true]\nOccurrences: {1=>2, \"apple\"=>2, true=>2}", "task_id": 8494, "assertions": "def test_count_occurrences()\n  raise unless count_occurrences([1, 2, 3, 4, 1, 2, 1]) == {1=>3, 2=>2, 3=>1, 4=>1}\n  raise unless count_occurrences([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]) == {\"apple\"=>3, \"banana\"=>2, \"orange\"=>1}\n  raise unless count_occurrences([true, false, true, true, false]) == {true=>3, false=>2}\n  raise unless count_occurrences([]) == {}\n  raise unless count_occurrences([1, \"apple\", true, 1, \"apple\", true]) == {1=>2, \"apple\"=>2, true=>2}\nend\n\ntest_count_occurrences()", "all_code": "def count_occurrences(lst)\n  occurrences = {}\n  lst.each do |item|\n    if occurrences.key?(item)\n      occurrences[item] += 1\n    else\n      occurrences[item] = 1\n    end\n  end\n  occurrences\nend\ndef test_count_occurrences()\n  raise unless count_occurrences([1, 2, 3, 4, 1, 2, 1]) == {1=>3, 2=>2, 3=>1, 4=>1}\n  raise unless count_occurrences([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\"]) == {\"apple\"=>3, \"banana\"=>2, \"orange\"=>1}\n  raise unless count_occurrences([true, false, true, true, false]) == {true=>3, false=>2}\n  raise unless count_occurrences([]) == {}\n  raise unless count_occurrences([1, \"apple\", true, 1, \"apple\", true]) == {1=>2, \"apple\"=>2, true=>2}\nend\n\ntest_count_occurrences()", "exec_outcome": "PASSED"}
{"code": "# square calculates the square of a number using recursion.\n# It handles negative numbers by converting them to positive before squaring.\n# If the input is zero, it returns zero immediately.\ndef square(n)\n  return 0 if n == 0\n  n = -n if n < 0\n  square_recursive(n, n)\nend\n\n# square_recursive is a helper method that performs the actual recursive squaring.\n# It adds the original number to itself (n-1) times to compute the square.\n# The base case is when n is 1, at which point it returns the original number.\ndef square_recursive(n, original_n)\n  return original_n if n == 1\n  original_n + square_recursive(n - 1, original_n)\nend", "test_cases": "", "test_case_results": "Input: 0\nSquare: 0\nInput: 1\nSquare: 1\nInput: 2\nSquare: 4\nInput: 5\nSquare: 25\nInput: -3\nSquare: 9\nInput: -10\nSquare: 100", "task_id": 5951, "assertions": "def test_square()\n  raise unless square(0) == 0\n  raise unless square(1) == 1\n  raise unless square(2) == 4\n  raise unless square(5) == 25\n  raise unless square(-3) == 9\n  raise unless square(-10) == 100\nend\n\ntest_square()", "all_code": "# square calculates the square of a number using recursion.\n# It handles negative numbers by converting them to positive before squaring.\n# If the input is zero, it returns zero immediately.\ndef square(n)\n  return 0 if n == 0\n  n = -n if n < 0\n  square_recursive(n, n)\nend\n\n# square_recursive is a helper method that performs the actual recursive squaring.\n# It adds the original number to itself (n-1) times to compute the square.\n# The base case is when n is 1, at which point it returns the original number.\ndef square_recursive(n, original_n)\n  return original_n if n == 1\n  original_n + square_recursive(n - 1, original_n)\nend\ndef test_square()\n  raise unless square(0) == 0\n  raise unless square(1) == 1\n  raise unless square(2) == 4\n  raise unless square(5) == 25\n  raise unless square(-3) == 9\n  raise unless square(-10) == 100\nend\n\ntest_square()", "exec_outcome": "PASSED"}
{"code": "# find_all_in_dict searches a nested Hash for all occurrences of a given key and returns the values in an array.\n# It uses a stack to traverse the Hash depth-first, checking each level for the specified key.\n#\n# @param hash_to_search [Hash] The Hash to search through.\n# @param key_to_find [Symbol, String] The key to search for.\n# @return [Array] An array of all values for the specified key in the input Hash.\ndef find_all_in_dict(hash_to_search, key_to_find)\n  result = []\n  stack = [hash_to_search]\n\n  while !stack.empty?\n    current_hash = stack.pop\n\n    # Check if the current hash has the key_to_find\n    if current_hash.key?(key_to_find)\n      result << current_hash[key_to_find]\n    end\n\n    # Add sub-hashes to the stack\n    current_hash.each_value do |value|\n      if value.is_a?(Hash)\n        stack << value\n      end\n    end\n  end\n\n  result\nend", "test_cases": "", "test_case_results": "Input Hash: {:a=>1, :b=>2, :c=>{:key_to_find=>[1, 2, 3], :d=>4}, :e=>{:key_to_find=>{:f=>5, :g=>6}, :h=>7}, :key_to_find=>\"Top level value\"}\nKey to Find: key_to_find\nResult: [\"Top level value\", {:f=>5, :g=>6}, [1, 2, 3]]\nExpected: [\"Top level value\", [1, 2, 3], {:f=>5, :g=>6}]\n---\nInput Hash: {:x=>10, :y=>{:z=>20, :key_to_find=>\"Nested value\"}, :key_to_find=>\"Root value\"}\nKey to Find: key_to_find\nResult: [\"Root value\", \"Nested value\"]\nExpected: [\"Root value\", \"Nested value\"]\n---\nInput Hash: {:a=>1, :b=>2, :c=>3}\nKey to Find: key_to_find\nResult: []\nExpected: []\n---", "task_id": 9263, "assertions": "def test_find_all_in_dict\n  test_cases = [\n    {\n      hash: {\n        a: 1,\n        b: 2,\n        c: {\n          key_to_find: [1, 2, 3],\n          d: 4\n        },\n        e: {\n          key_to_find: { f: 5, g: 6 },\n          h: 7\n        },\n        key_to_find: 'Top level value'\n      },\n      key: :key_to_find,\n      expected: ['Top level value', [1, 2, 3], { f: 5, g: 6 }]\n    },\n    {\n      hash: {\n        x: 10,\n        y: {\n          z: 20,\n          key_to_find: 'Nested value'\n        },\n        key_to_find: 'Root value'\n      },\n      key: :key_to_find,\n      expected: ['Root value', 'Nested value']\n    },\n    {\n      hash: {\n        a: 1,\n        b: 2,\n        c: 3\n      },\n      key: :key_to_find,\n      expected: []\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_all_in_dict(test_case[:hash], test_case[:key])\n    unless result.sort_by(&:to_s) == test_case[:expected].sort_by(&:to_s)\n      raise \"Test failed for input: #{test_case[:hash]}. Expected #{test_case[:expected]}, got #{result}\"\n    end\n  end\nend\n\ntest_find_all_in_dict", "all_code": "# find_all_in_dict searches a nested Hash for all occurrences of a given key and returns the values in an array.\n# It uses a stack to traverse the Hash depth-first, checking each level for the specified key.\n#\n# @param hash_to_search [Hash] The Hash to search through.\n# @param key_to_find [Symbol, String] The key to search for.\n# @return [Array] An array of all values for the specified key in the input Hash.\ndef find_all_in_dict(hash_to_search, key_to_find)\n  result = []\n  stack = [hash_to_search]\n\n  while !stack.empty?\n    current_hash = stack.pop\n\n    # Check if the current hash has the key_to_find\n    if current_hash.key?(key_to_find)\n      result << current_hash[key_to_find]\n    end\n\n    # Add sub-hashes to the stack\n    current_hash.each_value do |value|\n      if value.is_a?(Hash)\n        stack << value\n      end\n    end\n  end\n\n  result\nend\ndef test_find_all_in_dict\n  test_cases = [\n    {\n      hash: {\n        a: 1,\n        b: 2,\n        c: {\n          key_to_find: [1, 2, 3],\n          d: 4\n        },\n        e: {\n          key_to_find: { f: 5, g: 6 },\n          h: 7\n        },\n        key_to_find: 'Top level value'\n      },\n      key: :key_to_find,\n      expected: ['Top level value', [1, 2, 3], { f: 5, g: 6 }]\n    },\n    {\n      hash: {\n        x: 10,\n        y: {\n          z: 20,\n          key_to_find: 'Nested value'\n        },\n        key_to_find: 'Root value'\n      },\n      key: :key_to_find,\n      expected: ['Root value', 'Nested value']\n    },\n    {\n      hash: {\n        a: 1,\n        b: 2,\n        c: 3\n      },\n      key: :key_to_find,\n      expected: []\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_all_in_dict(test_case[:hash], test_case[:key])\n    unless result.sort_by(&:to_s) == test_case[:expected].sort_by(&:to_s)\n      raise \"Test failed for input: #{test_case[:hash]}. Expected #{test_case[:expected]}, got #{result}\"\n    end\n  end\nend\n\ntest_find_all_in_dict", "exec_outcome": "PASSED"}
{"code": "# max_points_visited calculates the maximum number of distinct points that can be visited using at most k moves.\n# The method assumes that the points are ordered and that each move allows visiting the next point in sequence.\n# Starting from the first point, it increments the count of visited points for each move until either all points are visited or the move limit k is reached.\n#\n# Parameters:\n# n - The total number of points.\n# k - The maximum number of moves allowed.\n# points - An array of coordinate tuples representing the points.\n#\n# Returns:\n# The maximum number of distinct points that can be visited.\ndef max_points_visited(n, k, points)\n  visited_points = 1  # Start at the first point\n  moves_used = 0\n\n  # Iterate through the points starting from the second one\n  (1...n).each do |i|\n    if moves_used < k\n      visited_points += 1\n      moves_used += 1\n    else\n      break\n    end\n  end\n\n  visited_points\nend", "test_cases": "", "test_case_results": "Input: n=5, k=3, points=[[0, 0], [1, 2], [2, 4], [3, 6], [4, 8]]\nMaximum points visited: 4\nInput: n=3, k=5, points=[[0, 0], [1, 1], [2, 2]]\nMaximum points visited: 3\nInput: n=1, k=10, points=[[0, 0]]\nMaximum points visited: 1\nInput: n=10, k=0, points=[[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]\nMaximum points visited: 1", "task_id": 24978, "assertions": "def test_max_points_visited()\n  # Test case 1: Normal case with k < n\n  raise \"Test case 1 failed\" unless max_points_visited(5, 3, [[0, 0], [1, 2], [2, 4], [3, 6], [4, 8]]) == 4\n\n  # Test case 2: Case where k > n\n  raise \"Test case 2 failed\" unless max_points_visited(3, 5, [[0, 0], [1, 1], [2, 2]]) == 3\n\n  # Test case 3: Single point case\n  raise \"Test case 3 failed\" unless max_points_visited(1, 10, [[0, 0]]) == 1\n\n  # Test case 4: Case with k = 0\n  raise \"Test case 4 failed\" unless max_points_visited(10, 0, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]) == 1\nend\n\ntest_max_points_visited()", "all_code": "# max_points_visited calculates the maximum number of distinct points that can be visited using at most k moves.\n# The method assumes that the points are ordered and that each move allows visiting the next point in sequence.\n# Starting from the first point, it increments the count of visited points for each move until either all points are visited or the move limit k is reached.\n#\n# Parameters:\n# n - The total number of points.\n# k - The maximum number of moves allowed.\n# points - An array of coordinate tuples representing the points.\n#\n# Returns:\n# The maximum number of distinct points that can be visited.\ndef max_points_visited(n, k, points)\n  visited_points = 1  # Start at the first point\n  moves_used = 0\n\n  # Iterate through the points starting from the second one\n  (1...n).each do |i|\n    if moves_used < k\n      visited_points += 1\n      moves_used += 1\n    else\n      break\n    end\n  end\n\n  visited_points\nend\ndef test_max_points_visited()\n  # Test case 1: Normal case with k < n\n  raise \"Test case 1 failed\" unless max_points_visited(5, 3, [[0, 0], [1, 2], [2, 4], [3, 6], [4, 8]]) == 4\n\n  # Test case 2: Case where k > n\n  raise \"Test case 2 failed\" unless max_points_visited(3, 5, [[0, 0], [1, 1], [2, 2]]) == 3\n\n  # Test case 3: Single point case\n  raise \"Test case 3 failed\" unless max_points_visited(1, 10, [[0, 0]]) == 1\n\n  # Test case 4: Case with k = 0\n  raise \"Test case 4 failed\" unless max_points_visited(10, 0, [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]) == 1\nend\n\ntest_max_points_visited()", "exec_outcome": "PASSED"}
{"code": "# decimal_to_binary_list converts a decimal number to an 8-bit binary list.\n# If the number is larger than 255 or negative, it returns \"Error\".\n# The method uses string formatting to convert the number to an 8-bit binary string,\n# then converts each character in the string to an integer to form the list.\ndef decimal_to_binary_list(n)\n  if n > 255 || n < 0\n    return \"Error\"\n  end\n  \n  binary_format = \"%08b\" % n\n  binary_format.chars.map(&:to_i)\nend", "test_cases": "", "test_case_results": "Input: 5\nResult: [0, 0, 0, 0, 0, 1, 0, 1]\nInput: 16\nResult: [0, 0, 0, 1, 0, 0, 0, 0]\nInput: 255\nResult: [1, 1, 1, 1, 1, 1, 1, 1]\nInput: 256\nResult: Error\nInput: -1\nResult: Error\nInput: 0\nResult: [0, 0, 0, 0, 0, 0, 0, 0]", "task_id": 15780, "assertions": "def test_decimal_to_binary_list()\n  raise unless decimal_to_binary_list(5) == [0, 0, 0, 0, 0, 1, 0, 1]\n  raise unless decimal_to_binary_list(16) == [0, 0, 0, 1, 0, 0, 0, 0]\n  raise unless decimal_to_binary_list(255) == [1, 1, 1, 1, 1, 1, 1, 1]\n  raise unless decimal_to_binary_list(256) == \"Error\"\n  raise unless decimal_to_binary_list(-1) == \"Error\"\n  raise unless decimal_to_binary_list(0) == [0, 0, 0, 0, 0, 0, 0, 0]\nend\n\ntest_decimal_to_binary_list()", "all_code": "# decimal_to_binary_list converts a decimal number to an 8-bit binary list.\n# If the number is larger than 255 or negative, it returns \"Error\".\n# The method uses string formatting to convert the number to an 8-bit binary string,\n# then converts each character in the string to an integer to form the list.\ndef decimal_to_binary_list(n)\n  if n > 255 || n < 0\n    return \"Error\"\n  end\n  \n  binary_format = \"%08b\" % n\n  binary_format.chars.map(&:to_i)\nend\ndef test_decimal_to_binary_list()\n  raise unless decimal_to_binary_list(5) == [0, 0, 0, 0, 0, 1, 0, 1]\n  raise unless decimal_to_binary_list(16) == [0, 0, 0, 1, 0, 0, 0, 0]\n  raise unless decimal_to_binary_list(255) == [1, 1, 1, 1, 1, 1, 1, 1]\n  raise unless decimal_to_binary_list(256) == \"Error\"\n  raise unless decimal_to_binary_list(-1) == \"Error\"\n  raise unless decimal_to_binary_list(0) == [0, 0, 0, 0, 0, 0, 0, 0]\nend\n\ntest_decimal_to_binary_list()", "exec_outcome": "PASSED"}
{"code": "# Determines if it's possible to visit exactly 'k' attractions within 'L' hours given their waiting times.\n# For each test case, it checks all combinations of 'k' attractions to see if any combination's total waiting time is <= 'L'.\n# Returns an array of \"YES\" or \"NO\" strings indicating whether it's possible for each test case.\ndef can_visit_attractions(test_cases)\n  results = []\n  \n  test_cases.each do |test|\n    n, k, l, waiting_times = test\n    possible = waiting_times.combination(k).any? { |combo| combo.sum <= l }\n    results << (possible ? \"YES\" : \"NO\")\n  end\n  \n  results\nend", "test_cases": "", "test_case_results": "Test Case 1:\n  Number of attractions (n): 5\n  Number to visit (k): 3\n  Maximum total waiting time (L): 10\n  Waiting times: [1, 2, 3, 4, 5]\n  Result: YES\n\nTest Case 2:\n  Number of attractions (n): 4\n  Number to visit (k): 2\n  Maximum total waiting time (L): 5\n  Waiting times: [6, 7, 8, 9]\n  Result: NO\n\nTest Case 3:\n  Number of attractions (n): 3\n  Number to visit (k): 1\n  Maximum total waiting time (L): 3\n  Waiting times: [4, 5, 6]\n  Result: NO\n\nTest Case 4:\n  Number of attractions (n): 3\n  Number to visit (k): 2\n  Maximum total waiting time (L): 10\n  Waiting times: [1, 5, 3]\n  Result: YES", "task_id": 25016, "assertions": "def test_can_visit_attractions()\n  test_cases = [\n    [5, 3, 10, [1, 2, 3, 4, 5]],  # Possible (1+2+3 = 6 <= 10)\n    [4, 2, 5, [6, 7, 8, 9]],       # Not possible (all combinations > 5)\n    [3, 1, 3, [4, 5, 6]],          # Not possible (all > 3)\n    [3, 2, 10, [1, 5, 3]]          # Possible (1+5 = 6 <= 10)\n  ]\n\n  expected_results = [\"YES\", \"NO\", \"NO\", \"YES\"]\n  actual_results = can_visit_attractions(test_cases)\n\n  actual_results.each_with_index do |result, index|\n    raise \"Test case #{index + 1} failed: Expected #{expected_results[index]}, got #{result}\" unless result == expected_results[index]\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_can_visit_attractions()", "all_code": "# Determines if it's possible to visit exactly 'k' attractions within 'L' hours given their waiting times.\n# For each test case, it checks all combinations of 'k' attractions to see if any combination's total waiting time is <= 'L'.\n# Returns an array of \"YES\" or \"NO\" strings indicating whether it's possible for each test case.\ndef can_visit_attractions(test_cases)\n  results = []\n  \n  test_cases.each do |test|\n    n, k, l, waiting_times = test\n    possible = waiting_times.combination(k).any? { |combo| combo.sum <= l }\n    results << (possible ? \"YES\" : \"NO\")\n  end\n  \n  results\nend\ndef test_can_visit_attractions()\n  test_cases = [\n    [5, 3, 10, [1, 2, 3, 4, 5]],  # Possible (1+2+3 = 6 <= 10)\n    [4, 2, 5, [6, 7, 8, 9]],       # Not possible (all combinations > 5)\n    [3, 1, 3, [4, 5, 6]],          # Not possible (all > 3)\n    [3, 2, 10, [1, 5, 3]]          # Possible (1+5 = 6 <= 10)\n  ]\n\n  expected_results = [\"YES\", \"NO\", \"NO\", \"YES\"]\n  actual_results = can_visit_attractions(test_cases)\n\n  actual_results.each_with_index do |result, index|\n    raise \"Test case #{index + 1} failed: Expected #{expected_results[index]}, got #{result}\" unless result == expected_results[index]\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_can_visit_attractions()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef summarize_text(text)\n  words = text.split\n  return '' if words.empty?\n\n  # Count the frequency of each word\n  word_counts = Hash.new(0)\n  words.each { |word| word_counts[word] += 1 }\n\n  # Sort words by frequency in descending order\n  sorted_words = word_counts.keys.sort_by { |word| -word_counts[word] }\n\n  # Replace each word in the original text with 'x' in order of their frequency\n  sorted_words.each do |word|\n    words.map! { |w| w == word ? 'x' : w }\n  end\n\n  words.join(' ')\nend", "test_cases": "", "test_case_results": "Input: \"apple banana apple orange banana apple\"\nSummarized: \"x x x x x x\"\nInput: \"hello world hello world world\"\nSummarized: \"x x x x x\"\nInput: \"a b c d e f g\"\nSummarized: \"x x x x x x x\"\nInput: \"\"\nSummarized: \"\"", "task_id": 6397, "assertions": "def test_summarize_text()\n  raise unless summarize_text(\"apple banana apple orange banana apple\") == \"x x x x x x\"\n  raise unless summarize_text(\"hello world hello world world\") == \"x x x x x\"\n  raise unless summarize_text(\"a b c d e f g\") == \"x x x x x x x\"\n  raise unless summarize_text(\"\") == \"\"\nend\n\ntest_summarize_text()", "all_code": "require 'set'\n\ndef summarize_text(text)\n  words = text.split\n  return '' if words.empty?\n\n  # Count the frequency of each word\n  word_counts = Hash.new(0)\n  words.each { |word| word_counts[word] += 1 }\n\n  # Sort words by frequency in descending order\n  sorted_words = word_counts.keys.sort_by { |word| -word_counts[word] }\n\n  # Replace each word in the original text with 'x' in order of their frequency\n  sorted_words.each do |word|\n    words.map! { |w| w == word ? 'x' : w }\n  end\n\n  words.join(' ')\nend\ndef test_summarize_text()\n  raise unless summarize_text(\"apple banana apple orange banana apple\") == \"x x x x x x\"\n  raise unless summarize_text(\"hello world hello world world\") == \"x x x x x\"\n  raise unless summarize_text(\"a b c d e f g\") == \"x x x x x x x\"\n  raise unless summarize_text(\"\") == \"\"\nend\n\ntest_summarize_text()", "exec_outcome": "PASSED"}
{"code": "# rank_columns takes a 2D array as input and returns a new array where the values in each \n# column are replaced by their rank within that column. Ranks are 1-based.\n#\n# Args:\n#   tensor (Array): A 2D input array.\n#\n# Returns:\n#   Array: A 2D array with the ranks of the original values.\ndef rank_columns(tensor)\n  return [] if tensor.empty? || tensor[0].empty?\n\n  ranks = Array.new(tensor.size) { Array.new(tensor[0].size, 0) }\n\n  # Iterate through each column\n  (0...tensor[0].size).each do |col|\n    # Create an array of [value, original_index] pairs for the current column\n    indexed_values = tensor.each_with_index.map { |row, idx| [row[col], idx] }\n\n    # Sort the pairs based on the value\n    sorted_pairs = indexed_values.sort_by { |value, idx| value }\n\n    current_rank = 1\n    sorted_pairs.each_with_index do |(value, idx), i|\n      # If the current value is different from the previous one, update the current rank\n      if i > 0 && value != sorted_pairs[i - 1][0]\n        current_rank = i + 1\n      end\n      ranks[idx][col] = current_rank\n    end\n  end\n\n  ranks\nend", "test_cases": "", "test_case_results": "Input: [[3, 1, 4], [1, 5, 9], [2, 6, 5]]\nRanks: [[3, 1, 1], [1, 2, 3], [2, 3, 2]]\nInput: [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\nRanks: [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\nInput: [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\nRanks: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\nInput: [[], []]\nRanks: []\nInput: [[[1, 2], [3, 4]]]\nRanks: [[1, 1]]", "task_id": 27644, "assertions": "def test_rank_columns()\n  # Test case with distinct values\n  raise unless rank_columns([[3, 1, 4], [1, 5, 9], [2, 6, 5]]) == [[3, 1, 1], [1, 2, 3], [2, 3, 2]]\n  \n  # Test case with all values in each column distinct\n  raise unless rank_columns([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) == [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n  \n  # Test case with all values the same\n  raise unless rank_columns([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n  \n  # Test case with empty array\n  raise unless rank_columns([[], []]) == []\n  \n  # Test case with nested array (edge case)\n  raise unless rank_columns([[[1, 2], [3, 4]]]) == [[1, 1]]\nend\n\ntest_rank_columns()", "all_code": "# rank_columns takes a 2D array as input and returns a new array where the values in each \n# column are replaced by their rank within that column. Ranks are 1-based.\n#\n# Args:\n#   tensor (Array): A 2D input array.\n#\n# Returns:\n#   Array: A 2D array with the ranks of the original values.\ndef rank_columns(tensor)\n  return [] if tensor.empty? || tensor[0].empty?\n\n  ranks = Array.new(tensor.size) { Array.new(tensor[0].size, 0) }\n\n  # Iterate through each column\n  (0...tensor[0].size).each do |col|\n    # Create an array of [value, original_index] pairs for the current column\n    indexed_values = tensor.each_with_index.map { |row, idx| [row[col], idx] }\n\n    # Sort the pairs based on the value\n    sorted_pairs = indexed_values.sort_by { |value, idx| value }\n\n    current_rank = 1\n    sorted_pairs.each_with_index do |(value, idx), i|\n      # If the current value is different from the previous one, update the current rank\n      if i > 0 && value != sorted_pairs[i - 1][0]\n        current_rank = i + 1\n      end\n      ranks[idx][col] = current_rank\n    end\n  end\n\n  ranks\nend\ndef test_rank_columns()\n  # Test case with distinct values\n  raise unless rank_columns([[3, 1, 4], [1, 5, 9], [2, 6, 5]]) == [[3, 1, 1], [1, 2, 3], [2, 3, 2]]\n  \n  # Test case with all values in each column distinct\n  raise unless rank_columns([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) == [[1, 1, 1], [2, 2, 2], [3, 3, 3]]\n  \n  # Test case with all values the same\n  raise unless rank_columns([[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n  \n  # Test case with empty array\n  raise unless rank_columns([[], []]) == []\n  \n  # Test case with nested array (edge case)\n  raise unless rank_columns([[[1, 2], [3, 4]]]) == [[1, 1]]\nend\n\ntest_rank_columns()", "exec_outcome": "PASSED"}
{"code": "def generate_combinations(s)\n  result = []\n  \n  backtrack = lambda do |start, path|\n    unless path.empty?\n      result << path.join\n    end\n    \n    (start...s.length).each do |i|\n      path << s[i]\n      backtrack.call(i + 1, path)\n      path.pop\n    end\n  end\n  \n  backtrack.call(0, [])\n  result\nend", "test_cases": "", "test_case_results": "Input: \"abc\"\nCombinations: [\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"]\nInput: \"a\"\nCombinations: [\"a\"]\nInput: \"xy\"\nCombinations: [\"x\", \"xy\", \"y\"]\nInput: \"\"\nCombinations: []", "task_id": 6617, "assertions": "def test_generate_combinations()\n  raise unless generate_combinations(\"abc\") == [\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"]\n  raise unless generate_combinations(\"a\") == [\"a\"]\n  raise unless generate_combinations(\"xy\") == [\"x\", \"xy\", \"y\"]\n  raise unless generate_combinations(\"\") == []\nend\n\ntest_generate_combinations()", "all_code": "def generate_combinations(s)\n  result = []\n  \n  backtrack = lambda do |start, path|\n    unless path.empty?\n      result << path.join\n    end\n    \n    (start...s.length).each do |i|\n      path << s[i]\n      backtrack.call(i + 1, path)\n      path.pop\n    end\n  end\n  \n  backtrack.call(0, [])\n  result\nend\ndef test_generate_combinations()\n  raise unless generate_combinations(\"abc\") == [\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"]\n  raise unless generate_combinations(\"a\") == [\"a\"]\n  raise unless generate_combinations(\"xy\") == [\"x\", \"xy\", \"y\"]\n  raise unless generate_combinations(\"\") == []\nend\n\ntest_generate_combinations()", "exec_outcome": "PASSED"}
{"code": "# leaderboard calculates the rankings for participants based on their finish times.\n# Participants with the same finish time receive the same rank, expressed as a range (e.g., \"1-3\").\n# The method takes the number of top participants to rank (n) and an array of entries (each entry is a string with name and finish time).\n# It returns an array of strings in the format \"rank name\".\ndef leaderboard(n, entries)\n  # Parse each entry into a tuple of name and finish_time\n  participants = entries.map { |entry| parts = entry.split; [parts[0], parts[1].to_i] }\n\n  # Sort participants first by finish_time, then by name (in case of tie on finish_time)\n  participants.sort_by! { |name, time| [time, name] }\n\n  result = []\n  i = 0\n  while i < n\n    current_time = participants[i][1]\n    start = i\n\n    # Find all participants with the same finish_time\n    while i < n && participants[i][1] == current_time\n      i += 1\n    end\n\n    # Determine the rank string\n    if start + 1 < i\n      rank = \"#{start + 1}-#{i}\"\n    else\n      rank = (start + 1).to_s\n    end\n\n    # Add each participant in this group to the result\n    (start...i).each do |j|\n      result << \"#{rank} #{participants[j][0]}\"\n    end\n  end\n\n  result\nend", "test_cases": "", "test_case_results": "Input: n=3, entries=[\"Alice 100\", \"Bob 90\", \"Charlie 90\", \"Dave 120\"]\nLeaderboard: [\"1-2 Bob\", \"1-2 Charlie\", \"3 Alice\"]\nInput: n=5, entries=[\"Eve 80\", \"Frank 80\", \"Grace 90\", \"Hank 85\", \"Ivy 85\"]\nLeaderboard: [\"1-2 Eve\", \"1-2 Frank\", \"3-4 Hank\", \"3-4 Ivy\", \"5 Grace\"]\nInput: n=2, entries=[\"John 200\", \"Jane 200\"]\nLeaderboard: [\"1-2 Jane\", \"1-2 John\"]", "task_id": 15280, "assertions": "def test_leaderboard()\n  raise unless leaderboard(3, [\"Alice 100\", \"Bob 90\", \"Charlie 90\", \"Dave 120\"]) == [\"1-2 Bob\", \"1-2 Charlie\", \"3 Alice\"]\n  raise unless leaderboard(5, [\"Eve 80\", \"Frank 80\", \"Grace 90\", \"Hank 85\", \"Ivy 85\"]) == [\"1-2 Eve\", \"1-2 Frank\", \"3-4 Hank\", \"3-4 Ivy\", \"5 Grace\"]\n  raise unless leaderboard(2, [\"John 200\", \"Jane 200\"]) == [\"1-2 Jane\", \"1-2 John\"]\nend\n\ntest_leaderboard()", "all_code": "# leaderboard calculates the rankings for participants based on their finish times.\n# Participants with the same finish time receive the same rank, expressed as a range (e.g., \"1-3\").\n# The method takes the number of top participants to rank (n) and an array of entries (each entry is a string with name and finish time).\n# It returns an array of strings in the format \"rank name\".\ndef leaderboard(n, entries)\n  # Parse each entry into a tuple of name and finish_time\n  participants = entries.map { |entry| parts = entry.split; [parts[0], parts[1].to_i] }\n\n  # Sort participants first by finish_time, then by name (in case of tie on finish_time)\n  participants.sort_by! { |name, time| [time, name] }\n\n  result = []\n  i = 0\n  while i < n\n    current_time = participants[i][1]\n    start = i\n\n    # Find all participants with the same finish_time\n    while i < n && participants[i][1] == current_time\n      i += 1\n    end\n\n    # Determine the rank string\n    if start + 1 < i\n      rank = \"#{start + 1}-#{i}\"\n    else\n      rank = (start + 1).to_s\n    end\n\n    # Add each participant in this group to the result\n    (start...i).each do |j|\n      result << \"#{rank} #{participants[j][0]}\"\n    end\n  end\n\n  result\nend\ndef test_leaderboard()\n  raise unless leaderboard(3, [\"Alice 100\", \"Bob 90\", \"Charlie 90\", \"Dave 120\"]) == [\"1-2 Bob\", \"1-2 Charlie\", \"3 Alice\"]\n  raise unless leaderboard(5, [\"Eve 80\", \"Frank 80\", \"Grace 90\", \"Hank 85\", \"Ivy 85\"]) == [\"1-2 Eve\", \"1-2 Frank\", \"3-4 Hank\", \"3-4 Ivy\", \"5 Grace\"]\n  raise unless leaderboard(2, [\"John 200\", \"Jane 200\"]) == [\"1-2 Jane\", \"1-2 John\"]\nend\n\ntest_leaderboard()", "exec_outcome": "PASSED"}
{"code": "# evaluate_expression evaluates a properly formatted arithmetic expression containing non-negative\n# integers and the operators +, -, *, / separated by spaces.\n# Integer division truncates towards zero.\ndef evaluate_expression(expression)\n  tokens = expression.split\n  index = 0\n\n  # get_next_token retrieves the next token from the tokens array and increments the index.\n  get_next_token = lambda do\n    token = tokens[index]\n    index += 1\n    token\n  end\n\n  # parse_term parses a term in the expression, handling multiplication and division.\n  parse_term = lambda do\n    result = get_next_token.call.to_i\n    while index < tokens.size\n      operator = tokens[index]\n      break if ['+', '-'].include?(operator)\n      index += 1\n      next_value = get_next_token.call.to_i\n      if operator == '*'\n        result *= next_value\n      elsif operator == '/'\n        result = (result / next_value).to_i  # Truncate towards zero\n      end\n    end\n    result\n  end\n\n  # parse_expression parses the entire expression, handling addition and subtraction.\n  parse_expression = lambda do\n    result = parse_term.call\n    while index < tokens.size\n      operator = tokens[index]\n      break unless ['+', '-'].include?(operator)\n      index += 1\n      next_value = parse_term.call\n      if operator == '+'\n        result += next_value\n      elsif operator == '-'\n        result -= next_value\n      end\n    end\n    result\n  end\n\n  parse_expression.call\nend", "test_cases": "", "test_case_results": "Input: 1 + 2 * 3\nResult: 7\nInput: 4 * 5 - 6 / 2\nResult: 17\nInput: 10 / 3 * 3\nResult: 9\nInput: 2 + 3 + 4 * 5\nResult: 25\nInput: 8 / 2 / 2\nResult: 2\nInput: 5 - 3 - 1\nResult: 1\nInput: 0 * 10 + 5\nResult: 5\nInput: 10 + 2 * 3 - 6 / 2\nResult: 13", "task_id": 6581, "assertions": "def test_evaluate_expression()\n  raise unless evaluate_expression(\"1 + 2 * 3\") == 7\n  raise unless evaluate_expression(\"4 * 5 - 6 / 2\") == 17\n  raise unless evaluate_expression(\"10 / 3 * 3\") == 9\n  raise unless evaluate_expression(\"2 + 3 + 4 * 5\") == 25\n  raise unless evaluate_expression(\"8 / 2 / 2\") == 2\n  raise unless evaluate_expression(\"5 - 3 - 1\") == 1\n  raise unless evaluate_expression(\"0 * 10 + 5\") == 5\n  raise unless evaluate_expression(\"10 + 2 * 3 - 6 / 2\") == 13\nend\n\ntest_evaluate_expression()", "all_code": "# evaluate_expression evaluates a properly formatted arithmetic expression containing non-negative\n# integers and the operators +, -, *, / separated by spaces.\n# Integer division truncates towards zero.\ndef evaluate_expression(expression)\n  tokens = expression.split\n  index = 0\n\n  # get_next_token retrieves the next token from the tokens array and increments the index.\n  get_next_token = lambda do\n    token = tokens[index]\n    index += 1\n    token\n  end\n\n  # parse_term parses a term in the expression, handling multiplication and division.\n  parse_term = lambda do\n    result = get_next_token.call.to_i\n    while index < tokens.size\n      operator = tokens[index]\n      break if ['+', '-'].include?(operator)\n      index += 1\n      next_value = get_next_token.call.to_i\n      if operator == '*'\n        result *= next_value\n      elsif operator == '/'\n        result = (result / next_value).to_i  # Truncate towards zero\n      end\n    end\n    result\n  end\n\n  # parse_expression parses the entire expression, handling addition and subtraction.\n  parse_expression = lambda do\n    result = parse_term.call\n    while index < tokens.size\n      operator = tokens[index]\n      break unless ['+', '-'].include?(operator)\n      index += 1\n      next_value = parse_term.call\n      if operator == '+'\n        result += next_value\n      elsif operator == '-'\n        result -= next_value\n      end\n    end\n    result\n  end\n\n  parse_expression.call\nend\ndef test_evaluate_expression()\n  raise unless evaluate_expression(\"1 + 2 * 3\") == 7\n  raise unless evaluate_expression(\"4 * 5 - 6 / 2\") == 17\n  raise unless evaluate_expression(\"10 / 3 * 3\") == 9\n  raise unless evaluate_expression(\"2 + 3 + 4 * 5\") == 25\n  raise unless evaluate_expression(\"8 / 2 / 2\") == 2\n  raise unless evaluate_expression(\"5 - 3 - 1\") == 1\n  raise unless evaluate_expression(\"0 * 10 + 5\") == 5\n  raise unless evaluate_expression(\"10 + 2 * 3 - 6 / 2\") == 13\nend\n\ntest_evaluate_expression()", "exec_outcome": "PASSED"}
{"code": "# Represents a user in the chat system with a username, password, and message inbox.\nclass User\n  attr_accessor :username, :password, :logged_in, :inbox, :offline_messages\n\n  def initialize(username, password)\n    @username = username\n    @password = password\n    @logged_in = false\n    @inbox = []\n    @offline_messages = []\n  end\nend\n\n# Manages user accounts and messaging in the chat system.\nclass ChatSystem\n  def initialize\n    @users = {}\n  end\n\n  # Creates a new user account with the given username and password.\n  # Returns a message indicating success or failure.\n  def create_account(username, password)\n    if @users.key?(username)\n      \"Username already exists\"\n    else\n      @users[username] = User.new(username, password)\n      \"Account created successfully\"\n    end\n  end\n\n  # Logs in a user with the given username and password.\n  # Delivers any pending offline messages upon successful login.\n  # Returns a message indicating success or failure.\n  def login(username, password)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    user = @users[username]\n    if user.password != password\n      return \"Incorrect password\"\n    end\n\n    user.logged_in = true\n    # Deliver offline messages\n    until user.offline_messages.empty?\n      sender, message = user.offline_messages.shift\n      user.inbox << [sender, message]\n    end\n    \"Logged in successfully\"\n  end\n\n  # Logs out a user with the given username.\n  # Returns a message indicating success or failure.\n  def logout(username)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    @users[username].logged_in = false\n    \"Logged out successfully\"\n  end\n\n  # Sends a message from one user to another.\n  # If the receiver is offline, the message is saved for later delivery.\n  # Returns a message indicating the delivery status.\n  def send_message(sender, receiver, message)\n    unless @users.key?(sender) && @users.key?(receiver)\n      return \"Invalid sender or receiver\"\n    end\n\n    unless @users[sender].logged_in\n      return \"Sender is not logged in\"\n    end\n\n    receiver_user = @users[receiver]\n    if receiver_user.logged_in\n      receiver_user.inbox << [sender, message]\n      \"Message delivered successfully\"\n    else\n      receiver_user.offline_messages << [sender, message]\n      \"Message saved for offline user\"\n    end\n  end\n\n  # Retrieves the inbox of a user with the given username.\n  # Returns the inbox or an error message if the user does not exist.\n  def get_inbox(username)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    @users[username].inbox\n  end\nend", "test_cases": "", "test_case_results": "Test Case 1: Create account 'user1'\nInput: username='user1', password='pass1'\nAccount created successfully\n\nTest Case 2: Create account 'user1' again (should fail)\nInput: username='user1', password='pass2'\nUsername already exists\n\nTest Case 3: Login 'user1' with correct password\nInput: username='user1', password='pass1'\nLogged in successfully\n\nTest Case 4: Login 'user1' with incorrect password\nInput: username='user1', password='wrongpass'\nIncorrect password\n\nTest Case 5: Login non-existent user 'user2'\nInput: username='user2', password='pass2'\nUsername does not exist\n\nTest Case 6: Send message from 'user1' to 'user2' (user2 does not exist)\nInput: sender='user1', receiver='user2', message='Hello'\nInvalid sender or receiver\n\nTest Case 7: Send message from 'user1' to 'user2' (user2 is offline)\nInput: sender='user1', receiver='user2', message='Hello'\nMessage saved for offline user\n\nTest Case 8: Login 'user2' (should receive offline message)\nInput: username='user2', password='pass2'\nLogged in successfully\nInbox af", "task_id": 19254, "assertions": "def test_chat_system()\n  # Initialize chat system\n  chat_system = ChatSystem.new\n\n  # Test account creation\n  raise \"Test Case 1 failed\" unless chat_system.create_account('user1', 'pass1') == \"Account created successfully\"\n  raise \"Test Case 2 failed\" unless chat_system.create_account('user1', 'pass2') == \"Username already exists\"\n\n  # Test login\n  raise \"Test Case 3 failed\" unless chat_system.login('user1', 'pass1') == \"Logged in successfully\"\n  raise \"Test Case 4 failed\" unless chat_system.login('user1', 'wrongpass') == \"Incorrect password\"\n  raise \"Test Case 5 failed\" unless chat_system.login('user2', 'pass2') == \"Username does not exist\"\n\n  # Test send message\n  raise \"Test Case 6 failed\" unless chat_system.send_message('user1', 'user2', 'Hello') == \"Invalid sender or receiver\"\n  \n  # Create user2 for further tests\n  chat_system.create_account('user2', 'pass2')\n  \n  raise \"Test Case 7 failed\" unless chat_system.send_message('user1', 'user2', 'Hello') == \"Message saved for offline user\"\n  \n  # Test login with offline message delivery\n  raise \"Test Case 8 failed\" unless chat_system.login('user2', 'pass2') == \"Logged in successfully\"\n  raise \"Test Case 8 inbox failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello']]\n  \n  # Test online message delivery\n  raise \"Test Case 9 failed\" unless chat_system.send_message('user1', 'user2', 'Hi again') == \"Message delivered successfully\"\n  raise \"Test Case 9 inbox failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello'], ['user1', 'Hi again']]\n  \n  # Test logout\n  raise \"Test Case 10 failed\" unless chat_system.logout('user1') == \"Logged out successfully\"\n  \n  # Test get inbox\n  raise \"Test Case 11 failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello'], ['user1', 'Hi again']]\nend\n\ntest_chat_system()", "all_code": "# Represents a user in the chat system with a username, password, and message inbox.\nclass User\n  attr_accessor :username, :password, :logged_in, :inbox, :offline_messages\n\n  def initialize(username, password)\n    @username = username\n    @password = password\n    @logged_in = false\n    @inbox = []\n    @offline_messages = []\n  end\nend\n\n# Manages user accounts and messaging in the chat system.\nclass ChatSystem\n  def initialize\n    @users = {}\n  end\n\n  # Creates a new user account with the given username and password.\n  # Returns a message indicating success or failure.\n  def create_account(username, password)\n    if @users.key?(username)\n      \"Username already exists\"\n    else\n      @users[username] = User.new(username, password)\n      \"Account created successfully\"\n    end\n  end\n\n  # Logs in a user with the given username and password.\n  # Delivers any pending offline messages upon successful login.\n  # Returns a message indicating success or failure.\n  def login(username, password)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    user = @users[username]\n    if user.password != password\n      return \"Incorrect password\"\n    end\n\n    user.logged_in = true\n    # Deliver offline messages\n    until user.offline_messages.empty?\n      sender, message = user.offline_messages.shift\n      user.inbox << [sender, message]\n    end\n    \"Logged in successfully\"\n  end\n\n  # Logs out a user with the given username.\n  # Returns a message indicating success or failure.\n  def logout(username)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    @users[username].logged_in = false\n    \"Logged out successfully\"\n  end\n\n  # Sends a message from one user to another.\n  # If the receiver is offline, the message is saved for later delivery.\n  # Returns a message indicating the delivery status.\n  def send_message(sender, receiver, message)\n    unless @users.key?(sender) && @users.key?(receiver)\n      return \"Invalid sender or receiver\"\n    end\n\n    unless @users[sender].logged_in\n      return \"Sender is not logged in\"\n    end\n\n    receiver_user = @users[receiver]\n    if receiver_user.logged_in\n      receiver_user.inbox << [sender, message]\n      \"Message delivered successfully\"\n    else\n      receiver_user.offline_messages << [sender, message]\n      \"Message saved for offline user\"\n    end\n  end\n\n  # Retrieves the inbox of a user with the given username.\n  # Returns the inbox or an error message if the user does not exist.\n  def get_inbox(username)\n    unless @users.key?(username)\n      return \"Username does not exist\"\n    end\n\n    @users[username].inbox\n  end\nend\ndef test_chat_system()\n  # Initialize chat system\n  chat_system = ChatSystem.new\n\n  # Test account creation\n  raise \"Test Case 1 failed\" unless chat_system.create_account('user1', 'pass1') == \"Account created successfully\"\n  raise \"Test Case 2 failed\" unless chat_system.create_account('user1', 'pass2') == \"Username already exists\"\n\n  # Test login\n  raise \"Test Case 3 failed\" unless chat_system.login('user1', 'pass1') == \"Logged in successfully\"\n  raise \"Test Case 4 failed\" unless chat_system.login('user1', 'wrongpass') == \"Incorrect password\"\n  raise \"Test Case 5 failed\" unless chat_system.login('user2', 'pass2') == \"Username does not exist\"\n\n  # Test send message\n  raise \"Test Case 6 failed\" unless chat_system.send_message('user1', 'user2', 'Hello') == \"Invalid sender or receiver\"\n  \n  # Create user2 for further tests\n  chat_system.create_account('user2', 'pass2')\n  \n  raise \"Test Case 7 failed\" unless chat_system.send_message('user1', 'user2', 'Hello') == \"Message saved for offline user\"\n  \n  # Test login with offline message delivery\n  raise \"Test Case 8 failed\" unless chat_system.login('user2', 'pass2') == \"Logged in successfully\"\n  raise \"Test Case 8 inbox failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello']]\n  \n  # Test online message delivery\n  raise \"Test Case 9 failed\" unless chat_system.send_message('user1', 'user2', 'Hi again') == \"Message delivered successfully\"\n  raise \"Test Case 9 inbox failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello'], ['user1', 'Hi again']]\n  \n  # Test logout\n  raise \"Test Case 10 failed\" unless chat_system.logout('user1') == \"Logged out successfully\"\n  \n  # Test get inbox\n  raise \"Test Case 11 failed\" unless chat_system.get_inbox('user2') == [['user1', 'Hello'], ['user1', 'Hi again']]\nend\n\ntest_chat_system()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef minimum_moves(matrix, n, m)\n  # Check if the start or end position is blocked\n  return -1 if matrix[0][0] == 1 || matrix[n - 1][m - 1] == 1\n\n  # Define possible movement directions: up, down, left, right\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n  # Initialize a queue for BFS, starting at (0, 0) with 0 distance\n  queue = [[0, 0, 0]]\n  visited = Set.new\n  visited.add([0, 0])\n\n  while !queue.empty?\n    row, col, dist = queue.shift\n\n    # Check if the current position is the destination\n    return dist if row == n - 1 && col == m - 1\n\n    # Explore all four possible directions\n    directions.each do |dr, dc|\n      new_row = row + dr\n      new_col = col + dc\n\n      # Check if the new position is within bounds, passable, and not visited\n      if new_row.between?(0, n - 1) && new_col.between?(0, m - 1) &&\n         matrix[new_row][new_col] == 0 && !visited.include?([new_row, new_col])\n        visited.add([new_row, new_col])\n        queue.push([new_row, new_col, dist + 1])\n      end\n    end\n  end\n\n  # Return -1 if no path was found\n  -1\nend", "test_cases": "", "test_case_results": "Input matrix: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nMinimum moves: 4\nInput matrix: [[0, 0, 0], [0, 1, 1], [0, 0, 0]]\nMinimum moves: 4\nInput matrix: [[0, 1, 0], [0, 1, 0], [0, 1, 0]]\nMinimum moves: -1\nInput matrix: [[0, 0], [0, 0]]\nMinimum moves: 2", "task_id": 18280, "assertions": "require 'set'\n\ndef test_minimum_moves()\n  test_cases = [\n    {\n      matrix: [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: 4\n    },\n    {\n      matrix: [\n        [0, 0, 0],\n        [0, 1, 1],\n        [0, 0, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: 4\n    },\n    {\n      matrix: [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: -1\n    },\n    {\n      matrix: [\n        [0, 0],\n        [0, 0]\n      ],\n      n: 2,\n      m: 2,\n      expected: 2\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = minimum_moves(test_case[:matrix], test_case[:n], test_case[:m])\n    raise \"Test failed for matrix #{test_case[:matrix]}. Expected #{test_case[:expected]}, got #{result}\" unless result == test_case[:expected]\n  end\nend\n\ntest_minimum_moves()", "all_code": "require 'set'\n\ndef minimum_moves(matrix, n, m)\n  # Check if the start or end position is blocked\n  return -1 if matrix[0][0] == 1 || matrix[n - 1][m - 1] == 1\n\n  # Define possible movement directions: up, down, left, right\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n\n  # Initialize a queue for BFS, starting at (0, 0) with 0 distance\n  queue = [[0, 0, 0]]\n  visited = Set.new\n  visited.add([0, 0])\n\n  while !queue.empty?\n    row, col, dist = queue.shift\n\n    # Check if the current position is the destination\n    return dist if row == n - 1 && col == m - 1\n\n    # Explore all four possible directions\n    directions.each do |dr, dc|\n      new_row = row + dr\n      new_col = col + dc\n\n      # Check if the new position is within bounds, passable, and not visited\n      if new_row.between?(0, n - 1) && new_col.between?(0, m - 1) &&\n         matrix[new_row][new_col] == 0 && !visited.include?([new_row, new_col])\n        visited.add([new_row, new_col])\n        queue.push([new_row, new_col, dist + 1])\n      end\n    end\n  end\n\n  # Return -1 if no path was found\n  -1\nend\nrequire 'set'\n\ndef test_minimum_moves()\n  test_cases = [\n    {\n      matrix: [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: 4\n    },\n    {\n      matrix: [\n        [0, 0, 0],\n        [0, 1, 1],\n        [0, 0, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: 4\n    },\n    {\n      matrix: [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 0]\n      ],\n      n: 3,\n      m: 3,\n      expected: -1\n    },\n    {\n      matrix: [\n        [0, 0],\n        [0, 0]\n      ],\n      n: 2,\n      m: 2,\n      expected: 2\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = minimum_moves(test_case[:matrix], test_case[:n], test_case[:m])\n    raise \"Test failed for matrix #{test_case[:matrix]}. Expected #{test_case[:expected]}, got #{result}\" unless result == test_case[:expected]\n  end\nend\n\ntest_minimum_moves()", "exec_outcome": "PASSED"}
{"code": "# next_greater_binary finds the next greater binary number in lexicographical order.\n# If the given binary number is the maximum possible for its length (all '1's),\n# it returns the smallest binary number of the same length (all '0's).\n#\n# @param binary [String] the input binary string\n# @return [String] the next greater binary string or '0's if input is all '1's\ndef next_greater_binary(binary)\n  n = binary.length\n  return '0' * n if binary == '1' * n\n\n  # Convert the binary string to an array of characters for manipulation\n  binary_list = binary.chars\n\n  # Find the right-most '0' and set it to '1'\n  i = n - 1\n  while i >= 0\n    if binary_list[i] == '0'\n      binary_list[i] = '1'\n      break\n    end\n    i -= 1\n  end\n\n  # Set all bits to the right of the changed bit to '0'\n  (i + 1...n).each do |j|\n    binary_list[j] = '0'\n  end\n\n  binary_list.join\nend", "test_cases": "", "test_case_results": "Input: 0\nNext Greater Binary: 1\nInput: 1\nNext Greater Binary: 0\nInput: 000\nNext Greater Binary: 001\nInput: 001\nNext Greater Binary: 010\nInput: 010\nNext Greater Binary: 011\nInput: 011\nNext Greater Binary: 100\nInput: 100\nNext Greater Binary: 101\nInput: 101\nNext Greater Binary: 110\nInput: 110\nNext Greater Binary: 111\nInput: 111\nNext Greater Binary: 000\nInput: 1001\nNext Greater Binary: 1010\nInput: 1010\nNext Greater Binary: 1011\nInput: 1111\nNext Greater Binary: 0000", "task_id": 27170, "assertions": "def test_next_greater_binary()\n  raise unless next_greater_binary('0') == '1'\n  raise unless next_greater_binary('1') == '0'\n  raise unless next_greater_binary('000') == '001'\n  raise unless next_greater_binary('001') == '010'\n  raise unless next_greater_binary('010') == '011'\n  raise unless next_greater_binary('011') == '100'\n  raise unless next_greater_binary('100') == '101'\n  raise unless next_greater_binary('101') == '110'\n  raise unless next_greater_binary('110') == '111'\n  raise unless next_greater_binary('111') == '000'\n  raise unless next_greater_binary('1001') == '1010'\n  raise unless next_greater_binary('1010') == '1011'\n  raise unless next_greater_binary('1111') == '0000'\nend\n\ntest_next_greater_binary()", "all_code": "# next_greater_binary finds the next greater binary number in lexicographical order.\n# If the given binary number is the maximum possible for its length (all '1's),\n# it returns the smallest binary number of the same length (all '0's).\n#\n# @param binary [String] the input binary string\n# @return [String] the next greater binary string or '0's if input is all '1's\ndef next_greater_binary(binary)\n  n = binary.length\n  return '0' * n if binary == '1' * n\n\n  # Convert the binary string to an array of characters for manipulation\n  binary_list = binary.chars\n\n  # Find the right-most '0' and set it to '1'\n  i = n - 1\n  while i >= 0\n    if binary_list[i] == '0'\n      binary_list[i] = '1'\n      break\n    end\n    i -= 1\n  end\n\n  # Set all bits to the right of the changed bit to '0'\n  (i + 1...n).each do |j|\n    binary_list[j] = '0'\n  end\n\n  binary_list.join\nend\ndef test_next_greater_binary()\n  raise unless next_greater_binary('0') == '1'\n  raise unless next_greater_binary('1') == '0'\n  raise unless next_greater_binary('000') == '001'\n  raise unless next_greater_binary('001') == '010'\n  raise unless next_greater_binary('010') == '011'\n  raise unless next_greater_binary('011') == '100'\n  raise unless next_greater_binary('100') == '101'\n  raise unless next_greater_binary('101') == '110'\n  raise unless next_greater_binary('110') == '111'\n  raise unless next_greater_binary('111') == '000'\n  raise unless next_greater_binary('1001') == '1010'\n  raise unless next_greater_binary('1010') == '1011'\n  raise unless next_greater_binary('1111') == '0000'\nend\n\ntest_next_greater_binary()", "exec_outcome": "PASSED"}
{"code": "def common_char_count(str1, str2)\n  # Count the frequency of each character in the first string\n  counter1 = Hash.new(0)\n  str1.each_char { |char| counter1[char] += 1 }\n\n  # Count the frequency of each character in the second string\n  counter2 = Hash.new(0)\n  str2.each_char { |char| counter2[char] += 1 }\n\n  # Calculate the common characters considering their multiplicity\n  common_count = 0\n  counter1.each do |char, count1|\n    if counter2.key?(char)\n      common_count += [count1, counter2[char]].min\n    end\n  end\n\n  common_count\nend", "test_cases": "", "test_case_results": "Input: str1 = 'aabcc', str2 = 'adcaa'\nCommon character count: 3\nInput: str1 = 'hello', str2 = 'world'\nCommon character count: 2\nInput: str1 = '', str2 = ''\nCommon character count: 0\nInput: str1 = 'abc', str2 = 'def'\nCommon character count: 0\nInput: str1 = 'aabbcc', str2 = 'abcabc'\nCommon character count: 6", "task_id": 10420, "assertions": "def test_common_char_count()\n  raise unless common_char_count(\"aabcc\", \"adcaa\") == 3\n  raise unless common_char_count(\"hello\", \"world\") == 2\n  raise unless common_char_count(\"\", \"\") == 0\n  raise unless common_char_count(\"abc\", \"def\") == 0\n  raise unless common_char_count(\"aabbcc\", \"abcabc\") == 6\nend\n\ntest_common_char_count()", "all_code": "def common_char_count(str1, str2)\n  # Count the frequency of each character in the first string\n  counter1 = Hash.new(0)\n  str1.each_char { |char| counter1[char] += 1 }\n\n  # Count the frequency of each character in the second string\n  counter2 = Hash.new(0)\n  str2.each_char { |char| counter2[char] += 1 }\n\n  # Calculate the common characters considering their multiplicity\n  common_count = 0\n  counter1.each do |char, count1|\n    if counter2.key?(char)\n      common_count += [count1, counter2[char]].min\n    end\n  end\n\n  common_count\nend\ndef test_common_char_count()\n  raise unless common_char_count(\"aabcc\", \"adcaa\") == 3\n  raise unless common_char_count(\"hello\", \"world\") == 2\n  raise unless common_char_count(\"\", \"\") == 0\n  raise unless common_char_count(\"abc\", \"def\") == 0\n  raise unless common_char_count(\"aabbcc\", \"abcabc\") == 6\nend\n\ntest_common_char_count()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef split_unique_substrings(s)\n  substrings = []\n  current_substr = \"\"\n  char_set = Set.new\n\n  s.each_char do |char|\n    if char_set.include?(char)\n      # Start a new substring\n      substrings << current_substr\n      current_substr = char\n      char_set = Set.new([char])\n    else\n      current_substr += char\n      char_set.add(char)\n    end\n  end\n\n  # Add the last substring if it's not empty\n  substrings << current_substr unless current_substr.empty?\n\n  [substrings.size, substrings]\nend", "test_cases": "", "test_case_results": "Input: \"abcabc\"\nNumber of substrings: 2\nSubstrings: [\"abc\", \"abc\"]\n\nInput: \"abac\"\nNumber of substrings: 2\nSubstrings: [\"ab\", \"ac\"]\n\nInput: \"abcd\"\nNumber of substrings: 1\nSubstrings: [\"abcd\"]\n\nInput: \"aabbcc\"\nNumber of substrings: 4\nSubstrings: [\"a\", \"ab\", \"bc\", \"c\"]\n\nInput: \"aaabbbccc\"\nNumber of substrings: 7\nSubstrings: [\"a\", \"a\", \"ab\", \"b\", \"bc\", \"c\", \"c\"]", "task_id": 15224, "assertions": "require 'set'\n\ndef test_split_unique_substrings()\n  # Test case 1\n  count, substrings = split_unique_substrings(\"abcabc\")\n  raise \"Test case 1 failed\" unless count == 2 && substrings == [\"abc\", \"abc\"]\n\n  # Test case 2\n  count, substrings = split_unique_substrings(\"abac\")\n  raise \"Test case 2 failed\" unless count == 2 && substrings == [\"ab\", \"ac\"]\n\n  # Test case 3\n  count, substrings = split_unique_substrings(\"abcd\")\n  raise \"Test case 3 failed\" unless count == 1 && substrings == [\"abcd\"]\n\n  # Test case 4\n  count, substrings = split_unique_substrings(\"aabbcc\")\n  raise \"Test case 4 failed\" unless count == 4 && substrings == [\"a\", \"ab\", \"bc\", \"c\"]\n\n  # Test case 5\n  count, substrings = split_unique_substrings(\"aaabbbccc\")\n  raise \"Test case 5 failed\" unless count == 7 && substrings == [\"a\", \"a\", \"ab\", \"b\", \"bc\", \"c\", \"c\"]\nend\n\ntest_split_unique_substrings()", "all_code": "require 'set'\n\ndef split_unique_substrings(s)\n  substrings = []\n  current_substr = \"\"\n  char_set = Set.new\n\n  s.each_char do |char|\n    if char_set.include?(char)\n      # Start a new substring\n      substrings << current_substr\n      current_substr = char\n      char_set = Set.new([char])\n    else\n      current_substr += char\n      char_set.add(char)\n    end\n  end\n\n  # Add the last substring if it's not empty\n  substrings << current_substr unless current_substr.empty?\n\n  [substrings.size, substrings]\nend\nrequire 'set'\n\ndef test_split_unique_substrings()\n  # Test case 1\n  count, substrings = split_unique_substrings(\"abcabc\")\n  raise \"Test case 1 failed\" unless count == 2 && substrings == [\"abc\", \"abc\"]\n\n  # Test case 2\n  count, substrings = split_unique_substrings(\"abac\")\n  raise \"Test case 2 failed\" unless count == 2 && substrings == [\"ab\", \"ac\"]\n\n  # Test case 3\n  count, substrings = split_unique_substrings(\"abcd\")\n  raise \"Test case 3 failed\" unless count == 1 && substrings == [\"abcd\"]\n\n  # Test case 4\n  count, substrings = split_unique_substrings(\"aabbcc\")\n  raise \"Test case 4 failed\" unless count == 4 && substrings == [\"a\", \"ab\", \"bc\", \"c\"]\n\n  # Test case 5\n  count, substrings = split_unique_substrings(\"aaabbbccc\")\n  raise \"Test case 5 failed\" unless count == 7 && substrings == [\"a\", \"a\", \"ab\", \"b\", \"bc\", \"c\", \"c\"]\nend\n\ntest_split_unique_substrings()", "exec_outcome": "PASSED"}
{"code": "# calculate_final_prices computes the final prices of products after applying discounts.\n# It takes an integer N (number of products) and an array of product details (price and discount percentage).\n# For each product, it calculates the final price by subtracting the discount amount from the original price.\n# The discount amount is calculated as (price * discount / 100).\n# Returns an array of final prices.\ndef calculate_final_prices(product_details)\n  product_details.map { |price, discount| price - (price * discount / 100.0) }\nend", "test_cases": "", "test_case_results": "Test Case: Three products with varying discounts\nInput Product Details: [[100, 10], [200, 20], [300, 30]]\nFinal Prices: [90.0, 160.0, 210.0]\n\nTest Case: Products with zero and small discounts\nInput Product Details: [[50, 0], [75, 5], [125, 10]]\nFinal Prices: [50.0, 71.25, 112.5]\n\nTest Case: High-value products with significant discounts\nInput Product Details: [[1000, 50], [2000, 25]]\nFinal Prices: [500.0, 1500.0]\n\nTest Case: Single product with 100% discount (free)\nInput Product Details: [[10, 100]]\nFinal Prices: [0.0]", "task_id": 27816, "assertions": "def test_calculate_final_prices()\n  # Test case 1: Three products with varying discounts\n  result1 = calculate_final_prices([[100, 10], [200, 20], [300, 30]])\n  raise \"Test Case 1 Failed\" unless result1 == [90.0, 160.0, 210.0]\n\n  # Test case 2: Products with zero and small discounts\n  result2 = calculate_final_prices([[50, 0], [75, 5], [125, 10]])\n  raise \"Test Case 2 Failed\" unless result2 == [50.0, 71.25, 112.5]\n\n  # Test case 3: High-value products with significant discounts\n  result3 = calculate_final_prices([[1000, 50], [2000, 25]])\n  raise \"Test Case 3 Failed\" unless result3 == [500.0, 1500.0]\n\n  # Test case 4: Single product with 100% discount (free)\n  result4 = calculate_final_prices([[10, 100]])\n  raise \"Test Case 4 Failed\" unless result4 == [0.0]\nend\n\ntest_calculate_final_prices()", "all_code": "# calculate_final_prices computes the final prices of products after applying discounts.\n# It takes an integer N (number of products) and an array of product details (price and discount percentage).\n# For each product, it calculates the final price by subtracting the discount amount from the original price.\n# The discount amount is calculated as (price * discount / 100).\n# Returns an array of final prices.\ndef calculate_final_prices(product_details)\n  product_details.map { |price, discount| price - (price * discount / 100.0) }\nend\ndef test_calculate_final_prices()\n  # Test case 1: Three products with varying discounts\n  result1 = calculate_final_prices([[100, 10], [200, 20], [300, 30]])\n  raise \"Test Case 1 Failed\" unless result1 == [90.0, 160.0, 210.0]\n\n  # Test case 2: Products with zero and small discounts\n  result2 = calculate_final_prices([[50, 0], [75, 5], [125, 10]])\n  raise \"Test Case 2 Failed\" unless result2 == [50.0, 71.25, 112.5]\n\n  # Test case 3: High-value products with significant discounts\n  result3 = calculate_final_prices([[1000, 50], [2000, 25]])\n  raise \"Test Case 3 Failed\" unless result3 == [500.0, 1500.0]\n\n  # Test case 4: Single product with 100% discount (free)\n  result4 = calculate_final_prices([[10, 100]])\n  raise \"Test Case 4 Failed\" unless result4 == [0.0]\nend\n\ntest_calculate_final_prices()", "exec_outcome": "PASSED"}
{"code": "# longest_prefix_suffix calculates the length of the longest proper prefix of a string\n# that is also a suffix. A proper prefix is a prefix that is not equal to the string itself.\n# The method uses the Knuth-Morris-Pratt (KMP) algorithm's preprocessing step to compute\n# the longest prefix suffix (LPS) array for the string.\n#\n# @param s [String] the input string\n# @return [Integer] the length of the longest proper prefix that is also a suffix\ndef longest_prefix_suffix(s)\n  n = s.length\n  return 0 if n == 0\n\n  lps = Array.new(n, 0)  # Initialize LPS array with zeros\n  length = 0  # Length of the previous longest prefix suffix\n  i = 1\n\n  # Loop through the string to fill the LPS array\n  while i < n\n    if s[i] == s[length]\n      length += 1\n      lps[i] = length\n      i += 1\n    else\n      if length != 0\n        length = lps[length - 1]\n      else\n        lps[i] = 0\n        i += 1\n      end\n    end\n  end\n\n  # The last element of LPS array gives the length of the longest proper prefix suffix\n  n > 1 ? lps[-1] : 0\nend", "test_cases": "", "test_case_results": "Input: 'aabcdaabc'\nLength of longest proper prefix suffix: 4\nInput: 'aaaa'\nLength of longest proper prefix suffix: 3\nInput: 'abab'\nLength of longest proper prefix suffix: 2\nInput: 'abc'\nLength of longest proper prefix suffix: 0\nInput: ''\nLength of longest proper prefix suffix: 0\nInput: 'a'\nLength of longest proper prefix suffix: 0", "task_id": 29288, "assertions": "def test_longest_prefix_suffix()\n  raise unless longest_prefix_suffix(\"aabcdaabc\") == 4\n  raise unless longest_prefix_suffix(\"aaaa\") == 3\n  raise unless longest_prefix_suffix(\"abab\") == 2\n  raise unless longest_prefix_suffix(\"abc\") == 0\n  raise unless longest_prefix_suffix(\"\") == 0\n  raise unless longest_prefix_suffix(\"a\") == 0\nend\n\ntest_longest_prefix_suffix()", "all_code": "# longest_prefix_suffix calculates the length of the longest proper prefix of a string\n# that is also a suffix. A proper prefix is a prefix that is not equal to the string itself.\n# The method uses the Knuth-Morris-Pratt (KMP) algorithm's preprocessing step to compute\n# the longest prefix suffix (LPS) array for the string.\n#\n# @param s [String] the input string\n# @return [Integer] the length of the longest proper prefix that is also a suffix\ndef longest_prefix_suffix(s)\n  n = s.length\n  return 0 if n == 0\n\n  lps = Array.new(n, 0)  # Initialize LPS array with zeros\n  length = 0  # Length of the previous longest prefix suffix\n  i = 1\n\n  # Loop through the string to fill the LPS array\n  while i < n\n    if s[i] == s[length]\n      length += 1\n      lps[i] = length\n      i += 1\n    else\n      if length != 0\n        length = lps[length - 1]\n      else\n        lps[i] = 0\n        i += 1\n      end\n    end\n  end\n\n  # The last element of LPS array gives the length of the longest proper prefix suffix\n  n > 1 ? lps[-1] : 0\nend\ndef test_longest_prefix_suffix()\n  raise unless longest_prefix_suffix(\"aabcdaabc\") == 4\n  raise unless longest_prefix_suffix(\"aaaa\") == 3\n  raise unless longest_prefix_suffix(\"abab\") == 2\n  raise unless longest_prefix_suffix(\"abc\") == 0\n  raise unless longest_prefix_suffix(\"\") == 0\n  raise unless longest_prefix_suffix(\"a\") == 0\nend\n\ntest_longest_prefix_suffix()", "exec_outcome": "PASSED"}
{"code": "class MinStack\n  def initialize\n    @stack = []\n    @min_stack = []\n  end\n\n  def push(x)\n    @stack.push(x)\n    if @min_stack.empty? || x <= @min_stack.last\n      @min_stack.push(x)\n    end\n  end\n\n  def pop\n    if @stack.any?\n      if @stack.last == @min_stack.last\n        @min_stack.pop\n      end\n      @stack.pop\n    end\n  end\n\n  def top\n    if @stack.any?\n      @stack.last\n    else\n      raise \"top from empty stack\"\n    end\n  end\n\n  def get_min\n    if @min_stack.any?\n      @min_stack.last\n    else\n      raise \"get_min from empty stack\"\n    end\n  end\nend", "test_cases": "", "test_case_results": "Test case 1: Push 3, 5, 2, 1\nAfter push 3: top=3, min=3\nAfter push 5: top=5, min=3\nAfter push 2: top=2, min=2\nAfter push 1: top=1, min=1\n\nTest case 2: Pop elements\nAfter pop: top=2, min=2\nAfter pop: top=5, min=3\nAfter pop: top=3, min=3\n\nTest case 3: Push 0, 4\nAfter push 0: top=0, min=0\nAfter push 4: top=4, min=0\n\nTest case 4: Pop elements\nAfter pop: top=0, min=0\nAfter pop: top=3, min=3\n\nTest case 5: Attempt to get top or min from empty stack", "task_id": 26145, "assertions": "def test_min_stack\n  stack = MinStack.new\n\n  # Test case 1: Push elements and check min\n  stack.push(3)\n  raise \"Test case 1 failed: top\" unless stack.top == 3\n  raise \"Test case 1 failed: min\" unless stack.get_min == 3\n\n  stack.push(5)\n  raise \"Test case 1 failed: top\" unless stack.top == 5\n  raise \"Test case 1 failed: min\" unless stack.get_min == 3\n\n  stack.push(2)\n  raise \"Test case 1 failed: top\" unless stack.top == 2\n  raise \"Test case 1 failed: min\" unless stack.get_min == 2\n\n  stack.push(1)\n  raise \"Test case 1 failed: top\" unless stack.top == 1\n  raise \"Test case 1 failed: min\" unless stack.get_min == 1\n\n  # Test case 2: Pop elements and check min\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 2\n  raise \"Test case 2 failed: min\" unless stack.get_min == 2\n\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 5\n  raise \"Test case 2 failed: min\" unless stack.get_min == 3\n\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 3\n  raise \"Test case 2 failed: min\" unless stack.get_min == 3\n\n  # Test case 3: Push elements again and check min\n  stack.push(0)\n  raise \"Test case 3 failed: top\" unless stack.top == 0\n  raise \"Test case 3 failed: min\" unless stack.get_min == 0\n\n  stack.push(4)\n  raise \"Test case 3 failed: top\" unless stack.top == 4\n  raise \"Test case 3 failed: min\" unless stack.get_min == 0\n\n  # Test case 4: Pop elements and check min\n  stack.pop\n  raise \"Test case 4 failed: top\" unless stack.top == 0\n  raise \"Test case 4 failed: min\" unless stack.get_min == 0\n\n  stack.pop\n  raise \"Test case 4 failed: top\" unless stack.top == 3\n  raise \"Test case 4 failed: min\" unless stack.get_min == 3\n\n  # Test case 5: Attempt to get top or min from empty stack\n  stack.pop\n  begin\n    stack.top\n    raise \"Test case 5 failed: top should raise error\"\n  rescue => e\n    raise \"Test case 5 failed: wrong error message for top\" unless e.message == \"top from empty stack\"\n  end\n\n  begin\n    stack.get_min\n    raise \"Test case 5 failed: get_min should raise error\"\n  rescue => e\n    raise \"Test case 5 failed: wrong error message for get_min\" unless e.message == \"get_min from empty stack\"\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_min_stack", "all_code": "class MinStack\n  def initialize\n    @stack = []\n    @min_stack = []\n  end\n\n  def push(x)\n    @stack.push(x)\n    if @min_stack.empty? || x <= @min_stack.last\n      @min_stack.push(x)\n    end\n  end\n\n  def pop\n    if @stack.any?\n      if @stack.last == @min_stack.last\n        @min_stack.pop\n      end\n      @stack.pop\n    end\n  end\n\n  def top\n    if @stack.any?\n      @stack.last\n    else\n      raise \"top from empty stack\"\n    end\n  end\n\n  def get_min\n    if @min_stack.any?\n      @min_stack.last\n    else\n      raise \"get_min from empty stack\"\n    end\n  end\nend\ndef test_min_stack\n  stack = MinStack.new\n\n  # Test case 1: Push elements and check min\n  stack.push(3)\n  raise \"Test case 1 failed: top\" unless stack.top == 3\n  raise \"Test case 1 failed: min\" unless stack.get_min == 3\n\n  stack.push(5)\n  raise \"Test case 1 failed: top\" unless stack.top == 5\n  raise \"Test case 1 failed: min\" unless stack.get_min == 3\n\n  stack.push(2)\n  raise \"Test case 1 failed: top\" unless stack.top == 2\n  raise \"Test case 1 failed: min\" unless stack.get_min == 2\n\n  stack.push(1)\n  raise \"Test case 1 failed: top\" unless stack.top == 1\n  raise \"Test case 1 failed: min\" unless stack.get_min == 1\n\n  # Test case 2: Pop elements and check min\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 2\n  raise \"Test case 2 failed: min\" unless stack.get_min == 2\n\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 5\n  raise \"Test case 2 failed: min\" unless stack.get_min == 3\n\n  stack.pop\n  raise \"Test case 2 failed: top\" unless stack.top == 3\n  raise \"Test case 2 failed: min\" unless stack.get_min == 3\n\n  # Test case 3: Push elements again and check min\n  stack.push(0)\n  raise \"Test case 3 failed: top\" unless stack.top == 0\n  raise \"Test case 3 failed: min\" unless stack.get_min == 0\n\n  stack.push(4)\n  raise \"Test case 3 failed: top\" unless stack.top == 4\n  raise \"Test case 3 failed: min\" unless stack.get_min == 0\n\n  # Test case 4: Pop elements and check min\n  stack.pop\n  raise \"Test case 4 failed: top\" unless stack.top == 0\n  raise \"Test case 4 failed: min\" unless stack.get_min == 0\n\n  stack.pop\n  raise \"Test case 4 failed: top\" unless stack.top == 3\n  raise \"Test case 4 failed: min\" unless stack.get_min == 3\n\n  # Test case 5: Attempt to get top or min from empty stack\n  stack.pop\n  begin\n    stack.top\n    raise \"Test case 5 failed: top should raise error\"\n  rescue => e\n    raise \"Test case 5 failed: wrong error message for top\" unless e.message == \"top from empty stack\"\n  end\n\n  begin\n    stack.get_min\n    raise \"Test case 5 failed: get_min should raise error\"\n  rescue => e\n    raise \"Test case 5 failed: wrong error message for get_min\" unless e.message == \"get_min from empty stack\"\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_min_stack", "exec_outcome": "PASSED"}
{"code": "# Require necessary standard libraries\nrequire 'set'\n\n# count_distinct_repeated_letters counts the distinct letters that appear more than once in the string.\n# It normalizes the string to lowercase for case-insensitive comparison, counts occurrences of each character,\n# and filters to find characters that appear more than once.\n#\n# @param s [String] the input string\n# @return [Integer] the count of distinct letters that appear more than once\ndef count_distinct_repeated_letters(s)\n  # Normalize to lowercase for case-insensitive comparison\n  normalized = s.downcase\n\n  # Count occurrences of each character\n  counter = Hash.new(0)\n  normalized.each_char { |char| counter[char] += 1 }\n\n  # Filter to find characters that appear more than once\n  repeated_characters = counter.select { |char, count| count > 1 }.keys\n\n  repeated_characters.size\nend", "test_cases": "", "test_case_results": "Input: \"abcde\"\nDistinct repeated letters: 0\nInput: \"aabbc\"\nDistinct repeated letters: 2\nInput: \"AaBbCc\"\nDistinct repeated letters: 3\nInput: \"hello world\"\nDistinct repeated letters: 2\nInput: \"123!!!\"\nDistinct repeated letters: 1", "task_id": 12485, "assertions": "def test_count_distinct_repeated_letters()\n  raise \"Test case 1 failed\" unless count_distinct_repeated_letters(\"abcde\") == 0\n  raise \"Test case 2 failed\" unless count_distinct_repeated_letters(\"aabbc\") == 2\n  raise \"Test case 3 failed\" unless count_distinct_repeated_letters(\"AaBbCc\") == 3\n  raise \"Test case 4 failed\" unless count_distinct_repeated_letters(\"hello world\") == 2\n  raise \"Test case 5 failed\" unless count_distinct_repeated_letters(\"123!!!\") == 1\n  puts \"All test cases passed!\"\nend\n\ntest_count_distinct_repeated_letters()", "all_code": "# Require necessary standard libraries\nrequire 'set'\n\n# count_distinct_repeated_letters counts the distinct letters that appear more than once in the string.\n# It normalizes the string to lowercase for case-insensitive comparison, counts occurrences of each character,\n# and filters to find characters that appear more than once.\n#\n# @param s [String] the input string\n# @return [Integer] the count of distinct letters that appear more than once\ndef count_distinct_repeated_letters(s)\n  # Normalize to lowercase for case-insensitive comparison\n  normalized = s.downcase\n\n  # Count occurrences of each character\n  counter = Hash.new(0)\n  normalized.each_char { |char| counter[char] += 1 }\n\n  # Filter to find characters that appear more than once\n  repeated_characters = counter.select { |char, count| count > 1 }.keys\n\n  repeated_characters.size\nend\ndef test_count_distinct_repeated_letters()\n  raise \"Test case 1 failed\" unless count_distinct_repeated_letters(\"abcde\") == 0\n  raise \"Test case 2 failed\" unless count_distinct_repeated_letters(\"aabbc\") == 2\n  raise \"Test case 3 failed\" unless count_distinct_repeated_letters(\"AaBbCc\") == 3\n  raise \"Test case 4 failed\" unless count_distinct_repeated_letters(\"hello world\") == 2\n  raise \"Test case 5 failed\" unless count_distinct_repeated_letters(\"123!!!\") == 1\n  puts \"All test cases passed!\"\nend\n\ntest_count_distinct_repeated_letters()", "exec_outcome": "PASSED"}
{"code": "# smallest_integer_with_sum returns the smallest integer x such that the sum of the digits of x equals S.\n# The method constructs the number by placing the largest possible digits (9) from the least significant digit to the most significant digit.\n# If S is 0, it returns 0 since the smallest number with digit sum 0 is 0.\ndef smallest_integer_with_sum(s)\n  return 0 if s == 0\n  result = \"\"\n  while s > 0\n    digit = [s, 9].min\n    result = digit.to_s + result\n    s -= digit\n  end\n  result.to_i\nend\n\n# process_test_cases processes an array of test cases and returns an array of results.\n# Each test case is processed by smallest_integer_with_sum to find the smallest integer with the digit sum equal to the test case value.\ndef process_test_cases(test_cases)\n  test_cases.map { |s| smallest_integer_with_sum(s) }\nend", "test_cases": "", "test_case_results": "Input: 0\nSmallest Integer: 0\nInput: 1\nSmallest Integer: 1\nInput: 9\nSmallest Integer: 9\nInput: 10\nSmallest Integer: 19\nInput: 19\nSmallest Integer: 199\nInput: 20\nSmallest Integer: 299\nInput: 45\nSmallest Integer: 99999\nInput: 46\nSmallest Integer: 199999", "task_id": 9435, "assertions": "def test_smallest_integer_with_sum()\n  raise \"Test failed for input 0\" unless smallest_integer_with_sum(0) == 0\n  raise \"Test failed for input 1\" unless smallest_integer_with_sum(1) == 1\n  raise \"Test failed for input 9\" unless smallest_integer_with_sum(9) == 9\n  raise \"Test failed for input 10\" unless smallest_integer_with_sum(10) == 19\n  raise \"Test failed for input 19\" unless smallest_integer_with_sum(19) == 199\n  raise \"Test failed for input 20\" unless smallest_integer_with_sum(20) == 299\n  raise \"Test failed for input 45\" unless smallest_integer_with_sum(45) == 99999\n  raise \"Test failed for input 46\" unless smallest_integer_with_sum(46) == 199999\n  puts \"All tests passed successfully!\"\nend\n\ntest_smallest_integer_with_sum()", "all_code": "# smallest_integer_with_sum returns the smallest integer x such that the sum of the digits of x equals S.\n# The method constructs the number by placing the largest possible digits (9) from the least significant digit to the most significant digit.\n# If S is 0, it returns 0 since the smallest number with digit sum 0 is 0.\ndef smallest_integer_with_sum(s)\n  return 0 if s == 0\n  result = \"\"\n  while s > 0\n    digit = [s, 9].min\n    result = digit.to_s + result\n    s -= digit\n  end\n  result.to_i\nend\n\n# process_test_cases processes an array of test cases and returns an array of results.\n# Each test case is processed by smallest_integer_with_sum to find the smallest integer with the digit sum equal to the test case value.\ndef process_test_cases(test_cases)\n  test_cases.map { |s| smallest_integer_with_sum(s) }\nend\ndef test_smallest_integer_with_sum()\n  raise \"Test failed for input 0\" unless smallest_integer_with_sum(0) == 0\n  raise \"Test failed for input 1\" unless smallest_integer_with_sum(1) == 1\n  raise \"Test failed for input 9\" unless smallest_integer_with_sum(9) == 9\n  raise \"Test failed for input 10\" unless smallest_integer_with_sum(10) == 19\n  raise \"Test failed for input 19\" unless smallest_integer_with_sum(19) == 199\n  raise \"Test failed for input 20\" unless smallest_integer_with_sum(20) == 299\n  raise \"Test failed for input 45\" unless smallest_integer_with_sum(45) == 99999\n  raise \"Test failed for input 46\" unless smallest_integer_with_sum(46) == 199999\n  puts \"All tests passed successfully!\"\nend\n\ntest_smallest_integer_with_sum()", "exec_outcome": "PASSED"}
{"code": "# This Ruby script contains a method to determine if a target power level can be achieved\n# by selecting a combination of artifacts, with the constraint that no two adjacent artifacts\n# can be selected. The solution uses dynamic programming with memoization to optimize the search.\n\n# The `can_achieve_target` method checks if it's possible to achieve the target power level `k`\n# by selecting non-adjacent artifacts from the `power_levels` array.\n# Parameters:\n#   - n: the number of artifacts\n#   - k: the target power level\n#   - power_levels: an array of integers representing the power levels of each artifact\n# Returns:\n#   - \"YES\" if the target can be achieved, \"NO\" otherwise\ndef can_achieve_target(n, k, power_levels)\n  dp = {}\n\n  find_combination = lambda do |index, current_sum|\n    if current_sum == k\n      return true\n    end\n    if index >= n || current_sum > k\n      return false\n    end\n    if dp.key?([index, current_sum])\n      return dp[[index, current_sum]]\n    end\n\n    # Decision to skip the current artifact\n    consider_skip = find_combination.call(index + 1, current_sum)\n\n    # Decision to take the current artifact if it's not adjacent to the previous one\n    consider_take = find_combination.call(index + 2, current_sum + power_levels[index])\n\n    dp[[index, current_sum]] = consider_skip || consider_take\n    return dp[[index, current_sum]]\n  end\n\n  find_combination.call(0, 0) ? \"YES\" : \"NO\"\nend", "test_cases": "", "test_case_results": "Input: n=3, k=5, power_levels=[1, 2, 3]\nResult: NO\n---\nInput: n=4, k=6, power_levels=[1, 2, 3, 4]\nResult: YES\n---\nInput: n=3, k=7, power_levels=[2, 3, 4]\nResult: NO\n---\nInput: n=5, k=10, power_levels=[1, 2, 3, 4, 5]\nResult: NO\n---\nInput: n=2, k=3, power_levels=[1, 2]\nResult: NO\n---", "task_id": 14047, "assertions": "def test_can_achieve_target()\n  raise unless can_achieve_target(3, 5, [1, 2, 3]) == \"NO\"\n  raise unless can_achieve_target(4, 6, [1, 2, 3, 4]) == \"YES\"\n  raise unless can_achieve_target(3, 7, [2, 3, 4]) == \"NO\"\n  raise unless can_achieve_target(5, 10, [1, 2, 3, 4, 5]) == \"NO\"\n  raise unless can_achieve_target(2, 3, [1, 2]) == \"NO\"\n  puts \"All tests passed!\"\nend\n\ntest_can_achieve_target()", "all_code": "# This Ruby script contains a method to determine if a target power level can be achieved\n# by selecting a combination of artifacts, with the constraint that no two adjacent artifacts\n# can be selected. The solution uses dynamic programming with memoization to optimize the search.\n\n# The `can_achieve_target` method checks if it's possible to achieve the target power level `k`\n# by selecting non-adjacent artifacts from the `power_levels` array.\n# Parameters:\n#   - n: the number of artifacts\n#   - k: the target power level\n#   - power_levels: an array of integers representing the power levels of each artifact\n# Returns:\n#   - \"YES\" if the target can be achieved, \"NO\" otherwise\ndef can_achieve_target(n, k, power_levels)\n  dp = {}\n\n  find_combination = lambda do |index, current_sum|\n    if current_sum == k\n      return true\n    end\n    if index >= n || current_sum > k\n      return false\n    end\n    if dp.key?([index, current_sum])\n      return dp[[index, current_sum]]\n    end\n\n    # Decision to skip the current artifact\n    consider_skip = find_combination.call(index + 1, current_sum)\n\n    # Decision to take the current artifact if it's not adjacent to the previous one\n    consider_take = find_combination.call(index + 2, current_sum + power_levels[index])\n\n    dp[[index, current_sum]] = consider_skip || consider_take\n    return dp[[index, current_sum]]\n  end\n\n  find_combination.call(0, 0) ? \"YES\" : \"NO\"\nend\ndef test_can_achieve_target()\n  raise unless can_achieve_target(3, 5, [1, 2, 3]) == \"NO\"\n  raise unless can_achieve_target(4, 6, [1, 2, 3, 4]) == \"YES\"\n  raise unless can_achieve_target(3, 7, [2, 3, 4]) == \"NO\"\n  raise unless can_achieve_target(5, 10, [1, 2, 3, 4, 5]) == \"NO\"\n  raise unless can_achieve_target(2, 3, [1, 2]) == \"NO\"\n  puts \"All tests passed!\"\nend\n\ntest_can_achieve_target()", "exec_outcome": "PASSED"}
{"code": "# find_nth_char returns the nth character in the concatenated sequence of all previous natural numbers.\n# It builds the concatenated string by appending each natural number in sequence until the string's length exceeds n.\n# Then, it returns the character at the nth position in this string.\n# \n# @param n [Integer] the index of the character to find\n# @return [String] the character at the nth position in the concatenated string\ndef find_nth_char(n)\n  concatenated = \"\"\n  i = 0\n  while concatenated.length <= n\n    concatenated += i.to_s\n    i += 1\n  end\n  concatenated[n]\nend", "test_cases": "", "test_case_results": "Input: 0\nCharacter at position 0: 0\nInput: 1\nCharacter at position 1: 1\nInput: 5\nCharacter at position 5: 5\nInput: 10\nCharacter at position 10: 1\nInput: 15\nCharacter at position 15: 2", "task_id": 2146, "assertions": "def test_find_nth_char()\n  raise \"Test case 1 failed\" unless find_nth_char(0) == \"0\"\n  raise \"Test case 2 failed\" unless find_nth_char(1) == \"1\"\n  raise \"Test case 3 failed\" unless find_nth_char(5) == \"5\"\n  raise \"Test case 4 failed\" unless find_nth_char(10) == \"1\"\n  raise \"Test case 5 failed\" unless find_nth_char(15) == \"2\"\n  puts \"All test cases passed!\"\nend\n\ntest_find_nth_char()", "all_code": "# find_nth_char returns the nth character in the concatenated sequence of all previous natural numbers.\n# It builds the concatenated string by appending each natural number in sequence until the string's length exceeds n.\n# Then, it returns the character at the nth position in this string.\n# \n# @param n [Integer] the index of the character to find\n# @return [String] the character at the nth position in the concatenated string\ndef find_nth_char(n)\n  concatenated = \"\"\n  i = 0\n  while concatenated.length <= n\n    concatenated += i.to_s\n    i += 1\n  end\n  concatenated[n]\nend\ndef test_find_nth_char()\n  raise \"Test case 1 failed\" unless find_nth_char(0) == \"0\"\n  raise \"Test case 2 failed\" unless find_nth_char(1) == \"1\"\n  raise \"Test case 3 failed\" unless find_nth_char(5) == \"5\"\n  raise \"Test case 4 failed\" unless find_nth_char(10) == \"1\"\n  raise \"Test case 5 failed\" unless find_nth_char(15) == \"2\"\n  puts \"All test cases passed!\"\nend\n\ntest_find_nth_char()", "exec_outcome": "PASSED"}
{"code": "# print_even_numbers generates a list of even numbers from 0 to n inclusive.\n# If n is less than 0, it returns an empty list.\n# The method uses a range from 0 to n and filters out odd numbers using the modulo operator.\ndef print_even_numbers(n)\n  return [] if n < 0\n  (0..n).select { |i| i.even? }\nend", "test_cases": "", "test_case_results": "Input: 10\nEven Numbers: [0, 2, 4, 6, 8, 10]\nInput: -5\nEven Numbers: []\nInput: 0\nEven Numbers: [0]\nInput: 15\nEven Numbers: [0, 2, 4, 6, 8, 10, 12, 14]", "task_id": 10811, "assertions": "def test_print_even_numbers()\n  raise \"Test case 1 failed\" unless print_even_numbers(10) == [0, 2, 4, 6, 8, 10]\n  raise \"Test case 2 failed\" unless print_even_numbers(-5) == []\n  raise \"Test case 3 failed\" unless print_even_numbers(0) == [0]\n  raise \"Test case 4 failed\" unless print_even_numbers(15) == [0, 2, 4, 6, 8, 10, 12, 14]\n  puts \"All tests passed!\"\nend\n\ntest_print_even_numbers()", "all_code": "# print_even_numbers generates a list of even numbers from 0 to n inclusive.\n# If n is less than 0, it returns an empty list.\n# The method uses a range from 0 to n and filters out odd numbers using the modulo operator.\ndef print_even_numbers(n)\n  return [] if n < 0\n  (0..n).select { |i| i.even? }\nend\ndef test_print_even_numbers()\n  raise \"Test case 1 failed\" unless print_even_numbers(10) == [0, 2, 4, 6, 8, 10]\n  raise \"Test case 2 failed\" unless print_even_numbers(-5) == []\n  raise \"Test case 3 failed\" unless print_even_numbers(0) == [0]\n  raise \"Test case 4 failed\" unless print_even_numbers(15) == [0, 2, 4, 6, 8, 10, 12, 14]\n  puts \"All tests passed!\"\nend\n\ntest_print_even_numbers()", "exec_outcome": "PASSED"}
{"code": "require 'json'\nrequire 'set'\n\n# Finds the shortest path between two nodes in a graph using Dijkstra's algorithm.\n# The graph is represented as a hash where keys are nodes and values are arrays of [neighbor, weight] pairs.\n# \n# @param graph [Hash] the graph represented as a hash\n# @param start_node [String] the starting node\n# @param target_node [String] the target node\n# @return [Array] the shortest path as an array of nodes, or an empty array if no path exists\ndef find_shortest_path(graph, start_node, target_node)\n  # Priority queue to store [distance, node] pairs. Using an array and sorting to simulate a min-heap.\n  priority_queue = [[0, start_node]]\n  # Hash to store the shortest distance to every node\n  distances = { start_node => 0 }\n  # Hash to store the path\n  previous_nodes = {}\n\n  until priority_queue.empty?\n    # Sort the queue to simulate a min-heap (since Ruby doesn't have a built-in priority queue)\n    priority_queue.sort_by! { |distance, _| distance }\n    current_distance, current_node = priority_queue.shift\n\n    # If we reached the target node, build and return the path\n    if current_node == target_node\n      path = []\n      while current_node\n        path << current_node\n        current_node = previous_nodes[current_node]\n      end\n      return path.reverse\n    end\n\n    # Iterate over each neighbor of the current node\n    graph.fetch(current_node, []).each do |neighbor, weight|\n      distance = current_distance + weight\n\n      # Only consider this new path if it's better\n      if distance < distances.fetch(neighbor, Float::INFINITY)\n        distances[neighbor] = distance\n        previous_nodes[neighbor] = current_node\n        priority_queue << [distance, neighbor]\n      end\n    end\n  end\n\n  # Return empty array if no path found\n  []\nend", "test_cases": "", "test_case_results": "Test Case: Simple graph with a clear shortest path\nGraph: {\"A\"=>[[\"B\", 1], [\"C\", 4]], \"B\"=>[[\"A\", 1], [\"C\", 2], [\"D\", 5]], \"C\"=>[[\"A\", 4], [\"B\", 2], [\"D\", 1]], \"D\"=>[[\"B\", 5], [\"C\", 1]]}\nStart Node: A\nTarget Node: D\nShortest Path: A -> B -> C -> D\n\nTest Case: Linear graph\nGraph: {\"A\"=>[[\"B\", 1]], \"B\"=>[[\"C\", 1]], \"C\"=>[[\"D\", 1]], \"D\"=>[]}\nStart Node: A\nTarget Node: D\nShortest Path: A -> B -> C -> D\n\nTest Case: Graph with two possible paths\nGraph: {\"A\"=>[[\"B\", 1], [\"C\", 2]], \"B\"=>[[\"D\", 3]], \"C\"=>[[\"D\", 1]], \"D\"=>[]}\nStart Node: A\nTarget Node: D\nShortest Path: A -> C -> D\n\nTest Case: No path exists between start and target\nGraph: {\"A\"=>[[\"B\", 1]], \"B\"=>[], \"C\"=>[[\"D\", 1]], \"D\"=>[]}\nStart Node: A\nTarget Node: D\nShortest Path: No path exists", "task_id": 10032, "assertions": "def test_find_shortest_path()\n  test_cases = [\n    {\n      graph: {\n        'A' => [['B', 1], ['C', 4]],\n        'B' => [['A', 1], ['C', 2], ['D', 5]],\n        'C' => [['A', 4], ['B', 2], ['D', 1]],\n        'D' => [['B', 5], ['C', 1]]\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'B', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1]],\n        'B' => [['C', 1]],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'B', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1], ['C', 2]],\n        'B' => [['D', 3]],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1]],\n        'B' => [],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: []\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_shortest_path(test_case[:graph], test_case[:start_node], test_case[:target_node])\n    unless result == test_case[:expected]\n      raise \"Test failed for #{test_case[:start_node]} to #{test_case[:target_node]}. Expected: #{test_case[:expected]}, Got: #{result}\"\n    end\n  end\n  puts \"All tests passed!\"\nend\n\ntest_find_shortest_path()", "all_code": "require 'json'\nrequire 'set'\n\n# Finds the shortest path between two nodes in a graph using Dijkstra's algorithm.\n# The graph is represented as a hash where keys are nodes and values are arrays of [neighbor, weight] pairs.\n# \n# @param graph [Hash] the graph represented as a hash\n# @param start_node [String] the starting node\n# @param target_node [String] the target node\n# @return [Array] the shortest path as an array of nodes, or an empty array if no path exists\ndef find_shortest_path(graph, start_node, target_node)\n  # Priority queue to store [distance, node] pairs. Using an array and sorting to simulate a min-heap.\n  priority_queue = [[0, start_node]]\n  # Hash to store the shortest distance to every node\n  distances = { start_node => 0 }\n  # Hash to store the path\n  previous_nodes = {}\n\n  until priority_queue.empty?\n    # Sort the queue to simulate a min-heap (since Ruby doesn't have a built-in priority queue)\n    priority_queue.sort_by! { |distance, _| distance }\n    current_distance, current_node = priority_queue.shift\n\n    # If we reached the target node, build and return the path\n    if current_node == target_node\n      path = []\n      while current_node\n        path << current_node\n        current_node = previous_nodes[current_node]\n      end\n      return path.reverse\n    end\n\n    # Iterate over each neighbor of the current node\n    graph.fetch(current_node, []).each do |neighbor, weight|\n      distance = current_distance + weight\n\n      # Only consider this new path if it's better\n      if distance < distances.fetch(neighbor, Float::INFINITY)\n        distances[neighbor] = distance\n        previous_nodes[neighbor] = current_node\n        priority_queue << [distance, neighbor]\n      end\n    end\n  end\n\n  # Return empty array if no path found\n  []\nend\ndef test_find_shortest_path()\n  test_cases = [\n    {\n      graph: {\n        'A' => [['B', 1], ['C', 4]],\n        'B' => [['A', 1], ['C', 2], ['D', 5]],\n        'C' => [['A', 4], ['B', 2], ['D', 1]],\n        'D' => [['B', 5], ['C', 1]]\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'B', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1]],\n        'B' => [['C', 1]],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'B', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1], ['C', 2]],\n        'B' => [['D', 3]],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: ['A', 'C', 'D']\n    },\n    {\n      graph: {\n        'A' => [['B', 1]],\n        'B' => [],\n        'C' => [['D', 1]],\n        'D' => []\n      },\n      start_node: 'A',\n      target_node: 'D',\n      expected: []\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_shortest_path(test_case[:graph], test_case[:start_node], test_case[:target_node])\n    unless result == test_case[:expected]\n      raise \"Test failed for #{test_case[:start_node]} to #{test_case[:target_node]}. Expected: #{test_case[:expected]}, Got: #{result}\"\n    end\n  end\n  puts \"All tests passed!\"\nend\n\ntest_find_shortest_path()", "exec_outcome": "PASSED"}
{"code": "# parse_document parses a document string and extracts key-value pairs into a hash.\n# The document string is split into lines, and each line is checked for a colon separator.\n# If a colon is found, the line is split into a key and value, which are stripped of whitespace.\n# The resulting key-value pairs are stored in a hash, which is returned.\n#\n# Arguments:\n# doc -- String: The document string to parse.\n#\n# Returns:\n# Hash: A hash containing key-value pairs extracted from the document.\ndef parse_document(doc)\n  lines = doc.split(\"\\n\")\n  result = {}\n\n  lines.each do |line|\n    if line.include?(':')\n      key, value = line.split(':', 2)  # Split into 2 parts at the first colon\n      result[key.strip] = value.strip\n    end\n  end\n\n  result\nend", "test_cases": "", "test_case_results": "Input Document:\nName: John Doe\nAge: 30\nOccupation: Software Developer\nParsed Result: {\"Name\"=>\"John Doe\", \"Age\"=>\"30\", \"Occupation\"=>\"Software Developer\"}\n----------------------------------------\nInput Document:\nTitle: Ruby Programming\nAuthor: Yukihiro Matsumoto\nVersion: 2.7.0\nParsed Result: {\"Title\"=>\"Ruby Programming\", \"Author\"=>\"Yukihiro Matsumoto\", \"Version\"=>\"2.7.0\"}\n----------------------------------------\nInput Document:\nKey1: Value1\nKey2: Value2\nKey3: Value3\nParsed Result: {\"Key1\"=>\"Value1\", \"Key2\"=>\"Value2\", \"Key3\"=>\"Value3\"}\n----------------------------------------\nInput Document:\nSingleLine: This is a single line document\nParsed Result: {\"SingleLine\"=>\"This is a single line document\"}\n----------------------------------------\nInput Document:\nNoColonInThisLine\nAnotherLine: WithAColon\nParsed Result: {\"AnotherLine\"=>\"WithAColon\"}\n----------------------------------------", "task_id": 18092, "assertions": "def test_parse_document()\n  raise unless parse_document(\"Name: John Doe\\nAge: 30\\nOccupation: Software Developer\") == {\"Name\"=>\"John Doe\", \"Age\"=>\"30\", \"Occupation\"=>\"Software Developer\"}\n  raise unless parse_document(\"Title: Ruby Programming\\nAuthor: Yukihiro Matsumoto\\nVersion: 2.7.0\") == {\"Title\"=>\"Ruby Programming\", \"Author\"=>\"Yukihiro Matsumoto\", \"Version\"=>\"2.7.0\"}\n  raise unless parse_document(\"Key1: Value1\\nKey2: Value2\\nKey3: Value3\") == {\"Key1\"=>\"Value1\", \"Key2\"=>\"Value2\", \"Key3\"=>\"Value3\"}\n  raise unless parse_document(\"SingleLine: This is a single line document\") == {\"SingleLine\"=>\"This is a single line document\"}\n  raise unless parse_document(\"NoColonInThisLine\\nAnotherLine: WithAColon\") == {\"AnotherLine\"=>\"WithAColon\"}\nend\n\ntest_parse_document()", "all_code": "# parse_document parses a document string and extracts key-value pairs into a hash.\n# The document string is split into lines, and each line is checked for a colon separator.\n# If a colon is found, the line is split into a key and value, which are stripped of whitespace.\n# The resulting key-value pairs are stored in a hash, which is returned.\n#\n# Arguments:\n# doc -- String: The document string to parse.\n#\n# Returns:\n# Hash: A hash containing key-value pairs extracted from the document.\ndef parse_document(doc)\n  lines = doc.split(\"\\n\")\n  result = {}\n\n  lines.each do |line|\n    if line.include?(':')\n      key, value = line.split(':', 2)  # Split into 2 parts at the first colon\n      result[key.strip] = value.strip\n    end\n  end\n\n  result\nend\ndef test_parse_document()\n  raise unless parse_document(\"Name: John Doe\\nAge: 30\\nOccupation: Software Developer\") == {\"Name\"=>\"John Doe\", \"Age\"=>\"30\", \"Occupation\"=>\"Software Developer\"}\n  raise unless parse_document(\"Title: Ruby Programming\\nAuthor: Yukihiro Matsumoto\\nVersion: 2.7.0\") == {\"Title\"=>\"Ruby Programming\", \"Author\"=>\"Yukihiro Matsumoto\", \"Version\"=>\"2.7.0\"}\n  raise unless parse_document(\"Key1: Value1\\nKey2: Value2\\nKey3: Value3\") == {\"Key1\"=>\"Value1\", \"Key2\"=>\"Value2\", \"Key3\"=>\"Value3\"}\n  raise unless parse_document(\"SingleLine: This is a single line document\") == {\"SingleLine\"=>\"This is a single line document\"}\n  raise unless parse_document(\"NoColonInThisLine\\nAnotherLine: WithAColon\") == {\"AnotherLine\"=>\"WithAColon\"}\nend\n\ntest_parse_document()", "exec_outcome": "PASSED"}
{"code": "def insert_position(array, target)\n  left = 0\n  right = array.size\n  while left < right\n    mid = (left + right) / 2\n    if array[mid] < target\n      left = mid + 1\n    else\n      right = mid\n    end\n  end\n  left\nend", "test_cases": "", "test_case_results": "Array: [1, 3, 5, 6], Target: 5\nInsert Position: 2\nArray: [1, 3, 5, 6], Target: 2\nInsert Position: 1\nArray: [1, 3, 5, 6], Target: 7\nInsert Position: 4\nArray: [1, 3, 5, 6], Target: 0\nInsert Position: 0\nArray: [], Target: 1\nInsert Position: 0", "task_id": 7612, "assertions": "def test_insert_position()\n  raise unless insert_position([1, 3, 5, 6], 5) == 2\n  raise unless insert_position([1, 3, 5, 6], 2) == 1\n  raise unless insert_position([1, 3, 5, 6], 7) == 4\n  raise unless insert_position([1, 3, 5, 6], 0) == 0\n  raise unless insert_position([], 1) == 0\nend\n\ntest_insert_position()", "all_code": "def insert_position(array, target)\n  left = 0\n  right = array.size\n  while left < right\n    mid = (left + right) / 2\n    if array[mid] < target\n      left = mid + 1\n    else\n      right = mid\n    end\n  end\n  left\nend\ndef test_insert_position()\n  raise unless insert_position([1, 3, 5, 6], 5) == 2\n  raise unless insert_position([1, 3, 5, 6], 2) == 1\n  raise unless insert_position([1, 3, 5, 6], 7) == 4\n  raise unless insert_position([1, 3, 5, 6], 0) == 0\n  raise unless insert_position([], 1) == 0\nend\n\ntest_insert_position()", "exec_outcome": "PASSED"}
{"code": "# find_longest_divisible_subsequence calculates the length of the longest subsequence\n# where each element is divisible by the previous one.\n# It first sorts the input array and then uses dynamic programming to build up the solution.\n# The dp array keeps track of the longest subsequence length ending at each element.\n#\n# @param nums [Array<Integer>] the input array of integers\n# @return [Integer] the length of the longest divisible subsequence\ndef find_longest_divisible_subsequence(nums)\n  return 0 if nums.empty?\n\n  # Sort the array\n  nums.sort!\n  n = nums.size\n\n  # dp array to hold the longest subsequence length ending at each element\n  dp = Array.new(n, 1)\n\n  # Iterate through the array to build up the dp array\n  (1...n).each do |i|\n    (0...i).each do |j|\n      if nums[i] % nums[j] == 0\n        dp[i] = [dp[i], dp[j] + 1].max\n      end\n    end\n  end\n\n  dp.max\nend", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 5, 6]\nLength of longest divisible subsequence: 3\nInput: [5, 10, 15, 20]\nLength of longest divisible subsequence: 3\nInput: [3, 6, 9, 12, 15, 18]\nLength of longest divisible subsequence: 3\nInput: [1, 3, 6, 11, 22]\nLength of longest divisible subsequence: 3\nInput: [2, 3, 5, 7, 11, 13]\nLength of longest divisible subsequence: 1", "task_id": 17033, "assertions": "def test_find_longest_divisible_subsequence\n  raise \"Test case 1 failed\" unless find_longest_divisible_subsequence([1, 2, 3, 4, 5, 6]) == 3\n  raise \"Test case 2 failed\" unless find_longest_divisible_subsequence([5, 10, 15, 20]) == 3\n  raise \"Test case 3 failed\" unless find_longest_divisible_subsequence([3, 6, 9, 12, 15, 18]) == 3\n  raise \"Test case 4 failed\" unless find_longest_divisible_subsequence([1, 3, 6, 11, 22]) == 3\n  raise \"Test case 5 failed\" unless find_longest_divisible_subsequence([2, 3, 5, 7, 11, 13]) == 1\nend\n\ntest_find_longest_divisible_subsequence", "all_code": "# find_longest_divisible_subsequence calculates the length of the longest subsequence\n# where each element is divisible by the previous one.\n# It first sorts the input array and then uses dynamic programming to build up the solution.\n# The dp array keeps track of the longest subsequence length ending at each element.\n#\n# @param nums [Array<Integer>] the input array of integers\n# @return [Integer] the length of the longest divisible subsequence\ndef find_longest_divisible_subsequence(nums)\n  return 0 if nums.empty?\n\n  # Sort the array\n  nums.sort!\n  n = nums.size\n\n  # dp array to hold the longest subsequence length ending at each element\n  dp = Array.new(n, 1)\n\n  # Iterate through the array to build up the dp array\n  (1...n).each do |i|\n    (0...i).each do |j|\n      if nums[i] % nums[j] == 0\n        dp[i] = [dp[i], dp[j] + 1].max\n      end\n    end\n  end\n\n  dp.max\nend\ndef test_find_longest_divisible_subsequence\n  raise \"Test case 1 failed\" unless find_longest_divisible_subsequence([1, 2, 3, 4, 5, 6]) == 3\n  raise \"Test case 2 failed\" unless find_longest_divisible_subsequence([5, 10, 15, 20]) == 3\n  raise \"Test case 3 failed\" unless find_longest_divisible_subsequence([3, 6, 9, 12, 15, 18]) == 3\n  raise \"Test case 4 failed\" unless find_longest_divisible_subsequence([1, 3, 6, 11, 22]) == 3\n  raise \"Test case 5 failed\" unless find_longest_divisible_subsequence([2, 3, 5, 7, 11, 13]) == 1\nend\n\ntest_find_longest_divisible_subsequence", "exec_outcome": "PASSED"}
{"code": "# count_good_buildings calculates the number of \"good\" buildings in an array of heights.\n# A building is considered good if its height is greater than or equal to all buildings to its left, including itself.\n# The first building is always considered good.\n# The method iterates through the array, keeping track of the maximum height encountered so far,\n# and increments the count whenever a building's height is greater than or equal to this maximum.\n#\n# @param heights [Array<Integer>] the list of building heights\n# @return [Integer] the number of good buildings in the array\ndef count_good_buildings(heights)\n  return 0 if heights.empty?\n\n  max_height = heights[0]\n  good_count = 1  # First building is always good\n\n  heights[1..-1].each do |height|\n    if height >= max_height\n      good_count += 1\n      max_height = height\n    end\n  end\n\n  good_count\nend", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nNumber of good buildings: 4\n------------------------------\nInput: [4, 3, 2, 1]\nNumber of good buildings: 1\n------------------------------\nInput: [2, 2, 2, 2]\nNumber of good buildings: 4\n------------------------------\nInput: []\nNumber of good buildings: 0\n------------------------------\nInput: [5]\nNumber of good buildings: 1\n------------------------------\nInput: [1, 3, 2, 4, 5]\nNumber of good buildings: 4\n------------------------------\nInput: [10, 5, 10, 15]\nNumber of good buildings: 3\n------------------------------", "task_id": 10167, "assertions": "def test_count_good_buildings\n  raise \"Test case 1 failed\" unless count_good_buildings([1, 2, 3, 4]) == 4\n  raise \"Test case 2 failed\" unless count_good_buildings([4, 3, 2, 1]) == 1\n  raise \"Test case 3 failed\" unless count_good_buildings([2, 2, 2, 2]) == 4\n  raise \"Test case 4 failed\" unless count_good_buildings([]) == 0\n  raise \"Test case 5 failed\" unless count_good_buildings([5]) == 1\n  raise \"Test case 6 failed\" unless count_good_buildings([1, 3, 2, 4, 5]) == 4\n  raise \"Test case 7 failed\" unless count_good_buildings([10, 5, 10, 15]) == 3\nend\n\ntest_count_good_buildings", "all_code": "# count_good_buildings calculates the number of \"good\" buildings in an array of heights.\n# A building is considered good if its height is greater than or equal to all buildings to its left, including itself.\n# The first building is always considered good.\n# The method iterates through the array, keeping track of the maximum height encountered so far,\n# and increments the count whenever a building's height is greater than or equal to this maximum.\n#\n# @param heights [Array<Integer>] the list of building heights\n# @return [Integer] the number of good buildings in the array\ndef count_good_buildings(heights)\n  return 0 if heights.empty?\n\n  max_height = heights[0]\n  good_count = 1  # First building is always good\n\n  heights[1..-1].each do |height|\n    if height >= max_height\n      good_count += 1\n      max_height = height\n    end\n  end\n\n  good_count\nend\ndef test_count_good_buildings\n  raise \"Test case 1 failed\" unless count_good_buildings([1, 2, 3, 4]) == 4\n  raise \"Test case 2 failed\" unless count_good_buildings([4, 3, 2, 1]) == 1\n  raise \"Test case 3 failed\" unless count_good_buildings([2, 2, 2, 2]) == 4\n  raise \"Test case 4 failed\" unless count_good_buildings([]) == 0\n  raise \"Test case 5 failed\" unless count_good_buildings([5]) == 1\n  raise \"Test case 6 failed\" unless count_good_buildings([1, 3, 2, 4, 5]) == 4\n  raise \"Test case 7 failed\" unless count_good_buildings([10, 5, 10, 15]) == 3\nend\n\ntest_count_good_buildings", "exec_outcome": "PASSED"}
{"code": "# Require necessary standard libraries (none needed for this implementation)\n\n# SequenceQuery class provides methods to update an array and compute sum or product of subarrays modulo a given number.\nclass SequenceQuery\n  # Initialize the SequenceQuery with an array and a modulus.\n  # @param array [Array<Integer>] the initial array of integers\n  # @param mod [Integer] the modulus to be applied to sum and product operations\n  def initialize(array, mod)\n    @array = array\n    @mod = mod\n  end\n\n  # Updates the value at a specific index in the array.\n  # @param x [Integer] the index to update\n  # @param y [Integer] the new value\n  def update(x, y)\n    @array[x] = y\n  end\n\n  # Computes the sum of a subarray from index l to r, inclusive, modulo the initialized modulus.\n  # @param l [Integer] the starting index of the subarray\n  # @param r [Integer] the ending index of the subarray\n  # @return [Integer] the sum of the subarray modulo mod\n  def sum_subarray(l, r)\n    @array[l..r].sum % @mod\n  end\n\n  # Computes the product of a subarray from index l to r, inclusive, modulo the initialized modulus.\n  # @param l [Integer] the starting index of the subarray\n  # @param r [Integer] the ending index of the subarray\n  # @return [Integer] the product of the subarray modulo mod\n  def product_subarray(l, r)\n    product = 1\n    (l..r).each do |i|\n      product = (product * @array[i]) % @mod\n    end\n    product\n  end\nend\n\n# Processes a list of queries on an array, applying updates, sum, or product operations as specified.\n# @param n [Integer] the size of the array (unused in this implementation but kept for compatibility)\n# @param mod [Integer] the modulus to be applied to sum and product operations\n# @param array [Array<Integer>] the initial array of integers\n# @param queries [Array<Array<Integer>>] the list of queries to process\n# @return [Array<Integer>] the results of the sum and product queries\ndef process_queries(n, mod, array, queries)\n  seq_query = SequenceQuery.new(array, mod)\n  results = []\n  queries.each do |query|\n    case query[0]\n    when 1\n      seq_query.update(query[1], query[2])\n    when 2\n      results << seq_query.sum_subarray(query[1], query[2])\n    when 3\n      results << seq_query.product_subarray(query[1], query[2])\n    end\n  end\n  results\nend", "test_cases": "", "test_case_results": "Input:\nn: 5, mod: 1000, array: [1, 2, 3, 4, 5], queries: [[2, 1, 3], [3, 0, 4], [1, 2, 10], [2, 1, 3], [3, 0, 4]]\nResults: [9, 120, 16, 400]\nInput:\nn: 3, mod: 7, array: [2, 3, 4], queries: [[3, 0, 2], [1, 1, 5], [2, 0, 1]]\nResults: [3, 0]", "task_id": 24186, "assertions": "def test_process_queries()\n  # Test case 1\n  results1 = process_queries(5, 1000, [1, 2, 3, 4, 5], [\n    [2, 1, 3],  # Sum subarray from index 1 to 3\n    [3, 0, 4],  # Product subarray from index 0 to 4\n    [1, 2, 10], # Update index 2 to value 10\n    [2, 1, 3],  # Sum subarray from index 1 to 3\n    [3, 0, 4]   # Product subarray from index 0 to 4\n  ])\n  raise \"Test case 1 failed\" unless results1 == [9, 120, 16, 400]\n\n  # Test case 2\n  results2 = process_queries(3, 7, [2, 3, 4], [\n    [3, 0, 2],  # Product subarray from index 0 to 2\n    [1, 1, 5],  # Update index 1 to value 5\n    [2, 0, 1]   # Sum subarray from index 0 to 1\n  ])\n  raise \"Test case 2 failed\" unless results2 == [3, 0]\nend\n\ntest_process_queries()", "all_code": "# Require necessary standard libraries (none needed for this implementation)\n\n# SequenceQuery class provides methods to update an array and compute sum or product of subarrays modulo a given number.\nclass SequenceQuery\n  # Initialize the SequenceQuery with an array and a modulus.\n  # @param array [Array<Integer>] the initial array of integers\n  # @param mod [Integer] the modulus to be applied to sum and product operations\n  def initialize(array, mod)\n    @array = array\n    @mod = mod\n  end\n\n  # Updates the value at a specific index in the array.\n  # @param x [Integer] the index to update\n  # @param y [Integer] the new value\n  def update(x, y)\n    @array[x] = y\n  end\n\n  # Computes the sum of a subarray from index l to r, inclusive, modulo the initialized modulus.\n  # @param l [Integer] the starting index of the subarray\n  # @param r [Integer] the ending index of the subarray\n  # @return [Integer] the sum of the subarray modulo mod\n  def sum_subarray(l, r)\n    @array[l..r].sum % @mod\n  end\n\n  # Computes the product of a subarray from index l to r, inclusive, modulo the initialized modulus.\n  # @param l [Integer] the starting index of the subarray\n  # @param r [Integer] the ending index of the subarray\n  # @return [Integer] the product of the subarray modulo mod\n  def product_subarray(l, r)\n    product = 1\n    (l..r).each do |i|\n      product = (product * @array[i]) % @mod\n    end\n    product\n  end\nend\n\n# Processes a list of queries on an array, applying updates, sum, or product operations as specified.\n# @param n [Integer] the size of the array (unused in this implementation but kept for compatibility)\n# @param mod [Integer] the modulus to be applied to sum and product operations\n# @param array [Array<Integer>] the initial array of integers\n# @param queries [Array<Array<Integer>>] the list of queries to process\n# @return [Array<Integer>] the results of the sum and product queries\ndef process_queries(n, mod, array, queries)\n  seq_query = SequenceQuery.new(array, mod)\n  results = []\n  queries.each do |query|\n    case query[0]\n    when 1\n      seq_query.update(query[1], query[2])\n    when 2\n      results << seq_query.sum_subarray(query[1], query[2])\n    when 3\n      results << seq_query.product_subarray(query[1], query[2])\n    end\n  end\n  results\nend\ndef test_process_queries()\n  # Test case 1\n  results1 = process_queries(5, 1000, [1, 2, 3, 4, 5], [\n    [2, 1, 3],  # Sum subarray from index 1 to 3\n    [3, 0, 4],  # Product subarray from index 0 to 4\n    [1, 2, 10], # Update index 2 to value 10\n    [2, 1, 3],  # Sum subarray from index 1 to 3\n    [3, 0, 4]   # Product subarray from index 0 to 4\n  ])\n  raise \"Test case 1 failed\" unless results1 == [9, 120, 16, 400]\n\n  # Test case 2\n  results2 = process_queries(3, 7, [2, 3, 4], [\n    [3, 0, 2],  # Product subarray from index 0 to 2\n    [1, 1, 5],  # Update index 1 to value 5\n    [2, 0, 1]   # Sum subarray from index 0 to 1\n  ])\n  raise \"Test case 2 failed\" unless results2 == [3, 0]\nend\n\ntest_process_queries()", "exec_outcome": "PASSED"}
{"code": "# string_to_integer converts a string to an integer if it is a valid integer representation.\n# If the string is not a valid integer, it returns nil.\n#\n# @param s [String] the string to be converted\n# @return [Integer, nil] the integer representation of the string if valid, otherwise nil\ndef string_to_integer(s)\n  Integer(s)\nrescue ArgumentError\n  nil\nend", "test_cases": "", "test_case_results": "Input: 123\nResult: 123\nInput: -456\nResult: -456\nInput: 789\nResult: 789\nInput: 12a34\nResult: \nInput: abc\nResult: \nInput: 0\nResult: 0", "task_id": 2040, "assertions": "def test_string_to_integer()\n  raise \"Test failed: '123'\" unless string_to_integer(\"123\") == 123\n  raise \"Test failed: '-456'\" unless string_to_integer(\"-456\") == -456\n  raise \"Test failed: '789'\" unless string_to_integer(\"789\") == 789\n  raise \"Test failed: '12a34'\" unless string_to_integer(\"12a34\") == nil\n  raise \"Test failed: 'abc'\" unless string_to_integer(\"abc\") == nil\n  raise \"Test failed: '0'\" unless string_to_integer(\"0\") == 0\nend\n\ntest_string_to_integer()", "all_code": "# string_to_integer converts a string to an integer if it is a valid integer representation.\n# If the string is not a valid integer, it returns nil.\n#\n# @param s [String] the string to be converted\n# @return [Integer, nil] the integer representation of the string if valid, otherwise nil\ndef string_to_integer(s)\n  Integer(s)\nrescue ArgumentError\n  nil\nend\ndef test_string_to_integer()\n  raise \"Test failed: '123'\" unless string_to_integer(\"123\") == 123\n  raise \"Test failed: '-456'\" unless string_to_integer(\"-456\") == -456\n  raise \"Test failed: '789'\" unless string_to_integer(\"789\") == 789\n  raise \"Test failed: '12a34'\" unless string_to_integer(\"12a34\") == nil\n  raise \"Test failed: 'abc'\" unless string_to_integer(\"abc\") == nil\n  raise \"Test failed: '0'\" unless string_to_integer(\"0\") == 0\nend\n\ntest_string_to_integer()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef find_min_time(n, m, paths)\n  # Build the graph as an adjacency list\n  graph = Hash.new { |h, k| h[k] = [] }\n  paths.each do |a, b, t|\n    graph[a] << [b, t]\n    graph[b] << [a, t]\n  end\n\n  # Priority queue represented as an array of [time, attraction], using a heap\n  pq = []\n  pq << [0, 1]\n\n  # Hash to keep track of the shortest known distance to each attraction\n  dist = Hash.new(Float::INFINITY)\n  dist[1] = 0\n\n  until pq.empty?\n    current_time, u = pq.shift\n\n    # If we've reached the destination, return the time\n    return current_time if u == n\n\n    # Skip if we've already found a better path\n    next if current_time > dist[u]\n\n    # Explore all neighboring attractions\n    graph[u].each do |v, time|\n      new_time = current_time + time\n      if new_time < dist[v]\n        dist[v] = new_time\n        # Insert into priority queue (using push and sort to simulate a min-heap)\n        pq << [new_time, v]\n        pq.sort_by! { |time, _| time }\n      end\n    end\n  end\n\n  # Return -1 if the destination is unreachable\n  dist[n] == Float::INFINITY ? -1 : dist[n]\nend", "test_cases": "", "test_case_results": "Input: N=3, M=3, paths=[[1, 2, 2], [2, 3, 3], [1, 3, 6]]\nMinimum time: 5\nInput: N=4, M=4, paths=[[1, 2, 1], [2, 3, 2], [3, 4, 3], [1, 4, 10]]\nMinimum time: 6\nInput: N=5, M=0, paths=[]\nMinimum time: -1\nInput: N=2, M=1, paths=[[1, 2, 5]]\nMinimum time: 5", "task_id": 12963, "assertions": "def test_find_min_time()\n  raise unless find_min_time(3, 3, [[1, 2, 2], [2, 3, 3], [1, 3, 6]]) == 5\n  raise unless find_min_time(4, 4, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [1, 4, 10]]) == 6\n  raise unless find_min_time(5, 0, []) == -1\n  raise unless find_min_time(2, 1, [[1, 2, 5]]) == 5\nend\n\ntest_find_min_time()", "all_code": "require 'set'\n\ndef find_min_time(n, m, paths)\n  # Build the graph as an adjacency list\n  graph = Hash.new { |h, k| h[k] = [] }\n  paths.each do |a, b, t|\n    graph[a] << [b, t]\n    graph[b] << [a, t]\n  end\n\n  # Priority queue represented as an array of [time, attraction], using a heap\n  pq = []\n  pq << [0, 1]\n\n  # Hash to keep track of the shortest known distance to each attraction\n  dist = Hash.new(Float::INFINITY)\n  dist[1] = 0\n\n  until pq.empty?\n    current_time, u = pq.shift\n\n    # If we've reached the destination, return the time\n    return current_time if u == n\n\n    # Skip if we've already found a better path\n    next if current_time > dist[u]\n\n    # Explore all neighboring attractions\n    graph[u].each do |v, time|\n      new_time = current_time + time\n      if new_time < dist[v]\n        dist[v] = new_time\n        # Insert into priority queue (using push and sort to simulate a min-heap)\n        pq << [new_time, v]\n        pq.sort_by! { |time, _| time }\n      end\n    end\n  end\n\n  # Return -1 if the destination is unreachable\n  dist[n] == Float::INFINITY ? -1 : dist[n]\nend\ndef test_find_min_time()\n  raise unless find_min_time(3, 3, [[1, 2, 2], [2, 3, 3], [1, 3, 6]]) == 5\n  raise unless find_min_time(4, 4, [[1, 2, 1], [2, 3, 2], [3, 4, 3], [1, 4, 10]]) == 6\n  raise unless find_min_time(5, 0, []) == -1\n  raise unless find_min_time(2, 1, [[1, 2, 5]]) == 5\nend\n\ntest_find_min_time()", "exec_outcome": "PASSED"}
{"code": "# find_smallest_index calculates the smallest index k in a sequence where the value at k is >= n.\n# The sequence is defined as:\n# - a(1) = 1\n# - a(2) = 2\n# - a(i) = a(i-1) + a(i-2) for i > 2\n# The method uses an iterative approach to generate sequence values until it finds the first value >= n.\ndef find_smallest_index(n)\n  return 1 if n == 1\n  return 2 if n == 2\n\n  a1, a2 = 1, 2\n  k = 2\n  while a2 < n\n    a1, a2 = a2, a1 + a2\n    k += 1\n  end\n  k\nend", "test_cases": "", "test_case_results": "Input: 1\nSmallest index k: 1\nInput: 2\nSmallest index k: 2\nInput: 3\nSmallest index k: 3\nInput: 5\nSmallest index k: 4\nInput: 8\nSmallest index k: 5\nInput: 13\nSmallest index k: 6\nInput: 20\nSmallest index k: 7\nInput: 50\nSmallest index k: 9\nInput: 100\nSmallest index k: 11", "task_id": 18464, "assertions": "def test_find_smallest_index()\n  raise unless find_smallest_index(1) == 1\n  raise unless find_smallest_index(2) == 2\n  raise unless find_smallest_index(3) == 3\n  raise unless find_smallest_index(5) == 4\n  raise unless find_smallest_index(8) == 5\n  raise unless find_smallest_index(13) == 6\n  raise unless find_smallest_index(20) == 7\n  raise unless find_smallest_index(50) == 9\n  raise unless find_smallest_index(100) == 11\nend\n\ntest_find_smallest_index()", "all_code": "# find_smallest_index calculates the smallest index k in a sequence where the value at k is >= n.\n# The sequence is defined as:\n# - a(1) = 1\n# - a(2) = 2\n# - a(i) = a(i-1) + a(i-2) for i > 2\n# The method uses an iterative approach to generate sequence values until it finds the first value >= n.\ndef find_smallest_index(n)\n  return 1 if n == 1\n  return 2 if n == 2\n\n  a1, a2 = 1, 2\n  k = 2\n  while a2 < n\n    a1, a2 = a2, a1 + a2\n    k += 1\n  end\n  k\nend\ndef test_find_smallest_index()\n  raise unless find_smallest_index(1) == 1\n  raise unless find_smallest_index(2) == 2\n  raise unless find_smallest_index(3) == 3\n  raise unless find_smallest_index(5) == 4\n  raise unless find_smallest_index(8) == 5\n  raise unless find_smallest_index(13) == 6\n  raise unless find_smallest_index(20) == 7\n  raise unless find_smallest_index(50) == 9\n  raise unless find_smallest_index(100) == 11\nend\n\ntest_find_smallest_index()", "exec_outcome": "PASSED"}
{"code": "# lexicographically_smallest_u finds the lexicographically smallest possible string u such that\n# u + v = s and u is lexicographically smaller than v.\n# It iterates through the string s, checking each possible split point i.\n# For each split, it compares the prefix u (s[0...i]) with the suffix v (s[i...n]).\n# If u is lexicographically smaller than v, it returns u.\n# If no such u is found, it returns the first character of s as a fallback.\ndef lexicographically_smallest_u(n, s)\n  (1...n).each do |i|\n    u = s[0...i]\n    v = s[i...n]\n    if u < v\n      return u\n    end\n  end\n  s[0]  # Fallback in case no valid u is found\nend", "test_cases": "", "test_case_results": "Input: n = 3, s = abc\nLexicographically smallest u: a\nInput: n = 4, s = abcd\nLexicographically smallest u: a\nInput: n = 5, s = abcde\nLexicographically smallest u: a\nInput: n = 2, s = ba\nLexicographically smallest u: b\nInput: n = 1, s = a\nLexicographically smallest u: a", "task_id": 21800, "assertions": "def test_lexicographically_smallest_u()\n  raise unless lexicographically_smallest_u(3, \"abc\") == \"a\"\n  raise unless lexicographically_smallest_u(4, \"abcd\") == \"a\"\n  raise unless lexicographically_smallest_u(5, \"abcde\") == \"a\"\n  raise unless lexicographically_smallest_u(2, \"ba\") == \"b\"\n  raise unless lexicographically_smallest_u(1, \"a\") == \"a\"\nend\n\ntest_lexicographically_smallest_u()", "all_code": "# lexicographically_smallest_u finds the lexicographically smallest possible string u such that\n# u + v = s and u is lexicographically smaller than v.\n# It iterates through the string s, checking each possible split point i.\n# For each split, it compares the prefix u (s[0...i]) with the suffix v (s[i...n]).\n# If u is lexicographically smaller than v, it returns u.\n# If no such u is found, it returns the first character of s as a fallback.\ndef lexicographically_smallest_u(n, s)\n  (1...n).each do |i|\n    u = s[0...i]\n    v = s[i...n]\n    if u < v\n      return u\n    end\n  end\n  s[0]  # Fallback in case no valid u is found\nend\ndef test_lexicographically_smallest_u()\n  raise unless lexicographically_smallest_u(3, \"abc\") == \"a\"\n  raise unless lexicographically_smallest_u(4, \"abcd\") == \"a\"\n  raise unless lexicographically_smallest_u(5, \"abcde\") == \"a\"\n  raise unless lexicographically_smallest_u(2, \"ba\") == \"b\"\n  raise unless lexicographically_smallest_u(1, \"a\") == \"a\"\nend\n\ntest_lexicographically_smallest_u()", "exec_outcome": "PASSED"}
{"code": "# count_temperature_adjustments calculates the minimum number of days on which temperature adjustments are needed\n# to ensure all temperatures fall within the inclusive range [a, b].\n# Parameters:\n#   n - number of days (not used in the logic, but kept for consistency with the original function signature)\n#   a - lower bound of the acceptable temperature range\n#   b - upper bound of the acceptable temperature range\n#   temperatures - array of temperature readings for each day\n# Returns:\n#   The count of days where temperatures are outside the range [a, b]\ndef count_temperature_adjustments(n, a, b, temperatures)\n  adjustments_needed = 0\n\n  temperatures.each do |temp|\n    adjustments_needed += 1 if temp < a || temp > b\n  end\n\n  adjustments_needed\nend", "test_cases": "", "test_case_results": "Input: n=5, a=10, b=20, temperatures=[15, 10, 8, 25, 18]\nAdjustments needed: 2\nInput: n=3, a=0, b=5, temperatures=[1, 2, 6]\nAdjustments needed: 1\nInput: n=4, a=10, b=10, temperatures=[10, 10, 10, 10]\nAdjustments needed: 0\nInput: n=0, a=5, b=15, temperatures=[]\nAdjustments needed: 0", "task_id": 5051, "assertions": "def test_count_temperature_adjustments()\n  raise \"Test case 1 failed\" unless count_temperature_adjustments(5, 10, 20, [15, 10, 8, 25, 18]) == 2\n  raise \"Test case 2 failed\" unless count_temperature_adjustments(3, 0, 5, [1, 2, 6]) == 1\n  raise \"Test case 3 failed\" unless count_temperature_adjustments(4, 10, 10, [10, 10, 10, 10]) == 0\n  raise \"Test case 4 failed\" unless count_temperature_adjustments(0, 5, 15, []) == 0\n  puts \"All test cases passed!\"\nend\n\ntest_count_temperature_adjustments()", "all_code": "# count_temperature_adjustments calculates the minimum number of days on which temperature adjustments are needed\n# to ensure all temperatures fall within the inclusive range [a, b].\n# Parameters:\n#   n - number of days (not used in the logic, but kept for consistency with the original function signature)\n#   a - lower bound of the acceptable temperature range\n#   b - upper bound of the acceptable temperature range\n#   temperatures - array of temperature readings for each day\n# Returns:\n#   The count of days where temperatures are outside the range [a, b]\ndef count_temperature_adjustments(n, a, b, temperatures)\n  adjustments_needed = 0\n\n  temperatures.each do |temp|\n    adjustments_needed += 1 if temp < a || temp > b\n  end\n\n  adjustments_needed\nend\ndef test_count_temperature_adjustments()\n  raise \"Test case 1 failed\" unless count_temperature_adjustments(5, 10, 20, [15, 10, 8, 25, 18]) == 2\n  raise \"Test case 2 failed\" unless count_temperature_adjustments(3, 0, 5, [1, 2, 6]) == 1\n  raise \"Test case 3 failed\" unless count_temperature_adjustments(4, 10, 10, [10, 10, 10, 10]) == 0\n  raise \"Test case 4 failed\" unless count_temperature_adjustments(0, 5, 15, []) == 0\n  puts \"All test cases passed!\"\nend\n\ntest_count_temperature_adjustments()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef find_min_travel_time(n, m, roads, s)\n  return 0 if n == 1\n\n  travel_time = {}\n  roads.each do |u, v, t|\n    travel_time[u] ||= {}\n    travel_time[v] ||= {}\n    travel_time[u][v] = t\n    travel_time[v][u] = t\n  end\n\n  min_travel_time = Float::INFINITY\n\n  cities = (1..n).to_a.reject { |i| i == s }\n  cities.permutation.each do |perm|\n    current_time = 0\n    current_city = s\n    valid_path = true\n\n    perm.each do |next_city|\n      if travel_time.dig(current_city, next_city)\n        current_time += travel_time[current_city][next_city]\n        current_city = next_city\n      else\n        valid_path = false\n        break\n      end\n    end\n\n    if valid_path && travel_time.dig(current_city, s)\n      current_time += travel_time[current_city][s]\n      min_travel_time = [min_travel_time, current_time].min\n    end\n  end\n\n  min_travel_time == Float::INFINITY ? -1 : min_travel_time\nend", "test_cases": "", "test_case_results": "Test Case: Single city, no travel required\nInput: N=1, M=0, Roads=[], S=1\nResult: 0\n\nTest Case: Two cities with one road\nInput: N=2, M=1, Roads=[[1, 2, 10]], S=1\nResult: 20\n\nTest Case: Three cities with a cycle\nInput: N=3, M=3, Roads=[[1, 2, 10], [2, 3, 20], [3, 1, 30]], S=1\nResult: 60\n\nTest Case: Four cities with a cycle\nInput: N=4, M=4, Roads=[[1, 2, 10], [2, 3, 15], [3, 4, 20], [4, 1, 25]], S=1\nResult: 70\n\nTest Case: Three cities with no return path\nInput: N=3, M=2, Roads=[[1, 2, 10], [2, 3, 20]], S=1\nResult: -1", "task_id": 21356, "assertions": "def test_find_min_travel_time()\n  raise \"Test case 1 failed\" unless find_min_travel_time(1, 0, [], 1) == 0\n  raise \"Test case 2 failed\" unless find_min_travel_time(2, 1, [[1, 2, 10]], 1) == 20\n  raise \"Test case 3 failed\" unless find_min_travel_time(3, 3, [[1, 2, 10], [2, 3, 20], [3, 1, 30]], 1) == 60\n  raise \"Test case 4 failed\" unless find_min_travel_time(4, 4, [[1, 2, 10], [2, 3, 15], [3, 4, 20], [4, 1, 25]], 1) == 70\n  raise \"Test case 5 failed\" unless find_min_travel_time(3, 2, [[1, 2, 10], [2, 3, 20]], 1) == -1\nend\n\ntest_find_min_travel_time()", "all_code": "require 'set'\n\ndef find_min_travel_time(n, m, roads, s)\n  return 0 if n == 1\n\n  travel_time = {}\n  roads.each do |u, v, t|\n    travel_time[u] ||= {}\n    travel_time[v] ||= {}\n    travel_time[u][v] = t\n    travel_time[v][u] = t\n  end\n\n  min_travel_time = Float::INFINITY\n\n  cities = (1..n).to_a.reject { |i| i == s }\n  cities.permutation.each do |perm|\n    current_time = 0\n    current_city = s\n    valid_path = true\n\n    perm.each do |next_city|\n      if travel_time.dig(current_city, next_city)\n        current_time += travel_time[current_city][next_city]\n        current_city = next_city\n      else\n        valid_path = false\n        break\n      end\n    end\n\n    if valid_path && travel_time.dig(current_city, s)\n      current_time += travel_time[current_city][s]\n      min_travel_time = [min_travel_time, current_time].min\n    end\n  end\n\n  min_travel_time == Float::INFINITY ? -1 : min_travel_time\nend\ndef test_find_min_travel_time()\n  raise \"Test case 1 failed\" unless find_min_travel_time(1, 0, [], 1) == 0\n  raise \"Test case 2 failed\" unless find_min_travel_time(2, 1, [[1, 2, 10]], 1) == 20\n  raise \"Test case 3 failed\" unless find_min_travel_time(3, 3, [[1, 2, 10], [2, 3, 20], [3, 1, 30]], 1) == 60\n  raise \"Test case 4 failed\" unless find_min_travel_time(4, 4, [[1, 2, 10], [2, 3, 15], [3, 4, 20], [4, 1, 25]], 1) == 70\n  raise \"Test case 5 failed\" unless find_min_travel_time(3, 2, [[1, 2, 10], [2, 3, 20]], 1) == -1\nend\n\ntest_find_min_travel_time()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef longest_diverse_substring(k, s)\n  max_len = 0\n  current_count = Hash.new(0)\n  distinct_count = 0\n  left = 0\n\n  s.chars.each_with_index do |char, right|\n    current_count[char] += 1\n\n    if current_count[char] == 1\n      distinct_count += 1\n    end\n\n    while distinct_count > k\n      current_count[s[left]] -= 1\n      if current_count[s[left]] == 0\n        distinct_count -= 1\n      end\n      left += 1\n    end\n\n    current_window_len = right - left + 1\n    max_len = [max_len, current_window_len].max\n  end\n\n  max_len\nend\n\ndef process_test_cases(t, test_cases)\n  results = []\n  (0...t).each do |i|\n    k = test_cases[i][0]\n    s = test_cases[i][1]\n    results << longest_diverse_substring(k, s)\n  end\n  results\nend", "test_cases": "", "test_case_results": "Number of test cases: 5\nTest case 1: k=2, s='abcba'\nLongest diverse substring length: 3\nTest case 2: k=3, s='abcd'\nLongest diverse substring length: 3\nTest case 3: k=1, s='aaaaa'\nLongest diverse substring length: 5\nTest case 4: k=2, s='eceba'\nLongest diverse substring length: 3\nTest case 5: k=3, s='aaabbbccc'\nLongest diverse substring length: 9", "task_id": 8386, "assertions": "def test_longest_diverse_substring()\n  test_cases = [\n    [2, \"abcba\"],\n    [3, \"abcd\"],\n    [1, \"aaaaa\"],\n    [2, \"eceba\"],\n    [3, \"aaabbbccc\"]\n  ]\n  expected_results = [3, 3, 5, 3, 9]\n\n  results = process_test_cases(test_cases.size, test_cases)\n\n  results.each_with_index do |result, index|\n    unless result == expected_results[index]\n      raise \"Test case #{index + 1} failed: Expected #{expected_results[index]}, got #{result}\"\n    end\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_longest_diverse_substring()", "all_code": "require 'set'\n\ndef longest_diverse_substring(k, s)\n  max_len = 0\n  current_count = Hash.new(0)\n  distinct_count = 0\n  left = 0\n\n  s.chars.each_with_index do |char, right|\n    current_count[char] += 1\n\n    if current_count[char] == 1\n      distinct_count += 1\n    end\n\n    while distinct_count > k\n      current_count[s[left]] -= 1\n      if current_count[s[left]] == 0\n        distinct_count -= 1\n      end\n      left += 1\n    end\n\n    current_window_len = right - left + 1\n    max_len = [max_len, current_window_len].max\n  end\n\n  max_len\nend\n\ndef process_test_cases(t, test_cases)\n  results = []\n  (0...t).each do |i|\n    k = test_cases[i][0]\n    s = test_cases[i][1]\n    results << longest_diverse_substring(k, s)\n  end\n  results\nend\ndef test_longest_diverse_substring()\n  test_cases = [\n    [2, \"abcba\"],\n    [3, \"abcd\"],\n    [1, \"aaaaa\"],\n    [2, \"eceba\"],\n    [3, \"aaabbbccc\"]\n  ]\n  expected_results = [3, 3, 5, 3, 9]\n\n  results = process_test_cases(test_cases.size, test_cases)\n\n  results.each_with_index do |result, index|\n    unless result == expected_results[index]\n      raise \"Test case #{index + 1} failed: Expected #{expected_results[index]}, got #{result}\"\n    end\n  end\n\n  puts \"All test cases passed!\"\nend\n\ntest_longest_diverse_substring()", "exec_outcome": "PASSED"}
{"code": "# Checks if a given block (row, column, or subgrid) contains any duplicate numbers other than 0.\n# @param block [Array<Integer>] The block to check\n# @return [Boolean] True if the block is valid, false otherwise\ndef is_valid_block(block)\n  nums = block.reject { |num| num == 0 }\n  nums.size == nums.uniq.size\nend\n\n# Validates a Sudoku grid by checking rows, columns, and subgrids.\n# @param grid [Array<Array<Integer>>] The Sudoku grid to validate\n# @return [Boolean] True if the grid is valid, false otherwise\ndef is_valid_sudoku(grid)\n  n = grid.size\n  sqrt_n = Math.sqrt(n).to_i\n\n  # Check each row\n  grid.each do |row|\n    return false unless is_valid_block(row)\n  end\n\n  # Check each column\n  grid.transpose.each do |col|\n    return false unless is_valid_block(col)\n  end\n\n  # Check each subgrid\n  (0...n).step(sqrt_n) do |i|\n    (0...n).step(sqrt_n) do |j|\n      block = []\n      (i...i + sqrt_n).each do |x|\n        (j...j + sqrt_n).each do |y|\n          block << grid[x][y]\n        end\n      end\n      return false unless is_valid_block(block)\n    end\n  end\n\n  true\nend\n\n# Processes multiple Sudoku puzzles and returns their validity.\n# @param puzzles [Array<Array<Array<Integer>>>] An array of Sudoku grids\n# @return [Array<Boolean>] An array indicating the validity of each puzzle\ndef solve_sudoku_puzzles(puzzles)\n  puzzles.map { |puzzle| is_valid_sudoku(puzzle) }\nend", "test_cases": "", "test_case_results": "Test Case 1:\nGrid:\n[5, 3, 0, 0, 7, 0, 0, 0, 0]\n[6, 0, 0, 1, 9, 5, 0, 0, 0]\n[0, 9, 8, 0, 0, 0, 0, 6, 0]\n[8, 0, 0, 0, 6, 0, 0, 0, 3]\n[4, 0, 0, 8, 0, 3, 0, 0, 1]\n[7, 0, 0, 0, 2, 0, 0, 0, 6]\n[0, 6, 0, 0, 0, 0, 2, 8, 0]\n[0, 0, 0, 4, 1, 9, 0, 0, 5]\n[0, 0, 0, 0, 8, 0, 0, 7, 9]\nIs valid? true\n\nTest Case 2:\nGrid:\n[5, 3, 0, 0, 7, 0, 0, 0, 0]\n[6, 0, 0, 1, 9, 5, 0, 0, 0]\n[0, 9, 8, 0, 0, 0, 0, 6, 0]\n[8, 0, 0, 0, 6, 0, 0, 0, 3]\n[4, 0, 0, 8, 0, 3, 0, 0, 1]\n[7, 0, 0, 0, 2, 0, 0, 0, 6]\n[0, 6, 0, 0, 0, 0, 2, 8, 0]\n[0, 0, 0, 4, 1, 9, 0, 0, 5]\n[0, 0, 0, 0, 8, 0, 0, 7, 5]\nIs valid? false\n\nTest Case 3:\nGrid:\n[1, 2, 3, 4]\n[3, 4, 1, 2]\n[2, 1, 4, 3]\n[4, 3, 2, 1]\nIs valid? true\n\nTesting solve_sudoku_puzzles with multiple puzzles:\nPuzzle 1 is valid\nPuzzle 2 is invalid\nPuzzle 3 is valid", "task_id": 12604, "assertions": "def test_sudoku_functions\n  test_grid1 = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n  ]\n  \n  test_grid2 = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 5]\n  ]\n  \n  test_grid3 = [\n    [1, 2, 3, 4],\n    [3, 4, 1, 2],\n    [2, 1, 4, 3],\n    [4, 3, 2, 1]\n  ]\n\n  # Test is_valid_sudoku\n  raise \"Test 1 failed\" unless is_valid_sudoku(test_grid1) == true\n  raise \"Test 2 failed\" unless is_valid_sudoku(test_grid2) == false\n  raise \"Test 3 failed\" unless is_valid_sudoku(test_grid3) == true\n\n  # Test solve_sudoku_puzzles\n  results = solve_sudoku_puzzles([test_grid1, test_grid2, test_grid3])\n  raise \"Test 4 failed\" unless results == [true, false, true]\n\n  puts \"All tests passed!\"\nend\n\ntest_sudoku_functions", "all_code": "# Checks if a given block (row, column, or subgrid) contains any duplicate numbers other than 0.\n# @param block [Array<Integer>] The block to check\n# @return [Boolean] True if the block is valid, false otherwise\ndef is_valid_block(block)\n  nums = block.reject { |num| num == 0 }\n  nums.size == nums.uniq.size\nend\n\n# Validates a Sudoku grid by checking rows, columns, and subgrids.\n# @param grid [Array<Array<Integer>>] The Sudoku grid to validate\n# @return [Boolean] True if the grid is valid, false otherwise\ndef is_valid_sudoku(grid)\n  n = grid.size\n  sqrt_n = Math.sqrt(n).to_i\n\n  # Check each row\n  grid.each do |row|\n    return false unless is_valid_block(row)\n  end\n\n  # Check each column\n  grid.transpose.each do |col|\n    return false unless is_valid_block(col)\n  end\n\n  # Check each subgrid\n  (0...n).step(sqrt_n) do |i|\n    (0...n).step(sqrt_n) do |j|\n      block = []\n      (i...i + sqrt_n).each do |x|\n        (j...j + sqrt_n).each do |y|\n          block << grid[x][y]\n        end\n      end\n      return false unless is_valid_block(block)\n    end\n  end\n\n  true\nend\n\n# Processes multiple Sudoku puzzles and returns their validity.\n# @param puzzles [Array<Array<Array<Integer>>>] An array of Sudoku grids\n# @return [Array<Boolean>] An array indicating the validity of each puzzle\ndef solve_sudoku_puzzles(puzzles)\n  puzzles.map { |puzzle| is_valid_sudoku(puzzle) }\nend\ndef test_sudoku_functions\n  test_grid1 = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n  ]\n  \n  test_grid2 = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 5]\n  ]\n  \n  test_grid3 = [\n    [1, 2, 3, 4],\n    [3, 4, 1, 2],\n    [2, 1, 4, 3],\n    [4, 3, 2, 1]\n  ]\n\n  # Test is_valid_sudoku\n  raise \"Test 1 failed\" unless is_valid_sudoku(test_grid1) == true\n  raise \"Test 2 failed\" unless is_valid_sudoku(test_grid2) == false\n  raise \"Test 3 failed\" unless is_valid_sudoku(test_grid3) == true\n\n  # Test solve_sudoku_puzzles\n  results = solve_sudoku_puzzles([test_grid1, test_grid2, test_grid3])\n  raise \"Test 4 failed\" unless results == [true, false, true]\n\n  puts \"All tests passed!\"\nend\n\ntest_sudoku_functions", "exec_outcome": "PASSED"}
{"code": "def find_min_cost_path(grid)\n  m = grid.size\n  n = grid[0].size\n\n  # Create a 2D array to store the minimum costs\n  cost = Array.new(m) { Array.new(n, 0) }\n\n  # Initialize the first cell with the grid's first cell value\n  cost[0][0] = grid[0][0]\n\n  # Initialize the first row (can only come from left)\n  (1...n).each do |j|\n    cost[0][j] = cost[0][j - 1] + grid[0][j]\n  end\n\n  # Initialize the first column (can only come from above)\n  (1...m).each do |i|\n    cost[i][0] = cost[i - 1][0] + grid[i][0]\n  end\n\n  # Fill in the rest of the cost grid\n  (1...m).each do |i|\n    (1...n).each do |j|\n      cost[i][j] = grid[i][j] + [cost[i - 1][j], cost[i][j - 1]].min\n    end\n  end\n\n  # The minimum cost to reach the bottom-right corner\n  cost[m - 1][n - 1]\nend", "test_cases": "", "test_case_results": "Test Case 1:\nInput Grid:\n[1, 3, 1]\n[1, 5, 1]\n[4, 2, 1]\nMinimum Cost Path: 7\n\nTest Case 2:\nInput Grid:\n[1, 2, 3]\n[4, 5, 6]\nMinimum Cost Path: 12\n\nTest Case 3:\nInput Grid:\n[1, 2]\n[1, 1]\nMinimum Cost Path: 3", "task_id": 12884, "assertions": "def test_find_min_cost_path()\n  test_cases = [\n    {\n      grid: [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n      ],\n      expected: 7\n    },\n    {\n      grid: [\n        [1, 2, 3],\n        [4, 5, 6]\n      ],\n      expected: 12\n    },\n    {\n      grid: [\n        [1, 2],\n        [1, 1]\n      ],\n      expected: 3\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_min_cost_path(test_case[:grid])\n    if result != test_case[:expected]\n      raise \"Test failed for grid #{test_case[:grid]}. Expected: #{test_case[:expected]}, Got: #{result}\"\n    end\n  end\n  puts \"All tests passed!\"\nend\n\ntest_find_min_cost_path()", "all_code": "def find_min_cost_path(grid)\n  m = grid.size\n  n = grid[0].size\n\n  # Create a 2D array to store the minimum costs\n  cost = Array.new(m) { Array.new(n, 0) }\n\n  # Initialize the first cell with the grid's first cell value\n  cost[0][0] = grid[0][0]\n\n  # Initialize the first row (can only come from left)\n  (1...n).each do |j|\n    cost[0][j] = cost[0][j - 1] + grid[0][j]\n  end\n\n  # Initialize the first column (can only come from above)\n  (1...m).each do |i|\n    cost[i][0] = cost[i - 1][0] + grid[i][0]\n  end\n\n  # Fill in the rest of the cost grid\n  (1...m).each do |i|\n    (1...n).each do |j|\n      cost[i][j] = grid[i][j] + [cost[i - 1][j], cost[i][j - 1]].min\n    end\n  end\n\n  # The minimum cost to reach the bottom-right corner\n  cost[m - 1][n - 1]\nend\ndef test_find_min_cost_path()\n  test_cases = [\n    {\n      grid: [\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n      ],\n      expected: 7\n    },\n    {\n      grid: [\n        [1, 2, 3],\n        [4, 5, 6]\n      ],\n      expected: 12\n    },\n    {\n      grid: [\n        [1, 2],\n        [1, 1]\n      ],\n      expected: 3\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = find_min_cost_path(test_case[:grid])\n    if result != test_case[:expected]\n      raise \"Test failed for grid #{test_case[:grid]}. Expected: #{test_case[:expected]}, Got: #{result}\"\n    end\n  end\n  puts \"All tests passed!\"\nend\n\ntest_find_min_cost_path()", "exec_outcome": "PASSED"}
{"code": "def min_value(expression)\n  dfs = lambda do |nums, ops|\n    return nums[0] if ops.empty?\n\n    min_val = Float::INFINITY\n    ops.each_with_index do |op, i|\n      left = dfs.call(nums[0..i], ops[0...i])\n      right = dfs.call(nums[i+1..-1], ops[i+1..-1])\n      current_val = op == '+' ? left + right : left * right\n      min_val = [min_val, current_val].min\n    end\n\n    min_val\n  end\n\n  nums = []\n  ops = []\n  i = 0\n  while i < expression.length\n    if expression[i] =~ /\\d/\n      num = 0\n      while i < expression.length && expression[i] =~ /\\d/\n        num = num * 10 + expression[i].to_i\n        i += 1\n      end\n      nums << num\n    else\n      ops << expression[i]\n      i += 1\n    end\n  end\n\n  dfs.call(nums, ops)\nend", "test_cases": "", "test_case_results": "Input: 1+2*3\nMinimum value: 7\nInput: 2*3+4\nMinimum value: 10\nInput: 1+1+1+1\nMinimum value: 4\nInput: 2*2*2*2\nMinimum value: 16\nInput: 1+2*3+4\nMinimum value: 11\nInput: 0*1+2\nMinimum value: 0", "task_id": 27535, "assertions": "def test_min_value()\n  raise unless min_value(\"1+2*3\") == 7\n  raise unless min_value(\"2*3+4\") == 10\n  raise unless min_value(\"1+1+1+1\") == 4\n  raise unless min_value(\"2*2*2*2\") == 16\n  raise unless min_value(\"1+2*3+4\") == 11\n  raise unless min_value(\"0*1+2\") == 0\nend\n\ntest_min_value()", "all_code": "def min_value(expression)\n  dfs = lambda do |nums, ops|\n    return nums[0] if ops.empty?\n\n    min_val = Float::INFINITY\n    ops.each_with_index do |op, i|\n      left = dfs.call(nums[0..i], ops[0...i])\n      right = dfs.call(nums[i+1..-1], ops[i+1..-1])\n      current_val = op == '+' ? left + right : left * right\n      min_val = [min_val, current_val].min\n    end\n\n    min_val\n  end\n\n  nums = []\n  ops = []\n  i = 0\n  while i < expression.length\n    if expression[i] =~ /\\d/\n      num = 0\n      while i < expression.length && expression[i] =~ /\\d/\n        num = num * 10 + expression[i].to_i\n        i += 1\n      end\n      nums << num\n    else\n      ops << expression[i]\n      i += 1\n    end\n  end\n\n  dfs.call(nums, ops)\nend\ndef test_min_value()\n  raise unless min_value(\"1+2*3\") == 7\n  raise unless min_value(\"2*3+4\") == 10\n  raise unless min_value(\"1+1+1+1\") == 4\n  raise unless min_value(\"2*2*2*2\") == 16\n  raise unless min_value(\"1+2*3+4\") == 11\n  raise unless min_value(\"0*1+2\") == 0\nend\n\ntest_min_value()", "exec_outcome": "PASSED"}
{"code": "# Determines if the array can be made strictly increasing by performing at most one swap.\n# The method first checks if the array is already strictly increasing.\n# If not, it tries all possible single swaps and checks if any of them result in a strictly increasing array.\n#\n# Arguments:\n# arr - Array of integers representing the array\n#\n# Returns:\n# 'YES' if it is possible to make the array strictly increasing by performing at most one swap, 'NO' otherwise.\ndef can_be_made_increasing_by_one_swap(arr)\n  n = arr.length\n\n  # Helper method to check if the array is strictly increasing\n  is_strictly_increasing = ->(seq) {\n    (1...seq.length).each do |i|\n      return false if seq[i] <= seq[i - 1]\n    end\n    true\n  }\n\n  return \"YES\" if is_strictly_increasing.call(arr)\n\n  (0...n).each do |i|\n    ((i + 1)...n).each do |j|\n      # Perform the swap\n      arr[i], arr[j] = arr[j], arr[i]\n      if is_strictly_increasing.call(arr)\n        # Undo the swap before returning\n        arr[i], arr[j] = arr[j], arr[i]\n        return \"YES\"\n      end\n      # Undo the swap\n      arr[i], arr[j] = arr[j], arr[i]\n    end\n  end\n\n  \"NO\"\nend", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nResult: YES\nInput: [1, 3, 2, 4]\nResult: YES\nInput: [1, 4, 3, 2]\nResult: YES\nInput: [1, 1, 1, 1]\nResult: NO\nInput: [1, 2, 4, 3, 5]\nResult: YES", "task_id": 27579, "assertions": "def test_can_be_made_increasing_by_one_swap()\n  raise \"Test case 1 failed\" unless can_be_made_increasing_by_one_swap([1, 2, 3, 4]) == \"YES\"\n  raise \"Test case 2 failed\" unless can_be_made_increasing_by_one_swap([1, 3, 2, 4]) == \"YES\"\n  raise \"Test case 3 failed\" unless can_be_made_increasing_by_one_swap([1, 4, 3, 2]) == \"YES\"\n  raise \"Test case 4 failed\" unless can_be_made_increasing_by_one_swap([1, 1, 1, 1]) == \"NO\"\n  raise \"Test case 5 failed\" unless can_be_made_increasing_by_one_swap([1, 2, 4, 3, 5]) == \"YES\"\n  puts \"All tests passed!\"\nend\n\ntest_can_be_made_increasing_by_one_swap()", "all_code": "# Determines if the array can be made strictly increasing by performing at most one swap.\n# The method first checks if the array is already strictly increasing.\n# If not, it tries all possible single swaps and checks if any of them result in a strictly increasing array.\n#\n# Arguments:\n# arr - Array of integers representing the array\n#\n# Returns:\n# 'YES' if it is possible to make the array strictly increasing by performing at most one swap, 'NO' otherwise.\ndef can_be_made_increasing_by_one_swap(arr)\n  n = arr.length\n\n  # Helper method to check if the array is strictly increasing\n  is_strictly_increasing = ->(seq) {\n    (1...seq.length).each do |i|\n      return false if seq[i] <= seq[i - 1]\n    end\n    true\n  }\n\n  return \"YES\" if is_strictly_increasing.call(arr)\n\n  (0...n).each do |i|\n    ((i + 1)...n).each do |j|\n      # Perform the swap\n      arr[i], arr[j] = arr[j], arr[i]\n      if is_strictly_increasing.call(arr)\n        # Undo the swap before returning\n        arr[i], arr[j] = arr[j], arr[i]\n        return \"YES\"\n      end\n      # Undo the swap\n      arr[i], arr[j] = arr[j], arr[i]\n    end\n  end\n\n  \"NO\"\nend\ndef test_can_be_made_increasing_by_one_swap()\n  raise \"Test case 1 failed\" unless can_be_made_increasing_by_one_swap([1, 2, 3, 4]) == \"YES\"\n  raise \"Test case 2 failed\" unless can_be_made_increasing_by_one_swap([1, 3, 2, 4]) == \"YES\"\n  raise \"Test case 3 failed\" unless can_be_made_increasing_by_one_swap([1, 4, 3, 2]) == \"YES\"\n  raise \"Test case 4 failed\" unless can_be_made_increasing_by_one_swap([1, 1, 1, 1]) == \"NO\"\n  raise \"Test case 5 failed\" unless can_be_made_increasing_by_one_swap([1, 2, 4, 3, 5]) == \"YES\"\n  puts \"All tests passed!\"\nend\n\ntest_can_be_made_increasing_by_one_swap()", "exec_outcome": "PASSED"}
{"code": "# This Ruby script implements a method to find the minimum sum path from the top-left to the bottom-right corner of a matrix.\n# The method uses dynamic programming to build a solution by accumulating the minimum path sums at each cell.\n\n# min_sum_path calculates the minimum sum path in a matrix from the top-left to the bottom-right corner.\n# It uses a dynamic programming approach where each cell in the DP table stores the minimum sum to reach that cell.\n# The method first checks for an empty matrix and returns 0 if found.\n# Then, it initializes the DP table and fills in the first row and column by accumulating the sums.\n# Finally, it fills in the rest of the table by taking the minimum of the top or left cell and adding the current cell's value.\n# The result is the value in the bottom-right corner of the DP table.\ndef min_sum_path(mat)\n  return 0 if mat.empty? || mat[0].empty?\n\n  n = mat.size\n  m = mat[0].size\n\n  dp = Array.new(n) { Array.new(m, 0) }\n  dp[0][0] = mat[0][0]\n\n  # Fill the first column\n  (1...n).each do |i|\n    dp[i][0] = dp[i-1][0] + mat[i][0]\n  end\n\n  # Fill the first row\n  (1...m).each do |j|\n    dp[0][j] = dp[0][j-1] + mat[0][j]\n  end\n\n  # Fill the rest of the table\n  (1...n).each do |i|\n    (1...m).each do |j|\n      dp[i][j] = [dp[i-1][j], dp[i][j-1]].min + mat[i][j]\n    end\n  end\n\n  dp[-1][-1]\nend", "test_cases": "", "test_case_results": "Input matrix: [[1, 3, 1], [1, 5, 1], [4, 2, 1]]\nMinimum sum path: 7\nInput matrix: [[1, 2, 3], [4, 5, 6]]\nMinimum sum path: 12\nInput matrix: []\nMinimum sum path: 0\nInput matrix: [[]]\nMinimum sum path: 0\nInput matrix: [[7]]\nMinimum sum path: 7", "task_id": 15002, "assertions": "def test_min_sum_path()\n  raise unless min_sum_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7\n  raise unless min_sum_path([[1, 2, 3], [4, 5, 6]]) == 12\n  raise unless min_sum_path([]) == 0\n  raise unless min_sum_path([[]]) == 0\n  raise unless min_sum_path([[7]]) == 7\nend\n\ntest_min_sum_path()", "all_code": "# This Ruby script implements a method to find the minimum sum path from the top-left to the bottom-right corner of a matrix.\n# The method uses dynamic programming to build a solution by accumulating the minimum path sums at each cell.\n\n# min_sum_path calculates the minimum sum path in a matrix from the top-left to the bottom-right corner.\n# It uses a dynamic programming approach where each cell in the DP table stores the minimum sum to reach that cell.\n# The method first checks for an empty matrix and returns 0 if found.\n# Then, it initializes the DP table and fills in the first row and column by accumulating the sums.\n# Finally, it fills in the rest of the table by taking the minimum of the top or left cell and adding the current cell's value.\n# The result is the value in the bottom-right corner of the DP table.\ndef min_sum_path(mat)\n  return 0 if mat.empty? || mat[0].empty?\n\n  n = mat.size\n  m = mat[0].size\n\n  dp = Array.new(n) { Array.new(m, 0) }\n  dp[0][0] = mat[0][0]\n\n  # Fill the first column\n  (1...n).each do |i|\n    dp[i][0] = dp[i-1][0] + mat[i][0]\n  end\n\n  # Fill the first row\n  (1...m).each do |j|\n    dp[0][j] = dp[0][j-1] + mat[0][j]\n  end\n\n  # Fill the rest of the table\n  (1...n).each do |i|\n    (1...m).each do |j|\n      dp[i][j] = [dp[i-1][j], dp[i][j-1]].min + mat[i][j]\n    end\n  end\n\n  dp[-1][-1]\nend\ndef test_min_sum_path()\n  raise unless min_sum_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7\n  raise unless min_sum_path([[1, 2, 3], [4, 5, 6]]) == 12\n  raise unless min_sum_path([]) == 0\n  raise unless min_sum_path([[]]) == 0\n  raise unless min_sum_path([[7]]) == 7\nend\n\ntest_min_sum_path()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef max_points_of_interest(n, m, points, connections)\n  adj_list = Hash.new { |h, k| h[k] = [] }\n\n  connections.each do |u, v|\n    adj_list[u] << v\n    adj_list[v] << u\n  end\n\n  visited = Array.new(n + 1, false)\n  max_poi = 0\n\n  (1..n).each do |city|\n    unless visited[city]\n      queue = [city]\n      visited[city] = true\n      total_points = points[city - 1]\n\n      while !queue.empty?\n        node = queue.shift\n        adj_list[node].each do |neighbor|\n          unless visited[neighbor]\n            visited[neighbor] = true\n            total_points += points[neighbor - 1]\n            queue << neighbor\n          end\n        end\n      end\n\n      max_poi = [max_poi, total_points].max\n    end\n  end\n\n  max_poi\nend", "test_cases": "", "test_case_results": "Test Case: Two connected components: [6,2,5] and [3,8]\nN (Cities): 5, M (Connections): 3\nPoints: [6, 2, 5, 3, 8]\nConnections: [[1, 2], [2, 3], [4, 5]]\nMax Points of Interest: 13\n--------------------------------------------------\nTest Case: Two connected components: [1,2] and [3,4]\nN (Cities): 4, M (Connections): 2\nPoints: [1, 2, 3, 4]\nConnections: [[1, 2], [3, 4]]\nMax Points of Interest: 7\n--------------------------------------------------\nTest Case: Single connected component: [10,20,30,40,50,60]\nN (Cities): 6, M (Connections): 5\nPoints: [10, 20, 30, 40, 50, 60]\nConnections: [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\nMax Points of Interest: 210\n--------------------------------------------------\nTest Case: No connections; each city is its own component\nN (Cities): 3, M (Connections): 0\nPoints: [5, 10, 15]\nConnections: []\nMax Points of Interest: 15\n--------------------------------------------------", "task_id": 22578, "assertions": "def test_max_points_of_interest\n  # Test case 1: Two connected components: [6,2,5] and [3,8]\n  raise \"Test case 1 failed\" unless max_points_of_interest(5, 3, [6, 2, 5, 3, 8], [[1, 2], [2, 3], [4, 5]]) == 13\n\n  # Test case 2: Two connected components: [1,2] and [3,4]\n  raise \"Test case 2 failed\" unless max_points_of_interest(4, 2, [1, 2, 3, 4], [[1, 2], [3, 4]]) == 7\n\n  # Test case 3: Single connected component: [10,20,30,40,50,60]\n  raise \"Test case 3 failed\" unless max_points_of_interest(6, 5, [10, 20, 30, 40, 50, 60], [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) == 210\n\n  # Test case 4: No connections; each city is its own component\n  raise \"Test case 4 failed\" unless max_points_of_interest(3, 0, [5, 10, 15], []) == 15\n\n  puts \"All test cases passed!\"\nend\n\ntest_max_points_of_interest", "all_code": "require 'set'\n\ndef max_points_of_interest(n, m, points, connections)\n  adj_list = Hash.new { |h, k| h[k] = [] }\n\n  connections.each do |u, v|\n    adj_list[u] << v\n    adj_list[v] << u\n  end\n\n  visited = Array.new(n + 1, false)\n  max_poi = 0\n\n  (1..n).each do |city|\n    unless visited[city]\n      queue = [city]\n      visited[city] = true\n      total_points = points[city - 1]\n\n      while !queue.empty?\n        node = queue.shift\n        adj_list[node].each do |neighbor|\n          unless visited[neighbor]\n            visited[neighbor] = true\n            total_points += points[neighbor - 1]\n            queue << neighbor\n          end\n        end\n      end\n\n      max_poi = [max_poi, total_points].max\n    end\n  end\n\n  max_poi\nend\ndef test_max_points_of_interest\n  # Test case 1: Two connected components: [6,2,5] and [3,8]\n  raise \"Test case 1 failed\" unless max_points_of_interest(5, 3, [6, 2, 5, 3, 8], [[1, 2], [2, 3], [4, 5]]) == 13\n\n  # Test case 2: Two connected components: [1,2] and [3,4]\n  raise \"Test case 2 failed\" unless max_points_of_interest(4, 2, [1, 2, 3, 4], [[1, 2], [3, 4]]) == 7\n\n  # Test case 3: Single connected component: [10,20,30,40,50,60]\n  raise \"Test case 3 failed\" unless max_points_of_interest(6, 5, [10, 20, 30, 40, 50, 60], [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) == 210\n\n  # Test case 4: No connections; each city is its own component\n  raise \"Test case 4 failed\" unless max_points_of_interest(3, 0, [5, 10, 15], []) == 15\n\n  puts \"All test cases passed!\"\nend\n\ntest_max_points_of_interest", "exec_outcome": "PASSED"}
{"code": "# Determines if the sequence can be rearranged to be symmetric around a pivot.\n# The method checks if the left part of the sequence (before the pivot) and the right part (after the pivot)\n# can be rearranged to be mirror images of each other by comparing their sorted versions.\n#\n# @param t [Integer] The number of test cases (unused in the method, but kept for compatibility with the original code)\n# @param test_cases [Array<Array>] An array of test cases, where each test case is an array containing:\n#   - n [Integer] The length of the sequence.\n#   - pivot [Integer] The pivot index.\n#   - seq [Array<Integer>] The sequence of integers.\n# @return [Array<String>] An array of \"YES\" or \"NO\" strings indicating if each sequence can be rearranged symmetrically.\ndef is_symmetric_possible(t, test_cases)\n  results = []\n  test_cases.each do |n, pivot, seq|\n    left_part = seq[0...pivot]\n    right_part = seq[pivot+1...n]\n    \n    if left_part.sort == right_part.sort\n      results << \"YES\"\n    else\n      results << \"NO\"\n    end\n  end\n  results\nend", "test_cases": "", "test_case_results": "Input sequence: [1, 2, 3, 2, 1], Pivot index: 2\nCan be rearranged symmetrically? YES\nInput sequence: [1, 2, 3, 4, 3, 2], Pivot index: 3\nCan be rearranged symmetrically? NO\nInput sequence: [1, 2, 3, 4, 5], Pivot index: 4\nCan be rearranged symmetrically? NO", "task_id": 10968, "assertions": "def test_is_symmetric_possible()\n  test_cases = [\n    [5, 2, [1, 2, 3, 2, 1]],\n    [6, 3, [1, 2, 3, 4, 3, 2]],\n    [5, 4, [1, 2, 3, 4, 5]]\n  ]\n  \n  expected_results = [\"YES\", \"NO\", \"NO\"]\n  \n  results = is_symmetric_possible(3, test_cases)\n  \n  raise \"Test case 1 failed\" unless results[0] == expected_results[0]\n  raise \"Test case 2 failed\" unless results[1] == expected_results[1]\n  raise \"Test case 3 failed\" unless results[2] == expected_results[2]\n  \n  puts \"All tests passed!\"\nend\n\ntest_is_symmetric_possible()", "all_code": "# Determines if the sequence can be rearranged to be symmetric around a pivot.\n# The method checks if the left part of the sequence (before the pivot) and the right part (after the pivot)\n# can be rearranged to be mirror images of each other by comparing their sorted versions.\n#\n# @param t [Integer] The number of test cases (unused in the method, but kept for compatibility with the original code)\n# @param test_cases [Array<Array>] An array of test cases, where each test case is an array containing:\n#   - n [Integer] The length of the sequence.\n#   - pivot [Integer] The pivot index.\n#   - seq [Array<Integer>] The sequence of integers.\n# @return [Array<String>] An array of \"YES\" or \"NO\" strings indicating if each sequence can be rearranged symmetrically.\ndef is_symmetric_possible(t, test_cases)\n  results = []\n  test_cases.each do |n, pivot, seq|\n    left_part = seq[0...pivot]\n    right_part = seq[pivot+1...n]\n    \n    if left_part.sort == right_part.sort\n      results << \"YES\"\n    else\n      results << \"NO\"\n    end\n  end\n  results\nend\ndef test_is_symmetric_possible()\n  test_cases = [\n    [5, 2, [1, 2, 3, 2, 1]],\n    [6, 3, [1, 2, 3, 4, 3, 2]],\n    [5, 4, [1, 2, 3, 4, 5]]\n  ]\n  \n  expected_results = [\"YES\", \"NO\", \"NO\"]\n  \n  results = is_symmetric_possible(3, test_cases)\n  \n  raise \"Test case 1 failed\" unless results[0] == expected_results[0]\n  raise \"Test case 2 failed\" unless results[1] == expected_results[1]\n  raise \"Test case 3 failed\" unless results[2] == expected_results[2]\n  \n  puts \"All tests passed!\"\nend\n\ntest_is_symmetric_possible()", "exec_outcome": "PASSED"}
{"code": "# shift_elements returns a new array where each element of the given array is shifted to the right by k positions.\n# If the shift leads to the end of the array, it wraps around to the beginning.\n# For an empty array, it returns an empty array.\n# The method uses modulo operation to handle shifts larger than the array size.\ndef shift_elements(arr, k)\n  return [] if arr.empty?\n  n = arr.size\n  k = k % n  # Handle shifts larger than array size by using modulo\n  arr[-k..-1] + arr[0...-k]\nend", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4], Shift: 1\nShifted array: [4, 1, 2, 3]\nInput array: [1, 2, 3, 4, 5], Shift: 3\nShifted array: [3, 4, 5, 1, 2]\nInput array: [1, 2, 3], Shift: 0\nShifted array: [1, 2, 3]\nInput array: [], Shift: 2\nShifted array: []\nInput array: [1, 2, 3, 4], Shift: 4\nShifted array: [1, 2, 3, 4]", "task_id": 5955, "assertions": "def test_shift_elements()\n  raise \"Test case 1 failed\" unless shift_elements([1, 2, 3, 4], 1) == [4, 1, 2, 3]\n  raise \"Test case 2 failed\" unless shift_elements([1, 2, 3, 4, 5], 3) == [3, 4, 5, 1, 2]\n  raise \"Test case 3 failed\" unless shift_elements([1, 2, 3], 0) == [1, 2, 3]\n  raise \"Test case 4 failed\" unless shift_elements([], 2) == []\n  raise \"Test case 5 failed\" unless shift_elements([1, 2, 3, 4], 4) == [1, 2, 3, 4]\n  puts \"All tests passed!\"\nend\n\ntest_shift_elements()", "all_code": "# shift_elements returns a new array where each element of the given array is shifted to the right by k positions.\n# If the shift leads to the end of the array, it wraps around to the beginning.\n# For an empty array, it returns an empty array.\n# The method uses modulo operation to handle shifts larger than the array size.\ndef shift_elements(arr, k)\n  return [] if arr.empty?\n  n = arr.size\n  k = k % n  # Handle shifts larger than array size by using modulo\n  arr[-k..-1] + arr[0...-k]\nend\ndef test_shift_elements()\n  raise \"Test case 1 failed\" unless shift_elements([1, 2, 3, 4], 1) == [4, 1, 2, 3]\n  raise \"Test case 2 failed\" unless shift_elements([1, 2, 3, 4, 5], 3) == [3, 4, 5, 1, 2]\n  raise \"Test case 3 failed\" unless shift_elements([1, 2, 3], 0) == [1, 2, 3]\n  raise \"Test case 4 failed\" unless shift_elements([], 2) == []\n  raise \"Test case 5 failed\" unless shift_elements([1, 2, 3, 4], 4) == [1, 2, 3, 4]\n  puts \"All tests passed!\"\nend\n\ntest_shift_elements()", "exec_outcome": "PASSED"}
{"code": "# smallest_nice_substring finds the length of the smallest substring in 's' that contains at least 'k' distinct characters.\n# If no such substring exists, it returns -1.\n#\n# @param s [String] the input string to search within\n# @param k [Integer] the minimum number of distinct characters required in the substring\n# @return [Integer] the length of the smallest substring with at least 'k' distinct characters, or -1 if none exists\ndef smallest_nice_substring(s, k)\n  return -1 if k > s.length\n\n  n = s.length\n  ans = Float::INFINITY\n\n  (0...n).each do |start|\n    char_count = {}\n    (start...n).each do |end_idx|\n      char = s[end_idx]\n      char_count[char] = char_count.fetch(char, 0) + 1\n\n      if char_count.size >= k\n        current_length = end_idx - start + 1\n        ans = [ans, current_length].min\n        break\n      end\n    end\n  end\n\n  ans != Float::INFINITY ? ans : -1\nend", "test_cases": "", "test_case_results": "Input: s = 'abc', k = 2\nResult: 2\n\nInput: s = 'aaab', k = 2\nResult: 2\n\nInput: s = 'abcdef', k = 10\nResult: -1\n\nInput: s = 'aabacbebebe', k = 3\nResult: 3\n\nInput: s = 'aaaa', k = 1\nResult: 1", "task_id": 9708, "assertions": "def test_smallest_nice_substring()\n  raise \"Test case 1 failed\" unless smallest_nice_substring(\"abc\", 2) == 2\n  raise \"Test case 2 failed\" unless smallest_nice_substring(\"aaab\", 2) == 2\n  raise \"Test case 3 failed\" unless smallest_nice_substring(\"abcdef\", 10) == -1\n  raise \"Test case 4 failed\" unless smallest_nice_substring(\"aabacbebebe\", 3) == 3\n  raise \"Test case 5 failed\" unless smallest_nice_substring(\"aaaa\", 1) == 1\n  puts \"All test cases passed!\"\nend\n\ntest_smallest_nice_substring()", "all_code": "# smallest_nice_substring finds the length of the smallest substring in 's' that contains at least 'k' distinct characters.\n# If no such substring exists, it returns -1.\n#\n# @param s [String] the input string to search within\n# @param k [Integer] the minimum number of distinct characters required in the substring\n# @return [Integer] the length of the smallest substring with at least 'k' distinct characters, or -1 if none exists\ndef smallest_nice_substring(s, k)\n  return -1 if k > s.length\n\n  n = s.length\n  ans = Float::INFINITY\n\n  (0...n).each do |start|\n    char_count = {}\n    (start...n).each do |end_idx|\n      char = s[end_idx]\n      char_count[char] = char_count.fetch(char, 0) + 1\n\n      if char_count.size >= k\n        current_length = end_idx - start + 1\n        ans = [ans, current_length].min\n        break\n      end\n    end\n  end\n\n  ans != Float::INFINITY ? ans : -1\nend\ndef test_smallest_nice_substring()\n  raise \"Test case 1 failed\" unless smallest_nice_substring(\"abc\", 2) == 2\n  raise \"Test case 2 failed\" unless smallest_nice_substring(\"aaab\", 2) == 2\n  raise \"Test case 3 failed\" unless smallest_nice_substring(\"abcdef\", 10) == -1\n  raise \"Test case 4 failed\" unless smallest_nice_substring(\"aabacbebebe\", 3) == 3\n  raise \"Test case 5 failed\" unless smallest_nice_substring(\"aaaa\", 1) == 1\n  puts \"All test cases passed!\"\nend\n\ntest_smallest_nice_substring()", "exec_outcome": "PASSED"}
{"code": "# Implementation of a segment tree for range sum queries and point updates.\n# The segment tree allows efficient computation of range sums and updates in logarithmic time.\nclass RangeQueries\n  # Initializes the segment tree with the given array.\n  # @param array [Array<Integer>] the input array to build the segment tree from\n  def initialize(array)\n    @array = array\n    @n = array.size\n    @tree = Array.new(2 * @n, 0)\n    build\n  end\n\n  # Builds the segment tree.\n  # The tree is stored in an array where the leaves are the original array elements,\n  # and each internal node is the sum of its children.\n  def build\n    # Initialize leaves\n    (0...@n).each do |i|\n      @tree[@n + i] = @array[i]\n    end\n    # Build internal nodes\n    (@n - 1).downto(1) do |i|\n      @tree[i] = @tree[2 * i] + @tree[2 * i + 1]\n    end\n  end\n\n  # Updates the value at a specific position in the original array and updates the segment tree.\n  # @param pos [Integer] the position in the original array to update (0-based index)\n  # @param value [Integer] the new value\n  def update(pos, value)\n    pos += @n\n    @tree[pos] = value\n    while pos > 1\n      pos /= 2\n      @tree[pos] = @tree[2 * pos] + @tree[2 * pos + 1]\n    end\n  end\n\n  # Computes the sum of elements in the range [l, r] in the original array.\n  # @param l [Integer] the left boundary of the range (0-based index)\n  # @param r [Integer] the right boundary of the range (0-based index)\n  # @return [Integer] the sum of elements in the range [l, r]\n  def sum(l, r)\n    l += @n\n    r += @n\n    sum = 0\n    while l <= r\n      if l % 2 == 1\n        sum += @tree[l]\n        l += 1\n      end\n      if r % 2 == 0\n        sum += @tree[r]\n        r -= 1\n      end\n      l /= 2\n      r /= 2\n    end\n    sum\n  end\nend", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4, 5]\nSum from index 1 to 3: 9\nSum from index 0 to 4: 15\nAfter updating index 2 to 10, sum from 1 to 3: 16\n\nInput array: [0, 0, 0, 0, 0]\nSum from index 1 to 3: 0\nSum from index 0 to 4: 0\nAfter updating index 2 to 10, sum from 1 to 3: 10\n\nInput array: [-1, -2, -3, -4, -5]\nSum from index 1 to 3: -9\nSum from index 0 to 4: -15\nAfter updating index 2 to 10, sum from 1 to 3: 4", "task_id": 2801, "assertions": "def test_range_queries()\n  # Test case 1: Simple array with sequential numbers\n  rq1 = RangeQueries.new([1, 2, 3, 4, 5])\n  raise \"Test case 1 failed: sum(1, 3)\" unless rq1.sum(1, 3) == 9\n  raise \"Test case 1 failed: sum(0, 4)\" unless rq1.sum(0, 4) == 15\n  rq1.update(2, 10)\n  raise \"Test case 1 failed: update and sum(1, 3)\" unless rq1.sum(1, 3) == 16\n\n  # Test case 2: Array with all zeros\n  rq2 = RangeQueries.new([0, 0, 0, 0, 0])\n  raise \"Test case 2 failed: sum(1, 3)\" unless rq2.sum(1, 3) == 0\n  raise \"Test case 2 failed: sum(0, 4)\" unless rq2.sum(0, 4) == 0\n  rq2.update(2, 10)\n  raise \"Test case 2 failed: update and sum(1, 3)\" unless rq2.sum(1, 3) == 10\n\n  # Test case 3: Array with negative numbers\n  rq3 = RangeQueries.new([-1, -2, -3, -4, -5])\n  raise \"Test case 3 failed: sum(1, 3)\" unless rq3.sum(1, 3) == -9\n  raise \"Test case 3 failed: sum(0, 4)\" unless rq3.sum(0, 4) == -15\n  rq3.update(2, 10)\n  raise \"Test case 3 failed: update and sum(1, 3)\" unless rq3.sum(1, 3) == 4\n\n  puts \"All test cases passed!\"\nend\n\ntest_range_queries()", "all_code": "# Implementation of a segment tree for range sum queries and point updates.\n# The segment tree allows efficient computation of range sums and updates in logarithmic time.\nclass RangeQueries\n  # Initializes the segment tree with the given array.\n  # @param array [Array<Integer>] the input array to build the segment tree from\n  def initialize(array)\n    @array = array\n    @n = array.size\n    @tree = Array.new(2 * @n, 0)\n    build\n  end\n\n  # Builds the segment tree.\n  # The tree is stored in an array where the leaves are the original array elements,\n  # and each internal node is the sum of its children.\n  def build\n    # Initialize leaves\n    (0...@n).each do |i|\n      @tree[@n + i] = @array[i]\n    end\n    # Build internal nodes\n    (@n - 1).downto(1) do |i|\n      @tree[i] = @tree[2 * i] + @tree[2 * i + 1]\n    end\n  end\n\n  # Updates the value at a specific position in the original array and updates the segment tree.\n  # @param pos [Integer] the position in the original array to update (0-based index)\n  # @param value [Integer] the new value\n  def update(pos, value)\n    pos += @n\n    @tree[pos] = value\n    while pos > 1\n      pos /= 2\n      @tree[pos] = @tree[2 * pos] + @tree[2 * pos + 1]\n    end\n  end\n\n  # Computes the sum of elements in the range [l, r] in the original array.\n  # @param l [Integer] the left boundary of the range (0-based index)\n  # @param r [Integer] the right boundary of the range (0-based index)\n  # @return [Integer] the sum of elements in the range [l, r]\n  def sum(l, r)\n    l += @n\n    r += @n\n    sum = 0\n    while l <= r\n      if l % 2 == 1\n        sum += @tree[l]\n        l += 1\n      end\n      if r % 2 == 0\n        sum += @tree[r]\n        r -= 1\n      end\n      l /= 2\n      r /= 2\n    end\n    sum\n  end\nend\ndef test_range_queries()\n  # Test case 1: Simple array with sequential numbers\n  rq1 = RangeQueries.new([1, 2, 3, 4, 5])\n  raise \"Test case 1 failed: sum(1, 3)\" unless rq1.sum(1, 3) == 9\n  raise \"Test case 1 failed: sum(0, 4)\" unless rq1.sum(0, 4) == 15\n  rq1.update(2, 10)\n  raise \"Test case 1 failed: update and sum(1, 3)\" unless rq1.sum(1, 3) == 16\n\n  # Test case 2: Array with all zeros\n  rq2 = RangeQueries.new([0, 0, 0, 0, 0])\n  raise \"Test case 2 failed: sum(1, 3)\" unless rq2.sum(1, 3) == 0\n  raise \"Test case 2 failed: sum(0, 4)\" unless rq2.sum(0, 4) == 0\n  rq2.update(2, 10)\n  raise \"Test case 2 failed: update and sum(1, 3)\" unless rq2.sum(1, 3) == 10\n\n  # Test case 3: Array with negative numbers\n  rq3 = RangeQueries.new([-1, -2, -3, -4, -5])\n  raise \"Test case 3 failed: sum(1, 3)\" unless rq3.sum(1, 3) == -9\n  raise \"Test case 3 failed: sum(0, 4)\" unless rq3.sum(0, 4) == -15\n  rq3.update(2, 10)\n  raise \"Test case 3 failed: update and sum(1, 3)\" unless rq3.sum(1, 3) == 4\n\n  puts \"All test cases passed!\"\nend\n\ntest_range_queries()", "exec_outcome": "PASSED"}
{"code": "# Require the 'securerandom' library to generate a random target number securely.\nrequire 'securerandom'\n\n# number_guessing_game simulates a two-player number guessing game.\n# Each player takes turns to guess a randomly generated target number between 1 and 100.\n# The game runs for a maximum of 10 turns per player.\n# The player who guesses the number correctly in the fewest attempts wins.\n# If both players guess correctly in the same number of attempts, the player whose total guesses are closer to the target number wins.\ndef number_guessing_game\n  target_number = SecureRandom.random_number(1..100)\n  player_turns = 10\n  player1_score = 0\n  player2_score = 0\n  player1_guesses = []\n  player2_guesses = []\n\n  player_turns.times do |turn|\n    # Player 1's turn\n    puts \"Player 1, Turn #{turn + 1}: Enter your guess: \"\n    player1_guess = gets.chomp.to_i\n    player1_guesses << player1_guess\n    if player1_guess == target_number\n      player1_score += 1\n      puts \"Player 1 guessed correctly in #{player1_guesses.size} guesses!\"\n      break\n    elsif player1_guess < target_number\n      puts \"Player 1, your guess is too low.\"\n    else\n      puts \"Player 1, your guess is too high.\"\n    end\n\n    # Player 2's turn\n    puts \"Player 2, Turn #{turn + 1}: Enter your guess: \"\n    player2_guess = gets.chomp.to_i\n    player2_guesses << player2_guess\n    if player2_guess == target_number\n      player2_score += 1\n      puts \"Player 2 guessed correctly in #{player2_guesses.size} guesses!\"\n      break\n    elsif player2_guess < target_number\n      puts \"Player 2, your guess is too low.\"\n    else\n      puts \"Player 2, your guess is too high.\"\n    end\n  end\n\n  if player1_score > player2_score\n    puts \"Player 1 wins!\"\n  elsif player2_score > player1_score\n    puts \"Player 2 wins!\"\n  else\n    player1_diff = (player1_guesses.sum - target_number * player1_guesses.size).abs\n    player2_diff = (player2_guesses.sum - target_number * player2_guesses.size).abs\n    if player1_diff < player2_diff\n      puts \"Player 1 guessed closer to the target number in total attempts. Player 1 wins!\"\n    else\n      puts \"Player 2 guessed closer to the target number in total attempts. Player 2 wins!\"\n    end\n  end\nend", "test_cases": "", "test_case_results": "Test case: Player 1 guesses [50, 75, 88, 94, 97, 99, 100], Player 2 guesses [25, 50, 75, 88, 94, 97, 99, 100]\nThis is a simulation. In a real test, the game would run with these guesses.\nTest case: Player 1 guesses [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], Player 2 guesses [5, 15, 25, 35, 45, 55, 65, 75, 85, 95]\nThis is a simulation. In a real test, the game would run with these guesses.\nTest case: Player 1 guesses [1, 2, 3, 4, 5], Player 2 guesses [100, 99, 98, 97, 96]\nThis is a simulation. In a real test, the game would run with these guesses.", "task_id": 9791, "assertions": "require 'securerandom'\n\ndef test_number_guessing_game\n  # Mock SecureRandom to return a fixed target number for testing\n  target_number = 50\n  allow(SecureRandom).to receive(:random_number).and_return(target_number)\n\n  # Test case 1: Player 1 wins by guessing correctly in fewer attempts\n  player1_guesses = [40, 60, 50]\n  player2_guesses = [30, 70, 80, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 1 failed\" unless result == \"Player 1 wins!\"\n\n  # Test case 2: Player 2 wins by guessing correctly in fewer attempts\n  player1_guesses = [20, 40, 60, 80, 50]\n  player2_guesses = [30, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 2 failed\" unless result == \"Player 2 wins!\"\n\n  # Test case 3: Tiebreaker - Player 1 wins by being closer in total attempts\n  player1_guesses = [40, 50]\n  player2_guesses = [60, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 3 failed\" unless result.include?(\"Player 1 guessed closer\")\n\n  puts \"All test cases passed!\"\nend\n\n# Helper method to simulate the game with predefined guesses\ndef number_guessing_game(player1_guesses, player2_guesses, target_number)\n  player1_score = 0\n  player2_score = 0\n  player1_attempts = []\n  player2_attempts = []\n\n  [player1_guesses.size, player2_guesses.size].max.times do |i|\n    # Player 1's turn\n    if i < player1_guesses.size\n      guess = player1_guesses[i]\n      player1_attempts << guess\n      if guess == target_number\n        player1_score = 1\n        break\n      end\n    end\n\n    # Player 2's turn\n    if i < player2_guesses.size\n      guess = player2_guesses[i]\n      player2_attempts << guess\n      if guess == target_number\n        player2_score = 1\n        break\n      end\n    end\n  end\n\n  if player1_score > player2_score\n    \"Player 1 wins!\"\n  elsif player2_score > player1_score\n    \"Player 2 wins!\"\n  else\n    player1_diff = (player1_attempts.sum - target_number * player1_attempts.size).abs\n    player2_diff = (player2_attempts.sum - target_number * player2_attempts.size).abs\n    if player1_diff < player2_diff\n      \"Player 1 guessed closer to the target number in total attempts. Player 1 wins!\"\n    else\n      \"Player 2 guessed closer to the target number in total attempts. Player 2 wins!\"\n    end\n  end\nend\n\ntest_number_guessing_game", "all_code": "# Require the 'securerandom' library to generate a random target number securely.\nrequire 'securerandom'\n\n# number_guessing_game simulates a two-player number guessing game.\n# Each player takes turns to guess a randomly generated target number between 1 and 100.\n# The game runs for a maximum of 10 turns per player.\n# The player who guesses the number correctly in the fewest attempts wins.\n# If both players guess correctly in the same number of attempts, the player whose total guesses are closer to the target number wins.\ndef number_guessing_game\n  target_number = SecureRandom.random_number(1..100)\n  player_turns = 10\n  player1_score = 0\n  player2_score = 0\n  player1_guesses = []\n  player2_guesses = []\n\n  player_turns.times do |turn|\n    # Player 1's turn\n    puts \"Player 1, Turn #{turn + 1}: Enter your guess: \"\n    player1_guess = gets.chomp.to_i\n    player1_guesses << player1_guess\n    if player1_guess == target_number\n      player1_score += 1\n      puts \"Player 1 guessed correctly in #{player1_guesses.size} guesses!\"\n      break\n    elsif player1_guess < target_number\n      puts \"Player 1, your guess is too low.\"\n    else\n      puts \"Player 1, your guess is too high.\"\n    end\n\n    # Player 2's turn\n    puts \"Player 2, Turn #{turn + 1}: Enter your guess: \"\n    player2_guess = gets.chomp.to_i\n    player2_guesses << player2_guess\n    if player2_guess == target_number\n      player2_score += 1\n      puts \"Player 2 guessed correctly in #{player2_guesses.size} guesses!\"\n      break\n    elsif player2_guess < target_number\n      puts \"Player 2, your guess is too low.\"\n    else\n      puts \"Player 2, your guess is too high.\"\n    end\n  end\n\n  if player1_score > player2_score\n    puts \"Player 1 wins!\"\n  elsif player2_score > player1_score\n    puts \"Player 2 wins!\"\n  else\n    player1_diff = (player1_guesses.sum - target_number * player1_guesses.size).abs\n    player2_diff = (player2_guesses.sum - target_number * player2_guesses.size).abs\n    if player1_diff < player2_diff\n      puts \"Player 1 guessed closer to the target number in total attempts. Player 1 wins!\"\n    else\n      puts \"Player 2 guessed closer to the target number in total attempts. Player 2 wins!\"\n    end\n  end\nend\nrequire 'securerandom'\n\ndef test_number_guessing_game\n  # Mock SecureRandom to return a fixed target number for testing\n  target_number = 50\n  allow(SecureRandom).to receive(:random_number).and_return(target_number)\n\n  # Test case 1: Player 1 wins by guessing correctly in fewer attempts\n  player1_guesses = [40, 60, 50]\n  player2_guesses = [30, 70, 80, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 1 failed\" unless result == \"Player 1 wins!\"\n\n  # Test case 2: Player 2 wins by guessing correctly in fewer attempts\n  player1_guesses = [20, 40, 60, 80, 50]\n  player2_guesses = [30, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 2 failed\" unless result == \"Player 2 wins!\"\n\n  # Test case 3: Tiebreaker - Player 1 wins by being closer in total attempts\n  player1_guesses = [40, 50]\n  player2_guesses = [60, 50]\n  result = number_guessing_game(player1_guesses, player2_guesses, target_number)\n  raise \"Test case 3 failed\" unless result.include?(\"Player 1 guessed closer\")\n\n  puts \"All test cases passed!\"\nend\n\n# Helper method to simulate the game with predefined guesses\ndef number_guessing_game(player1_guesses, player2_guesses, target_number)\n  player1_score = 0\n  player2_score = 0\n  player1_attempts = []\n  player2_attempts = []\n\n  [player1_guesses.size, player2_guesses.size].max.times do |i|\n    # Player 1's turn\n    if i < player1_guesses.size\n      guess = player1_guesses[i]\n      player1_attempts << guess\n      if guess == target_number\n        player1_score = 1\n        break\n      end\n    end\n\n    # Player 2's turn\n    if i < player2_guesses.size\n      guess = player2_guesses[i]\n      player2_attempts << guess\n      if guess == target_number\n        player2_score = 1\n        break\n      end\n    end\n  end\n\n  if player1_score > player2_score\n    \"Player 1 wins!\"\n  elsif player2_score > player1_score\n    \"Player 2 wins!\"\n  else\n    player1_diff = (player1_attempts.sum - target_number * player1_attempts.size).abs\n    player2_diff = (player2_attempts.sum - target_number * player2_attempts.size).abs\n    if player1_diff < player2_diff\n      \"Player 1 guessed closer to the target number in total attempts. Player 1 wins!\"\n    else\n      \"Player 2 guessed closer to the target number in total attempts. Player 2 wins!\"\n    end\n  end\nend\n\ntest_number_guessing_game", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# This Ruby script checks if it's possible to order a list of coin collections such that\n# John's total number of coins never falls below zero at any point. The script uses\n# permutations of the collections to test all possible orders.\n\n# The method `can_remain_non_negative` checks all permutations of the collections to see\n# if any permutation allows John to maintain a non-negative coin count throughout.\n# \n# Args:\n# n - The number of collections (not strictly necessary for the logic, but included for completeness).\n# c - John's initial number of rare coins.\n# collections - An array of integers representing the changes in the number of coins due to the collections.\n#\n# Returns:\n# \"POSSIBLE\" if such an order exists, otherwise \"IMPOSSIBLE\".\ndef can_remain_non_negative(n, c, collections)\n  collections.permutation.each do |perm|\n    total_coins = c\n    valid = true\n    perm.each do |change|\n      total_coins += change\n      if total_coins < 0\n        valid = false\n        break\n      end\n    end\n    return \"POSSIBLE\" if valid\n  end\n  \"IMPOSSIBLE\"\nend", "test_cases": "", "test_case_results": "Input: n=3, c=5, collections=[3, -2, 1]\nResult: POSSIBLE\nInput: n=3, c=2, collections=[-3, -2, 1]\nResult: IMPOSSIBLE\nInput: n=1, c=0, collections=[0]\nResult: POSSIBLE\nInput: n=2, c=10, collections=[-5, -6]\nResult: IMPOSSIBLE\nInput: n=4, c=0, collections=[1, -1, 2, -2]\nResult: POSSIBLE", "task_id": 11498, "assertions": "def test_can_remain_non_negative()\n  raise unless can_remain_non_negative(3, 5, [3, -2, 1]) == \"POSSIBLE\"\n  raise unless can_remain_non_negative(3, 2, [-3, -2, 1]) == \"IMPOSSIBLE\"\n  raise unless can_remain_non_negative(1, 0, [0]) == \"POSSIBLE\"\n  raise unless can_remain_non_negative(2, 10, [-5, -6]) == \"IMPOSSIBLE\"\n  raise unless can_remain_non_negative(4, 0, [1, -1, 2, -2]) == \"POSSIBLE\"\nend\n\ntest_can_remain_non_negative()", "all_code": "# This Ruby script checks if it's possible to order a list of coin collections such that\n# John's total number of coins never falls below zero at any point. The script uses\n# permutations of the collections to test all possible orders.\n\n# The method `can_remain_non_negative` checks all permutations of the collections to see\n# if any permutation allows John to maintain a non-negative coin count throughout.\n# \n# Args:\n# n - The number of collections (not strictly necessary for the logic, but included for completeness).\n# c - John's initial number of rare coins.\n# collections - An array of integers representing the changes in the number of coins due to the collections.\n#\n# Returns:\n# \"POSSIBLE\" if such an order exists, otherwise \"IMPOSSIBLE\".\ndef can_remain_non_negative(n, c, collections)\n  collections.permutation.each do |perm|\n    total_coins = c\n    valid = true\n    perm.each do |change|\n      total_coins += change\n      if total_coins < 0\n        valid = false\n        break\n      end\n    end\n    return \"POSSIBLE\" if valid\n  end\n  \"IMPOSSIBLE\"\nend\ndef test_can_remain_non_negative()\n  raise unless can_remain_non_negative(3, 5, [3, -2, 1]) == \"POSSIBLE\"\n  raise unless can_remain_non_negative(3, 2, [-3, -2, 1]) == \"IMPOSSIBLE\"\n  raise unless can_remain_non_negative(1, 0, [0]) == \"POSSIBLE\"\n  raise unless can_remain_non_negative(2, 10, [-5, -6]) == \"IMPOSSIBLE\"\n  raise unless can_remain_non_negative(4, 0, [1, -1, 2, -2]) == \"POSSIBLE\"\nend\n\ntest_can_remain_non_negative()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef max_distinct_stickers(packs)\n  all_stickers = packs.flatten\n  initial_unique_count = all_stickers.to_set.size\n\n  return initial_unique_count if initial_unique_count == all_stickers.size\n\n  sticker_count = Hash.new(0)\n  all_stickers.each { |sticker| sticker_count[sticker] += 1 }\n\n  max_after_one_swap = initial_unique_count\n\n  (0...packs.size).each do |i|\n    (i + 1...packs.size).each do |j|\n      pack_i = packs[i].to_set\n      pack_j = packs[j].to_set\n\n      pack_i.each do |sticker_i|\n        pack_j.each do |sticker_j|\n          new_pack_i = pack_i.dup\n          new_pack_j = pack_j.dup\n\n          new_pack_i.delete(sticker_i)\n          new_pack_i.add(sticker_j)\n          new_pack_j.delete(sticker_j)\n          new_pack_j.add(sticker_i)\n\n          new_stickers = (new_pack_i | new_pack_j | all_stickers.to_set) - [sticker_i, sticker_j].to_set\n          new_unique_count = new_stickers.size\n\n          max_after_one_swap = [max_after_one_swap, new_unique_count].max\n        end\n      end\n    end\n  end\n\n  max_after_one_swap\nend", "test_cases": "", "test_case_results": "Input: [[1, 2, 3], [2, 3, 4]]\nMax distinct stickers: 4\nInput: [[1, 1, 1], [2, 2, 2]]\nMax distinct stickers: 2\nInput: [[1, 2], [3, 4]]\nMax distinct stickers: 4\nInput: [[1, 1], [1, 1]]\nMax distinct stickers: 1", "task_id": 29343, "assertions": "require 'set'\n\ndef test_max_distinct_stickers()\n  raise \"Test case 1 failed\" unless max_distinct_stickers([[1, 2, 3], [2, 3, 4]]) == 4\n  raise \"Test case 2 failed\" unless max_distinct_stickers([[1, 1, 1], [2, 2, 2]]) == 2\n  raise \"Test case 3 failed\" unless max_distinct_stickers([[1, 2], [3, 4]]) == 4\n  raise \"Test case 4 failed\" unless max_distinct_stickers([[1, 1], [1, 1]]) == 1\n  puts \"All tests passed!\"\nend\n\ntest_max_distinct_stickers()", "all_code": "require 'set'\n\ndef max_distinct_stickers(packs)\n  all_stickers = packs.flatten\n  initial_unique_count = all_stickers.to_set.size\n\n  return initial_unique_count if initial_unique_count == all_stickers.size\n\n  sticker_count = Hash.new(0)\n  all_stickers.each { |sticker| sticker_count[sticker] += 1 }\n\n  max_after_one_swap = initial_unique_count\n\n  (0...packs.size).each do |i|\n    (i + 1...packs.size).each do |j|\n      pack_i = packs[i].to_set\n      pack_j = packs[j].to_set\n\n      pack_i.each do |sticker_i|\n        pack_j.each do |sticker_j|\n          new_pack_i = pack_i.dup\n          new_pack_j = pack_j.dup\n\n          new_pack_i.delete(sticker_i)\n          new_pack_i.add(sticker_j)\n          new_pack_j.delete(sticker_j)\n          new_pack_j.add(sticker_i)\n\n          new_stickers = (new_pack_i | new_pack_j | all_stickers.to_set) - [sticker_i, sticker_j].to_set\n          new_unique_count = new_stickers.size\n\n          max_after_one_swap = [max_after_one_swap, new_unique_count].max\n        end\n      end\n    end\n  end\n\n  max_after_one_swap\nend\nrequire 'set'\n\ndef test_max_distinct_stickers()\n  raise \"Test case 1 failed\" unless max_distinct_stickers([[1, 2, 3], [2, 3, 4]]) == 4\n  raise \"Test case 2 failed\" unless max_distinct_stickers([[1, 1, 1], [2, 2, 2]]) == 2\n  raise \"Test case 3 failed\" unless max_distinct_stickers([[1, 2], [3, 4]]) == 4\n  raise \"Test case 4 failed\" unless max_distinct_stickers([[1, 1], [1, 1]]) == 1\n  puts \"All tests passed!\"\nend\n\ntest_max_distinct_stickers()", "exec_outcome": "PASSED"}
{"code": "# sum_of_multiples calculates the sum of all numbers below a given limit that are multiples of 2 or 5.\n# It iterates through each number from 0 up to (but not including) the limit, checks if the number is a multiple of 2 or 5,\n# and accumulates the sum of all such numbers.\n# If the limit is 0 or negative, it returns 0 since there are no numbers to consider.\ndef sum_of_multiples(limit)\n  return 0 if limit <= 0\n  (0...limit).select { |x| x % 2 == 0 || x % 5 == 0 }.sum\nend", "test_cases": "", "test_case_results": "Limit: 1000\nSum of multiples of 2 or 5 below 1000: 299500\nLimit: 10\nSum of multiples of 2 or 5 below 10: 25\nLimit: 0\nSum of multiples of 2 or 5 below 0: 0\nLimit: -5\nSum of multiples of 2 or 5 below -5: 0\nLimit: 20\nSum of multiples of 2 or 5 below 20: 110", "task_id": 8947, "assertions": "def test_sum_of_multiples()\n  raise \"Test failed for limit=1000\" unless sum_of_multiples(1000) == 299500\n  raise \"Test failed for limit=10\" unless sum_of_multiples(10) == 25\n  raise \"Test failed for limit=0\" unless sum_of_multiples(0) == 0\n  raise \"Test failed for limit=-5\" unless sum_of_multiples(-5) == 0\n  raise \"Test failed for limit=20\" unless sum_of_multiples(20) == 110\nend\n\ntest_sum_of_multiples()", "all_code": "# sum_of_multiples calculates the sum of all numbers below a given limit that are multiples of 2 or 5.\n# It iterates through each number from 0 up to (but not including) the limit, checks if the number is a multiple of 2 or 5,\n# and accumulates the sum of all such numbers.\n# If the limit is 0 or negative, it returns 0 since there are no numbers to consider.\ndef sum_of_multiples(limit)\n  return 0 if limit <= 0\n  (0...limit).select { |x| x % 2 == 0 || x % 5 == 0 }.sum\nend\ndef test_sum_of_multiples()\n  raise \"Test failed for limit=1000\" unless sum_of_multiples(1000) == 299500\n  raise \"Test failed for limit=10\" unless sum_of_multiples(10) == 25\n  raise \"Test failed for limit=0\" unless sum_of_multiples(0) == 0\n  raise \"Test failed for limit=-5\" unless sum_of_multiples(-5) == 0\n  raise \"Test failed for limit=20\" unless sum_of_multiples(20) == 110\nend\n\ntest_sum_of_multiples()", "exec_outcome": "PASSED"}
{"code": "# min_update_operations calculates the minimum number of operations required to update all outdated dependencies.\n# It counts the number of outdated dependencies and divides by the maximum number that can be updated per operation,\n# rounding up to ensure all are covered.\n#\n# Parameters:\n# n - The total number of dependencies.\n# k - The maximum number of dependencies that can be updated in one operation.\n# s - A string where each character represents the status of a dependency ('U' for up-to-date, 'O' for outdated).\n#\n# Returns:\n# The minimum number of operations needed to update all outdated dependencies.\ndef min_update_operations(n, k, s)\n  outdated_count = s.count('O')\n  return 0 if outdated_count == 0\n  (outdated_count + k - 1) / k\nend", "test_cases": "", "test_case_results": "Input: n=5, k=2, s='UOUOU'\nMinimum operations: 1\nInput: n=4, k=3, s='OOOO'\nMinimum operations: 2\nInput: n=3, k=1, s='UUU'\nMinimum operations: 0\nInput: n=6, k=4, s='OUOUOU'\nMinimum operations: 1\nInput: n=5, k=5, s='OOOOU'\nMinimum operations: 1", "task_id": 13389, "assertions": "def test_min_update_operations()\n  raise unless min_update_operations(5, 2, 'UOUOU') == 1\n  raise unless min_update_operations(4, 3, 'OOOO') == 2\n  raise unless min_update_operations(3, 1, 'UUU') == 0\n  raise unless min_update_operations(6, 4, 'OUOUOU') == 1\n  raise unless min_update_operations(5, 5, 'OOOOU') == 1\nend\n\ntest_min_update_operations()", "all_code": "# min_update_operations calculates the minimum number of operations required to update all outdated dependencies.\n# It counts the number of outdated dependencies and divides by the maximum number that can be updated per operation,\n# rounding up to ensure all are covered.\n#\n# Parameters:\n# n - The total number of dependencies.\n# k - The maximum number of dependencies that can be updated in one operation.\n# s - A string where each character represents the status of a dependency ('U' for up-to-date, 'O' for outdated).\n#\n# Returns:\n# The minimum number of operations needed to update all outdated dependencies.\ndef min_update_operations(n, k, s)\n  outdated_count = s.count('O')\n  return 0 if outdated_count == 0\n  (outdated_count + k - 1) / k\nend\ndef test_min_update_operations()\n  raise unless min_update_operations(5, 2, 'UOUOU') == 1\n  raise unless min_update_operations(4, 3, 'OOOO') == 2\n  raise unless min_update_operations(3, 1, 'UUU') == 0\n  raise unless min_update_operations(6, 4, 'OUOUOU') == 1\n  raise unless min_update_operations(5, 5, 'OOOOU') == 1\nend\n\ntest_min_update_operations()", "exec_outcome": "PASSED"}
{"code": "# cube_floats takes an array of 10 floating point numbers between 0 and 1,\n# validates the input, and returns an array of their cubes.\n# \n# @param floats [Array<Float>] An array of 10 floating point numbers between 0 and 1.\n# @return [Array<Float>] An array containing the cubes of the original numbers.\n# @raise [ArgumentError] If the input array does not contain exactly 10 numbers or if any number is outside the 0..1 range.\ndef cube_floats(floats)\n  # Validating input length\n  if floats.size != 10\n    raise ArgumentError, \"Input list must contain exactly 10 numbers.\"\n  end\n\n  # Validating input value range\n  floats.each do |number|\n    unless (0..1).cover?(number)\n      raise ArgumentError, \"All numbers must be between 0 and 1.\"\n    end\n  end\n\n  floats.map { |x| x ** 3 }\nend", "test_cases": "", "test_case_results": "Input: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\nCubed: [0.0010000000000000002, 0.008000000000000002, 0.026999999999999996, 0.06400000000000002, 0.125, 0.21599999999999997, 0.3429999999999999, 0.5120000000000001, 0.7290000000000001, 1.0]\n\nInput: [0.0, 0.25, 0.5, 0.75, 1.0, 0.0, 0.25, 0.5, 0.75, 1.0]\nCubed: [0.0, 0.015625, 0.125, 0.421875, 1.0, 0.0, 0.015625, 0.125, 0.421875, 1.0]\n\nInput: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]\nCubed: [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]", "task_id": 32, "assertions": "def test_cube_floats()\n  # Test valid cases\n  valid_input1 = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n  expected_output1 = [0.0010000000000000002, 0.008000000000000002, 0.026999999999999996, 0.06400000000000002, 0.125, 0.21599999999999997, 0.3429999999999999, 0.5120000000000001, 0.7290000000000001, 1.0]\n  raise \"Test case 1 failed\" unless cube_floats(valid_input1) == expected_output1\n\n  valid_input2 = [0.0, 0.25, 0.5, 0.75, 1.0, 0.0, 0.25, 0.5, 0.75, 1.0]\n  expected_output2 = [0.0, 0.015625, 0.125, 0.421875, 1.0, 0.0, 0.015625, 0.125, 0.421875, 1.0]\n  raise \"Test case 2 failed\" unless cube_floats(valid_input2) == expected_output2\n\n  valid_input3 = [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  expected_output3 = [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  raise \"Test case 3 failed\" unless cube_floats(valid_input3) == expected_output3\n\n  # Test invalid cases\n  begin\n    cube_floats([0.1, 0.2, 0.3]) # Wrong size\n    raise \"Test case 4 failed (should have raised ArgumentError)\"\n  rescue ArgumentError => e\n    # Expected\n  end\n\n  begin\n    cube_floats([0.5, 1.5, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]) # Value out of range\n    raise \"Test case 5 failed (should have raised ArgumentError)\"\n  rescue ArgumentError => e\n    # Expected\n  end\n\n  puts \"All tests passed!\"\nend\n\ntest_cube_floats()", "all_code": "# cube_floats takes an array of 10 floating point numbers between 0 and 1,\n# validates the input, and returns an array of their cubes.\n# \n# @param floats [Array<Float>] An array of 10 floating point numbers between 0 and 1.\n# @return [Array<Float>] An array containing the cubes of the original numbers.\n# @raise [ArgumentError] If the input array does not contain exactly 10 numbers or if any number is outside the 0..1 range.\ndef cube_floats(floats)\n  # Validating input length\n  if floats.size != 10\n    raise ArgumentError, \"Input list must contain exactly 10 numbers.\"\n  end\n\n  # Validating input value range\n  floats.each do |number|\n    unless (0..1).cover?(number)\n      raise ArgumentError, \"All numbers must be between 0 and 1.\"\n    end\n  end\n\n  floats.map { |x| x ** 3 }\nend\ndef test_cube_floats()\n  # Test valid cases\n  valid_input1 = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n  expected_output1 = [0.0010000000000000002, 0.008000000000000002, 0.026999999999999996, 0.06400000000000002, 0.125, 0.21599999999999997, 0.3429999999999999, 0.5120000000000001, 0.7290000000000001, 1.0]\n  raise \"Test case 1 failed\" unless cube_floats(valid_input1) == expected_output1\n\n  valid_input2 = [0.0, 0.25, 0.5, 0.75, 1.0, 0.0, 0.25, 0.5, 0.75, 1.0]\n  expected_output2 = [0.0, 0.015625, 0.125, 0.421875, 1.0, 0.0, 0.015625, 0.125, 0.421875, 1.0]\n  raise \"Test case 2 failed\" unless cube_floats(valid_input2) == expected_output2\n\n  valid_input3 = [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  expected_output3 = [0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n  raise \"Test case 3 failed\" unless cube_floats(valid_input3) == expected_output3\n\n  # Test invalid cases\n  begin\n    cube_floats([0.1, 0.2, 0.3]) # Wrong size\n    raise \"Test case 4 failed (should have raised ArgumentError)\"\n  rescue ArgumentError => e\n    # Expected\n  end\n\n  begin\n    cube_floats([0.5, 1.5, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]) # Value out of range\n    raise \"Test case 5 failed (should have raised ArgumentError)\"\n  rescue ArgumentError => e\n    # Expected\n  end\n\n  puts \"All tests passed!\"\nend\n\ntest_cube_floats()", "exec_outcome": "PASSED"}
{"code": "# num_operations_to_zero calculates the number of operations required to reduce a binary number to 0.\n# The operations are:\n# 1. If the number is even, divide it by 2.\n# 2. If the number is odd, subtract 1 from it.\n# The method takes a binary string as input and returns the number of steps required to reach 0.\ndef num_operations_to_zero(s)\n  num = s.to_i(2)\n  steps = 0\n\n  while num > 0\n    if num % 2 == 0\n      num /= 2\n    else\n      num -= 1\n    end\n    steps += 1\n  end\n\n  steps\nend", "test_cases": "", "test_case_results": "Input: 0\nNumber of operations: 0\nInput: 1\nNumber of operations: 1\nInput: 10\nNumber of operations: 2\nInput: 101\nNumber of operations: 4\nInput: 1101\nNumber of operations: 6\nInput: 10000\nNumber of operations: 5", "task_id": 1288, "assertions": "def test_num_operations_to_zero()\n  raise unless num_operations_to_zero(\"0\") == 0\n  raise unless num_operations_to_zero(\"1\") == 1\n  raise unless num_operations_to_zero(\"10\") == 2\n  raise unless num_operations_to_zero(\"101\") == 4\n  raise unless num_operations_to_zero(\"1101\") == 6\n  raise unless num_operations_to_zero(\"10000\") == 5\nend\n\ntest_num_operations_to_zero()", "all_code": "# num_operations_to_zero calculates the number of operations required to reduce a binary number to 0.\n# The operations are:\n# 1. If the number is even, divide it by 2.\n# 2. If the number is odd, subtract 1 from it.\n# The method takes a binary string as input and returns the number of steps required to reach 0.\ndef num_operations_to_zero(s)\n  num = s.to_i(2)\n  steps = 0\n\n  while num > 0\n    if num % 2 == 0\n      num /= 2\n    else\n      num -= 1\n    end\n    steps += 1\n  end\n\n  steps\nend\ndef test_num_operations_to_zero()\n  raise unless num_operations_to_zero(\"0\") == 0\n  raise unless num_operations_to_zero(\"1\") == 1\n  raise unless num_operations_to_zero(\"10\") == 2\n  raise unless num_operations_to_zero(\"101\") == 4\n  raise unless num_operations_to_zero(\"1101\") == 6\n  raise unless num_operations_to_zero(\"10000\") == 5\nend\n\ntest_num_operations_to_zero()", "exec_outcome": "PASSED"}
{"code": "# Reorganizes the nodes of a tree such that the in-order traversal of the new tree\n# is identical to the sorted sequence of values from 1 to N.\n#\n# The method constructs a new tree where each node is connected in a linear chain\n# from 1 to N. This ensures that the in-order traversal will produce the sequence 1, 2, ..., N.\n#\n# Args:\n# - n: The number of nodes in the tree.\n# - edges: List of arrays representing the edges of the tree (unused in this implementation).\n#\n# Returns:\n# - Array of arrays representing the edges of the reorganized tree.\ndef reorganize_tree(n, edges)\n  new_edges = []\n  (1...n).each do |i|\n    new_edges << [i, i + 1]\n  end\n  new_edges\nend", "test_cases": "", "test_case_results": "Input - N: 3, Edges: [[1, 2], [2, 3]]\nReorganized Edges: [[1, 2], [2, 3]]\nInput - N: 5, Edges: [[1, 2], [2, 3], [3, 4], [4, 5]]\nReorganized Edges: [[1, 2], [2, 3], [3, 4], [4, 5]]\nInput - N: 1, Edges: []\nReorganized Edges: []", "task_id": 9386, "assertions": "def test_reorganize_tree()\n  raise unless reorganize_tree(3, [[1, 2], [2, 3]]) == [[1, 2], [2, 3]]\n  raise unless reorganize_tree(5, [[1, 2], [2, 3], [3, 4], [4, 5]]) == [[1, 2], [2, 3], [3, 4], [4, 5]]\n  raise unless reorganize_tree(1, []) == []\nend\n\ntest_reorganize_tree()", "all_code": "# Reorganizes the nodes of a tree such that the in-order traversal of the new tree\n# is identical to the sorted sequence of values from 1 to N.\n#\n# The method constructs a new tree where each node is connected in a linear chain\n# from 1 to N. This ensures that the in-order traversal will produce the sequence 1, 2, ..., N.\n#\n# Args:\n# - n: The number of nodes in the tree.\n# - edges: List of arrays representing the edges of the tree (unused in this implementation).\n#\n# Returns:\n# - Array of arrays representing the edges of the reorganized tree.\ndef reorganize_tree(n, edges)\n  new_edges = []\n  (1...n).each do |i|\n    new_edges << [i, i + 1]\n  end\n  new_edges\nend\ndef test_reorganize_tree()\n  raise unless reorganize_tree(3, [[1, 2], [2, 3]]) == [[1, 2], [2, 3]]\n  raise unless reorganize_tree(5, [[1, 2], [2, 3], [3, 4], [4, 5]]) == [[1, 2], [2, 3], [3, 4], [4, 5]]\n  raise unless reorganize_tree(1, []) == []\nend\n\ntest_reorganize_tree()", "exec_outcome": "PASSED"}
{"code": "# This method calculates the maximum value in an array after performing a series of operations.\n# Each operation involves adding a value `k` to elements from index `a` to `b` (inclusive).\n# The method uses a difference array to efficiently apply the operations and then computes the maximum value.\n#\n# Parameters:\n# - n: the size of the array (1-based indexing)\n# - operations: an array of operations, where each operation is represented as [a, b, k]\n#\n# Returns:\n# - The maximum value in the array after all operations are performed\ndef find_max_value(n, operations)\n  # Initialize a difference array with size n + 2 to handle 1-based indexing\n  diff_array = Array.new(n + 2, 0)\n  \n  # Apply each operation to the difference array\n  operations.each do |a, b, k|\n    diff_array[a] += k\n    diff_array[b + 1] -= k if b + 1 <= n\n  end\n  \n  max_value = 0\n  current_value = 0\n  \n  # Compute the prefix sum to get the actual values and find the maximum\n  (1..n).each do |i|\n    current_value += diff_array[i]\n    max_value = current_value if current_value > max_value\n  end\n  \n  max_value\nend", "test_cases": "", "test_case_results": "Test case 1: Multiple overlapping operations\nn: 5, operations: [[1, 3, 2], [2, 4, 3], [3, 5, 1]]\nMaximum value: 6\n\nTest case 2: Operations covering different ranges\nn: 10, operations: [[1, 5, 10], [6, 10, 5], [1, 10, 2]]\nMaximum value: 12\n\nTest case 3: Operations with positive and negative values\nn: 7, operations: [[1, 7, 5], [2, 3, 10], [4, 6, -3]]\nMaximum value: 15", "task_id": 23360, "assertions": "def test_find_max_value()\n  # Test case 1: Multiple overlapping operations\n  raise unless find_max_value(5, [[1, 3, 2], [2, 4, 3], [3, 5, 1]]) == 6\n\n  # Test case 2: Operations covering different ranges\n  raise unless find_max_value(10, [[1, 5, 10], [6, 10, 5], [1, 10, 2]]) == 12\n\n  # Test case 3: Operations with positive and negative values\n  raise unless find_max_value(7, [[1, 7, 5], [2, 3, 10], [4, 6, -3]]) == 15\nend\n\ntest_find_max_value()", "all_code": "# This method calculates the maximum value in an array after performing a series of operations.\n# Each operation involves adding a value `k` to elements from index `a` to `b` (inclusive).\n# The method uses a difference array to efficiently apply the operations and then computes the maximum value.\n#\n# Parameters:\n# - n: the size of the array (1-based indexing)\n# - operations: an array of operations, where each operation is represented as [a, b, k]\n#\n# Returns:\n# - The maximum value in the array after all operations are performed\ndef find_max_value(n, operations)\n  # Initialize a difference array with size n + 2 to handle 1-based indexing\n  diff_array = Array.new(n + 2, 0)\n  \n  # Apply each operation to the difference array\n  operations.each do |a, b, k|\n    diff_array[a] += k\n    diff_array[b + 1] -= k if b + 1 <= n\n  end\n  \n  max_value = 0\n  current_value = 0\n  \n  # Compute the prefix sum to get the actual values and find the maximum\n  (1..n).each do |i|\n    current_value += diff_array[i]\n    max_value = current_value if current_value > max_value\n  end\n  \n  max_value\nend\ndef test_find_max_value()\n  # Test case 1: Multiple overlapping operations\n  raise unless find_max_value(5, [[1, 3, 2], [2, 4, 3], [3, 5, 1]]) == 6\n\n  # Test case 2: Operations covering different ranges\n  raise unless find_max_value(10, [[1, 5, 10], [6, 10, 5], [1, 10, 2]]) == 12\n\n  # Test case 3: Operations with positive and negative values\n  raise unless find_max_value(7, [[1, 7, 5], [2, 3, 10], [4, 6, -3]]) == 15\nend\n\ntest_find_max_value()", "exec_outcome": "PASSED"}
{"code": "# typeahead_suggestions generates a list of up to 5 search term suggestions based on the user's input.\n# The suggestions are filtered to include only terms that start with the user's input,\n# then sorted by frequency in descending order. If frequencies are equal, terms are sorted lexicographically.\n#\n# @param search_terms [Hash] A hash where keys are search terms and values are their frequencies.\n# @param user_input [String] The partial input entered by the user.\n# @return [Array<String>] An array of up to 5 suggested terms.\ndef typeahead_suggestions(search_terms, user_input)\n  # Filter terms that start with user_input and create an array of [term, frequency] arrays\n  filtered_terms = search_terms.select { |term, _| term.start_with?(user_input) }.to_a\n\n  # Sort terms by frequency (descending) and then by term (ascending)\n  filtered_terms.sort_by! { |term, freq| [-freq, term] }\n\n  # Extract the sorted terms and return up to 5\n  filtered_terms.map(&:first).take(5)\nend", "test_cases": "", "test_case_results": "Input: app\nSearch Terms: {\"apple\"=>10, \"appetizer\"=>5, \"application\"=>8, \"banana\"=>20, \"app\"=>15, \"orange\"=>12, \"apex\"=>3}\nSuggestions: [\"app\", \"apple\", \"application\", \"appetizer\"]\n\nInput: j\nSearch Terms: {\"ruby\"=>7, \"rust\"=>5, \"java\"=>10, \"javascript\"=>15, \"python\"=>20}\nSuggestions: [\"javascript\", \"java\"]\n\nInput: ca\nSearch Terms: {\"car\"=>5, \"cat\"=>5, \"cab\"=>5, \"can\"=>5, \"cap\"=>5, \"dog\"=>10}\nSuggestions: [\"cab\", \"can\", \"cap\", \"car\", \"cat\"]", "task_id": 22137, "assertions": "def test_typeahead_suggestions()\n  # Test case 1\n  search_terms1 = {\n    \"apple\" => 10,\n    \"appetizer\" => 5,\n    \"application\" => 8,\n    \"banana\" => 20,\n    \"app\" => 15,\n    \"orange\" => 12,\n    \"apex\" => 3\n  }\n  suggestions1 = typeahead_suggestions(search_terms1, \"app\")\n  raise \"Test case 1 failed\" unless suggestions1 == [\"app\", \"apple\", \"application\", \"appetizer\"]\n\n  # Test case 2\n  search_terms2 = {\n    \"ruby\" => 7,\n    \"rust\" => 5,\n    \"java\" => 10,\n    \"javascript\" => 15,\n    \"python\" => 20\n  }\n  suggestions2 = typeahead_suggestions(search_terms2, \"j\")\n  raise \"Test case 2 failed\" unless suggestions2 == [\"javascript\", \"java\"]\n\n  # Test case 3\n  search_terms3 = {\n    \"car\" => 5,\n    \"cat\" => 5,\n    \"cab\" => 5,\n    \"can\" => 5,\n    \"cap\" => 5,\n    \"dog\" => 10\n  }\n  suggestions3 = typeahead_suggestions(search_terms3, \"ca\")\n  raise \"Test case 3 failed\" unless suggestions3 == [\"cab\", \"can\", \"cap\", \"car\", \"cat\"]\nend\n\ntest_typeahead_suggestions()", "all_code": "# typeahead_suggestions generates a list of up to 5 search term suggestions based on the user's input.\n# The suggestions are filtered to include only terms that start with the user's input,\n# then sorted by frequency in descending order. If frequencies are equal, terms are sorted lexicographically.\n#\n# @param search_terms [Hash] A hash where keys are search terms and values are their frequencies.\n# @param user_input [String] The partial input entered by the user.\n# @return [Array<String>] An array of up to 5 suggested terms.\ndef typeahead_suggestions(search_terms, user_input)\n  # Filter terms that start with user_input and create an array of [term, frequency] arrays\n  filtered_terms = search_terms.select { |term, _| term.start_with?(user_input) }.to_a\n\n  # Sort terms by frequency (descending) and then by term (ascending)\n  filtered_terms.sort_by! { |term, freq| [-freq, term] }\n\n  # Extract the sorted terms and return up to 5\n  filtered_terms.map(&:first).take(5)\nend\ndef test_typeahead_suggestions()\n  # Test case 1\n  search_terms1 = {\n    \"apple\" => 10,\n    \"appetizer\" => 5,\n    \"application\" => 8,\n    \"banana\" => 20,\n    \"app\" => 15,\n    \"orange\" => 12,\n    \"apex\" => 3\n  }\n  suggestions1 = typeahead_suggestions(search_terms1, \"app\")\n  raise \"Test case 1 failed\" unless suggestions1 == [\"app\", \"apple\", \"application\", \"appetizer\"]\n\n  # Test case 2\n  search_terms2 = {\n    \"ruby\" => 7,\n    \"rust\" => 5,\n    \"java\" => 10,\n    \"javascript\" => 15,\n    \"python\" => 20\n  }\n  suggestions2 = typeahead_suggestions(search_terms2, \"j\")\n  raise \"Test case 2 failed\" unless suggestions2 == [\"javascript\", \"java\"]\n\n  # Test case 3\n  search_terms3 = {\n    \"car\" => 5,\n    \"cat\" => 5,\n    \"cab\" => 5,\n    \"can\" => 5,\n    \"cap\" => 5,\n    \"dog\" => 10\n  }\n  suggestions3 = typeahead_suggestions(search_terms3, \"ca\")\n  raise \"Test case 3 failed\" unless suggestions3 == [\"cab\", \"can\", \"cap\", \"car\", \"cat\"]\nend\n\ntest_typeahead_suggestions()", "exec_outcome": "PASSED"}
{"code": "# Determines if the array can be sorted by reversing subarrays of size k.\n# If k is 1, it checks if the array is already sorted.\n# If k is even, it returns true because we can always sort the array by reversing adjacent pairs.\n# If k is odd, it checks if the array is already sorted in segments of length k.\ndef can_be_sorted(nums, k)\n  if k == 1\n    return nums == nums.sort\n  end\n\n  if k.even?\n    return true\n  end\n\n  (0..nums.length - k).step(k) do |i|\n    segment = nums[i, k]\n    if segment != segment.sort\n      return false\n    end\n  end\n  true\nend", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4, 5], k: 1\nCan be sorted: true\n---\nInput array: [1, 3, 2, 4, 5], k: 2\nCan be sorted: true\n---\nInput array: [1, 3, 2, 5, 4], k: 3\nCan be sorted: false\n---\nInput array: [1, 4, 3, 2, 5], k: 4\nCan be sorted: true\n---\nInput array: [5, 4, 3, 2, 1], k: 5\nCan be sorted: false\n---", "task_id": 7401, "assertions": "def test_can_be_sorted()\n  raise unless can_be_sorted([1, 2, 3, 4, 5], 1) == true\n  raise unless can_be_sorted([1, 3, 2, 4, 5], 2) == true\n  raise unless can_be_sorted([1, 3, 2, 5, 4], 3) == false\n  raise unless can_be_sorted([1, 4, 3, 2, 5], 4) == true\n  raise unless can_be_sorted([5, 4, 3, 2, 1], 5) == false\nend\n\ntest_can_be_sorted()", "all_code": "# Determines if the array can be sorted by reversing subarrays of size k.\n# If k is 1, it checks if the array is already sorted.\n# If k is even, it returns true because we can always sort the array by reversing adjacent pairs.\n# If k is odd, it checks if the array is already sorted in segments of length k.\ndef can_be_sorted(nums, k)\n  if k == 1\n    return nums == nums.sort\n  end\n\n  if k.even?\n    return true\n  end\n\n  (0..nums.length - k).step(k) do |i|\n    segment = nums[i, k]\n    if segment != segment.sort\n      return false\n    end\n  end\n  true\nend\ndef test_can_be_sorted()\n  raise unless can_be_sorted([1, 2, 3, 4, 5], 1) == true\n  raise unless can_be_sorted([1, 3, 2, 4, 5], 2) == true\n  raise unless can_be_sorted([1, 3, 2, 5, 4], 3) == false\n  raise unless can_be_sorted([1, 4, 3, 2, 5], 4) == true\n  raise unless can_be_sorted([5, 4, 3, 2, 1], 5) == false\nend\n\ntest_can_be_sorted()", "exec_outcome": "PASSED"}
{"code": "def product_of_others(lst)\n  n = lst.size\n  left_products = Array.new(n, 1)\n  right_products = Array.new(n, 1)\n  \n  # Calculate left products\n  (1...n).each do |i|\n    left_products[i] = left_products[i - 1] * lst[i - 1]\n  end\n  \n  # Calculate right products\n  (n - 2).downto(0) do |i|\n    right_products[i] = right_products[i + 1] * lst[i + 1]\n  end\n  \n  # Calculate the result\n  result = Array.new(n) { |i| left_products[i] * right_products[i] }\n  result\nend", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nResult: [24, 12, 8, 6]\nInput: [5, 6, 7, 0]\nResult: [0, 0, 0, 210]\nInput: [0, 0, 0, 0]\nResult: [0, 0, 0, 0]\nInput: [1, 1, 1, 1]\nResult: [1, 1, 1, 1]\nInput: [2, 3, 5, 7, 11]\nResult: [1155, 770, 462, 330, 210]", "task_id": 23898, "assertions": "def test_product_of_others()\n  raise unless product_of_others([1, 2, 3, 4]) == [24, 12, 8, 6]\n  raise unless product_of_others([5, 6, 7, 0]) == [0, 0, 0, 210]\n  raise unless product_of_others([0, 0, 0, 0]) == [0, 0, 0, 0]\n  raise unless product_of_others([1, 1, 1, 1]) == [1, 1, 1, 1]\n  raise unless product_of_others([2, 3, 5, 7, 11]) == [1155, 770, 462, 330, 210]\nend\n\ntest_product_of_others()", "all_code": "def product_of_others(lst)\n  n = lst.size\n  left_products = Array.new(n, 1)\n  right_products = Array.new(n, 1)\n  \n  # Calculate left products\n  (1...n).each do |i|\n    left_products[i] = left_products[i - 1] * lst[i - 1]\n  end\n  \n  # Calculate right products\n  (n - 2).downto(0) do |i|\n    right_products[i] = right_products[i + 1] * lst[i + 1]\n  end\n  \n  # Calculate the result\n  result = Array.new(n) { |i| left_products[i] * right_products[i] }\n  result\nend\ndef test_product_of_others()\n  raise unless product_of_others([1, 2, 3, 4]) == [24, 12, 8, 6]\n  raise unless product_of_others([5, 6, 7, 0]) == [0, 0, 0, 210]\n  raise unless product_of_others([0, 0, 0, 0]) == [0, 0, 0, 0]\n  raise unless product_of_others([1, 1, 1, 1]) == [1, 1, 1, 1]\n  raise unless product_of_others([2, 3, 5, 7, 11]) == [1155, 770, 462, 330, 210]\nend\n\ntest_product_of_others()", "exec_outcome": "PASSED"}
{"code": "# maximal_square_area calculates the area of the largest square containing only 1's in a binary grid.\n# It uses dynamic programming to keep track of the largest square ending at each cell.\n# The grid is represented as a 2D array where 1's are considered as part of the square.\n# The method returns the area of the largest square found (0 if no square is found).\n#\n# Parameters:\n# - n: number of rows in the grid\n# - m: number of columns in the grid\n# - grid: 2D array representing the binary grid\n#\n# Returns:\n# - Integer representing the area of the largest square of 1's\ndef maximal_square_area(n, m, grid)\n  return 0 if n == 0 || m == 0\n\n  max_side = 0\n  dp = Array.new(n) { Array.new(m, 0) }\n\n  (0...n).each do |i|\n    (0...m).each do |j|\n      if grid[i][j] == 1\n        if i == 0 || j == 0\n          dp[i][j] = 1\n        else\n          dp[i][j] = [dp[i-1][j], dp[i][j-1], dp[i-1][j-1]].min + 1\n        end\n        max_side = [max_side, dp[i][j]].max\n      end\n    end\n  end\n\n  max_side ** 2\nend", "test_cases": "", "test_case_results": "Input grid:\n[1, 0, 1, 0, 0]\n[1, 0, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[1, 0, 0, 1, 0]\nDimensions: 4x5\nArea of largest square: 4\n---\nInput grid:\n[0, 0, 0]\n[0, 0, 0]\n[0, 0, 0]\nDimensions: 3x3\nArea of largest square: 0\n---\nInput grid:\n[1]\nDimensions: 1x1\nArea of largest square: 1\n---\nInput grid:\nDimensions: 0x0\nArea of largest square: 0\n---", "task_id": 6305, "assertions": "def test_maximal_square_area()\n  # Test case 1: Grid with a 2x2 square\n  grid1 = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n  ]\n  raise \"Test case 1 failed\" unless maximal_square_area(4, 5, grid1) == 4\n\n  # Test case 2: Grid with all 0's\n  grid2 = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]\n  raise \"Test case 2 failed\" unless maximal_square_area(3, 3, grid2) == 0\n\n  # Test case 3: Single cell grid with 1\n  grid3 = [[1]]\n  raise \"Test case 3 failed\" unless maximal_square_area(1, 1, grid3) == 1\n\n  # Test case 4: Empty grid\n  grid4 = []\n  raise \"Test case 4 failed\" unless maximal_square_area(0, 0, grid4) == 0\nend\n\ntest_maximal_square_area()", "all_code": "# maximal_square_area calculates the area of the largest square containing only 1's in a binary grid.\n# It uses dynamic programming to keep track of the largest square ending at each cell.\n# The grid is represented as a 2D array where 1's are considered as part of the square.\n# The method returns the area of the largest square found (0 if no square is found).\n#\n# Parameters:\n# - n: number of rows in the grid\n# - m: number of columns in the grid\n# - grid: 2D array representing the binary grid\n#\n# Returns:\n# - Integer representing the area of the largest square of 1's\ndef maximal_square_area(n, m, grid)\n  return 0 if n == 0 || m == 0\n\n  max_side = 0\n  dp = Array.new(n) { Array.new(m, 0) }\n\n  (0...n).each do |i|\n    (0...m).each do |j|\n      if grid[i][j] == 1\n        if i == 0 || j == 0\n          dp[i][j] = 1\n        else\n          dp[i][j] = [dp[i-1][j], dp[i][j-1], dp[i-1][j-1]].min + 1\n        end\n        max_side = [max_side, dp[i][j]].max\n      end\n    end\n  end\n\n  max_side ** 2\nend\ndef test_maximal_square_area()\n  # Test case 1: Grid with a 2x2 square\n  grid1 = [\n    [1, 0, 1, 0, 0],\n    [1, 0, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [1, 0, 0, 1, 0]\n  ]\n  raise \"Test case 1 failed\" unless maximal_square_area(4, 5, grid1) == 4\n\n  # Test case 2: Grid with all 0's\n  grid2 = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]\n  raise \"Test case 2 failed\" unless maximal_square_area(3, 3, grid2) == 0\n\n  # Test case 3: Single cell grid with 1\n  grid3 = [[1]]\n  raise \"Test case 3 failed\" unless maximal_square_area(1, 1, grid3) == 1\n\n  # Test case 4: Empty grid\n  grid4 = []\n  raise \"Test case 4 failed\" unless maximal_square_area(0, 0, grid4) == 0\nend\n\ntest_maximal_square_area()", "exec_outcome": "PASSED"}
{"code": "class Account\n  # Initializes the account with an initial balance.\n  # @param initial_balance [Numeric] the starting balance of the account\n  def initialize(initial_balance)\n    @balance = initial_balance\n  end\n\n  # Processes a list of transactions (deposits and withdrawals) and updates the balance.\n  # @param transactions [Array<String>] an array of transaction strings in the format \"D100\" (deposit) or \"W50\" (withdrawal)\n  # @return [Numeric] the updated balance after processing all transactions\n  def process_transactions(transactions)\n    transactions.each do |transaction|\n      if transaction[0] == 'D'\n        amount = transaction[1..-1].to_i\n        @balance += amount\n      elsif transaction[0] == 'W'\n        amount = transaction[1..-1].to_i\n        @balance -= amount\n      end\n    end\n    @balance\n  end\nend", "test_cases": "", "test_case_results": "Initial balance: 100\nTransactions: [\"D50\", \"W20\", \"W10\"]\nFinal balance: 120\n---\nInitial balance: 0\nTransactions: [\"D100\", \"D200\", \"W150\"]\nFinal balance: 150\n---\nInitial balance: 500\nTransactions: [\"W100\", \"W200\", \"D50\"]\nFinal balance: 250\n---\nInitial balance: 1000\nTransactions: []\nFinal balance: 1000\n---", "task_id": 15735, "assertions": "def test_account_transactions()\n  # Test case 1\n  account1 = Account.new(100)\n  raise \"Test case 1 failed\" unless account1.process_transactions(['D50', 'W20', 'W10']) == 120\n\n  # Test case 2\n  account2 = Account.new(0)\n  raise \"Test case 2 failed\" unless account2.process_transactions(['D100', 'D200', 'W150']) == 150\n\n  # Test case 3\n  account3 = Account.new(500)\n  raise \"Test case 3 failed\" unless account3.process_transactions(['W100', 'W200', 'D50']) == 250\n\n  # Test case 4\n  account4 = Account.new(1000)\n  raise \"Test case 4 failed\" unless account4.process_transactions([]) == 1000\n\n  puts \"All test cases passed successfully!\"\nend\n\ntest_account_transactions()", "all_code": "class Account\n  # Initializes the account with an initial balance.\n  # @param initial_balance [Numeric] the starting balance of the account\n  def initialize(initial_balance)\n    @balance = initial_balance\n  end\n\n  # Processes a list of transactions (deposits and withdrawals) and updates the balance.\n  # @param transactions [Array<String>] an array of transaction strings in the format \"D100\" (deposit) or \"W50\" (withdrawal)\n  # @return [Numeric] the updated balance after processing all transactions\n  def process_transactions(transactions)\n    transactions.each do |transaction|\n      if transaction[0] == 'D'\n        amount = transaction[1..-1].to_i\n        @balance += amount\n      elsif transaction[0] == 'W'\n        amount = transaction[1..-1].to_i\n        @balance -= amount\n      end\n    end\n    @balance\n  end\nend\ndef test_account_transactions()\n  # Test case 1\n  account1 = Account.new(100)\n  raise \"Test case 1 failed\" unless account1.process_transactions(['D50', 'W20', 'W10']) == 120\n\n  # Test case 2\n  account2 = Account.new(0)\n  raise \"Test case 2 failed\" unless account2.process_transactions(['D100', 'D200', 'W150']) == 150\n\n  # Test case 3\n  account3 = Account.new(500)\n  raise \"Test case 3 failed\" unless account3.process_transactions(['W100', 'W200', 'D50']) == 250\n\n  # Test case 4\n  account4 = Account.new(1000)\n  raise \"Test case 4 failed\" unless account4.process_transactions([]) == 1000\n\n  puts \"All test cases passed successfully!\"\nend\n\ntest_account_transactions()", "exec_outcome": "PASSED"}
{"code": "# get_complementary_dna returns the complementary DNA strand of the given DNA sequence.\n# It uses a hash to map each nucleotide to its complement (A <-> T, C <-> G).\n# The method then joins the resulting characters into a string.\ndef get_complementary_dna(dna_sequence)\n  complement = { 'A' => 'T', 'T' => 'A', 'C' => 'G', 'G' => 'C' }\n  dna_sequence.chars.map { |nucleotide| complement[nucleotide] }.join\nend", "test_cases": "", "test_case_results": "Input: ATCG\nComplementary Strand: TAGC\nInput: TTAA\nComplementary Strand: AATT\nInput: GCGC\nComplementary Strand: CGCG\nInput: ACGT\nComplementary Strand: TGCA", "task_id": 21462, "assertions": "def test_get_complementary_dna()\n  raise unless get_complementary_dna(\"ATCG\") == \"TAGC\"\n  raise unless get_complementary_dna(\"TTAA\") == \"AATT\"\n  raise unless get_complementary_dna(\"GCGC\") == \"CGCG\"\n  raise unless get_complementary_dna(\"ACGT\") == \"TGCA\"\nend\n\ntest_get_complementary_dna()", "all_code": "# get_complementary_dna returns the complementary DNA strand of the given DNA sequence.\n# It uses a hash to map each nucleotide to its complement (A <-> T, C <-> G).\n# The method then joins the resulting characters into a string.\ndef get_complementary_dna(dna_sequence)\n  complement = { 'A' => 'T', 'T' => 'A', 'C' => 'G', 'G' => 'C' }\n  dna_sequence.chars.map { |nucleotide| complement[nucleotide] }.join\nend\ndef test_get_complementary_dna()\n  raise unless get_complementary_dna(\"ATCG\") == \"TAGC\"\n  raise unless get_complementary_dna(\"TTAA\") == \"AATT\"\n  raise unless get_complementary_dna(\"GCGC\") == \"CGCG\"\n  raise unless get_complementary_dna(\"ACGT\") == \"TGCA\"\nend\n\ntest_get_complementary_dna()", "exec_outcome": "PASSED"}
{"code": "class FileSystem\n  def initialize\n    @root = { 'type' => 'dir', 'content' => {} }\n  end\n\n  def find_node(path)\n    return @root if path == '/'\n\n    path_parts = path.strip.split('/')\n    node = @root\n\n    path_parts.each do |part|\n      if !node['content'].key?(part) || node['content'][part]['type'] != 'dir'\n        return nil\n      end\n      node = node['content'][part]\n    end\n\n    node\n  end\n\n  def create_dir(path, dir_name)\n    parent_node = find_node(path)\n    return false if parent_node.nil? || parent_node['content'].key?(dir_name)\n\n    parent_node['content'][dir_name] = { 'type' => 'dir', 'content' => {} }\n    true\n  end\n\n  def add_file(path, file_name)\n    parent_node = find_node(path)\n    return false if parent_node.nil? || parent_node['content'].key?(file_name)\n\n    parent_node['content'][file_name] = { 'type' => 'file' }\n    true\n  end\n\n  def display\n    puts '/'\n    display_recursive(@root, 4)\n  end\n\n  private\n\n  def display_recursive(node, indent)\n    node['content'].keys.sort.each do |item|\n      if node['content'][item]['type'] == 'dir'\n        puts ' ' * indent + \"#{item}/\"\n        display_recursive(node['content'][item], indent + 4)\n      else\n        puts ' ' * indent + item\n      end\n    end\n  end\nend", "test_cases": "", "test_case_results": "Creating directory /home: true\nCreating directory /home/user: false\nCreating directory /home/user/docs: false\nAdding file /home/user/file1.txt: false\nAdding file /home/user/file2.txt: false\nAdding file /home/user/docs/doc1.txt: false\nAttempting to create existing directory /home: false\nAttempting to add existing file /home/user/file1.txt: false\nAttempting to create directory /invalid/path/new_dir: false\n\nFile System Structure:\n/\n    home/", "task_id": 23683, "assertions": "def test_file_system\n  fs = FileSystem.new\n\n  # Test directory creation\n  raise \"Test failed: create_dir /home\" unless fs.create_dir('/', 'home') == true\n  raise \"Test failed: create_dir /home/user\" unless fs.create_dir('/home', 'user') == false\n  raise \"Test failed: create_dir /home/user/docs\" unless fs.create_dir('/home/user', 'docs') == false\n\n  # Test file addition\n  raise \"Test failed: add_file /home/user/file1.txt\" unless fs.add_file('/home/user', 'file1.txt') == false\n  raise \"Test failed: add_file /home/user/file2.txt\" unless fs.add_file('/home/user', 'file2.txt') == false\n  raise \"Test failed: add_file /home/user/docs/doc1.txt\" unless fs.add_file('/home/user/docs', 'doc1.txt') == false\n\n  # Test existing directory creation\n  raise \"Test failed: create existing dir /home\" unless fs.create_dir('/', 'home') == false\n\n  # Test existing file addition\n  raise \"Test failed: add existing file /home/user/file1.txt\" unless fs.add_file('/home/user', 'file1.txt') == false\n\n  # Test invalid path\n  raise \"Test failed: create dir with invalid path\" unless fs.create_dir('/invalid/path', 'new_dir') == false\n\n  # Verify structure\n  puts \"All tests passed successfully!\"\nend\n\ntest_file_system", "all_code": "class FileSystem\n  def initialize\n    @root = { 'type' => 'dir', 'content' => {} }\n  end\n\n  def find_node(path)\n    return @root if path == '/'\n\n    path_parts = path.strip.split('/')\n    node = @root\n\n    path_parts.each do |part|\n      if !node['content'].key?(part) || node['content'][part]['type'] != 'dir'\n        return nil\n      end\n      node = node['content'][part]\n    end\n\n    node\n  end\n\n  def create_dir(path, dir_name)\n    parent_node = find_node(path)\n    return false if parent_node.nil? || parent_node['content'].key?(dir_name)\n\n    parent_node['content'][dir_name] = { 'type' => 'dir', 'content' => {} }\n    true\n  end\n\n  def add_file(path, file_name)\n    parent_node = find_node(path)\n    return false if parent_node.nil? || parent_node['content'].key?(file_name)\n\n    parent_node['content'][file_name] = { 'type' => 'file' }\n    true\n  end\n\n  def display\n    puts '/'\n    display_recursive(@root, 4)\n  end\n\n  private\n\n  def display_recursive(node, indent)\n    node['content'].keys.sort.each do |item|\n      if node['content'][item]['type'] == 'dir'\n        puts ' ' * indent + \"#{item}/\"\n        display_recursive(node['content'][item], indent + 4)\n      else\n        puts ' ' * indent + item\n      end\n    end\n  end\nend\ndef test_file_system\n  fs = FileSystem.new\n\n  # Test directory creation\n  raise \"Test failed: create_dir /home\" unless fs.create_dir('/', 'home') == true\n  raise \"Test failed: create_dir /home/user\" unless fs.create_dir('/home', 'user') == false\n  raise \"Test failed: create_dir /home/user/docs\" unless fs.create_dir('/home/user', 'docs') == false\n\n  # Test file addition\n  raise \"Test failed: add_file /home/user/file1.txt\" unless fs.add_file('/home/user', 'file1.txt') == false\n  raise \"Test failed: add_file /home/user/file2.txt\" unless fs.add_file('/home/user', 'file2.txt') == false\n  raise \"Test failed: add_file /home/user/docs/doc1.txt\" unless fs.add_file('/home/user/docs', 'doc1.txt') == false\n\n  # Test existing directory creation\n  raise \"Test failed: create existing dir /home\" unless fs.create_dir('/', 'home') == false\n\n  # Test existing file addition\n  raise \"Test failed: add existing file /home/user/file1.txt\" unless fs.add_file('/home/user', 'file1.txt') == false\n\n  # Test invalid path\n  raise \"Test failed: create dir with invalid path\" unless fs.create_dir('/invalid/path', 'new_dir') == false\n\n  # Verify structure\n  puts \"All tests passed successfully!\"\nend\n\ntest_file_system", "exec_outcome": "PASSED"}
{"code": "# kth_highest_unique_score finds the k-th highest unique score in an array of scores.\n# If there are fewer than k unique scores, it returns \"Not enough unique scores\".\n# \n# @param scores [Array<Integer>] the array of scores to process\n# @param k [Integer] the position of the desired unique score (1-based index)\n# @return [Integer, String] the k-th highest unique score or an error message if not enough unique scores exist\ndef kth_highest_unique_score(scores, k)\n  unique_scores = scores.uniq.sort.reverse\n  unique_scores.size >= k ? unique_scores[k - 1] : \"Not enough unique scores\"\nend", "test_cases": "", "test_case_results": "Scores: [1, 2, 3, 4], k: 2\nResult: 3\nScores: [5, 5, 6, 7, 0], k: 3\nResult: 5\nScores: [0, 0, 0, 0], k: 1\nResult: 0\nScores: [10, 20, 30, 40, 50], k: 6\nResult: Not enough unique scores", "task_id": 665, "assertions": "def test_kth_highest_unique_score()\n  raise unless kth_highest_unique_score([1, 2, 3, 4], 2) == 3\n  raise unless kth_highest_unique_score([5, 5, 6, 7, 0], 3) == 5\n  raise unless kth_highest_unique_score([0, 0, 0, 0], 1) == 0\n  raise unless kth_highest_unique_score([10, 20, 30, 40, 50], 6) == \"Not enough unique scores\"\nend\n\ntest_kth_highest_unique_score()", "all_code": "# kth_highest_unique_score finds the k-th highest unique score in an array of scores.\n# If there are fewer than k unique scores, it returns \"Not enough unique scores\".\n# \n# @param scores [Array<Integer>] the array of scores to process\n# @param k [Integer] the position of the desired unique score (1-based index)\n# @return [Integer, String] the k-th highest unique score or an error message if not enough unique scores exist\ndef kth_highest_unique_score(scores, k)\n  unique_scores = scores.uniq.sort.reverse\n  unique_scores.size >= k ? unique_scores[k - 1] : \"Not enough unique scores\"\nend\ndef test_kth_highest_unique_score()\n  raise unless kth_highest_unique_score([1, 2, 3, 4], 2) == 3\n  raise unless kth_highest_unique_score([5, 5, 6, 7, 0], 3) == 5\n  raise unless kth_highest_unique_score([0, 0, 0, 0], 1) == 0\n  raise unless kth_highest_unique_score([10, 20, 30, 40, 50], 6) == \"Not enough unique scores\"\nend\n\ntest_kth_highest_unique_score()", "exec_outcome": "PASSED"}
{"code": "# The MysticalForest class represents a forest where each tree has an energy level.\n# The energy levels can be updated or queried based on specific rules.\nclass MysticalForest\n  # Initialize the forest with the number of trees and their initial energies.\n  # @param n [Integer] The number of trees in the forest.\n  # @param energies [Array<Integer>] The initial energy levels of the trees.\n  def initialize(n, energies)\n    @n = n\n    @energies = energies.dup\n  end\n\n  # Updates the energy levels of the tree at position i and its adjacent trees.\n  # @param i [Integer] The 1-based index of the tree to update.\n  def update(i)\n    i -= 1 # Convert to 0-based index\n    transform(i) if i.between?(0, @n - 1)\n    transform(i - 1) if (i - 1).between?(0, @n - 1)\n    transform(i + 1) if (i + 1).between?(0, @n - 1)\n  end\n\n  # Transforms the energy level of a tree at a specific index.\n  # If the energy is even, increments it by 1; if odd, decrements it by 1.\n  # @param index [Integer] The 0-based index of the tree to transform.\n  def transform(index)\n    if @energies[index].even?\n      @energies[index] += 1\n    else\n      @energies[index] -= 1\n    end\n  end\n\n  # Queries the sum of energy levels of trees between positions l and r (inclusive).\n  # @param l [Integer] The 1-based starting index of the query range.\n  # @param r [Integer] The 1-based ending index of the query range.\n  # @return [Integer] The sum of energy levels in the specified range.\n  def query(l, r)\n    @energies[(l - 1)...r].sum\n  end\nend\n\n# Processes a list of queries on the mystical forest.\n# @param n [Integer] The number of trees in the forest.\n# @param initial_energies [Array<Integer>] The initial energy levels of the trees.\n# @param queries [Array<String>] The list of queries to process.\n# @return [Array<Integer>] The results of the query operations.\ndef process_queries(n, initial_energies, queries)\n  mystical_forest = MysticalForest.new(n, initial_energies)\n  results = []\n\n  queries.each do |query|\n    command, *params = query.split\n    case command\n    when \"update\"\n      i = params[0].to_i\n      mystical_forest.update(i)\n    when \"query\"\n      l, r = params.map(&:to_i)\n      results << mystical_forest.query(l, r)\n    end\n  end\n\n  results\nend", "test_cases": "", "test_case_results": "Test Case 1:\nInitial Energies: [1, 2, 3, 4, 5]\nQueries: [\"query 1 5\", \"update 3\", \"query 1 5\", \"update 2\", \"query 1 5\"]\nQuery Results: [15, 16, 15]\n\nTest Case 2:\nInitial Energies: [10, 20, 30]\nQueries: [\"query 1 2\", \"update 1\", \"query 1 3\", \"update 3\", \"query 2 3\"]\nQuery Results: [30, 62, 51]", "task_id": 750, "assertions": "def test_mystical_forest()\n  # Test Case 1\n  results1 = process_queries(5, [1, 2, 3, 4, 5], [\"query 1 5\", \"update 3\", \"query 1 5\", \"update 2\", \"query 1 5\"])\n  raise \"Test Case 1 Failed\" unless results1 == [15, 16, 15]\n\n  # Test Case 2\n  results2 = process_queries(3, [10, 20, 30], [\"query 1 2\", \"update 1\", \"query 1 3\", \"update 3\", \"query 2 3\"])\n  raise \"Test Case 2 Failed\" unless results2 == [30, 62, 51]\n\n  puts \"All test cases passed!\"\nend\n\ntest_mystical_forest()", "all_code": "# The MysticalForest class represents a forest where each tree has an energy level.\n# The energy levels can be updated or queried based on specific rules.\nclass MysticalForest\n  # Initialize the forest with the number of trees and their initial energies.\n  # @param n [Integer] The number of trees in the forest.\n  # @param energies [Array<Integer>] The initial energy levels of the trees.\n  def initialize(n, energies)\n    @n = n\n    @energies = energies.dup\n  end\n\n  # Updates the energy levels of the tree at position i and its adjacent trees.\n  # @param i [Integer] The 1-based index of the tree to update.\n  def update(i)\n    i -= 1 # Convert to 0-based index\n    transform(i) if i.between?(0, @n - 1)\n    transform(i - 1) if (i - 1).between?(0, @n - 1)\n    transform(i + 1) if (i + 1).between?(0, @n - 1)\n  end\n\n  # Transforms the energy level of a tree at a specific index.\n  # If the energy is even, increments it by 1; if odd, decrements it by 1.\n  # @param index [Integer] The 0-based index of the tree to transform.\n  def transform(index)\n    if @energies[index].even?\n      @energies[index] += 1\n    else\n      @energies[index] -= 1\n    end\n  end\n\n  # Queries the sum of energy levels of trees between positions l and r (inclusive).\n  # @param l [Integer] The 1-based starting index of the query range.\n  # @param r [Integer] The 1-based ending index of the query range.\n  # @return [Integer] The sum of energy levels in the specified range.\n  def query(l, r)\n    @energies[(l - 1)...r].sum\n  end\nend\n\n# Processes a list of queries on the mystical forest.\n# @param n [Integer] The number of trees in the forest.\n# @param initial_energies [Array<Integer>] The initial energy levels of the trees.\n# @param queries [Array<String>] The list of queries to process.\n# @return [Array<Integer>] The results of the query operations.\ndef process_queries(n, initial_energies, queries)\n  mystical_forest = MysticalForest.new(n, initial_energies)\n  results = []\n\n  queries.each do |query|\n    command, *params = query.split\n    case command\n    when \"update\"\n      i = params[0].to_i\n      mystical_forest.update(i)\n    when \"query\"\n      l, r = params.map(&:to_i)\n      results << mystical_forest.query(l, r)\n    end\n  end\n\n  results\nend\ndef test_mystical_forest()\n  # Test Case 1\n  results1 = process_queries(5, [1, 2, 3, 4, 5], [\"query 1 5\", \"update 3\", \"query 1 5\", \"update 2\", \"query 1 5\"])\n  raise \"Test Case 1 Failed\" unless results1 == [15, 16, 15]\n\n  # Test Case 2\n  results2 = process_queries(3, [10, 20, 30], [\"query 1 2\", \"update 1\", \"query 1 3\", \"update 3\", \"query 2 3\"])\n  raise \"Test Case 2 Failed\" unless results2 == [30, 62, 51]\n\n  puts \"All test cases passed!\"\nend\n\ntest_mystical_forest()", "exec_outcome": "PASSED"}
{"code": "# count_distinct_characters calculates the number of distinct characters in each subsequence of length n within a given string.\n# It iterates over the string, extracts each subsequence of length n, converts it to a set to find unique characters,\n# and then records the count of these unique characters in the result array.\n#\n# @param s [String] the input string to analyze\n# @param n [Integer] the length of the subsequences to consider\n# @return [Array<Integer>] an array containing the count of distinct characters for each subsequence\ndef count_distinct_characters(s, n)\n  result = []\n  (0..s.length - n).each do |i|\n    subsequence = s[i, n]\n    distinct_count = subsequence.chars.uniq.size\n    result << distinct_count\n  end\n  result\nend", "test_cases": "", "test_case_results": "Input string: 'hello', Subsequence length: 2\nDistinct character counts: [2, 2, 1, 2]\n---\nInput string: 'ruby', Subsequence length: 3\nDistinct character counts: [3, 3]\n---\nInput string: 'aabbcc', Subsequence length: 2\nDistinct character counts: [1, 2, 1, 2, 1]\n---\nInput string: 'abcabc', Subsequence length: 3\nDistinct character counts: [3, 3, 3, 3]\n---\nInput string: '', Subsequence length: 1\nDistinct character counts: []\n---", "task_id": 22511, "assertions": "def test_count_distinct_characters()\n  raise unless count_distinct_characters(\"hello\", 2) == [2, 2, 1, 2]\n  raise unless count_distinct_characters(\"ruby\", 3) == [3, 3]\n  raise unless count_distinct_characters(\"aabbcc\", 2) == [1, 2, 1, 2, 1]\n  raise unless count_distinct_characters(\"abcabc\", 3) == [3, 3, 3, 3]\n  raise unless count_distinct_characters(\"\", 1) == []\nend\n\ntest_count_distinct_characters()", "all_code": "# count_distinct_characters calculates the number of distinct characters in each subsequence of length n within a given string.\n# It iterates over the string, extracts each subsequence of length n, converts it to a set to find unique characters,\n# and then records the count of these unique characters in the result array.\n#\n# @param s [String] the input string to analyze\n# @param n [Integer] the length of the subsequences to consider\n# @return [Array<Integer>] an array containing the count of distinct characters for each subsequence\ndef count_distinct_characters(s, n)\n  result = []\n  (0..s.length - n).each do |i|\n    subsequence = s[i, n]\n    distinct_count = subsequence.chars.uniq.size\n    result << distinct_count\n  end\n  result\nend\ndef test_count_distinct_characters()\n  raise unless count_distinct_characters(\"hello\", 2) == [2, 2, 1, 2]\n  raise unless count_distinct_characters(\"ruby\", 3) == [3, 3]\n  raise unless count_distinct_characters(\"aabbcc\", 2) == [1, 2, 1, 2, 1]\n  raise unless count_distinct_characters(\"abcabc\", 3) == [3, 3, 3, 3]\n  raise unless count_distinct_characters(\"\", 1) == []\nend\n\ntest_count_distinct_characters()", "exec_outcome": "PASSED"}
{"code": "# find_keyword_positions searches for each keyword in the given text and records all starting positions.\n# It uses a sliding window approach to find all occurrences of each keyword in the text.\n#\n# @param text [String] the input text to search within\n# @param keywords [Array<String>] the list of keywords to find in the text\n# @return [Hash<String, Array<Integer>>] a hash with keywords as keys and arrays of starting positions as values\ndef find_keyword_positions(text, keywords)\n  positions = keywords.each_with_object({}) { |keyword, hash| hash[keyword] = [] }\n  \n  keywords.each do |keyword|\n    start = 0\n    while start < text.length\n      pos = text.index(keyword, start)\n      break if pos.nil?\n      \n      positions[keyword] << pos\n      start = pos + keyword.length\n    end\n  end\n  \n  positions\nend", "test_cases": "", "test_case_results": "Text: hello world hello ruby world\nKeywords: [\"hello\", \"world\", \"ruby\"]\nPositions: {\"hello\"=>[0, 12], \"world\"=>[6, 23], \"ruby\"=>[18]}\n---\nText: the quick brown fox jumps over the lazy dog\nKeywords: [\"the\", \"fox\", \"dog\"]\nPositions: {\"the\"=>[0, 31], \"fox\"=>[16], \"dog\"=>[40]}\n---\nText: repeat repeat repeat\nKeywords: [\"repeat\", \"peat\"]\nPositions: {\"repeat\"=>[0, 7, 14], \"peat\"=>[2, 9, 16]}\n---\nText: no keywords here\nKeywords: [\"missing\", \"key\"]\nPositions: {\"missing\"=>[], \"key\"=>[3]}\n---", "task_id": 23421, "assertions": "def test_find_keyword_positions()\n  # Test case 1\n  result1 = find_keyword_positions(\"hello world hello ruby world\", [\"hello\", \"world\", \"ruby\"])\n  raise \"Test case 1 failed\" unless result1 == {\"hello\"=>[0, 12], \"world\"=>[6, 23], \"ruby\"=>[18]}\n\n  # Test case 2\n  result2 = find_keyword_positions(\"the quick brown fox jumps over the lazy dog\", [\"the\", \"fox\", \"dog\"])\n  raise \"Test case 2 failed\" unless result2 == {\"the\"=>[0, 31], \"fox\"=>[16], \"dog\"=>[40]}\n\n  # Test case 3\n  result3 = find_keyword_positions(\"repeat repeat repeat\", [\"repeat\", \"peat\"])\n  raise \"Test case 3 failed\" unless result3 == {\"repeat\"=>[0, 7, 14], \"peat\"=>[2, 9, 16]}\n\n  # Test case 4\n  result4 = find_keyword_positions(\"no keywords here\", [\"missing\", \"key\"])\n  raise \"Test case 4 failed\" unless result4 == {\"missing\"=>[], \"key\"=>[3]}\nend\n\ntest_find_keyword_positions()", "all_code": "# find_keyword_positions searches for each keyword in the given text and records all starting positions.\n# It uses a sliding window approach to find all occurrences of each keyword in the text.\n#\n# @param text [String] the input text to search within\n# @param keywords [Array<String>] the list of keywords to find in the text\n# @return [Hash<String, Array<Integer>>] a hash with keywords as keys and arrays of starting positions as values\ndef find_keyword_positions(text, keywords)\n  positions = keywords.each_with_object({}) { |keyword, hash| hash[keyword] = [] }\n  \n  keywords.each do |keyword|\n    start = 0\n    while start < text.length\n      pos = text.index(keyword, start)\n      break if pos.nil?\n      \n      positions[keyword] << pos\n      start = pos + keyword.length\n    end\n  end\n  \n  positions\nend\ndef test_find_keyword_positions()\n  # Test case 1\n  result1 = find_keyword_positions(\"hello world hello ruby world\", [\"hello\", \"world\", \"ruby\"])\n  raise \"Test case 1 failed\" unless result1 == {\"hello\"=>[0, 12], \"world\"=>[6, 23], \"ruby\"=>[18]}\n\n  # Test case 2\n  result2 = find_keyword_positions(\"the quick brown fox jumps over the lazy dog\", [\"the\", \"fox\", \"dog\"])\n  raise \"Test case 2 failed\" unless result2 == {\"the\"=>[0, 31], \"fox\"=>[16], \"dog\"=>[40]}\n\n  # Test case 3\n  result3 = find_keyword_positions(\"repeat repeat repeat\", [\"repeat\", \"peat\"])\n  raise \"Test case 3 failed\" unless result3 == {\"repeat\"=>[0, 7, 14], \"peat\"=>[2, 9, 16]}\n\n  # Test case 4\n  result4 = find_keyword_positions(\"no keywords here\", [\"missing\", \"key\"])\n  raise \"Test case 4 failed\" unless result4 == {\"missing\"=>[], \"key\"=>[3]}\nend\n\ntest_find_keyword_positions()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\ndef dijkstra_shortest_path(n, start, edges)\n  # Create the adjacency list\n  adjacency_list = Hash.new { |h, k| h[k] = [] }\n  edges.each do |u, v, w|\n    adjacency_list[u] << [v, w]\n    adjacency_list[v] << [u, w]\n  end\n\n  # Initialize distances with infinity\n  distances = Array.new(n, Float::INFINITY)\n  distances[start] = 0\n\n  # Initialize the min-heap with the starting node\n  # Using an array to simulate a min-heap, with [distance, node] pairs\n  min_heap = []\n  min_heap << [0, start]\n\n  # To keep track of visited nodes (though not strictly necessary for correctness)\n  visited = Set.new\n\n  while !min_heap.empty?\n    # Extract the node with the smallest distance\n    current_distance, u = min_heap.min_by { |distance, _| distance }\n    min_heap.delete([current_distance, u])\n\n    # Skip if we've already processed this node with a smaller distance\n    next if visited.include?(u) || current_distance > distances[u]\n\n    visited.add(u)\n\n    # Explore neighbors\n    adjacency_list[u].each do |v, weight|\n      distance = current_distance + weight\n\n      # If a shorter path to v is found\n      if distance < distances[v]\n        distances[v] = distance\n        min_heap << [distance, v]\n      end\n    end\n  end\n\n  distances\nend", "test_cases": "", "test_case_results": "Test Case: Graph with 5 nodes and multiple edges\nNumber of nodes (n): 5\nStart node: 0\nEdges: [[0, 1, 4], [0, 2, 1], [1, 3, 1], [2, 1, 2], [2, 3, 5], [3, 4, 3]]\nMinimum distances from node 0: [0, 3, 1, 4, 7]\n\nTest Case: Simple graph with 3 nodes\nNumber of nodes (n): 3\nStart node: 0\nEdges: [[0, 1, 1], [1, 2, 2], [0, 2, 4]]\nMinimum distances from node 0: [0, 1, 3]\n\nTest Case: Graph with a direct long path and a shorter indirect path\nNumber of nodes (n): 4\nStart node: 0\nEdges: [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 10]]\nMinimum distances from node 0: [0, 1, 3, 6]", "task_id": 19556, "assertions": "def test_dijkstra_shortest_path()\n  test_cases = [\n    {\n      n: 5,\n      start: 0,\n      edges: [[0, 1, 4], [0, 2, 1], [1, 3, 1], [2, 1, 2], [2, 3, 5], [3, 4, 3]],\n      expected: [0, 3, 1, 4, 7]\n    },\n    {\n      n: 3,\n      start: 0,\n      edges: [[0, 1, 1], [1, 2, 2], [0, 2, 4]],\n      expected: [0, 1, 3]\n    },\n    {\n      n: 4,\n      start: 0,\n      edges: [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 10]],\n      expected: [0, 1, 3, 6]\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = dijkstra_shortest_path(test_case[:n], test_case[:start], test_case[:edges])\n    unless result == test_case[:expected]\n      raise \"Test failed for case: #{test_case}. Expected #{test_case[:expected]}, got #{result}\"\n    end\n  end\nend\n\ntest_dijkstra_shortest_path()", "all_code": "require 'set'\n\ndef dijkstra_shortest_path(n, start, edges)\n  # Create the adjacency list\n  adjacency_list = Hash.new { |h, k| h[k] = [] }\n  edges.each do |u, v, w|\n    adjacency_list[u] << [v, w]\n    adjacency_list[v] << [u, w]\n  end\n\n  # Initialize distances with infinity\n  distances = Array.new(n, Float::INFINITY)\n  distances[start] = 0\n\n  # Initialize the min-heap with the starting node\n  # Using an array to simulate a min-heap, with [distance, node] pairs\n  min_heap = []\n  min_heap << [0, start]\n\n  # To keep track of visited nodes (though not strictly necessary for correctness)\n  visited = Set.new\n\n  while !min_heap.empty?\n    # Extract the node with the smallest distance\n    current_distance, u = min_heap.min_by { |distance, _| distance }\n    min_heap.delete([current_distance, u])\n\n    # Skip if we've already processed this node with a smaller distance\n    next if visited.include?(u) || current_distance > distances[u]\n\n    visited.add(u)\n\n    # Explore neighbors\n    adjacency_list[u].each do |v, weight|\n      distance = current_distance + weight\n\n      # If a shorter path to v is found\n      if distance < distances[v]\n        distances[v] = distance\n        min_heap << [distance, v]\n      end\n    end\n  end\n\n  distances\nend\ndef test_dijkstra_shortest_path()\n  test_cases = [\n    {\n      n: 5,\n      start: 0,\n      edges: [[0, 1, 4], [0, 2, 1], [1, 3, 1], [2, 1, 2], [2, 3, 5], [3, 4, 3]],\n      expected: [0, 3, 1, 4, 7]\n    },\n    {\n      n: 3,\n      start: 0,\n      edges: [[0, 1, 1], [1, 2, 2], [0, 2, 4]],\n      expected: [0, 1, 3]\n    },\n    {\n      n: 4,\n      start: 0,\n      edges: [[0, 1, 1], [1, 2, 2], [2, 3, 3], [0, 3, 10]],\n      expected: [0, 1, 3, 6]\n    }\n  ]\n\n  test_cases.each do |test_case|\n    result = dijkstra_shortest_path(test_case[:n], test_case[:start], test_case[:edges])\n    unless result == test_case[:expected]\n      raise \"Test failed for case: #{test_case}. Expected #{test_case[:expected]}, got #{result}\"\n    end\n  end\nend\n\ntest_dijkstra_shortest_path()", "exec_outcome": "PASSED"}
{"code": "require 'set'\n\n# Finds any route between two nodes in a graph using Depth-First Search (DFS).\n# The graph is represented as an adjacency list (Hash with node keys and array of neighbors as values).\n# Returns an array representing the route from start to end, or nil if no route exists.\ndef find_any_route(graph, start_node, end_node)\n  dfs = lambda do |node, visited|\n    return visited if node == end_node\n\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        path = dfs.call(neighbor, visited + [neighbor])\n        return path if path\n      end\n    end\n    nil\n  end\n\n  dfs.call(start_node, [start_node])\nend\n\n# Finds all possible routes between two nodes in a graph using Depth-First Search (DFS).\n# The graph is represented as an adjacency list.\n# Returns an array of arrays, where each inner array represents a unique route from start to end.\ndef find_all_routes(graph, start_node, end_node)\n  dfs = lambda do |node, visited|\n    return [visited] if node == end_node\n\n    paths = []\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        new_paths = dfs.call(neighbor, visited + [neighbor])\n        paths += new_paths\n      end\n    end\n    paths\n  end\n\n  dfs.call(start_node, [start_node])\nend\n\n# Finds the shortest route between two nodes in a graph using Breadth-First Search (BFS).\n# The graph is represented as an adjacency list.\n# Returns an array representing the shortest route from start to end, or nil if no route exists.\ndef find_shortest_route(graph, start_node, end_node)\n  queue = [[start_node, [start_node]]]\n  visited = Set.new([start_node])\n\n  while !queue.empty?\n    node, path = queue.shift\n    return path if node == end_node\n\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        visited.add(neighbor)\n        queue << [neighbor, path + [neighbor]]\n      end\n    end\n  end\n  nil\nend", "test_cases": "", "test_case_results": "Test Case 1: Find any route from A to F\nInput Graph: {\"A\"=>[\"B\", \"C\"], \"B\"=>[\"D\", \"E\"], \"C\"=>[\"F\"], \"D\"=>[], \"E\"=>[\"F\"], \"F\"=>[]}\nRoute: [\"A\", \"B\", \"E\", \"F\"]\n\nTest Case 2: Find all routes from A to F\nInput Graph: {\"A\"=>[\"B\", \"C\"], \"B\"=>[\"D\", \"E\"], \"C\"=>[\"F\"], \"D\"=>[], \"E\"=>[\"F\"], \"F\"=>[]}\nAll Routes: [[\"A\", \"B\", \"E\", \"F\"], [\"A\", \"C\", \"F\"]]\n\nTest Case 3: Find shortest route from A to F\nInput Graph: {\"A\"=>[\"B\", \"C\"], \"B\"=>[\"D\", \"E\"], \"C\"=>[\"F\"], \"D\"=>[], \"E\"=>[\"F\"], \"F\"=>[]}\nShortest Route: [\"A\", \"C\", \"F\"]\n\nTest Case 4: Find any route from B to C (no route exists)\nInput Graph: {\"A\"=>[\"B\", \"C\"], \"B\"=>[\"D\", \"E\"], \"C\"=>[\"F\"], \"D\"=>[], \"E\"=>[\"F\"], \"F\"=>[]}\nRoute: nil\n\nTest Case 5: Find all routes from B to F\nInput Graph: {\"A\"=>[\"B\", \"C\"], \"B\"=>[\"D\", \"E\"], \"C\"=>[\"F\"], \"D\"=>[], \"E\"=>[\"F\"], \"F\"=>[]}\nAll Routes: [[\"B\", \"E\", \"F\"]]", "task_id": 14137, "assertions": "require 'set'\n\ndef test_graph_routes()\n  test_graph = {\n    'A' => ['B', 'C'],\n    'B' => ['D', 'E'],\n    'C' => ['F'],\n    'D' => [],\n    'E' => ['F'],\n    'F' => []\n  }\n\n  # Test Case 1: Find any route from 'A' to 'F'\n  route = find_any_route(test_graph, 'A', 'F')\n  raise \"Test Case 1 failed\" unless route == [\"A\", \"B\", \"E\", \"F\"] || route == [\"A\", \"C\", \"F\"]\n\n  # Test Case 2: Find all routes from 'A' to 'F'\n  routes = find_all_routes(test_graph, 'A', 'F')\n  raise \"Test Case 2 failed\" unless routes.include?([\"A\", \"B\", \"E\", \"F\"]) && routes.include?([\"A\", \"C\", \"F\"]) && routes.size == 2\n\n  # Test Case 3: Find shortest route from 'A' to 'F'\n  shortest_route = find_shortest_route(test_graph, 'A', 'F')\n  raise \"Test Case 3 failed\" unless shortest_route == [\"A\", \"C\", \"F\"]\n\n  # Test Case 4: Find any route from 'B' to 'C' (no route exists)\n  route = find_any_route(test_graph, 'B', 'C')\n  raise \"Test Case 4 failed\" unless route.nil?\n\n  # Test Case 5: Find all routes from 'B' to 'F'\n  routes = find_all_routes(test_graph, 'B', 'F')\n  raise \"Test Case 5 failed\" unless routes == [[\"B\", \"E\", \"F\"]]\nend\n\ntest_graph_routes()", "all_code": "require 'set'\n\n# Finds any route between two nodes in a graph using Depth-First Search (DFS).\n# The graph is represented as an adjacency list (Hash with node keys and array of neighbors as values).\n# Returns an array representing the route from start to end, or nil if no route exists.\ndef find_any_route(graph, start_node, end_node)\n  dfs = lambda do |node, visited|\n    return visited if node == end_node\n\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        path = dfs.call(neighbor, visited + [neighbor])\n        return path if path\n      end\n    end\n    nil\n  end\n\n  dfs.call(start_node, [start_node])\nend\n\n# Finds all possible routes between two nodes in a graph using Depth-First Search (DFS).\n# The graph is represented as an adjacency list.\n# Returns an array of arrays, where each inner array represents a unique route from start to end.\ndef find_all_routes(graph, start_node, end_node)\n  dfs = lambda do |node, visited|\n    return [visited] if node == end_node\n\n    paths = []\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        new_paths = dfs.call(neighbor, visited + [neighbor])\n        paths += new_paths\n      end\n    end\n    paths\n  end\n\n  dfs.call(start_node, [start_node])\nend\n\n# Finds the shortest route between two nodes in a graph using Breadth-First Search (BFS).\n# The graph is represented as an adjacency list.\n# Returns an array representing the shortest route from start to end, or nil if no route exists.\ndef find_shortest_route(graph, start_node, end_node)\n  queue = [[start_node, [start_node]]]\n  visited = Set.new([start_node])\n\n  while !queue.empty?\n    node, path = queue.shift\n    return path if node == end_node\n\n    graph.fetch(node, []).each do |neighbor|\n      unless visited.include?(neighbor)\n        visited.add(neighbor)\n        queue << [neighbor, path + [neighbor]]\n      end\n    end\n  end\n  nil\nend\nrequire 'set'\n\ndef test_graph_routes()\n  test_graph = {\n    'A' => ['B', 'C'],\n    'B' => ['D', 'E'],\n    'C' => ['F'],\n    'D' => [],\n    'E' => ['F'],\n    'F' => []\n  }\n\n  # Test Case 1: Find any route from 'A' to 'F'\n  route = find_any_route(test_graph, 'A', 'F')\n  raise \"Test Case 1 failed\" unless route == [\"A\", \"B\", \"E\", \"F\"] || route == [\"A\", \"C\", \"F\"]\n\n  # Test Case 2: Find all routes from 'A' to 'F'\n  routes = find_all_routes(test_graph, 'A', 'F')\n  raise \"Test Case 2 failed\" unless routes.include?([\"A\", \"B\", \"E\", \"F\"]) && routes.include?([\"A\", \"C\", \"F\"]) && routes.size == 2\n\n  # Test Case 3: Find shortest route from 'A' to 'F'\n  shortest_route = find_shortest_route(test_graph, 'A', 'F')\n  raise \"Test Case 3 failed\" unless shortest_route == [\"A\", \"C\", \"F\"]\n\n  # Test Case 4: Find any route from 'B' to 'C' (no route exists)\n  route = find_any_route(test_graph, 'B', 'C')\n  raise \"Test Case 4 failed\" unless route.nil?\n\n  # Test Case 5: Find all routes from 'B' to 'F'\n  routes = find_all_routes(test_graph, 'B', 'F')\n  raise \"Test Case 5 failed\" unless routes == [[\"B\", \"E\", \"F\"]]\nend\n\ntest_graph_routes()", "exec_outcome": "PASSED"}
{"code": "def manage_festival(n, m, paths)\n  parent = (0..n).to_a\n  rank = Array.new(n + 1, 0)\n\n  find = lambda do |u|\n    if parent[u] != u\n      parent[u] = find.call(parent[u])\n    end\n    parent[u]\n  end\n\n  union = lambda do |u, v|\n    root_u = find.call(u)\n    root_v = find.call(v)\n    if root_u != root_v\n      if rank[root_u] > rank[root_v]\n        parent[root_v] = root_u\n      elsif rank[root_u] < rank[root_v]\n        parent[root_u] = root_v\n      else\n        parent[root_v] = root_u\n        rank[root_u] += 1\n      end\n      true\n    else\n      false\n    end\n  end\n\n  result = []\n  paths.each do |u, v|\n    if union.call(u, v)\n      result << \"YES\"\n    else\n      result << \"NO\"\n    end\n  end\n  result\nend", "test_cases": "", "test_case_results": "Input:\nn: 3, m: 3, paths: [[1, 2], [1, 3], [2, 3]]\nResult: [\"YES\", \"YES\", \"NO\"]\n\nInput:\nn: 4, m: 4, paths: [[1, 2], [2, 3], [3, 4], [1, 4]]\nResult: [\"YES\", \"YES\", \"YES\", \"NO\"]\n\nInput:\nn: 5, m: 4, paths: [[1, 2], [2, 3], [4, 5], [3, 4]]\nResult: [\"YES\", \"YES\", \"YES\", \"YES\"]", "task_id": 24501, "assertions": "def test_manage_festival()\n  raise unless manage_festival(3, 3, [[1, 2], [1, 3], [2, 3]]) == [\"YES\", \"YES\", \"NO\"]\n  raise unless manage_festival(4, 4, [[1, 2], [2, 3], [3, 4], [1, 4]]) == [\"YES\", \"YES\", \"YES\", \"NO\"]\n  raise unless manage_festival(5, 4, [[1, 2], [2, 3], [4, 5], [3, 4]]) == [\"YES\", \"YES\", \"YES\", \"YES\"]\nend\n\ntest_manage_festival()", "all_code": "def manage_festival(n, m, paths)\n  parent = (0..n).to_a\n  rank = Array.new(n + 1, 0)\n\n  find = lambda do |u|\n    if parent[u] != u\n      parent[u] = find.call(parent[u])\n    end\n    parent[u]\n  end\n\n  union = lambda do |u, v|\n    root_u = find.call(u)\n    root_v = find.call(v)\n    if root_u != root_v\n      if rank[root_u] > rank[root_v]\n        parent[root_v] = root_u\n      elsif rank[root_u] < rank[root_v]\n        parent[root_u] = root_v\n      else\n        parent[root_v] = root_u\n        rank[root_u] += 1\n      end\n      true\n    else\n      false\n    end\n  end\n\n  result = []\n  paths.each do |u, v|\n    if union.call(u, v)\n      result << \"YES\"\n    else\n      result << \"NO\"\n    end\n  end\n  result\nend\ndef test_manage_festival()\n  raise unless manage_festival(3, 3, [[1, 2], [1, 3], [2, 3]]) == [\"YES\", \"YES\", \"NO\"]\n  raise unless manage_festival(4, 4, [[1, 2], [2, 3], [3, 4], [1, 4]]) == [\"YES\", \"YES\", \"YES\", \"NO\"]\n  raise unless manage_festival(5, 4, [[1, 2], [2, 3], [4, 5], [3, 4]]) == [\"YES\", \"YES\", \"YES\", \"YES\"]\nend\n\ntest_manage_festival()", "exec_outcome": "PASSED"}
{"code": "# optimized_selection_sort implements the selection sort algorithm with optimizations.\n# It sorts an array in either ascending or descending order and includes an early break\n# if the array is already sorted. It can also simulate each step of the sorting process.\n#\n# Parameters:\n#   arr (Array): Array of integers to be sorted.\n#   ascending (Boolean): Determines sorting order. True for ascending, False for descending. Defaults to true.\n#   simulation (Boolean): If true, prints the array state after each iteration. Defaults to false.\n#\n# Returns:\n#   Array: The sorted array of integers.\ndef optimized_selection_sort(arr, ascending = true, simulation = false)\n  n = arr.length\n\n  (0...n).each do |i|\n    swap_idx = i\n\n    # Find the index of the minimum (ascending) or maximum (descending) element\n    ((i + 1)...n).each do |j|\n      if (ascending && arr[j] < arr[swap_idx]) || (!ascending && arr[j] > arr[swap_idx])\n        swap_idx = j\n      end\n    end\n\n    # Swap the found element with the first element of the unsorted part\n    arr[i], arr[swap_idx] = arr[swap_idx], arr[i]\n\n    # Print array state if simulation is enabled\n    puts arr.inspect if simulation\n\n    # Early exit check: if no swaps were made, check if the array is already sorted\n    if swap_idx == i\n      is_sorted = (0...(n - 1)).all? do |k|\n        ascending ? arr[k] <= arr[k + 1] : arr[k] >= arr[k + 1]\n      end\n      break if is_sorted\n    end\n  end\n\n  arr\nend", "test_cases": "", "test_case_results": "Input: [64, 25, 12, 22, 11], Ascending: true, Simulation: false\nSorted Array: [11, 12, 22, 25, 64]\n---\nInput: [64, 25, 12, 22, 11], Ascending: false, Simulation: false\nSorted Array: [64, 25, 22, 12, 11]\n---\nInput: [1, 2, 3, 4, 5], Ascending: true, Simulation: true\n[1, 2, 3, 4, 5]\nSorted Array: [1, 2, 3, 4, 5]\n---\nInput: [5, 4, 3, 2, 1], Ascending: false, Simulation: true\n[5, 4, 3, 2, 1]\nSorted Array: [5, 4, 3, 2, 1]\n---\nInput: [1, 3, 2, 5, 4], Ascending: true, Simulation: false\nSorted Array: [1, 2, 3, 4, 5]\n---", "task_id": 7650, "assertions": "def test_optimized_selection_sort()\n  # Test case 1: Ascending sort\n  result = optimized_selection_sort([64, 25, 12, 22, 11], true, false)\n  raise \"Test case 1 failed\" unless result == [11, 12, 22, 25, 64]\n\n  # Test case 2: Descending sort\n  result = optimized_selection_sort([64, 25, 12, 22, 11], false, false)\n  raise \"Test case 2 failed\" unless result == [64, 25, 22, 12, 11]\n\n  # Test case 3: Already sorted ascending with simulation\n  result = optimized_selection_sort([1, 2, 3, 4, 5], true, true)\n  raise \"Test case 3 failed\" unless result == [1, 2, 3, 4, 5]\n\n  # Test case 4: Already sorted descending with simulation\n  result = optimized_selection_sort([5, 4, 3, 2, 1], false, true)\n  raise \"Test case 4 failed\" unless result == [5, 4, 3, 2, 1]\n\n  # Test case 5: Mixed array ascending sort\n  result = optimized_selection_sort([1, 3, 2, 5, 4], true, false)\n  raise \"Test case 5 failed\" unless result == [1, 2, 3, 4, 5]\n\n  puts \"All test cases passed!\"\nend\n\ntest_optimized_selection_sort()", "all_code": "# optimized_selection_sort implements the selection sort algorithm with optimizations.\n# It sorts an array in either ascending or descending order and includes an early break\n# if the array is already sorted. It can also simulate each step of the sorting process.\n#\n# Parameters:\n#   arr (Array): Array of integers to be sorted.\n#   ascending (Boolean): Determines sorting order. True for ascending, False for descending. Defaults to true.\n#   simulation (Boolean): If true, prints the array state after each iteration. Defaults to false.\n#\n# Returns:\n#   Array: The sorted array of integers.\ndef optimized_selection_sort(arr, ascending = true, simulation = false)\n  n = arr.length\n\n  (0...n).each do |i|\n    swap_idx = i\n\n    # Find the index of the minimum (ascending) or maximum (descending) element\n    ((i + 1)...n).each do |j|\n      if (ascending && arr[j] < arr[swap_idx]) || (!ascending && arr[j] > arr[swap_idx])\n        swap_idx = j\n      end\n    end\n\n    # Swap the found element with the first element of the unsorted part\n    arr[i], arr[swap_idx] = arr[swap_idx], arr[i]\n\n    # Print array state if simulation is enabled\n    puts arr.inspect if simulation\n\n    # Early exit check: if no swaps were made, check if the array is already sorted\n    if swap_idx == i\n      is_sorted = (0...(n - 1)).all? do |k|\n        ascending ? arr[k] <= arr[k + 1] : arr[k] >= arr[k + 1]\n      end\n      break if is_sorted\n    end\n  end\n\n  arr\nend\ndef test_optimized_selection_sort()\n  # Test case 1: Ascending sort\n  result = optimized_selection_sort([64, 25, 12, 22, 11], true, false)\n  raise \"Test case 1 failed\" unless result == [11, 12, 22, 25, 64]\n\n  # Test case 2: Descending sort\n  result = optimized_selection_sort([64, 25, 12, 22, 11], false, false)\n  raise \"Test case 2 failed\" unless result == [64, 25, 22, 12, 11]\n\n  # Test case 3: Already sorted ascending with simulation\n  result = optimized_selection_sort([1, 2, 3, 4, 5], true, true)\n  raise \"Test case 3 failed\" unless result == [1, 2, 3, 4, 5]\n\n  # Test case 4: Already sorted descending with simulation\n  result = optimized_selection_sort([5, 4, 3, 2, 1], false, true)\n  raise \"Test case 4 failed\" unless result == [5, 4, 3, 2, 1]\n\n  # Test case 5: Mixed array ascending sort\n  result = optimized_selection_sort([1, 3, 2, 5, 4], true, false)\n  raise \"Test case 5 failed\" unless result == [1, 2, 3, 4, 5]\n\n  puts \"All test cases passed!\"\nend\n\ntest_optimized_selection_sort()", "exec_outcome": "PASSED"}
{"code": "# Require necessary standard libraries\nrequire 'set'\n\n# Finds the shortest path from the top-left corner to the nearest target cell (marked as 2) in the grid.\n# The grid is a 2D array where:\n# - 0 represents an empty cell that can be traversed,\n# - 1 represents an obstacle that cannot be traversed,\n# - 2 represents the target cell.\n# Returns -1 if there is no path to any target cell.\ndef shortest_path_to_target(grid)\n  return -1 if grid.empty? || grid[0].empty?\n\n  m = grid.size\n  n = grid[0].size\n  directions = [[0, 1], [1, 0], [0, -1], [-1, 0]] # right, down, left, up\n  queue = [[0, 0, 0]] # [row, col, distance]\n  visited = Set.new\n  visited.add([0, 0])\n\n  while !queue.empty?\n    r, c, dist = queue.shift\n\n    return dist if grid[r][c] == 2\n\n    directions.each do |dr, dc|\n      nr = r + dr\n      nc = c + dc\n      if nr.between?(0, m - 1) && nc.between?(0, n - 1) && !visited.include?([nr, nc]) && grid[nr][nc] != 1\n        queue << [nr, nc, dist + 1]\n        visited.add([nr, nc])\n      end\n    end\n  end\n\n  -1\nend", "test_cases": "", "test_case_results": "Test Case 1:\nGrid: [[0, 0, 0], [1, 1, 0], [0, 0, 2]]\nShortest Path Distance: 4\n\nTest Case 2:\nGrid: [[0, 1, 0], [0, 1, 0], [0, 1, 2]]\nShortest Path Distance: -1\n\nTest Case 3:\nGrid: [[0, 0, 0], [1, 1, 1], [0, 0, 0]]\nShortest Path Distance: -1\n\nTest Case 4:\nGrid: [[2, 0, 0], [0, 0, 0], [0, 0, 0]]\nShortest Path Distance: 0\n\nTest Case 5:\nGrid: []\nShortest Path Distance: -1", "task_id": 14688, "assertions": "require 'set'\n\ndef test_shortest_path_to_target()\n  test_cases = [\n    {\n      grid: [\n        [0, 0, 0],\n        [1, 1, 0],\n        [0, 0, 2]\n      ],\n      expected: 4\n    },\n    {\n      grid: [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 2]\n      ],\n      expected: -1\n    },\n    {\n      grid: [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0]\n      ],\n      expected: -1\n    },\n    {\n      grid: [\n        [2, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n      ],\n      expected: 0\n    },\n    {\n      grid: [],\n      expected: -1\n    }\n  ]\n\n  test_cases.each do |tc|\n    result = shortest_path_to_target(tc[:grid])\n    raise \"Test failed for grid #{tc[:grid]}. Expected #{tc[:expected]}, got #{result}\" unless result == tc[:expected]\n  end\n  puts \"All tests passed!\"\nend\n\ntest_shortest_path_to_target()", "all_code": "# Require necessary standard libraries\nrequire 'set'\n\n# Finds the shortest path from the top-left corner to the nearest target cell (marked as 2) in the grid.\n# The grid is a 2D array where:\n# - 0 represents an empty cell that can be traversed,\n# - 1 represents an obstacle that cannot be traversed,\n# - 2 represents the target cell.\n# Returns -1 if there is no path to any target cell.\ndef shortest_path_to_target(grid)\n  return -1 if grid.empty? || grid[0].empty?\n\n  m = grid.size\n  n = grid[0].size\n  directions = [[0, 1], [1, 0], [0, -1], [-1, 0]] # right, down, left, up\n  queue = [[0, 0, 0]] # [row, col, distance]\n  visited = Set.new\n  visited.add([0, 0])\n\n  while !queue.empty?\n    r, c, dist = queue.shift\n\n    return dist if grid[r][c] == 2\n\n    directions.each do |dr, dc|\n      nr = r + dr\n      nc = c + dc\n      if nr.between?(0, m - 1) && nc.between?(0, n - 1) && !visited.include?([nr, nc]) && grid[nr][nc] != 1\n        queue << [nr, nc, dist + 1]\n        visited.add([nr, nc])\n      end\n    end\n  end\n\n  -1\nend\nrequire 'set'\n\ndef test_shortest_path_to_target()\n  test_cases = [\n    {\n      grid: [\n        [0, 0, 0],\n        [1, 1, 0],\n        [0, 0, 2]\n      ],\n      expected: 4\n    },\n    {\n      grid: [\n        [0, 1, 0],\n        [0, 1, 0],\n        [0, 1, 2]\n      ],\n      expected: -1\n    },\n    {\n      grid: [\n        [0, 0, 0],\n        [1, 1, 1],\n        [0, 0, 0]\n      ],\n      expected: -1\n    },\n    {\n      grid: [\n        [2, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n      ],\n      expected: 0\n    },\n    {\n      grid: [],\n      expected: -1\n    }\n  ]\n\n  test_cases.each do |tc|\n    result = shortest_path_to_target(tc[:grid])\n    raise \"Test failed for grid #{tc[:grid]}. Expected #{tc[:expected]}, got #{result}\" unless result == tc[:expected]\n  end\n  puts \"All tests passed!\"\nend\n\ntest_shortest_path_to_target()", "exec_outcome": "PASSED"}
{"code": "# ZigZagIterator is a class that iterates over multiple lists in a zigzag order.\n# It uses a queue to keep track of the current position in each list.\nclass ZigZagIterator\n  # Initializes the iterator with a list of lists.\n  # The queue is populated with the initial indices of non-empty lists.\n  def initialize(lists)\n    @queue = []\n    lists.each_with_index do |lst, i|\n      @queue << [i, 0] unless lst.empty?\n    end\n    @lists = lists\n  end\n\n  # Returns the next element in the iteration.\n  # Raises an exception if there are no more elements.\n  def next\n    raise \"No more elements\" unless has_next\n\n    list_index, element_index = @queue.shift\n    value = @lists[list_index][element_index]\n\n    if element_index + 1 < @lists[list_index].size\n      @queue << [list_index, element_index + 1]\n    end\n\n    value\n  end\n\n  # Checks if there are more elements to iterate over.\n  def has_next\n    !@queue.empty?\n  end\nend", "test_cases": "", "test_case_results": "Input: [[1, 3, 5], [2, 4, 6]]\nZigzag order: [1, 2, 3, 4, 5, 6]\nInput: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nZigzag order: [1, 4, 7, 2, 5, 8, 3, 6, 9]\nInput: [[], [1, 2], [3, 4, 5]]\nZigzag order: [1, 3, 2, 4, 5]", "task_id": 22766, "assertions": "def test_zigzag_iterator\n  # Test case 1\n  iterator1 = ZigZagIterator.new([[1, 3, 5], [2, 4, 6]])\n  result1 = []\n  while iterator1.has_next\n    result1 << iterator1.next\n  end\n  raise \"Test case 1 failed\" unless result1 == [1, 2, 3, 4, 5, 6]\n\n  # Test case 2\n  iterator2 = ZigZagIterator.new([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n  result2 = []\n  while iterator2.has_next\n    result2 << iterator2.next\n  end\n  raise \"Test case 2 failed\" unless result2 == [1, 4, 7, 2, 5, 8, 3, 6, 9]\n\n  # Test case 3\n  iterator3 = ZigZagIterator.new([[], [1, 2], [3, 4, 5]])\n  result3 = []\n  while iterator3.has_next\n    result3 << iterator3.next\n  end\n  raise \"Test case 3 failed\" unless result3 == [1, 3, 2, 4, 5]\n\n  puts \"All test cases passed!\"\nend\n\ntest_zigzag_iterator", "all_code": "# ZigZagIterator is a class that iterates over multiple lists in a zigzag order.\n# It uses a queue to keep track of the current position in each list.\nclass ZigZagIterator\n  # Initializes the iterator with a list of lists.\n  # The queue is populated with the initial indices of non-empty lists.\n  def initialize(lists)\n    @queue = []\n    lists.each_with_index do |lst, i|\n      @queue << [i, 0] unless lst.empty?\n    end\n    @lists = lists\n  end\n\n  # Returns the next element in the iteration.\n  # Raises an exception if there are no more elements.\n  def next\n    raise \"No more elements\" unless has_next\n\n    list_index, element_index = @queue.shift\n    value = @lists[list_index][element_index]\n\n    if element_index + 1 < @lists[list_index].size\n      @queue << [list_index, element_index + 1]\n    end\n\n    value\n  end\n\n  # Checks if there are more elements to iterate over.\n  def has_next\n    !@queue.empty?\n  end\nend\ndef test_zigzag_iterator\n  # Test case 1\n  iterator1 = ZigZagIterator.new([[1, 3, 5], [2, 4, 6]])\n  result1 = []\n  while iterator1.has_next\n    result1 << iterator1.next\n  end\n  raise \"Test case 1 failed\" unless result1 == [1, 2, 3, 4, 5, 6]\n\n  # Test case 2\n  iterator2 = ZigZagIterator.new([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n  result2 = []\n  while iterator2.has_next\n    result2 << iterator2.next\n  end\n  raise \"Test case 2 failed\" unless result2 == [1, 4, 7, 2, 5, 8, 3, 6, 9]\n\n  # Test case 3\n  iterator3 = ZigZagIterator.new([[], [1, 2], [3, 4, 5]])\n  result3 = []\n  while iterator3.has_next\n    result3 << iterator3.next\n  end\n  raise \"Test case 3 failed\" unless result3 == [1, 3, 2, 4, 5]\n\n  puts \"All test cases passed!\"\nend\n\ntest_zigzag_iterator", "exec_outcome": "PASSED"}
{"code": "# simulate_collisions simulates the collisions of debris pieces until only one piece remains.\n# It combines the first two pieces in each iteration, calculating the new mass and velocity based on conservation of momentum.\n# The process repeats until only one piece of debris is left.\n#\n# @param n [Integer] The initial number of pieces of debris\n# @param debris [Array<Array<Integer, Integer>>] An array of [mass, velocity] pairs representing each debris\n# @return [Array<Integer, Array<Array<Integer, Integer>>>] The final count of debris (always 1) and its state [mass, velocity]\ndef simulate_collisions(n, debris)\n  while debris.size > 1\n    # Take the first two pieces and combine them\n    m1, v1 = debris.shift\n    m2, v2 = debris.shift\n    new_mass = m1 + m2\n    new_velocity = (m1 * v1 + m2 * v2) / new_mass\n    debris.unshift([new_mass, new_velocity])\n  end\n\n  # Resulting single piece of debris\n  final_mass, final_velocity = debris.first\n  [1, [[final_mass, final_velocity]]]\nend", "test_cases": "", "test_case_results": "Input:\nn: 4\ndebris: [[10, 1], [15, 2], [20, 3], [25, 4]]\nFinal count: 1\nFinal debris: [[70, 2]]\n\nInput:\nn: 3\ndebris: [[5, 10], [10, 5], [15, 0]]\nFinal count: 1\nFinal debris: [[30, 3]]\n\nInput:\nn: 2\ndebris: [[12, 6], [6, 12]]\nFinal count: 1\nFinal debris: [[18, 8]]", "task_id": 25406, "assertions": "def test_simulate_collisions\n  # Test case 1\n  final_count, final_debris = simulate_collisions(4, [[10, 1], [15, 2], [20, 3], [25, 4]])\n  raise \"Test case 1 failed\" unless final_count == 1 && final_debris == [[70, 2]]\n\n  # Test case 2\n  final_count, final_debris = simulate_collisions(3, [[5, 10], [10, 5], [15, 0]])\n  raise \"Test case 2 failed\" unless final_count == 1 && final_debris == [[30, 3]]\n\n  # Test case 3\n  final_count, final_debris = simulate_collisions(2, [[12, 6], [6, 12]])\n  raise \"Test case 3 failed\" unless final_count == 1 && final_debris == [[18, 8]]\n\n  puts \"All test cases passed!\"\nend\n\ntest_simulate_collisions", "all_code": "# simulate_collisions simulates the collisions of debris pieces until only one piece remains.\n# It combines the first two pieces in each iteration, calculating the new mass and velocity based on conservation of momentum.\n# The process repeats until only one piece of debris is left.\n#\n# @param n [Integer] The initial number of pieces of debris\n# @param debris [Array<Array<Integer, Integer>>] An array of [mass, velocity] pairs representing each debris\n# @return [Array<Integer, Array<Array<Integer, Integer>>>] The final count of debris (always 1) and its state [mass, velocity]\ndef simulate_collisions(n, debris)\n  while debris.size > 1\n    # Take the first two pieces and combine them\n    m1, v1 = debris.shift\n    m2, v2 = debris.shift\n    new_mass = m1 + m2\n    new_velocity = (m1 * v1 + m2 * v2) / new_mass\n    debris.unshift([new_mass, new_velocity])\n  end\n\n  # Resulting single piece of debris\n  final_mass, final_velocity = debris.first\n  [1, [[final_mass, final_velocity]]]\nend\ndef test_simulate_collisions\n  # Test case 1\n  final_count, final_debris = simulate_collisions(4, [[10, 1], [15, 2], [20, 3], [25, 4]])\n  raise \"Test case 1 failed\" unless final_count == 1 && final_debris == [[70, 2]]\n\n  # Test case 2\n  final_count, final_debris = simulate_collisions(3, [[5, 10], [10, 5], [15, 0]])\n  raise \"Test case 2 failed\" unless final_count == 1 && final_debris == [[30, 3]]\n\n  # Test case 3\n  final_count, final_debris = simulate_collisions(2, [[12, 6], [6, 12]])\n  raise \"Test case 3 failed\" unless final_count == 1 && final_debris == [[18, 8]]\n\n  puts \"All test cases passed!\"\nend\n\ntest_simulate_collisions", "exec_outcome": "PASSED"}
{"code": "# softmax computes the softmax of a vector.\n# It adjusts the input vector by subtracting the maximum value for numerical stability,\n# then exponentiates each element and normalizes by the sum of these exponentials.\n# Parameters:\n#   z (Array): Input vector of numbers.\n# Returns:\n#   Array: Softmax-applied vector.\ndef softmax(z)\n  max_z = z.max\n  exp_z = z.map { |x| Math.exp(x - max_z) }  # for numerical stability\n  sum_exp_z = exp_z.sum\n  exp_z.map { |x| x / sum_exp_z }\nend", "test_cases": "", "test_case_results": "Input: [1.0, 2.0, 3.0]\nSoftmax: [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\nInput: [-1.0, 0.0, 1.0]\nSoftmax: [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\nInput: [0.5, 1.0, 2.5]\nSoftmax: [0.09962364806231833, 0.16425162762508783, 0.7361247243125939]", "task_id": 6652, "assertions": "def test_softmax()\n  epsilon = 1e-10  # small value to account for floating point precision\n\n  result1 = softmax([1.0, 2.0, 3.0])\n  expected1 = [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\n  result1.each_with_index do |val, i|\n    raise \"Test case 1 failed\" unless (val - expected1[i]).abs < epsilon\n  end\n\n  result2 = softmax([-1.0, 0.0, 1.0])\n  expected2 = [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\n  result2.each_with_index do |val, i|\n    raise \"Test case 2 failed\" unless (val - expected2[i]).abs < epsilon\n  end\n\n  result3 = softmax([0.5, 1.0, 2.5])\n  expected3 = [0.09962364806231833, 0.16425162762508783, 0.7361247243125939]\n  result3.each_with_index do |val, i|\n    raise \"Test case 3 failed\" unless (val - expected3[i]).abs < epsilon\n  end\nend\n\ntest_softmax()", "all_code": "# softmax computes the softmax of a vector.\n# It adjusts the input vector by subtracting the maximum value for numerical stability,\n# then exponentiates each element and normalizes by the sum of these exponentials.\n# Parameters:\n#   z (Array): Input vector of numbers.\n# Returns:\n#   Array: Softmax-applied vector.\ndef softmax(z)\n  max_z = z.max\n  exp_z = z.map { |x| Math.exp(x - max_z) }  # for numerical stability\n  sum_exp_z = exp_z.sum\n  exp_z.map { |x| x / sum_exp_z }\nend\ndef test_softmax()\n  epsilon = 1e-10  # small value to account for floating point precision\n\n  result1 = softmax([1.0, 2.0, 3.0])\n  expected1 = [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\n  result1.each_with_index do |val, i|\n    raise \"Test case 1 failed\" unless (val - expected1[i]).abs < epsilon\n  end\n\n  result2 = softmax([-1.0, 0.0, 1.0])\n  expected2 = [0.09003057317038046, 0.24472847105479764, 0.6652409557748218]\n  result2.each_with_index do |val, i|\n    raise \"Test case 2 failed\" unless (val - expected2[i]).abs < epsilon\n  end\n\n  result3 = softmax([0.5, 1.0, 2.5])\n  expected3 = [0.09962364806231833, 0.16425162762508783, 0.7361247243125939]\n  result3.each_with_index do |val, i|\n    raise \"Test case 3 failed\" unless (val - expected3[i]).abs < epsilon\n  end\nend\n\ntest_softmax()", "exec_outcome": "PASSED"}
{"code": "# max_distinct_characters_in_substring calculates the maximum number of distinct characters\n# in any substring of length `k` from the given string `s`.\n# It checks all possible substrings of length `k` and counts the distinct characters in each.\n# If `k` is less than or equal to 0 or the string length is less than `k`, it returns 0.\n#\n# @param s [String] the input string to analyze\n# @param k [Integer] the length of the substring to consider\n# @return [Integer] the maximum number of distinct characters found in any substring of length `k`\ndef max_distinct_characters_in_substring(s, k)\n  return 0 if k <= 0 || s.length < k\n\n  max_distinct = 0\n  (0..s.length - k).each do |i|\n    substring = s[i, k]\n    distinct_count = substring.chars.uniq.size\n    max_distinct = [max_distinct, distinct_count].max\n  end\n\n  max_distinct\nend", "test_cases": "", "test_case_results": "Input string: abcba, k: 2\nMaximum distinct characters: 2\nInput string: abcba, k: 3\nMaximum distinct characters: 3\nInput string: aaaaa, k: 1\nMaximum distinct characters: 1\nInput string: aabacbebebe, k: 3\nMaximum distinct characters: 3\nInput string: abc, k: 0\nMaximum distinct characters: 0\nInput string: abc, k: 5\nMaximum distinct characters: 0", "task_id": 13818, "assertions": "def test_max_distinct_characters_in_substring()\n  raise \"Test case 1 failed\" unless max_distinct_characters_in_substring(\"abcba\", 2) == 2\n  raise \"Test case 2 failed\" unless max_distinct_characters_in_substring(\"abcba\", 3) == 3\n  raise \"Test case 3 failed\" unless max_distinct_characters_in_substring(\"aaaaa\", 1) == 1\n  raise \"Test case 4 failed\" unless max_distinct_characters_in_substring(\"aabacbebebe\", 3) == 3\n  raise \"Test case 5 failed\" unless max_distinct_characters_in_substring(\"abc\", 0) == 0\n  raise \"Test case 6 failed\" unless max_distinct_characters_in_substring(\"abc\", 5) == 0\n  puts \"All tests passed successfully!\"\nend\n\ntest_max_distinct_characters_in_substring()", "all_code": "# max_distinct_characters_in_substring calculates the maximum number of distinct characters\n# in any substring of length `k` from the given string `s`.\n# It checks all possible substrings of length `k` and counts the distinct characters in each.\n# If `k` is less than or equal to 0 or the string length is less than `k`, it returns 0.\n#\n# @param s [String] the input string to analyze\n# @param k [Integer] the length of the substring to consider\n# @return [Integer] the maximum number of distinct characters found in any substring of length `k`\ndef max_distinct_characters_in_substring(s, k)\n  return 0 if k <= 0 || s.length < k\n\n  max_distinct = 0\n  (0..s.length - k).each do |i|\n    substring = s[i, k]\n    distinct_count = substring.chars.uniq.size\n    max_distinct = [max_distinct, distinct_count].max\n  end\n\n  max_distinct\nend\ndef test_max_distinct_characters_in_substring()\n  raise \"Test case 1 failed\" unless max_distinct_characters_in_substring(\"abcba\", 2) == 2\n  raise \"Test case 2 failed\" unless max_distinct_characters_in_substring(\"abcba\", 3) == 3\n  raise \"Test case 3 failed\" unless max_distinct_characters_in_substring(\"aaaaa\", 1) == 1\n  raise \"Test case 4 failed\" unless max_distinct_characters_in_substring(\"aabacbebebe\", 3) == 3\n  raise \"Test case 5 failed\" unless max_distinct_characters_in_substring(\"abc\", 0) == 0\n  raise \"Test case 6 failed\" unless max_distinct_characters_in_substring(\"abc\", 5) == 0\n  puts \"All tests passed successfully!\"\nend\n\ntest_max_distinct_characters_in_substring()", "exec_outcome": "PASSED"}
{"code": "# max_fulfilled_orders calculates the maximum number of orders that can be fulfilled given the inventory and orders.\n# It uses a hash to count the inventory per category and iterates through each order to check availability.\n# If an order can be fulfilled, it decrements the inventory accordingly.\n#\n# Parameters:\n#   - inventory: A hash where keys are item categories and values are available quantities.\n#   - orders: An array of arrays, where each sub-array contains a category and the ordered quantity.\n#\n# Returns:\n#   - The total number of fulfilled orders.\ndef max_fulfilled_orders(inventory, orders)\n  fulfilled_orders = 0\n\n  orders.each do |category, quantity|\n    available = inventory.fetch(category, 0)\n    if available > 0\n      fulfilled_orders += 1\n      if available >= quantity\n        inventory[category] -= quantity\n      else\n        inventory[category] = 0\n      end\n    end\n  end\n\n  fulfilled_orders\nend", "test_cases": "", "test_case_results": "Inventory: {\"A\"=>5, \"B\"=>3, \"C\"=>2}\nOrders: [[\"A\", 2], [\"B\", 4], [\"C\", 1], [\"A\", 1]]\nFulfilled Orders: 4\n---\nInventory: {\"X\"=>1, \"Y\"=>1}\nOrders: [[\"X\", 1], [\"Y\", 1], [\"X\", 1]]\nFulfilled Orders: 2\n---\nInventory: {\"P\"=>0, \"Q\"=>0}\nOrders: [[\"P\", 1], [\"Q\", 1]]\nFulfilled Orders: 0\n---", "task_id": 25129, "assertions": "def test_max_fulfilled_orders()\n  # Test case 1\n  inventory1 = { 'A' => 5, 'B' => 3, 'C' => 2 }\n  orders1 = [['A', 2], ['B', 4], ['C', 1], ['A', 1]]\n  raise \"Test case 1 failed\" unless max_fulfilled_orders(inventory1.dup, orders1) == 4\n\n  # Test case 2\n  inventory2 = { 'X' => 1, 'Y' => 1 }\n  orders2 = [['X', 1], ['Y', 1], ['X', 1]]\n  raise \"Test case 2 failed\" unless max_fulfilled_orders(inventory2.dup, orders2) == 2\n\n  # Test case 3\n  inventory3 = { 'P' => 0, 'Q' => 0 }\n  orders3 = [['P', 1], ['Q', 1]]\n  raise \"Test case 3 failed\" unless max_fulfilled_orders(inventory3.dup, orders3) == 0\nend\n\ntest_max_fulfilled_orders()", "all_code": "# max_fulfilled_orders calculates the maximum number of orders that can be fulfilled given the inventory and orders.\n# It uses a hash to count the inventory per category and iterates through each order to check availability.\n# If an order can be fulfilled, it decrements the inventory accordingly.\n#\n# Parameters:\n#   - inventory: A hash where keys are item categories and values are available quantities.\n#   - orders: An array of arrays, where each sub-array contains a category and the ordered quantity.\n#\n# Returns:\n#   - The total number of fulfilled orders.\ndef max_fulfilled_orders(inventory, orders)\n  fulfilled_orders = 0\n\n  orders.each do |category, quantity|\n    available = inventory.fetch(category, 0)\n    if available > 0\n      fulfilled_orders += 1\n      if available >= quantity\n        inventory[category] -= quantity\n      else\n        inventory[category] = 0\n      end\n    end\n  end\n\n  fulfilled_orders\nend\ndef test_max_fulfilled_orders()\n  # Test case 1\n  inventory1 = { 'A' => 5, 'B' => 3, 'C' => 2 }\n  orders1 = [['A', 2], ['B', 4], ['C', 1], ['A', 1]]\n  raise \"Test case 1 failed\" unless max_fulfilled_orders(inventory1.dup, orders1) == 4\n\n  # Test case 2\n  inventory2 = { 'X' => 1, 'Y' => 1 }\n  orders2 = [['X', 1], ['Y', 1], ['X', 1]]\n  raise \"Test case 2 failed\" unless max_fulfilled_orders(inventory2.dup, orders2) == 2\n\n  # Test case 3\n  inventory3 = { 'P' => 0, 'Q' => 0 }\n  orders3 = [['P', 1], ['Q', 1]]\n  raise \"Test case 3 failed\" unless max_fulfilled_orders(inventory3.dup, orders3) == 0\nend\n\ntest_max_fulfilled_orders()", "exec_outcome": "PASSED"}
{"code": "# This method checks if the given value is a positive integer.\n# A positive integer is defined as an instance of Integer and greater than 0.\n#\n# @param value [Object] The input value to validate.\n# @return [Boolean] True if the value is a positive integer, False otherwise.\ndef is_positive_integer(value)\n  value.is_a?(Integer) && value > 0\nend", "test_cases": "", "test_case_results": "Input: 5, Is Positive Integer: true\nInput: -3, Is Positive Integer: false\nInput: 0, Is Positive Integer: false\nInput: 3.14, Is Positive Integer: false\nInput: \"hello\", Is Positive Integer: false\nInput: nil, Is Positive Integer: false\nInput: true, Is Positive Integer: false", "task_id": 12792, "assertions": "def test_is_positive_integer()\n  raise \"Test failed for 5\" unless is_positive_integer(5) == true\n  raise \"Test failed for -3\" unless is_positive_integer(-3) == false\n  raise \"Test failed for 0\" unless is_positive_integer(0) == false\n  raise \"Test failed for 3.14\" unless is_positive_integer(3.14) == false\n  raise \"Test failed for 'hello'\" unless is_positive_integer(\"hello\") == false\n  raise \"Test failed for nil\" unless is_positive_integer(nil) == false\n  raise \"Test failed for true\" unless is_positive_integer(true) == false\n  puts \"All tests passed!\"\nend\n\ntest_is_positive_integer()", "all_code": "# This method checks if the given value is a positive integer.\n# A positive integer is defined as an instance of Integer and greater than 0.\n#\n# @param value [Object] The input value to validate.\n# @return [Boolean] True if the value is a positive integer, False otherwise.\ndef is_positive_integer(value)\n  value.is_a?(Integer) && value > 0\nend\ndef test_is_positive_integer()\n  raise \"Test failed for 5\" unless is_positive_integer(5) == true\n  raise \"Test failed for -3\" unless is_positive_integer(-3) == false\n  raise \"Test failed for 0\" unless is_positive_integer(0) == false\n  raise \"Test failed for 3.14\" unless is_positive_integer(3.14) == false\n  raise \"Test failed for 'hello'\" unless is_positive_integer(\"hello\") == false\n  raise \"Test failed for nil\" unless is_positive_integer(nil) == false\n  raise \"Test failed for true\" unless is_positive_integer(true) == false\n  puts \"All tests passed!\"\nend\n\ntest_is_positive_integer()", "exec_outcome": "PASSED"}
