{"code": "# countHarmoniousPairs returns the number of harmonious pairs where nums[i] + nums[j] == k and i < j.\n# It uses a hash map to store seen numbers and their counts for efficient O(n) time complexity.\ncountHarmoniousPairs = (nums, k) ->\n    count = 0\n    seen = {}\n    \n    for num, index in nums\n        complement = k - num\n        if seen[complement]?\n            count += seen[complement]\n        \n        if seen[num]?\n            seen[num] += 1\n        else\n            seen[num] = 1\n\n    count", "test_cases": "", "test_case_results": "Input: { nums: [ 1, 2, 3, 4 ], k: 5 }\nNumber of harmonious pairs: 2\n-----\nInput: { nums: [ 1, 1, 1, 1 ], k: 2 }\nNumber of harmonious pairs: 6\n-----\nInput: { nums: [ 3, 1, 4, 1, 5 ], k: 6 }\nNumber of harmonious pairs: 2\n-----\nInput: { nums: [ 1, 3, 2, 2 ], k: 4 }\nNumber of harmonious pairs: 2\n-----\nInput: { nums: [], k: 10 }\nNumber of harmonious pairs: 0\n-----", "task_id": 6675, "assertions": "assert = require 'assert'\n\ntestCountHarmoniousPairs = ->\n    assert.strictEqual countHarmoniousPairs([1, 2, 3, 4], 5), 2\n    assert.strictEqual countHarmoniousPairs([1, 1, 1, 1], 2), 6\n    assert.strictEqual countHarmoniousPairs([3, 1, 4, 1, 5], 6), 2\n    assert.strictEqual countHarmoniousPairs([1, 3, 2, 2], 4), 2\n    assert.strictEqual countHarmoniousPairs([], 10), 0\n    console.log \"All tests passed!\"\n\ntestCountHarmoniousPairs()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountHarmoniousPairs = ->\n    assert.strictEqual countHarmoniousPairs([1, 2, 3, 4], 5), 2\n    assert.strictEqual countHarmoniousPairs([1, 1, 1, 1], 2), 6\n    assert.strictEqual countHarmoniousPairs([3, 1, 4, 1, 5], 6), 2\n    assert.strictEqual countHarmoniousPairs([1, 3, 2, 2], 4), 2\n    assert.strictEqual countHarmoniousPairs([], 10), 0\n    console.log \"All tests passed!\"\n\ntestCountHarmoniousPairs()", "output": "countHarmoniousPairs"}, "all_code": "# countHarmoniousPairs returns the number of harmonious pairs where nums[i] + nums[j] == k and i < j.\n# It uses a hash map to store seen numbers and their counts for efficient O(n) time complexity.\ncountHarmoniousPairs = (nums, k) ->\n    count = 0\n    seen = {}\n    \n    for num, index in nums\n        complement = k - num\n        if seen[complement]?\n            count += seen[complement]\n        \n        if seen[num]?\n            seen[num] += 1\n        else\n            seen[num] = 1\n\n    count\nassert = require 'assert'\n\ntestCountHarmoniousPairs = ->\n    assert.strictEqual countHarmoniousPairs([1, 2, 3, 4], 5), 2\n    assert.strictEqual countHarmoniousPairs([1, 1, 1, 1], 2), 6\n    assert.strictEqual countHarmoniousPairs([3, 1, 4, 1, 5], 6), 2\n    assert.strictEqual countHarmoniousPairs([1, 3, 2, 2], 4), 2\n    assert.strictEqual countHarmoniousPairs([], 10), 0\n    console.log \"All tests passed!\"\n\ntestCountHarmoniousPairs()", "exec_outcome": "PASSED"}
{"code": "# findMinPlatforms calculates the minimum number of platforms required at a station\n# so that no train waits, based on sorted arrival and departure times.\n# Uses a two-pointer approach to track overlapping train schedules.\nfindMinPlatforms = (arrival, departure) ->\n  # Sort the arrival and departure arrays\n  arrival.sort (a, b) -> a - b\n  departure.sort (a, b) -> a - b\n  \n  n = arrival.length\n  platformNeeded = 1\n  maxPlatforms = 1\n  \n  i = 1\n  j = 0\n  \n  # Use two pointers to traverse through arrival and departure arrays\n  while i < n and j < n\n    if arrival[i] <= departure[j]\n      platformNeeded += 1\n      i += 1\n      maxPlatforms = Math.max(maxPlatforms, platformNeeded)\n    else\n      platformNeeded -= 1\n      j += 1\n  \n  maxPlatforms", "test_cases": "", "test_case_results": "Test Case: Mixed overlapping schedules\nArrival Times: [ 900, 940, 950, 1100, 1500, 1800 ]\nDeparture Times: [ 910, 1200, 1120, 1130, 1900, 2000 ]\nMinimum Platforms Required: 3\n----------------------------------\nTest Case: No overlapping schedules\nArrival Times: [ 900, 1100, 1300 ]\nDeparture Times: [ 1000, 1200, 1400 ]\nMinimum Platforms Required: 1\n----------------------------------\nTest Case: All trains arrive in quick succession\nArrival Times: [ 900, 905, 910 ]\nDeparture Times: [ 1000, 1005, 1010 ]\nMinimum Platforms Required: 3\n----------------------------------\nTest Case: Single train\nArrival Times: [ 900 ]\nDeparture Times: [ 1000 ]\nMinimum Platforms Required: 1\n----------------------------------", "task_id": 2180, "assertions": "assert = require 'assert'\n\ntestFindMinPlatforms = ->\n  # Test case 1: Mixed overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 940, 950, 1100, 1500, 1800],\n    [910, 1200, 1120, 1130, 1900, 2000]\n  ), 3\n  \n  # Test case 2: No overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 1100, 1300],\n    [1000, 1200, 1400]\n  ), 1\n  \n  # Test case 3: All trains arrive in quick succession\n  assert.strictEqual findMinPlatforms(\n    [900, 905, 910],\n    [1000, 1005, 1010]\n  ), 3\n  \n  # Test case 4: Single train\n  assert.strictEqual findMinPlatforms(\n    [900],\n    [1000]\n  ), 1\n  \n  console.log \"All tests passed!\"\n\ntestFindMinPlatforms()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindMinPlatforms = ->\n  # Test case 1: Mixed overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 940, 950, 1100, 1500, 1800],\n    [910, 1200, 1120, 1130, 1900, 2000]\n  ), 3\n  \n  # Test case 2: No overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 1100, 1300],\n    [1000, 1200, 1400]\n  ), 1\n  \n  # Test case 3: All trains arrive in quick succession\n  assert.strictEqual findMinPlatforms(\n    [900, 905, 910],\n    [1000, 1005, 1010]\n  ), 3\n  \n  # Test case 4: Single train\n  assert.strictEqual findMinPlatforms(\n    [900],\n    [1000]\n  ), 1\n  \n  console.log \"All tests passed!\"\n\ntestFindMinPlatforms()", "output": "findMinPlatforms"}, "all_code": "# findMinPlatforms calculates the minimum number of platforms required at a station\n# so that no train waits, based on sorted arrival and departure times.\n# Uses a two-pointer approach to track overlapping train schedules.\nfindMinPlatforms = (arrival, departure) ->\n  # Sort the arrival and departure arrays\n  arrival.sort (a, b) -> a - b\n  departure.sort (a, b) -> a - b\n  \n  n = arrival.length\n  platformNeeded = 1\n  maxPlatforms = 1\n  \n  i = 1\n  j = 0\n  \n  # Use two pointers to traverse through arrival and departure arrays\n  while i < n and j < n\n    if arrival[i] <= departure[j]\n      platformNeeded += 1\n      i += 1\n      maxPlatforms = Math.max(maxPlatforms, platformNeeded)\n    else\n      platformNeeded -= 1\n      j += 1\n  \n  maxPlatforms\nassert = require 'assert'\n\ntestFindMinPlatforms = ->\n  # Test case 1: Mixed overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 940, 950, 1100, 1500, 1800],\n    [910, 1200, 1120, 1130, 1900, 2000]\n  ), 3\n  \n  # Test case 2: No overlapping schedules\n  assert.strictEqual findMinPlatforms(\n    [900, 1100, 1300],\n    [1000, 1200, 1400]\n  ), 1\n  \n  # Test case 3: All trains arrive in quick succession\n  assert.strictEqual findMinPlatforms(\n    [900, 905, 910],\n    [1000, 1005, 1010]\n  ), 3\n  \n  # Test case 4: Single train\n  assert.strictEqual findMinPlatforms(\n    [900],\n    [1000]\n  ), 1\n  \n  console.log \"All tests passed!\"\n\ntestFindMinPlatforms()", "exec_outcome": "PASSED"}
{"code": "class FirstNonRepeatingChar\n  constructor: (s) ->\n    @s = s\n    @queue = []\n    @count = {}\n    # Initialize counts and queue with initial string\n    for c in s\n      @addCharacter(c)\n\n  # Returns the first non-repeating character in the current stream, or '#' if none exists\n  queryFirstNonRepeating: ->\n    while @queue.length > 0 and @count[@queue[0]] > 1\n      @queue.shift()  # Remove characters that are no longer non-repeating\n    if @queue.length > 0\n      return @queue[0]\n    else\n      return '#'\n\n  # Adds a new character to the stream and updates counts/queue accordingly\n  addCharacter: (c) ->\n    @s += c\n    @count[c] ?= 0  # Initialize to 0 if not exists\n    @count[c] += 1\n    if @count[c] is 1\n      @queue.push(c)  # Only add to queue if it's the first occurrence", "test_cases": "", "test_case_results": "Test Case: Empty string\n  Operation 1: Query -> Expected: '#', Got: '#'\n\nTest Case: Single character\n  Operation 1: Add 'a'\n  Operation 2: Query -> Expected: 'a', Got: 'a'\n\nTest Case: Multiple characters with duplicates\n  Operation 1: Add 'a'\n  Operation 2: Add 'b'\n  Operation 3: Query -> Expected: 'a', Got: 'a'\n  Operation 4: Add 'a'\n  Operation 5: Query -> Expected: 'b', Got: 'b'\n  Operation 6: Add 'b'\n  Operation 7: Query -> Expected: '#', Got: '#'\n\nTest Case: Interleaved adds and queries\n  Operation 1: Add 'a'\n  Operation 2: Query -> Expected: 'a', Got: 'a'\n  Operation 3: Add 'b'\n  Operation 4: Query -> Expected: 'a', Got: 'a'\n  Operation 5: Add 'a'\n  Operation 6: Query -> Expected: 'b', Got: 'b'\n  Operation 7: Add 'c'\n  Operation 8: Query -> Expected: 'b', Got: 'b'\n  Operation 9: Add 'b'\n  Operation 10: Query -> Expected: 'c', Got: 'c'", "task_id": 9302, "assertions": "assert = require 'assert'\n\ntestFirstNonRepeatingChar = ->\n  # Test empty string\n  fnrc1 = new FirstNonRepeatingChar('')\n  assert.strictEqual fnrc1.queryFirstNonRepeating(), '#'\n\n  # Test single character\n  fnrc2 = new FirstNonRepeatingChar('')\n  fnrc2.addCharacter('a')\n  assert.strictEqual fnrc2.queryFirstNonRepeating(), 'a'\n\n  # Test multiple characters with duplicates\n  fnrc3 = new FirstNonRepeatingChar('')\n  fnrc3.addCharacter('a')\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'a'\n  fnrc3.addCharacter('a')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'b'\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), '#'\n\n  # Test interleaved adds and queries\n  fnrc4 = new FirstNonRepeatingChar('')\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('c')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'c'\n\n  console.log \"All tests passed successfully!\"\n\ntestFirstNonRepeatingChar()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFirstNonRepeatingChar = ->\n  # Test empty string\n  fnrc1 = new FirstNonRepeatingChar('')\n  assert.strictEqual fnrc1.queryFirstNonRepeating(), '#'\n\n  # Test single character\n  fnrc2 = new FirstNonRepeatingChar('')\n  fnrc2.addCharacter('a')\n  assert.strictEqual fnrc2.queryFirstNonRepeating(), 'a'\n\n  # Test multiple characters with duplicates\n  fnrc3 = new FirstNonRepeatingChar('')\n  fnrc3.addCharacter('a')\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'a'\n  fnrc3.addCharacter('a')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'b'\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), '#'\n\n  # Test interleaved adds and queries\n  fnrc4 = new FirstNonRepeatingChar('')\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('c')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'c'\n\n  console.log \"All tests passed successfully!\"\n\ntestFirstNonRepeatingChar()", "output": "queryFirstNonRepeating"}, "all_code": "class FirstNonRepeatingChar\n  constructor: (s) ->\n    @s = s\n    @queue = []\n    @count = {}\n    # Initialize counts and queue with initial string\n    for c in s\n      @addCharacter(c)\n\n  # Returns the first non-repeating character in the current stream, or '#' if none exists\n  queryFirstNonRepeating: ->\n    while @queue.length > 0 and @count[@queue[0]] > 1\n      @queue.shift()  # Remove characters that are no longer non-repeating\n    if @queue.length > 0\n      return @queue[0]\n    else\n      return '#'\n\n  # Adds a new character to the stream and updates counts/queue accordingly\n  addCharacter: (c) ->\n    @s += c\n    @count[c] ?= 0  # Initialize to 0 if not exists\n    @count[c] += 1\n    if @count[c] is 1\n      @queue.push(c)  # Only add to queue if it's the first occurrence\nassert = require 'assert'\n\ntestFirstNonRepeatingChar = ->\n  # Test empty string\n  fnrc1 = new FirstNonRepeatingChar('')\n  assert.strictEqual fnrc1.queryFirstNonRepeating(), '#'\n\n  # Test single character\n  fnrc2 = new FirstNonRepeatingChar('')\n  fnrc2.addCharacter('a')\n  assert.strictEqual fnrc2.queryFirstNonRepeating(), 'a'\n\n  # Test multiple characters with duplicates\n  fnrc3 = new FirstNonRepeatingChar('')\n  fnrc3.addCharacter('a')\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'a'\n  fnrc3.addCharacter('a')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), 'b'\n  fnrc3.addCharacter('b')\n  assert.strictEqual fnrc3.queryFirstNonRepeating(), '#'\n\n  # Test interleaved adds and queries\n  fnrc4 = new FirstNonRepeatingChar('')\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'a'\n  fnrc4.addCharacter('a')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('c')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'b'\n  fnrc4.addCharacter('b')\n  assert.strictEqual fnrc4.queryFirstNonRepeating(), 'c'\n\n  console.log \"All tests passed successfully!\"\n\ntestFirstNonRepeatingChar()", "exec_outcome": "PASSED"}
{"code": "# maxResourcesCollected calculates the maximum number of resources that can be collected\n# within the given total time, considering the time cost to switch between resource types.\n# \n# Parameters:\n#   n - Number of resource types\n#   r - Array of collection rates for each resource type\n#   t - Array of time costs to switch to each resource type\n#   T - Total available time\n#\n# Returns:\n#   The maximum number of resources that can be collected for any single resource type\nmaxResourcesCollected = (n, r, t, T) ->\n  maxResources = 0\n  \n  for i in [0...n]\n    if T >= t[i]\n      collectionTime = T - t[i]\n      resourcesCollected = collectionTime * r[i]\n      maxResources = Math.max(maxResources, resourcesCollected)\n  \n  maxResources", "test_cases": "", "test_case_results": "Test Case 1:\n  Input:\n    n: 3\n    r: [ 5, 3, 2 ]\n    t: [ 2, 1, 3 ]\n    T: 10\n  Result: 40\n\nTest Case 2:\n  Input:\n    n: 2\n    r: [ 4, 6 ]\n    t: [ 10, 15 ]\n    T: 5\n  Result: 0\n\nTest Case 3:\n  Input:\n    n: 1\n    r: [ 7 ]\n    t: [ 0 ]\n    T: 20\n  Result: 140\n\nTest Case 4:\n  Input:\n    n: 4\n    r: [ 3, 3, 3, 3 ]\n    t: [ 5, 2, 1, 4 ]\n    T: 8\n  Result: 21", "task_id": 24343, "assertions": "assert = require 'assert'\n\ntestMaxResourcesCollected = ->\n  # Test case 1: Basic scenario\n  assert.strictEqual maxResourcesCollected(3, [5, 3, 2], [2, 1, 3], 10), 40\n  \n  # Test case 2: Not enough time for any collection\n  assert.strictEqual maxResourcesCollected(2, [4, 6], [10, 15], 5), 0\n  \n  # Test case 3: Single resource type\n  assert.strictEqual maxResourcesCollected(1, [7], [0], 20), 140\n  \n  # Test case 4: Multiple resources with same collection rate\n  assert.strictEqual maxResourcesCollected(4, [3, 3, 3, 3], [5, 2, 1, 4], 8), 21\n\n  console.log \"All tests passed!\"\n\ntestMaxResourcesCollected()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxResourcesCollected = ->\n  # Test case 1: Basic scenario\n  assert.strictEqual maxResourcesCollected(3, [5, 3, 2], [2, 1, 3], 10), 40\n  \n  # Test case 2: Not enough time for any collection\n  assert.strictEqual maxResourcesCollected(2, [4, 6], [10, 15], 5), 0\n  \n  # Test case 3: Single resource type\n  assert.strictEqual maxResourcesCollected(1, [7], [0], 20), 140\n  \n  # Test case 4: Multiple resources with same collection rate\n  assert.strictEqual maxResourcesCollected(4, [3, 3, 3, 3], [5, 2, 1, 4], 8), 21\n\n  console.log \"All tests passed!\"\n\ntestMaxResourcesCollected()", "output": "maxResourcesCollected"}, "all_code": "# maxResourcesCollected calculates the maximum number of resources that can be collected\n# within the given total time, considering the time cost to switch between resource types.\n# \n# Parameters:\n#   n - Number of resource types\n#   r - Array of collection rates for each resource type\n#   t - Array of time costs to switch to each resource type\n#   T - Total available time\n#\n# Returns:\n#   The maximum number of resources that can be collected for any single resource type\nmaxResourcesCollected = (n, r, t, T) ->\n  maxResources = 0\n  \n  for i in [0...n]\n    if T >= t[i]\n      collectionTime = T - t[i]\n      resourcesCollected = collectionTime * r[i]\n      maxResources = Math.max(maxResources, resourcesCollected)\n  \n  maxResources\nassert = require 'assert'\n\ntestMaxResourcesCollected = ->\n  # Test case 1: Basic scenario\n  assert.strictEqual maxResourcesCollected(3, [5, 3, 2], [2, 1, 3], 10), 40\n  \n  # Test case 2: Not enough time for any collection\n  assert.strictEqual maxResourcesCollected(2, [4, 6], [10, 15], 5), 0\n  \n  # Test case 3: Single resource type\n  assert.strictEqual maxResourcesCollected(1, [7], [0], 20), 140\n  \n  # Test case 4: Multiple resources with same collection rate\n  assert.strictEqual maxResourcesCollected(4, [3, 3, 3, 3], [5, 2, 1, 4], 8), 21\n\n  console.log \"All tests passed!\"\n\ntestMaxResourcesCollected()", "exec_outcome": "PASSED"}
{"code": "# efficientFibonacci computes the n-th Fibonacci number using an efficient iterative approach.\n# It handles the base cases (n = 0 or n = 1) directly and iterates for larger values.\nefficientFibonacci = (n) ->\n  return 0 if n is 0\n  return 1 if n is 1\n\n  a = 0\n  b = 1\n  for i in [2..n]\n    [a, b] = [b, a + b]\n  \n  b", "test_cases": "", "test_case_results": "Input: n = 0\nFibonacci number: 0\nInput: n = 1\nFibonacci number: 1\nInput: n = 2\nFibonacci number: 1\nInput: n = 5\nFibonacci number: 5\nInput: n = 10\nFibonacci number: 55\nInput: n = 15\nFibonacci number: 610", "task_id": 24119, "assertions": "assert = require 'assert'\n\ntestEfficientFibonacci = ->\n  assert.strictEqual efficientFibonacci(0), 0\n  assert.strictEqual efficientFibonacci(1), 1\n  assert.strictEqual efficientFibonacci(2), 1\n  assert.strictEqual efficientFibonacci(5), 5\n  assert.strictEqual efficientFibonacci(10), 55\n  assert.strictEqual efficientFibonacci(15), 610\n  console.log \"All tests passed!\"\n\ntestEfficientFibonacci()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestEfficientFibonacci = ->\n  assert.strictEqual efficientFibonacci(0), 0\n  assert.strictEqual efficientFibonacci(1), 1\n  assert.strictEqual efficientFibonacci(2), 1\n  assert.strictEqual efficientFibonacci(5), 5\n  assert.strictEqual efficientFibonacci(10), 55\n  assert.strictEqual efficientFibonacci(15), 610\n  console.log \"All tests passed!\"\n\ntestEfficientFibonacci()", "output": "efficientFibonacci"}, "all_code": "# efficientFibonacci computes the n-th Fibonacci number using an efficient iterative approach.\n# It handles the base cases (n = 0 or n = 1) directly and iterates for larger values.\nefficientFibonacci = (n) ->\n  return 0 if n is 0\n  return 1 if n is 1\n\n  a = 0\n  b = 1\n  for i in [2..n]\n    [a, b] = [b, a + b]\n  \n  b\nassert = require 'assert'\n\ntestEfficientFibonacci = ->\n  assert.strictEqual efficientFibonacci(0), 0\n  assert.strictEqual efficientFibonacci(1), 1\n  assert.strictEqual efficientFibonacci(2), 1\n  assert.strictEqual efficientFibonacci(5), 5\n  assert.strictEqual efficientFibonacci(10), 55\n  assert.strictEqual efficientFibonacci(15), 610\n  console.log \"All tests passed!\"\n\ntestEfficientFibonacci()", "exec_outcome": "PASSED"}
{"code": "# matrixOperations performs a series of operations on a matrix and tracks the sum after each operation.\n# Each operation adds a value `v` to all elements in a submatrix defined by (x1,y1) to (x2,y2),\n# then records the new total sum of all matrix elements.\n#\n# Parameters:\n#   n - number of rows in matrix\n#   m - number of columns in matrix\n#   q - number of operations\n#   matrix - 2D array of numbers\n#   operations - array of operations, each as [x1, y1, x2, y2, v]\n#\n# Returns array of sums after each operation\nmatrixOperations = (n, m, q, matrix, operations) ->\n  result = []\n  # Calculate initial sum of all matrix elements\n  currentSum = matrix.reduce ((sum, row) -> sum + row.reduce ((rowSum, val) -> rowSum + val), 0), 0\n  \n  for [x1, y1, x2, y2, v] in operations\n    # Calculate number of elements in the operation area\n    area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    currentSum += area * v\n    result.push(currentSum)\n    \n  result", "test_cases": "", "test_case_results": "Test Case 1:\nInitial Matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\nOperations: [ [ 0, 0, 1, 1, 2 ], [ 1, 1, 2, 2, -1 ] ]\nResulting sums: [ 53, 49 ]\n\nTest Case 2:\nInitial Matrix: [ [ 0, 0 ], [ 0, 0 ] ]\nOperations: [ [ 0, 0, 1, 1, 5 ], [ 0, 0, 0, 1, 2 ] ]\nResulting sums: [ 20, 24 ]", "task_id": 23541, "assertions": "assert = require 'assert'\n\ntestMatrixOperations = ->\n  testMatrix1 = [\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n  ]\n  testOperations1 = [\n    [0, 0, 1, 1, 2]\n    [1, 1, 2, 2, -1]\n  ]\n  \n  testMatrix2 = [\n    [0, 0]\n    [0, 0]\n  ]\n  testOperations2 = [\n    [0, 0, 1, 1, 5]\n    [0, 0, 0, 1, 2]\n  ]\n\n  assert.deepStrictEqual matrixOperations(3, 3, 2, testMatrix1, testOperations1), [53, 49]\n  assert.deepStrictEqual matrixOperations(2, 2, 2, testMatrix2, testOperations2), [20, 24]\n\ntestMatrixOperations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMatrixOperations = ->\n  testMatrix1 = [\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n  ]\n  testOperations1 = [\n    [0, 0, 1, 1, 2]\n    [1, 1, 2, 2, -1]\n  ]\n  \n  testMatrix2 = [\n    [0, 0]\n    [0, 0]\n  ]\n  testOperations2 = [\n    [0, 0, 1, 1, 5]\n    [0, 0, 0, 1, 2]\n  ]\n\n  assert.deepStrictEqual matrixOperations(3, 3, 2, testMatrix1, testOperations1), [53, 49]\n  assert.deepStrictEqual matrixOperations(2, 2, 2, testMatrix2, testOperations2), [20, 24]\n\ntestMatrixOperations()", "output": "matrixOperations"}, "all_code": "# matrixOperations performs a series of operations on a matrix and tracks the sum after each operation.\n# Each operation adds a value `v` to all elements in a submatrix defined by (x1,y1) to (x2,y2),\n# then records the new total sum of all matrix elements.\n#\n# Parameters:\n#   n - number of rows in matrix\n#   m - number of columns in matrix\n#   q - number of operations\n#   matrix - 2D array of numbers\n#   operations - array of operations, each as [x1, y1, x2, y2, v]\n#\n# Returns array of sums after each operation\nmatrixOperations = (n, m, q, matrix, operations) ->\n  result = []\n  # Calculate initial sum of all matrix elements\n  currentSum = matrix.reduce ((sum, row) -> sum + row.reduce ((rowSum, val) -> rowSum + val), 0), 0\n  \n  for [x1, y1, x2, y2, v] in operations\n    # Calculate number of elements in the operation area\n    area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    currentSum += area * v\n    result.push(currentSum)\n    \n  result\nassert = require 'assert'\n\ntestMatrixOperations = ->\n  testMatrix1 = [\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n  ]\n  testOperations1 = [\n    [0, 0, 1, 1, 2]\n    [1, 1, 2, 2, -1]\n  ]\n  \n  testMatrix2 = [\n    [0, 0]\n    [0, 0]\n  ]\n  testOperations2 = [\n    [0, 0, 1, 1, 5]\n    [0, 0, 0, 1, 2]\n  ]\n\n  assert.deepStrictEqual matrixOperations(3, 3, 2, testMatrix1, testOperations1), [53, 49]\n  assert.deepStrictEqual matrixOperations(2, 2, 2, testMatrix2, testOperations2), [20, 24]\n\ntestMatrixOperations()", "exec_outcome": "PASSED"}
{"code": "# reverseSubstring reverses the characters in a string between left and right indices (inclusive)\nreverseSubstring = (s, left, right) ->\n  sArr = s.split('')\n  while left < right\n    [sArr[left], sArr[right]] = [sArr[right], sArr[left]]  # Swap characters\n    left += 1\n    right -= 1\n  sArr.join('')\n\n# reverseStr reverses the first k characters for every 2k characters in the string\n# If there are fewer than k characters left, reverses all remaining characters\nreverseStr = (s, k) ->\n  n = s.length\n  result = s\n  for i in [0...n] by 2 * k\n    # Determine the end index for reversal (minimum of i+k-1 or end of string)\n    end = Math.min(i + k - 1, n - 1)\n    result = reverseSubstring(result, i, end)\n  result", "test_cases": "", "test_case_results": "Input string: 'abcdefg', k: 2\nResult: 'bacdfeg'\n---\nInput string: 'abcd', k: 2\nResult: 'bacd'\n---\nInput string: 'abcdefghij', k: 3\nResult: 'cbadefihgj'\n---\nInput string: 'a', k: 1\nResult: 'a'\n---\nInput string: 'hello', k: 4\nResult: 'lleho'\n---\nInput string: 'world', k: 5\nResult: 'dlrow'\n---", "task_id": 5337, "assertions": "assert = require 'assert'\n\ntestReverseStr = ->\n  assert.strictEqual reverseStr(\"abcdefg\", 2), \"bacdfeg\"\n  assert.strictEqual reverseStr(\"abcd\", 2), \"bacd\"\n  assert.strictEqual reverseStr(\"abcdefghij\", 3), \"cbadefihgj\"\n  assert.strictEqual reverseStr(\"a\", 1), \"a\"\n  assert.strictEqual reverseStr(\"hello\", 4), \"lleho\"\n  assert.strictEqual reverseStr(\"world\", 5), \"dlrow\"\n  console.log \"All tests passed!\"\n\ntestReverseStr()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestReverseStr = ->\n  assert.strictEqual reverseStr(\"abcdefg\", 2), \"bacdfeg\"\n  assert.strictEqual reverseStr(\"abcd\", 2), \"bacd\"\n  assert.strictEqual reverseStr(\"abcdefghij\", 3), \"cbadefihgj\"\n  assert.strictEqual reverseStr(\"a\", 1), \"a\"\n  assert.strictEqual reverseStr(\"hello\", 4), \"lleho\"\n  assert.strictEqual reverseStr(\"world\", 5), \"dlrow\"\n  console.log \"All tests passed!\"\n\ntestReverseStr()", "output": "reverseStr"}, "all_code": "# reverseSubstring reverses the characters in a string between left and right indices (inclusive)\nreverseSubstring = (s, left, right) ->\n  sArr = s.split('')\n  while left < right\n    [sArr[left], sArr[right]] = [sArr[right], sArr[left]]  # Swap characters\n    left += 1\n    right -= 1\n  sArr.join('')\n\n# reverseStr reverses the first k characters for every 2k characters in the string\n# If there are fewer than k characters left, reverses all remaining characters\nreverseStr = (s, k) ->\n  n = s.length\n  result = s\n  for i in [0...n] by 2 * k\n    # Determine the end index for reversal (minimum of i+k-1 or end of string)\n    end = Math.min(i + k - 1, n - 1)\n    result = reverseSubstring(result, i, end)\n  result\nassert = require 'assert'\n\ntestReverseStr = ->\n  assert.strictEqual reverseStr(\"abcdefg\", 2), \"bacdfeg\"\n  assert.strictEqual reverseStr(\"abcd\", 2), \"bacd\"\n  assert.strictEqual reverseStr(\"abcdefghij\", 3), \"cbadefihgj\"\n  assert.strictEqual reverseStr(\"a\", 1), \"a\"\n  assert.strictEqual reverseStr(\"hello\", 4), \"lleho\"\n  assert.strictEqual reverseStr(\"world\", 5), \"dlrow\"\n  console.log \"All tests passed!\"\n\ntestReverseStr()", "exec_outcome": "PASSED"}
{"code": "# minStepsToReach calculates the minimum number of steps to move from (r1, c1) to (r2, c2)\n# on an n x m grid, where '#' represents obstacles and '.' represents walkable paths.\n# Uses BFS to find the shortest path. Returns -1 if no path exists.\nminStepsToReach = (n, m, grid, r1, c1, r2, c2) ->\n  # Convert to zero-based indices\n  r1 -= 1\n  c1 -= 1\n  r2 -= 1\n  c2 -= 1\n  \n  # Validate whether start or end positions are invalid\n  if grid[r1][c1] is '#' or grid[r2][c2] is '#'\n    return -1\n  \n  # Directions for moving up, down, left, right\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  \n  # BFS queue for storing positions and steps taken\n  queue = [[r1, c1, 0]]  # [row, col, steps]\n  visited = new Set()\n  visited.add(\"#{r1},#{c1}\")\n  \n  while queue.length > 0\n    [row, col, steps] = queue.shift()\n    \n    if row is r2 and col is c2\n      return steps\n    \n    for [dr, dc] in directions\n      newRow = row + dr\n      newCol = col + dc\n      key = \"#{newRow},#{newCol}\"\n      \n      if 0 <= newRow < n and 0 <= newCol < m and not visited.has(key)\n        if grid[newRow][newCol] is '.'\n          visited.add(key)\n          queue.push([newRow, newCol, steps + 1])\n  \n  return -1", "test_cases": "", "test_case_results": "Test Case 1:\nGrid Size: 3x3\nStart: (1, 1)\nEnd: (3, 3)\nGrid:\n. . .\n. # .\n. . .\nMinimum Steps: 4\n----------------------\nTest Case 2:\nGrid Size: 2x2\nStart: (1, 1)\nEnd: (2, 2)\nGrid:\n# .\n. .\nMinimum Steps: -1\n----------------------\nTest Case 3:\nGrid Size: 3x3\nStart: (1, 1)\nEnd: (3, 3)\nGrid:\n. # .\n# # #\n. # .\nMinimum Steps: -1\n----------------------\nTest Case 4:\nGrid Size: 5x5\nStart: (1, 1)\nEnd: (5, 5)\nGrid:\n. . . # .\n. # . # .\n. # . . .\n. # # # .\n. . . . .\nMinimum Steps: 8\n----------------------", "task_id": 17026, "assertions": "assert = require 'assert'\n\ntestMinStepsToReach = ->\n  # Test case 1: Simple 3x3 grid with clear path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '.', '.']\n    ['.', '#', '.']\n    ['.', '.', '.']\n  ], 1, 1, 3, 3), 4\n\n  # Test case 2: Start position is blocked\n  assert.strictEqual minStepsToReach(2, 2, [\n    ['#', '.']\n    ['.', '.']\n  ], 1, 1, 2, 2), -1\n\n  # Test case 3: No possible path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '#', '.']\n    ['#', '#', '#']\n    ['.', '#', '.']\n  ], 1, 1, 3, 3), -1\n\n  # Test case 4: Larger grid with winding path\n  assert.strictEqual minStepsToReach(5, 5, [\n    ['.', '.', '.', '#', '.']\n    ['.', '#', '.', '#', '.']\n    ['.', '#', '.', '.', '.']\n    ['.', '#', '#', '#', '.']\n    ['.', '.', '.', '.', '.']\n  ], 1, 1, 5, 5), 8\n\n  console.log \"All tests passed!\"\n\ntestMinStepsToReach()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinStepsToReach = ->\n  # Test case 1: Simple 3x3 grid with clear path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '.', '.']\n    ['.', '#', '.']\n    ['.', '.', '.']\n  ], 1, 1, 3, 3), 4\n\n  # Test case 2: Start position is blocked\n  assert.strictEqual minStepsToReach(2, 2, [\n    ['#', '.']\n    ['.', '.']\n  ], 1, 1, 2, 2), -1\n\n  # Test case 3: No possible path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '#', '.']\n    ['#', '#', '#']\n    ['.', '#', '.']\n  ], 1, 1, 3, 3), -1\n\n  # Test case 4: Larger grid with winding path\n  assert.strictEqual minStepsToReach(5, 5, [\n    ['.', '.', '.', '#', '.']\n    ['.', '#', '.', '#', '.']\n    ['.', '#', '.', '.', '.']\n    ['.', '#', '#', '#', '.']\n    ['.', '.', '.', '.', '.']\n  ], 1, 1, 5, 5), 8\n\n  console.log \"All tests passed!\"\n\ntestMinStepsToReach()", "output": "minStepsToReach"}, "all_code": "# minStepsToReach calculates the minimum number of steps to move from (r1, c1) to (r2, c2)\n# on an n x m grid, where '#' represents obstacles and '.' represents walkable paths.\n# Uses BFS to find the shortest path. Returns -1 if no path exists.\nminStepsToReach = (n, m, grid, r1, c1, r2, c2) ->\n  # Convert to zero-based indices\n  r1 -= 1\n  c1 -= 1\n  r2 -= 1\n  c2 -= 1\n  \n  # Validate whether start or end positions are invalid\n  if grid[r1][c1] is '#' or grid[r2][c2] is '#'\n    return -1\n  \n  # Directions for moving up, down, left, right\n  directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n  \n  # BFS queue for storing positions and steps taken\n  queue = [[r1, c1, 0]]  # [row, col, steps]\n  visited = new Set()\n  visited.add(\"#{r1},#{c1}\")\n  \n  while queue.length > 0\n    [row, col, steps] = queue.shift()\n    \n    if row is r2 and col is c2\n      return steps\n    \n    for [dr, dc] in directions\n      newRow = row + dr\n      newCol = col + dc\n      key = \"#{newRow},#{newCol}\"\n      \n      if 0 <= newRow < n and 0 <= newCol < m and not visited.has(key)\n        if grid[newRow][newCol] is '.'\n          visited.add(key)\n          queue.push([newRow, newCol, steps + 1])\n  \n  return -1\nassert = require 'assert'\n\ntestMinStepsToReach = ->\n  # Test case 1: Simple 3x3 grid with clear path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '.', '.']\n    ['.', '#', '.']\n    ['.', '.', '.']\n  ], 1, 1, 3, 3), 4\n\n  # Test case 2: Start position is blocked\n  assert.strictEqual minStepsToReach(2, 2, [\n    ['#', '.']\n    ['.', '.']\n  ], 1, 1, 2, 2), -1\n\n  # Test case 3: No possible path\n  assert.strictEqual minStepsToReach(3, 3, [\n    ['.', '#', '.']\n    ['#', '#', '#']\n    ['.', '#', '.']\n  ], 1, 1, 3, 3), -1\n\n  # Test case 4: Larger grid with winding path\n  assert.strictEqual minStepsToReach(5, 5, [\n    ['.', '.', '.', '#', '.']\n    ['.', '#', '.', '#', '.']\n    ['.', '#', '.', '.', '.']\n    ['.', '#', '#', '#', '.']\n    ['.', '.', '.', '.', '.']\n  ], 1, 1, 5, 5), 8\n\n  console.log \"All tests passed!\"\n\ntestMinStepsToReach()", "exec_outcome": "PASSED"}
{"code": "# caesarCipher implements the Caesar cipher encryption algorithm.\n# It shifts each alphabetical character in the input text by the specified shift value,\n# wrapping around the alphabet if necessary. Non-alphabetical characters remain unchanged.\n#\n# Parameters:\n#   text - The input string to be encrypted\n#   shift - The number of positions to shift each character (can be positive or negative)\n#\n# Returns:\n#   The encrypted string\ncaesarCipher = (text, shift) ->\n  shiftedText = \"\"\n  \n  for char in text\n    if char.match(/[a-zA-Z]/)\n      # Determine ASCII offset based on case\n      asciiOffset = if char is char.toUpperCase() then 65 else 97\n      # Calculate shifted value with modulo to handle wrap-around\n      shiftedValue = (char.charCodeAt(0) - asciiOffset + shift) %% 26\n      shiftedText += String.fromCharCode(shiftedValue + asciiOffset)\n    else\n      shiftedText += char\n\n  shiftedText", "test_cases": "", "test_case_results": "Input:\n  Text: 'Hello, World!'\n  Shift: 3\nResult: 'Khoor, Zruog!'\n\nInput:\n  Text: 'XYZ'\n  Shift: 5\nResult: 'CDE'\n\nInput:\n  Text: 'abc'\n  Shift: -1\nResult: 'zab'\n\nInput:\n  Text: '123 Numbers!'\n  Shift: 7\nResult: '123 Ubtilyz!'\n\nInput:\n  Text: 'CoffeeScript'\n  Shift: 13\nResult: 'PbssrrFpevcg'\n\nInput:\n  Text: 'Zebra'\n  Shift: 26\nResult: 'Zebra'\n\nInput:\n  Text: 'Mixed CASE'\n  Shift: -5\nResult: 'Hdszy XVNZ'", "task_id": 17227, "assertions": "assert = require 'assert'\n\ntestCaesarCipher = ->\n  assert.strictEqual caesarCipher(\"Hello, World!\", 3), \"Khoor, Zruog!\"\n  assert.strictEqual caesarCipher(\"XYZ\", 5), \"CDE\"\n  assert.strictEqual caesarCipher(\"abc\", -1), \"zab\"\n  assert.strictEqual caesarCipher(\"123 Numbers!\", 7), \"123 Ubtilyz!\"\n  assert.strictEqual caesarCipher(\"CoffeeScript\", 13), \"PbssrrFpevcg\"\n  assert.strictEqual caesarCipher(\"Zebra\", 26), \"Zebra\"\n  assert.strictEqual caesarCipher(\"Mixed CASE\", -5), \"Hdszy XVNZ\"\n\ntestCaesarCipher()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCaesarCipher = ->\n  assert.strictEqual caesarCipher(\"Hello, World!\", 3), \"Khoor, Zruog!\"\n  assert.strictEqual caesarCipher(\"XYZ\", 5), \"CDE\"\n  assert.strictEqual caesarCipher(\"abc\", -1), \"zab\"\n  assert.strictEqual caesarCipher(\"123 Numbers!\", 7), \"123 Ubtilyz!\"\n  assert.strictEqual caesarCipher(\"CoffeeScript\", 13), \"PbssrrFpevcg\"\n  assert.strictEqual caesarCipher(\"Zebra\", 26), \"Zebra\"\n  assert.strictEqual caesarCipher(\"Mixed CASE\", -5), \"Hdszy XVNZ\"\n\ntestCaesarCipher()", "output": "caesarCipher"}, "all_code": "# caesarCipher implements the Caesar cipher encryption algorithm.\n# It shifts each alphabetical character in the input text by the specified shift value,\n# wrapping around the alphabet if necessary. Non-alphabetical characters remain unchanged.\n#\n# Parameters:\n#   text - The input string to be encrypted\n#   shift - The number of positions to shift each character (can be positive or negative)\n#\n# Returns:\n#   The encrypted string\ncaesarCipher = (text, shift) ->\n  shiftedText = \"\"\n  \n  for char in text\n    if char.match(/[a-zA-Z]/)\n      # Determine ASCII offset based on case\n      asciiOffset = if char is char.toUpperCase() then 65 else 97\n      # Calculate shifted value with modulo to handle wrap-around\n      shiftedValue = (char.charCodeAt(0) - asciiOffset + shift) %% 26\n      shiftedText += String.fromCharCode(shiftedValue + asciiOffset)\n    else\n      shiftedText += char\n\n  shiftedText\nassert = require 'assert'\n\ntestCaesarCipher = ->\n  assert.strictEqual caesarCipher(\"Hello, World!\", 3), \"Khoor, Zruog!\"\n  assert.strictEqual caesarCipher(\"XYZ\", 5), \"CDE\"\n  assert.strictEqual caesarCipher(\"abc\", -1), \"zab\"\n  assert.strictEqual caesarCipher(\"123 Numbers!\", 7), \"123 Ubtilyz!\"\n  assert.strictEqual caesarCipher(\"CoffeeScript\", 13), \"PbssrrFpevcg\"\n  assert.strictEqual caesarCipher(\"Zebra\", 26), \"Zebra\"\n  assert.strictEqual caesarCipher(\"Mixed CASE\", -5), \"Hdszy XVNZ\"\n\ntestCaesarCipher()", "exec_outcome": "PASSED"}
{"code": "# Returns a new string containing characters present only in s1 and not in s2, ignoring case.\n# Only considers ASCII characters.\nonlyInS1NotInS2 = (s1, s2) ->\n  # Create a set of lowercase characters from s2 for case-insensitive comparison\n  s2LowerChars = new Set(s2.toLowerCase())\n  # Filter characters from s1 that aren't in s2 (case-insensitive)\n  (char for char in s1 when not s2LowerChars.has(char.toLowerCase())).join('')", "test_cases": "", "test_case_results": "Test Case 1:\n  s1: Hello\n  s2: World\n  Result: He\n\nTest Case 2:\n  s1: CoffeeScript\n  s2: JavaScript\n  Result: offee\n\nTest Case 3:\n  s1: abcDEF\n  s2: XYZdef\n  Result: abc\n\nTest Case 4:\n  s1: 12345\n  s2: 54321\n  Result: \n\nTest Case 5:\n  s1: CaseSensitive\n  s2: caseinsensitive\n  Result:", "task_id": 12625, "assertions": "assert = require 'assert'\n\ntestOnlyInS1NotInS2 = ->\n  assert.strictEqual onlyInS1NotInS2(\"Hello\", \"World\"), \"He\"\n  assert.strictEqual onlyInS1NotInS2(\"CoffeeScript\", \"JavaScript\"), \"offee\"\n  assert.strictEqual onlyInS1NotInS2(\"abcDEF\", \"XYZdef\"), \"abc\"\n  assert.strictEqual onlyInS1NotInS2(\"12345\", \"54321\"), \"\"\n  assert.strictEqual onlyInS1NotInS2(\"CaseSensitive\", \"caseinsensitive\"), \"\"\n\ntestOnlyInS1NotInS2()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestOnlyInS1NotInS2 = ->\n  assert.strictEqual onlyInS1NotInS2(\"Hello\", \"World\"), \"He\"\n  assert.strictEqual onlyInS1NotInS2(\"CoffeeScript\", \"JavaScript\"), \"offee\"\n  assert.strictEqual onlyInS1NotInS2(\"abcDEF\", \"XYZdef\"), \"abc\"\n  assert.strictEqual onlyInS1NotInS2(\"12345\", \"54321\"), \"\"\n  assert.strictEqual onlyInS1NotInS2(\"CaseSensitive\", \"caseinsensitive\"), \"\"\n\ntestOnlyInS1NotInS2()", "output": "onlyInS1NotInS2"}, "all_code": "# Returns a new string containing characters present only in s1 and not in s2, ignoring case.\n# Only considers ASCII characters.\nonlyInS1NotInS2 = (s1, s2) ->\n  # Create a set of lowercase characters from s2 for case-insensitive comparison\n  s2LowerChars = new Set(s2.toLowerCase())\n  # Filter characters from s1 that aren't in s2 (case-insensitive)\n  (char for char in s1 when not s2LowerChars.has(char.toLowerCase())).join('')\nassert = require 'assert'\n\ntestOnlyInS1NotInS2 = ->\n  assert.strictEqual onlyInS1NotInS2(\"Hello\", \"World\"), \"He\"\n  assert.strictEqual onlyInS1NotInS2(\"CoffeeScript\", \"JavaScript\"), \"offee\"\n  assert.strictEqual onlyInS1NotInS2(\"abcDEF\", \"XYZdef\"), \"abc\"\n  assert.strictEqual onlyInS1NotInS2(\"12345\", \"54321\"), \"\"\n  assert.strictEqual onlyInS1NotInS2(\"CaseSensitive\", \"caseinsensitive\"), \"\"\n\ntestOnlyInS1NotInS2()", "exec_outcome": "PASSED"}
{"code": "# lowerWords filters an array of words and returns only those that start with a lowercase letter\nlowerWords = (words) ->\n    words.filter (word) -> word[0] is word[0].toLowerCase() and word[0] isnt word[0].toUpperCase()", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [ 'Apple', 'banana', 'Cherry', 'date', 'Eggplant' ]\n  Result: [ 'banana', 'date' ]\n\nTest Case 2:\n  Input: [ 'all', 'lower', 'case', 'WORDS' ]\n  Result: [ 'all', 'lower', 'case' ]\n\nTest Case 3:\n  Input: [ 'ALL', 'UPPER', 'CASE' ]\n  Result: []\n\nTest Case 4:\n  Input: [ 'mixed', 'Casing', 'in', 'The', 'array' ]\n  Result: [ 'mixed', 'in', 'array' ]\n\nTest Case 5:\n  Input: []\n  Result: []", "task_id": 23819, "assertions": "assert = require 'assert'\n\ntestLowerWords = ->\n  assert.deepStrictEqual lowerWords([\"Apple\", \"banana\", \"Cherry\", \"date\", \"Eggplant\"]), ['banana', 'date']\n  assert.deepStrictEqual lowerWords([\"all\", \"lower\", \"case\", \"WORDS\"]), ['all', 'lower', 'case']\n  assert.deepStrictEqual lowerWords([\"ALL\", \"UPPER\", \"CASE\"]), []\n  assert.deepStrictEqual lowerWords([\"mixed\", \"Casing\", \"in\", \"The\", \"array\"]), ['mixed', 'in', 'array']\n  assert.deepStrictEqual lowerWords([]), []\n\ntestLowerWords()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestLowerWords = ->\n  assert.deepStrictEqual lowerWords([\"Apple\", \"banana\", \"Cherry\", \"date\", \"Eggplant\"]), ['banana', 'date']\n  assert.deepStrictEqual lowerWords([\"all\", \"lower\", \"case\", \"WORDS\"]), ['all', 'lower', 'case']\n  assert.deepStrictEqual lowerWords([\"ALL\", \"UPPER\", \"CASE\"]), []\n  assert.deepStrictEqual lowerWords([\"mixed\", \"Casing\", \"in\", \"The\", \"array\"]), ['mixed', 'in', 'array']\n  assert.deepStrictEqual lowerWords([]), []\n\ntestLowerWords()", "output": "lowerWords"}, "all_code": "# lowerWords filters an array of words and returns only those that start with a lowercase letter\nlowerWords = (words) ->\n    words.filter (word) -> word[0] is word[0].toLowerCase() and word[0] isnt word[0].toUpperCase()\nassert = require 'assert'\n\ntestLowerWords = ->\n  assert.deepStrictEqual lowerWords([\"Apple\", \"banana\", \"Cherry\", \"date\", \"Eggplant\"]), ['banana', 'date']\n  assert.deepStrictEqual lowerWords([\"all\", \"lower\", \"case\", \"WORDS\"]), ['all', 'lower', 'case']\n  assert.deepStrictEqual lowerWords([\"ALL\", \"UPPER\", \"CASE\"]), []\n  assert.deepStrictEqual lowerWords([\"mixed\", \"Casing\", \"in\", \"The\", \"array\"]), ['mixed', 'in', 'array']\n  assert.deepStrictEqual lowerWords([]), []\n\ntestLowerWords()", "exec_outcome": "PASSED"}
{"code": "# maxRouteIntensity calculates the maximum intensity of a triangular route in a city map.\n# A triangular route is defined as a cycle of 3 distinct cities (u -> v -> w -> u).\n# The intensity is the sum of weights along this triangular path.\n# Parameters:\n#   x, y - unused parameters (included to match original function signature)\n#   roads - array of road tuples [u, v, w] representing cities and weights\n# Returns the maximum intensity found, or 0 if no triangular routes exist\nmaxRouteIntensity = (x, y, roads) ->\n  cityMap = {}\n  \n  # Build adjacency map from roads data\n  for [u, v, w] in roads\n    cityMap[u] ?= {}\n    cityMap[v] ?= {}\n    cityMap[u][v] = w\n    cityMap[v][u] = w\n\n  maxIntensity = 0\n  \n  # Check all possible triangular routes\n  for u of cityMap\n    for v of cityMap[u]\n      # Skip mirrored pairs to avoid duplicate checks\n      continue if v <= u\n      for w of cityMap[v]\n        # Ensure we have a valid triangle (w > v and w != u)\n        continue if w <= v or w == u\n        if cityMap[w]?[u]?\n          intensity = cityMap[u][v] + cityMap[v][w] + cityMap[w][u]\n          maxIntensity = Math.max(maxIntensity, intensity)\n          \n  maxIntensity", "test_cases": "", "test_case_results": "Test Case 1: Example case with triangular routes\nInput:\n  x: 5\n  y: 6\n  roads: [\n  [ 1, 2, 4 ],\n  [ 2, 3, 5 ],\n  [ 3, 4, 6 ],\n  [ 4, 1, 7 ],\n  [ 1, 3, 9 ],\n  [ 2, 4, 8 ]\n]\nResult: 22\n\nTest Case 2: Case with no triangular routes\nInput:\n  x: 3\n  y: 3\n  roads: [ [ 1, 2, 1 ], [ 2, 3, 2 ], [ 3, 4, 3 ] ]\nResult: 0\n\nTest Case 3: Case with multiple triangular routes\nInput:\n  x: 4\n  y: 4\n  roads: [\n  [ 1, 2, 10 ],\n  [ 2, 3, 20 ],\n  [ 3, 1, 30 ],\n  [ 1, 4, 5 ],\n  [ 2, 4, 15 ],\n  [ 3, 4, 25 ]\n]\nResult: 60", "task_id": 28153, "assertions": "assert = require 'assert'\n\ntestMaxRouteIntensity = ->\n  # Test case 1: Example case with triangular routes\n  assert.strictEqual maxRouteIntensity(5, 6, [\n    [1, 2, 4],\n    [2, 3, 5],\n    [3, 4, 6],\n    [4, 1, 7],\n    [1, 3, 9],\n    [2, 4, 8]\n  ]), 22\n\n  # Test case 2: Case with no triangular routes\n  assert.strictEqual maxRouteIntensity(3, 3, [\n    [1, 2, 1],\n    [2, 3, 2],\n    [3, 4, 3]\n  ]), 0\n\n  # Test case 3: Case with multiple triangular routes\n  assert.strictEqual maxRouteIntensity(4, 4, [\n    [1, 2, 10],\n    [2, 3, 20],\n    [3, 1, 30],\n    [1, 4, 5],\n    [2, 4, 15],\n    [3, 4, 25]\n  ]), 60\n\n  console.log \"All tests passed successfully!\"\n\ntestMaxRouteIntensity()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxRouteIntensity = ->\n  # Test case 1: Example case with triangular routes\n  assert.strictEqual maxRouteIntensity(5, 6, [\n    [1, 2, 4],\n    [2, 3, 5],\n    [3, 4, 6],\n    [4, 1, 7],\n    [1, 3, 9],\n    [2, 4, 8]\n  ]), 22\n\n  # Test case 2: Case with no triangular routes\n  assert.strictEqual maxRouteIntensity(3, 3, [\n    [1, 2, 1],\n    [2, 3, 2],\n    [3, 4, 3]\n  ]), 0\n\n  # Test case 3: Case with multiple triangular routes\n  assert.strictEqual maxRouteIntensity(4, 4, [\n    [1, 2, 10],\n    [2, 3, 20],\n    [3, 1, 30],\n    [1, 4, 5],\n    [2, 4, 15],\n    [3, 4, 25]\n  ]), 60\n\n  console.log \"All tests passed successfully!\"\n\ntestMaxRouteIntensity()", "output": "maxRouteIntensity"}, "all_code": "# maxRouteIntensity calculates the maximum intensity of a triangular route in a city map.\n# A triangular route is defined as a cycle of 3 distinct cities (u -> v -> w -> u).\n# The intensity is the sum of weights along this triangular path.\n# Parameters:\n#   x, y - unused parameters (included to match original function signature)\n#   roads - array of road tuples [u, v, w] representing cities and weights\n# Returns the maximum intensity found, or 0 if no triangular routes exist\nmaxRouteIntensity = (x, y, roads) ->\n  cityMap = {}\n  \n  # Build adjacency map from roads data\n  for [u, v, w] in roads\n    cityMap[u] ?= {}\n    cityMap[v] ?= {}\n    cityMap[u][v] = w\n    cityMap[v][u] = w\n\n  maxIntensity = 0\n  \n  # Check all possible triangular routes\n  for u of cityMap\n    for v of cityMap[u]\n      # Skip mirrored pairs to avoid duplicate checks\n      continue if v <= u\n      for w of cityMap[v]\n        # Ensure we have a valid triangle (w > v and w != u)\n        continue if w <= v or w == u\n        if cityMap[w]?[u]?\n          intensity = cityMap[u][v] + cityMap[v][w] + cityMap[w][u]\n          maxIntensity = Math.max(maxIntensity, intensity)\n          \n  maxIntensity\nassert = require 'assert'\n\ntestMaxRouteIntensity = ->\n  # Test case 1: Example case with triangular routes\n  assert.strictEqual maxRouteIntensity(5, 6, [\n    [1, 2, 4],\n    [2, 3, 5],\n    [3, 4, 6],\n    [4, 1, 7],\n    [1, 3, 9],\n    [2, 4, 8]\n  ]), 22\n\n  # Test case 2: Case with no triangular routes\n  assert.strictEqual maxRouteIntensity(3, 3, [\n    [1, 2, 1],\n    [2, 3, 2],\n    [3, 4, 3]\n  ]), 0\n\n  # Test case 3: Case with multiple triangular routes\n  assert.strictEqual maxRouteIntensity(4, 4, [\n    [1, 2, 10],\n    [2, 3, 20],\n    [3, 1, 30],\n    [1, 4, 5],\n    [2, 4, 15],\n    [3, 4, 25]\n  ]), 60\n\n  console.log \"All tests passed successfully!\"\n\ntestMaxRouteIntensity()", "exec_outcome": "PASSED"}
{"code": "# maxConsecutiveOnes calculates the maximum number of consecutive '1's in a 2D grid.\n# The search is performed in all directions: horizontal, vertical, and both diagonals.\n# Parameters:\n#   n - number of rows in the grid\n#   m - number of columns in the grid\n#   grid - 2D array of '0's and '1's\nmaxConsecutiveOnes = (n, m, grid) ->\n  # Helper function to count consecutive '1's in a specific direction\n  countConsecutiveOnes = (x, y, dx, dy) ->\n    length = 0\n    maxLength = 0\n    while 0 <= x < n and 0 <= y < m\n      if grid[x][y] == '1'\n        length += 1\n        maxLength = Math.max(maxLength, length)\n      else\n        length = 0\n      x += dx\n      y += dy\n    maxLength\n\n  maxLength = 0\n\n  # Check all rows (left to right)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, 0, 0, 1))\n\n  # Check all columns (top to bottom)\n  for j in [0...m]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, 0))\n\n  # Check diagonals (top-left to bottom-right)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, 0, 1, 1))\n  for j in [1...m]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, 1))\n\n  # Check diagonals (top-right to bottom-left)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, m-1, 1, -1))\n  for j in [0...m-1]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, -1))\n\n  maxLength", "test_cases": "", "test_case_results": "Test Case: Single row with consecutive '1's\nGrid Size: 1 rows x 5 cols\nGrid:\n1 1 0 1 1\nMaximum consecutive '1's: 2\n-----\nTest Case: All '1's grid\nGrid Size: 3 rows x 3 cols\nGrid:\n1 1 1\n1 1 1\n1 1 1\nMaximum consecutive '1's: 3\n-----\nTest Case: Diagonal '1's\nGrid Size: 4 rows x 4 cols\nGrid:\n1 0 0 0\n0 1 0 0\n0 0 1 0\n0 0 0 1\nMaximum consecutive '1's: 4\n-----\nTest Case: Checkerboard pattern\nGrid Size: 4 rows x 4 cols\nGrid:\n1 0 1 0\n0 1 0 1\n1 0 1 0\n0 1 0 1\nMaximum consecutive '1's: 4\n-----", "task_id": 6230, "assertions": "assert = require 'assert'\n\ntestMaxConsecutiveOnes = ->\n  # Test Case 1: Single row with consecutive '1's\n  grid1 = [\n    ['1', '1', '0', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(1, 5, grid1), 2\n\n  # Test Case 2: All '1's grid\n  grid2 = [\n    ['1', '1', '1'],\n    ['1', '1', '1'],\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(3, 3, grid2), 3\n\n  # Test Case 3: Diagonal '1's\n  grid3 = [\n    ['1', '0', '0', '0'],\n    ['0', '1', '0', '0'],\n    ['0', '0', '1', '0'],\n    ['0', '0', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid3), 4\n\n  # Test Case 4: Checkerboard pattern\n  grid4 = [\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1'],\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid4), 1\n\n  console.log \"All tests passed!\"\n\ntestMaxConsecutiveOnes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxConsecutiveOnes = ->\n  # Test Case 1: Single row with consecutive '1's\n  grid1 = [\n    ['1', '1', '0', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(1, 5, grid1), 2\n\n  # Test Case 2: All '1's grid\n  grid2 = [\n    ['1', '1', '1'],\n    ['1', '1', '1'],\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(3, 3, grid2), 3\n\n  # Test Case 3: Diagonal '1's\n  grid3 = [\n    ['1', '0', '0', '0'],\n    ['0', '1', '0', '0'],\n    ['0', '0', '1', '0'],\n    ['0', '0', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid3), 4\n\n  # Test Case 4: Checkerboard pattern\n  grid4 = [\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1'],\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid4), 1\n\n  console.log \"All tests passed!\"\n\ntestMaxConsecutiveOnes()", "output": "maxConsecutiveOnes"}, "all_code": "# maxConsecutiveOnes calculates the maximum number of consecutive '1's in a 2D grid.\n# The search is performed in all directions: horizontal, vertical, and both diagonals.\n# Parameters:\n#   n - number of rows in the grid\n#   m - number of columns in the grid\n#   grid - 2D array of '0's and '1's\nmaxConsecutiveOnes = (n, m, grid) ->\n  # Helper function to count consecutive '1's in a specific direction\n  countConsecutiveOnes = (x, y, dx, dy) ->\n    length = 0\n    maxLength = 0\n    while 0 <= x < n and 0 <= y < m\n      if grid[x][y] == '1'\n        length += 1\n        maxLength = Math.max(maxLength, length)\n      else\n        length = 0\n      x += dx\n      y += dy\n    maxLength\n\n  maxLength = 0\n\n  # Check all rows (left to right)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, 0, 0, 1))\n\n  # Check all columns (top to bottom)\n  for j in [0...m]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, 0))\n\n  # Check diagonals (top-left to bottom-right)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, 0, 1, 1))\n  for j in [1...m]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, 1))\n\n  # Check diagonals (top-right to bottom-left)\n  for i in [0...n]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(i, m-1, 1, -1))\n  for j in [0...m-1]\n    maxLength = Math.max(maxLength, countConsecutiveOnes(0, j, 1, -1))\n\n  maxLength\nassert = require 'assert'\n\ntestMaxConsecutiveOnes = ->\n  # Test Case 1: Single row with consecutive '1's\n  grid1 = [\n    ['1', '1', '0', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(1, 5, grid1), 2\n\n  # Test Case 2: All '1's grid\n  grid2 = [\n    ['1', '1', '1'],\n    ['1', '1', '1'],\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(3, 3, grid2), 3\n\n  # Test Case 3: Diagonal '1's\n  grid3 = [\n    ['1', '0', '0', '0'],\n    ['0', '1', '0', '0'],\n    ['0', '0', '1', '0'],\n    ['0', '0', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid3), 4\n\n  # Test Case 4: Checkerboard pattern\n  grid4 = [\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1'],\n    ['1', '0', '1', '0'],\n    ['0', '1', '0', '1']\n  ]\n  assert.strictEqual maxConsecutiveOnes(4, 4, grid4), 1\n\n  console.log \"All tests passed!\"\n\ntestMaxConsecutiveOnes()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# Determines if it's possible to partition the array into exactly two non-empty parts\n# such that the XOR of the two parts is equal.\n# \n# Parameters:\n#   n - length of the array\n#   arr - array of numbers to partition\n#\n# Returns:\n#   \"YES\" if such a partition exists, \"NO\" otherwise\ncanPartitionEqualXor = (n, arr) ->\n  totalXor = 0\n  totalXor ^= num for num in arr\n  \n  leftXor = 0\n  for i in [0...n-1]\n    leftXor ^= arr[i]\n    rightXor = totalXor ^ leftXor\n    if leftXor is rightXor\n      return \"YES\"\n  \n  return \"NO\"", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: n = 4, arr = [1,2,3,4]\n  Result: NO\n\nTest Case 2:\n  Input: n = 4, arr = [1,2,3,0]\n  Result: YES\n\nTest Case 3:\n  Input: n = 5, arr = [5,5,5,5,5]\n  Result: NO\n\nTest Case 4:\n  Input: n = 3, arr = [0,0,0]\n  Result: YES\n\nTest Case 5:\n  Input: n = 2, arr = [10,10]\n  Result: YES\n\nTest Case 6:\n  Input: n = 2, arr = [1,2]\n  Result: NO", "task_id": 13677, "assertions": "assert = require 'assert'\n\ntestCanPartitionEqualXor = ->\n  # Test case 1\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 4]), \"NO\"\n  # Test case 2\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 0]), \"YES\"\n  # Test case 3 - Note: The expected result in the output was \"NO\" but the comment said \"YES\"\n  # Using the actual output from test results\n  assert.strictEqual canPartitionEqualXor(5, [5, 5, 5, 5, 5]), \"NO\"\n  # Test case 4\n  assert.strictEqual canPartitionEqualXor(3, [0, 0, 0]), \"YES\"\n  # Test case 5\n  assert.strictEqual canPartitionEqualXor(2, [10, 10]), \"YES\"\n  # Test case 6\n  assert.strictEqual canPartitionEqualXor(2, [1, 2]), \"NO\"\n  console.log \"All tests passed!\"\n\ntestCanPartitionEqualXor()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCanPartitionEqualXor = ->\n  # Test case 1\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 4]), \"NO\"\n  # Test case 2\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 0]), \"YES\"\n  # Test case 3 - Note: The expected result in the output was \"NO\" but the comment said \"YES\"\n  # Using the actual output from test results\n  assert.strictEqual canPartitionEqualXor(5, [5, 5, 5, 5, 5]), \"NO\"\n  # Test case 4\n  assert.strictEqual canPartitionEqualXor(3, [0, 0, 0]), \"YES\"\n  # Test case 5\n  assert.strictEqual canPartitionEqualXor(2, [10, 10]), \"YES\"\n  # Test case 6\n  assert.strictEqual canPartitionEqualXor(2, [1, 2]), \"NO\"\n  console.log \"All tests passed!\"\n\ntestCanPartitionEqualXor()", "output": "canPartitionEqualXor"}, "all_code": "# Determines if it's possible to partition the array into exactly two non-empty parts\n# such that the XOR of the two parts is equal.\n# \n# Parameters:\n#   n - length of the array\n#   arr - array of numbers to partition\n#\n# Returns:\n#   \"YES\" if such a partition exists, \"NO\" otherwise\ncanPartitionEqualXor = (n, arr) ->\n  totalXor = 0\n  totalXor ^= num for num in arr\n  \n  leftXor = 0\n  for i in [0...n-1]\n    leftXor ^= arr[i]\n    rightXor = totalXor ^ leftXor\n    if leftXor is rightXor\n      return \"YES\"\n  \n  return \"NO\"\nassert = require 'assert'\n\ntestCanPartitionEqualXor = ->\n  # Test case 1\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 4]), \"NO\"\n  # Test case 2\n  assert.strictEqual canPartitionEqualXor(4, [1, 2, 3, 0]), \"YES\"\n  # Test case 3 - Note: The expected result in the output was \"NO\" but the comment said \"YES\"\n  # Using the actual output from test results\n  assert.strictEqual canPartitionEqualXor(5, [5, 5, 5, 5, 5]), \"NO\"\n  # Test case 4\n  assert.strictEqual canPartitionEqualXor(3, [0, 0, 0]), \"YES\"\n  # Test case 5\n  assert.strictEqual canPartitionEqualXor(2, [10, 10]), \"YES\"\n  # Test case 6\n  assert.strictEqual canPartitionEqualXor(2, [1, 2]), \"NO\"\n  console.log \"All tests passed!\"\n\ntestCanPartitionEqualXor()", "exec_outcome": "PASSED"}
{"code": "# highestScorePermutation generates a permutation of numbers from 1 to n that maximizes\n# the absolute difference between the first two elements, and returns both the max difference\n# and the permutation itself.\n# The permutation alternates between high and low values to maximize differences.\nhighestScorePermutation = (n) ->\n  # Construct permutation in alternating high-low order\n  permutation = for i in [0...n]\n    if i % 2 is 0 then n - Math.floor(i / 2) else Math.floor(i / 2) + 1\n  \n  # Calculate maximum difference between first two elements\n  maxDiff = if n > 1 then Math.abs(permutation[0] - permutation[1]) else 0\n  \n  {maxDiff, permutation}", "test_cases": "", "test_case_results": "Input n: 1\nMax Difference: NaN\nPermutation: [ 1 ]\n\nInput n: 2\nMax Difference: 1\nPermutation: [ 2, 1 ]\n\nInput n: 3\nMax Difference: 2\nPermutation: [ 3, 1, 2 ]\n\nInput n: 4\nMax Difference: 3\nPermutation: [ 4, 1, 3, 2 ]\n\nInput n: 5\nMax Difference: 4\nPermutation: [ 5, 1, 4, 2, 3 ]\n\nInput n: 6\nMax Difference: 5\nPermutation: [ 6, 1, 5, 2, 4, 3 ]", "task_id": 12221, "assertions": "assert = require 'assert'\n\ntestHighestScorePermutation = ->\n  # Test case for n=1\n  result1 = highestScorePermutation(1)\n  assert.strictEqual result1.maxDiff, 0\n  assert.deepStrictEqual result1.permutation, [1]\n\n  # Test case for n=2\n  result2 = highestScorePermutation(2)\n  assert.strictEqual result2.maxDiff, 1\n  assert.deepStrictEqual result2.permutation, [2, 1]\n\n  # Test case for n=3\n  result3 = highestScorePermutation(3)\n  assert.strictEqual result3.maxDiff, 2\n  assert.deepStrictEqual result3.permutation, [3, 1, 2]\n\n  # Test case for n=4\n  result4 = highestScorePermutation(4)\n  assert.strictEqual result4.maxDiff, 3\n  assert.deepStrictEqual result4.permutation, [4, 1, 3, 2]\n\n  # Test case for n=5\n  result5 = highestScorePermutation(5)\n  assert.strictEqual result5.maxDiff, 4\n  assert.deepStrictEqual result5.permutation, [5, 1, 4, 2, 3]\n\n  # Test case for n=6\n  result6 = highestScorePermutation(6)\n  assert.strictEqual result6.maxDiff, 5\n  assert.deepStrictEqual result6.permutation, [6, 1, 5, 2, 4, 3]\n\n  console.log \"All tests passed!\"\n\ntestHighestScorePermutation()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestHighestScorePermutation = ->\n  # Test case for n=1\n  result1 = highestScorePermutation(1)\n  assert.strictEqual result1.maxDiff, 0\n  assert.deepStrictEqual result1.permutation, [1]\n\n  # Test case for n=2\n  result2 = highestScorePermutation(2)\n  assert.strictEqual result2.maxDiff, 1\n  assert.deepStrictEqual result2.permutation, [2, 1]\n\n  # Test case for n=3\n  result3 = highestScorePermutation(3)\n  assert.strictEqual result3.maxDiff, 2\n  assert.deepStrictEqual result3.permutation, [3, 1, 2]\n\n  # Test case for n=4\n  result4 = highestScorePermutation(4)\n  assert.strictEqual result4.maxDiff, 3\n  assert.deepStrictEqual result4.permutation, [4, 1, 3, 2]\n\n  # Test case for n=5\n  result5 = highestScorePermutation(5)\n  assert.strictEqual result5.maxDiff, 4\n  assert.deepStrictEqual result5.permutation, [5, 1, 4, 2, 3]\n\n  # Test case for n=6\n  result6 = highestScorePermutation(6)\n  assert.strictEqual result6.maxDiff, 5\n  assert.deepStrictEqual result6.permutation, [6, 1, 5, 2, 4, 3]\n\n  console.log \"All tests passed!\"\n\ntestHighestScorePermutation()", "output": "highestScorePermutation"}, "all_code": "# highestScorePermutation generates a permutation of numbers from 1 to n that maximizes\n# the absolute difference between the first two elements, and returns both the max difference\n# and the permutation itself.\n# The permutation alternates between high and low values to maximize differences.\nhighestScorePermutation = (n) ->\n  # Construct permutation in alternating high-low order\n  permutation = for i in [0...n]\n    if i % 2 is 0 then n - Math.floor(i / 2) else Math.floor(i / 2) + 1\n  \n  # Calculate maximum difference between first two elements\n  maxDiff = if n > 1 then Math.abs(permutation[0] - permutation[1]) else 0\n  \n  {maxDiff, permutation}\nassert = require 'assert'\n\ntestHighestScorePermutation = ->\n  # Test case for n=1\n  result1 = highestScorePermutation(1)\n  assert.strictEqual result1.maxDiff, 0\n  assert.deepStrictEqual result1.permutation, [1]\n\n  # Test case for n=2\n  result2 = highestScorePermutation(2)\n  assert.strictEqual result2.maxDiff, 1\n  assert.deepStrictEqual result2.permutation, [2, 1]\n\n  # Test case for n=3\n  result3 = highestScorePermutation(3)\n  assert.strictEqual result3.maxDiff, 2\n  assert.deepStrictEqual result3.permutation, [3, 1, 2]\n\n  # Test case for n=4\n  result4 = highestScorePermutation(4)\n  assert.strictEqual result4.maxDiff, 3\n  assert.deepStrictEqual result4.permutation, [4, 1, 3, 2]\n\n  # Test case for n=5\n  result5 = highestScorePermutation(5)\n  assert.strictEqual result5.maxDiff, 4\n  assert.deepStrictEqual result5.permutation, [5, 1, 4, 2, 3]\n\n  # Test case for n=6\n  result6 = highestScorePermutation(6)\n  assert.strictEqual result6.maxDiff, 5\n  assert.deepStrictEqual result6.permutation, [6, 1, 5, 2, 4, 3]\n\n  console.log \"All tests passed!\"\n\ntestHighestScorePermutation()", "exec_outcome": "PASSED"}
{"code": "# smallestRemainingStonePower calculates the smallest possible power level of the remaining stone\n# after repeatedly combining the two most powerful stones (replacing them with their absolute difference).\n# Returns 0 if no stones remain.\nsmallestRemainingStonePower = (stones) ->\n  workingStones = stones.slice() # Create a copy to avoid modifying input\n  while workingStones.length > 1\n    # Sort in ascending order for easy access to two largest stones\n    workingStones.sort (a, b) -> a - b\n    a = workingStones.pop()\n    b = workingStones.pop()\n    newStone = Math.abs(a - b)\n    workingStones.push(newStone) if newStone isnt 0\n  return workingStones[0] or 0", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Stones: [ 2, 7, 4, 1, 8, 1 ]\n  Remaining Stone Power: 1\n\nTest Case 2:\n  Input Stones: [ 1, 2, 3, 4 ]\n  Remaining Stone Power: 0\n\nTest Case 3:\n  Input Stones: [ 5, 5, 5, 5 ]\n  Remaining Stone Power: 0\n\nTest Case 4:\n  Input Stones: [ 10 ]\n  Remaining Stone Power: 10\n\nTest Case 5:\n  Input Stones: []\n  Remaining Stone Power: 0\n\nTest Case 6:\n  Input Stones: [ 3, 1, 1 ]\n  Remaining Stone Power: 1", "task_id": 23829, "assertions": "assert = require 'assert'\n\ntestSmallestRemainingStonePower = ->\n  assert.strictEqual smallestRemainingStonePower([2, 7, 4, 1, 8, 1]), 1\n  assert.strictEqual smallestRemainingStonePower([1, 2, 3, 4]), 0\n  assert.strictEqual smallestRemainingStonePower([5, 5, 5, 5]), 0\n  assert.strictEqual smallestRemainingStonePower([10]), 10\n  assert.strictEqual smallestRemainingStonePower([]), 0\n  assert.strictEqual smallestRemainingStonePower([3, 1, 1]), 1\n  console.log \"All tests passed!\"\n\ntestSmallestRemainingStonePower()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSmallestRemainingStonePower = ->\n  assert.strictEqual smallestRemainingStonePower([2, 7, 4, 1, 8, 1]), 1\n  assert.strictEqual smallestRemainingStonePower([1, 2, 3, 4]), 0\n  assert.strictEqual smallestRemainingStonePower([5, 5, 5, 5]), 0\n  assert.strictEqual smallestRemainingStonePower([10]), 10\n  assert.strictEqual smallestRemainingStonePower([]), 0\n  assert.strictEqual smallestRemainingStonePower([3, 1, 1]), 1\n  console.log \"All tests passed!\"\n\ntestSmallestRemainingStonePower()", "output": "smallestRemainingStonePower"}, "all_code": "# smallestRemainingStonePower calculates the smallest possible power level of the remaining stone\n# after repeatedly combining the two most powerful stones (replacing them with their absolute difference).\n# Returns 0 if no stones remain.\nsmallestRemainingStonePower = (stones) ->\n  workingStones = stones.slice() # Create a copy to avoid modifying input\n  while workingStones.length > 1\n    # Sort in ascending order for easy access to two largest stones\n    workingStones.sort (a, b) -> a - b\n    a = workingStones.pop()\n    b = workingStones.pop()\n    newStone = Math.abs(a - b)\n    workingStones.push(newStone) if newStone isnt 0\n  return workingStones[0] or 0\nassert = require 'assert'\n\ntestSmallestRemainingStonePower = ->\n  assert.strictEqual smallestRemainingStonePower([2, 7, 4, 1, 8, 1]), 1\n  assert.strictEqual smallestRemainingStonePower([1, 2, 3, 4]), 0\n  assert.strictEqual smallestRemainingStonePower([5, 5, 5, 5]), 0\n  assert.strictEqual smallestRemainingStonePower([10]), 10\n  assert.strictEqual smallestRemainingStonePower([]), 0\n  assert.strictEqual smallestRemainingStonePower([3, 1, 1]), 1\n  console.log \"All tests passed!\"\n\ntestSmallestRemainingStonePower()", "exec_outcome": "PASSED"}
{"code": "# mostFrequentActivity computes the most frequent activity type for each user\n# within a specified time period.\n#\n# Parameters:\n# - activities: Array of user activity tuples [userId, activityType, timestamp]\n# - startTime: Start of the time period (inclusive)\n# - endTime: End of the time period (inclusive)\n#\n# Returns:\n# - Object where keys are user IDs and values are the most frequent activity type\nmostFrequentActivity = (activities, startTime, endTime) ->\n  userActivityCounts = {}\n  \n  # Count activities for each user within the time period\n  for [userId, activityType, timestamp] in activities\n    if timestamp >= startTime and timestamp <= endTime\n      userActivityCounts[userId] ?= {}\n      userActivityCounts[userId][activityType] ?= 0\n      userActivityCounts[userId][activityType] += 1\n  \n  result = {}\n  \n  # Find most frequent activity for each user\n  for userId, counts of userActivityCounts\n    maxCount = -1\n    mostCommonActivity = null\n    \n    for activityType, count of counts\n      if count > maxCount or (count == maxCount and activityType < mostCommonActivity)\n        maxCount = count\n        mostCommonActivity = activityType\n    \n    result[userId] = mostCommonActivity\n  \n  result", "test_cases": "", "test_case_results": "Test Case: Basic test case with multiple users and activities\nInput Activities: [\n  [ 'user1', 'login', 1 ],\n  [ 'user1', 'logout', 2 ],\n  [ 'user1', 'login', 3 ],\n  [ 'user2', 'login', 1 ],\n  [ 'user2', 'view', 2 ],\n  [ 'user2', 'login', 4 ]\n]\nTime Range: 1 to 3\nResult: { user1: 'login', user2: 'login' }\n-----\nTest Case: Test case with tie-breaker (alphabetical order)\nInput Activities: [\n  [ 'userA', 'click', 10 ],\n  [ 'userA', 'scroll', 10 ],\n  [ 'userB', 'click', 15 ]\n]\nTime Range: 10 to 15\nResult: { userA: 'click', userB: 'click' }\n-----\nTest Case: Test case with only one activity in time range\nInput Activities: [ [ 'userX', 'open', 100 ], [ 'userX', 'close', 200 ] ]\nTime Range: 150 to 250\nResult: { userX: 'close' }\n-----", "task_id": 14421, "assertions": "assert = require 'assert'\n\ntestMostFrequentActivity = ->\n  # Test case 1: Basic test case with multiple users and activities\n  activities1 = [\n    [\"user1\", \"login\", 1]\n    [\"user1\", \"logout\", 2]\n    [\"user1\", \"login\", 3]\n    [\"user2\", \"login\", 1]\n    [\"user2\", \"view\", 2]\n    [\"user2\", \"login\", 4]\n  ]\n  result1 = mostFrequentActivity(activities1, 1, 3)\n  assert.deepStrictEqual result1, { user1: 'login', user2: 'login' }\n\n  # Test case 2: Test case with tie-breaker (alphabetical order)\n  activities2 = [\n    [\"userA\", \"click\", 10]\n    [\"userA\", \"scroll\", 10]\n    [\"userB\", \"click\", 15]\n  ]\n  result2 = mostFrequentActivity(activities2, 10, 15)\n  assert.deepStrictEqual result2, { userA: 'click', userB: 'click' }\n\n  # Test case 3: Test case with only one activity in time range\n  activities3 = [\n    [\"userX\", \"open\", 100]\n    [\"userX\", \"close\", 200]\n  ]\n  result3 = mostFrequentActivity(activities3, 150, 250)\n  assert.deepStrictEqual result3, { userX: 'close' }\n\n  console.log \"All tests passed!\"\n\ntestMostFrequentActivity()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMostFrequentActivity = ->\n  # Test case 1: Basic test case with multiple users and activities\n  activities1 = [\n    [\"user1\", \"login\", 1]\n    [\"user1\", \"logout\", 2]\n    [\"user1\", \"login\", 3]\n    [\"user2\", \"login\", 1]\n    [\"user2\", \"view\", 2]\n    [\"user2\", \"login\", 4]\n  ]\n  result1 = mostFrequentActivity(activities1, 1, 3)\n  assert.deepStrictEqual result1, { user1: 'login', user2: 'login' }\n\n  # Test case 2: Test case with tie-breaker (alphabetical order)\n  activities2 = [\n    [\"userA\", \"click\", 10]\n    [\"userA\", \"scroll\", 10]\n    [\"userB\", \"click\", 15]\n  ]\n  result2 = mostFrequentActivity(activities2, 10, 15)\n  assert.deepStrictEqual result2, { userA: 'click', userB: 'click' }\n\n  # Test case 3: Test case with only one activity in time range\n  activities3 = [\n    [\"userX\", \"open\", 100]\n    [\"userX\", \"close\", 200]\n  ]\n  result3 = mostFrequentActivity(activities3, 150, 250)\n  assert.deepStrictEqual result3, { userX: 'close' }\n\n  console.log \"All tests passed!\"\n\ntestMostFrequentActivity()", "output": "mostFrequentActivity"}, "all_code": "# mostFrequentActivity computes the most frequent activity type for each user\n# within a specified time period.\n#\n# Parameters:\n# - activities: Array of user activity tuples [userId, activityType, timestamp]\n# - startTime: Start of the time period (inclusive)\n# - endTime: End of the time period (inclusive)\n#\n# Returns:\n# - Object where keys are user IDs and values are the most frequent activity type\nmostFrequentActivity = (activities, startTime, endTime) ->\n  userActivityCounts = {}\n  \n  # Count activities for each user within the time period\n  for [userId, activityType, timestamp] in activities\n    if timestamp >= startTime and timestamp <= endTime\n      userActivityCounts[userId] ?= {}\n      userActivityCounts[userId][activityType] ?= 0\n      userActivityCounts[userId][activityType] += 1\n  \n  result = {}\n  \n  # Find most frequent activity for each user\n  for userId, counts of userActivityCounts\n    maxCount = -1\n    mostCommonActivity = null\n    \n    for activityType, count of counts\n      if count > maxCount or (count == maxCount and activityType < mostCommonActivity)\n        maxCount = count\n        mostCommonActivity = activityType\n    \n    result[userId] = mostCommonActivity\n  \n  result\nassert = require 'assert'\n\ntestMostFrequentActivity = ->\n  # Test case 1: Basic test case with multiple users and activities\n  activities1 = [\n    [\"user1\", \"login\", 1]\n    [\"user1\", \"logout\", 2]\n    [\"user1\", \"login\", 3]\n    [\"user2\", \"login\", 1]\n    [\"user2\", \"view\", 2]\n    [\"user2\", \"login\", 4]\n  ]\n  result1 = mostFrequentActivity(activities1, 1, 3)\n  assert.deepStrictEqual result1, { user1: 'login', user2: 'login' }\n\n  # Test case 2: Test case with tie-breaker (alphabetical order)\n  activities2 = [\n    [\"userA\", \"click\", 10]\n    [\"userA\", \"scroll\", 10]\n    [\"userB\", \"click\", 15]\n  ]\n  result2 = mostFrequentActivity(activities2, 10, 15)\n  assert.deepStrictEqual result2, { userA: 'click', userB: 'click' }\n\n  # Test case 3: Test case with only one activity in time range\n  activities3 = [\n    [\"userX\", \"open\", 100]\n    [\"userX\", \"close\", 200]\n  ]\n  result3 = mostFrequentActivity(activities3, 150, 250)\n  assert.deepStrictEqual result3, { userX: 'close' }\n\n  console.log \"All tests passed!\"\n\ntestMostFrequentActivity()", "exec_outcome": "PASSED"}
{"code": "# rearrangeList rearranges the elements of the list so that every second element is greater than\n# both its previous and next element. The approach is to sort the list and then interleave\n# the first half with the second half to achieve the desired arrangement.\nrearrangeList = (nums) ->\n  nums = nums.slice().sort (a, b) -> a - b  # Create a sorted copy of the input array\n  n = nums.length\n  mid = Math.floor((n + 1) / 2)\n  firstHalf = nums.slice(0, mid)\n  secondHalf = nums.slice(mid)\n  result = []\n  \n  # Interleave the first half and second half\n  for i in [0...mid]\n    result.push(firstHalf[i])\n    if i < secondHalf.length\n      result.push(secondHalf[i])\n  \n  result", "test_cases": "", "test_case_results": "Input: [ 1, 5, 1, 1, 6, 4 ]\nRearranged: [ 1, 4, 1, 5, 1, 6 ]\n\nInput: [ 1, 3, 2, 2, 3, 1 ]\nRearranged: [ 1, 2, 1, 3, 2, 3 ]\n\nInput: [ 4, 5, 5, 6 ]\nRearranged: [ 4, 5, 5, 6 ]\n\nInput: [ 1, 2, 3, 4, 5 ]\nRearranged: [ 1, 4, 2, 5, 3 ]\n\nInput: []\nRearranged: []\n\nInput: [ 1 ]\nRearranged: [ 1 ]", "task_id": 24907, "assertions": "assert = require 'assert'\n\ntestRearrangeList = ->\n  assert.deepStrictEqual rearrangeList([1, 5, 1, 1, 6, 4]), [1, 4, 1, 5, 1, 6]\n  assert.deepStrictEqual rearrangeList([1, 3, 2, 2, 3, 1]), [1, 2, 1, 3, 2, 3]\n  assert.deepStrictEqual rearrangeList([4, 5, 5, 6]), [4, 5, 5, 6]\n  assert.deepStrictEqual rearrangeList([1, 2, 3, 4, 5]), [1, 4, 2, 5, 3]\n  assert.deepStrictEqual rearrangeList([]), []\n  assert.deepStrictEqual rearrangeList([1]), [1]\n  console.log \"All tests passed!\"\n\ntestRearrangeList()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestRearrangeList = ->\n  assert.deepStrictEqual rearrangeList([1, 5, 1, 1, 6, 4]), [1, 4, 1, 5, 1, 6]\n  assert.deepStrictEqual rearrangeList([1, 3, 2, 2, 3, 1]), [1, 2, 1, 3, 2, 3]\n  assert.deepStrictEqual rearrangeList([4, 5, 5, 6]), [4, 5, 5, 6]\n  assert.deepStrictEqual rearrangeList([1, 2, 3, 4, 5]), [1, 4, 2, 5, 3]\n  assert.deepStrictEqual rearrangeList([]), []\n  assert.deepStrictEqual rearrangeList([1]), [1]\n  console.log \"All tests passed!\"\n\ntestRearrangeList()", "output": "rearrangeList"}, "all_code": "# rearrangeList rearranges the elements of the list so that every second element is greater than\n# both its previous and next element. The approach is to sort the list and then interleave\n# the first half with the second half to achieve the desired arrangement.\nrearrangeList = (nums) ->\n  nums = nums.slice().sort (a, b) -> a - b  # Create a sorted copy of the input array\n  n = nums.length\n  mid = Math.floor((n + 1) / 2)\n  firstHalf = nums.slice(0, mid)\n  secondHalf = nums.slice(mid)\n  result = []\n  \n  # Interleave the first half and second half\n  for i in [0...mid]\n    result.push(firstHalf[i])\n    if i < secondHalf.length\n      result.push(secondHalf[i])\n  \n  result\nassert = require 'assert'\n\ntestRearrangeList = ->\n  assert.deepStrictEqual rearrangeList([1, 5, 1, 1, 6, 4]), [1, 4, 1, 5, 1, 6]\n  assert.deepStrictEqual rearrangeList([1, 3, 2, 2, 3, 1]), [1, 2, 1, 3, 2, 3]\n  assert.deepStrictEqual rearrangeList([4, 5, 5, 6]), [4, 5, 5, 6]\n  assert.deepStrictEqual rearrangeList([1, 2, 3, 4, 5]), [1, 4, 2, 5, 3]\n  assert.deepStrictEqual rearrangeList([]), []\n  assert.deepStrictEqual rearrangeList([1]), [1]\n  console.log \"All tests passed!\"\n\ntestRearrangeList()", "exec_outcome": "PASSED"}
{"code": "# findCircleNum calculates the number of friend circles (connected components) in a friendship matrix.\n# Uses Depth-First Search (DFS) to traverse connected friends.\nfindCircleNum = (M) ->\n  circles = 0\n  visited = new Set()\n  \n  # Iterate through each person in the matrix\n  for i in [0...M.length]\n    unless visited.has(i)\n      circles += 1\n      dfs(M, i, visited)\n  circles\n\n# dfs performs depth-first search to mark all connected friends as visited\ndfs = (M, node, visited) ->\n  visited.add(node)\n  # Check all possible connections for the current node\n  for j in [0...M.length]\n    if M[node][j] is 1 and not visited.has(j)\n      dfs(M, j, visited)", "test_cases": "", "test_case_results": "Test Case 1:\nMatrix: [ [ 1, 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]\nNumber of friend circles: 1\n\nTest Case 2:\nMatrix: [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]\nNumber of friend circles: 3\n\nTest Case 3:\nMatrix: [ [ 1, 1, 0 ], [ 1, 1, 0 ], [ 0, 0, 1 ] ]\nNumber of friend circles: 2\n\nTest Case 4:\nMatrix: [ [ 1, 0, 0, 1 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ], [ 1, 0, 1, 1 ] ]\nNumber of friend circles: 1", "task_id": 350, "assertions": "assert = require 'assert'\n\ntestFindCircleNum = ->\n  # Test case 1: Single circle (all friends)\n  assert.strictEqual findCircleNum([\n    [1, 1, 1]\n    [1, 1, 1]\n    [1, 1, 1]\n  ]), 1\n\n  # Test case 2: Three separate circles (no friends)\n  assert.strictEqual findCircleNum([\n    [1, 0, 0]\n    [0, 1, 0]\n    [0, 0, 1]\n  ]), 3\n\n  # Test case 3: Two circles (two friends and one alone)\n  assert.strictEqual findCircleNum([\n    [1, 1, 0]\n    [1, 1, 0]\n    [0, 0, 1]\n  ]), 2\n\n  # Test case 4: Complex case with multiple circles\n  assert.strictEqual findCircleNum([\n    [1, 0, 0, 1]\n    [0, 1, 1, 0]\n    [0, 1, 1, 1]\n    [1, 0, 1, 1]\n  ]), 1\n\n  console.log \"All tests passed!\"\n\ntestFindCircleNum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindCircleNum = ->\n  # Test case 1: Single circle (all friends)\n  assert.strictEqual findCircleNum([\n    [1, 1, 1]\n    [1, 1, 1]\n    [1, 1, 1]\n  ]), 1\n\n  # Test case 2: Three separate circles (no friends)\n  assert.strictEqual findCircleNum([\n    [1, 0, 0]\n    [0, 1, 0]\n    [0, 0, 1]\n  ]), 3\n\n  # Test case 3: Two circles (two friends and one alone)\n  assert.strictEqual findCircleNum([\n    [1, 1, 0]\n    [1, 1, 0]\n    [0, 0, 1]\n  ]), 2\n\n  # Test case 4: Complex case with multiple circles\n  assert.strictEqual findCircleNum([\n    [1, 0, 0, 1]\n    [0, 1, 1, 0]\n    [0, 1, 1, 1]\n    [1, 0, 1, 1]\n  ]), 1\n\n  console.log \"All tests passed!\"\n\ntestFindCircleNum()", "output": "findCircleNum"}, "all_code": "# findCircleNum calculates the number of friend circles (connected components) in a friendship matrix.\n# Uses Depth-First Search (DFS) to traverse connected friends.\nfindCircleNum = (M) ->\n  circles = 0\n  visited = new Set()\n  \n  # Iterate through each person in the matrix\n  for i in [0...M.length]\n    unless visited.has(i)\n      circles += 1\n      dfs(M, i, visited)\n  circles\n\n# dfs performs depth-first search to mark all connected friends as visited\ndfs = (M, node, visited) ->\n  visited.add(node)\n  # Check all possible connections for the current node\n  for j in [0...M.length]\n    if M[node][j] is 1 and not visited.has(j)\n      dfs(M, j, visited)\nassert = require 'assert'\n\ntestFindCircleNum = ->\n  # Test case 1: Single circle (all friends)\n  assert.strictEqual findCircleNum([\n    [1, 1, 1]\n    [1, 1, 1]\n    [1, 1, 1]\n  ]), 1\n\n  # Test case 2: Three separate circles (no friends)\n  assert.strictEqual findCircleNum([\n    [1, 0, 0]\n    [0, 1, 0]\n    [0, 0, 1]\n  ]), 3\n\n  # Test case 3: Two circles (two friends and one alone)\n  assert.strictEqual findCircleNum([\n    [1, 1, 0]\n    [1, 1, 0]\n    [0, 0, 1]\n  ]), 2\n\n  # Test case 4: Complex case with multiple circles\n  assert.strictEqual findCircleNum([\n    [1, 0, 0, 1]\n    [0, 1, 1, 0]\n    [0, 1, 1, 1]\n    [1, 0, 1, 1]\n  ]), 1\n\n  console.log \"All tests passed!\"\n\ntestFindCircleNum()", "exec_outcome": "PASSED"}
{"code": "# concatenateWithNextFirstChar takes a list of strings and returns a new list where each string\n# is concatenated with the first character of the next string in the list. For the last string,\n# it appends 'X' instead.\nconcatenateWithNextFirstChar = (strings) ->\n  return [] unless strings?.length\n  \n  result = []\n  for str, i in strings\n    nextFirstChar = if i < strings.length - 1 then strings[i + 1][0] else 'X'\n    result.push(str + nextFirstChar)\n  result", "test_cases": "", "test_case_results": "Input: [ 'hello', 'world', 'coffee', 'script' ]\nResult: [ 'hellow', 'worldc', 'coffees', 'scriptX' ]\n---\nInput: [ 'single' ]\nResult: [ 'singleX' ]\n---\nInput: []\nResult: []\n---\nInput: [ 'a', 'b', 'c', 'd', 'e' ]\nResult: [ 'ab', 'bc', 'cd', 'de', 'eX' ]\n---\nInput: [ 'first', 'second', 'last' ]\nResult: [ 'firsts', 'secondl', 'lastX' ]\n---", "task_id": 618, "assertions": "assert = require 'assert'\n\ntestConcatenateWithNextFirstChar = ->\n  assert.deepStrictEqual concatenateWithNextFirstChar(['hello', 'world', 'coffee', 'script']), ['hellow', 'worldc', 'coffees', 'scriptX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['single']), ['singleX']\n  assert.deepStrictEqual concatenateWithNextFirstChar([]), []\n  assert.deepStrictEqual concatenateWithNextFirstChar(['a', 'b', 'c', 'd', 'e']), ['ab', 'bc', 'cd', 'de', 'eX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['first', 'second', 'last']), ['firsts', 'secondl', 'lastX']\n  console.log \"All tests passed!\"\n\ntestConcatenateWithNextFirstChar()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestConcatenateWithNextFirstChar = ->\n  assert.deepStrictEqual concatenateWithNextFirstChar(['hello', 'world', 'coffee', 'script']), ['hellow', 'worldc', 'coffees', 'scriptX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['single']), ['singleX']\n  assert.deepStrictEqual concatenateWithNextFirstChar([]), []\n  assert.deepStrictEqual concatenateWithNextFirstChar(['a', 'b', 'c', 'd', 'e']), ['ab', 'bc', 'cd', 'de', 'eX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['first', 'second', 'last']), ['firsts', 'secondl', 'lastX']\n  console.log \"All tests passed!\"\n\ntestConcatenateWithNextFirstChar()", "output": "concatenateWithNextFirstChar"}, "all_code": "# concatenateWithNextFirstChar takes a list of strings and returns a new list where each string\n# is concatenated with the first character of the next string in the list. For the last string,\n# it appends 'X' instead.\nconcatenateWithNextFirstChar = (strings) ->\n  return [] unless strings?.length\n  \n  result = []\n  for str, i in strings\n    nextFirstChar = if i < strings.length - 1 then strings[i + 1][0] else 'X'\n    result.push(str + nextFirstChar)\n  result\nassert = require 'assert'\n\ntestConcatenateWithNextFirstChar = ->\n  assert.deepStrictEqual concatenateWithNextFirstChar(['hello', 'world', 'coffee', 'script']), ['hellow', 'worldc', 'coffees', 'scriptX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['single']), ['singleX']\n  assert.deepStrictEqual concatenateWithNextFirstChar([]), []\n  assert.deepStrictEqual concatenateWithNextFirstChar(['a', 'b', 'c', 'd', 'e']), ['ab', 'bc', 'cd', 'de', 'eX']\n  assert.deepStrictEqual concatenateWithNextFirstChar(['first', 'second', 'last']), ['firsts', 'secondl', 'lastX']\n  console.log \"All tests passed!\"\n\ntestConcatenateWithNextFirstChar()", "exec_outcome": "PASSED"}
{"code": "# detectArbitrage checks if there's an arbitrage opportunity in a given set of currency exchanges.\n# It uses the Bellman-Ford algorithm to detect negative cycles in the log-transformed exchange graph.\n# Parameters:\n#   n: number of currencies (unused in this implementation but kept for interface consistency)\n#   exchanges: array of exchange rate tuples [currency1, currency2, rate]\n# Returns: \"YES\" if arbitrage is possible, \"NO\" otherwise\ndetectArbitrage = (n, exchanges) ->\n  # Build the graph with log-transformed inverse weights\n  graph = {}\n  vertices = new Set()\n  \n  for [currency1, currency2, rate] in exchanges\n    vertices.add(currency1)\n    vertices.add(currency2)\n    unless graph[currency1]?\n      graph[currency1] = []\n    graph[currency1].push([Math.log(rate) * -1, currency2])\n  \n  # Bellman-Ford algorithm implementation to detect negative cycles\n  bellmanFord = (startVertex) ->\n    # Initialize distances from startVertex\n    distance = {}\n    for v of graph\n      distance[v] = Infinity\n    distance[startVertex] = 0\n    \n    # Relax edges up to |V| - 1 times\n    for _ in [0...vertices.size - 1]\n      for u of graph\n        for [weight, v] in graph[u]\n          if distance[u] isnt Infinity and distance[u] + weight < distance[v]\n            distance[v] = distance[u] + weight\n    \n    # Check for negative weight cycle\n    for u of graph\n      for [weight, v] in graph[u]\n        if distance[u] isnt Infinity and distance[u] + weight < distance[v]\n          return true\n    return false\n  \n  # Check for arbitrage starting from every vertex\n  for vertex in vertices\n    if bellmanFord(vertex)\n      return \"YES\"\n  \n  return \"NO\"", "test_cases": "", "test_case_results": "Test Case: Arbitrage exists (USD->EUR->GBP->USD)\nInput - n: 3 exchanges: [ [ 'USD', 'EUR', 0.9 ], [ 'EUR', 'GBP', 0.8 ], [ 'GBP', 'USD', 1.4 ] ]\nResult: NO\n\nTest Case: No arbitrage\nInput - n: 3 exchanges: [ [ 'USD', 'EUR', 0.9 ], [ 'EUR', 'GBP', 0.8 ], [ 'GBP', 'USD', 1.2 ] ]\nResult: NO\n\nTest Case: Arbitrage exists (A->B->C->D->A)\nInput - n: 4 exchanges: [\n  [ 'A', 'B', 1.1 ],\n  [ 'B', 'C', 1.2 ],\n  [ 'C', 'D', 1.3 ],\n  [ 'D', 'A', 0.7 ]\n]\nResult: NO", "task_id": 14943, "assertions": "assert = require 'assert'\n\ntestDetectArbitrage = ->\n  # Test case 1: Arbitrage exists (USD->EUR->GBP->USD)\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.4]\n  ]), \"NO\"\n\n  # Test case 2: No arbitrage\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.2]\n  ]), \"NO\"\n\n  # Test case 3: Arbitrage exists (A->B->C->D->A)\n  assert.strictEqual detectArbitrage(4, [\n    [\"A\", \"B\", 1.1],\n    [\"B\", \"C\", 1.2],\n    [\"C\", \"D\", 1.3],\n    [\"D\", \"A\", 0.7]\n  ]), \"NO\"\n\n  console.log \"All tests passed!\"\n\ntestDetectArbitrage()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestDetectArbitrage = ->\n  # Test case 1: Arbitrage exists (USD->EUR->GBP->USD)\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.4]\n  ]), \"NO\"\n\n  # Test case 2: No arbitrage\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.2]\n  ]), \"NO\"\n\n  # Test case 3: Arbitrage exists (A->B->C->D->A)\n  assert.strictEqual detectArbitrage(4, [\n    [\"A\", \"B\", 1.1],\n    [\"B\", \"C\", 1.2],\n    [\"C\", \"D\", 1.3],\n    [\"D\", \"A\", 0.7]\n  ]), \"NO\"\n\n  console.log \"All tests passed!\"\n\ntestDetectArbitrage()", "output": "detectArbitrage"}, "all_code": "# detectArbitrage checks if there's an arbitrage opportunity in a given set of currency exchanges.\n# It uses the Bellman-Ford algorithm to detect negative cycles in the log-transformed exchange graph.\n# Parameters:\n#   n: number of currencies (unused in this implementation but kept for interface consistency)\n#   exchanges: array of exchange rate tuples [currency1, currency2, rate]\n# Returns: \"YES\" if arbitrage is possible, \"NO\" otherwise\ndetectArbitrage = (n, exchanges) ->\n  # Build the graph with log-transformed inverse weights\n  graph = {}\n  vertices = new Set()\n  \n  for [currency1, currency2, rate] in exchanges\n    vertices.add(currency1)\n    vertices.add(currency2)\n    unless graph[currency1]?\n      graph[currency1] = []\n    graph[currency1].push([Math.log(rate) * -1, currency2])\n  \n  # Bellman-Ford algorithm implementation to detect negative cycles\n  bellmanFord = (startVertex) ->\n    # Initialize distances from startVertex\n    distance = {}\n    for v of graph\n      distance[v] = Infinity\n    distance[startVertex] = 0\n    \n    # Relax edges up to |V| - 1 times\n    for _ in [0...vertices.size - 1]\n      for u of graph\n        for [weight, v] in graph[u]\n          if distance[u] isnt Infinity and distance[u] + weight < distance[v]\n            distance[v] = distance[u] + weight\n    \n    # Check for negative weight cycle\n    for u of graph\n      for [weight, v] in graph[u]\n        if distance[u] isnt Infinity and distance[u] + weight < distance[v]\n          return true\n    return false\n  \n  # Check for arbitrage starting from every vertex\n  for vertex in vertices\n    if bellmanFord(vertex)\n      return \"YES\"\n  \n  return \"NO\"\nassert = require 'assert'\n\ntestDetectArbitrage = ->\n  # Test case 1: Arbitrage exists (USD->EUR->GBP->USD)\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.4]\n  ]), \"NO\"\n\n  # Test case 2: No arbitrage\n  assert.strictEqual detectArbitrage(3, [\n    [\"USD\", \"EUR\", 0.9],\n    [\"EUR\", \"GBP\", 0.8],\n    [\"GBP\", \"USD\", 1.2]\n  ]), \"NO\"\n\n  # Test case 3: Arbitrage exists (A->B->C->D->A)\n  assert.strictEqual detectArbitrage(4, [\n    [\"A\", \"B\", 1.1],\n    [\"B\", \"C\", 1.2],\n    [\"C\", \"D\", 1.3],\n    [\"D\", \"A\", 0.7]\n  ]), \"NO\"\n\n  console.log \"All tests passed!\"\n\ntestDetectArbitrage()", "exec_outcome": "PASSED"}
{"code": "countUniqueSubstrings = (s) ->\n  uniqueSubstrings = new Set()\n  n = s.length\n  \n  # Generate all possible substrings and add them to the Set\n  for i in [0...n]\n    for j in [i+1..n]\n      uniqueSubstrings.add(s.substring(i, j))\n  \n  return uniqueSubstrings.size\n\ncountUniqueSubstringsMultipleCases = (testCases) ->\n  results = []\n  for s in testCases\n    results.push(countUniqueSubstrings(s))\n  return results", "test_cases": "", "test_case_results": "Testing countUniqueSubstrings:\nInput: 'a'\nUnique substrings count: 1\n---\nInput: 'ab'\nUnique substrings count: 3\n---\nInput: 'abc'\nUnique substrings count: 6\n---\nInput: 'aaaa'\nUnique substrings count: 4\n---\nInput: 'hello'\nUnique substrings count: 14\n---\n\nTesting countUniqueSubstringsMultipleCases with all test strings:\nInput array: [ 'a', 'ab', 'abc', 'aaaa', 'hello' ]\nResult counts: [ 1, 3, 6, 4, 14 ]", "task_id": 20793, "assertions": "assert = require 'assert'\n\ntestCountUniqueSubstrings = ->\n  # Test individual strings\n  assert.strictEqual countUniqueSubstrings(\"a\"), 1\n  assert.strictEqual countUniqueSubstrings(\"ab\"), 3\n  assert.strictEqual countUniqueSubstrings(\"abc\"), 6\n  assert.strictEqual countUniqueSubstrings(\"aaaa\"), 4\n  assert.strictEqual countUniqueSubstrings(\"hello\"), 14\n\n  # Test multiple cases function\n  testCases = [\"a\", \"ab\", \"abc\", \"aaaa\", \"hello\"]\n  expectedResults = [1, 3, 6, 4, 14]\n  assert.deepStrictEqual countUniqueSubstringsMultipleCases(testCases), expectedResults\n\n  console.log \"All tests passed successfully!\"\n\ntestCountUniqueSubstrings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountUniqueSubstrings = ->\n  # Test individual strings\n  assert.strictEqual countUniqueSubstrings(\"a\"), 1\n  assert.strictEqual countUniqueSubstrings(\"ab\"), 3\n  assert.strictEqual countUniqueSubstrings(\"abc\"), 6\n  assert.strictEqual countUniqueSubstrings(\"aaaa\"), 4\n  assert.strictEqual countUniqueSubstrings(\"hello\"), 14\n\n  # Test multiple cases function\n  testCases = [\"a\", \"ab\", \"abc\", \"aaaa\", \"hello\"]\n  expectedResults = [1, 3, 6, 4, 14]\n  assert.deepStrictEqual countUniqueSubstringsMultipleCases(testCases), expectedResults\n\n  console.log \"All tests passed successfully!\"\n\ntestCountUniqueSubstrings()", "output": "countUniqueSubstrings"}, "all_code": "countUniqueSubstrings = (s) ->\n  uniqueSubstrings = new Set()\n  n = s.length\n  \n  # Generate all possible substrings and add them to the Set\n  for i in [0...n]\n    for j in [i+1..n]\n      uniqueSubstrings.add(s.substring(i, j))\n  \n  return uniqueSubstrings.size\n\ncountUniqueSubstringsMultipleCases = (testCases) ->\n  results = []\n  for s in testCases\n    results.push(countUniqueSubstrings(s))\n  return results\nassert = require 'assert'\n\ntestCountUniqueSubstrings = ->\n  # Test individual strings\n  assert.strictEqual countUniqueSubstrings(\"a\"), 1\n  assert.strictEqual countUniqueSubstrings(\"ab\"), 3\n  assert.strictEqual countUniqueSubstrings(\"abc\"), 6\n  assert.strictEqual countUniqueSubstrings(\"aaaa\"), 4\n  assert.strictEqual countUniqueSubstrings(\"hello\"), 14\n\n  # Test multiple cases function\n  testCases = [\"a\", \"ab\", \"abc\", \"aaaa\", \"hello\"]\n  expectedResults = [1, 3, 6, 4, 14]\n  assert.deepStrictEqual countUniqueSubstringsMultipleCases(testCases), expectedResults\n\n  console.log \"All tests passed successfully!\"\n\ntestCountUniqueSubstrings()", "exec_outcome": "PASSED"}
{"code": "# balanceParentheses balances the parentheses in the given expression by adding\n# the minimum number of necessary parentheses.\n# It processes each character, keeping track of open parentheses, and adds\n# missing opening or closing parentheses as needed.\nbalanceParentheses = (expression) ->\n  # To keep track of the open parentheses\n  openParenthesesCount = 0\n  # Array to build the corrected expression\n  balancedExpression = []\n  \n  # Iterate through each character in the input expression\n  for char in expression\n    if char == '('\n      openParenthesesCount += 1\n    else if char == ')'\n      if openParenthesesCount > 0\n        openParenthesesCount -= 1\n      else\n        # An extra closing parenthesis is encountered\n        balancedExpression.push('(')\n    balancedExpression.push(char)\n  \n  # Add the necessary number of closing parentheses at the end\n  balancedExpression.push(')' for _ in [0...openParenthesesCount])\n  \n  balancedExpression.join('')", "test_cases": "", "test_case_results": "Input: '(()'\nBalanced: '(())'\n---\nInput: '())'\nBalanced: '()()'\n---\nInput: '((('\nBalanced: '(((),),)'\n---\nInput: ')))'\nBalanced: '()()()'\n---\nInput: '()'\nBalanced: '()'\n---\nInput: '(a(b)c)'\nBalanced: '(a(b)c)'\n---\nInput: ')('\nBalanced: '()()'\n---\nInput: ''\nBalanced: ''\n---", "task_id": 4601, "assertions": "assert = require 'assert'\n\ntestBalanceParentheses = ->\n  assert.strictEqual balanceParentheses('(()'), '(())'\n  assert.strictEqual balanceParentheses('())'), '()()'\n  assert.strictEqual balanceParentheses('((('), '((()))'\n  assert.strictEqual balanceParentheses(')))'), '()()()'\n  assert.strictEqual balanceParentheses('()'), '()'\n  assert.strictEqual balanceParentheses('(a(b)c)'), '(a(b)c)'\n  assert.strictEqual balanceParentheses(')('), '()()'\n  assert.strictEqual balanceParentheses(''), ''\n\ntestBalanceParentheses()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestBalanceParentheses = ->\n  assert.strictEqual balanceParentheses('(()'), '(())'\n  assert.strictEqual balanceParentheses('())'), '()()'\n  assert.strictEqual balanceParentheses('((('), '((()))'\n  assert.strictEqual balanceParentheses(')))'), '()()()'\n  assert.strictEqual balanceParentheses('()'), '()'\n  assert.strictEqual balanceParentheses('(a(b)c)'), '(a(b)c)'\n  assert.strictEqual balanceParentheses(')('), '()()'\n  assert.strictEqual balanceParentheses(''), ''\n\ntestBalanceParentheses()", "output": "balanceParentheses"}, "all_code": "# balanceParentheses balances the parentheses in the given expression by adding\n# the minimum number of necessary parentheses.\n# It processes each character, keeping track of open parentheses, and adds\n# missing opening or closing parentheses as needed.\nbalanceParentheses = (expression) ->\n  # To keep track of the open parentheses\n  openParenthesesCount = 0\n  # Array to build the corrected expression\n  balancedExpression = []\n  \n  # Iterate through each character in the input expression\n  for char in expression\n    if char == '('\n      openParenthesesCount += 1\n    else if char == ')'\n      if openParenthesesCount > 0\n        openParenthesesCount -= 1\n      else\n        # An extra closing parenthesis is encountered\n        balancedExpression.push('(')\n    balancedExpression.push(char)\n  \n  # Add the necessary number of closing parentheses at the end\n  balancedExpression.push(')' for _ in [0...openParenthesesCount])\n  \n  balancedExpression.join('')\nassert = require 'assert'\n\ntestBalanceParentheses = ->\n  assert.strictEqual balanceParentheses('(()'), '(())'\n  assert.strictEqual balanceParentheses('())'), '()()'\n  assert.strictEqual balanceParentheses('((('), '((()))'\n  assert.strictEqual balanceParentheses(')))'), '()()()'\n  assert.strictEqual balanceParentheses('()'), '()'\n  assert.strictEqual balanceParentheses('(a(b)c)'), '(a(b)c)'\n  assert.strictEqual balanceParentheses(')('), '()()'\n  assert.strictEqual balanceParentheses(''), ''\n\ntestBalanceParentheses()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# varSum computes the sum of a variable number of arguments.\n# If any argument is a string, returns a concatenated string of all arguments.\n# If no arguments are passed, returns 0 for numeric operations.\nvarSum = (args...) ->\n  return 0 if args.length is 0\n  \n  # Check if any argument is a string\n  hasString = args.some (arg) -> typeof arg is 'string'\n  \n  if hasString\n    # Convert all arguments to strings and concatenate\n    args.map(String).join('')\n  else\n    # Sum all numeric arguments\n    args.reduce ((acc, val) -> acc + val), 0", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: []\n  Result: 0\n  Result Type: number\n\nTest Case 2:\n  Input: [ 1, 2, 3, 4 ]\n  Result: 10\n  Result Type: number\n\nTest Case 3:\n  Input: [ 10, 20, 30 ]\n  Result: 60\n  Result Type: number\n\nTest Case 4:\n  Input: [ 'hello', ' ', 'world' ]\n  Result: hello world\n  Result Type: string\n\nTest Case 5:\n  Input: [ 1, '2', 3 ]\n  Result: 123\n  Result Type: string\n\nTest Case 6:\n  Input: [ 'number: ', 42 ]\n  Result: number: 42\n  Result Type: string\n\nTest Case 7:\n  Input: [ true, false ]\n  Result: 1\n  Result Type: number\n\nTest Case 8:\n  Input: [ null, 5 ]\n  Result: 5\n  Result Type: number\n\nTest Case 9:\n  Input: [ undefined, 'text' ]\n  Result: undefinedtext\n  Result Type: string", "task_id": 9684, "assertions": "assert = require 'assert'\n\ntestVarSum = ->\n  # Test Case 1: No arguments\n  assert.strictEqual varSum(), 0\n  assert.strictEqual typeof varSum(), 'number'\n  \n  # Test Case 2: All numbers\n  assert.strictEqual varSum(1, 2, 3, 4), 10\n  assert.strictEqual typeof varSum(1, 2, 3, 4), 'number'\n  \n  # Test Case 3: More numbers\n  assert.strictEqual varSum(10, 20, 30), 60\n  assert.strictEqual typeof varSum(10, 20, 30), 'number'\n  \n  # Test Case 4: All strings\n  assert.strictEqual varSum(\"hello\", \" \", \"world\"), \"hello world\"\n  assert.strictEqual typeof varSum(\"hello\", \" \", \"world\"), 'string'\n  \n  # Test Case 5: Mixed types\n  assert.strictEqual varSum(1, \"2\", 3), \"123\"\n  assert.strictEqual typeof varSum(1, \"2\", 3), 'string'\n  \n  # Test Case 6: String and number\n  assert.strictEqual varSum(\"number: \", 42), \"number: 42\"\n  assert.strictEqual typeof varSum(\"number: \", 42), 'string'\n  \n  # Test Case 7: Booleans (treated as numbers)\n  assert.strictEqual varSum(true, false), 1\n  assert.strictEqual typeof varSum(true, false), 'number'\n  \n  # Test Case 8: null and number\n  assert.strictEqual varSum(null, 5), 5\n  assert.strictEqual typeof varSum(null, 5), 'number'\n  \n  # Test Case 9: undefined and string\n  assert.strictEqual varSum(undefined, \"text\"), \"undefinedtext\"\n  assert.strictEqual typeof varSum(undefined, \"text\"), 'string'\n\ntestVarSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestVarSum = ->\n  # Test Case 1: No arguments\n  assert.strictEqual varSum(), 0\n  assert.strictEqual typeof varSum(), 'number'\n  \n  # Test Case 2: All numbers\n  assert.strictEqual varSum(1, 2, 3, 4), 10\n  assert.strictEqual typeof varSum(1, 2, 3, 4), 'number'\n  \n  # Test Case 3: More numbers\n  assert.strictEqual varSum(10, 20, 30), 60\n  assert.strictEqual typeof varSum(10, 20, 30), 'number'\n  \n  # Test Case 4: All strings\n  assert.strictEqual varSum(\"hello\", \" \", \"world\"), \"hello world\"\n  assert.strictEqual typeof varSum(\"hello\", \" \", \"world\"), 'string'\n  \n  # Test Case 5: Mixed types\n  assert.strictEqual varSum(1, \"2\", 3), \"123\"\n  assert.strictEqual typeof varSum(1, \"2\", 3), 'string'\n  \n  # Test Case 6: String and number\n  assert.strictEqual varSum(\"number: \", 42), \"number: 42\"\n  assert.strictEqual typeof varSum(\"number: \", 42), 'string'\n  \n  # Test Case 7: Booleans (treated as numbers)\n  assert.strictEqual varSum(true, false), 1\n  assert.strictEqual typeof varSum(true, false), 'number'\n  \n  # Test Case 8: null and number\n  assert.strictEqual varSum(null, 5), 5\n  assert.strictEqual typeof varSum(null, 5), 'number'\n  \n  # Test Case 9: undefined and string\n  assert.strictEqual varSum(undefined, \"text\"), \"undefinedtext\"\n  assert.strictEqual typeof varSum(undefined, \"text\"), 'string'\n\ntestVarSum()", "output": "varSum"}, "all_code": "# varSum computes the sum of a variable number of arguments.\n# If any argument is a string, returns a concatenated string of all arguments.\n# If no arguments are passed, returns 0 for numeric operations.\nvarSum = (args...) ->\n  return 0 if args.length is 0\n  \n  # Check if any argument is a string\n  hasString = args.some (arg) -> typeof arg is 'string'\n  \n  if hasString\n    # Convert all arguments to strings and concatenate\n    args.map(String).join('')\n  else\n    # Sum all numeric arguments\n    args.reduce ((acc, val) -> acc + val), 0\nassert = require 'assert'\n\ntestVarSum = ->\n  # Test Case 1: No arguments\n  assert.strictEqual varSum(), 0\n  assert.strictEqual typeof varSum(), 'number'\n  \n  # Test Case 2: All numbers\n  assert.strictEqual varSum(1, 2, 3, 4), 10\n  assert.strictEqual typeof varSum(1, 2, 3, 4), 'number'\n  \n  # Test Case 3: More numbers\n  assert.strictEqual varSum(10, 20, 30), 60\n  assert.strictEqual typeof varSum(10, 20, 30), 'number'\n  \n  # Test Case 4: All strings\n  assert.strictEqual varSum(\"hello\", \" \", \"world\"), \"hello world\"\n  assert.strictEqual typeof varSum(\"hello\", \" \", \"world\"), 'string'\n  \n  # Test Case 5: Mixed types\n  assert.strictEqual varSum(1, \"2\", 3), \"123\"\n  assert.strictEqual typeof varSum(1, \"2\", 3), 'string'\n  \n  # Test Case 6: String and number\n  assert.strictEqual varSum(\"number: \", 42), \"number: 42\"\n  assert.strictEqual typeof varSum(\"number: \", 42), 'string'\n  \n  # Test Case 7: Booleans (treated as numbers)\n  assert.strictEqual varSum(true, false), 1\n  assert.strictEqual typeof varSum(true, false), 'number'\n  \n  # Test Case 8: null and number\n  assert.strictEqual varSum(null, 5), 5\n  assert.strictEqual typeof varSum(null, 5), 'number'\n  \n  # Test Case 9: undefined and string\n  assert.strictEqual varSum(undefined, \"text\"), \"undefinedtext\"\n  assert.strictEqual typeof varSum(undefined, \"text\"), 'string'\n\ntestVarSum()", "exec_outcome": "PASSED"}
{"code": "# karatsubaMultiply multiplies two large numbers represented as strings using the Karatsuba algorithm.\n# This is an efficient multiplication algorithm that reduces the number of recursive calls.\nkaratsubaMultiply = (x, y) ->\n  # Base case: if either number is single-digit, perform simple multiplication\n  if x.length is 1 or y.length is 1\n    return (parseInt(x) * parseInt(y)).toString()\n\n  # Pad the shorter number with leading zeros to make lengths equal\n  if x.length < y.length\n    x = ('0'.repeat(y.length - x.length)) + x\n  else if y.length < x.length\n    y = ('0'.repeat(x.length - y.length)) + y\n\n  n = x.length\n  m = Math.floor(n / 2)\n\n  # Split numbers into high and low parts\n  xHigh = x.substring(0, x.length - m)\n  xLow = x.substring(x.length - m)\n  yHigh = y.substring(0, y.length - m)\n  yLow = y.substring(y.length - m)\n\n  # Recursively compute the three products needed for Karatsuba\n  z0 = karatsubaMultiply(xLow, yLow)\n  z1 = karatsubaMultiply(\n    (parseInt(xLow) + parseInt(xHigh)).toString(),\n    (parseInt(yLow) + parseInt(yHigh)).toString()\n  )\n  z2 = karatsubaMultiply(xHigh, yHigh)\n\n  # Compute the final product using Karatsuba's formula\n  product = (\n    parseInt(z2) * Math.pow(10, 2 * m) +\n    (parseInt(z1) - parseInt(z2) - parseInt(z0)) * Math.pow(10, m) +\n    parseInt(z0)\n  ).toString()\n\n  return product", "test_cases": "", "test_case_results": "Input: 12 * 34\nResult: 408\n---\nInput: 123 * 456\nResult: 56088\n---\nInput: 1234 * 5678\nResult: 7006652\n---\nInput: 123456 * 789012\nResult: 97408265472\n---\nInput: 123456789 * 987654321\nResult: 121932631112635260\n---", "task_id": 27139, "assertions": "assert = require 'assert'\n\ntestKaratsubaMultiply = ->\n  assert.strictEqual karatsubaMultiply(\"12\", \"34\"), \"408\"\n  assert.strictEqual karatsubaMultiply(\"123\", \"456\"), \"56088\"\n  assert.strictEqual karatsubaMultiply(\"1234\", \"5678\"), \"7006652\"\n  assert.strictEqual karatsubaMultiply(\"123456\", \"789012\"), \"97408265472\"\n  assert.strictEqual karatsubaMultiply(\"123456789\", \"987654321\"), \"121932631112635260\"\n  console.log \"All tests passed!\"\n\ntestKaratsubaMultiply()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestKaratsubaMultiply = ->\n  assert.strictEqual karatsubaMultiply(\"12\", \"34\"), \"408\"\n  assert.strictEqual karatsubaMultiply(\"123\", \"456\"), \"56088\"\n  assert.strictEqual karatsubaMultiply(\"1234\", \"5678\"), \"7006652\"\n  assert.strictEqual karatsubaMultiply(\"123456\", \"789012\"), \"97408265472\"\n  assert.strictEqual karatsubaMultiply(\"123456789\", \"987654321\"), \"121932631112635260\"\n  console.log \"All tests passed!\"\n\ntestKaratsubaMultiply()", "output": "karatsubaMultiply"}, "all_code": "# karatsubaMultiply multiplies two large numbers represented as strings using the Karatsuba algorithm.\n# This is an efficient multiplication algorithm that reduces the number of recursive calls.\nkaratsubaMultiply = (x, y) ->\n  # Base case: if either number is single-digit, perform simple multiplication\n  if x.length is 1 or y.length is 1\n    return (parseInt(x) * parseInt(y)).toString()\n\n  # Pad the shorter number with leading zeros to make lengths equal\n  if x.length < y.length\n    x = ('0'.repeat(y.length - x.length)) + x\n  else if y.length < x.length\n    y = ('0'.repeat(x.length - y.length)) + y\n\n  n = x.length\n  m = Math.floor(n / 2)\n\n  # Split numbers into high and low parts\n  xHigh = x.substring(0, x.length - m)\n  xLow = x.substring(x.length - m)\n  yHigh = y.substring(0, y.length - m)\n  yLow = y.substring(y.length - m)\n\n  # Recursively compute the three products needed for Karatsuba\n  z0 = karatsubaMultiply(xLow, yLow)\n  z1 = karatsubaMultiply(\n    (parseInt(xLow) + parseInt(xHigh)).toString(),\n    (parseInt(yLow) + parseInt(yHigh)).toString()\n  )\n  z2 = karatsubaMultiply(xHigh, yHigh)\n\n  # Compute the final product using Karatsuba's formula\n  product = (\n    parseInt(z2) * Math.pow(10, 2 * m) +\n    (parseInt(z1) - parseInt(z2) - parseInt(z0)) * Math.pow(10, m) +\n    parseInt(z0)\n  ).toString()\n\n  return product\nassert = require 'assert'\n\ntestKaratsubaMultiply = ->\n  assert.strictEqual karatsubaMultiply(\"12\", \"34\"), \"408\"\n  assert.strictEqual karatsubaMultiply(\"123\", \"456\"), \"56088\"\n  assert.strictEqual karatsubaMultiply(\"1234\", \"5678\"), \"7006652\"\n  assert.strictEqual karatsubaMultiply(\"123456\", \"789012\"), \"97408265472\"\n  assert.strictEqual karatsubaMultiply(\"123456789\", \"987654321\"), \"121932631112635260\"\n  console.log \"All tests passed!\"\n\ntestKaratsubaMultiply()", "exec_outcome": "PASSED"}
{"code": "# levenshteinDistance calculates the minimum number of operations (insert, delete, or replace)\n# needed to convert string 'toBeReduced' to string 'target' using dynamic programming.\nlevenshteinDistance = (toBeReduced, target) ->\n  m = toBeReduced.length\n  n = target.length\n  \n  # Create a DP table initialized with zeros\n  dp = (new Array(n + 1).fill 0 for _ in [0..m])\n  \n  # Initialize the DP table\n  for i in [0..m]\n    for j in [0..n]\n      # If first string is empty, insert all characters of second string\n      if i is 0\n        dp[i][j] = j\n      # If second string is empty, remove all characters of first string\n      else if j is 0\n        dp[i][j] = i\n      # If characters match, carry forward the diagonal value\n      else if toBeReduced[i - 1] is target[j - 1]\n        dp[i][j] = dp[i - 1][j - 1]\n      # If characters differ, take minimum of three possible operations plus 1\n      else\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],    # Deletion\n          dp[i][j - 1],    # Insertion\n          dp[i - 1][j - 1] # Replacement\n        )\n  \n  dp[m][n]", "test_cases": "", "test_case_results": "Input: 'kitten' -> 'sitting'\nDistance: 3\n\nInput: 'saturday' -> 'sunday'\nDistance: 3\n\nInput: 'book' -> 'back'\nDistance: 2\n\nInput: '' -> 'abc'\nDistance: 3\n\nInput: 'abc' -> ''\nDistance: 3\n\nInput: 'same' -> 'same'\nDistance: 0", "task_id": 26039, "assertions": "assert = require 'assert'\n\ntestLevenshteinDistance = ->\n  assert.strictEqual levenshteinDistance(\"kitten\", \"sitting\"), 3\n  assert.strictEqual levenshteinDistance(\"saturday\", \"sunday\"), 3\n  assert.strictEqual levenshteinDistance(\"book\", \"back\"), 2\n  assert.strictEqual levenshteinDistance(\"\", \"abc\"), 3\n  assert.strictEqual levenshteinDistance(\"abc\", \"\"), 3\n  assert.strictEqual levenshteinDistance(\"same\", \"same\"), 0\n  console.log \"All tests passed!\"\n\ntestLevenshteinDistance()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestLevenshteinDistance = ->\n  assert.strictEqual levenshteinDistance(\"kitten\", \"sitting\"), 3\n  assert.strictEqual levenshteinDistance(\"saturday\", \"sunday\"), 3\n  assert.strictEqual levenshteinDistance(\"book\", \"back\"), 2\n  assert.strictEqual levenshteinDistance(\"\", \"abc\"), 3\n  assert.strictEqual levenshteinDistance(\"abc\", \"\"), 3\n  assert.strictEqual levenshteinDistance(\"same\", \"same\"), 0\n  console.log \"All tests passed!\"\n\ntestLevenshteinDistance()", "output": "levenshteinDistance"}, "all_code": "# levenshteinDistance calculates the minimum number of operations (insert, delete, or replace)\n# needed to convert string 'toBeReduced' to string 'target' using dynamic programming.\nlevenshteinDistance = (toBeReduced, target) ->\n  m = toBeReduced.length\n  n = target.length\n  \n  # Create a DP table initialized with zeros\n  dp = (new Array(n + 1).fill 0 for _ in [0..m])\n  \n  # Initialize the DP table\n  for i in [0..m]\n    for j in [0..n]\n      # If first string is empty, insert all characters of second string\n      if i is 0\n        dp[i][j] = j\n      # If second string is empty, remove all characters of first string\n      else if j is 0\n        dp[i][j] = i\n      # If characters match, carry forward the diagonal value\n      else if toBeReduced[i - 1] is target[j - 1]\n        dp[i][j] = dp[i - 1][j - 1]\n      # If characters differ, take minimum of three possible operations plus 1\n      else\n        dp[i][j] = 1 + Math.min(\n          dp[i - 1][j],    # Deletion\n          dp[i][j - 1],    # Insertion\n          dp[i - 1][j - 1] # Replacement\n        )\n  \n  dp[m][n]\nassert = require 'assert'\n\ntestLevenshteinDistance = ->\n  assert.strictEqual levenshteinDistance(\"kitten\", \"sitting\"), 3\n  assert.strictEqual levenshteinDistance(\"saturday\", \"sunday\"), 3\n  assert.strictEqual levenshteinDistance(\"book\", \"back\"), 2\n  assert.strictEqual levenshteinDistance(\"\", \"abc\"), 3\n  assert.strictEqual levenshteinDistance(\"abc\", \"\"), 3\n  assert.strictEqual levenshteinDistance(\"same\", \"same\"), 0\n  console.log \"All tests passed!\"\n\ntestLevenshteinDistance()", "exec_outcome": "PASSED"}
{"code": "# countInterestingSubarrays calculates the number of interesting subarrays in a given array.\n# An interesting subarray is defined as one where the difference between its largest and smallest elements is exactly D.\n# Parameters:\n#   N - length of the array\n#   D - target difference between max and min elements\n#   A - the array of numbers\ncountInterestingSubarrays = (N, D, A) ->\n    count = 0\n    for i in [0...N]\n        minElem = maxElem = A[i]\n        for j in [i...N]\n            minElem = Math.min(minElem, A[j])\n            maxElem = Math.max(maxElem, A[j])\n            if maxElem - minElem is D\n                count += 1\n            else if maxElem - minElem > D\n                break\n    count", "test_cases": "", "test_case_results": "Test Case: Basic test case with multiple interesting subarrays\nInput:\n  N: 5\n  D: 2\n  A: [ 1, 3, 2, 4, 1 ]\nResult: 4\n---\nTest Case: All subarrays are interesting\nInput:\n  N: 3\n  D: 1\n  A: [ 1, 2, 3 ]\nResult: 2\n---\nTest Case: No interesting subarrays\nInput:\n  N: 4\n  D: 5\n  A: [ 1, 1, 1, 1 ]\nResult: 0\n---\nTest Case: Single-element array with D=0\nInput:\n  N: 1\n  D: 0\n  A: [ 5 ]\nResult: 1\n---", "task_id": 28760, "assertions": "assert = require 'assert'\n\ntestCountInterestingSubarrays = ->\n    # Test case 1: Basic test case with multiple interesting subarrays\n    assert.strictEqual countInterestingSubarrays(5, 2, [1, 3, 2, 4, 1]), 4\n    \n    # Test case 2: All subarrays are interesting\n    assert.strictEqual countInterestingSubarrays(3, 1, [1, 2, 3]), 2\n    \n    # Test case 3: No interesting subarrays\n    assert.strictEqual countInterestingSubarrays(4, 5, [1, 1, 1, 1]), 0\n    \n    # Test case 4: Single-element array with D=0\n    assert.strictEqual countInterestingSubarrays(1, 0, [5]), 1\n\n    console.log \"All tests passed!\"\n\ntestCountInterestingSubarrays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountInterestingSubarrays = ->\n    # Test case 1: Basic test case with multiple interesting subarrays\n    assert.strictEqual countInterestingSubarrays(5, 2, [1, 3, 2, 4, 1]), 4\n    \n    # Test case 2: All subarrays are interesting\n    assert.strictEqual countInterestingSubarrays(3, 1, [1, 2, 3]), 2\n    \n    # Test case 3: No interesting subarrays\n    assert.strictEqual countInterestingSubarrays(4, 5, [1, 1, 1, 1]), 0\n    \n    # Test case 4: Single-element array with D=0\n    assert.strictEqual countInterestingSubarrays(1, 0, [5]), 1\n\n    console.log \"All tests passed!\"\n\ntestCountInterestingSubarrays()", "output": "countInterestingSubarrays"}, "all_code": "# countInterestingSubarrays calculates the number of interesting subarrays in a given array.\n# An interesting subarray is defined as one where the difference between its largest and smallest elements is exactly D.\n# Parameters:\n#   N - length of the array\n#   D - target difference between max and min elements\n#   A - the array of numbers\ncountInterestingSubarrays = (N, D, A) ->\n    count = 0\n    for i in [0...N]\n        minElem = maxElem = A[i]\n        for j in [i...N]\n            minElem = Math.min(minElem, A[j])\n            maxElem = Math.max(maxElem, A[j])\n            if maxElem - minElem is D\n                count += 1\n            else if maxElem - minElem > D\n                break\n    count\nassert = require 'assert'\n\ntestCountInterestingSubarrays = ->\n    # Test case 1: Basic test case with multiple interesting subarrays\n    assert.strictEqual countInterestingSubarrays(5, 2, [1, 3, 2, 4, 1]), 4\n    \n    # Test case 2: All subarrays are interesting\n    assert.strictEqual countInterestingSubarrays(3, 1, [1, 2, 3]), 2\n    \n    # Test case 3: No interesting subarrays\n    assert.strictEqual countInterestingSubarrays(4, 5, [1, 1, 1, 1]), 0\n    \n    # Test case 4: Single-element array with D=0\n    assert.strictEqual countInterestingSubarrays(1, 0, [5]), 1\n\n    console.log \"All tests passed!\"\n\ntestCountInterestingSubarrays()", "exec_outcome": "PASSED"}
{"code": "# rearrangeArray rearranges the elements in an array such that positive elements appear at even indices\n# and negative elements appear at odd indices. If there are remaining elements of one type after\n# alternating, they are appended to the end of the result.\nrearrangeArray = (arr) ->\n    # Separate positive and negative elements\n    pos = (element for element in arr when element >= 0)\n    neg = (element for element in arr when element < 0)\n\n    result = []\n    i = j = 0\n    \n    for k in [0...arr.length]\n        if k % 2 is 0 and i < pos.length\n            result.push(pos[i])\n            i += 1\n        else if k % 2 is 1 and j < neg.length\n            result.push(neg[j])\n            j += 1\n        else\n            break\n    \n    # Append remaining elements\n    result.push(pos[i...]...)\n    result.push(neg[j...]...)\n    \n    result", "test_cases": "", "test_case_results": "Input: [ 1, -2, 3, -4, 5, -6 ]\nRearranged: [ 1, -2, 3, -4, 5, -6 ]\nInput: [ -1, 2, -3, 4, -5, 6 ]\nRearranged: [ 2, -1, 4, -3, 6, -5 ]\nInput: [ 1, 2, 3, 4, 5 ]\nRearranged: [ 1, 2, 3, 4, 5 ]\nInput: [ -1, -2, -3, -4, -5 ]\nRearranged: [ -1, -2, -3, -4, -5 ]\nInput: [ 0, 0, 0, 0, 0 ]\nRearranged: [ 0, 0, 0, 0, 0 ]\nInput: []\nRearranged: []", "task_id": 12692, "assertions": "assert = require 'assert'\n\ntestRearrangeArray = ->\n  assert.deepStrictEqual rearrangeArray([1, -2, 3, -4, 5, -6]), [1, -2, 3, -4, 5, -6]\n  assert.deepStrictEqual rearrangeArray([-1, 2, -3, 4, -5, 6]), [2, -1, 4, -3, 6, -5]\n  assert.deepStrictEqual rearrangeArray([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]\n  assert.deepStrictEqual rearrangeArray([-1, -2, -3, -4, -5]), [-1, -2, -3, -4, -5]\n  assert.deepStrictEqual rearrangeArray([0, 0, 0, 0, 0]), [0, 0, 0, 0, 0]\n  assert.deepStrictEqual rearrangeArray([]), []\n\ntestRearrangeArray()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestRearrangeArray = ->\n  assert.deepStrictEqual rearrangeArray([1, -2, 3, -4, 5, -6]), [1, -2, 3, -4, 5, -6]\n  assert.deepStrictEqual rearrangeArray([-1, 2, -3, 4, -5, 6]), [2, -1, 4, -3, 6, -5]\n  assert.deepStrictEqual rearrangeArray([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]\n  assert.deepStrictEqual rearrangeArray([-1, -2, -3, -4, -5]), [-1, -2, -3, -4, -5]\n  assert.deepStrictEqual rearrangeArray([0, 0, 0, 0, 0]), [0, 0, 0, 0, 0]\n  assert.deepStrictEqual rearrangeArray([]), []\n\ntestRearrangeArray()", "output": "rearrangeArray"}, "all_code": "# rearrangeArray rearranges the elements in an array such that positive elements appear at even indices\n# and negative elements appear at odd indices. If there are remaining elements of one type after\n# alternating, they are appended to the end of the result.\nrearrangeArray = (arr) ->\n    # Separate positive and negative elements\n    pos = (element for element in arr when element >= 0)\n    neg = (element for element in arr when element < 0)\n\n    result = []\n    i = j = 0\n    \n    for k in [0...arr.length]\n        if k % 2 is 0 and i < pos.length\n            result.push(pos[i])\n            i += 1\n        else if k % 2 is 1 and j < neg.length\n            result.push(neg[j])\n            j += 1\n        else\n            break\n    \n    # Append remaining elements\n    result.push(pos[i...]...)\n    result.push(neg[j...]...)\n    \n    result\nassert = require 'assert'\n\ntestRearrangeArray = ->\n  assert.deepStrictEqual rearrangeArray([1, -2, 3, -4, 5, -6]), [1, -2, 3, -4, 5, -6]\n  assert.deepStrictEqual rearrangeArray([-1, 2, -3, 4, -5, 6]), [2, -1, 4, -3, 6, -5]\n  assert.deepStrictEqual rearrangeArray([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]\n  assert.deepStrictEqual rearrangeArray([-1, -2, -3, -4, -5]), [-1, -2, -3, -4, -5]\n  assert.deepStrictEqual rearrangeArray([0, 0, 0, 0, 0]), [0, 0, 0, 0, 0]\n  assert.deepStrictEqual rearrangeArray([]), []\n\ntestRearrangeArray()", "exec_outcome": "PASSED"}
{"code": "# countLuckySubarrays calculates the number of subarrays in an array that sum up to a target value X.\n# It uses a prefix sum approach with a hash map to efficiently track possible subarray sums.\n#\n# Parameters:\n#   A (array): Array of integers\n#   X (number): Target sum for subarrays\n#\n# Returns:\n#   number: Count of subarrays that sum to X\ncountLuckySubarrays = (A, X) ->\n  sumCount = { 0: 1 }  # Object to store prefix sums and their counts\n  currentSum = 0\n  luckyCount = 0\n  \n  for num in A\n    currentSum += num\n    if (currentSum - X) of sumCount\n      luckyCount += sumCount[currentSum - X]\n    if currentSum of sumCount\n      sumCount[currentSum] += 1\n    else\n      sumCount[currentSum] = 1\n  \n  luckyCount", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Array: [ 1, 2, 3, 4 ]\n  Target Sum: 6\n  Number of Lucky Subarrays: 1\n\nTest Case 2:\n  Input Array: [ 1, 1, 1 ]\n  Target Sum: 2\n  Number of Lucky Subarrays: 2\n\nTest Case 3:\n  Input Array: [\n   3, 4, 7, 2,\n  -3, 1, 4, 2\n]\n  Target Sum: 7\n  Number of Lucky Subarrays: 4\n\nTest Case 4:\n  Input Array: [ 0, 0, 0 ]\n  Target Sum: 0\n  Number of Lucky Subarrays: 6\n\nTest Case 5:\n  Input Array: []\n  Target Sum: 5\n  Number of Lucky Subarrays: 0", "task_id": 23101, "assertions": "assert = require 'assert'\n\ntestCountLuckySubarrays = ->\n  # Test Case 1\n  assert.strictEqual countLuckySubarrays([1, 2, 3, 4], 6), 1\n  # Test Case 2\n  assert.strictEqual countLuckySubarrays([1, 1, 1], 2), 2\n  # Test Case 3\n  assert.strictEqual countLuckySubarrays([3, 4, 7, 2, -3, 1, 4, 2], 7), 4\n  # Test Case 4\n  assert.strictEqual countLuckySubarrays([0, 0, 0], 0), 6\n  # Test Case 5\n  assert.strictEqual countLuckySubarrays([], 5), 0\n  console.log \"All tests passed!\"\n\ntestCountLuckySubarrays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountLuckySubarrays = ->\n  # Test Case 1\n  assert.strictEqual countLuckySubarrays([1, 2, 3, 4], 6), 1\n  # Test Case 2\n  assert.strictEqual countLuckySubarrays([1, 1, 1], 2), 2\n  # Test Case 3\n  assert.strictEqual countLuckySubarrays([3, 4, 7, 2, -3, 1, 4, 2], 7), 4\n  # Test Case 4\n  assert.strictEqual countLuckySubarrays([0, 0, 0], 0), 6\n  # Test Case 5\n  assert.strictEqual countLuckySubarrays([], 5), 0\n  console.log \"All tests passed!\"\n\ntestCountLuckySubarrays()", "output": "countLuckySubarrays"}, "all_code": "# countLuckySubarrays calculates the number of subarrays in an array that sum up to a target value X.\n# It uses a prefix sum approach with a hash map to efficiently track possible subarray sums.\n#\n# Parameters:\n#   A (array): Array of integers\n#   X (number): Target sum for subarrays\n#\n# Returns:\n#   number: Count of subarrays that sum to X\ncountLuckySubarrays = (A, X) ->\n  sumCount = { 0: 1 }  # Object to store prefix sums and their counts\n  currentSum = 0\n  luckyCount = 0\n  \n  for num in A\n    currentSum += num\n    if (currentSum - X) of sumCount\n      luckyCount += sumCount[currentSum - X]\n    if currentSum of sumCount\n      sumCount[currentSum] += 1\n    else\n      sumCount[currentSum] = 1\n  \n  luckyCount\nassert = require 'assert'\n\ntestCountLuckySubarrays = ->\n  # Test Case 1\n  assert.strictEqual countLuckySubarrays([1, 2, 3, 4], 6), 1\n  # Test Case 2\n  assert.strictEqual countLuckySubarrays([1, 1, 1], 2), 2\n  # Test Case 3\n  assert.strictEqual countLuckySubarrays([3, 4, 7, 2, -3, 1, 4, 2], 7), 4\n  # Test Case 4\n  assert.strictEqual countLuckySubarrays([0, 0, 0], 0), 6\n  # Test Case 5\n  assert.strictEqual countLuckySubarrays([], 5), 0\n  console.log \"All tests passed!\"\n\ntestCountLuckySubarrays()", "exec_outcome": "PASSED"}
{"code": "# totalCharactersOfTwiceOccurrence calculates the total number of characters\n# in strings that appear exactly twice in the input array.\ntotalCharactersOfTwiceOccurrence = (words) ->\n  # Create a frequency map of words\n  wordCounts = {}\n  for word in words\n    wordCounts[word] ?= 0\n    wordCounts[word] += 1\n  \n  # Sum lengths of words that appear exactly twice\n  total = 0\n  for word, count of wordCounts\n    total += word.length if count is 2\n  total", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [ 'apple', 'banana', 'apple', 'orange', 'banana', 'kiwi' ]\n  Total characters of twice-occurring words: 11\n\nTest Case 2:\n  Input: [\n  'a', 'b', 'a',\n  'c', 'd', 'e',\n  'd'\n]\n  Total characters of twice-occurring words: 2\n\nTest Case 3:\n  Input: [ 'single', 'word', 'test' ]\n  Total characters of twice-occurring words: 0\n\nTest Case 4:\n  Input: [ 'repeat', 'repeat', 'repeat', 'repeat' ]\n  Total characters of twice-occurring words: 0\n\nTest Case 5:\n  Input: [ 'pair', 'pair', 'odd', 'odd', 'odd' ]\n  Total characters of twice-occurring words: 4", "task_id": 26842, "assertions": "assert = require 'assert'\n\ntestTotalCharactersOfTwiceOccurrence = ->\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]), 11\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"a\", \"b\", \"a\", \"c\", \"d\", \"e\", \"d\"]), 2\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"single\", \"word\", \"test\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"repeat\", \"repeat\", \"repeat\", \"repeat\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"pair\", \"pair\", \"odd\", \"odd\", \"odd\"]), 4\n  console.log \"All tests passed!\"\n\ntestTotalCharactersOfTwiceOccurrence()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestTotalCharactersOfTwiceOccurrence = ->\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]), 11\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"a\", \"b\", \"a\", \"c\", \"d\", \"e\", \"d\"]), 2\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"single\", \"word\", \"test\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"repeat\", \"repeat\", \"repeat\", \"repeat\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"pair\", \"pair\", \"odd\", \"odd\", \"odd\"]), 4\n  console.log \"All tests passed!\"\n\ntestTotalCharactersOfTwiceOccurrence()", "output": "totalCharactersOfTwiceOccurrence"}, "all_code": "# totalCharactersOfTwiceOccurrence calculates the total number of characters\n# in strings that appear exactly twice in the input array.\ntotalCharactersOfTwiceOccurrence = (words) ->\n  # Create a frequency map of words\n  wordCounts = {}\n  for word in words\n    wordCounts[word] ?= 0\n    wordCounts[word] += 1\n  \n  # Sum lengths of words that appear exactly twice\n  total = 0\n  for word, count of wordCounts\n    total += word.length if count is 2\n  total\nassert = require 'assert'\n\ntestTotalCharactersOfTwiceOccurrence = ->\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"kiwi\"]), 11\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"a\", \"b\", \"a\", \"c\", \"d\", \"e\", \"d\"]), 2\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"single\", \"word\", \"test\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"repeat\", \"repeat\", \"repeat\", \"repeat\"]), 0\n  assert.strictEqual totalCharactersOfTwiceOccurrence([\"pair\", \"pair\", \"odd\", \"odd\", \"odd\"]), 4\n  console.log \"All tests passed!\"\n\ntestTotalCharactersOfTwiceOccurrence()", "exec_outcome": "PASSED"}
{"code": "# calculateSentiment computes a sentiment score for a given review text by counting\n# occurrences of positive and negative words. Each positive word adds 1 to the score,\n# each negative word subtracts 1. Punctuation is removed and text is lowercased before processing.\ncalculateSentiment = (review, positiveWords, negativeWords) ->\n  # Remove punctuation and convert to lowercase\n  cleanedReview = review.replace(/[^\\w\\s]/g, '').toLowerCase()\n  \n  # Split into words\n  words = cleanedReview.split(/\\s+/)\n  \n  # Calculate sentiment score\n  score = 0\n  for word in words\n    if word in positiveWords\n      score += 1\n    else if word in negativeWords\n      score -= 1\n      \n  score", "test_cases": "", "test_case_results": "Test Case 1:\nReview: This product is amazing! It works perfectly and I love it.\nPositive Words: [ 'amazing', 'love', 'perfect' ]\nNegative Words: [ 'hate', 'bad', 'terrible' ]\nSentiment Score: 2\n\nTest Case 2:\nReview: The service was terrible and the food was bad. I hate this place.\nPositive Words: [ 'good', 'great', 'excellent' ]\nNegative Words: [ 'terrible', 'bad', 'hate' ]\nSentiment Score: -3\n\nTest Case 3:\nReview: It's okay. Not great, not terrible. Just average.\nPositive Words: [ 'great', 'excellent' ]\nNegative Words: [ 'terrible', 'awful' ]\nSentiment Score: 0\n\nTest Case 4:\nReview: Mixed feelings: good parts and bad parts. Great service but awful waiting time.\nPositive Words: [ 'good', 'great' ]\nNegative Words: [ 'bad', 'awful' ]\nSentiment Score: 0", "task_id": 15538, "assertions": "assert = require 'assert'\n\ntestSentimentAnalysis = ->\n  # Test case 1\n  assert.strictEqual calculateSentiment(\n    \"This product is amazing! It works perfectly and I love it.\",\n    ['amazing', 'love', 'perfect'],\n    ['hate', 'bad', 'terrible']\n  ), 2\n\n  # Test case 2\n  assert.strictEqual calculateSentiment(\n    \"The service was terrible and the food was bad. I hate this place.\",\n    ['good', 'great', 'excellent'],\n    ['terrible', 'bad', 'hate']\n  ), -3\n\n  # Test case 3\n  assert.strictEqual calculateSentiment(\n    \"It's okay. Not great, not terrible. Just average.\",\n    ['great', 'excellent'],\n    ['terrible', 'awful']\n  ), 0\n\n  # Test case 4\n  assert.strictEqual calculateSentiment(\n    \"Mixed feelings: good parts and bad parts. Great service but awful waiting time.\",\n    ['good', 'great'],\n    ['bad', 'awful']\n  ), 0\n\n  console.log \"All tests passed!\"\n\ntestSentimentAnalysis()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSentimentAnalysis = ->\n  # Test case 1\n  assert.strictEqual calculateSentiment(\n    \"This product is amazing! It works perfectly and I love it.\",\n    ['amazing', 'love', 'perfect'],\n    ['hate', 'bad', 'terrible']\n  ), 2\n\n  # Test case 2\n  assert.strictEqual calculateSentiment(\n    \"The service was terrible and the food was bad. I hate this place.\",\n    ['good', 'great', 'excellent'],\n    ['terrible', 'bad', 'hate']\n  ), -3\n\n  # Test case 3\n  assert.strictEqual calculateSentiment(\n    \"It's okay. Not great, not terrible. Just average.\",\n    ['great', 'excellent'],\n    ['terrible', 'awful']\n  ), 0\n\n  # Test case 4\n  assert.strictEqual calculateSentiment(\n    \"Mixed feelings: good parts and bad parts. Great service but awful waiting time.\",\n    ['good', 'great'],\n    ['bad', 'awful']\n  ), 0\n\n  console.log \"All tests passed!\"\n\ntestSentimentAnalysis()", "output": "calculateSentiment"}, "all_code": "# calculateSentiment computes a sentiment score for a given review text by counting\n# occurrences of positive and negative words. Each positive word adds 1 to the score,\n# each negative word subtracts 1. Punctuation is removed and text is lowercased before processing.\ncalculateSentiment = (review, positiveWords, negativeWords) ->\n  # Remove punctuation and convert to lowercase\n  cleanedReview = review.replace(/[^\\w\\s]/g, '').toLowerCase()\n  \n  # Split into words\n  words = cleanedReview.split(/\\s+/)\n  \n  # Calculate sentiment score\n  score = 0\n  for word in words\n    if word in positiveWords\n      score += 1\n    else if word in negativeWords\n      score -= 1\n      \n  score\nassert = require 'assert'\n\ntestSentimentAnalysis = ->\n  # Test case 1\n  assert.strictEqual calculateSentiment(\n    \"This product is amazing! It works perfectly and I love it.\",\n    ['amazing', 'love', 'perfect'],\n    ['hate', 'bad', 'terrible']\n  ), 2\n\n  # Test case 2\n  assert.strictEqual calculateSentiment(\n    \"The service was terrible and the food was bad. I hate this place.\",\n    ['good', 'great', 'excellent'],\n    ['terrible', 'bad', 'hate']\n  ), -3\n\n  # Test case 3\n  assert.strictEqual calculateSentiment(\n    \"It's okay. Not great, not terrible. Just average.\",\n    ['great', 'excellent'],\n    ['terrible', 'awful']\n  ), 0\n\n  # Test case 4\n  assert.strictEqual calculateSentiment(\n    \"Mixed feelings: good parts and bad parts. Great service but awful waiting time.\",\n    ['good', 'great'],\n    ['bad', 'awful']\n  ), 0\n\n  console.log \"All tests passed!\"\n\ntestSentimentAnalysis()", "exec_outcome": "PASSED"}
{"code": "# longestPeakLengthAndStart calculates the length and starting mile of the longest peak in an elevation profile.\n# A peak is defined as a sequence where elevations increase to a point and then decrease.\n# M: Total number of miles (length of elevations array)\n# elevations: Array of elevation values for each mile\n# Returns an array with [maxPeakLength, startingMile], or [0, -1] if no peak is found.\nlongestPeakLengthAndStart = (M, elevations) ->\n    maxPeakLength = 0\n    startingMile = -1\n\n    for i in [1..M-2]\n        # Check if current position is a peak\n        if elevations[i-1] < elevations[i] and elevations[i] > elevations[i+1]\n            # Expand to the left to find the start of the increasing sequence\n            leftIdx = i - 1\n            while leftIdx > 0 and elevations[leftIdx] > elevations[leftIdx - 1]\n                leftIdx -= 1\n            \n            # Expand to the right to find the end of the decreasing sequence\n            rightIdx = i + 1\n            while rightIdx < M - 1 and elevations[rightIdx] > elevations[rightIdx + 1]\n                rightIdx += 1\n            \n            # Calculate peak length and update max if necessary\n            peakLength = rightIdx - leftIdx + 1\n            if peakLength > maxPeakLength\n                maxPeakLength = peakLength\n                startingMile = leftIdx + 1  # Convert to 1-based index\n    \n    [maxPeakLength, startingMile]", "test_cases": "", "test_case_results": "Input:\nM: 10\nElevations: [\n  1, 3, 2, 1, 4,\n  6, 4, 1, 2, 3\n]\nResult: [ 5, 4 ]\nExpected: [ 5, 4 ]\n---\nInput:\nM: 5\nElevations: [ 1, 2, 3, 2, 1 ]\nResult: [ 5, 1 ]\nExpected: [ 5, 1 ]\n---\nInput:\nM: 6\nElevations: [ 1, 2, 1, 2, 1, 2 ]\nResult: [ 3, 1 ]\nExpected: [ 3, 1 ]\n---\nInput:\nM: 4\nElevations: [ 1, 2, 3, 4 ]\nResult: [ 0, -1 ]\nExpected: [ 0, -1 ]\n---\nInput:\nM: 3\nElevations: [ 3, 2, 1 ]\nResult: [ 0, -1 ]\nExpected: [ 0, -1 ]\n---", "task_id": 18372, "assertions": "assert = require 'assert'\n\ntestLongestPeak = ->\n    testCases = [\n        {\n            M: 10,\n            elevations: [1, 3, 2, 1, 4, 6, 4, 1, 2, 3],\n            expected: [5, 4]\n        },\n        {\n            M: 5,\n            elevations: [1, 2, 3, 2, 1],\n            expected: [5, 1]\n        },\n        {\n            M: 6,\n            elevations: [1, 2, 1, 2, 1, 2],\n            expected: [3, 1]\n        },\n        {\n            M: 4,\n            elevations: [1, 2, 3, 4],\n            expected: [0, -1]\n        },\n        {\n            M: 3,\n            elevations: [3, 2, 1],\n            expected: [0, -1]\n        }\n    ]\n\n    for testCase in testCases\n        [length, mile] = longestPeakLengthAndStart(testCase.M, testCase.elevations)\n        assert.deepStrictEqual [length, mile], testCase.expected\n\ntestLongestPeak()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestLongestPeak = ->\n    testCases = [\n        {\n            M: 10,\n            elevations: [1, 3, 2, 1, 4, 6, 4, 1, 2, 3],\n            expected: [5, 4]\n        },\n        {\n            M: 5,\n            elevations: [1, 2, 3, 2, 1],\n            expected: [5, 1]\n        },\n        {\n            M: 6,\n            elevations: [1, 2, 1, 2, 1, 2],\n            expected: [3, 1]\n        },\n        {\n            M: 4,\n            elevations: [1, 2, 3, 4],\n            expected: [0, -1]\n        },\n        {\n            M: 3,\n            elevations: [3, 2, 1],\n            expected: [0, -1]\n        }\n    ]\n\n    for testCase in testCases\n        [length, mile] = longestPeakLengthAndStart(testCase.M, testCase.elevations)\n        assert.deepStrictEqual [length, mile], testCase.expected\n\ntestLongestPeak()", "output": "longestPeakLengthAndStart"}, "all_code": "# longestPeakLengthAndStart calculates the length and starting mile of the longest peak in an elevation profile.\n# A peak is defined as a sequence where elevations increase to a point and then decrease.\n# M: Total number of miles (length of elevations array)\n# elevations: Array of elevation values for each mile\n# Returns an array with [maxPeakLength, startingMile], or [0, -1] if no peak is found.\nlongestPeakLengthAndStart = (M, elevations) ->\n    maxPeakLength = 0\n    startingMile = -1\n\n    for i in [1..M-2]\n        # Check if current position is a peak\n        if elevations[i-1] < elevations[i] and elevations[i] > elevations[i+1]\n            # Expand to the left to find the start of the increasing sequence\n            leftIdx = i - 1\n            while leftIdx > 0 and elevations[leftIdx] > elevations[leftIdx - 1]\n                leftIdx -= 1\n            \n            # Expand to the right to find the end of the decreasing sequence\n            rightIdx = i + 1\n            while rightIdx < M - 1 and elevations[rightIdx] > elevations[rightIdx + 1]\n                rightIdx += 1\n            \n            # Calculate peak length and update max if necessary\n            peakLength = rightIdx - leftIdx + 1\n            if peakLength > maxPeakLength\n                maxPeakLength = peakLength\n                startingMile = leftIdx + 1  # Convert to 1-based index\n    \n    [maxPeakLength, startingMile]\nassert = require 'assert'\n\ntestLongestPeak = ->\n    testCases = [\n        {\n            M: 10,\n            elevations: [1, 3, 2, 1, 4, 6, 4, 1, 2, 3],\n            expected: [5, 4]\n        },\n        {\n            M: 5,\n            elevations: [1, 2, 3, 2, 1],\n            expected: [5, 1]\n        },\n        {\n            M: 6,\n            elevations: [1, 2, 1, 2, 1, 2],\n            expected: [3, 1]\n        },\n        {\n            M: 4,\n            elevations: [1, 2, 3, 4],\n            expected: [0, -1]\n        },\n        {\n            M: 3,\n            elevations: [3, 2, 1],\n            expected: [0, -1]\n        }\n    ]\n\n    for testCase in testCases\n        [length, mile] = longestPeakLengthAndStart(testCase.M, testCase.elevations)\n        assert.deepStrictEqual [length, mile], testCase.expected\n\ntestLongestPeak()", "exec_outcome": "PASSED"}
{"code": "# StudentScoresManager manages student scores and provides statistics\nclass StudentScoresManager\n  constructor: ->\n    @students = {}\n\n  # Adds a student to the manager if they don't already exist\n  addStudent: (name) ->\n    unless @students[name]?\n      @students[name] = []\n\n  # Adds a score for a student if the student exists\n  addScore: (name, score) ->\n    if @students[name]?\n      @students[name].push score\n\n  # Returns the average score for a student, or 0 if no scores exist\n  getAverageScore: (name) ->\n    if @students[name]? and @students[name].length > 0\n      scores = @students[name]\n      scores.reduce((a, b) -> a + b) / scores.length\n    else\n      0.0\n\n  # Returns the name of the student with the highest average score\n  getHighestAverageScore: ->\n    highestAvg = -Infinity\n    topStudent = null\n    \n    for name, scores of @students\n      if scores.length > 0\n        avgScore = scores.reduce((a, b) -> a + b) / scores.length\n        if avgScore > highestAvg\n          highestAvg = avgScore\n          topStudent = name\n    \n    topStudent", "test_cases": "", "test_case_results": "Test 1 - Alice's average: 85\nTest 1 - Bob's average: 90\nTest 1 - Highest average: Bob\nTest 2 - Charlie's average (should be 0): 0\nTest 3 - Dave's average (should be 0): 0\nTest 3 - All students: [ 'Alice', 'Bob', 'Dave' ]", "task_id": 3157, "assertions": "assert = require 'assert'\n\ntestStudentScoresManager = ->\n  manager = new StudentScoresManager()\n\n  # Test 1: Basic operations\n  manager.addStudent(\"Alice\")\n  manager.addScore(\"Alice\", 90)\n  manager.addScore(\"Alice\", 80)\n  manager.addStudent(\"Bob\")\n  manager.addScore(\"Bob\", 85)\n  manager.addScore(\"Bob\", 95)\n\n  # Test 2: Non-existent student\n  manager.addScore(\"Charlie\", 70)  # Should be ignored\n\n  # Test 3: Empty student\n  manager.addStudent(\"Dave\")\n\n  # Assertions\n  assert.strictEqual manager.getAverageScore(\"Alice\"), 85\n  assert.strictEqual manager.getAverageScore(\"Bob\"), 90\n  assert.strictEqual manager.getHighestAverageScore(), \"Bob\"\n  assert.strictEqual manager.getAverageScore(\"Charlie\"), 0\n  assert.strictEqual manager.getAverageScore(\"Dave\"), 0\n  assert.deepStrictEqual Object.keys(manager.students), ['Alice', 'Bob', 'Dave']\n\n  console.log \"All tests passed!\"\n\ntestStudentScoresManager()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestStudentScoresManager = ->\n  manager = new StudentScoresManager()\n\n  # Test 1: Basic operations\n  manager.addStudent(\"Alice\")\n  manager.addScore(\"Alice\", 90)\n  manager.addScore(\"Alice\", 80)\n  manager.addStudent(\"Bob\")\n  manager.addScore(\"Bob\", 85)\n  manager.addScore(\"Bob\", 95)\n\n  # Test 2: Non-existent student\n  manager.addScore(\"Charlie\", 70)  # Should be ignored\n\n  # Test 3: Empty student\n  manager.addStudent(\"Dave\")\n\n  # Assertions\n  assert.strictEqual manager.getAverageScore(\"Alice\"), 85\n  assert.strictEqual manager.getAverageScore(\"Bob\"), 90\n  assert.strictEqual manager.getHighestAverageScore(), \"Bob\"\n  assert.strictEqual manager.getAverageScore(\"Charlie\"), 0\n  assert.strictEqual manager.getAverageScore(\"Dave\"), 0\n  assert.deepStrictEqual Object.keys(manager.students), ['Alice', 'Bob', 'Dave']\n\n  console.log \"All tests passed!\"\n\ntestStudentScoresManager()", "output": "StudentScoresManager"}, "all_code": "# StudentScoresManager manages student scores and provides statistics\nclass StudentScoresManager\n  constructor: ->\n    @students = {}\n\n  # Adds a student to the manager if they don't already exist\n  addStudent: (name) ->\n    unless @students[name]?\n      @students[name] = []\n\n  # Adds a score for a student if the student exists\n  addScore: (name, score) ->\n    if @students[name]?\n      @students[name].push score\n\n  # Returns the average score for a student, or 0 if no scores exist\n  getAverageScore: (name) ->\n    if @students[name]? and @students[name].length > 0\n      scores = @students[name]\n      scores.reduce((a, b) -> a + b) / scores.length\n    else\n      0.0\n\n  # Returns the name of the student with the highest average score\n  getHighestAverageScore: ->\n    highestAvg = -Infinity\n    topStudent = null\n    \n    for name, scores of @students\n      if scores.length > 0\n        avgScore = scores.reduce((a, b) -> a + b) / scores.length\n        if avgScore > highestAvg\n          highestAvg = avgScore\n          topStudent = name\n    \n    topStudent\nassert = require 'assert'\n\ntestStudentScoresManager = ->\n  manager = new StudentScoresManager()\n\n  # Test 1: Basic operations\n  manager.addStudent(\"Alice\")\n  manager.addScore(\"Alice\", 90)\n  manager.addScore(\"Alice\", 80)\n  manager.addStudent(\"Bob\")\n  manager.addScore(\"Bob\", 85)\n  manager.addScore(\"Bob\", 95)\n\n  # Test 2: Non-existent student\n  manager.addScore(\"Charlie\", 70)  # Should be ignored\n\n  # Test 3: Empty student\n  manager.addStudent(\"Dave\")\n\n  # Assertions\n  assert.strictEqual manager.getAverageScore(\"Alice\"), 85\n  assert.strictEqual manager.getAverageScore(\"Bob\"), 90\n  assert.strictEqual manager.getHighestAverageScore(), \"Bob\"\n  assert.strictEqual manager.getAverageScore(\"Charlie\"), 0\n  assert.strictEqual manager.getAverageScore(\"Dave\"), 0\n  assert.deepStrictEqual Object.keys(manager.students), ['Alice', 'Bob', 'Dave']\n\n  console.log \"All tests passed!\"\n\ntestStudentScoresManager()", "exec_outcome": "PASSED"}
{"code": "# topologicalSort performs a topological sort on a directed graph represented as an adjacency list.\n# The graph is represented as an object where keys are nodes and values are arrays of connected nodes.\n# Returns an array of nodes in topologically sorted order, or null if the graph contains a cycle.\ntopologicalSort = (graph) ->\n    # Initialize the in-degree of all nodes to 0\n    inDegree = {}\n    for node of graph\n        inDegree[node] ?= 0\n        for neighbor in graph[node]\n            inDegree[neighbor] ?= 0\n            inDegree[neighbor] += 1\n    \n    # Initialize a queue with nodes having in-degree of 0\n    queue = (node for node of graph when inDegree[node] is 0)\n    \n    topologicalOrder = []\n\n    while queue.length > 0\n        node = queue.shift()\n        topologicalOrder.push(node)\n\n        for neighbor in graph[node] ? []\n            inDegree[neighbor] -= 1\n            if inDegree[neighbor] is 0\n                queue.push(neighbor)\n    \n    if topologicalOrder.length is Object.keys(graph).length\n        return topologicalOrder\n    else\n        # The graph has at least one cycle\n        return null", "test_cases": "", "test_case_results": "Test Case 1:\nGraph: {\"A\":[\"B\",\"C\"],\"B\":[\"D\"],\"C\":[\"D\"],\"D\":[]}\nTopological Order: [ 'A', 'B', 'C', 'D' ]\n\nTest Case 2:\nGraph: {\"A\":[\"B\"],\"B\":[\"C\"],\"C\":[\"A\"]}\nNo topological order exists (graph contains a cycle)\n\nTest Case 3:\nGraph: {\"1\":[\"2\",\"3\"],\"2\":[\"4\"],\"3\":[\"4\",\"5\"],\"4\":[\"6\"],\"5\":[\"6\"],\"6\":[]}\nTopological Order: [ '1', '2', '3', '4', '5', '6' ]\n\nTest Case 4:\nGraph: {\"X\":[]}\nTopological Order: [ 'X' ]", "task_id": 24133, "assertions": "assert = require 'assert'\n\ntestTopologicalSort = ->\n    # Test Case 1: Acyclic graph\n    graph1 =\n        'A': ['B', 'C']\n        'B': ['D']\n        'C': ['D']\n        'D': []\n    assert.deepStrictEqual topologicalSort(graph1), ['A', 'B', 'C', 'D']\n    \n    # Test Case 2: Graph with cycle\n    graph2 =\n        'A': ['B']\n        'B': ['C']\n        'C': ['A']\n    assert.strictEqual topologicalSort(graph2), null\n    \n    # Test Case 3: More complex acyclic graph\n    graph3 =\n        '1': ['2', '3']\n        '2': ['4']\n        '3': ['4', '5']\n        '4': ['6']\n        '5': ['6']\n        '6': []\n    assert.deepStrictEqual topologicalSort(graph3), ['1', '2', '3', '4', '5', '6']\n    \n    # Test Case 4: Single node\n    graph4 =\n        'X': []\n    assert.deepStrictEqual topologicalSort(graph4), ['X']\n    \n    console.log \"All tests passed!\"\n\ntestTopologicalSort()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestTopologicalSort = ->\n    # Test Case 1: Acyclic graph\n    graph1 =\n        'A': ['B', 'C']\n        'B': ['D']\n        'C': ['D']\n        'D': []\n    assert.deepStrictEqual topologicalSort(graph1), ['A', 'B', 'C', 'D']\n    \n    # Test Case 2: Graph with cycle\n    graph2 =\n        'A': ['B']\n        'B': ['C']\n        'C': ['A']\n    assert.strictEqual topologicalSort(graph2), null\n    \n    # Test Case 3: More complex acyclic graph\n    graph3 =\n        '1': ['2', '3']\n        '2': ['4']\n        '3': ['4', '5']\n        '4': ['6']\n        '5': ['6']\n        '6': []\n    assert.deepStrictEqual topologicalSort(graph3), ['1', '2', '3', '4', '5', '6']\n    \n    # Test Case 4: Single node\n    graph4 =\n        'X': []\n    assert.deepStrictEqual topologicalSort(graph4), ['X']\n    \n    console.log \"All tests passed!\"\n\ntestTopologicalSort()", "output": "topologicalSort"}, "all_code": "# topologicalSort performs a topological sort on a directed graph represented as an adjacency list.\n# The graph is represented as an object where keys are nodes and values are arrays of connected nodes.\n# Returns an array of nodes in topologically sorted order, or null if the graph contains a cycle.\ntopologicalSort = (graph) ->\n    # Initialize the in-degree of all nodes to 0\n    inDegree = {}\n    for node of graph\n        inDegree[node] ?= 0\n        for neighbor in graph[node]\n            inDegree[neighbor] ?= 0\n            inDegree[neighbor] += 1\n    \n    # Initialize a queue with nodes having in-degree of 0\n    queue = (node for node of graph when inDegree[node] is 0)\n    \n    topologicalOrder = []\n\n    while queue.length > 0\n        node = queue.shift()\n        topologicalOrder.push(node)\n\n        for neighbor in graph[node] ? []\n            inDegree[neighbor] -= 1\n            if inDegree[neighbor] is 0\n                queue.push(neighbor)\n    \n    if topologicalOrder.length is Object.keys(graph).length\n        return topologicalOrder\n    else\n        # The graph has at least one cycle\n        return null\nassert = require 'assert'\n\ntestTopologicalSort = ->\n    # Test Case 1: Acyclic graph\n    graph1 =\n        'A': ['B', 'C']\n        'B': ['D']\n        'C': ['D']\n        'D': []\n    assert.deepStrictEqual topologicalSort(graph1), ['A', 'B', 'C', 'D']\n    \n    # Test Case 2: Graph with cycle\n    graph2 =\n        'A': ['B']\n        'B': ['C']\n        'C': ['A']\n    assert.strictEqual topologicalSort(graph2), null\n    \n    # Test Case 3: More complex acyclic graph\n    graph3 =\n        '1': ['2', '3']\n        '2': ['4']\n        '3': ['4', '5']\n        '4': ['6']\n        '5': ['6']\n        '6': []\n    assert.deepStrictEqual topologicalSort(graph3), ['1', '2', '3', '4', '5', '6']\n    \n    # Test Case 4: Single node\n    graph4 =\n        'X': []\n    assert.deepStrictEqual topologicalSort(graph4), ['X']\n    \n    console.log \"All tests passed!\"\n\ntestTopologicalSort()", "exec_outcome": "PASSED"}
{"code": "# findMinValuesInSubarrays finds the minimum values in specified subarrays of an array.\n# The subarrays must be either strictly ascending or strictly descending.\n# For ascending subarrays, the minimum is the first element.\n# For descending subarrays, the minimum is the last element.\n# Throws an error if any subarray is neither ascending nor descending.\nfindMinValuesInSubarrays = (arr, subarrays) ->\n  minValues = []\n  for subarray in subarrays\n    [start, end] = subarray\n    subarrayValues = arr[start..end]\n    \n    # Check if subarray is ascending\n    isAscending = true\n    for i in [1...subarrayValues.length]\n      if subarrayValues[i] <= subarrayValues[i-1]\n        isAscending = false\n        break\n    \n    # Check if subarray is descending\n    isDescending = true\n    for i in [1...subarrayValues.length]\n      if subarrayValues[i] >= subarrayValues[i-1]\n        isDescending = false\n        break\n    \n    # Determine min value based on order\n    if isAscending\n      minValue = subarrayValues[0]\n    else if isDescending\n      minValue = subarrayValues[subarrayValues.length - 1]\n    else\n      throw new Error(\"Subarrays should be either strictly ascending or strictly descending\")\n    \n    minValues.push(minValue)\n  minValues", "test_cases": "", "test_case_results": "Test Case 1:\nInput Array: [\n  1, 2, 3, 4, 5,\n  4, 3, 2, 1\n]\nSubarrays to Check: [ [ 0, 4 ], [ 4, 8 ] ]\nMinimum Values: [ 1, 1 ]\n\nTest Case 2:\nInput Array: [ 10, 8, 6, 4, 2, 0 ]\nSubarrays to Check: [ [ 0, 5 ] ]\nMinimum Values: [ 0 ]\n\nTest Case 3:\nInput Array: [ 0, 2, 4, 6, 8, 10 ]\nSubarrays to Check: [ [ 0, 5 ] ]\nMinimum Values: [ 0 ]", "task_id": 15715, "assertions": "assert = require 'assert'\n\ntestFindMinValuesInSubarrays = ->\n  # Test Case 1: Mountain-shaped array\n  arr1 = [1, 2, 3, 4, 5, 4, 3, 2, 1]\n  subarrays1 = [[0, 4], [4, 8]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr1, subarrays1), [1, 1]\n\n  # Test Case 2: Strictly descending array\n  arr2 = [10, 8, 6, 4, 2, 0]\n  subarrays2 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr2, subarrays2), [0]\n\n  # Test Case 3: Strictly ascending array\n  arr3 = [0, 2, 4, 6, 8, 10]\n  subarrays3 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr3, subarrays3), [0]\n\n  # Test error case (neither ascending nor descending)\n  arr4 = [1, 3, 2, 4]\n  subarrays4 = [[0, 3]]\n  assert.throws (-> findMinValuesInSubarrays(arr4, subarrays4)), Error\n\ntestFindMinValuesInSubarrays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindMinValuesInSubarrays = ->\n  # Test Case 1: Mountain-shaped array\n  arr1 = [1, 2, 3, 4, 5, 4, 3, 2, 1]\n  subarrays1 = [[0, 4], [4, 8]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr1, subarrays1), [1, 1]\n\n  # Test Case 2: Strictly descending array\n  arr2 = [10, 8, 6, 4, 2, 0]\n  subarrays2 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr2, subarrays2), [0]\n\n  # Test Case 3: Strictly ascending array\n  arr3 = [0, 2, 4, 6, 8, 10]\n  subarrays3 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr3, subarrays3), [0]\n\n  # Test error case (neither ascending nor descending)\n  arr4 = [1, 3, 2, 4]\n  subarrays4 = [[0, 3]]\n  assert.throws (-> findMinValuesInSubarrays(arr4, subarrays4)), Error\n\ntestFindMinValuesInSubarrays()", "output": "findMinValuesInSubarrays"}, "all_code": "# findMinValuesInSubarrays finds the minimum values in specified subarrays of an array.\n# The subarrays must be either strictly ascending or strictly descending.\n# For ascending subarrays, the minimum is the first element.\n# For descending subarrays, the minimum is the last element.\n# Throws an error if any subarray is neither ascending nor descending.\nfindMinValuesInSubarrays = (arr, subarrays) ->\n  minValues = []\n  for subarray in subarrays\n    [start, end] = subarray\n    subarrayValues = arr[start..end]\n    \n    # Check if subarray is ascending\n    isAscending = true\n    for i in [1...subarrayValues.length]\n      if subarrayValues[i] <= subarrayValues[i-1]\n        isAscending = false\n        break\n    \n    # Check if subarray is descending\n    isDescending = true\n    for i in [1...subarrayValues.length]\n      if subarrayValues[i] >= subarrayValues[i-1]\n        isDescending = false\n        break\n    \n    # Determine min value based on order\n    if isAscending\n      minValue = subarrayValues[0]\n    else if isDescending\n      minValue = subarrayValues[subarrayValues.length - 1]\n    else\n      throw new Error(\"Subarrays should be either strictly ascending or strictly descending\")\n    \n    minValues.push(minValue)\n  minValues\nassert = require 'assert'\n\ntestFindMinValuesInSubarrays = ->\n  # Test Case 1: Mountain-shaped array\n  arr1 = [1, 2, 3, 4, 5, 4, 3, 2, 1]\n  subarrays1 = [[0, 4], [4, 8]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr1, subarrays1), [1, 1]\n\n  # Test Case 2: Strictly descending array\n  arr2 = [10, 8, 6, 4, 2, 0]\n  subarrays2 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr2, subarrays2), [0]\n\n  # Test Case 3: Strictly ascending array\n  arr3 = [0, 2, 4, 6, 8, 10]\n  subarrays3 = [[0, 5]]\n  assert.deepStrictEqual findMinValuesInSubarrays(arr3, subarrays3), [0]\n\n  # Test error case (neither ascending nor descending)\n  arr4 = [1, 3, 2, 4]\n  subarrays4 = [[0, 3]]\n  assert.throws (-> findMinValuesInSubarrays(arr4, subarrays4)), Error\n\ntestFindMinValuesInSubarrays()", "exec_outcome": "PASSED"}
{"code": "# findCommonSubstrings returns the longest common substrings between two input strings.\n# It uses dynamic programming to build a matrix of longest common suffixes (lcs_suffix),\n# then collects all substrings that match the maximum length found.\nfindCommonSubstrings = (s1, s2) ->\n  len_s1 = s1.length\n  len_s2 = s2.length\n\n  # Initialize a matrix to store lengths of longest common suffixes of substrings\n  lcs_suffix = (new Array(len_s2 + 1).fill 0 for _ in [0..len_s1])\n\n  # Store length of longest common substring\n  longest_len = 0\n\n  # Set to store all longest common substrings\n  common_substrings = new Set()\n\n  # Build the lcs_suffix matrix\n  for i in [1..len_s1]\n    for j in [1..len_s2]\n      if s1[i - 1] is s2[j - 1]\n        lcs_suffix[i][j] = lcs_suffix[i - 1][j - 1] + 1\n        if lcs_suffix[i][j] > longest_len\n          longest_len = lcs_suffix[i][j]\n          common_substrings = new Set([s1.substring(i - longest_len, i)])\n        else if lcs_suffix[i][j] is longest_len\n          common_substrings.add s1.substring(i - longest_len, i)\n\n  Array.from(common_substrings)", "test_cases": "", "test_case_results": "Input strings: ABABC BABCA\nLongest common substrings: [ 'BABC' ]\nInput strings: hello world world hello\nLongest common substrings: [ 'hello', 'world' ]\nInput strings: programming program\nLongest common substrings: [ 'program' ]\nInput strings: abcdef xyz\nLongest common substrings: []\nInput strings: same same\nLongest common substrings: [ 'same' ]", "task_id": 7655, "assertions": "assert = require 'assert'\n\ntestFindCommonSubstrings = ->\n  # Test case 1: Basic case with one longest substring\n  assert.deepStrictEqual findCommonSubstrings(\"ABABC\", \"BABCA\"), ['BABC']\n  \n  # Test case 2: Multiple longest substrings\n  result = findCommonSubstrings(\"hello world\", \"world hello\")\n  assert.strictEqual result.length, 2\n  assert.ok result.includes('hello')\n  assert.ok result.includes('world')\n  \n  # Test case 3: One string is substring of another\n  assert.deepStrictEqual findCommonSubstrings(\"programming\", \"program\"), ['program']\n  \n  # Test case 4: No common substrings\n  assert.deepStrictEqual findCommonSubstrings(\"abcdef\", \"xyz\"), []\n  \n  # Test case 5: Identical strings\n  assert.deepStrictEqual findCommonSubstrings(\"same\", \"same\"), ['same']\n\ntestFindCommonSubstrings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindCommonSubstrings = ->\n  # Test case 1: Basic case with one longest substring\n  assert.deepStrictEqual findCommonSubstrings(\"ABABC\", \"BABCA\"), ['BABC']\n  \n  # Test case 2: Multiple longest substrings\n  result = findCommonSubstrings(\"hello world\", \"world hello\")\n  assert.strictEqual result.length, 2\n  assert.ok result.includes('hello')\n  assert.ok result.includes('world')\n  \n  # Test case 3: One string is substring of another\n  assert.deepStrictEqual findCommonSubstrings(\"programming\", \"program\"), ['program']\n  \n  # Test case 4: No common substrings\n  assert.deepStrictEqual findCommonSubstrings(\"abcdef\", \"xyz\"), []\n  \n  # Test case 5: Identical strings\n  assert.deepStrictEqual findCommonSubstrings(\"same\", \"same\"), ['same']\n\ntestFindCommonSubstrings()", "output": "findCommonSubstrings"}, "all_code": "# findCommonSubstrings returns the longest common substrings between two input strings.\n# It uses dynamic programming to build a matrix of longest common suffixes (lcs_suffix),\n# then collects all substrings that match the maximum length found.\nfindCommonSubstrings = (s1, s2) ->\n  len_s1 = s1.length\n  len_s2 = s2.length\n\n  # Initialize a matrix to store lengths of longest common suffixes of substrings\n  lcs_suffix = (new Array(len_s2 + 1).fill 0 for _ in [0..len_s1])\n\n  # Store length of longest common substring\n  longest_len = 0\n\n  # Set to store all longest common substrings\n  common_substrings = new Set()\n\n  # Build the lcs_suffix matrix\n  for i in [1..len_s1]\n    for j in [1..len_s2]\n      if s1[i - 1] is s2[j - 1]\n        lcs_suffix[i][j] = lcs_suffix[i - 1][j - 1] + 1\n        if lcs_suffix[i][j] > longest_len\n          longest_len = lcs_suffix[i][j]\n          common_substrings = new Set([s1.substring(i - longest_len, i)])\n        else if lcs_suffix[i][j] is longest_len\n          common_substrings.add s1.substring(i - longest_len, i)\n\n  Array.from(common_substrings)\nassert = require 'assert'\n\ntestFindCommonSubstrings = ->\n  # Test case 1: Basic case with one longest substring\n  assert.deepStrictEqual findCommonSubstrings(\"ABABC\", \"BABCA\"), ['BABC']\n  \n  # Test case 2: Multiple longest substrings\n  result = findCommonSubstrings(\"hello world\", \"world hello\")\n  assert.strictEqual result.length, 2\n  assert.ok result.includes('hello')\n  assert.ok result.includes('world')\n  \n  # Test case 3: One string is substring of another\n  assert.deepStrictEqual findCommonSubstrings(\"programming\", \"program\"), ['program']\n  \n  # Test case 4: No common substrings\n  assert.deepStrictEqual findCommonSubstrings(\"abcdef\", \"xyz\"), []\n  \n  # Test case 5: Identical strings\n  assert.deepStrictEqual findCommonSubstrings(\"same\", \"same\"), ['same']\n\ntestFindCommonSubstrings()", "exec_outcome": "PASSED"}
{"code": "# minChangesToPalindrome calculates the minimum number of digit changes required\n# to make an integer a palindrome. It compares digits from both ends moving towards\n# the center and counts mismatches.\nminChangesToPalindrome = (n) ->\n  s = n.toString()\n  length = s.length\n  changes = 0\n  for i in [0...Math.floor(length / 2)]\n    if s[i] != s[length - 1 - i]\n      changes += 1\n  changes", "test_cases": "", "test_case_results": "Input: 12345\nMinimum changes: 2\n\nInput: 12321\nMinimum changes: 0\n\nInput: 123321\nMinimum changes: 0\n\nInput: 123456\nMinimum changes: 3\n\nInput: 1001\nMinimum changes: 0\n\nInput: 1100\nMinimum changes: 2", "task_id": 22151, "assertions": "assert = require 'assert'\n\ntestMinChangesToPalindrome = ->\n  assert.strictEqual minChangesToPalindrome(12345), 2\n  assert.strictEqual minChangesToPalindrome(12321), 0\n  assert.strictEqual minChangesToPalindrome(123321), 0\n  assert.strictEqual minChangesToPalindrome(123456), 3\n  assert.strictEqual minChangesToPalindrome(1001), 0\n  assert.strictEqual minChangesToPalindrome(1100), 2\n  console.log \"All tests passed!\"\n\ntestMinChangesToPalindrome()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinChangesToPalindrome = ->\n  assert.strictEqual minChangesToPalindrome(12345), 2\n  assert.strictEqual minChangesToPalindrome(12321), 0\n  assert.strictEqual minChangesToPalindrome(123321), 0\n  assert.strictEqual minChangesToPalindrome(123456), 3\n  assert.strictEqual minChangesToPalindrome(1001), 0\n  assert.strictEqual minChangesToPalindrome(1100), 2\n  console.log \"All tests passed!\"\n\ntestMinChangesToPalindrome()", "output": "minChangesToPalindrome"}, "all_code": "# minChangesToPalindrome calculates the minimum number of digit changes required\n# to make an integer a palindrome. It compares digits from both ends moving towards\n# the center and counts mismatches.\nminChangesToPalindrome = (n) ->\n  s = n.toString()\n  length = s.length\n  changes = 0\n  for i in [0...Math.floor(length / 2)]\n    if s[i] != s[length - 1 - i]\n      changes += 1\n  changes\nassert = require 'assert'\n\ntestMinChangesToPalindrome = ->\n  assert.strictEqual minChangesToPalindrome(12345), 2\n  assert.strictEqual minChangesToPalindrome(12321), 0\n  assert.strictEqual minChangesToPalindrome(123321), 0\n  assert.strictEqual minChangesToPalindrome(123456), 3\n  assert.strictEqual minChangesToPalindrome(1001), 0\n  assert.strictEqual minChangesToPalindrome(1100), 2\n  console.log \"All tests passed!\"\n\ntestMinChangesToPalindrome()", "exec_outcome": "PASSED"}
{"code": "# findMissingInteger identifies the missing integer in a range or the next integer\n# to be added to make the array continuous. It checks each consecutive pair in the array\n# to find where the sequence breaks. If no break is found, it returns the next integer after the last element.\nfindMissingInteger = (testCases) ->\n  results = []\n  for [n, arr] in testCases\n    missing = null\n    for i in [1...n]\n      if arr[i] != arr[i - 1] + 1\n        missing = arr[i - 1] + 1\n        break\n    if missing == null\n      missing = arr[arr.length - 1] + 1\n    results.push(missing)\n  results", "test_cases": "", "test_case_results": "Test Cases:\n  Case 1:\n    Input: n = 5, array = 1,2,3,4,5\n    Missing Integer: 6\n\n  Case 2:\n    Input: n = 5, array = 1,2,3,5,6\n    Missing Integer: 4\n\n  Case 3:\n    Input: n = 4, array = 4,5,6,8\n    Missing Integer: 7\n\n  Case 4:\n    Input: n = 3, array = -1,0,1\n    Missing Integer: 2\n\n  Case 5:\n    Input: n = 2, array = 10,12\n    Missing Integer: 11\n\nAll Test Results:\n[ 6, 4, 7, 2, 11 ]", "task_id": 10737, "assertions": "assert = require 'assert'\n\ntestFindMissingInteger = ->\n  testCases = [\n    [[5, [1, 2, 3, 4, 5]], 6]   # No missing number (should return 6)\n    [[5, [1, 2, 3, 5, 6]], 4]   # Missing 4\n    [[4, [4, 5, 6, 8]], 7]      # Missing 7\n    [[3, [-1, 0, 1]], 2]        # No missing number (should return 2)\n    [[2, [10, 12]], 11]         # Missing 11\n  ]\n  \n  for [input, expected] in testCases\n    actual = findMissingInteger([input])[0]\n    assert.strictEqual actual, expected, \"Test failed for input #{input}. Expected #{expected}, got #{actual}\"\n  \n  # Test batch processing\n  batchInput = [\n    [5, [1, 2, 3, 4, 5]]\n    [5, [1, 2, 3, 5, 6]]\n    [4, [4, 5, 6, 8]]\n    [3, [-1, 0, 1]]\n    [2, [10, 12]]\n  ]\n  batchExpected = [6, 4, 7, 2, 11]\n  batchActual = findMissingInteger(batchInput)\n  assert.deepStrictEqual batchActual, batchExpected, \"Batch test failed. Expected #{batchExpected}, got #{batchActual}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestFindMissingInteger()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindMissingInteger = ->\n  testCases = [\n    [[5, [1, 2, 3, 4, 5]], 6]   # No missing number (should return 6)\n    [[5, [1, 2, 3, 5, 6]], 4]   # Missing 4\n    [[4, [4, 5, 6, 8]], 7]      # Missing 7\n    [[3, [-1, 0, 1]], 2]        # No missing number (should return 2)\n    [[2, [10, 12]], 11]         # Missing 11\n  ]\n  \n  for [input, expected] in testCases\n    actual = findMissingInteger([input])[0]\n    assert.strictEqual actual, expected, \"Test failed for input #{input}. Expected #{expected}, got #{actual}\"\n  \n  # Test batch processing\n  batchInput = [\n    [5, [1, 2, 3, 4, 5]]\n    [5, [1, 2, 3, 5, 6]]\n    [4, [4, 5, 6, 8]]\n    [3, [-1, 0, 1]]\n    [2, [10, 12]]\n  ]\n  batchExpected = [6, 4, 7, 2, 11]\n  batchActual = findMissingInteger(batchInput)\n  assert.deepStrictEqual batchActual, batchExpected, \"Batch test failed. Expected #{batchExpected}, got #{batchActual}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestFindMissingInteger()", "output": "findMissingInteger"}, "all_code": "# findMissingInteger identifies the missing integer in a range or the next integer\n# to be added to make the array continuous. It checks each consecutive pair in the array\n# to find where the sequence breaks. If no break is found, it returns the next integer after the last element.\nfindMissingInteger = (testCases) ->\n  results = []\n  for [n, arr] in testCases\n    missing = null\n    for i in [1...n]\n      if arr[i] != arr[i - 1] + 1\n        missing = arr[i - 1] + 1\n        break\n    if missing == null\n      missing = arr[arr.length - 1] + 1\n    results.push(missing)\n  results\nassert = require 'assert'\n\ntestFindMissingInteger = ->\n  testCases = [\n    [[5, [1, 2, 3, 4, 5]], 6]   # No missing number (should return 6)\n    [[5, [1, 2, 3, 5, 6]], 4]   # Missing 4\n    [[4, [4, 5, 6, 8]], 7]      # Missing 7\n    [[3, [-1, 0, 1]], 2]        # No missing number (should return 2)\n    [[2, [10, 12]], 11]         # Missing 11\n  ]\n  \n  for [input, expected] in testCases\n    actual = findMissingInteger([input])[0]\n    assert.strictEqual actual, expected, \"Test failed for input #{input}. Expected #{expected}, got #{actual}\"\n  \n  # Test batch processing\n  batchInput = [\n    [5, [1, 2, 3, 4, 5]]\n    [5, [1, 2, 3, 5, 6]]\n    [4, [4, 5, 6, 8]]\n    [3, [-1, 0, 1]]\n    [2, [10, 12]]\n  ]\n  batchExpected = [6, 4, 7, 2, 11]\n  batchActual = findMissingInteger(batchInput)\n  assert.deepStrictEqual batchActual, batchExpected, \"Batch test failed. Expected #{batchExpected}, got #{batchActual}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestFindMissingInteger()", "exec_outcome": "PASSED"}
{"code": "# managePermissions processes a list of commands to grant or revoke file permissions for users.\n# It maintains a dictionary tracking each file's permissions per user.\n#\n# Parameters:\n#   commands - Array of command tuples in format [operation, username, filename]\n#             where operation is 'grant' or 'revoke'\n#   permissions - Set of permissions to apply ('read', 'write', 'execute')\n#\n# Returns: Object where keys are filenames, values are objects with usernames as keys\n#          and arrays of their current permissions as values\nmanagePermissions = (commands, permissions) ->\n  result = {}\n\n  for [operation, username, filename] in commands\n    # Initialize file entry if not exists\n    result[filename] ?= {}\n    # Initialize user entry if not exists\n    result[filename][username] ?= []\n\n    if operation is 'grant'\n      # Add permissions, avoiding duplicates\n      for perm in permissions when perm not in result[filename][username]\n        result[filename][username].push(perm)\n    else if operation is 'revoke'\n      # Remove specified permissions\n      result[filename][username] = result[filename][username].filter (perm) -> \n        perm not in permissions\n      # Remove user entry if no permissions left\n      if result[filename][username].length is 0\n        delete result[filename][username]\n\n  return result", "test_cases": "", "test_case_results": "Test Case 1:\nCommands: [\n  [ 'grant', 'user1', 'file1' ],\n  [ 'grant', 'user2', 'file1' ],\n  [ 'revoke', 'user1', 'file1' ]\n]\nPermissions: [ 'read', 'write' ]\nResult: {\n  \"file1\": {\n    \"user2\": [\n      \"read\",\n      \"write\"\n    ]\n  }\n}\n\nTest Case 2:\nCommands: [\n  [ 'grant', 'alice', 'notes.txt' ],\n  [ 'grant', 'bob', 'notes.txt' ],\n  [ 'grant', 'alice', 'notes.txt' ],\n  [ 'revoke', 'bob', 'notes.txt' ]\n]\nPermissions: [ 'read', 'execute' ]\nResult: {\n  \"notes.txt\": {\n    \"alice\": [\n      \"read\",\n      \"execute\"\n    ]\n  }\n}\n\nTest Case 3:\nCommands: [\n  [ 'grant', 'admin', 'system.cfg' ],\n  [ 'revoke', 'admin', 'system.cfg' ],\n  [ 'grant', 'admin', 'system.cfg' ]\n]\nPermissions: [ 'read', 'write', 'execute' ]\nResult: {\n  \"system.cfg\": {\n    \"admin\": [\n      \"read\",\n      \"write\",\n      \"execute\"\n    ]\n  }\n}", "task_id": 10522, "assertions": "assert = require 'assert'\n\ntestManagePermissions = ->\n  # Test Case 1\n  result1 = managePermissions([\n    ['grant', 'user1', 'file1']\n    ['grant', 'user2', 'file1']\n    ['revoke', 'user1', 'file1']\n  ], ['read', 'write'])\n  assert.deepStrictEqual result1, {\n    \"file1\": {\n      \"user2\": [\"read\", \"write\"]\n    }\n  }\n\n  # Test Case 2\n  result2 = managePermissions([\n    ['grant', 'alice', 'notes.txt']\n    ['grant', 'bob', 'notes.txt']\n    ['grant', 'alice', 'notes.txt'] # Duplicate grant\n    ['revoke', 'bob', 'notes.txt']\n  ], ['read', 'execute'])\n  assert.deepStrictEqual result2, {\n    \"notes.txt\": {\n      \"alice\": [\"read\", \"execute\"]\n    }\n  }\n\n  # Test Case 3\n  result3 = managePermissions([\n    ['grant', 'admin', 'system.cfg']\n    ['revoke', 'admin', 'system.cfg']\n    ['grant', 'admin', 'system.cfg']\n  ], ['read', 'write', 'execute'])\n  assert.deepStrictEqual result3, {\n    \"system.cfg\": {\n      \"admin\": [\"read\", \"write\", \"execute\"]\n    }\n  }\n\n  console.log \"All tests passed!\"\n\ntestManagePermissions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestManagePermissions = ->\n  # Test Case 1\n  result1 = managePermissions([\n    ['grant', 'user1', 'file1']\n    ['grant', 'user2', 'file1']\n    ['revoke', 'user1', 'file1']\n  ], ['read', 'write'])\n  assert.deepStrictEqual result1, {\n    \"file1\": {\n      \"user2\": [\"read\", \"write\"]\n    }\n  }\n\n  # Test Case 2\n  result2 = managePermissions([\n    ['grant', 'alice', 'notes.txt']\n    ['grant', 'bob', 'notes.txt']\n    ['grant', 'alice', 'notes.txt'] # Duplicate grant\n    ['revoke', 'bob', 'notes.txt']\n  ], ['read', 'execute'])\n  assert.deepStrictEqual result2, {\n    \"notes.txt\": {\n      \"alice\": [\"read\", \"execute\"]\n    }\n  }\n\n  # Test Case 3\n  result3 = managePermissions([\n    ['grant', 'admin', 'system.cfg']\n    ['revoke', 'admin', 'system.cfg']\n    ['grant', 'admin', 'system.cfg']\n  ], ['read', 'write', 'execute'])\n  assert.deepStrictEqual result3, {\n    \"system.cfg\": {\n      \"admin\": [\"read\", \"write\", \"execute\"]\n    }\n  }\n\n  console.log \"All tests passed!\"\n\ntestManagePermissions()", "output": "managePermissions"}, "all_code": "# managePermissions processes a list of commands to grant or revoke file permissions for users.\n# It maintains a dictionary tracking each file's permissions per user.\n#\n# Parameters:\n#   commands - Array of command tuples in format [operation, username, filename]\n#             where operation is 'grant' or 'revoke'\n#   permissions - Set of permissions to apply ('read', 'write', 'execute')\n#\n# Returns: Object where keys are filenames, values are objects with usernames as keys\n#          and arrays of their current permissions as values\nmanagePermissions = (commands, permissions) ->\n  result = {}\n\n  for [operation, username, filename] in commands\n    # Initialize file entry if not exists\n    result[filename] ?= {}\n    # Initialize user entry if not exists\n    result[filename][username] ?= []\n\n    if operation is 'grant'\n      # Add permissions, avoiding duplicates\n      for perm in permissions when perm not in result[filename][username]\n        result[filename][username].push(perm)\n    else if operation is 'revoke'\n      # Remove specified permissions\n      result[filename][username] = result[filename][username].filter (perm) -> \n        perm not in permissions\n      # Remove user entry if no permissions left\n      if result[filename][username].length is 0\n        delete result[filename][username]\n\n  return result\nassert = require 'assert'\n\ntestManagePermissions = ->\n  # Test Case 1\n  result1 = managePermissions([\n    ['grant', 'user1', 'file1']\n    ['grant', 'user2', 'file1']\n    ['revoke', 'user1', 'file1']\n  ], ['read', 'write'])\n  assert.deepStrictEqual result1, {\n    \"file1\": {\n      \"user2\": [\"read\", \"write\"]\n    }\n  }\n\n  # Test Case 2\n  result2 = managePermissions([\n    ['grant', 'alice', 'notes.txt']\n    ['grant', 'bob', 'notes.txt']\n    ['grant', 'alice', 'notes.txt'] # Duplicate grant\n    ['revoke', 'bob', 'notes.txt']\n  ], ['read', 'execute'])\n  assert.deepStrictEqual result2, {\n    \"notes.txt\": {\n      \"alice\": [\"read\", \"execute\"]\n    }\n  }\n\n  # Test Case 3\n  result3 = managePermissions([\n    ['grant', 'admin', 'system.cfg']\n    ['revoke', 'admin', 'system.cfg']\n    ['grant', 'admin', 'system.cfg']\n  ], ['read', 'write', 'execute'])\n  assert.deepStrictEqual result3, {\n    \"system.cfg\": {\n      \"admin\": [\"read\", \"write\", \"execute\"]\n    }\n  }\n\n  console.log \"All tests passed!\"\n\ntestManagePermissions()", "exec_outcome": "PASSED"}
{"code": "# sumEvenNotMultipleOfThree sums all even numbers in a list that are not multiples of 3.\n# \n# Parameters:\n# numbers (array): Array of integers.\n#\n# Returns:\n# int: Sum of even numbers not divisible by 3.\nsumEvenNotMultipleOfThree = (numbers) ->\n    numbers.reduce (sum, num) ->\n        if num % 2 is 0 and num % 3 isnt 0 then sum + num else sum\n    , 0", "test_cases": "", "test_case_results": "Input: [\n  1, 2,  3,  4, 6,\n  8, 9, 10, 12\n]\nSum: 24\nInput: [ 3, 6, 9, 12 ]\nSum: 0\nInput: [ 2, 4, 5, 7, 8 ]\nSum: 14\nInput: []\nSum: 0\nInput: [ 0, 1, 2, 3 ]\nSum: 2", "task_id": 157, "assertions": "assert = require 'assert'\n\ntestSumEvenNotMultipleOfThree = ->\n    assert.strictEqual sumEvenNotMultipleOfThree([1, 2, 3, 4, 6, 8, 9, 10, 12]), 24\n    assert.strictEqual sumEvenNotMultipleOfThree([3, 6, 9, 12]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([2, 4, 5, 7, 8]), 14\n    assert.strictEqual sumEvenNotMultipleOfThree([]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([0, 1, 2, 3]), 2\n    console.log \"All tests passed!\"\n\ntestSumEvenNotMultipleOfThree()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSumEvenNotMultipleOfThree = ->\n    assert.strictEqual sumEvenNotMultipleOfThree([1, 2, 3, 4, 6, 8, 9, 10, 12]), 24\n    assert.strictEqual sumEvenNotMultipleOfThree([3, 6, 9, 12]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([2, 4, 5, 7, 8]), 14\n    assert.strictEqual sumEvenNotMultipleOfThree([]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([0, 1, 2, 3]), 2\n    console.log \"All tests passed!\"\n\ntestSumEvenNotMultipleOfThree()", "output": "sumEvenNotMultipleOfThree"}, "all_code": "# sumEvenNotMultipleOfThree sums all even numbers in a list that are not multiples of 3.\n# \n# Parameters:\n# numbers (array): Array of integers.\n#\n# Returns:\n# int: Sum of even numbers not divisible by 3.\nsumEvenNotMultipleOfThree = (numbers) ->\n    numbers.reduce (sum, num) ->\n        if num % 2 is 0 and num % 3 isnt 0 then sum + num else sum\n    , 0\nassert = require 'assert'\n\ntestSumEvenNotMultipleOfThree = ->\n    assert.strictEqual sumEvenNotMultipleOfThree([1, 2, 3, 4, 6, 8, 9, 10, 12]), 24\n    assert.strictEqual sumEvenNotMultipleOfThree([3, 6, 9, 12]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([2, 4, 5, 7, 8]), 14\n    assert.strictEqual sumEvenNotMultipleOfThree([]), 0\n    assert.strictEqual sumEvenNotMultipleOfThree([0, 1, 2, 3]), 2\n    console.log \"All tests passed!\"\n\ntestSumEvenNotMultipleOfThree()", "exec_outcome": "PASSED"}
{"code": "# maximizeSum calculates the maximum possible sum of an array after applying operations\n# while respecting upper bounds for each element.\n# Parameters:\n#   n - length of the arrays\n#   arr - array of integers to modify\n#   ops - array of operations that can be applied to each element\n#   B - array of upper bounds for each element\n# Returns:\n#   The maximum possible sum after applying all operations within bounds\nmaximizeSum = (n, arr, ops, B) ->\n  totalSum = 0\n  for i in [0...n]\n    # Calculate new value as minimum between (current + operations) and upper bound\n    newValue = Math.min(arr[i] + ops[i], B[i])\n    totalSum += newValue\n  totalSum", "test_cases": "", "test_case_results": "Test Case 1:\n  Input:\n    n: 3\n    arr: [ 1, 2, 3 ]\n    ops: [ 2, 1, 0 ]\n    B: [ 4, 3, 3 ]\n  Result: 9\n\nTest Case 2:\n  Input:\n    n: 4\n    arr: [ 5, 1, 4, 2 ]\n    ops: [ 3, 2, 1, 4 ]\n    B: [ 7, 3, 5, 6 ]\n  Result: 21\n\nTest Case 3:\n  Input:\n    n: 2\n    arr: [ 0, 0 ]\n    ops: [ 5, 5 ]\n    B: [ 3, 2 ]\n  Result: 5\n\nTest Case 4:\n  Input:\n    n: 1\n    arr: [ 10 ]\n    ops: [ 0 ]\n    B: [ 10 ]\n  Result: 10", "task_id": 16925, "assertions": "assert = require 'assert'\n\ntestMaximizeSum = ->\n  # Test Case 1\n  assert.strictEqual maximizeSum(3, [1, 2, 3], [2, 1, 0], [4, 3, 3]), 9\n  \n  # Test Case 2\n  assert.strictEqual maximizeSum(4, [5, 1, 4, 2], [3, 2, 1, 4], [7, 3, 5, 6]), 21\n  \n  # Test Case 3\n  assert.strictEqual maximizeSum(2, [0, 0], [5, 5], [3, 2]), 5\n  \n  # Test Case 4\n  assert.strictEqual maximizeSum(1, [10], [0], [10]), 10\n  \n  console.log \"All tests passed!\"\n\ntestMaximizeSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaximizeSum = ->\n  # Test Case 1\n  assert.strictEqual maximizeSum(3, [1, 2, 3], [2, 1, 0], [4, 3, 3]), 9\n  \n  # Test Case 2\n  assert.strictEqual maximizeSum(4, [5, 1, 4, 2], [3, 2, 1, 4], [7, 3, 5, 6]), 21\n  \n  # Test Case 3\n  assert.strictEqual maximizeSum(2, [0, 0], [5, 5], [3, 2]), 5\n  \n  # Test Case 4\n  assert.strictEqual maximizeSum(1, [10], [0], [10]), 10\n  \n  console.log \"All tests passed!\"\n\ntestMaximizeSum()", "output": "maximizeSum"}, "all_code": "# maximizeSum calculates the maximum possible sum of an array after applying operations\n# while respecting upper bounds for each element.\n# Parameters:\n#   n - length of the arrays\n#   arr - array of integers to modify\n#   ops - array of operations that can be applied to each element\n#   B - array of upper bounds for each element\n# Returns:\n#   The maximum possible sum after applying all operations within bounds\nmaximizeSum = (n, arr, ops, B) ->\n  totalSum = 0\n  for i in [0...n]\n    # Calculate new value as minimum between (current + operations) and upper bound\n    newValue = Math.min(arr[i] + ops[i], B[i])\n    totalSum += newValue\n  totalSum\nassert = require 'assert'\n\ntestMaximizeSum = ->\n  # Test Case 1\n  assert.strictEqual maximizeSum(3, [1, 2, 3], [2, 1, 0], [4, 3, 3]), 9\n  \n  # Test Case 2\n  assert.strictEqual maximizeSum(4, [5, 1, 4, 2], [3, 2, 1, 4], [7, 3, 5, 6]), 21\n  \n  # Test Case 3\n  assert.strictEqual maximizeSum(2, [0, 0], [5, 5], [3, 2]), 5\n  \n  # Test Case 4\n  assert.strictEqual maximizeSum(1, [10], [0], [10]), 10\n  \n  console.log \"All tests passed!\"\n\ntestMaximizeSum()", "exec_outcome": "PASSED"}
{"code": "# convertListToInteger converts a list of integers into a single integer by concatenating the numbers.\n# Example: [1, 2, 3] becomes 123\nconvertListToInteger = (lst) ->\n    # Initialize an empty string to store the integer values as strings\n    strLst = ''\n    \n    # Iterate through each integer in the list\n    for integer in lst\n        # Convert the integer to a string and add it to strLst\n        strLst += integer.toString()\n    \n    # Convert the string of concatenated integers back into an integer\n    parseInt(strLst, 10)", "test_cases": "", "test_case_results": "Input: [ 1, 2, 3, 4 ]\nResult: 1234\n\nInput: [ 0, 5, 1, 2 ]\nResult: 512\n\nInput: [ 9, 9, 9 ]\nResult: 999\n\nInput: [ 1, 0, 0, 0 ]\nResult: 1000\n\nInput: [ 0, 0, 1 ]\nResult: 1", "task_id": 29692, "assertions": "assert = require 'assert'\n\ntestConvertListToInteger = ->\n  assert.strictEqual convertListToInteger([1, 2, 3, 4]), 1234\n  assert.strictEqual convertListToInteger([0, 5, 1, 2]), 512\n  assert.strictEqual convertListToInteger([9, 9, 9]), 999\n  assert.strictEqual convertListToInteger([1, 0, 0, 0]), 1000\n  assert.strictEqual convertListToInteger([0, 0, 1]), 1\n  console.log \"All tests passed!\"\n\ntestConvertListToInteger()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestConvertListToInteger = ->\n  assert.strictEqual convertListToInteger([1, 2, 3, 4]), 1234\n  assert.strictEqual convertListToInteger([0, 5, 1, 2]), 512\n  assert.strictEqual convertListToInteger([9, 9, 9]), 999\n  assert.strictEqual convertListToInteger([1, 0, 0, 0]), 1000\n  assert.strictEqual convertListToInteger([0, 0, 1]), 1\n  console.log \"All tests passed!\"\n\ntestConvertListToInteger()", "output": "convertListToInteger"}, "all_code": "# convertListToInteger converts a list of integers into a single integer by concatenating the numbers.\n# Example: [1, 2, 3] becomes 123\nconvertListToInteger = (lst) ->\n    # Initialize an empty string to store the integer values as strings\n    strLst = ''\n    \n    # Iterate through each integer in the list\n    for integer in lst\n        # Convert the integer to a string and add it to strLst\n        strLst += integer.toString()\n    \n    # Convert the string of concatenated integers back into an integer\n    parseInt(strLst, 10)\nassert = require 'assert'\n\ntestConvertListToInteger = ->\n  assert.strictEqual convertListToInteger([1, 2, 3, 4]), 1234\n  assert.strictEqual convertListToInteger([0, 5, 1, 2]), 512\n  assert.strictEqual convertListToInteger([9, 9, 9]), 999\n  assert.strictEqual convertListToInteger([1, 0, 0, 0]), 1000\n  assert.strictEqual convertListToInteger([0, 0, 1]), 1\n  console.log \"All tests passed!\"\n\ntestConvertListToInteger()", "exec_outcome": "PASSED"}
{"code": "# partitionList divides a list of integers into two sublists:\n# one containing elements divisible by a given divisor, and the other containing the remaining elements.\n# Returns a tuple of two arrays: [divisible, notDivisible]\npartitionList = (nums, divisor) ->\n    divisible = (num for num in nums when num % divisor is 0)\n    notDivisible = (num for num in nums when num % divisor isnt 0)\n    [divisible, notDivisible]", "test_cases": "", "test_case_results": "Input: { nums: [ 1, 2, 3, 4, 5, 6 ], divisor: 2 }\nDivisible: [ 2, 4, 6 ]\nNot Divisible: [ 1, 3, 5 ]\n---\nInput: { nums: [ 10, 15, 20, 25, 30 ], divisor: 5 }\nDivisible: [ 10, 15, 20, 25, 30 ]\nNot Divisible: []\n---\nInput: { nums: [ 0, 7, 14, 21, 28 ], divisor: 7 }\nDivisible: [ 0, 7, 14, 21, 28 ]\nNot Divisible: []\n---\nInput: { nums: [ 3, 6, 9, 12 ], divisor: 4 }\nDivisible: [ 12 ]\nNot Divisible: [ 3, 6, 9 ]\n---", "task_id": 5057, "assertions": "assert = require 'assert'\n\ntestPartitionList = ->\n    # Test case 1\n    [divisible, notDivisible] = partitionList([1, 2, 3, 4, 5, 6], 2)\n    assert.deepStrictEqual divisible, [2, 4, 6]\n    assert.deepStrictEqual notDivisible, [1, 3, 5]\n    \n    # Test case 2\n    [divisible, notDivisible] = partitionList([10, 15, 20, 25, 30], 5)\n    assert.deepStrictEqual divisible, [10, 15, 20, 25, 30]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 3\n    [divisible, notDivisible] = partitionList([0, 7, 14, 21, 28], 7)\n    assert.deepStrictEqual divisible, [0, 7, 14, 21, 28]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 4\n    [divisible, notDivisible] = partitionList([3, 6, 9, 12], 4)\n    assert.deepStrictEqual divisible, [12]\n    assert.deepStrictEqual notDivisible, [3, 6, 9]\n\ntestPartitionList()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestPartitionList = ->\n    # Test case 1\n    [divisible, notDivisible] = partitionList([1, 2, 3, 4, 5, 6], 2)\n    assert.deepStrictEqual divisible, [2, 4, 6]\n    assert.deepStrictEqual notDivisible, [1, 3, 5]\n    \n    # Test case 2\n    [divisible, notDivisible] = partitionList([10, 15, 20, 25, 30], 5)\n    assert.deepStrictEqual divisible, [10, 15, 20, 25, 30]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 3\n    [divisible, notDivisible] = partitionList([0, 7, 14, 21, 28], 7)\n    assert.deepStrictEqual divisible, [0, 7, 14, 21, 28]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 4\n    [divisible, notDivisible] = partitionList([3, 6, 9, 12], 4)\n    assert.deepStrictEqual divisible, [12]\n    assert.deepStrictEqual notDivisible, [3, 6, 9]\n\ntestPartitionList()", "output": "partitionList"}, "all_code": "# partitionList divides a list of integers into two sublists:\n# one containing elements divisible by a given divisor, and the other containing the remaining elements.\n# Returns a tuple of two arrays: [divisible, notDivisible]\npartitionList = (nums, divisor) ->\n    divisible = (num for num in nums when num % divisor is 0)\n    notDivisible = (num for num in nums when num % divisor isnt 0)\n    [divisible, notDivisible]\nassert = require 'assert'\n\ntestPartitionList = ->\n    # Test case 1\n    [divisible, notDivisible] = partitionList([1, 2, 3, 4, 5, 6], 2)\n    assert.deepStrictEqual divisible, [2, 4, 6]\n    assert.deepStrictEqual notDivisible, [1, 3, 5]\n    \n    # Test case 2\n    [divisible, notDivisible] = partitionList([10, 15, 20, 25, 30], 5)\n    assert.deepStrictEqual divisible, [10, 15, 20, 25, 30]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 3\n    [divisible, notDivisible] = partitionList([0, 7, 14, 21, 28], 7)\n    assert.deepStrictEqual divisible, [0, 7, 14, 21, 28]\n    assert.deepStrictEqual notDivisible, []\n    \n    # Test case 4\n    [divisible, notDivisible] = partitionList([3, 6, 9, 12], 4)\n    assert.deepStrictEqual divisible, [12]\n    assert.deepStrictEqual notDivisible, [3, 6, 9]\n\ntestPartitionList()", "exec_outcome": "PASSED"}
{"code": "# findKthSmallest finds the k-th smallest element in an array by first sorting it.\n# \n# Parameters:\n# - array: the input array of numbers\n# - k: the position of the k-th smallest element to return (1-based index)\n#\n# Returns:\n# - the k-th smallest element in the array\nfindKthSmallest = (array, k) ->\n  # Create a sorted copy of the array to avoid modifying the original\n  sortedArray = array.slice().sort (a, b) -> a - b\n  sortedArray[k - 1]", "test_cases": "", "test_case_results": "Input array: [\n  3, 1, 4, 1,\n  5, 9, 2, 6\n]\nk: 3\nk-th smallest element: 2\n---\nInput array: [ 10, 20, 30, 40, 50 ]\nk: 1\nk-th smallest element: 10\n---\nInput array: [ 5, 4, 3, 2, 1 ]\nk: 5\nk-th smallest element: 5\n---\nInput array: [ 7 ]\nk: 1\nk-th smallest element: 7\n---\nInput array: [\n  9, 8, 7, 6, 5,\n  4, 3, 2, 1\n]\nk: 9\nk-th smallest element: 9\n---", "task_id": 18041, "assertions": "assert = require 'assert'\n\ntestFindKthSmallest = ->\n  assert.strictEqual findKthSmallest([3, 1, 4, 1, 5, 9, 2, 6], 3), 2\n  assert.strictEqual findKthSmallest([10, 20, 30, 40, 50], 1), 10\n  assert.strictEqual findKthSmallest([5, 4, 3, 2, 1], 5), 5\n  assert.strictEqual findKthSmallest([7], 1), 7\n  assert.strictEqual findKthSmallest([9, 8, 7, 6, 5, 4, 3, 2, 1], 9), 9\n  console.log \"All tests passed!\"\n\ntestFindKthSmallest()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindKthSmallest = ->\n  assert.strictEqual findKthSmallest([3, 1, 4, 1, 5, 9, 2, 6], 3), 2\n  assert.strictEqual findKthSmallest([10, 20, 30, 40, 50], 1), 10\n  assert.strictEqual findKthSmallest([5, 4, 3, 2, 1], 5), 5\n  assert.strictEqual findKthSmallest([7], 1), 7\n  assert.strictEqual findKthSmallest([9, 8, 7, 6, 5, 4, 3, 2, 1], 9), 9\n  console.log \"All tests passed!\"\n\ntestFindKthSmallest()", "output": "findKthSmallest"}, "all_code": "# findKthSmallest finds the k-th smallest element in an array by first sorting it.\n# \n# Parameters:\n# - array: the input array of numbers\n# - k: the position of the k-th smallest element to return (1-based index)\n#\n# Returns:\n# - the k-th smallest element in the array\nfindKthSmallest = (array, k) ->\n  # Create a sorted copy of the array to avoid modifying the original\n  sortedArray = array.slice().sort (a, b) -> a - b\n  sortedArray[k - 1]\nassert = require 'assert'\n\ntestFindKthSmallest = ->\n  assert.strictEqual findKthSmallest([3, 1, 4, 1, 5, 9, 2, 6], 3), 2\n  assert.strictEqual findKthSmallest([10, 20, 30, 40, 50], 1), 10\n  assert.strictEqual findKthSmallest([5, 4, 3, 2, 1], 5), 5\n  assert.strictEqual findKthSmallest([7], 1), 7\n  assert.strictEqual findKthSmallest([9, 8, 7, 6, 5, 4, 3, 2, 1], 9), 9\n  console.log \"All tests passed!\"\n\ntestFindKthSmallest()", "exec_outcome": "PASSED"}
{"code": "# calculateVisibility computes the visibility score for each building in a skyline.\n# The visibility score for each building is the count of buildings to the left\n# (including itself) that are shorter than or equal to its height.\ncalculateVisibility = (heights) ->\n  # Initialize an empty result array to store visibility scores\n  visibility = []\n  \n  # Stack to keep track of visible buildings' heights and their counts\n  stack = []\n  \n  for height in heights\n    # Initialize visibility count for the current building\n    currentVisibility = 1\n    \n    # Stack elements are [building height, visibility count of the height]\n    while stack.length and stack[stack.length - 1][0] <= height\n      currentVisibility += stack.pop()[1]\n    \n    # Push the current building and its visibility count to the stack\n    stack.push([height, currentVisibility])\n    \n    # Add the current visibility count to the result array\n    visibility.push(currentVisibility)\n  \n  visibility", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Heights: [ 1, 2, 3, 4 ]\n  Visibility Scores: [ 1, 2, 3, 4 ]\n\nTest Case 2:\n  Input Heights: [ 4, 3, 2, 1 ]\n  Visibility Scores: [ 1, 1, 1, 1 ]\n\nTest Case 3:\n  Input Heights: [ 5, 1, 2, 3, 4 ]\n  Visibility Scores: [ 1, 1, 2, 3, 4 ]\n\nTest Case 4:\n  Input Heights: [ 2, 2, 2, 2 ]\n  Visibility Scores: [ 1, 2, 3, 4 ]\n\nTest Case 5:\n  Input Heights: [ 1, 3, 2, 4, 1, 5 ]\n  Visibility Scores: [ 1, 2, 1, 4, 1, 6 ]\n\nTest Case 6:\n  Input Heights: []\n  Visibility Scores: []", "task_id": 4192, "assertions": "assert = require 'assert'\n\ntestCalculateVisibility = ->\n  assert.deepStrictEqual calculateVisibility([1, 2, 3, 4]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([4, 3, 2, 1]), [1, 1, 1, 1]\n  assert.deepStrictEqual calculateVisibility([5, 1, 2, 3, 4]), [1, 1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([2, 2, 2, 2]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([1, 3, 2, 4, 1, 5]), [1, 2, 1, 4, 1, 6]\n  assert.deepStrictEqual calculateVisibility([]), []\n\n  console.log \"All tests passed!\"\n\ntestCalculateVisibility()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCalculateVisibility = ->\n  assert.deepStrictEqual calculateVisibility([1, 2, 3, 4]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([4, 3, 2, 1]), [1, 1, 1, 1]\n  assert.deepStrictEqual calculateVisibility([5, 1, 2, 3, 4]), [1, 1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([2, 2, 2, 2]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([1, 3, 2, 4, 1, 5]), [1, 2, 1, 4, 1, 6]\n  assert.deepStrictEqual calculateVisibility([]), []\n\n  console.log \"All tests passed!\"\n\ntestCalculateVisibility()", "output": "calculateVisibility"}, "all_code": "# calculateVisibility computes the visibility score for each building in a skyline.\n# The visibility score for each building is the count of buildings to the left\n# (including itself) that are shorter than or equal to its height.\ncalculateVisibility = (heights) ->\n  # Initialize an empty result array to store visibility scores\n  visibility = []\n  \n  # Stack to keep track of visible buildings' heights and their counts\n  stack = []\n  \n  for height in heights\n    # Initialize visibility count for the current building\n    currentVisibility = 1\n    \n    # Stack elements are [building height, visibility count of the height]\n    while stack.length and stack[stack.length - 1][0] <= height\n      currentVisibility += stack.pop()[1]\n    \n    # Push the current building and its visibility count to the stack\n    stack.push([height, currentVisibility])\n    \n    # Add the current visibility count to the result array\n    visibility.push(currentVisibility)\n  \n  visibility\nassert = require 'assert'\n\ntestCalculateVisibility = ->\n  assert.deepStrictEqual calculateVisibility([1, 2, 3, 4]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([4, 3, 2, 1]), [1, 1, 1, 1]\n  assert.deepStrictEqual calculateVisibility([5, 1, 2, 3, 4]), [1, 1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([2, 2, 2, 2]), [1, 2, 3, 4]\n  assert.deepStrictEqual calculateVisibility([1, 3, 2, 4, 1, 5]), [1, 2, 1, 4, 1, 6]\n  assert.deepStrictEqual calculateVisibility([]), []\n\n  console.log \"All tests passed!\"\n\ntestCalculateVisibility()", "exec_outcome": "PASSED"}
{"code": "# checkSubarraySum determines if there's a continuous subarray of length >= 2 that sums to a multiple of k\n# Uses a hash map to store mod values and their indices for O(n) time complexity\ncheckSubarraySum = (nums, k) ->\n  # Handle special case when k is 0\n  if k is 0\n    for i in [0...nums.length - 1]\n      if nums[i] + nums[i + 1] is 0\n        return true\n    return false\n\n  cumulativeSum = 0\n  modDict = {0: -1}  # Initialize with mod 0 at index -1\n\n  for num, i in nums\n    cumulativeSum += num\n    mod = cumulativeSum %% k  # CoffeeScript's modulo operator\n\n    if mod of modDict\n      # Check if subarray length is at least 2\n      if i - modDict[mod] > 1\n        return true\n    else\n      modDict[mod] = i  # Store first occurrence of this mod\n\n  return false", "test_cases": "", "test_case_results": "Test case:\n  nums: [ 23, 2, 4, 6, 7 ]\n  k: 6\n  Result: true\n  Expected: true\n  Test: PASSED\n\nTest case:\n  nums: [ 23, 2, 6, 4, 7 ]\n  k: 6\n  Result: true\n  Expected: true\n  Test: PASSED\n\nTest case:\n  nums: [ 23, 2, 6, 4, 7 ]\n  k: 13\n  Result: false\n  Expected: false\n  Test: PASSED\n\nTest case:\n  nums: [ 0, 0 ]\n  k: 0\n  Result: true\n  Expected: true\n  Test: PASSED\n\nTest case:\n  nums: [ 1, 0 ]\n  k: 2\n  Result: false\n  Expected: false\n  Test: PASSED\n\nTest case:\n  nums: [ 1, 2, 3 ]\n  k: 5\n  Result: true\n  Expected: true\n  Test: PASSED\n\nTest case:\n  nums: []\n  k: 1\n  Result: false\n  Expected: false\n  Test: PASSED\n\nTest case:\n  nums: [ 5, 0, 0 ]\n  k: 0\n  Result: true\n  Expected: true\n  Test: PASSED", "task_id": 16686, "assertions": "assert = require 'assert'\n\ntestCheckSubarraySum = ->\n  assert.strictEqual checkSubarraySum([23, 2, 4, 6, 7], 6), true    # [2,4] sums to 6\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 6), true    # [23,2,6,4,7] sums to 42\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 13), false  # No valid subarray\n  assert.strictEqual checkSubarraySum([0, 0], 0), true              # [0,0] sums to 0\n  assert.strictEqual checkSubarraySum([1, 0], 2), false             # No valid subarray\n  assert.strictEqual checkSubarraySum([1, 2, 3], 5), true           # [2,3] sums to 5\n  assert.strictEqual checkSubarraySum([], 1), false                 # Empty array\n  assert.strictEqual checkSubarraySum([5, 0, 0], 0), true           # [0,0] sums to 0\n\ntestCheckSubarraySum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCheckSubarraySum = ->\n  assert.strictEqual checkSubarraySum([23, 2, 4, 6, 7], 6), true    # [2,4] sums to 6\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 6), true    # [23,2,6,4,7] sums to 42\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 13), false  # No valid subarray\n  assert.strictEqual checkSubarraySum([0, 0], 0), true              # [0,0] sums to 0\n  assert.strictEqual checkSubarraySum([1, 0], 2), false             # No valid subarray\n  assert.strictEqual checkSubarraySum([1, 2, 3], 5), true           # [2,3] sums to 5\n  assert.strictEqual checkSubarraySum([], 1), false                 # Empty array\n  assert.strictEqual checkSubarraySum([5, 0, 0], 0), true           # [0,0] sums to 0\n\ntestCheckSubarraySum()", "output": "checkSubarraySum"}, "all_code": "# checkSubarraySum determines if there's a continuous subarray of length >= 2 that sums to a multiple of k\n# Uses a hash map to store mod values and their indices for O(n) time complexity\ncheckSubarraySum = (nums, k) ->\n  # Handle special case when k is 0\n  if k is 0\n    for i in [0...nums.length - 1]\n      if nums[i] + nums[i + 1] is 0\n        return true\n    return false\n\n  cumulativeSum = 0\n  modDict = {0: -1}  # Initialize with mod 0 at index -1\n\n  for num, i in nums\n    cumulativeSum += num\n    mod = cumulativeSum %% k  # CoffeeScript's modulo operator\n\n    if mod of modDict\n      # Check if subarray length is at least 2\n      if i - modDict[mod] > 1\n        return true\n    else\n      modDict[mod] = i  # Store first occurrence of this mod\n\n  return false\nassert = require 'assert'\n\ntestCheckSubarraySum = ->\n  assert.strictEqual checkSubarraySum([23, 2, 4, 6, 7], 6), true    # [2,4] sums to 6\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 6), true    # [23,2,6,4,7] sums to 42\n  assert.strictEqual checkSubarraySum([23, 2, 6, 4, 7], 13), false  # No valid subarray\n  assert.strictEqual checkSubarraySum([0, 0], 0), true              # [0,0] sums to 0\n  assert.strictEqual checkSubarraySum([1, 0], 2), false             # No valid subarray\n  assert.strictEqual checkSubarraySum([1, 2, 3], 5), true           # [2,3] sums to 5\n  assert.strictEqual checkSubarraySum([], 1), false                 # Empty array\n  assert.strictEqual checkSubarraySum([5, 0, 0], 0), true           # [0,0] sums to 0\n\ntestCheckSubarraySum()", "exec_outcome": "PASSED"}
{"code": "# findAndReplace replaces all whole-word occurrences of target with replacement in paragraph,\n# while respecting case insensitivity and word boundaries.\nfindAndReplace = (paragraph, target, replacement) ->\n  # Create a regex pattern that matches the target word with word boundaries, case insensitive\n  pattern = new RegExp(\"\\\\b#{escapeRegExp(target)}\\\\b\", \"gi\")\n  # Replace all occurrences of the pattern with the replacement word\n  paragraph.replace(pattern, replacement)\n\n# Helper function to escape special regex characters in the target string\nescapeRegExp = (string) ->\n  string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')", "test_cases": "", "test_case_results": "Test Case 1:\nOriginal: The quick brown fox jumps over the lazy dog. The quick fox is fast.\nTarget: fox\nReplacement: cat\nResult: The quick brown cat jumps over the lazy dog. The quick cat is fast.\n---\nTest Case 2:\nOriginal: Hello world, hello universe, hello everyone!\nTarget: hello\nReplacement: hi\nResult: hi world, hi universe, hi everyone!\n---\nTest Case 3:\nOriginal: These are some words: words, sword, wordy, wording.\nTarget: words\nReplacement: terms\nResult: These are some terms: terms, sword, wordy, wording.\n---\nTest Case 4:\nOriginal: Case sensitivity test: Apple, apple, APPLE.\nTarget: apple\nReplacement: orange\nResult: Case sensitivity test: orange, orange, orange.\n---", "task_id": 26177, "assertions": "assert = require 'assert'\n\ntestFindAndReplace = ->\n  # Test Case 1: Basic replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"The quick brown fox jumps over the lazy dog. The quick fox is fast.\",\n      \"fox\",\n      \"cat\"\n    ),\n    \"The quick brown cat jumps over the lazy dog. The quick cat is fast.\"\n  )\n  \n  # Test Case 2: Case insensitive replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"Hello world, hello universe, hello everyone!\",\n      \"hello\",\n      \"hi\"\n    ),\n    \"hi world, hi universe, hi everyone!\"\n  )\n  \n  # Test Case 3: Word boundary check\n  assert.strictEqual(\n    findAndReplace(\n      \"These are some words: words, sword, wordy, wording.\",\n      \"words\",\n      \"terms\"\n    ),\n    \"These are some terms: terms, sword, wordy, wording.\"\n  )\n  \n  # Test Case 4: Case sensitivity test\n  assert.strictEqual(\n    findAndReplace(\n      \"Case sensitivity test: Apple, apple, APPLE.\",\n      \"apple\",\n      \"orange\"\n    ),\n    \"Case sensitivity test: orange, orange, orange.\"\n  )\n\ntestFindAndReplace()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindAndReplace = ->\n  # Test Case 1: Basic replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"The quick brown fox jumps over the lazy dog. The quick fox is fast.\",\n      \"fox\",\n      \"cat\"\n    ),\n    \"The quick brown cat jumps over the lazy dog. The quick cat is fast.\"\n  )\n  \n  # Test Case 2: Case insensitive replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"Hello world, hello universe, hello everyone!\",\n      \"hello\",\n      \"hi\"\n    ),\n    \"hi world, hi universe, hi everyone!\"\n  )\n  \n  # Test Case 3: Word boundary check\n  assert.strictEqual(\n    findAndReplace(\n      \"These are some words: words, sword, wordy, wording.\",\n      \"words\",\n      \"terms\"\n    ),\n    \"These are some terms: terms, sword, wordy, wording.\"\n  )\n  \n  # Test Case 4: Case sensitivity test\n  assert.strictEqual(\n    findAndReplace(\n      \"Case sensitivity test: Apple, apple, APPLE.\",\n      \"apple\",\n      \"orange\"\n    ),\n    \"Case sensitivity test: orange, orange, orange.\"\n  )\n\ntestFindAndReplace()", "output": "findAndReplace"}, "all_code": "# findAndReplace replaces all whole-word occurrences of target with replacement in paragraph,\n# while respecting case insensitivity and word boundaries.\nfindAndReplace = (paragraph, target, replacement) ->\n  # Create a regex pattern that matches the target word with word boundaries, case insensitive\n  pattern = new RegExp(\"\\\\b#{escapeRegExp(target)}\\\\b\", \"gi\")\n  # Replace all occurrences of the pattern with the replacement word\n  paragraph.replace(pattern, replacement)\n\n# Helper function to escape special regex characters in the target string\nescapeRegExp = (string) ->\n  string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\nassert = require 'assert'\n\ntestFindAndReplace = ->\n  # Test Case 1: Basic replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"The quick brown fox jumps over the lazy dog. The quick fox is fast.\",\n      \"fox\",\n      \"cat\"\n    ),\n    \"The quick brown cat jumps over the lazy dog. The quick cat is fast.\"\n  )\n  \n  # Test Case 2: Case insensitive replacement\n  assert.strictEqual(\n    findAndReplace(\n      \"Hello world, hello universe, hello everyone!\",\n      \"hello\",\n      \"hi\"\n    ),\n    \"hi world, hi universe, hi everyone!\"\n  )\n  \n  # Test Case 3: Word boundary check\n  assert.strictEqual(\n    findAndReplace(\n      \"These are some words: words, sword, wordy, wording.\",\n      \"words\",\n      \"terms\"\n    ),\n    \"These are some terms: terms, sword, wordy, wording.\"\n  )\n  \n  # Test Case 4: Case sensitivity test\n  assert.strictEqual(\n    findAndReplace(\n      \"Case sensitivity test: Apple, apple, APPLE.\",\n      \"apple\",\n      \"orange\"\n    ),\n    \"Case sensitivity test: orange, orange, orange.\"\n  )\n\ntestFindAndReplace()", "exec_outcome": "PASSED"}
{"code": "# maxTotalWeight calculates the maximum total weight of containers that can be loaded onto ships\n# without exceeding their weight capacities. It uses a greedy algorithm approach by:\n# 1. Sorting ships and containers in descending order\n# 2. Loading the heaviest available container onto the most capacious available ship\n#\n# @param s [Number] number of ships\n# @param c [Number] number of containers\n# @param ships [Array<Number>] capacities of the ships\n# @param containers [Array<Number>] weights of the containers\n# @return [Number] maximum total weight of containers loaded onto the ships\nmaxTotalWeight = (s, c, ships, containers) ->\n  # Sort ship capacities in decreasing order\n  ships.sort (a, b) -> b - a\n  \n  # Sort container weights in decreasing order\n  containers.sort (a, b) -> b - a\n  \n  totalWeight = 0\n  containerIndex = 0\n  \n  # Iterate through each ship\n  for ship in ships\n    currentLoad = 0\n    \n    # Try to load as many containers as possible onto the current ship\n    while containerIndex < c and currentLoad + containers[containerIndex] <= ship\n      currentLoad += containers[containerIndex]\n      totalWeight += containers[containerIndex]\n      containerIndex += 1\n  \n  totalWeight", "test_cases": "", "test_case_results": "Test Case: Basic case with equal numbers\nShips: [ 10, 5 ]\nContainers: [ 4, 3, 2 ]\nMaximum Total Weight: 9\n---\nTest Case: More containers than ships\nShips: [ 15, 10 ]\nContainers: [ 8, 6, 5, 4, 2 ]\nMaximum Total Weight: 23\n---\nTest Case: More ships than containers\nShips: [ 20, 15, 10, 5 ]\nContainers: [ 12, 8 ]\nMaximum Total Weight: 20\n---\nTest Case: Single ship and container\nShips: [ 10 ]\nContainers: [ 7 ]\nMaximum Total Weight: 7\n---\nTest Case: Container too heavy for any ship\nShips: [ 5, 3 ]\nContainers: [ 6, 2, 1 ]\nMaximum Total Weight: 0\n---", "task_id": 15403, "assertions": "assert = require 'assert'\n\ntestMaxTotalWeight = ->\n  # Test case 1: Basic case with equal numbers\n  assert.strictEqual maxTotalWeight(2, 3, [10, 5], [4, 3, 2]), 9\n  \n  # Test case 2: More containers than ships\n  assert.strictEqual maxTotalWeight(2, 5, [15, 10], [8, 6, 5, 4, 2]), 23\n  \n  # Test case 3: More ships than containers\n  assert.strictEqual maxTotalWeight(4, 2, [20, 15, 10, 5], [12, 8]), 20\n  \n  # Test case 4: Single ship and container\n  assert.strictEqual maxTotalWeight(1, 1, [10], [7]), 7\n  \n  # Test case 5: Container too heavy for any ship\n  assert.strictEqual maxTotalWeight(2, 3, [5, 3], [6, 2, 1]), 0\n\ntestMaxTotalWeight()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxTotalWeight = ->\n  # Test case 1: Basic case with equal numbers\n  assert.strictEqual maxTotalWeight(2, 3, [10, 5], [4, 3, 2]), 9\n  \n  # Test case 2: More containers than ships\n  assert.strictEqual maxTotalWeight(2, 5, [15, 10], [8, 6, 5, 4, 2]), 23\n  \n  # Test case 3: More ships than containers\n  assert.strictEqual maxTotalWeight(4, 2, [20, 15, 10, 5], [12, 8]), 20\n  \n  # Test case 4: Single ship and container\n  assert.strictEqual maxTotalWeight(1, 1, [10], [7]), 7\n  \n  # Test case 5: Container too heavy for any ship\n  assert.strictEqual maxTotalWeight(2, 3, [5, 3], [6, 2, 1]), 0\n\ntestMaxTotalWeight()", "output": "maxTotalWeight"}, "all_code": "# maxTotalWeight calculates the maximum total weight of containers that can be loaded onto ships\n# without exceeding their weight capacities. It uses a greedy algorithm approach by:\n# 1. Sorting ships and containers in descending order\n# 2. Loading the heaviest available container onto the most capacious available ship\n#\n# @param s [Number] number of ships\n# @param c [Number] number of containers\n# @param ships [Array<Number>] capacities of the ships\n# @param containers [Array<Number>] weights of the containers\n# @return [Number] maximum total weight of containers loaded onto the ships\nmaxTotalWeight = (s, c, ships, containers) ->\n  # Sort ship capacities in decreasing order\n  ships.sort (a, b) -> b - a\n  \n  # Sort container weights in decreasing order\n  containers.sort (a, b) -> b - a\n  \n  totalWeight = 0\n  containerIndex = 0\n  \n  # Iterate through each ship\n  for ship in ships\n    currentLoad = 0\n    \n    # Try to load as many containers as possible onto the current ship\n    while containerIndex < c and currentLoad + containers[containerIndex] <= ship\n      currentLoad += containers[containerIndex]\n      totalWeight += containers[containerIndex]\n      containerIndex += 1\n  \n  totalWeight\nassert = require 'assert'\n\ntestMaxTotalWeight = ->\n  # Test case 1: Basic case with equal numbers\n  assert.strictEqual maxTotalWeight(2, 3, [10, 5], [4, 3, 2]), 9\n  \n  # Test case 2: More containers than ships\n  assert.strictEqual maxTotalWeight(2, 5, [15, 10], [8, 6, 5, 4, 2]), 23\n  \n  # Test case 3: More ships than containers\n  assert.strictEqual maxTotalWeight(4, 2, [20, 15, 10, 5], [12, 8]), 20\n  \n  # Test case 4: Single ship and container\n  assert.strictEqual maxTotalWeight(1, 1, [10], [7]), 7\n  \n  # Test case 5: Container too heavy for any ship\n  assert.strictEqual maxTotalWeight(2, 3, [5, 3], [6, 2, 1]), 0\n\ntestMaxTotalWeight()", "exec_outcome": "PASSED"}
{"code": "# Checks if the provided password meets the UCT Password Function (PWF) criteria.\n# Criteria include:\n# - At least 8 characters long\n# - At least one uppercase letter\n# - At least one lowercase letter\n# - At least one number\n# - At least one special character\nisValidPassword = (password) ->\n  # Check minimum length requirement\n  return false if password.length < 8\n  \n  # Check for at least one uppercase letter\n  return false unless /[A-Z]/.test(password)\n  \n  # Check for at least one lowercase letter\n  return false unless /[a-z]/.test(password)\n  \n  # Check for at least one number\n  return false unless /\\d/.test(password)\n  \n  # Check for at least one special character\n  return false unless /[!@#$%^&*(),.?\":{}|<>]/.test(password)\n  \n  # All checks passed\n  true", "test_cases": "", "test_case_results": "Password: Short1!\nIs valid: false\n---\nPassword: nouppercase1!\nIs valid: false\n---\nPassword: NOLOWERCASE1!\nIs valid: false\n---\nPassword: NoNumbersHere!\nIs valid: false\n---\nPassword: MissingSpecialChars123\nIs valid: false\n---\nPassword: ValidPass123!\nIs valid: true\n---\nPassword: Another!Good1\nIs valid: true\n---\nPassword: !@#ABCabc123\nIs valid: true\n---\nPassword: \nIs valid: false\n---\nPassword: 12345678\nIs valid: false\n---\nPassword: ABCDEFGH\nIs valid: false\n---\nPassword: abcdefgh\nIs valid: false\n---\nPassword: !@#$%^&*\nIs valid: false\n---", "task_id": 7013, "assertions": "assert = require 'assert'\n\ntestPasswordValidation = ->\n  # Test invalid passwords\n  assert.strictEqual isValidPassword(\"Short1!\"), false\n  assert.strictEqual isValidPassword(\"nouppercase1!\"), false\n  assert.strictEqual isValidPassword(\"NOLOWERCASE1!\"), false\n  assert.strictEqual isValidPassword(\"NoNumbersHere!\"), false\n  assert.strictEqual isValidPassword(\"MissingSpecialChars123\"), false\n  assert.strictEqual isValidPassword(\"\"), false\n  assert.strictEqual isValidPassword(\"12345678\"), false\n  assert.strictEqual isValidPassword(\"ABCDEFGH\"), false\n  assert.strictEqual isValidPassword(\"abcdefgh\"), false\n  assert.strictEqual isValidPassword(\"!@#$%^&*\"), false\n  \n  # Test valid passwords\n  assert.strictEqual isValidPassword(\"ValidPass123!\"), true\n  assert.strictEqual isValidPassword(\"Another!Good1\"), true\n  assert.strictEqual isValidPassword(\"!@#ABCabc123\"), true\n  \n  console.log \"All tests passed!\"\n\ntestPasswordValidation()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestPasswordValidation = ->\n  # Test invalid passwords\n  assert.strictEqual isValidPassword(\"Short1!\"), false\n  assert.strictEqual isValidPassword(\"nouppercase1!\"), false\n  assert.strictEqual isValidPassword(\"NOLOWERCASE1!\"), false\n  assert.strictEqual isValidPassword(\"NoNumbersHere!\"), false\n  assert.strictEqual isValidPassword(\"MissingSpecialChars123\"), false\n  assert.strictEqual isValidPassword(\"\"), false\n  assert.strictEqual isValidPassword(\"12345678\"), false\n  assert.strictEqual isValidPassword(\"ABCDEFGH\"), false\n  assert.strictEqual isValidPassword(\"abcdefgh\"), false\n  assert.strictEqual isValidPassword(\"!@#$%^&*\"), false\n  \n  # Test valid passwords\n  assert.strictEqual isValidPassword(\"ValidPass123!\"), true\n  assert.strictEqual isValidPassword(\"Another!Good1\"), true\n  assert.strictEqual isValidPassword(\"!@#ABCabc123\"), true\n  \n  console.log \"All tests passed!\"\n\ntestPasswordValidation()", "output": "isValidPassword"}, "all_code": "# Checks if the provided password meets the UCT Password Function (PWF) criteria.\n# Criteria include:\n# - At least 8 characters long\n# - At least one uppercase letter\n# - At least one lowercase letter\n# - At least one number\n# - At least one special character\nisValidPassword = (password) ->\n  # Check minimum length requirement\n  return false if password.length < 8\n  \n  # Check for at least one uppercase letter\n  return false unless /[A-Z]/.test(password)\n  \n  # Check for at least one lowercase letter\n  return false unless /[a-z]/.test(password)\n  \n  # Check for at least one number\n  return false unless /\\d/.test(password)\n  \n  # Check for at least one special character\n  return false unless /[!@#$%^&*(),.?\":{}|<>]/.test(password)\n  \n  # All checks passed\n  true\nassert = require 'assert'\n\ntestPasswordValidation = ->\n  # Test invalid passwords\n  assert.strictEqual isValidPassword(\"Short1!\"), false\n  assert.strictEqual isValidPassword(\"nouppercase1!\"), false\n  assert.strictEqual isValidPassword(\"NOLOWERCASE1!\"), false\n  assert.strictEqual isValidPassword(\"NoNumbersHere!\"), false\n  assert.strictEqual isValidPassword(\"MissingSpecialChars123\"), false\n  assert.strictEqual isValidPassword(\"\"), false\n  assert.strictEqual isValidPassword(\"12345678\"), false\n  assert.strictEqual isValidPassword(\"ABCDEFGH\"), false\n  assert.strictEqual isValidPassword(\"abcdefgh\"), false\n  assert.strictEqual isValidPassword(\"!@#$%^&*\"), false\n  \n  # Test valid passwords\n  assert.strictEqual isValidPassword(\"ValidPass123!\"), true\n  assert.strictEqual isValidPassword(\"Another!Good1\"), true\n  assert.strictEqual isValidPassword(\"!@#ABCabc123\"), true\n  \n  console.log \"All tests passed!\"\n\ntestPasswordValidation()", "exec_outcome": "PASSED"}
{"code": "# optimizedBubbleSort performs a bubble sort on an array with an early exit optimization.\n# If simulation is true, it prints the array state after each swap.\n# Returns the sorted array.\noptimizedBubbleSort = (arr, simulation = false) ->\n  n = arr.length\n  for i in [0...n]\n    swapped = false\n    for j in [0...n-i-1]\n      if arr[j] > arr[j+1]\n        # Swap elements\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]\n        swapped = true\n        if simulation\n          console.log \"iteration #{i*n+j}: #{arr.join(' ')}\"\n    # Early exit if no swaps occurred\n    break unless swapped\n  arr", "test_cases": "", "test_case_results": "Input array: [ 5, 1, 4, 2, 8 ]\nSimulation mode: true\niteration 0: 1 5 4 2 8\niteration 1: 1 4 5 2 8\niteration 2: 1 4 2 5 8\niteration 6: 1 2 4 5 8\nSorted array: [ 1, 2, 4, 5, 8 ]\n\nInput array: [ 1, 2, 3, 4, 5 ]\nSimulation mode: false\nSorted array: [ 1, 2, 3, 4, 5 ]\n\nInput array: [ 10, 9, 8, 7, 6 ]\nSimulation mode: false\nSorted array: [ 6, 7, 8, 9, 10 ]\n\nInput array: [\n  3, 1, 4, 1,\n  5, 9, 2, 6\n]\nSimulation mode: true\niteration 0: 1 3 4 1 5 9 2 6\niteration 2: 1 3 1 4 5 9 2 6\niteration 5: 1 3 1 4 5 2 9 6\niteration 6: 1 3 1 4 5 2 6 9\niteration 9: 1 1 3 4 5 2 6 9\niteration 12: 1 1 3 4 2 5 6 9\niteration 19: 1 1 3 2 4 5 6 9\niteration 26: 1 1 2 3 4 5 6 9\nSorted array: [\n  1, 1, 2, 3,\n  4, 5, 6, 9\n]", "task_id": 10236, "assertions": "assert = require 'assert'\n\ntestOptimizedBubbleSort = ->\n  # Test case 1: Basic unsorted array with simulation\n  input1 = [5, 1, 4, 2, 8]\n  expected1 = [1, 2, 4, 5, 8]\n  assert.deepStrictEqual optimizedBubbleSort(input1[..]), expected1\n\n  # Test case 2: Already sorted array\n  input2 = [1, 2, 3, 4, 5]\n  expected2 = [1, 2, 3, 4, 5]\n  assert.deepStrictEqual optimizedBubbleSort(input2[..]), expected2\n\n  # Test case 3: Reverse sorted array\n  input3 = [10, 9, 8, 7, 6]\n  expected3 = [6, 7, 8, 9, 10]\n  assert.deepStrictEqual optimizedBubbleSort(input3[..]), expected3\n\n  # Test case 4: Array with duplicates\n  input4 = [3, 1, 4, 1, 5, 9, 2, 6]\n  expected4 = [1, 1, 2, 3, 4, 5, 6, 9]\n  assert.deepStrictEqual optimizedBubbleSort(input4[..]), expected4\n\n  console.log \"All tests passed!\"\n\ntestOptimizedBubbleSort()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestOptimizedBubbleSort = ->\n  # Test case 1: Basic unsorted array with simulation\n  input1 = [5, 1, 4, 2, 8]\n  expected1 = [1, 2, 4, 5, 8]\n  assert.deepStrictEqual optimizedBubbleSort(input1[..]), expected1\n\n  # Test case 2: Already sorted array\n  input2 = [1, 2, 3, 4, 5]\n  expected2 = [1, 2, 3, 4, 5]\n  assert.deepStrictEqual optimizedBubbleSort(input2[..]), expected2\n\n  # Test case 3: Reverse sorted array\n  input3 = [10, 9, 8, 7, 6]\n  expected3 = [6, 7, 8, 9, 10]\n  assert.deepStrictEqual optimizedBubbleSort(input3[..]), expected3\n\n  # Test case 4: Array with duplicates\n  input4 = [3, 1, 4, 1, 5, 9, 2, 6]\n  expected4 = [1, 1, 2, 3, 4, 5, 6, 9]\n  assert.deepStrictEqual optimizedBubbleSort(input4[..]), expected4\n\n  console.log \"All tests passed!\"\n\ntestOptimizedBubbleSort()", "output": "optimizedBubbleSort"}, "all_code": "# optimizedBubbleSort performs a bubble sort on an array with an early exit optimization.\n# If simulation is true, it prints the array state after each swap.\n# Returns the sorted array.\noptimizedBubbleSort = (arr, simulation = false) ->\n  n = arr.length\n  for i in [0...n]\n    swapped = false\n    for j in [0...n-i-1]\n      if arr[j] > arr[j+1]\n        # Swap elements\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]\n        swapped = true\n        if simulation\n          console.log \"iteration #{i*n+j}: #{arr.join(' ')}\"\n    # Early exit if no swaps occurred\n    break unless swapped\n  arr\nassert = require 'assert'\n\ntestOptimizedBubbleSort = ->\n  # Test case 1: Basic unsorted array with simulation\n  input1 = [5, 1, 4, 2, 8]\n  expected1 = [1, 2, 4, 5, 8]\n  assert.deepStrictEqual optimizedBubbleSort(input1[..]), expected1\n\n  # Test case 2: Already sorted array\n  input2 = [1, 2, 3, 4, 5]\n  expected2 = [1, 2, 3, 4, 5]\n  assert.deepStrictEqual optimizedBubbleSort(input2[..]), expected2\n\n  # Test case 3: Reverse sorted array\n  input3 = [10, 9, 8, 7, 6]\n  expected3 = [6, 7, 8, 9, 10]\n  assert.deepStrictEqual optimizedBubbleSort(input3[..]), expected3\n\n  # Test case 4: Array with duplicates\n  input4 = [3, 1, 4, 1, 5, 9, 2, 6]\n  expected4 = [1, 1, 2, 3, 4, 5, 6, 9]\n  assert.deepStrictEqual optimizedBubbleSort(input4[..]), expected4\n\n  console.log \"All tests passed!\"\n\ntestOptimizedBubbleSort()", "exec_outcome": "PASSED"}
{"code": "# decompose breaks down (n - 1) into the form (2^r * d) where d is odd\ndecompose = (n) ->\n  r = 0\n  d = n - 1\n  while d % 2 is 0\n    r += 1\n    d = d // 2\n  return {r, d}\n\n# isComposite checks if 'a' is a witness for n being composite\nisComposite = (a, r, d, n) ->\n  x = Math.pow(a, d) % n\n  if x is 1 or x is n - 1\n    return false\n  for _ in [0...r - 1]\n    x = Math.pow(x, 2) % n\n    if x is n - 1\n      return false\n  return true\n\n# rabinMillerTest determines if a number is probably prime using k iterations\nrabinMillerTest = (n, k) ->\n  # Handle edge cases directly\n  return false if n < 2\n  return true if n in [2, 3]\n  return false if n % 2 is 0\n\n  # Decompose (n - 1) to (2^r * d)\n  {r, d} = decompose(n)\n\n  # Perform k iterations of the test\n  for _ in [0...k]\n    a = 2 + Math.floor(Math.random() * (n - 3))\n    if isComposite(a, r, d, n)\n      return false\n  return true", "test_cases": "", "test_case_results": "Testing n=1 with k=5:\n  Result: false\n  Correct: true\n\nTesting n=2 with k=5:\n  Result: true\n  Correct: true\n\nTesting n=3 with k=5:\n  Result: true\n  Correct: true\n\nTesting n=4 with k=5:\n  Result: false\n  Correct: true\n\nTesting n=5 with k=5:\n  Result: true\n  Correct: true\n\nTesting n=9 with k=5:\n  Result: false\n  Correct: true\n\nTesting n=13 with k=5:\n  Result: true\n  Correct: true\n\nTesting n=15 with k=5:\n  Result: false\n  Correct: true\n\nTesting n=17 with k=5:\n  Result: true\n  Correct: true\n\nTesting n=7919 with k=5:\n  Result: false\n  Correct: false\n\nTesting n=7921 with k=5:\n  Result: false\n  Correct: true", "task_id": 1449, "assertions": "assert = require 'assert'\n\ntestRabinMiller = ->\n  # Test cases with expected results\n  testCases = [\n    {n: 1, k: 5, expected: false}\n    {n: 2, k: 5, expected: true}\n    {n: 3, k: 5, expected: true}\n    {n: 4, k: 5, expected: false}\n    {n: 5, k: 5, expected: true}\n    {n: 9, k: 5, expected: false}\n    {n: 13, k: 5, expected: true}\n    {n: 15, k: 5, expected: false}\n    {n: 17, k: 5, expected: true}\n    {n: 7919, k: 5, expected: true}  # Note: Original test had incorrect expected value\n    {n: 7921, k: 5, expected: false}\n  ]\n\n  for testCase in testCases\n    {n, k, expected} = testCase\n    result = rabinMillerTest(n, k)\n    assert.strictEqual result, expected, \"Failed for n=#{n} with k=#{k}\"\n\ntestRabinMiller()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestRabinMiller = ->\n  # Test cases with expected results\n  testCases = [\n    {n: 1, k: 5, expected: false}\n    {n: 2, k: 5, expected: true}\n    {n: 3, k: 5, expected: true}\n    {n: 4, k: 5, expected: false}\n    {n: 5, k: 5, expected: true}\n    {n: 9, k: 5, expected: false}\n    {n: 13, k: 5, expected: true}\n    {n: 15, k: 5, expected: false}\n    {n: 17, k: 5, expected: true}\n    {n: 7919, k: 5, expected: true}  # Note: Original test had incorrect expected value\n    {n: 7921, k: 5, expected: false}\n  ]\n\n  for testCase in testCases\n    {n, k, expected} = testCase\n    result = rabinMillerTest(n, k)\n    assert.strictEqual result, expected, \"Failed for n=#{n} with k=#{k}\"\n\ntestRabinMiller()", "output": "rabinMillerTest"}, "all_code": "# decompose breaks down (n - 1) into the form (2^r * d) where d is odd\ndecompose = (n) ->\n  r = 0\n  d = n - 1\n  while d % 2 is 0\n    r += 1\n    d = d // 2\n  return {r, d}\n\n# isComposite checks if 'a' is a witness for n being composite\nisComposite = (a, r, d, n) ->\n  x = Math.pow(a, d) % n\n  if x is 1 or x is n - 1\n    return false\n  for _ in [0...r - 1]\n    x = Math.pow(x, 2) % n\n    if x is n - 1\n      return false\n  return true\n\n# rabinMillerTest determines if a number is probably prime using k iterations\nrabinMillerTest = (n, k) ->\n  # Handle edge cases directly\n  return false if n < 2\n  return true if n in [2, 3]\n  return false if n % 2 is 0\n\n  # Decompose (n - 1) to (2^r * d)\n  {r, d} = decompose(n)\n\n  # Perform k iterations of the test\n  for _ in [0...k]\n    a = 2 + Math.floor(Math.random() * (n - 3))\n    if isComposite(a, r, d, n)\n      return false\n  return true\nassert = require 'assert'\n\ntestRabinMiller = ->\n  # Test cases with expected results\n  testCases = [\n    {n: 1, k: 5, expected: false}\n    {n: 2, k: 5, expected: true}\n    {n: 3, k: 5, expected: true}\n    {n: 4, k: 5, expected: false}\n    {n: 5, k: 5, expected: true}\n    {n: 9, k: 5, expected: false}\n    {n: 13, k: 5, expected: true}\n    {n: 15, k: 5, expected: false}\n    {n: 17, k: 5, expected: true}\n    {n: 7919, k: 5, expected: true}  # Note: Original test had incorrect expected value\n    {n: 7921, k: 5, expected: false}\n  ]\n\n  for testCase in testCases\n    {n, k, expected} = testCase\n    result = rabinMillerTest(n, k)\n    assert.strictEqual result, expected, \"Failed for n=#{n} with k=#{k}\"\n\ntestRabinMiller()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# maxHeapify ensures the subtree rooted at index i is a max heap\n# arr: the array to heapify\n# n: size of the heap\n# i: root index of the subtree\n# simulation: whether to print iteration details\n# iterCount: array to track iteration count (using array for mutable reference)\nmaxHeapify = (arr, n, i, simulation = false, iterCount = [0]) ->\n  largest = i\n  left = 2 * i + 1\n  right = 2 * i + 2\n\n  if left < n and arr[left] > arr[largest]\n    largest = left\n\n  if right < n and arr[right] > arr[largest]\n    largest = right\n\n  if largest isnt i\n    [arr[i], arr[largest]] = [arr[largest], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    maxHeapify(arr, n, largest, simulation, iterCount)\n\n# minHeapify ensures the subtree rooted at index i is a min heap\nminHeapify = (arr, n, i, simulation = false, iterCount = [0]) ->\n  smallest = i\n  left = 2 * i + 1\n  right = 2 * i + 2\n\n  if left < n and arr[left] < arr[smallest]\n    smallest = left\n\n  if right < n and arr[right] < arr[smallest]\n    smallest = right\n\n  if smallest isnt i\n    [arr[i], arr[smallest]] = [arr[smallest], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    minHeapify(arr, n, smallest, simulation, iterCount)\n\n# maxHeapSort sorts an array in ascending order using max heap\nmaxHeapSort = (arr, simulation = false) ->\n  n = arr.length\n  iterCount = [0]\n\n  # Build max heap\n  for i in [Math.floor(n / 2) - 1..0]\n    maxHeapify(arr, n, i, simulation, iterCount)\n\n  # Extract elements one by one\n  for i in [n - 1..1]\n    [arr[i], arr[0]] = [arr[0], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    maxHeapify(arr, i, 0, simulation, iterCount)\n\n  arr\n\n# minHeapSort sorts an array in descending order using min heap\nminHeapSort = (arr, simulation = false) ->\n  n = arr.length\n  iterCount = [0]\n\n  # Build min heap\n  for i in [Math.floor(n / 2) - 1..0]\n    minHeapify(arr, n, i, simulation, iterCount)\n\n  # Extract elements one by one\n  for i in [n - 1..1]\n    [arr[i], arr[0]] = [arr[0], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    minHeapify(arr, i, 0, simulation, iterCount)\n\n  arr.reverse()\n  arr", "test_cases": "", "test_case_results": "Testing maxHeapSort (ascending order):\nTest case 1:\n  Original: 12,11,13,5,6,7\n  Sorted:   5,6,7,11,12,13\nTest case 2:\n  Original: 4,10,3,5,1\n  Sorted:   1,3,4,5,10\nTest case 3:\n  Original: 1,2,3,4,5\n  Sorted:   1,2,3,4,5\nTest case 4:\n  Original: 5,4,3,2,1\n  Sorted:   1,2,3,4,5\n\nTesting minHeapSort (descending order):\nTest case 1:\n  Original: 12,11,13,5,6,7\n  Sorted:   5,6,7,11,12,13\nTest case 2:\n  Original: 4,10,3,5,1\n  Sorted:   1,3,4,5,10\nTest case 3:\n  Original: 1,2,3,4,5\n  Sorted:   1,2,3,4,5\nTest case 4:\n  Original: 5,4,3,2,1\n  Sorted:   1,2,3,4,5\n\nTesting maxHeapSort with simulation (first test case only):\nOriginal array: 12,11,13,5,6,7\niteration 1: 13,11,12,5,6,7\niteration 2: 7,11,12,5,6,13\niteration 3: 12,11,7,5,6,13\niteration 4: 6,11,7,5,12,13\niteration 5: 11,6,7,5,12,13\niteration 6: 5,6,7,11,12,13\niteration 7: 7,6,5,11,12,13\niteration 8: 5,6,7,11,12,13\niteration 9: 6,5,7,11,12,13\niteration 10: 5,6,7,11,12,13", "task_id": 29716, "assertions": "assert = require 'assert'\n\ntestHeapSorts = ->\n  testArrays = [\n    [12, 11, 13, 5, 6, 7]\n    [4, 10, 3, 5, 1]\n    [1, 2, 3, 4, 5]\n    [5, 4, 3, 2, 1]\n  ]\n\n  expectedMaxHeapSortResults = [\n    [5, 6, 7, 11, 12, 13]\n    [1, 3, 4, 5, 10]\n    [1, 2, 3, 4, 5]\n    [1, 2, 3, 4, 5]\n  ]\n\n  expectedMinHeapSortResults = [\n    [13, 12, 11, 7, 6, 5]\n    [10, 5, 4, 3, 1]\n    [5, 4, 3, 2, 1]\n    [5, 4, 3, 2, 1]\n  ]\n\n  # Test maxHeapSort\n  for arr, i in testArrays\n    sorted = maxHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMaxHeapSortResults[i],\n      \"Test case #{i + 1} failed for maxHeapSort\"\n\n  # Test minHeapSort\n  for arr, i in testArrays\n    sorted = minHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMinHeapSortResults[i],\n      \"Test case #{i + 1} failed for minHeapSort\"\n\n  console.log \"All tests passed successfully!\"\n\ntestHeapSorts()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestHeapSorts = ->\n  testArrays = [\n    [12, 11, 13, 5, 6, 7]\n    [4, 10, 3, 5, 1]\n    [1, 2, 3, 4, 5]\n    [5, 4, 3, 2, 1]\n  ]\n\n  expectedMaxHeapSortResults = [\n    [5, 6, 7, 11, 12, 13]\n    [1, 3, 4, 5, 10]\n    [1, 2, 3, 4, 5]\n    [1, 2, 3, 4, 5]\n  ]\n\n  expectedMinHeapSortResults = [\n    [13, 12, 11, 7, 6, 5]\n    [10, 5, 4, 3, 1]\n    [5, 4, 3, 2, 1]\n    [5, 4, 3, 2, 1]\n  ]\n\n  # Test maxHeapSort\n  for arr, i in testArrays\n    sorted = maxHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMaxHeapSortResults[i],\n      \"Test case #{i + 1} failed for maxHeapSort\"\n\n  # Test minHeapSort\n  for arr, i in testArrays\n    sorted = minHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMinHeapSortResults[i],\n      \"Test case #{i + 1} failed for minHeapSort\"\n\n  console.log \"All tests passed successfully!\"\n\ntestHeapSorts()", "output": "maxHeapSort and minHeapSort"}, "all_code": "# maxHeapify ensures the subtree rooted at index i is a max heap\n# arr: the array to heapify\n# n: size of the heap\n# i: root index of the subtree\n# simulation: whether to print iteration details\n# iterCount: array to track iteration count (using array for mutable reference)\nmaxHeapify = (arr, n, i, simulation = false, iterCount = [0]) ->\n  largest = i\n  left = 2 * i + 1\n  right = 2 * i + 2\n\n  if left < n and arr[left] > arr[largest]\n    largest = left\n\n  if right < n and arr[right] > arr[largest]\n    largest = right\n\n  if largest isnt i\n    [arr[i], arr[largest]] = [arr[largest], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    maxHeapify(arr, n, largest, simulation, iterCount)\n\n# minHeapify ensures the subtree rooted at index i is a min heap\nminHeapify = (arr, n, i, simulation = false, iterCount = [0]) ->\n  smallest = i\n  left = 2 * i + 1\n  right = 2 * i + 2\n\n  if left < n and arr[left] < arr[smallest]\n    smallest = left\n\n  if right < n and arr[right] < arr[smallest]\n    smallest = right\n\n  if smallest isnt i\n    [arr[i], arr[smallest]] = [arr[smallest], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    minHeapify(arr, n, smallest, simulation, iterCount)\n\n# maxHeapSort sorts an array in ascending order using max heap\nmaxHeapSort = (arr, simulation = false) ->\n  n = arr.length\n  iterCount = [0]\n\n  # Build max heap\n  for i in [Math.floor(n / 2) - 1..0]\n    maxHeapify(arr, n, i, simulation, iterCount)\n\n  # Extract elements one by one\n  for i in [n - 1..1]\n    [arr[i], arr[0]] = [arr[0], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    maxHeapify(arr, i, 0, simulation, iterCount)\n\n  arr\n\n# minHeapSort sorts an array in descending order using min heap\nminHeapSort = (arr, simulation = false) ->\n  n = arr.length\n  iterCount = [0]\n\n  # Build min heap\n  for i in [Math.floor(n / 2) - 1..0]\n    minHeapify(arr, n, i, simulation, iterCount)\n\n  # Extract elements one by one\n  for i in [n - 1..1]\n    [arr[i], arr[0]] = [arr[0], arr[i]]\n    iterCount[0] += 1\n    if simulation\n      console.log \"iteration #{iterCount[0]}: #{arr}\"\n    minHeapify(arr, i, 0, simulation, iterCount)\n\n  arr.reverse()\n  arr\nassert = require 'assert'\n\ntestHeapSorts = ->\n  testArrays = [\n    [12, 11, 13, 5, 6, 7]\n    [4, 10, 3, 5, 1]\n    [1, 2, 3, 4, 5]\n    [5, 4, 3, 2, 1]\n  ]\n\n  expectedMaxHeapSortResults = [\n    [5, 6, 7, 11, 12, 13]\n    [1, 3, 4, 5, 10]\n    [1, 2, 3, 4, 5]\n    [1, 2, 3, 4, 5]\n  ]\n\n  expectedMinHeapSortResults = [\n    [13, 12, 11, 7, 6, 5]\n    [10, 5, 4, 3, 1]\n    [5, 4, 3, 2, 1]\n    [5, 4, 3, 2, 1]\n  ]\n\n  # Test maxHeapSort\n  for arr, i in testArrays\n    sorted = maxHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMaxHeapSortResults[i],\n      \"Test case #{i + 1} failed for maxHeapSort\"\n\n  # Test minHeapSort\n  for arr, i in testArrays\n    sorted = minHeapSort(arr.slice())\n    assert.deepStrictEqual sorted, expectedMinHeapSortResults[i],\n      \"Test case #{i + 1} failed for minHeapSort\"\n\n  console.log \"All tests passed successfully!\"\n\ntestHeapSorts()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# bfsShortestPaths calculates the shortest path distances from a source node to all other nodes\n# in an undirected graph using Breadth-First Search (BFS).\n# \n# Parameters:\n#   graph - An object where each key is a node and its value is an array of neighboring nodes\n#   source - The source node from which to calculate the shortest paths\n#\n# Returns:\n#   An object where keys are nodes and values are their shortest distance from the source node\nbfsShortestPaths = (graph, source) ->\n    distances = {}\n    # Initialize all distances to Infinity\n    for node of graph\n        distances[node] = Infinity\n    distances[source] = 0\n    queue = [source]\n\n    while queue.length > 0\n        current = queue.shift()\n        \n        for neighbor in graph[current]\n            if distances[neighbor] is Infinity  # not visited yet\n                distances[neighbor] = distances[current] + 1\n                queue.push(neighbor)\n    \n    distances", "test_cases": "", "test_case_results": "Test Case 1 - Graph:\n{\n  \"A\": [\n    \"B\",\n    \"C\"\n  ],\n  \"B\": [\n    \"A\",\n    \"D\",\n    \"E\"\n  ],\n  \"C\": [\n    \"A\",\n    \"F\"\n  ],\n  \"D\": [\n    \"B\"\n  ],\n  \"E\": [\n    \"B\",\n    \"F\"\n  ],\n  \"F\": [\n    \"C\",\n    \"E\"\n  ]\n}\nShortest paths from 'A':\n{ A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }\n\nTest Case 2 - Graph:\n{\n  \"1\": [\n    \"2\",\n    \"3\"\n  ],\n  \"2\": [\n    \"1\",\n    \"4\"\n  ],\n  \"3\": [\n    \"1\",\n    \"4\"\n  ],\n  \"4\": [\n    \"2\",\n    \"3\",\n    \"5\"\n  ],\n  \"5\": [\n    \"4\"\n  ]\n}\nShortest paths from '1':\n{ '1': 0, '2': 1, '3': 1, '4': 2, '5': 3 }\n\nTest Case 3 - Graph:\n{\n  \"X\": [\n    \"Y\"\n  ],\n  \"Y\": [\n    \"X\",\n    \"Z\"\n  ],\n  \"Z\": [\n    \"Y\"\n  ]\n}\nShortest paths from 'Z':\n{ X: 2, Y: 1, Z: 0 }", "task_id": 3149, "assertions": "assert = require 'assert'\n\ntestBfsShortestPaths = ->\n    testGraph1 =\n        'A': ['B', 'C']\n        'B': ['A', 'D', 'E']\n        'C': ['A', 'F']\n        'D': ['B']\n        'E': ['B', 'F']\n        'F': ['C', 'E']\n\n    testGraph2 =\n        '1': ['2', '3']\n        '2': ['1', '4']\n        '3': ['1', '4']\n        '4': ['2', '3', '5']\n        '5': ['4']\n\n    testGraph3 =\n        'X': ['Y']\n        'Y': ['X', 'Z']\n        'Z': ['Y']\n\n    # Test Case 1\n    result1 = bfsShortestPaths(testGraph1, 'A')\n    assert.deepStrictEqual result1, { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }\n\n    # Test Case 2\n    result2 = bfsShortestPaths(testGraph2, '1')\n    assert.deepStrictEqual result2, { '1': 0, '2': 1, '3': 1, '4': 2, '5': 3 }\n\n    # Test Case 3\n    result3 = bfsShortestPaths(testGraph3, 'Z')\n    assert.deepStrictEqual result3, { X: 2, Y: 1, Z: 0 }\n\n    console.log \"All tests passed successfully!\"\n\ntestBfsShortestPaths()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestBfsShortestPaths = ->\n    testGraph1 =\n        'A': ['B', 'C']\n        'B': ['A', 'D', 'E']\n        'C': ['A', 'F']\n        'D': ['B']\n        'E': ['B', 'F']\n        'F': ['C', 'E']\n\n    testGraph2 =\n        '1': ['2', '3']\n        '2': ['1', '4']\n        '3': ['1', '4']\n        '4': ['2', '3', '5']\n        '5': ['4']\n\n    testGraph3 =\n        'X': ['Y']\n        'Y': ['X', 'Z']\n        'Z': ['Y']\n\n    # Test Case 1\n    result1 = bfsShortestPaths(testGraph1, 'A')\n    assert.deepStrictEqual result1, { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }\n\n    # Test Case 2\n    result2 = bfsShortestPaths(testGraph2, '1')\n    assert.deepStrictEqual result2, { '1': 0, '2': 1, '3': 1, '4': 2, '5': 3 }\n\n    # Test Case 3\n    result3 = bfsShortestPaths(testGraph3, 'Z')\n    assert.deepStrictEqual result3, { X: 2, Y: 1, Z: 0 }\n\n    console.log \"All tests passed successfully!\"\n\ntestBfsShortestPaths()", "output": "bfsShortestPaths"}, "all_code": "# bfsShortestPaths calculates the shortest path distances from a source node to all other nodes\n# in an undirected graph using Breadth-First Search (BFS).\n# \n# Parameters:\n#   graph - An object where each key is a node and its value is an array of neighboring nodes\n#   source - The source node from which to calculate the shortest paths\n#\n# Returns:\n#   An object where keys are nodes and values are their shortest distance from the source node\nbfsShortestPaths = (graph, source) ->\n    distances = {}\n    # Initialize all distances to Infinity\n    for node of graph\n        distances[node] = Infinity\n    distances[source] = 0\n    queue = [source]\n\n    while queue.length > 0\n        current = queue.shift()\n        \n        for neighbor in graph[current]\n            if distances[neighbor] is Infinity  # not visited yet\n                distances[neighbor] = distances[current] + 1\n                queue.push(neighbor)\n    \n    distances\nassert = require 'assert'\n\ntestBfsShortestPaths = ->\n    testGraph1 =\n        'A': ['B', 'C']\n        'B': ['A', 'D', 'E']\n        'C': ['A', 'F']\n        'D': ['B']\n        'E': ['B', 'F']\n        'F': ['C', 'E']\n\n    testGraph2 =\n        '1': ['2', '3']\n        '2': ['1', '4']\n        '3': ['1', '4']\n        '4': ['2', '3', '5']\n        '5': ['4']\n\n    testGraph3 =\n        'X': ['Y']\n        'Y': ['X', 'Z']\n        'Z': ['Y']\n\n    # Test Case 1\n    result1 = bfsShortestPaths(testGraph1, 'A')\n    assert.deepStrictEqual result1, { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }\n\n    # Test Case 2\n    result2 = bfsShortestPaths(testGraph2, '1')\n    assert.deepStrictEqual result2, { '1': 0, '2': 1, '3': 1, '4': 2, '5': 3 }\n\n    # Test Case 3\n    result3 = bfsShortestPaths(testGraph3, 'Z')\n    assert.deepStrictEqual result3, { X: 2, Y: 1, Z: 0 }\n\n    console.log \"All tests passed successfully!\"\n\ntestBfsShortestPaths()", "exec_outcome": "PASSED"}
{"code": "# Distributes items to shelves while respecting weight limits\n# Items are sorted by weight in descending order and placed on the first shelf with available capacity\n# Returns \"NO\" if any item cannot be placed, otherwise returns \"YES\" followed by shelf assignments\ndistributeItems = (n, m, shelves, items) ->\n  # Sort items by weight in descending order\n  items.sort (a, b) -> b[1] - a[1]\n\n  # Initialize shelf tracking\n  currentWeight = {}\n  assignments = {}\n  for [shelfId, shelfLimit] in shelves\n    currentWeight[shelfId] = 0\n    assignments[shelfId] = []\n\n  # Distribute items to shelves\n  for [itemId, itemWeight] in items\n    placed = false\n    for [shelfId, shelfLimit] in shelves\n      if currentWeight[shelfId] + itemWeight <= shelfLimit\n        assignments[shelfId].push itemId\n        currentWeight[shelfId] += itemWeight\n        placed = true\n        break\n    return \"NO\" unless placed\n\n  # Format the result\n  result = [\"YES\"]\n  for shelfId of assignments\n    result.push \"#{shelfId}: #{assignments[shelfId].join(' ')}\"\n  result.join '\\n'", "test_cases": "", "test_case_results": "Test Case 1: Basic test with all items fitting\nShelves: [ [ 1, 10 ], [ 2, 15 ], [ 3, 20 ] ]\nItems: [ [ 1, 5 ], [ 2, 8 ], [ 3, 3 ], [ 4, 6 ] ]\nResult: YES\n1: 2\n2: 4 1 3\n3: \n\nTest Case 2: Test where one item doesn't fit\nShelves: [ [ 1, 5 ], [ 2, 5 ] ]\nItems: [ [ 1, 6 ], [ 2, 4 ], [ 3, 2 ] ]\nResult: NO\n\nTest Case 3: Test with exact fit\nShelves: [ [ 1, 10 ], [ 2, 10 ] ]\nItems: [ [ 1, 5 ], [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ]\nResult: YES\n1: 1 2\n2: 3 4", "task_id": 17246, "assertions": "assert = require 'assert'\n\ntestDistributeItems = ->\n  # Test Case 1: Basic test with all items fitting\n  assert.strictEqual distributeItems(3, 4, [[1, 10], [2, 15], [3, 20]], [[1, 5], [2, 8], [3, 3], [4, 6]]), \n    \"YES\\n1: 2\\n2: 4 1 3\\n3: \"\n\n  # Test Case 2: Test where one item doesn't fit\n  assert.strictEqual distributeItems(2, 3, [[1, 5], [2, 5]], [[1, 6], [2, 4], [3, 2]]), \"NO\"\n\n  # Test Case 3: Test with exact fit\n  assert.strictEqual distributeItems(2, 4, [[1, 10], [2, 10]], [[1, 5], [2, 5], [3, 5], [4, 5]]), \n    \"YES\\n1: 1 2\\n2: 3 4\"\n\ntestDistributeItems()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestDistributeItems = ->\n  # Test Case 1: Basic test with all items fitting\n  assert.strictEqual distributeItems(3, 4, [[1, 10], [2, 15], [3, 20]], [[1, 5], [2, 8], [3, 3], [4, 6]]), \n    \"YES\\n1: 2\\n2: 4 1 3\\n3: \"\n\n  # Test Case 2: Test where one item doesn't fit\n  assert.strictEqual distributeItems(2, 3, [[1, 5], [2, 5]], [[1, 6], [2, 4], [3, 2]]), \"NO\"\n\n  # Test Case 3: Test with exact fit\n  assert.strictEqual distributeItems(2, 4, [[1, 10], [2, 10]], [[1, 5], [2, 5], [3, 5], [4, 5]]), \n    \"YES\\n1: 1 2\\n2: 3 4\"\n\ntestDistributeItems()", "output": "distributeItems"}, "all_code": "# Distributes items to shelves while respecting weight limits\n# Items are sorted by weight in descending order and placed on the first shelf with available capacity\n# Returns \"NO\" if any item cannot be placed, otherwise returns \"YES\" followed by shelf assignments\ndistributeItems = (n, m, shelves, items) ->\n  # Sort items by weight in descending order\n  items.sort (a, b) -> b[1] - a[1]\n\n  # Initialize shelf tracking\n  currentWeight = {}\n  assignments = {}\n  for [shelfId, shelfLimit] in shelves\n    currentWeight[shelfId] = 0\n    assignments[shelfId] = []\n\n  # Distribute items to shelves\n  for [itemId, itemWeight] in items\n    placed = false\n    for [shelfId, shelfLimit] in shelves\n      if currentWeight[shelfId] + itemWeight <= shelfLimit\n        assignments[shelfId].push itemId\n        currentWeight[shelfId] += itemWeight\n        placed = true\n        break\n    return \"NO\" unless placed\n\n  # Format the result\n  result = [\"YES\"]\n  for shelfId of assignments\n    result.push \"#{shelfId}: #{assignments[shelfId].join(' ')}\"\n  result.join '\\n'\nassert = require 'assert'\n\ntestDistributeItems = ->\n  # Test Case 1: Basic test with all items fitting\n  assert.strictEqual distributeItems(3, 4, [[1, 10], [2, 15], [3, 20]], [[1, 5], [2, 8], [3, 3], [4, 6]]), \n    \"YES\\n1: 2\\n2: 4 1 3\\n3: \"\n\n  # Test Case 2: Test where one item doesn't fit\n  assert.strictEqual distributeItems(2, 3, [[1, 5], [2, 5]], [[1, 6], [2, 4], [3, 2]]), \"NO\"\n\n  # Test Case 3: Test with exact fit\n  assert.strictEqual distributeItems(2, 4, [[1, 10], [2, 10]], [[1, 5], [2, 5], [3, 5], [4, 5]]), \n    \"YES\\n1: 1 2\\n2: 3 4\"\n\ntestDistributeItems()", "exec_outcome": "PASSED"}
{"code": "# minimumRotations calculates the minimum number of rotations required\n# to move a cake from position x to position y in a circular arrangement.\n# Parameters:\n#   n - total number of cakes\n#   cakes - array representing the cakes (unused in calculation but kept for context)\n#   x - starting position (1-based index)\n#   y - target position (1-based index)\n# Returns: minimum number of rotations needed\nminimumRotations = (n, cakes, x, y) ->\n  xIndex = x - 1\n  yIndex = y - 1\n  \n  if yIndex >= xIndex\n    yIndex - xIndex\n  else\n    n - xIndex + yIndex", "test_cases": "", "test_case_results": "Test Case:\n  n: 5\n  cakes: [ 'A', 'B', 'C', 'D', 'E' ]\n  x: 1\n  y: 3\n  Minimum Rotations: 2\n\nTest Case:\n  n: 5\n  cakes: [ 'A', 'B', 'C', 'D', 'E' ]\n  x: 3\n  y: 1\n  Minimum Rotations: 3\n\nTest Case:\n  n: 5\n  cakes: [ 'A', 'B', 'C', 'D', 'E' ]\n  x: 2\n  y: 5\n  Minimum Rotations: 3\n\nTest Case:\n  n: 5\n  cakes: [ 'A', 'B', 'C', 'D', 'E' ]\n  x: 5\n  y: 2\n  Minimum Rotations: 2\n\nTest Case:\n  n: 1\n  cakes: [ 'A' ]\n  x: 1\n  y: 1\n  Minimum Rotations: 0", "task_id": 8931, "assertions": "assert = require 'assert'\n\ntestMinimumRotations = ->\n  # Test cases based on provided input/output\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 1, 3), 2\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 3, 1), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 2, 5), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 5, 2), 2\n  assert.strictEqual minimumRotations(1, ['A'], 1, 1), 0\n  console.log \"All tests passed!\"\n\ntestMinimumRotations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinimumRotations = ->\n  # Test cases based on provided input/output\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 1, 3), 2\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 3, 1), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 2, 5), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 5, 2), 2\n  assert.strictEqual minimumRotations(1, ['A'], 1, 1), 0\n  console.log \"All tests passed!\"\n\ntestMinimumRotations()", "output": "minimumRotations"}, "all_code": "# minimumRotations calculates the minimum number of rotations required\n# to move a cake from position x to position y in a circular arrangement.\n# Parameters:\n#   n - total number of cakes\n#   cakes - array representing the cakes (unused in calculation but kept for context)\n#   x - starting position (1-based index)\n#   y - target position (1-based index)\n# Returns: minimum number of rotations needed\nminimumRotations = (n, cakes, x, y) ->\n  xIndex = x - 1\n  yIndex = y - 1\n  \n  if yIndex >= xIndex\n    yIndex - xIndex\n  else\n    n - xIndex + yIndex\nassert = require 'assert'\n\ntestMinimumRotations = ->\n  # Test cases based on provided input/output\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 1, 3), 2\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 3, 1), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 2, 5), 3\n  assert.strictEqual minimumRotations(5, ['A', 'B', 'C', 'D', 'E'], 5, 2), 2\n  assert.strictEqual minimumRotations(1, ['A'], 1, 1), 0\n  console.log \"All tests passed!\"\n\ntestMinimumRotations()", "exec_outcome": "PASSED"}
{"code": "# mergeIntervals merges overlapping intervals and handles open intervals (where end is null).\n# Intervals can be a mix of closed intervals (arrays with two numbers) and open intervals (arrays with a number and null).\nmergeIntervals = (intervals) ->\n  # Handle edge case: empty list\n  return [] if intervals.length is 0\n\n  # Normalize intervals to use Infinity for null end values\n  normalizedIntervals = intervals.map ([start, end]) ->\n    [start, if end is null then Infinity else end]\n\n  # Sort the intervals based on start time\n  normalizedIntervals.sort (a, b) -> a[0] - b[0]\n\n  merged = []\n  for currentInterval in normalizedIntervals\n    # If no overlap with last merged interval, add current interval\n    if merged.length is 0 or currentInterval[0] > merged[merged.length - 1][1]\n      merged.push currentInterval\n    else\n      # Merge with last interval by extending end time if needed\n      lastInterval = merged[merged.length - 1]\n      merged[merged.length - 1] = [lastInterval[0], Math.max(lastInterval[1], currentInterval[1])]\n\n  # Convert back to original format (Infinity -> null)\n  merged.map ([start, end]) ->\n    [start, if end is Infinity then null else end]", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [[1,3],[2,6],[8,10],[15,null]]\n  Result: [[1,6],[8,10],[15,null]]\n\nTest Case 2:\n  Input: [[1,4],[4,5]]\n  Result: [[1,5]]\n\nTest Case 3:\n  Input: [[1,2],[3,4],[5,6]]\n  Result: [[1,2],[3,4],[5,6]]\n\nTest Case 4:\n  Input: [[1,5],[2,4]]\n  Result: [[1,5]]\n\nTest Case 5:\n  Input: [[1,null],[5,6]]\n  Result: [[1,null]]\n\nTest Case 6:\n  Input: []\n  Result: []", "task_id": 16923, "assertions": "assert = require 'assert'\n\ntestMergeIntervals = ->\n  # Test Case 1: Mixed closed and open intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 3], [2, 6], [8, 10], [15, null]]),\n    [[1, 6], [8, 10], [15, null]]\n  )\n\n  # Test Case 2: Adjacent intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 4], [4, 5]]),\n    [[1, 5]]\n  )\n\n  # Test Case 3: Non-overlapping intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 2], [3, 4], [5, 6]]),\n    [[1, 2], [3, 4], [5, 6]]\n  )\n\n  # Test Case 4: Complete overlap\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 5], [2, 4]]),\n    [[1, 5]]\n  )\n\n  # Test Case 5: Open interval merging\n  assert.deepStrictEqual(\n    mergeIntervals([[1, null], [5, 6]]),\n    [[1, null]]\n  )\n\n  # Test Case 6: Empty input\n  assert.deepStrictEqual(\n    mergeIntervals([]),\n    []\n  )\n\n  console.log \"All tests passed!\"\n\ntestMergeIntervals()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMergeIntervals = ->\n  # Test Case 1: Mixed closed and open intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 3], [2, 6], [8, 10], [15, null]]),\n    [[1, 6], [8, 10], [15, null]]\n  )\n\n  # Test Case 2: Adjacent intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 4], [4, 5]]),\n    [[1, 5]]\n  )\n\n  # Test Case 3: Non-overlapping intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 2], [3, 4], [5, 6]]),\n    [[1, 2], [3, 4], [5, 6]]\n  )\n\n  # Test Case 4: Complete overlap\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 5], [2, 4]]),\n    [[1, 5]]\n  )\n\n  # Test Case 5: Open interval merging\n  assert.deepStrictEqual(\n    mergeIntervals([[1, null], [5, 6]]),\n    [[1, null]]\n  )\n\n  # Test Case 6: Empty input\n  assert.deepStrictEqual(\n    mergeIntervals([]),\n    []\n  )\n\n  console.log \"All tests passed!\"\n\ntestMergeIntervals()", "output": "mergeIntervals"}, "all_code": "# mergeIntervals merges overlapping intervals and handles open intervals (where end is null).\n# Intervals can be a mix of closed intervals (arrays with two numbers) and open intervals (arrays with a number and null).\nmergeIntervals = (intervals) ->\n  # Handle edge case: empty list\n  return [] if intervals.length is 0\n\n  # Normalize intervals to use Infinity for null end values\n  normalizedIntervals = intervals.map ([start, end]) ->\n    [start, if end is null then Infinity else end]\n\n  # Sort the intervals based on start time\n  normalizedIntervals.sort (a, b) -> a[0] - b[0]\n\n  merged = []\n  for currentInterval in normalizedIntervals\n    # If no overlap with last merged interval, add current interval\n    if merged.length is 0 or currentInterval[0] > merged[merged.length - 1][1]\n      merged.push currentInterval\n    else\n      # Merge with last interval by extending end time if needed\n      lastInterval = merged[merged.length - 1]\n      merged[merged.length - 1] = [lastInterval[0], Math.max(lastInterval[1], currentInterval[1])]\n\n  # Convert back to original format (Infinity -> null)\n  merged.map ([start, end]) ->\n    [start, if end is Infinity then null else end]\nassert = require 'assert'\n\ntestMergeIntervals = ->\n  # Test Case 1: Mixed closed and open intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 3], [2, 6], [8, 10], [15, null]]),\n    [[1, 6], [8, 10], [15, null]]\n  )\n\n  # Test Case 2: Adjacent intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 4], [4, 5]]),\n    [[1, 5]]\n  )\n\n  # Test Case 3: Non-overlapping intervals\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 2], [3, 4], [5, 6]]),\n    [[1, 2], [3, 4], [5, 6]]\n  )\n\n  # Test Case 4: Complete overlap\n  assert.deepStrictEqual(\n    mergeIntervals([[1, 5], [2, 4]]),\n    [[1, 5]]\n  )\n\n  # Test Case 5: Open interval merging\n  assert.deepStrictEqual(\n    mergeIntervals([[1, null], [5, 6]]),\n    [[1, null]]\n  )\n\n  # Test Case 6: Empty input\n  assert.deepStrictEqual(\n    mergeIntervals([]),\n    []\n  )\n\n  console.log \"All tests passed!\"\n\ntestMergeIntervals()", "exec_outcome": "PASSED"}
{"code": "# canFormAlternatingPattern checks if a batch of product codes can be rearranged to form an alternating pattern of 'A' and 'B'.\n# The counts of 'A' and 'B' must differ by at most 1 for this to be possible.\ncanFormAlternatingPattern = (batch) ->\n  countA = (char for char in batch when char is 'A').length\n  countB = (char for char in batch when char is 'B').length\n  if Math.abs(countA - countB) <= 1 then \"YES\" else \"NO\"\n\n# batchCheck processes a list of batches and checks each one for the possibility of forming an alternating pattern.\n# It returns an array of results (\"YES\" or \"NO\") corresponding to each input batch.\nbatchCheck = (batches) ->\n  (canFormAlternatingPattern(batch) for batch in batches)", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [ 'A', 'B', 'A', 'B' ]\n  Result: YES\n\nTest Case 2:\n  Input: [ 'A', 'A', 'B', 'B' ]\n  Result: YES\n\nTest Case 3:\n  Input: [ 'A', 'A', 'A', 'B' ]\n  Result: NO\n\nTest Case 4:\n  Input: [ 'A', 'B', 'B', 'B' ]\n  Result: NO\n\nTest Case 5:\n  Input: [ 'A', 'B' ]\n  Result: YES\n\nTest Case 6:\n  Input: [ 'A' ]\n  Result: YES\n\nTest Case 7:\n  Input: [ 'B' ]\n  Result: YES\n\nTest Case 8:\n  Input: []\n  Result: YES\n\nBatch Check Results: [\n  'YES', 'YES',\n  'NO',  'NO',\n  'YES', 'YES',\n  'YES', 'YES'\n]", "task_id": 5156, "assertions": "assert = require 'assert'\n\ntestAlternatingPattern = ->\n  # Test individual canFormAlternatingPattern function\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'B', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'A', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'B', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern([]), 'YES'\n\n  # Test batchCheck function\n  testBatches = [\n    ['A', 'B', 'A', 'B']\n    ['A', 'A', 'B', 'B']\n    ['A', 'A', 'A', 'B']\n    ['A', 'B', 'B', 'B']\n    ['A', 'B']\n    ['A']\n    ['B']\n    []\n  ]\n  expectedResults = ['YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES']\n  assert.deepStrictEqual batchCheck(testBatches), expectedResults\n\n  console.log \"All tests passed!\"\n\ntestAlternatingPattern()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestAlternatingPattern = ->\n  # Test individual canFormAlternatingPattern function\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'B', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'A', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'B', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern([]), 'YES'\n\n  # Test batchCheck function\n  testBatches = [\n    ['A', 'B', 'A', 'B']\n    ['A', 'A', 'B', 'B']\n    ['A', 'A', 'A', 'B']\n    ['A', 'B', 'B', 'B']\n    ['A', 'B']\n    ['A']\n    ['B']\n    []\n  ]\n  expectedResults = ['YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES']\n  assert.deepStrictEqual batchCheck(testBatches), expectedResults\n\n  console.log \"All tests passed!\"\n\ntestAlternatingPattern()", "output": "canFormAlternatingPattern"}, "all_code": "# canFormAlternatingPattern checks if a batch of product codes can be rearranged to form an alternating pattern of 'A' and 'B'.\n# The counts of 'A' and 'B' must differ by at most 1 for this to be possible.\ncanFormAlternatingPattern = (batch) ->\n  countA = (char for char in batch when char is 'A').length\n  countB = (char for char in batch when char is 'B').length\n  if Math.abs(countA - countB) <= 1 then \"YES\" else \"NO\"\n\n# batchCheck processes a list of batches and checks each one for the possibility of forming an alternating pattern.\n# It returns an array of results (\"YES\" or \"NO\") corresponding to each input batch.\nbatchCheck = (batches) ->\n  (canFormAlternatingPattern(batch) for batch in batches)\nassert = require 'assert'\n\ntestAlternatingPattern = ->\n  # Test individual canFormAlternatingPattern function\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'B', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A', 'A', 'A', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B', 'B', 'B']), 'NO'\n  assert.strictEqual canFormAlternatingPattern(['A', 'B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['A']), 'YES'\n  assert.strictEqual canFormAlternatingPattern(['B']), 'YES'\n  assert.strictEqual canFormAlternatingPattern([]), 'YES'\n\n  # Test batchCheck function\n  testBatches = [\n    ['A', 'B', 'A', 'B']\n    ['A', 'A', 'B', 'B']\n    ['A', 'A', 'A', 'B']\n    ['A', 'B', 'B', 'B']\n    ['A', 'B']\n    ['A']\n    ['B']\n    []\n  ]\n  expectedResults = ['YES', 'YES', 'NO', 'NO', 'YES', 'YES', 'YES', 'YES']\n  assert.deepStrictEqual batchCheck(testBatches), expectedResults\n\n  console.log \"All tests passed!\"\n\ntestAlternatingPattern()", "exec_outcome": "PASSED"}
{"code": "# performOperations applies a series of operations to a binary string and returns the result.\n# Supported operations:\n# - 'invert': flips all bits (0->1, 1->0)\n# - 'rotate': moves first character to end of string\n# - 'count-consecutive-ones': returns max count of consecutive '1's\nperformOperations = (binaryString, operations) ->\n  invert = (s) ->\n    s.split('').map((ch) -> if ch is '0' then '1' else '0').join('')\n  \n  rotate = (s) ->\n    s.substring(1) + s[0]\n  \n  countConsecutiveOnes = (s) ->\n    count = maxCount = 0\n    for ch in s\n      if ch is '1'\n        count++\n        maxCount = Math.max(maxCount, count)\n      else\n        count = 0\n    maxCount\n  \n  for operation in operations\n    switch operation\n      when 'invert' then binaryString = invert(binaryString)\n      when 'rotate' then binaryString = rotate(binaryString)\n      when 'count-consecutive-ones' then return countConsecutiveOnes(binaryString)\n  \n  binaryString", "test_cases": "", "test_case_results": "Running test cases:\n\nTest Case 1:\nInput binary: 1010\nOperations: invert rotate\nResult: 1010\n\nTest Case 2:\nInput binary: 1101\nOperations: rotate invert\nResult: 0100\n\nTest Case 3:\nInput binary: 111010\nOperations: count-consecutive-ones\nResult: 3\n\nTest Case 4:\nInput binary: 0000\nOperations: invert rotate invert\nResult: 0000\n\nTest Case 5:\nInput binary: 101010\nOperations: rotate rotate count-consecutive-ones\nResult: 1", "task_id": 28346, "assertions": "assert = require 'assert'\n\ntestBinaryOperations = ->\n  # Test Case 1\n  assert.strictEqual performOperations('1010', ['invert', 'rotate']), '1010'\n  \n  # Test Case 2\n  assert.strictEqual performOperations('1101', ['rotate', 'invert']), '0100'\n  \n  # Test Case 3\n  assert.strictEqual performOperations('111010', ['count-consecutive-ones']), 3\n  \n  # Test Case 4\n  assert.strictEqual performOperations('0000', ['invert', 'rotate', 'invert']), '0000'\n  \n  # Test Case 5\n  assert.strictEqual performOperations('101010', ['rotate', 'rotate', 'count-consecutive-ones']), 1\n\ntestBinaryOperations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestBinaryOperations = ->\n  # Test Case 1\n  assert.strictEqual performOperations('1010', ['invert', 'rotate']), '1010'\n  \n  # Test Case 2\n  assert.strictEqual performOperations('1101', ['rotate', 'invert']), '0100'\n  \n  # Test Case 3\n  assert.strictEqual performOperations('111010', ['count-consecutive-ones']), 3\n  \n  # Test Case 4\n  assert.strictEqual performOperations('0000', ['invert', 'rotate', 'invert']), '0000'\n  \n  # Test Case 5\n  assert.strictEqual performOperations('101010', ['rotate', 'rotate', 'count-consecutive-ones']), 1\n\ntestBinaryOperations()", "output": "performOperations"}, "all_code": "# performOperations applies a series of operations to a binary string and returns the result.\n# Supported operations:\n# - 'invert': flips all bits (0->1, 1->0)\n# - 'rotate': moves first character to end of string\n# - 'count-consecutive-ones': returns max count of consecutive '1's\nperformOperations = (binaryString, operations) ->\n  invert = (s) ->\n    s.split('').map((ch) -> if ch is '0' then '1' else '0').join('')\n  \n  rotate = (s) ->\n    s.substring(1) + s[0]\n  \n  countConsecutiveOnes = (s) ->\n    count = maxCount = 0\n    for ch in s\n      if ch is '1'\n        count++\n        maxCount = Math.max(maxCount, count)\n      else\n        count = 0\n    maxCount\n  \n  for operation in operations\n    switch operation\n      when 'invert' then binaryString = invert(binaryString)\n      when 'rotate' then binaryString = rotate(binaryString)\n      when 'count-consecutive-ones' then return countConsecutiveOnes(binaryString)\n  \n  binaryString\nassert = require 'assert'\n\ntestBinaryOperations = ->\n  # Test Case 1\n  assert.strictEqual performOperations('1010', ['invert', 'rotate']), '1010'\n  \n  # Test Case 2\n  assert.strictEqual performOperations('1101', ['rotate', 'invert']), '0100'\n  \n  # Test Case 3\n  assert.strictEqual performOperations('111010', ['count-consecutive-ones']), 3\n  \n  # Test Case 4\n  assert.strictEqual performOperations('0000', ['invert', 'rotate', 'invert']), '0000'\n  \n  # Test Case 5\n  assert.strictEqual performOperations('101010', ['rotate', 'rotate', 'count-consecutive-ones']), 1\n\ntestBinaryOperations()", "exec_outcome": "PASSED"}
{"code": "# sumOfUniqueDigits calculates the sum of all unique digits in a given non-negative integer.\n# It converts the number to a string to easily access each digit, then uses a set to ensure uniqueness.\n# Finally, it sums the unique digits and returns the result.\nsumOfUniqueDigits = (number) ->\n  digits = String(number).split('')\n  uniqueDigits = new Set(digits)\n  sum = 0\n  for digit in uniqueDigits\n    sum += parseInt(digit)\n  sum", "test_cases": "", "test_case_results": "Input: 1234\nSum of unique digits: 0\nInput: 112233\nSum of unique digits: 0\nInput: 0\nSum of unique digits: 0\nInput: 999\nSum of unique digits: 0\nInput: 123123\nSum of unique digits: 0", "task_id": 11919, "assertions": "assert = require 'assert'\n\ntestSumOfUniqueDigits = ->\n  assert.strictEqual sumOfUniqueDigits(1234), 10\n  assert.strictEqual sumOfUniqueDigits(112233), 6\n  assert.strictEqual sumOfUniqueDigits(0), 0\n  assert.strictEqual sumOfUniqueDigits(999), 9\n  assert.strictEqual sumOfUniqueDigits(123123), 6\n\ntestSumOfUniqueDigits()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSumOfUniqueDigits = ->\n  assert.strictEqual sumOfUniqueDigits(1234), 10\n  assert.strictEqual sumOfUniqueDigits(112233), 6\n  assert.strictEqual sumOfUniqueDigits(0), 0\n  assert.strictEqual sumOfUniqueDigits(999), 9\n  assert.strictEqual sumOfUniqueDigits(123123), 6\n\ntestSumOfUniqueDigits()", "output": "sumOfUniqueDigits"}, "all_code": "# sumOfUniqueDigits calculates the sum of all unique digits in a given non-negative integer.\n# It converts the number to a string to easily access each digit, then uses a set to ensure uniqueness.\n# Finally, it sums the unique digits and returns the result.\nsumOfUniqueDigits = (number) ->\n  digits = String(number).split('')\n  uniqueDigits = new Set(digits)\n  sum = 0\n  for digit in uniqueDigits\n    sum += parseInt(digit)\n  sum\nassert = require 'assert'\n\ntestSumOfUniqueDigits = ->\n  assert.strictEqual sumOfUniqueDigits(1234), 10\n  assert.strictEqual sumOfUniqueDigits(112233), 6\n  assert.strictEqual sumOfUniqueDigits(0), 0\n  assert.strictEqual sumOfUniqueDigits(999), 9\n  assert.strictEqual sumOfUniqueDigits(123123), 6\n\ntestSumOfUniqueDigits()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# Evaluates a mathematical expression given as a string.\n# Handles algebraic operations: addition, subtraction, multiplication, and division.\n# Ignores any white spaces in the input.\n# Proper order of operations is maintained (PEMDAS/BODMAS rules).\nevaluateExpression = (expression) ->\n  # Helper function to perform basic arithmetic operations\n  operate = (a, b, operator) ->\n    switch operator\n      when '+' then a + b\n      when '-' then a - b\n      when '*' then a * b\n      when '/' then a / b\n\n  # Remove all whitespace from the expression\n  expression = expression.replace /\\s/g, ''\n\n  # Tokenize the input string into numbers and operators\n  tokens = expression.match(/\\d+\\.?\\d*|[+\\-*/()]/g) or []\n\n  evaluate = (tokens) ->\n    opStack = []\n    valStack = []\n\n    applyOperator = ->\n      operator = opStack.pop()\n      right = valStack.pop()\n      left = valStack.pop()\n      valStack.push operate(left, right, operator)\n\n    i = 0\n    while i < tokens.length\n      token = tokens[i]\n      if /^\\d+\\.?\\d*$/.test token\n        valStack.push parseFloat(token)\n      else if token is '('\n        opStack.push token\n      else if token is ')'\n        while opStack.length and opStack[opStack.length - 1] isnt '('\n          applyOperator()\n        opStack.pop() # pop '('\n      else\n        while opStack.length and opStack[opStack.length - 1] in ['*', '/', '+', '-'] and\n              (token in ['+', '-'] or opStack[opStack.length - 1] in ['*', '/'])\n          applyOperator()\n        opStack.push token\n      i++\n\n    while opStack.length\n      applyOperator()\n\n    valStack[0]\n\n  result = evaluate tokens\n  parseFloat(result.toFixed(2))", "test_cases": "", "test_case_results": "Expression: 1 + 2 * 3\nResult: 7\n---\nExpression: (1 + 2) * 3\nResult: 9\n---\nExpression: 10 - 4 / 2\nResult: 8\n---\nExpression: 2 * 3 + 4 / 2 - 1\nResult: 7\n---\nExpression: 2 * (3 + 4) / 2\nResult: 7\n---\nExpression:  10.5 + 20.25 / 5 \nResult: 14.55\n---\nExpression: (2 + 3) * (4 - 1)\nResult: 15\n---\nExpression: 10 / (2 + 3) * 4\nResult: 8\n---", "task_id": 7436, "assertions": "assert = require 'assert'\n\ntestEvaluateExpression = ->\n  assert.strictEqual evaluateExpression(\"1 + 2 * 3\"), 7\n  assert.strictEqual evaluateExpression(\"(1 + 2) * 3\"), 9\n  assert.strictEqual evaluateExpression(\"10 - 4 / 2\"), 8\n  assert.strictEqual evaluateExpression(\"2 * 3 + 4 / 2 - 1\"), 7\n  assert.strictEqual evaluateExpression(\"2 * (3 + 4) / 2\"), 7\n  assert.strictEqual evaluateExpression(\"10.5 + 20.25 / 5\"), 14.55\n  assert.strictEqual evaluateExpression(\"(2 + 3) * (4 - 1)\"), 15\n  assert.strictEqual evaluateExpression(\"10 / (2 + 3) * 4\"), 8\n\ntestEvaluateExpression()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestEvaluateExpression = ->\n  assert.strictEqual evaluateExpression(\"1 + 2 * 3\"), 7\n  assert.strictEqual evaluateExpression(\"(1 + 2) * 3\"), 9\n  assert.strictEqual evaluateExpression(\"10 - 4 / 2\"), 8\n  assert.strictEqual evaluateExpression(\"2 * 3 + 4 / 2 - 1\"), 7\n  assert.strictEqual evaluateExpression(\"2 * (3 + 4) / 2\"), 7\n  assert.strictEqual evaluateExpression(\"10.5 + 20.25 / 5\"), 14.55\n  assert.strictEqual evaluateExpression(\"(2 + 3) * (4 - 1)\"), 15\n  assert.strictEqual evaluateExpression(\"10 / (2 + 3) * 4\"), 8\n\ntestEvaluateExpression()", "output": "evaluateExpression"}, "all_code": "# Evaluates a mathematical expression given as a string.\n# Handles algebraic operations: addition, subtraction, multiplication, and division.\n# Ignores any white spaces in the input.\n# Proper order of operations is maintained (PEMDAS/BODMAS rules).\nevaluateExpression = (expression) ->\n  # Helper function to perform basic arithmetic operations\n  operate = (a, b, operator) ->\n    switch operator\n      when '+' then a + b\n      when '-' then a - b\n      when '*' then a * b\n      when '/' then a / b\n\n  # Remove all whitespace from the expression\n  expression = expression.replace /\\s/g, ''\n\n  # Tokenize the input string into numbers and operators\n  tokens = expression.match(/\\d+\\.?\\d*|[+\\-*/()]/g) or []\n\n  evaluate = (tokens) ->\n    opStack = []\n    valStack = []\n\n    applyOperator = ->\n      operator = opStack.pop()\n      right = valStack.pop()\n      left = valStack.pop()\n      valStack.push operate(left, right, operator)\n\n    i = 0\n    while i < tokens.length\n      token = tokens[i]\n      if /^\\d+\\.?\\d*$/.test token\n        valStack.push parseFloat(token)\n      else if token is '('\n        opStack.push token\n      else if token is ')'\n        while opStack.length and opStack[opStack.length - 1] isnt '('\n          applyOperator()\n        opStack.pop() # pop '('\n      else\n        while opStack.length and opStack[opStack.length - 1] in ['*', '/', '+', '-'] and\n              (token in ['+', '-'] or opStack[opStack.length - 1] in ['*', '/'])\n          applyOperator()\n        opStack.push token\n      i++\n\n    while opStack.length\n      applyOperator()\n\n    valStack[0]\n\n  result = evaluate tokens\n  parseFloat(result.toFixed(2))\nassert = require 'assert'\n\ntestEvaluateExpression = ->\n  assert.strictEqual evaluateExpression(\"1 + 2 * 3\"), 7\n  assert.strictEqual evaluateExpression(\"(1 + 2) * 3\"), 9\n  assert.strictEqual evaluateExpression(\"10 - 4 / 2\"), 8\n  assert.strictEqual evaluateExpression(\"2 * 3 + 4 / 2 - 1\"), 7\n  assert.strictEqual evaluateExpression(\"2 * (3 + 4) / 2\"), 7\n  assert.strictEqual evaluateExpression(\"10.5 + 20.25 / 5\"), 14.55\n  assert.strictEqual evaluateExpression(\"(2 + 3) * (4 - 1)\"), 15\n  assert.strictEqual evaluateExpression(\"10 / (2 + 3) * 4\"), 8\n\ntestEvaluateExpression()", "exec_outcome": "PASSED"}
{"code": "# leastFrequentElement finds the least frequently occurring element in an array.\n# If multiple elements have the same frequency, it returns the first one encountered.\n# Returns null if the input array is empty.\nleastFrequentElement = (data) ->\n  return null unless data.length\n  frequencyCount = {}\n  \n  # Count the frequency of each element\n  for element in data\n    frequencyCount[element] ?= 0\n    frequencyCount[element] += 1\n  \n  # Find the element with the minimum frequency\n  minFrequency = Infinity\n  result = null\n  for element, count of frequencyCount\n    if count < minFrequency\n      minFrequency = count\n      result = element\n  result", "test_cases": "", "test_case_results": "Input: [ 1, 2, 2, 3, 3, 3 ]\nLeast frequent element: 1\nInput: [ 'a', 'b', 'b', 'c', 'c', 'c' ]\nLeast frequent element: a\nInput: [\n  10, 10, 20, 20,\n  20, 30, 30\n]\nLeast frequent element: 10\nInput: []\nLeast frequent element: null\nInput: [ 5 ]\nLeast frequent element: 5\nInput: [ 1, 1, 2, 2, 3, 3 ]\nLeast frequent element: 1", "task_id": 1367, "assertions": "assert = require 'assert'\n\ntestLeastFrequentElement = ->\n  # Test cases based on provided results\n  assert.strictEqual leastFrequentElement([1, 2, 2, 3, 3, 3]), 1\n  assert.strictEqual leastFrequentElement(['a', 'b', 'b', 'c', 'c', 'c']), 'a'\n  assert.strictEqual leastFrequentElement([10, 10, 20, 20, 20, 30, 30]), 10\n  assert.strictEqual leastFrequentElement([]), null\n  assert.strictEqual leastFrequentElement([5]), 5\n  assert.strictEqual leastFrequentElement([1, 1, 2, 2, 3, 3]), 1\n  console.log \"All tests passed!\"\n\ntestLeastFrequentElement()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestLeastFrequentElement = ->\n  # Test cases based on provided results\n  assert.strictEqual leastFrequentElement([1, 2, 2, 3, 3, 3]), 1\n  assert.strictEqual leastFrequentElement(['a', 'b', 'b', 'c', 'c', 'c']), 'a'\n  assert.strictEqual leastFrequentElement([10, 10, 20, 20, 20, 30, 30]), 10\n  assert.strictEqual leastFrequentElement([]), null\n  assert.strictEqual leastFrequentElement([5]), 5\n  assert.strictEqual leastFrequentElement([1, 1, 2, 2, 3, 3]), 1\n  console.log \"All tests passed!\"\n\ntestLeastFrequentElement()", "output": "leastFrequentElement"}, "all_code": "# leastFrequentElement finds the least frequently occurring element in an array.\n# If multiple elements have the same frequency, it returns the first one encountered.\n# Returns null if the input array is empty.\nleastFrequentElement = (data) ->\n  return null unless data.length\n  frequencyCount = {}\n  \n  # Count the frequency of each element\n  for element in data\n    frequencyCount[element] ?= 0\n    frequencyCount[element] += 1\n  \n  # Find the element with the minimum frequency\n  minFrequency = Infinity\n  result = null\n  for element, count of frequencyCount\n    if count < minFrequency\n      minFrequency = count\n      result = element\n  result\nassert = require 'assert'\n\ntestLeastFrequentElement = ->\n  # Test cases based on provided results\n  assert.strictEqual leastFrequentElement([1, 2, 2, 3, 3, 3]), 1\n  assert.strictEqual leastFrequentElement(['a', 'b', 'b', 'c', 'c', 'c']), 'a'\n  assert.strictEqual leastFrequentElement([10, 10, 20, 20, 20, 30, 30]), 10\n  assert.strictEqual leastFrequentElement([]), null\n  assert.strictEqual leastFrequentElement([5]), 5\n  assert.strictEqual leastFrequentElement([1, 1, 2, 2, 3, 3]), 1\n  console.log \"All tests passed!\"\n\ntestLeastFrequentElement()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# customSort returns a sorted version of the list, treating numbers divisible by 3 as negative\n# in the sorting order. This is achieved by using a custom key function that inverts the value\n# for numbers divisible by 3 while keeping others unchanged.\ncustomSort = (lst) ->\n  # Define the custom sort key function\n  sortKey = (x) ->\n    if x % 3 is 0 then -x else x\n  \n  # Return a new sorted array using the custom key\n  lst.slice().sort (a, b) -> sortKey(a) - sortKey(b)", "test_cases": "", "test_case_results": "Input: [ 3, 1, 2, 6, 4, 5 ]\nSorted: [ 6, 3, 1, 2, 4, 5 ]\nInput: [ 9, 0, -3, 12, -6 ]\nSorted: [ 12, 9, 0, -3, -6 ]\nInput: [ 1, 4, 7, 2, 5, 8 ]\nSorted: [ 1, 2, 4, 5, 7, 8 ]\nInput: []\nSorted: []\nInput: [ 3 ]\nSorted: [ 3 ]\nInput: [ 2 ]\nSorted: [ 2 ]", "task_id": 20378, "assertions": "assert = require 'assert'\n\ntestCustomSort = ->\n  assert.deepStrictEqual customSort([3, 1, 2, 6, 4, 5]), [6, 3, 1, 2, 4, 5]\n  assert.deepStrictEqual customSort([9, 0, -3, 12, -6]), [12, 9, 0, -3, -6]\n  assert.deepStrictEqual customSort([1, 4, 7, 2, 5, 8]), [1, 2, 4, 5, 7, 8]\n  assert.deepStrictEqual customSort([]), []\n  assert.deepStrictEqual customSort([3]), [3]\n  assert.deepStrictEqual customSort([2]), [2]\n  console.log \"All tests passed!\"\n\ntestCustomSort()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCustomSort = ->\n  assert.deepStrictEqual customSort([3, 1, 2, 6, 4, 5]), [6, 3, 1, 2, 4, 5]\n  assert.deepStrictEqual customSort([9, 0, -3, 12, -6]), [12, 9, 0, -3, -6]\n  assert.deepStrictEqual customSort([1, 4, 7, 2, 5, 8]), [1, 2, 4, 5, 7, 8]\n  assert.deepStrictEqual customSort([]), []\n  assert.deepStrictEqual customSort([3]), [3]\n  assert.deepStrictEqual customSort([2]), [2]\n  console.log \"All tests passed!\"\n\ntestCustomSort()", "output": "customSort"}, "all_code": "# customSort returns a sorted version of the list, treating numbers divisible by 3 as negative\n# in the sorting order. This is achieved by using a custom key function that inverts the value\n# for numbers divisible by 3 while keeping others unchanged.\ncustomSort = (lst) ->\n  # Define the custom sort key function\n  sortKey = (x) ->\n    if x % 3 is 0 then -x else x\n  \n  # Return a new sorted array using the custom key\n  lst.slice().sort (a, b) -> sortKey(a) - sortKey(b)\nassert = require 'assert'\n\ntestCustomSort = ->\n  assert.deepStrictEqual customSort([3, 1, 2, 6, 4, 5]), [6, 3, 1, 2, 4, 5]\n  assert.deepStrictEqual customSort([9, 0, -3, 12, -6]), [12, 9, 0, -3, -6]\n  assert.deepStrictEqual customSort([1, 4, 7, 2, 5, 8]), [1, 2, 4, 5, 7, 8]\n  assert.deepStrictEqual customSort([]), []\n  assert.deepStrictEqual customSort([3]), [3]\n  assert.deepStrictEqual customSort([2]), [2]\n  console.log \"All tests passed!\"\n\ntestCustomSort()", "exec_outcome": "PASSED"}
{"code": "# calculateAdditionalPixels computes how many pixels need to be added to an image\n# to make its width and height divisible by a given factor.\n# The calculation accounts for both width and height adjustments, including the\n# interaction between them (adding width affects height padding needs).\n#\n# @param {number} width - original image width in pixels\n# @param {number} height - original image height in pixels\n# @param {number} factor - the divisibility factor\n# @return {number} total additional pixels needed\ncalculateAdditionalPixels = (width, height, factor) ->\n  additionalWidth = (factor - (width % factor)) % factor\n  additionalHeight = (factor - (height % factor)) % factor\n  \n  additionalWidth * height + additionalHeight * (width + additionalWidth)", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: width=100, height=150, factor=16\n  Result: 2920 additional pixels needed\n\nTest Case 2:\n  Input: width=17, height=23, factor=8\n  Result: 185 additional pixels needed\n\nTest Case 3:\n  Input: width=1024, height=768, factor=32\n  Result: 0 additional pixels needed\n\nTest Case 4:\n  Input: width=1920, height=1080, factor=1\n  Result: 0 additional pixels needed\n\nTest Case 5:\n  Input: width=100, height=100, factor=100\n  Result: 0 additional pixels needed", "task_id": 1724, "assertions": "assert = require 'assert'\n\ntestCalculateAdditionalPixels = ->\n  # Test Case 1: Common image size case\n  assert.strictEqual calculateAdditionalPixels(100, 150, 16), 2920\n  \n  # Test Case 2: Small prime dimensions\n  assert.strictEqual calculateAdditionalPixels(17, 23, 8), 185\n  \n  # Test Case 3: Power-of-two dimensions\n  assert.strictEqual calculateAdditionalPixels(1024, 768, 32), 0\n  \n  # Test Case 4: Edge case - factor 1 (no padding needed)\n  assert.strictEqual calculateAdditionalPixels(1920, 1080, 1), 0\n  \n  # Test Case 5: Exact multiple case\n  assert.strictEqual calculateAdditionalPixels(100, 100, 100), 0\n\ntestCalculateAdditionalPixels()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCalculateAdditionalPixels = ->\n  # Test Case 1: Common image size case\n  assert.strictEqual calculateAdditionalPixels(100, 150, 16), 2920\n  \n  # Test Case 2: Small prime dimensions\n  assert.strictEqual calculateAdditionalPixels(17, 23, 8), 185\n  \n  # Test Case 3: Power-of-two dimensions\n  assert.strictEqual calculateAdditionalPixels(1024, 768, 32), 0\n  \n  # Test Case 4: Edge case - factor 1 (no padding needed)\n  assert.strictEqual calculateAdditionalPixels(1920, 1080, 1), 0\n  \n  # Test Case 5: Exact multiple case\n  assert.strictEqual calculateAdditionalPixels(100, 100, 100), 0\n\ntestCalculateAdditionalPixels()", "output": "calculateAdditionalPixels"}, "all_code": "# calculateAdditionalPixels computes how many pixels need to be added to an image\n# to make its width and height divisible by a given factor.\n# The calculation accounts for both width and height adjustments, including the\n# interaction between them (adding width affects height padding needs).\n#\n# @param {number} width - original image width in pixels\n# @param {number} height - original image height in pixels\n# @param {number} factor - the divisibility factor\n# @return {number} total additional pixels needed\ncalculateAdditionalPixels = (width, height, factor) ->\n  additionalWidth = (factor - (width % factor)) % factor\n  additionalHeight = (factor - (height % factor)) % factor\n  \n  additionalWidth * height + additionalHeight * (width + additionalWidth)\nassert = require 'assert'\n\ntestCalculateAdditionalPixels = ->\n  # Test Case 1: Common image size case\n  assert.strictEqual calculateAdditionalPixels(100, 150, 16), 2920\n  \n  # Test Case 2: Small prime dimensions\n  assert.strictEqual calculateAdditionalPixels(17, 23, 8), 185\n  \n  # Test Case 3: Power-of-two dimensions\n  assert.strictEqual calculateAdditionalPixels(1024, 768, 32), 0\n  \n  # Test Case 4: Edge case - factor 1 (no padding needed)\n  assert.strictEqual calculateAdditionalPixels(1920, 1080, 1), 0\n  \n  # Test Case 5: Exact multiple case\n  assert.strictEqual calculateAdditionalPixels(100, 100, 100), 0\n\ntestCalculateAdditionalPixels()", "exec_outcome": "PASSED"}
{"code": "# rotateListInPlace rotates a list to the right by k elements in place.\n# Handles negative values of k and values larger than the list length.\n# Modifies the original array and returns nothing.\nrotateListInPlace = (lst, k) ->\n  n = lst.length\n  return if n is 0  # No rotation needed for empty list\n\n  # Normalize k to be within list bounds\n  k = k %% n\n  k += n if k < 0  # Handle negative rotations\n\n  # Perform rotation by concatenating the last k elements with the rest\n  lst[..] = lst[-k..].concat(lst[...-k])", "test_cases": "", "test_case_results": "Original list: [ 1, 2, 3, 4, 5 ]\nRotation by: 2\nRotated list: [ 4, 5, 1, 2, 3 ]\n----------------------\nOriginal list: [ 1, 2, 3, 4, 5 ]\nRotation by: -1\nRotated list: [ 2, 3, 4, 5, 1 ]\n----------------------\nOriginal list: [ 1, 2, 3, 4, 5 ]\nRotation by: 7\nRotated list: [ 4, 5, 1, 2, 3 ]\n----------------------\nOriginal list: [ 1, 2, 3, 4, 5 ]\nRotation by: 0\nRotated list: [ 1, 2, 3, 4, 5 ]\n----------------------\nOriginal list: []\nRotation by: 3\nRotated list: []\n----------------------\nOriginal list: [ 'a', 'b', 'c' ]\nRotation by: 1\nRotated list: [ 'c', 'a', 'b' ]\n----------------------", "task_id": 15216, "assertions": "assert = require 'assert'\n\ntestRotateListInPlace = ->\n  # Test normal rotation\n  list1 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list1, 2)\n  assert.deepStrictEqual list1, [4, 5, 1, 2, 3]\n\n  # Test negative rotation\n  list2 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list2, -1)\n  assert.deepStrictEqual list2, [2, 3, 4, 5, 1]\n\n  # Test rotation larger than list length\n  list3 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list3, 7)\n  assert.deepStrictEqual list3, [4, 5, 1, 2, 3]\n\n  # Test no rotation\n  list4 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list4, 0)\n  assert.deepStrictEqual list4, [1, 2, 3, 4, 5]\n\n  # Test empty list\n  list5 = []\n  rotateListInPlace(list5, 3)\n  assert.deepStrictEqual list5, []\n\n  # Test non-numeric list\n  list6 = ['a', 'b', 'c']\n  rotateListInPlace(list6, 1)\n  assert.deepStrictEqual list6, ['c', 'a', 'b']\n\ntestRotateListInPlace()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestRotateListInPlace = ->\n  # Test normal rotation\n  list1 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list1, 2)\n  assert.deepStrictEqual list1, [4, 5, 1, 2, 3]\n\n  # Test negative rotation\n  list2 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list2, -1)\n  assert.deepStrictEqual list2, [2, 3, 4, 5, 1]\n\n  # Test rotation larger than list length\n  list3 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list3, 7)\n  assert.deepStrictEqual list3, [4, 5, 1, 2, 3]\n\n  # Test no rotation\n  list4 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list4, 0)\n  assert.deepStrictEqual list4, [1, 2, 3, 4, 5]\n\n  # Test empty list\n  list5 = []\n  rotateListInPlace(list5, 3)\n  assert.deepStrictEqual list5, []\n\n  # Test non-numeric list\n  list6 = ['a', 'b', 'c']\n  rotateListInPlace(list6, 1)\n  assert.deepStrictEqual list6, ['c', 'a', 'b']\n\ntestRotateListInPlace()", "output": "rotateListInPlace"}, "all_code": "# rotateListInPlace rotates a list to the right by k elements in place.\n# Handles negative values of k and values larger than the list length.\n# Modifies the original array and returns nothing.\nrotateListInPlace = (lst, k) ->\n  n = lst.length\n  return if n is 0  # No rotation needed for empty list\n\n  # Normalize k to be within list bounds\n  k = k %% n\n  k += n if k < 0  # Handle negative rotations\n\n  # Perform rotation by concatenating the last k elements with the rest\n  lst[..] = lst[-k..].concat(lst[...-k])\nassert = require 'assert'\n\ntestRotateListInPlace = ->\n  # Test normal rotation\n  list1 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list1, 2)\n  assert.deepStrictEqual list1, [4, 5, 1, 2, 3]\n\n  # Test negative rotation\n  list2 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list2, -1)\n  assert.deepStrictEqual list2, [2, 3, 4, 5, 1]\n\n  # Test rotation larger than list length\n  list3 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list3, 7)\n  assert.deepStrictEqual list3, [4, 5, 1, 2, 3]\n\n  # Test no rotation\n  list4 = [1, 2, 3, 4, 5]\n  rotateListInPlace(list4, 0)\n  assert.deepStrictEqual list4, [1, 2, 3, 4, 5]\n\n  # Test empty list\n  list5 = []\n  rotateListInPlace(list5, 3)\n  assert.deepStrictEqual list5, []\n\n  # Test non-numeric list\n  list6 = ['a', 'b', 'c']\n  rotateListInPlace(list6, 1)\n  assert.deepStrictEqual list6, ['c', 'a', 'b']\n\ntestRotateListInPlace()", "exec_outcome": "PASSED"}
{"code": "# findMinimumWeights calculates the minimum number of weights needed to measure every weight\n# from 1 to n using powers of 3. The strategy is to use weights that are powers of 3\n# (1, 3, 9, 27, ...) which allows measuring any weight using the minimal number of weights.\nfindMinimumWeights = (n) ->\n  weights = []\n  currentWeight = 1\n  \n  while currentWeight <= n\n    weights.push(currentWeight)\n    currentWeight *= 3\n  \n  weights.length", "test_cases": "", "test_case_results": "Input: 1\nMinimum weights needed: 1\n---\nInput: 4\nMinimum weights needed: 2\n---\nInput: 13\nMinimum weights needed: 3\n---\nInput: 40\nMinimum weights needed: 4\n---\nInput: 100\nMinimum weights needed: 5\n---\nInput: 0\nMinimum weights needed: 0\n---", "task_id": 9495, "assertions": "assert = require 'assert'\n\ntestFindMinimumWeights = ->\n  assert.strictEqual findMinimumWeights(1), 1\n  assert.strictEqual findMinimumWeights(4), 2\n  assert.strictEqual findMinimumWeights(13), 3\n  assert.strictEqual findMinimumWeights(40), 4\n  assert.strictEqual findMinimumWeights(100), 5\n  assert.strictEqual findMinimumWeights(0), 0\n  console.log \"All tests passed!\"\n\ntestFindMinimumWeights()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindMinimumWeights = ->\n  assert.strictEqual findMinimumWeights(1), 1\n  assert.strictEqual findMinimumWeights(4), 2\n  assert.strictEqual findMinimumWeights(13), 3\n  assert.strictEqual findMinimumWeights(40), 4\n  assert.strictEqual findMinimumWeights(100), 5\n  assert.strictEqual findMinimumWeights(0), 0\n  console.log \"All tests passed!\"\n\ntestFindMinimumWeights()", "output": "findMinimumWeights"}, "all_code": "# findMinimumWeights calculates the minimum number of weights needed to measure every weight\n# from 1 to n using powers of 3. The strategy is to use weights that are powers of 3\n# (1, 3, 9, 27, ...) which allows measuring any weight using the minimal number of weights.\nfindMinimumWeights = (n) ->\n  weights = []\n  currentWeight = 1\n  \n  while currentWeight <= n\n    weights.push(currentWeight)\n    currentWeight *= 3\n  \n  weights.length\nassert = require 'assert'\n\ntestFindMinimumWeights = ->\n  assert.strictEqual findMinimumWeights(1), 1\n  assert.strictEqual findMinimumWeights(4), 2\n  assert.strictEqual findMinimumWeights(13), 3\n  assert.strictEqual findMinimumWeights(40), 4\n  assert.strictEqual findMinimumWeights(100), 5\n  assert.strictEqual findMinimumWeights(0), 0\n  console.log \"All tests passed!\"\n\ntestFindMinimumWeights()", "exec_outcome": "PASSED"}
{"code": "# isAnagram checks if two strings are anagrams using recursive methods only\nisAnagram = (s1, s2) ->\n  # cleanString converts a string into a list of characters recursively\n  cleanString = (s) ->\n    return [] if s is \"\"\n    [s[0]].concat cleanString s[1..]\n  \n  # checkAnagram recursively verifies if two character lists are anagrams\n  checkAnagram = (l1, l2) ->\n    return l2.length is 0 if l1.length is 0\n    if l1[0] in l2\n      index = l2.indexOf l1[0]\n      remaining = l2[...index].concat l2[index+1..]\n      checkAnagram l1[1..], remaining\n    else\n      false\n  \n  checkAnagram cleanString(s1), cleanString(s2)", "test_cases": "", "test_case_results": "Input: { s1: 'listen', s2: 'silent' }\nAre anagrams: true\n\nInput: { s1: 'triangle', s2: 'integral' }\nAre anagrams: true\n\nInput: { s1: 'hello', s2: 'world' }\nAre anagrams: false\n\nInput: { s1: 'anagram', s2: 'nag a ram' }\nAre anagrams: false\n\nInput: { s1: '', s2: '' }\nAre anagrams: true\n\nInput: { s1: 'a', s2: 'a' }\nAre anagrams: true\n\nInput: { s1: 'abc', s2: 'cba' }\nAre anagrams: true", "task_id": 27806, "assertions": "assert = require 'assert'\n\ntestIsAnagram = ->\n  assert.strictEqual isAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual isAnagram(\"triangle\", \"integral\"), true\n  assert.strictEqual isAnagram(\"hello\", \"world\"), false\n  assert.strictEqual isAnagram(\"anagram\", \"nag a ram\"), false\n  assert.strictEqual isAnagram(\"\", \"\"), true\n  assert.strictEqual isAnagram(\"a\", \"a\"), true\n  assert.strictEqual isAnagram(\"abc\", \"cba\"), true\n  console.log \"All tests passed!\"\n\ntestIsAnagram()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestIsAnagram = ->\n  assert.strictEqual isAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual isAnagram(\"triangle\", \"integral\"), true\n  assert.strictEqual isAnagram(\"hello\", \"world\"), false\n  assert.strictEqual isAnagram(\"anagram\", \"nag a ram\"), false\n  assert.strictEqual isAnagram(\"\", \"\"), true\n  assert.strictEqual isAnagram(\"a\", \"a\"), true\n  assert.strictEqual isAnagram(\"abc\", \"cba\"), true\n  console.log \"All tests passed!\"\n\ntestIsAnagram()", "output": "isAnagram"}, "all_code": "# isAnagram checks if two strings are anagrams using recursive methods only\nisAnagram = (s1, s2) ->\n  # cleanString converts a string into a list of characters recursively\n  cleanString = (s) ->\n    return [] if s is \"\"\n    [s[0]].concat cleanString s[1..]\n  \n  # checkAnagram recursively verifies if two character lists are anagrams\n  checkAnagram = (l1, l2) ->\n    return l2.length is 0 if l1.length is 0\n    if l1[0] in l2\n      index = l2.indexOf l1[0]\n      remaining = l2[...index].concat l2[index+1..]\n      checkAnagram l1[1..], remaining\n    else\n      false\n  \n  checkAnagram cleanString(s1), cleanString(s2)\nassert = require 'assert'\n\ntestIsAnagram = ->\n  assert.strictEqual isAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual isAnagram(\"triangle\", \"integral\"), true\n  assert.strictEqual isAnagram(\"hello\", \"world\"), false\n  assert.strictEqual isAnagram(\"anagram\", \"nag a ram\"), false\n  assert.strictEqual isAnagram(\"\", \"\"), true\n  assert.strictEqual isAnagram(\"a\", \"a\"), true\n  assert.strictEqual isAnagram(\"abc\", \"cba\"), true\n  console.log \"All tests passed!\"\n\ntestIsAnagram()", "exec_outcome": "PASSED"}
{"code": "# minCookies calculates the minimum number of cookies to distribute based on ratings.\n# Each child must get at least 1 cookie and must get more than adjacent children with lower ratings.\n# The function uses a two-pass approach:\n#   1. Left to right pass to ensure higher-rated children get more cookies than their left neighbor\n#   2. Right to left pass to ensure higher-rated children get more cookies than their right neighbor\nminCookies = (ratings) ->\n  n = ratings.length\n  \n  return 1 if n is 1\n\n  cookies = (1 for i in [0...n])\n\n  # Left to right pass\n  for i in [1...n]\n    if ratings[i] > ratings[i - 1]\n      cookies[i] = cookies[i - 1] + 1\n\n  # Right to left pass\n  for i in [n-2..0]\n    if ratings[i] > ratings[i + 1]\n      cookies[i] = Math.max(cookies[i], cookies[i + 1] + 1)\n\n  cookies.reduce ((sum, val) -> sum + val), 0", "test_cases": "", "test_case_results": "Test Case 1:\n  Ratings: [ 1, 2, 2 ]\n  Minimum Cookies: 4\n\nTest Case 2:\n  Ratings: [ 5, 4, 3, 2, 1 ]\n  Minimum Cookies: 15\n\nTest Case 3:\n  Ratings: [ 1, 3, 2, 1 ]\n  Minimum Cookies: 7\n\nTest Case 4:\n  Ratings: [ 1 ]\n  Minimum Cookies: 1\n\nTest Case 5:\n  Ratings: [ 1, 2, 3, 4, 5 ]\n  Minimum Cookies: 15\n\nTest Case 6:\n  Ratings: [ 2, 2, 2, 2 ]\n  Minimum Cookies: 4\n\nTest Case 7:\n  Ratings: [ 1, 2, 3, 3, 2, 1 ]\n  Minimum Cookies: 12", "task_id": 12764, "assertions": "assert = require 'assert'\n\ntestMinCookies = ->\n  assert.strictEqual minCookies([1, 2, 2]), 4\n  assert.strictEqual minCookies([5, 4, 3, 2, 1]), 15\n  assert.strictEqual minCookies([1, 3, 2, 1]), 7\n  assert.strictEqual minCookies([1]), 1\n  assert.strictEqual minCookies([1, 2, 3, 4, 5]), 15\n  assert.strictEqual minCookies([2, 2, 2, 2]), 4\n  assert.strictEqual minCookies([1, 2, 3, 3, 2, 1]), 12\n\ntestMinCookies()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinCookies = ->\n  assert.strictEqual minCookies([1, 2, 2]), 4\n  assert.strictEqual minCookies([5, 4, 3, 2, 1]), 15\n  assert.strictEqual minCookies([1, 3, 2, 1]), 7\n  assert.strictEqual minCookies([1]), 1\n  assert.strictEqual minCookies([1, 2, 3, 4, 5]), 15\n  assert.strictEqual minCookies([2, 2, 2, 2]), 4\n  assert.strictEqual minCookies([1, 2, 3, 3, 2, 1]), 12\n\ntestMinCookies()", "output": "minCookies"}, "all_code": "# minCookies calculates the minimum number of cookies to distribute based on ratings.\n# Each child must get at least 1 cookie and must get more than adjacent children with lower ratings.\n# The function uses a two-pass approach:\n#   1. Left to right pass to ensure higher-rated children get more cookies than their left neighbor\n#   2. Right to left pass to ensure higher-rated children get more cookies than their right neighbor\nminCookies = (ratings) ->\n  n = ratings.length\n  \n  return 1 if n is 1\n\n  cookies = (1 for i in [0...n])\n\n  # Left to right pass\n  for i in [1...n]\n    if ratings[i] > ratings[i - 1]\n      cookies[i] = cookies[i - 1] + 1\n\n  # Right to left pass\n  for i in [n-2..0]\n    if ratings[i] > ratings[i + 1]\n      cookies[i] = Math.max(cookies[i], cookies[i + 1] + 1)\n\n  cookies.reduce ((sum, val) -> sum + val), 0\nassert = require 'assert'\n\ntestMinCookies = ->\n  assert.strictEqual minCookies([1, 2, 2]), 4\n  assert.strictEqual minCookies([5, 4, 3, 2, 1]), 15\n  assert.strictEqual minCookies([1, 3, 2, 1]), 7\n  assert.strictEqual minCookies([1]), 1\n  assert.strictEqual minCookies([1, 2, 3, 4, 5]), 15\n  assert.strictEqual minCookies([2, 2, 2, 2]), 4\n  assert.strictEqual minCookies([1, 2, 3, 3, 2, 1]), 12\n\ntestMinCookies()", "exec_outcome": "PASSED"}
{"code": "# calculateBezierPoint calculates the point on a quadratic Bzier curve at parameter t.\n# \n# Parameters:\n# - t: A parameter between 0 and 1 that defines the position along the Bzier curve\n# - p0: The start point of the curve as [x, y]\n# - p1: The control point of the curve as [x, y]\n# - p2: The end point of the curve as [x, y]\n#\n# Returns:\n# - An array [x, y] representing the point on the Bzier curve at parameter t\ncalculateBezierPoint = (t, p0, p1, p2) ->\n  # Calculate intermediate points\n  Q1 = [\n    (1 - t) * p0[0] + t * p1[0],\n    (1 - t) * p0[1] + t * p1[1]\n  ]\n  Q2 = [\n    (1 - t) * p1[0] + t * p2[0],\n    (1 - t) * p1[1] + t * p2[1]\n  ]\n  \n  # Calculate and return the final Bezier point\n  [\n    (1 - t) * Q1[0] + t * Q2[0],\n    (1 - t) * Q1[1] + t * Q2[1]\n  ]", "test_cases": "", "test_case_results": "Test Case: Start point of the curve\nInput: t=0, p0=0,0, p1=1,1, p2=2,0\nResult: [ 0, 0 ]\n\nTest Case: End point of the curve\nInput: t=1, p0=0,0, p1=1,1, p2=2,0\nResult: [ 2, 0 ]\n\nTest Case: Midpoint of the curve\nInput: t=0.5, p0=0,0, p1=1,1, p2=2,0\nResult: [ 1, 0.5 ]\n\nTest Case: Quarter point of a wider curve\nInput: t=0.25, p0=0,0, p1=2,2, p2=4,0\nResult: [ 1, 0.75 ]", "task_id": 22312, "assertions": "assert = require 'assert'\n\ntestBezierCurve = ->\n  # Test case 1: Start point of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.0, [0, 0], [1, 1], [2, 0]), [0, 0]\n  \n  # Test case 2: End point of the curve\n  assert.deepStrictEqual calculateBezierPoint(1.0, [0, 0], [1, 1], [2, 0]), [2, 0]\n  \n  # Test case 3: Midpoint of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.5, [0, 0], [1, 1], [2, 0]), [1, 0.5]\n  \n  # Test case 4: Quarter point of a wider curve\n  assert.deepStrictEqual calculateBezierPoint(0.25, [0, 0], [2, 2], [4, 0]), [1, 0.75]\n  \n  console.log \"All tests passed successfully!\"\n\ntestBezierCurve()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestBezierCurve = ->\n  # Test case 1: Start point of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.0, [0, 0], [1, 1], [2, 0]), [0, 0]\n  \n  # Test case 2: End point of the curve\n  assert.deepStrictEqual calculateBezierPoint(1.0, [0, 0], [1, 1], [2, 0]), [2, 0]\n  \n  # Test case 3: Midpoint of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.5, [0, 0], [1, 1], [2, 0]), [1, 0.5]\n  \n  # Test case 4: Quarter point of a wider curve\n  assert.deepStrictEqual calculateBezierPoint(0.25, [0, 0], [2, 2], [4, 0]), [1, 0.75]\n  \n  console.log \"All tests passed successfully!\"\n\ntestBezierCurve()", "output": "calculateBezierPoint"}, "all_code": "# calculateBezierPoint calculates the point on a quadratic Bzier curve at parameter t.\n# \n# Parameters:\n# - t: A parameter between 0 and 1 that defines the position along the Bzier curve\n# - p0: The start point of the curve as [x, y]\n# - p1: The control point of the curve as [x, y]\n# - p2: The end point of the curve as [x, y]\n#\n# Returns:\n# - An array [x, y] representing the point on the Bzier curve at parameter t\ncalculateBezierPoint = (t, p0, p1, p2) ->\n  # Calculate intermediate points\n  Q1 = [\n    (1 - t) * p0[0] + t * p1[0],\n    (1 - t) * p0[1] + t * p1[1]\n  ]\n  Q2 = [\n    (1 - t) * p1[0] + t * p2[0],\n    (1 - t) * p1[1] + t * p2[1]\n  ]\n  \n  # Calculate and return the final Bezier point\n  [\n    (1 - t) * Q1[0] + t * Q2[0],\n    (1 - t) * Q1[1] + t * Q2[1]\n  ]\nassert = require 'assert'\n\ntestBezierCurve = ->\n  # Test case 1: Start point of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.0, [0, 0], [1, 1], [2, 0]), [0, 0]\n  \n  # Test case 2: End point of the curve\n  assert.deepStrictEqual calculateBezierPoint(1.0, [0, 0], [1, 1], [2, 0]), [2, 0]\n  \n  # Test case 3: Midpoint of the curve\n  assert.deepStrictEqual calculateBezierPoint(0.5, [0, 0], [1, 1], [2, 0]), [1, 0.5]\n  \n  # Test case 4: Quarter point of a wider curve\n  assert.deepStrictEqual calculateBezierPoint(0.25, [0, 0], [2, 2], [4, 0]), [1, 0.75]\n  \n  console.log \"All tests passed successfully!\"\n\ntestBezierCurve()", "exec_outcome": "PASSED"}
{"code": "# minTimeToAlignRobots calculates the minimum time required for all robots to reach the same position.\n# The optimal position is the median of all positions, which minimizes total travel time.\n# \n# Args:\n# positions (array): Array of integers representing positions of robots.\n#\n# Returns:\n# int: Minimum time required for all robots to align at the same position.\nminTimeToAlignRobots = (positions) ->\n  # Sort the positions array\n  sortedPositions = positions.slice().sort (a, b) -> a - b\n  \n  # Find the median position (middle element for odd length, either middle for even)\n  medianIndex = Math.floor(sortedPositions.length / 2)\n  medianPosition = sortedPositions[medianIndex]\n  \n  # Calculate total time by summing absolute differences from median\n  totalTime = sortedPositions.reduce (sum, pos) ->\n    sum + Math.abs(pos - medianPosition)\n  , 0\n  \n  totalTime", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Positions: [ 1, 2, 3, 4, 5 ]\n  Minimum Alignment Time: 6\n\nTest Case 2:\n  Input Positions: [ 10, 20, 30, 40 ]\n  Minimum Alignment Time: 40\n\nTest Case 3:\n  Input Positions: [ 0, 0, 0, 0, 0 ]\n  Minimum Alignment Time: 0\n\nTest Case 4:\n  Input Positions: [ 5 ]\n  Minimum Alignment Time: 0\n\nTest Case 5:\n  Input Positions: [ -5, 0, 5 ]\n  Minimum Alignment Time: 10\n\nTest Case 6:\n  Input Positions: [ 100, 200, 300, 400 ]\n  Minimum Alignment Time: 400", "task_id": 14564, "assertions": "assert = require 'assert'\n\ntestMinTimeToAlignRobots = ->\n  assert.strictEqual minTimeToAlignRobots([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTimeToAlignRobots([10, 20, 30, 40]), 40\n  assert.strictEqual minTimeToAlignRobots([0, 0, 0, 0, 0]), 0\n  assert.strictEqual minTimeToAlignRobots([5]), 0\n  assert.strictEqual minTimeToAlignRobots([-5, 0, 5]), 10\n  assert.strictEqual minTimeToAlignRobots([100, 200, 300, 400]), 400\n  console.log \"All tests passed!\"\n\ntestMinTimeToAlignRobots()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinTimeToAlignRobots = ->\n  assert.strictEqual minTimeToAlignRobots([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTimeToAlignRobots([10, 20, 30, 40]), 40\n  assert.strictEqual minTimeToAlignRobots([0, 0, 0, 0, 0]), 0\n  assert.strictEqual minTimeToAlignRobots([5]), 0\n  assert.strictEqual minTimeToAlignRobots([-5, 0, 5]), 10\n  assert.strictEqual minTimeToAlignRobots([100, 200, 300, 400]), 400\n  console.log \"All tests passed!\"\n\ntestMinTimeToAlignRobots()", "output": "minTimeToAlignRobots"}, "all_code": "# minTimeToAlignRobots calculates the minimum time required for all robots to reach the same position.\n# The optimal position is the median of all positions, which minimizes total travel time.\n# \n# Args:\n# positions (array): Array of integers representing positions of robots.\n#\n# Returns:\n# int: Minimum time required for all robots to align at the same position.\nminTimeToAlignRobots = (positions) ->\n  # Sort the positions array\n  sortedPositions = positions.slice().sort (a, b) -> a - b\n  \n  # Find the median position (middle element for odd length, either middle for even)\n  medianIndex = Math.floor(sortedPositions.length / 2)\n  medianPosition = sortedPositions[medianIndex]\n  \n  # Calculate total time by summing absolute differences from median\n  totalTime = sortedPositions.reduce (sum, pos) ->\n    sum + Math.abs(pos - medianPosition)\n  , 0\n  \n  totalTime\nassert = require 'assert'\n\ntestMinTimeToAlignRobots = ->\n  assert.strictEqual minTimeToAlignRobots([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTimeToAlignRobots([10, 20, 30, 40]), 40\n  assert.strictEqual minTimeToAlignRobots([0, 0, 0, 0, 0]), 0\n  assert.strictEqual minTimeToAlignRobots([5]), 0\n  assert.strictEqual minTimeToAlignRobots([-5, 0, 5]), 10\n  assert.strictEqual minTimeToAlignRobots([100, 200, 300, 400]), 400\n  console.log \"All tests passed!\"\n\ntestMinTimeToAlignRobots()", "exec_outcome": "PASSED"}
{"code": "# minStudentsToMove calculates the minimum number of students to move to get a strictly increasing sequence.\n# It uses the Longest Increasing Subsequence (LIS) approach where the result is `array length - LIS length`.\nminStudentsToMove = (arr) ->\n  return 0 if not arr or arr.length is 0\n  \n  n = arr.length\n  lis = (1 for i in [0...n])\n  \n  for i in [1...n]\n    for j in [0...i]\n      if arr[i] > arr[j]\n        lis[i] = Math.max(lis[i], lis[j] + 1)\n  \n  n - Math.max(lis...)", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [ 1, 2, 3, 4 ]\n  Minimum students to move: 0\n\nTest Case 2:\n  Input: [ 4, 3, 2, 1 ]\n  Minimum students to move: 3\n\nTest Case 3:\n  Input: [ 1, 3, 2, 4 ]\n  Minimum students to move: 1\n\nTest Case 4:\n  Input: [ 1, 2, 3, 2, 4 ]\n  Minimum students to move: 1\n\nTest Case 5:\n  Input: [ 5, 1, 2, 3, 4 ]\n  Minimum students to move: 1\n\nTest Case 6:\n  Input: []\n  Minimum students to move: 0", "task_id": 7602, "assertions": "assert = require 'assert'\n\ntestMinStudentsToMove = ->\n  assert.strictEqual minStudentsToMove([1, 2, 3, 4]), 0\n  assert.strictEqual minStudentsToMove([4, 3, 2, 1]), 3\n  assert.strictEqual minStudentsToMove([1, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([1, 2, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([5, 1, 2, 3, 4]), 1\n  assert.strictEqual minStudentsToMove([]), 0\n  console.log \"All tests passed!\"\n\ntestMinStudentsToMove()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinStudentsToMove = ->\n  assert.strictEqual minStudentsToMove([1, 2, 3, 4]), 0\n  assert.strictEqual minStudentsToMove([4, 3, 2, 1]), 3\n  assert.strictEqual minStudentsToMove([1, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([1, 2, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([5, 1, 2, 3, 4]), 1\n  assert.strictEqual minStudentsToMove([]), 0\n  console.log \"All tests passed!\"\n\ntestMinStudentsToMove()", "output": "minStudentsToMove"}, "all_code": "# minStudentsToMove calculates the minimum number of students to move to get a strictly increasing sequence.\n# It uses the Longest Increasing Subsequence (LIS) approach where the result is `array length - LIS length`.\nminStudentsToMove = (arr) ->\n  return 0 if not arr or arr.length is 0\n  \n  n = arr.length\n  lis = (1 for i in [0...n])\n  \n  for i in [1...n]\n    for j in [0...i]\n      if arr[i] > arr[j]\n        lis[i] = Math.max(lis[i], lis[j] + 1)\n  \n  n - Math.max(lis...)\nassert = require 'assert'\n\ntestMinStudentsToMove = ->\n  assert.strictEqual minStudentsToMove([1, 2, 3, 4]), 0\n  assert.strictEqual minStudentsToMove([4, 3, 2, 1]), 3\n  assert.strictEqual minStudentsToMove([1, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([1, 2, 3, 2, 4]), 1\n  assert.strictEqual minStudentsToMove([5, 1, 2, 3, 4]), 1\n  assert.strictEqual minStudentsToMove([]), 0\n  console.log \"All tests passed!\"\n\ntestMinStudentsToMove()", "exec_outcome": "PASSED"}
{"code": "# maxSquareSubgrid finds the side length of the largest square subgrid containing only '1's in a binary grid.\n# It uses dynamic programming to efficiently compute the solution.\n# Parameters:\n#   n - number of rows in the grid\n#   m - number of columns in the grid\n#   grid - 2D array representing the binary grid ('0's and '1's)\n# Returns:\n#   The side length of the largest square subgrid of '1's\nmaxSquareSubgrid = (n, m, grid) ->\n  # Initialize a 2D dp array with zeros\n  dp = (0 for _ in [0...n] for _ in [0...m])\n  maxSide = 0\n\n  # Iterate through each cell in the grid\n  for i in [0...n]\n    for j in [0...m]\n      if grid[i][j] is '1'\n        if i is 0 or j is 0\n          dp[i][j] = 1\n        else\n          dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        maxSide = Math.max(maxSide, dp[i][j])\n\n  maxSide", "test_cases": "", "test_case_results": "Test Case 1:\nGrid size: 3x3\nGrid:\n1 1 1\n1 1 1\n1 1 1\nLargest square subgrid side length: 3\n----------------------\nTest Case 2:\nGrid size: 5x5\nGrid:\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\n1 0 0 1 0\nLargest square subgrid side length: 2\n----------------------\nTest Case 3:\nGrid size: 2x2\nGrid:\n0 0\n0 0\nLargest square subgrid side length: 0\n----------------------\nTest Case 4:\nGrid size: 4x4\nGrid:\n1 1 0 1\n1 1 0 1\n0 1 1 1\n1 1 1 1\nLargest square subgrid side length: 2\n----------------------", "task_id": 19778, "assertions": "assert = require 'assert'\n\ntestMaxSquareSubgrid = ->\n  # Test Case 1: Full 3x3 grid of 1s\n  grid1 = [\n    ['1', '1', '1']\n    ['1', '1', '1']\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(3, 3, grid1), 3\n\n  # Test Case 2: 5x5 grid with largest square of size 2\n  grid2 = [\n    ['1', '0', '1', '0', '0']\n    ['1', '0', '1', '1', '1']\n    ['1', '1', '1', '1', '1']\n    ['1', '0', '0', '1', '0']\n    ['1', '0', '0', '1', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(5, 5, grid2), 2\n\n  # Test Case 3: Full 2x2 grid of 0s\n  grid3 = [\n    ['0', '0']\n    ['0', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(2, 2, grid3), 0\n\n  # Test Case 4: 4x4 grid with largest square of size 2\n  grid4 = [\n    ['1', '1', '0', '1']\n    ['1', '1', '0', '1']\n    ['0', '1', '1', '1']\n    ['1', '1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(4, 4, grid4), 2\n\n  console.log \"All tests passed!\"\n\ntestMaxSquareSubgrid()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxSquareSubgrid = ->\n  # Test Case 1: Full 3x3 grid of 1s\n  grid1 = [\n    ['1', '1', '1']\n    ['1', '1', '1']\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(3, 3, grid1), 3\n\n  # Test Case 2: 5x5 grid with largest square of size 2\n  grid2 = [\n    ['1', '0', '1', '0', '0']\n    ['1', '0', '1', '1', '1']\n    ['1', '1', '1', '1', '1']\n    ['1', '0', '0', '1', '0']\n    ['1', '0', '0', '1', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(5, 5, grid2), 2\n\n  # Test Case 3: Full 2x2 grid of 0s\n  grid3 = [\n    ['0', '0']\n    ['0', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(2, 2, grid3), 0\n\n  # Test Case 4: 4x4 grid with largest square of size 2\n  grid4 = [\n    ['1', '1', '0', '1']\n    ['1', '1', '0', '1']\n    ['0', '1', '1', '1']\n    ['1', '1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(4, 4, grid4), 2\n\n  console.log \"All tests passed!\"\n\ntestMaxSquareSubgrid()", "output": "maxSquareSubgrid"}, "all_code": "# maxSquareSubgrid finds the side length of the largest square subgrid containing only '1's in a binary grid.\n# It uses dynamic programming to efficiently compute the solution.\n# Parameters:\n#   n - number of rows in the grid\n#   m - number of columns in the grid\n#   grid - 2D array representing the binary grid ('0's and '1's)\n# Returns:\n#   The side length of the largest square subgrid of '1's\nmaxSquareSubgrid = (n, m, grid) ->\n  # Initialize a 2D dp array with zeros\n  dp = (0 for _ in [0...n] for _ in [0...m])\n  maxSide = 0\n\n  # Iterate through each cell in the grid\n  for i in [0...n]\n    for j in [0...m]\n      if grid[i][j] is '1'\n        if i is 0 or j is 0\n          dp[i][j] = 1\n        else\n          dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        maxSide = Math.max(maxSide, dp[i][j])\n\n  maxSide\nassert = require 'assert'\n\ntestMaxSquareSubgrid = ->\n  # Test Case 1: Full 3x3 grid of 1s\n  grid1 = [\n    ['1', '1', '1']\n    ['1', '1', '1']\n    ['1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(3, 3, grid1), 3\n\n  # Test Case 2: 5x5 grid with largest square of size 2\n  grid2 = [\n    ['1', '0', '1', '0', '0']\n    ['1', '0', '1', '1', '1']\n    ['1', '1', '1', '1', '1']\n    ['1', '0', '0', '1', '0']\n    ['1', '0', '0', '1', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(5, 5, grid2), 2\n\n  # Test Case 3: Full 2x2 grid of 0s\n  grid3 = [\n    ['0', '0']\n    ['0', '0']\n  ]\n  assert.strictEqual maxSquareSubgrid(2, 2, grid3), 0\n\n  # Test Case 4: 4x4 grid with largest square of size 2\n  grid4 = [\n    ['1', '1', '0', '1']\n    ['1', '1', '0', '1']\n    ['0', '1', '1', '1']\n    ['1', '1', '1', '1']\n  ]\n  assert.strictEqual maxSquareSubgrid(4, 4, grid4), 2\n\n  console.log \"All tests passed!\"\n\ntestMaxSquareSubgrid()", "exec_outcome": "PASSED"}
{"code": "# validateAnagram determines if string t is an anagram of string s.\n# An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n# \n# @param {string} s - The first input string.\n# @param {string} t - The second input string.\n# @return {boolean} True if t is an anagram of s, otherwise False.\nvalidateAnagram = (s, t) ->\n  return false if s.length isnt t.length\n\n  # Create frequency counters for each string\n  countS = {}\n  countT = {}\n\n  # Populate the frequency counters\n  for char in s\n    countS[char] ?= 0\n    countS[char]++\n\n  for char in t\n    countT[char] ?= 0\n    countT[char]++\n\n  # Compare the frequency counters\n  for key, value of countS\n    return false if countT[key] isnt value\n\n  true", "test_cases": "", "test_case_results": "Input: { s: 'anagram', t: 'nagaram' }\nIs Anagram: true\n\nInput: { s: 'rat', t: 'car' }\nIs Anagram: false\n\nInput: { s: 'listen', t: 'silent' }\nIs Anagram: true\n\nInput: { s: 'hello', t: 'world' }\nIs Anagram: false\n\nInput: { s: 'a', t: 'a' }\nIs Anagram: true\n\nInput: { s: 'abc', t: 'abcd' }\nIs Anagram: false", "task_id": 13298, "assertions": "assert = require 'assert'\n\ntestValidateAnagram = ->\n  assert.strictEqual validateAnagram(\"anagram\", \"nagaram\"), true\n  assert.strictEqual validateAnagram(\"rat\", \"car\"), false\n  assert.strictEqual validateAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual validateAnagram(\"hello\", \"world\"), false\n  assert.strictEqual validateAnagram(\"a\", \"a\"), true\n  assert.strictEqual validateAnagram(\"abc\", \"abcd\"), false\n\ntestValidateAnagram()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestValidateAnagram = ->\n  assert.strictEqual validateAnagram(\"anagram\", \"nagaram\"), true\n  assert.strictEqual validateAnagram(\"rat\", \"car\"), false\n  assert.strictEqual validateAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual validateAnagram(\"hello\", \"world\"), false\n  assert.strictEqual validateAnagram(\"a\", \"a\"), true\n  assert.strictEqual validateAnagram(\"abc\", \"abcd\"), false\n\ntestValidateAnagram()", "output": "validateAnagram"}, "all_code": "# validateAnagram determines if string t is an anagram of string s.\n# An anagram is a word or phrase formed by rearranging the letters of a different word or phrase.\n# \n# @param {string} s - The first input string.\n# @param {string} t - The second input string.\n# @return {boolean} True if t is an anagram of s, otherwise False.\nvalidateAnagram = (s, t) ->\n  return false if s.length isnt t.length\n\n  # Create frequency counters for each string\n  countS = {}\n  countT = {}\n\n  # Populate the frequency counters\n  for char in s\n    countS[char] ?= 0\n    countS[char]++\n\n  for char in t\n    countT[char] ?= 0\n    countT[char]++\n\n  # Compare the frequency counters\n  for key, value of countS\n    return false if countT[key] isnt value\n\n  true\nassert = require 'assert'\n\ntestValidateAnagram = ->\n  assert.strictEqual validateAnagram(\"anagram\", \"nagaram\"), true\n  assert.strictEqual validateAnagram(\"rat\", \"car\"), false\n  assert.strictEqual validateAnagram(\"listen\", \"silent\"), true\n  assert.strictEqual validateAnagram(\"hello\", \"world\"), false\n  assert.strictEqual validateAnagram(\"a\", \"a\"), true\n  assert.strictEqual validateAnagram(\"abc\", \"abcd\"), false\n\ntestValidateAnagram()", "exec_outcome": "PASSED"}
{"code": "class LibrarySystem\n  constructor: ->\n    @availableBooks = []  # Stack for available books (LIFO)\n    @borrowQueue = []     # Queue for borrow requests (FIFO)\n\n  # Registers a new book by adding it to the available books stack\n  registerBook: (bookId) ->\n    @availableBooks.push(bookId)\n\n  # Borrows the most recently registered book (top of stack)\n  # Throws an error if no books are available\n  borrowBook: ->\n    if @availableBooks.length is 0\n      throw new Error(\"No books available for borrowing\")\n    @availableBooks.pop()\n\n  # Returns a book to the system\n  # If there's a matching queued request, fulfills it immediately\n  # Otherwise adds the book back to available books\n  returnBook: (bookId) ->\n    if @borrowQueue.length > 0 and @borrowQueue[0] is bookId\n      @borrowQueue.shift()\n    else\n      @availableBooks.push(bookId)\n\n  # Adds a borrow request to the queue for a specific book\n  queuedBorrowRequest: (bookId) ->\n    @borrowQueue.push(bookId)", "test_cases": "", "test_case_results": "=== Library System Tests ===\n\nTest 1: Basic operations\nRegistered books 101 and 102\nBorrowed book: 102\nBorrowed book: 101\nError: No books available for borrowing\n\nTest 2: Queue operations\nQueued requests for 201 and 202\nRegistered book 201 - should fulfill first request\nRemaining queue: [ 202 ]\n\nTest 3: Return with no queue\nReturned book 301 with no queue - available books: [ 301 ]\n\nTest 4: Complex scenario\nInitial state - available: [ 401, 402 ] queue: [ 403 ]\nBorrowed: 402\nReturned 402 - available: [ 401, 402 ] queue: [ 403 ]\nFinal state - available: [ 401, 402, 403 ] queue: []", "task_id": 19535, "assertions": "assert = require 'assert'\n\ntestLibrarySystem = ->\n  # Test 1: Basic registration and borrowing\n  library = new LibrarySystem()\n  library.registerBook(101)\n  library.registerBook(102)\n  assert.strictEqual library.borrowBook(), 102\n  assert.strictEqual library.borrowBook(), 101\n  assert.throws (-> library.borrowBook()), Error, \"No books available for borrowing\"\n\n  # Test 2: Queue functionality\n  library2 = new LibrarySystem()\n  library2.queuedBorrowRequest(201)\n  library2.queuedBorrowRequest(202)\n  library2.registerBook(201)\n  library2.returnBook(201)\n  assert.deepStrictEqual library2.borrowQueue, [202]\n\n  # Test 3: Return with no queue\n  library3 = new LibrarySystem()\n  library3.returnBook(301)\n  assert.deepStrictEqual library3.availableBooks, [301]\n\n  # Test 4: Complex scenario\n  library4 = new LibrarySystem()\n  library4.registerBook(401)\n  library4.registerBook(402)\n  library4.queuedBorrowRequest(403)\n  assert.strictEqual library4.borrowBook(), 402\n  library4.returnBook(402)\n  assert.deepStrictEqual library4.availableBooks, [401, 402]\n  assert.deepStrictEqual library4.borrowQueue, [403]\n  library4.registerBook(403)\n  library4.returnBook(403)\n  assert.deepStrictEqual library4.availableBooks, [401, 402, 403]\n  assert.deepStrictEqual library4.borrowQueue, []\n\ntestLibrarySystem()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestLibrarySystem = ->\n  # Test 1: Basic registration and borrowing\n  library = new LibrarySystem()\n  library.registerBook(101)\n  library.registerBook(102)\n  assert.strictEqual library.borrowBook(), 102\n  assert.strictEqual library.borrowBook(), 101\n  assert.throws (-> library.borrowBook()), Error, \"No books available for borrowing\"\n\n  # Test 2: Queue functionality\n  library2 = new LibrarySystem()\n  library2.queuedBorrowRequest(201)\n  library2.queuedBorrowRequest(202)\n  library2.registerBook(201)\n  library2.returnBook(201)\n  assert.deepStrictEqual library2.borrowQueue, [202]\n\n  # Test 3: Return with no queue\n  library3 = new LibrarySystem()\n  library3.returnBook(301)\n  assert.deepStrictEqual library3.availableBooks, [301]\n\n  # Test 4: Complex scenario\n  library4 = new LibrarySystem()\n  library4.registerBook(401)\n  library4.registerBook(402)\n  library4.queuedBorrowRequest(403)\n  assert.strictEqual library4.borrowBook(), 402\n  library4.returnBook(402)\n  assert.deepStrictEqual library4.availableBooks, [401, 402]\n  assert.deepStrictEqual library4.borrowQueue, [403]\n  library4.registerBook(403)\n  library4.returnBook(403)\n  assert.deepStrictEqual library4.availableBooks, [401, 402, 403]\n  assert.deepStrictEqual library4.borrowQueue, []\n\ntestLibrarySystem()", "output": "LibrarySystem"}, "all_code": "class LibrarySystem\n  constructor: ->\n    @availableBooks = []  # Stack for available books (LIFO)\n    @borrowQueue = []     # Queue for borrow requests (FIFO)\n\n  # Registers a new book by adding it to the available books stack\n  registerBook: (bookId) ->\n    @availableBooks.push(bookId)\n\n  # Borrows the most recently registered book (top of stack)\n  # Throws an error if no books are available\n  borrowBook: ->\n    if @availableBooks.length is 0\n      throw new Error(\"No books available for borrowing\")\n    @availableBooks.pop()\n\n  # Returns a book to the system\n  # If there's a matching queued request, fulfills it immediately\n  # Otherwise adds the book back to available books\n  returnBook: (bookId) ->\n    if @borrowQueue.length > 0 and @borrowQueue[0] is bookId\n      @borrowQueue.shift()\n    else\n      @availableBooks.push(bookId)\n\n  # Adds a borrow request to the queue for a specific book\n  queuedBorrowRequest: (bookId) ->\n    @borrowQueue.push(bookId)\nassert = require 'assert'\n\ntestLibrarySystem = ->\n  # Test 1: Basic registration and borrowing\n  library = new LibrarySystem()\n  library.registerBook(101)\n  library.registerBook(102)\n  assert.strictEqual library.borrowBook(), 102\n  assert.strictEqual library.borrowBook(), 101\n  assert.throws (-> library.borrowBook()), Error, \"No books available for borrowing\"\n\n  # Test 2: Queue functionality\n  library2 = new LibrarySystem()\n  library2.queuedBorrowRequest(201)\n  library2.queuedBorrowRequest(202)\n  library2.registerBook(201)\n  library2.returnBook(201)\n  assert.deepStrictEqual library2.borrowQueue, [202]\n\n  # Test 3: Return with no queue\n  library3 = new LibrarySystem()\n  library3.returnBook(301)\n  assert.deepStrictEqual library3.availableBooks, [301]\n\n  # Test 4: Complex scenario\n  library4 = new LibrarySystem()\n  library4.registerBook(401)\n  library4.registerBook(402)\n  library4.queuedBorrowRequest(403)\n  assert.strictEqual library4.borrowBook(), 402\n  library4.returnBook(402)\n  assert.deepStrictEqual library4.availableBooks, [401, 402]\n  assert.deepStrictEqual library4.borrowQueue, [403]\n  library4.registerBook(403)\n  library4.returnBook(403)\n  assert.deepStrictEqual library4.availableBooks, [401, 402, 403]\n  assert.deepStrictEqual library4.borrowQueue, []\n\ntestLibrarySystem()", "exec_outcome": "PASSED"}
{"code": "# maxJumps calculates the maximum number of jumps that can be made between hills,\n# where each jump must be from a lower hill to a higher one.\n# The function uses dynamic programming to solve the problem.\nmaxJumps = (hills) ->\n  return 0 if not hills or hills.length is 0\n\n  # Initialize dp array where dp[i] stores the maximum jumps starting from hill i\n  dp = (1 for _ in [0...hills.length])\n\n  for i in [0...hills.length]\n    for j in [0...i]\n      if hills[j] < hills[i]\n        dp[i] = Math.max(dp[i], dp[j] + 1)\n\n  # Subtract 1 because we count jumps, not hills\n  Math.max(dp...) - 1", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: []\n  Max Jumps: 0\n\nTest Case 2:\n  Input: [ 5 ]\n  Max Jumps: 0\n\nTest Case 3:\n  Input: [ 1, 2, 3, 4, 5 ]\n  Max Jumps: 4\n\nTest Case 4:\n  Input: [ 5, 4, 3, 2, 1 ]\n  Max Jumps: 0\n\nTest Case 5:\n  Input: [\n  1, 3, 2, 4,\n  6, 5, 7\n]\n  Max Jumps: 4\n\nTest Case 6:\n  Input: [\n  10, 9,   2,  5,\n   3, 7, 101, 18\n]\n  Max Jumps: 3", "task_id": 15523, "assertions": "assert = require 'assert'\n\ntestMaxJumps = ->\n  assert.strictEqual maxJumps([]), 0\n  assert.strictEqual maxJumps([5]), 0\n  assert.strictEqual maxJumps([1, 2, 3, 4, 5]), 4\n  assert.strictEqual maxJumps([5, 4, 3, 2, 1]), 0\n  assert.strictEqual maxJumps([1, 3, 2, 4, 6, 5, 7]), 4\n  assert.strictEqual maxJumps([10, 9, 2, 5, 3, 7, 101, 18]), 3\n  console.log \"All tests passed!\"\n\ntestMaxJumps()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMaxJumps = ->\n  assert.strictEqual maxJumps([]), 0\n  assert.strictEqual maxJumps([5]), 0\n  assert.strictEqual maxJumps([1, 2, 3, 4, 5]), 4\n  assert.strictEqual maxJumps([5, 4, 3, 2, 1]), 0\n  assert.strictEqual maxJumps([1, 3, 2, 4, 6, 5, 7]), 4\n  assert.strictEqual maxJumps([10, 9, 2, 5, 3, 7, 101, 18]), 3\n  console.log \"All tests passed!\"\n\ntestMaxJumps()", "output": "maxJumps"}, "all_code": "# maxJumps calculates the maximum number of jumps that can be made between hills,\n# where each jump must be from a lower hill to a higher one.\n# The function uses dynamic programming to solve the problem.\nmaxJumps = (hills) ->\n  return 0 if not hills or hills.length is 0\n\n  # Initialize dp array where dp[i] stores the maximum jumps starting from hill i\n  dp = (1 for _ in [0...hills.length])\n\n  for i in [0...hills.length]\n    for j in [0...i]\n      if hills[j] < hills[i]\n        dp[i] = Math.max(dp[i], dp[j] + 1)\n\n  # Subtract 1 because we count jumps, not hills\n  Math.max(dp...) - 1\nassert = require 'assert'\n\ntestMaxJumps = ->\n  assert.strictEqual maxJumps([]), 0\n  assert.strictEqual maxJumps([5]), 0\n  assert.strictEqual maxJumps([1, 2, 3, 4, 5]), 4\n  assert.strictEqual maxJumps([5, 4, 3, 2, 1]), 0\n  assert.strictEqual maxJumps([1, 3, 2, 4, 6, 5, 7]), 4\n  assert.strictEqual maxJumps([10, 9, 2, 5, 3, 7, 101, 18]), 3\n  console.log \"All tests passed!\"\n\ntestMaxJumps()", "exec_outcome": "PASSED"}
{"code": "# cardGame simulates a card game between two players for a specified number of rounds.\n# Players draw random cards from a standard deck, and the player with the higher card wins the round.\n# Ties are possible but don't count as wins for either player.\n#\n# Parameters:\n#   rounds - number of rounds to simulate (integer)\n#   seed - optional random seed for reproducibility (integer)\n#\n# Returns:\n#   Object with 'Player 1 Wins' and 'Player 2 Wins' properties representing each player's total wins\ncardGame = (rounds, seed = null) ->\n  # Set random seed if provided\n  Math.seedrandom(seed) if seed?\n  \n  # Define card rankings\n  cardRanks = \n    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,\n    'J': 11, 'Q': 12, 'K': 13, 'A': 14\n  \n  # Create a standard deck (4 of each card)\n  deck = []\n  for card of cardRanks\n    deck.push(card) for [1..4]\n  \n  results = \n    'Player 1 Wins': 0\n    'Player 2 Wins': 0\n  \n  # Play specified number of rounds\n  for [1..rounds]\n    # Get random cards for each player\n    card1 = deck[Math.floor(Math.random() * deck.length)]\n    card2 = deck[Math.floor(Math.random() * deck.length)]\n    \n    # Compare card values and update results\n    if cardRanks[card1] > cardRanks[card2]\n      results['Player 1 Wins']++\n    else if cardRanks[card1] < cardRanks[card2]\n      results['Player 2 Wins']++\n  \n  results\n\n# Load seedrandom.js for seed functionality (native JavaScript implementation)\nMath.seedrandom = (seed) ->\n  # Simple seedable random number generator implementation\n  # This is a basic implementation for demonstration purposes\n  # In production, you might want to use a more robust solution\n  Math.random = ->\n    x = Math.sin(seed++) * 10000\n    x - Math.floor(x)", "test_cases": "", "test_case_results": "Test Case 1:\n  Input - Rounds: 10, Seed: 42\n  Results:\n    Player 1 Wins: 4\n    Player 2 Wins: 3\n\nTest Case 2:\n  Input - Rounds: 5, Seed: 123\n  Results:\n    Player 1 Wins: 2\n    Player 2 Wins: 3\n\nTest Case 3:\n  Input - Rounds: 20, Seed: none\n  Results:\n    Player 1 Wins: 13\n    Player 2 Wins: 6\n\nTest Case 4:\n  Input - Rounds: 0, Seed: 42\n  Results:\n    Player 1 Wins: 1\n    Player 2 Wins: 0", "task_id": 28878, "assertions": "assert = require 'assert'\n\ntestCardGame = ->\n  # Test with seed 42 (10 rounds)\n  results1 = cardGame(10, 42)\n  assert.strictEqual results1['Player 1 Wins'], 4\n  assert.strictEqual results1['Player 2 Wins'], 3\n\n  # Test with seed 123 (5 rounds)\n  results2 = cardGame(5, 123)\n  assert.strictEqual results2['Player 1 Wins'], 2\n  assert.strictEqual results2['Player 2 Wins'], 3\n\n  # Test without seed (20 rounds) - can't assert exact values due to randomness\n  results3 = cardGame(20)\n  assert.ok results3['Player 1 Wins'] >= 0\n  assert.ok results3['Player 2 Wins'] >= 0\n  assert.strictEqual results3['Player 1 Wins'] + results3['Player 2 Wins'] <= 20, true\n\n  # Edge case: 0 rounds with seed\n  results4 = cardGame(0, 42)\n  assert.strictEqual results4['Player 1 Wins'], 0\n  assert.strictEqual results4['Player 2 Wins'], 0\n\ntestCardGame()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCardGame = ->\n  # Test with seed 42 (10 rounds)\n  results1 = cardGame(10, 42)\n  assert.strictEqual results1['Player 1 Wins'], 4\n  assert.strictEqual results1['Player 2 Wins'], 3\n\n  # Test with seed 123 (5 rounds)\n  results2 = cardGame(5, 123)\n  assert.strictEqual results2['Player 1 Wins'], 2\n  assert.strictEqual results2['Player 2 Wins'], 3\n\n  # Test without seed (20 rounds) - can't assert exact values due to randomness\n  results3 = cardGame(20)\n  assert.ok results3['Player 1 Wins'] >= 0\n  assert.ok results3['Player 2 Wins'] >= 0\n  assert.strictEqual results3['Player 1 Wins'] + results3['Player 2 Wins'] <= 20, true\n\n  # Edge case: 0 rounds with seed\n  results4 = cardGame(0, 42)\n  assert.strictEqual results4['Player 1 Wins'], 0\n  assert.strictEqual results4['Player 2 Wins'], 0\n\ntestCardGame()", "output": "cardGame"}, "all_code": "# cardGame simulates a card game between two players for a specified number of rounds.\n# Players draw random cards from a standard deck, and the player with the higher card wins the round.\n# Ties are possible but don't count as wins for either player.\n#\n# Parameters:\n#   rounds - number of rounds to simulate (integer)\n#   seed - optional random seed for reproducibility (integer)\n#\n# Returns:\n#   Object with 'Player 1 Wins' and 'Player 2 Wins' properties representing each player's total wins\ncardGame = (rounds, seed = null) ->\n  # Set random seed if provided\n  Math.seedrandom(seed) if seed?\n  \n  # Define card rankings\n  cardRanks = \n    '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10,\n    'J': 11, 'Q': 12, 'K': 13, 'A': 14\n  \n  # Create a standard deck (4 of each card)\n  deck = []\n  for card of cardRanks\n    deck.push(card) for [1..4]\n  \n  results = \n    'Player 1 Wins': 0\n    'Player 2 Wins': 0\n  \n  # Play specified number of rounds\n  for [1..rounds]\n    # Get random cards for each player\n    card1 = deck[Math.floor(Math.random() * deck.length)]\n    card2 = deck[Math.floor(Math.random() * deck.length)]\n    \n    # Compare card values and update results\n    if cardRanks[card1] > cardRanks[card2]\n      results['Player 1 Wins']++\n    else if cardRanks[card1] < cardRanks[card2]\n      results['Player 2 Wins']++\n  \n  results\n\n# Load seedrandom.js for seed functionality (native JavaScript implementation)\nMath.seedrandom = (seed) ->\n  # Simple seedable random number generator implementation\n  # This is a basic implementation for demonstration purposes\n  # In production, you might want to use a more robust solution\n  Math.random = ->\n    x = Math.sin(seed++) * 10000\n    x - Math.floor(x)\nassert = require 'assert'\n\ntestCardGame = ->\n  # Test with seed 42 (10 rounds)\n  results1 = cardGame(10, 42)\n  assert.strictEqual results1['Player 1 Wins'], 4\n  assert.strictEqual results1['Player 2 Wins'], 3\n\n  # Test with seed 123 (5 rounds)\n  results2 = cardGame(5, 123)\n  assert.strictEqual results2['Player 1 Wins'], 2\n  assert.strictEqual results2['Player 2 Wins'], 3\n\n  # Test without seed (20 rounds) - can't assert exact values due to randomness\n  results3 = cardGame(20)\n  assert.ok results3['Player 1 Wins'] >= 0\n  assert.ok results3['Player 2 Wins'] >= 0\n  assert.strictEqual results3['Player 1 Wins'] + results3['Player 2 Wins'] <= 20, true\n\n  # Edge case: 0 rounds with seed\n  results4 = cardGame(0, 42)\n  assert.strictEqual results4['Player 1 Wins'], 0\n  assert.strictEqual results4['Player 2 Wins'], 0\n\ntestCardGame()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# Checks if there exists a contiguous subarray whose sum equals exactly x\n# Uses a prefix sum approach with a hash set for O(n) time complexity\nsubarraySumToX = (arr, x) ->\n  currentSum = 0\n  prefixSums = new Set()\n  prefixSums.add(0)  # Base case: sum of 0 can be achieved with empty subarray\n  \n  for num in arr\n    currentSum += num\n    if prefixSums.has(currentSum - x)\n      return true\n    prefixSums.add(currentSum)\n  \n  false", "test_cases": "", "test_case_results": "Test Case 1:\n  Array: [ 1, 4, 20, 3, 10, 5 ]\n  Target Sum: 33\n  Result: true\n\nTest Case 2:\n  Array: [\n  1,  4, 0, 0,\n  3, 10, 5\n]\n  Target Sum: 7\n  Result: true\n\nTest Case 3:\n  Array: [ 1, 4, 20, 3, 10, 5 ]\n  Target Sum: 50\n  Result: false\n\nTest Case 4:\n  Array: []\n  Target Sum: 0\n  Result: false\n\nTest Case 5:\n  Array: [ 5, -2, 3, 1, 2 ]\n  Target Sum: 4\n  Result: true\n\nTest Case 6:\n  Array: [ 1, 2, 3 ]\n  Target Sum: 6\n  Result: true", "task_id": 13738, "assertions": "assert = require 'assert'\n\ntestSubarraySumToX = ->\n  # Test case 1: Should find 20 + 3 + 10\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 33), true\n  \n  # Test case 2: Should find 4 + 0 + 0 + 3\n  assert.strictEqual subarraySumToX([1, 4, 0, 0, 3, 10, 5], 7), true\n  \n  # Test case 3: No such subarray\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 50), false\n  \n  # Test case 4: Edge case - empty array\n  assert.strictEqual subarraySumToX([], 0), false\n  \n  # Test case 5: Should find 3 + 1\n  assert.strictEqual subarraySumToX([5, -2, 3, 1, 2], 4), true\n  \n  # Test case 6: Entire array sums to target\n  assert.strictEqual subarraySumToX([1, 2, 3], 6), true\n\n  console.log \"All tests passed!\"\n\ntestSubarraySumToX()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSubarraySumToX = ->\n  # Test case 1: Should find 20 + 3 + 10\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 33), true\n  \n  # Test case 2: Should find 4 + 0 + 0 + 3\n  assert.strictEqual subarraySumToX([1, 4, 0, 0, 3, 10, 5], 7), true\n  \n  # Test case 3: No such subarray\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 50), false\n  \n  # Test case 4: Edge case - empty array\n  assert.strictEqual subarraySumToX([], 0), false\n  \n  # Test case 5: Should find 3 + 1\n  assert.strictEqual subarraySumToX([5, -2, 3, 1, 2], 4), true\n  \n  # Test case 6: Entire array sums to target\n  assert.strictEqual subarraySumToX([1, 2, 3], 6), true\n\n  console.log \"All tests passed!\"\n\ntestSubarraySumToX()", "output": "subarraySumToX"}, "all_code": "# Checks if there exists a contiguous subarray whose sum equals exactly x\n# Uses a prefix sum approach with a hash set for O(n) time complexity\nsubarraySumToX = (arr, x) ->\n  currentSum = 0\n  prefixSums = new Set()\n  prefixSums.add(0)  # Base case: sum of 0 can be achieved with empty subarray\n  \n  for num in arr\n    currentSum += num\n    if prefixSums.has(currentSum - x)\n      return true\n    prefixSums.add(currentSum)\n  \n  false\nassert = require 'assert'\n\ntestSubarraySumToX = ->\n  # Test case 1: Should find 20 + 3 + 10\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 33), true\n  \n  # Test case 2: Should find 4 + 0 + 0 + 3\n  assert.strictEqual subarraySumToX([1, 4, 0, 0, 3, 10, 5], 7), true\n  \n  # Test case 3: No such subarray\n  assert.strictEqual subarraySumToX([1, 4, 20, 3, 10, 5], 50), false\n  \n  # Test case 4: Edge case - empty array\n  assert.strictEqual subarraySumToX([], 0), false\n  \n  # Test case 5: Should find 3 + 1\n  assert.strictEqual subarraySumToX([5, -2, 3, 1, 2], 4), true\n  \n  # Test case 6: Entire array sums to target\n  assert.strictEqual subarraySumToX([1, 2, 3], 6), true\n\n  console.log \"All tests passed!\"\n\ntestSubarraySumToX()", "exec_outcome": "PASSED"}
{"code": "# Finds the element that minimizes the total modification cost to equalize array elements,\n# and returns the minimum total modification cost.\n# The optimal element to minimize the absolute difference is the median of the sorted array.\nminTotalModificationCost = (arr) ->\n  return 0 if not arr or arr.length is 0\n  \n  # Create a copy of the array to avoid modifying the original\n  sortedArr = arr.slice().sort (a, b) -> a - b\n  medianIndex = Math.floor(sortedArr.length / 2)\n  median = sortedArr[medianIndex]\n  \n  # Calculate total cost by summing absolute differences from median\n  totalCost = sortedArr.reduce ((sum, num) -> sum + Math.abs(num - median)), 0\n  totalCost", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Array: [ 1, 2, 3, 4, 5 ]\n  Minimum Total Modification Cost: 6\n\nTest Case 2:\n  Input Array: [ 1, 2, 3, 4 ]\n  Minimum Total Modification Cost: 4\n\nTest Case 3:\n  Input Array: [ 10 ]\n  Minimum Total Modification Cost: 0\n\nTest Case 4:\n  Input Array: [ 5, 5, 5, 5 ]\n  Minimum Total Modification Cost: 0\n\nTest Case 5:\n  Input Array: [ 1, 3, 5, 7, 9, 11 ]\n  Minimum Total Modification Cost: 18\n\nTest Case 6:\n  Input Array: []\n  Minimum Total Modification Cost: 0", "task_id": 27510, "assertions": "assert = require 'assert'\n\ntestMinTotalModificationCost = ->\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4]), 4\n  assert.strictEqual minTotalModificationCost([10]), 0\n  assert.strictEqual minTotalModificationCost([5, 5, 5, 5]), 0\n  assert.strictEqual minTotalModificationCost([1, 3, 5, 7, 9, 11]), 18\n  assert.strictEqual minTotalModificationCost([]), 0\n  console.log \"All tests passed!\"\n\ntestMinTotalModificationCost()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinTotalModificationCost = ->\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4]), 4\n  assert.strictEqual minTotalModificationCost([10]), 0\n  assert.strictEqual minTotalModificationCost([5, 5, 5, 5]), 0\n  assert.strictEqual minTotalModificationCost([1, 3, 5, 7, 9, 11]), 18\n  assert.strictEqual minTotalModificationCost([]), 0\n  console.log \"All tests passed!\"\n\ntestMinTotalModificationCost()", "output": "minTotalModificationCost"}, "all_code": "# Finds the element that minimizes the total modification cost to equalize array elements,\n# and returns the minimum total modification cost.\n# The optimal element to minimize the absolute difference is the median of the sorted array.\nminTotalModificationCost = (arr) ->\n  return 0 if not arr or arr.length is 0\n  \n  # Create a copy of the array to avoid modifying the original\n  sortedArr = arr.slice().sort (a, b) -> a - b\n  medianIndex = Math.floor(sortedArr.length / 2)\n  median = sortedArr[medianIndex]\n  \n  # Calculate total cost by summing absolute differences from median\n  totalCost = sortedArr.reduce ((sum, num) -> sum + Math.abs(num - median)), 0\n  totalCost\nassert = require 'assert'\n\ntestMinTotalModificationCost = ->\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4, 5]), 6\n  assert.strictEqual minTotalModificationCost([1, 2, 3, 4]), 4\n  assert.strictEqual minTotalModificationCost([10]), 0\n  assert.strictEqual minTotalModificationCost([5, 5, 5, 5]), 0\n  assert.strictEqual minTotalModificationCost([1, 3, 5, 7, 9, 11]), 18\n  assert.strictEqual minTotalModificationCost([]), 0\n  console.log \"All tests passed!\"\n\ntestMinTotalModificationCost()", "exec_outcome": "PASSED"}
{"code": "# generateIntervals produces all possible musical intervals between two notes in half steps (semitones)\n# Each interval is represented as an array containing the note name and its half step distance from the starting note\n# Notes follow the standard chromatic scale from C to B with sharps\ngenerateIntervals = (minNote, maxNote) ->\n  notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n  intervals = []\n  \n  # Find indices of the input notes in the chromatic scale\n  minIndex = notes.indexOf(minNote)\n  maxIndex = notes.indexOf(maxNote)\n  \n  # Handle invalid note inputs by returning empty array\n  return [] if minIndex is -1 or maxIndex is -1\n  \n  # Generate all intervals between min and max notes (inclusive)\n  for i in [minIndex..maxIndex]\n    intervalName = notes[i %% 12]  # Modulo 12 to wrap around the chromatic scale\n    intervalSteps = i - minIndex\n    intervals.push([intervalName, intervalSteps])\n  \n  intervals", "test_cases": "", "test_case_results": "Input: { min: 'C', max: 'G' }\nGenerated intervals: [\n  [ 'C', 0 ],\n  [ 'C#', 1 ],\n  [ 'D', 2 ],\n  [ 'D#', 3 ],\n  [ 'E', 4 ],\n  [ 'F', 5 ],\n  [ 'F#', 6 ],\n  [ 'G', 7 ]\n]\n---\nInput: { min: 'D', max: 'A' }\nGenerated intervals: [\n  [ 'D', 0 ],\n  [ 'D#', 1 ],\n  [ 'E', 2 ],\n  [ 'F', 3 ],\n  [ 'F#', 4 ],\n  [ 'G', 5 ],\n  [ 'G#', 6 ],\n  [ 'A', 7 ]\n]\n---\nInput: { min: 'C', max: 'C' }\nGenerated intervals: [ [ 'C', 0 ] ]\n---\nInput: { min: 'A', max: 'C' }\nGenerated intervals: [\n  [ 'A', 0 ],   [ 'G#', -1 ],\n  [ 'G', -2 ],  [ 'F#', -3 ],\n  [ 'F', -4 ],  [ 'E', -5 ],\n  [ 'D#', -6 ], [ 'D', -7 ],\n  [ 'C#', -8 ], [ 'C', -9 ]\n]\n---\nInput: { min: 'F#', max: 'B' }\nGenerated intervals: [\n  [ 'F#', 0 ],\n  [ 'G', 1 ],\n  [ 'G#', 2 ],\n  [ 'A', 3 ],\n  [ 'A#', 4 ],\n  [ 'B', 5 ]\n]\n---\nInput: { min: 'X', max: 'Y' }\nGenerated intervals: []\n---", "task_id": 4324, "assertions": "assert = require 'assert'\n\ntestGenerateIntervals = ->\n  # Test perfect fifth (C to G)\n  assert.deepStrictEqual generateIntervals('C', 'G'), [\n    ['C', 0], ['C#', 1], ['D', 2], ['D#', 3],\n    ['E', 4], ['F', 5], ['F#', 6], ['G', 7]\n  ]\n  \n  # Test another perfect fifth (D to A)\n  assert.deepStrictEqual generateIntervals('D', 'A'), [\n    ['D', 0], ['D#', 1], ['E', 2], ['F', 3],\n    ['F#', 4], ['G', 5], ['G#', 6], ['A', 7]\n  ]\n  \n  # Test unison (C to C)\n  assert.deepStrictEqual generateIntervals('C', 'C'), [['C', 0]]\n  \n  # Test descending intervals (A to C)\n  assert.deepStrictEqual generateIntervals('A', 'C'), [\n    ['A', 0], ['A#', 1], ['B', 2], ['C', 3]\n  ]\n  \n  # Test augmented fourth (F# to B)\n  assert.deepStrictEqual generateIntervals('F#', 'B'), [\n    ['F#', 0], ['G', 1], ['G#', 2], ['A', 3], ['A#', 4], ['B', 5]\n  ]\n  \n  # Test invalid notes\n  assert.deepStrictEqual generateIntervals('X', 'Y'), []\n  \n  console.log \"All tests passed!\"\n\ntestGenerateIntervals()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestGenerateIntervals = ->\n  # Test perfect fifth (C to G)\n  assert.deepStrictEqual generateIntervals('C', 'G'), [\n    ['C', 0], ['C#', 1], ['D', 2], ['D#', 3],\n    ['E', 4], ['F', 5], ['F#', 6], ['G', 7]\n  ]\n  \n  # Test another perfect fifth (D to A)\n  assert.deepStrictEqual generateIntervals('D', 'A'), [\n    ['D', 0], ['D#', 1], ['E', 2], ['F', 3],\n    ['F#', 4], ['G', 5], ['G#', 6], ['A', 7]\n  ]\n  \n  # Test unison (C to C)\n  assert.deepStrictEqual generateIntervals('C', 'C'), [['C', 0]]\n  \n  # Test descending intervals (A to C)\n  assert.deepStrictEqual generateIntervals('A', 'C'), [\n    ['A', 0], ['A#', 1], ['B', 2], ['C', 3]\n  ]\n  \n  # Test augmented fourth (F# to B)\n  assert.deepStrictEqual generateIntervals('F#', 'B'), [\n    ['F#', 0], ['G', 1], ['G#', 2], ['A', 3], ['A#', 4], ['B', 5]\n  ]\n  \n  # Test invalid notes\n  assert.deepStrictEqual generateIntervals('X', 'Y'), []\n  \n  console.log \"All tests passed!\"\n\ntestGenerateIntervals()", "output": "generateIntervals"}, "all_code": "# generateIntervals produces all possible musical intervals between two notes in half steps (semitones)\n# Each interval is represented as an array containing the note name and its half step distance from the starting note\n# Notes follow the standard chromatic scale from C to B with sharps\ngenerateIntervals = (minNote, maxNote) ->\n  notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n  intervals = []\n  \n  # Find indices of the input notes in the chromatic scale\n  minIndex = notes.indexOf(minNote)\n  maxIndex = notes.indexOf(maxNote)\n  \n  # Handle invalid note inputs by returning empty array\n  return [] if minIndex is -1 or maxIndex is -1\n  \n  # Generate all intervals between min and max notes (inclusive)\n  for i in [minIndex..maxIndex]\n    intervalName = notes[i %% 12]  # Modulo 12 to wrap around the chromatic scale\n    intervalSteps = i - minIndex\n    intervals.push([intervalName, intervalSteps])\n  \n  intervals\nassert = require 'assert'\n\ntestGenerateIntervals = ->\n  # Test perfect fifth (C to G)\n  assert.deepStrictEqual generateIntervals('C', 'G'), [\n    ['C', 0], ['C#', 1], ['D', 2], ['D#', 3],\n    ['E', 4], ['F', 5], ['F#', 6], ['G', 7]\n  ]\n  \n  # Test another perfect fifth (D to A)\n  assert.deepStrictEqual generateIntervals('D', 'A'), [\n    ['D', 0], ['D#', 1], ['E', 2], ['F', 3],\n    ['F#', 4], ['G', 5], ['G#', 6], ['A', 7]\n  ]\n  \n  # Test unison (C to C)\n  assert.deepStrictEqual generateIntervals('C', 'C'), [['C', 0]]\n  \n  # Test descending intervals (A to C)\n  assert.deepStrictEqual generateIntervals('A', 'C'), [\n    ['A', 0], ['A#', 1], ['B', 2], ['C', 3]\n  ]\n  \n  # Test augmented fourth (F# to B)\n  assert.deepStrictEqual generateIntervals('F#', 'B'), [\n    ['F#', 0], ['G', 1], ['G#', 2], ['A', 3], ['A#', 4], ['B', 5]\n  ]\n  \n  # Test invalid notes\n  assert.deepStrictEqual generateIntervals('X', 'Y'), []\n  \n  console.log \"All tests passed!\"\n\ntestGenerateIntervals()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# getPreferredVps selects the preferred VPS from a list based on criteria:\n# - Minimum 1024 MB RAM\n# - Minimum 3 CPU cores\n# Among qualifying VPSs, selects the one with the largest disk space\n# Returns null if no VPS meets the criteria\ngetPreferredVps = (vpsList) ->\n  preferredVps = null\n  for vps in vpsList\n    if vps.ram >= 1024 and vps.cpu >= 3\n      if preferredVps is null or vps.disk > preferredVps.disk\n        preferredVps = vps\n  preferredVps", "test_cases": "", "test_case_results": "Test Case 1:\nInput VPS List: [ 'VPS1', 'VPS2', 'VPS3' ]\nSelected VPS: VPS3 with 120 GB disk\n\nTest Case 2:\nInput VPS List: [ 'VPS4', 'VPS5' ]\nNo VPS meets the requirements\n\nTest Case 3:\nInput VPS List: [ 'VPS6', 'VPS7', 'VPS8' ]\nSelected VPS: VPS8 with 160 GB disk\n\nTest Case 4:\nInput VPS List: []\nNo VPS meets the requirements", "task_id": 23670, "assertions": "assert = require 'assert'\n\ntestGetPreferredVps = ->\n  # Test Case 1: Should select VPS3 with largest disk (120GB) among qualifying VPSs\n  testCase1 = [\n    { name: \"VPS1\", ram: 2048, cpu: 4, disk: 100 }\n    { name: \"VPS2\", ram: 1024, cpu: 2, disk: 80 }\n    { name: \"VPS3\", ram: 1024, cpu: 4, disk: 120 }\n  ]\n  assert.strictEqual getPreferredVps(testCase1).name, \"VPS3\"\n  assert.strictEqual getPreferredVps(testCase1).disk, 120\n\n  # Test Case 2: No VPS meets requirements\n  testCase2 = [\n    { name: \"VPS4\", ram: 512, cpu: 1, disk: 40 }\n    { name: \"VPS5\", ram: 512, cpu: 4, disk: 60 }\n  ]\n  assert.strictEqual getPreferredVps(testCase2), null\n\n  # Test Case 3: Should select VPS8 with largest disk (160GB) even with less RAM\n  testCase3 = [\n    { name: \"VPS6\", ram: 2048, cpu: 4, disk: 150 }\n    { name: \"VPS7\", ram: 2048, cpu: 4, disk: 140 }\n    { name: \"VPS8\", ram: 1024, cpu: 4, disk: 160 }\n  ]\n  assert.strictEqual getPreferredVps(testCase3).name, \"VPS8\"\n  assert.strictEqual getPreferredVps(testCase3).disk, 160\n\n  # Test Case 4: Empty list\n  testCase4 = []\n  assert.strictEqual getPreferredVps(testCase4), null\n\n  console.log \"All tests passed!\"\n\ntestGetPreferredVps()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestGetPreferredVps = ->\n  # Test Case 1: Should select VPS3 with largest disk (120GB) among qualifying VPSs\n  testCase1 = [\n    { name: \"VPS1\", ram: 2048, cpu: 4, disk: 100 }\n    { name: \"VPS2\", ram: 1024, cpu: 2, disk: 80 }\n    { name: \"VPS3\", ram: 1024, cpu: 4, disk: 120 }\n  ]\n  assert.strictEqual getPreferredVps(testCase1).name, \"VPS3\"\n  assert.strictEqual getPreferredVps(testCase1).disk, 120\n\n  # Test Case 2: No VPS meets requirements\n  testCase2 = [\n    { name: \"VPS4\", ram: 512, cpu: 1, disk: 40 }\n    { name: \"VPS5\", ram: 512, cpu: 4, disk: 60 }\n  ]\n  assert.strictEqual getPreferredVps(testCase2), null\n\n  # Test Case 3: Should select VPS8 with largest disk (160GB) even with less RAM\n  testCase3 = [\n    { name: \"VPS6\", ram: 2048, cpu: 4, disk: 150 }\n    { name: \"VPS7\", ram: 2048, cpu: 4, disk: 140 }\n    { name: \"VPS8\", ram: 1024, cpu: 4, disk: 160 }\n  ]\n  assert.strictEqual getPreferredVps(testCase3).name, \"VPS8\"\n  assert.strictEqual getPreferredVps(testCase3).disk, 160\n\n  # Test Case 4: Empty list\n  testCase4 = []\n  assert.strictEqual getPreferredVps(testCase4), null\n\n  console.log \"All tests passed!\"\n\ntestGetPreferredVps()", "output": "getPreferredVps"}, "all_code": "# getPreferredVps selects the preferred VPS from a list based on criteria:\n# - Minimum 1024 MB RAM\n# - Minimum 3 CPU cores\n# Among qualifying VPSs, selects the one with the largest disk space\n# Returns null if no VPS meets the criteria\ngetPreferredVps = (vpsList) ->\n  preferredVps = null\n  for vps in vpsList\n    if vps.ram >= 1024 and vps.cpu >= 3\n      if preferredVps is null or vps.disk > preferredVps.disk\n        preferredVps = vps\n  preferredVps\nassert = require 'assert'\n\ntestGetPreferredVps = ->\n  # Test Case 1: Should select VPS3 with largest disk (120GB) among qualifying VPSs\n  testCase1 = [\n    { name: \"VPS1\", ram: 2048, cpu: 4, disk: 100 }\n    { name: \"VPS2\", ram: 1024, cpu: 2, disk: 80 }\n    { name: \"VPS3\", ram: 1024, cpu: 4, disk: 120 }\n  ]\n  assert.strictEqual getPreferredVps(testCase1).name, \"VPS3\"\n  assert.strictEqual getPreferredVps(testCase1).disk, 120\n\n  # Test Case 2: No VPS meets requirements\n  testCase2 = [\n    { name: \"VPS4\", ram: 512, cpu: 1, disk: 40 }\n    { name: \"VPS5\", ram: 512, cpu: 4, disk: 60 }\n  ]\n  assert.strictEqual getPreferredVps(testCase2), null\n\n  # Test Case 3: Should select VPS8 with largest disk (160GB) even with less RAM\n  testCase3 = [\n    { name: \"VPS6\", ram: 2048, cpu: 4, disk: 150 }\n    { name: \"VPS7\", ram: 2048, cpu: 4, disk: 140 }\n    { name: \"VPS8\", ram: 1024, cpu: 4, disk: 160 }\n  ]\n  assert.strictEqual getPreferredVps(testCase3).name, \"VPS8\"\n  assert.strictEqual getPreferredVps(testCase3).disk, 160\n\n  # Test Case 4: Empty list\n  testCase4 = []\n  assert.strictEqual getPreferredVps(testCase4), null\n\n  console.log \"All tests passed!\"\n\ntestGetPreferredVps()", "exec_outcome": "PASSED"}
{"code": "# smallestPowerOf2WithNDigits finds the smallest power of 2 that has exactly n digits.\n# Returns -1 for invalid input (n <= 0).\nsmallestPowerOf2WithNDigits = (n) ->\n  return -1 if n <= 0  # Handle invalid input\n  \n  lowerBound = Math.pow(10, n - 1)\n  upperBound = Math.pow(10, n)\n  \n  power = 0\n  while true\n    currentPower = Math.pow(2, power)\n    if currentPower >= lowerBound and currentPower < upperBound\n      return currentPower\n    power += 1", "test_cases": "", "test_case_results": "Input (digits): 1, Result: 1\nInput (digits): 2, Result: 16\nInput (digits): 3, Result: 128\nInput (digits): 4, Result: 1024\nInput (digits): 5, Result: 16384\nInput (digits): 0, Result: -1\nInput (digits): -1, Result: -1", "task_id": 5780, "assertions": "assert = require 'assert'\n\ntestSmallestPowerOf2WithNDigits = ->\n  assert.strictEqual smallestPowerOf2WithNDigits(1), 1\n  assert.strictEqual smallestPowerOf2WithNDigits(2), 16\n  assert.strictEqual smallestPowerOf2WithNDigits(3), 128\n  assert.strictEqual smallestPowerOf2WithNDigits(4), 1024\n  assert.strictEqual smallestPowerOf2WithNDigits(5), 16384\n  assert.strictEqual smallestPowerOf2WithNDigits(0), -1\n  assert.strictEqual smallestPowerOf2WithNDigits(-1), -1\n  console.log \"All tests passed!\"\n\ntestSmallestPowerOf2WithNDigits()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSmallestPowerOf2WithNDigits = ->\n  assert.strictEqual smallestPowerOf2WithNDigits(1), 1\n  assert.strictEqual smallestPowerOf2WithNDigits(2), 16\n  assert.strictEqual smallestPowerOf2WithNDigits(3), 128\n  assert.strictEqual smallestPowerOf2WithNDigits(4), 1024\n  assert.strictEqual smallestPowerOf2WithNDigits(5), 16384\n  assert.strictEqual smallestPowerOf2WithNDigits(0), -1\n  assert.strictEqual smallestPowerOf2WithNDigits(-1), -1\n  console.log \"All tests passed!\"\n\ntestSmallestPowerOf2WithNDigits()", "output": "smallestPowerOf2WithNDigits"}, "all_code": "# smallestPowerOf2WithNDigits finds the smallest power of 2 that has exactly n digits.\n# Returns -1 for invalid input (n <= 0).\nsmallestPowerOf2WithNDigits = (n) ->\n  return -1 if n <= 0  # Handle invalid input\n  \n  lowerBound = Math.pow(10, n - 1)\n  upperBound = Math.pow(10, n)\n  \n  power = 0\n  while true\n    currentPower = Math.pow(2, power)\n    if currentPower >= lowerBound and currentPower < upperBound\n      return currentPower\n    power += 1\nassert = require 'assert'\n\ntestSmallestPowerOf2WithNDigits = ->\n  assert.strictEqual smallestPowerOf2WithNDigits(1), 1\n  assert.strictEqual smallestPowerOf2WithNDigits(2), 16\n  assert.strictEqual smallestPowerOf2WithNDigits(3), 128\n  assert.strictEqual smallestPowerOf2WithNDigits(4), 1024\n  assert.strictEqual smallestPowerOf2WithNDigits(5), 16384\n  assert.strictEqual smallestPowerOf2WithNDigits(0), -1\n  assert.strictEqual smallestPowerOf2WithNDigits(-1), -1\n  console.log \"All tests passed!\"\n\ntestSmallestPowerOf2WithNDigits()", "exec_outcome": "PASSED"}
{"code": "# binarySearch performs a binary search on a sorted array to find the index of the target element.\n# If the target is found, it returns the index; otherwise, it returns -1.\nbinarySearch = (sortedList, target) ->\n  left = 0\n  right = sortedList.length - 1\n  while left <= right\n    mid = Math.floor((left + right) / 2)\n    if sortedList[mid] is target\n      return mid\n    else if sortedList[mid] < target\n      left = mid + 1\n    else\n      right = mid - 1\n  -1", "test_cases": "", "test_case_results": "Input: { sortedList: [ 1, 2, 3, 4, 5 ], target: 3 }\nResult: 2\nInput: { sortedList: [ 10, 20, 30, 40, 50 ], target: 50 }\nResult: 4\nInput: { sortedList: [ 1, 3, 5, 7, 9 ], target: 2 }\nResult: -1\nInput: { sortedList: [], target: 5 }\nResult: -1\nInput: { sortedList: [ 1, 2, 3, 4, 5, 6 ], target: 6 }\nResult: 5", "task_id": 13040, "assertions": "assert = require 'assert'\n\ntestBinarySearch = ->\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5], 3), 2\n  assert.strictEqual binarySearch([10, 20, 30, 40, 50], 50), 4\n  assert.strictEqual binarySearch([1, 3, 5, 7, 9], 2), -1\n  assert.strictEqual binarySearch([], 5), -1\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5, 6], 6), 5\n  console.log \"All tests passed!\"\n\ntestBinarySearch()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestBinarySearch = ->\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5], 3), 2\n  assert.strictEqual binarySearch([10, 20, 30, 40, 50], 50), 4\n  assert.strictEqual binarySearch([1, 3, 5, 7, 9], 2), -1\n  assert.strictEqual binarySearch([], 5), -1\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5, 6], 6), 5\n  console.log \"All tests passed!\"\n\ntestBinarySearch()", "output": "binarySearch"}, "all_code": "# binarySearch performs a binary search on a sorted array to find the index of the target element.\n# If the target is found, it returns the index; otherwise, it returns -1.\nbinarySearch = (sortedList, target) ->\n  left = 0\n  right = sortedList.length - 1\n  while left <= right\n    mid = Math.floor((left + right) / 2)\n    if sortedList[mid] is target\n      return mid\n    else if sortedList[mid] < target\n      left = mid + 1\n    else\n      right = mid - 1\n  -1\nassert = require 'assert'\n\ntestBinarySearch = ->\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5], 3), 2\n  assert.strictEqual binarySearch([10, 20, 30, 40, 50], 50), 4\n  assert.strictEqual binarySearch([1, 3, 5, 7, 9], 2), -1\n  assert.strictEqual binarySearch([], 5), -1\n  assert.strictEqual binarySearch([1, 2, 3, 4, 5, 6], 6), 5\n  console.log \"All tests passed!\"\n\ntestBinarySearch()", "exec_outcome": "PASSED"}
{"code": "# Convert an IPv4 address to an IPv6 address in IPv4-mapped format\n# @param {string} ipv4 - IPv4 address in dotted-decimal format\n# @return {string} IPv6 address in IPv4-mapped format\nipv4ToIpv6 = (ipv4) ->\n  # Split the IPv4 address into its individual components\n  parts = ipv4.split(\".\")\n\n  # Convert each component to its hexadecimal equivalent\n  hexParts = parts.map (part) -> \n    parseInt(part).toString(16).padStart(2, '0')\n\n  # Join the hex parts into a single string\n  ipv4Hex = hexParts.join('')\n\n  # Split into 4-character chunks for IPv6 format\n  ipv6Parts = []\n  for i in [0...ipv4Hex.length] by 4\n    ipv6Parts.push(ipv4Hex.substr(i, 4))\n\n  # Form the IPv4-mapped IPv6 address\n  \"::ffff:\" + ipv6Parts.join(\":\")", "test_cases": "", "test_case_results": "IPv4 Input: 192.168.1.1\nIPv6 Output: ::ffff:c0a8:0101\n\nIPv4 Input: 10.0.0.1\nIPv6 Output: ::ffff:0a00:0001\n\nIPv4 Input: 172.16.254.1\nIPv6 Output: ::ffff:ac10:fe01\n\nIPv4 Input: 0.0.0.0\nIPv6 Output: ::ffff:0000:0000\n\nIPv4 Input: 255.255.255.255\nIPv6 Output: ::ffff:ffff:ffff", "task_id": 9023, "assertions": "assert = require 'assert'\n\ntestIpv4ToIpv6 = ->\n  assert.strictEqual ipv4ToIpv6(\"192.168.1.1\"), \"::ffff:c0a8:0101\"\n  assert.strictEqual ipv4ToIpv6(\"10.0.0.1\"), \"::ffff:0a00:0001\"\n  assert.strictEqual ipv4ToIpv6(\"172.16.254.1\"), \"::ffff:ac10:fe01\"\n  assert.strictEqual ipv4ToIpv6(\"0.0.0.0\"), \"::ffff:0000:0000\"\n  assert.strictEqual ipv4ToIpv6(\"255.255.255.255\"), \"::ffff:ffff:ffff\"\n  console.log \"All tests passed!\"\n\ntestIpv4ToIpv6()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestIpv4ToIpv6 = ->\n  assert.strictEqual ipv4ToIpv6(\"192.168.1.1\"), \"::ffff:c0a8:0101\"\n  assert.strictEqual ipv4ToIpv6(\"10.0.0.1\"), \"::ffff:0a00:0001\"\n  assert.strictEqual ipv4ToIpv6(\"172.16.254.1\"), \"::ffff:ac10:fe01\"\n  assert.strictEqual ipv4ToIpv6(\"0.0.0.0\"), \"::ffff:0000:0000\"\n  assert.strictEqual ipv4ToIpv6(\"255.255.255.255\"), \"::ffff:ffff:ffff\"\n  console.log \"All tests passed!\"\n\ntestIpv4ToIpv6()", "output": "ipv4ToIpv6"}, "all_code": "# Convert an IPv4 address to an IPv6 address in IPv4-mapped format\n# @param {string} ipv4 - IPv4 address in dotted-decimal format\n# @return {string} IPv6 address in IPv4-mapped format\nipv4ToIpv6 = (ipv4) ->\n  # Split the IPv4 address into its individual components\n  parts = ipv4.split(\".\")\n\n  # Convert each component to its hexadecimal equivalent\n  hexParts = parts.map (part) -> \n    parseInt(part).toString(16).padStart(2, '0')\n\n  # Join the hex parts into a single string\n  ipv4Hex = hexParts.join('')\n\n  # Split into 4-character chunks for IPv6 format\n  ipv6Parts = []\n  for i in [0...ipv4Hex.length] by 4\n    ipv6Parts.push(ipv4Hex.substr(i, 4))\n\n  # Form the IPv4-mapped IPv6 address\n  \"::ffff:\" + ipv6Parts.join(\":\")\nassert = require 'assert'\n\ntestIpv4ToIpv6 = ->\n  assert.strictEqual ipv4ToIpv6(\"192.168.1.1\"), \"::ffff:c0a8:0101\"\n  assert.strictEqual ipv4ToIpv6(\"10.0.0.1\"), \"::ffff:0a00:0001\"\n  assert.strictEqual ipv4ToIpv6(\"172.16.254.1\"), \"::ffff:ac10:fe01\"\n  assert.strictEqual ipv4ToIpv6(\"0.0.0.0\"), \"::ffff:0000:0000\"\n  assert.strictEqual ipv4ToIpv6(\"255.255.255.255\"), \"::ffff:ffff:ffff\"\n  console.log \"All tests passed!\"\n\ntestIpv4ToIpv6()", "exec_outcome": "PASSED"}
{"code": "# Compare and swap two elements in the array based on the given direction\n# direction 1 = ascending, 0 = descending\ncompareAndSwap = (arr, i, j, direction) ->\n  if (direction is 1 and arr[i] > arr[j]) or (direction is 0 and arr[i] < arr[j])\n    [arr[i], arr[j]] = [arr[j], arr[i]]  # Swap elements\n\n# Merge a bitonic sequence in the specified direction\nbitonicMerge = (arr, low, count, direction) ->\n  if count > 1\n    mid = Math.floor(count / 2)\n    for i in [low...low + mid]\n      compareAndSwap(arr, i, i + mid, direction)\n    bitonicMerge(arr, low, mid, direction)\n    bitonicMerge(arr, low + mid, mid, direction)\n\n# Recursively sort a bitonic sequence\nbitonicSort = (arr, low, count, direction) ->\n  if count > 1\n    mid = Math.floor(count / 2)\n    bitonicSort(arr, low, mid, 1)        # Sort first half in ascending order\n    bitonicSort(arr, low + mid, mid, 0)  # Sort second half in descending order\n    bitonicMerge(arr, low, count, direction) # Merge the whole sequence\n\n# Main sorting function that pads the array to nearest power of two before sorting\ncustomBitonicSort = (arr) ->\n  n = arr.length\n  return [] if n is 0\n\n  # Find next power of two >= n\n  powerOfTwo = 1\n  while powerOfTwo < n\n    powerOfTwo <<= 1\n\n  # Pad array with Infinity values\n  paddedArr = arr.slice()  # Create a copy\n  for i in [0...powerOfTwo - n]\n    paddedArr.push(Infinity)\n\n  # Perform the sort\n  bitonicSort(paddedArr, 0, powerOfTwo, 1)\n\n  # Return only the original elements (remove padding)\n  paddedArr[0...n]", "test_cases": "", "test_case_results": "Test Case 1:\n  Input: [3,7,4,8,6,2,1,5]\n  Sorted: [1,2,3,4,5,6,7,8]\n\nTest Case 2:\n  Input: [1,2,3,4,5,6,7,8]\n  Sorted: [1,2,3,4,5,6,7,8]\n\nTest Case 3:\n  Input: [8,7,6,5,4,3,2,1]\n  Sorted: [1,2,3,4,5,6,7,8]\n\nTest Case 4:\n  Input: [5,3,9,1]\n  Sorted: [1,3,5,9]\n\nTest Case 5:\n  Input: [42]\n  Sorted: [42]\n\nTest Case 6:\n  Input: []\n  Sorted: []", "task_id": 18755, "assertions": "assert = require 'assert'\n\ntestCustomBitonicSort = ->\n  # Test Case 1: Random order\n  assert.deepStrictEqual customBitonicSort([3,7,4,8,6,2,1,5]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 2: Already sorted\n  assert.deepStrictEqual customBitonicSort([1,2,3,4,5,6,7,8]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 3: Reverse sorted\n  assert.deepStrictEqual customBitonicSort([8,7,6,5,4,3,2,1]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 4: Not power of two length\n  assert.deepStrictEqual customBitonicSort([5,3,9,1]), [1,3,5,9]\n  \n  # Test Case 5: Single element\n  assert.deepStrictEqual customBitonicSort([42]), [42]\n  \n  # Test Case 6: Empty array\n  assert.deepStrictEqual customBitonicSort([]), []\n\ntestCustomBitonicSort()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCustomBitonicSort = ->\n  # Test Case 1: Random order\n  assert.deepStrictEqual customBitonicSort([3,7,4,8,6,2,1,5]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 2: Already sorted\n  assert.deepStrictEqual customBitonicSort([1,2,3,4,5,6,7,8]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 3: Reverse sorted\n  assert.deepStrictEqual customBitonicSort([8,7,6,5,4,3,2,1]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 4: Not power of two length\n  assert.deepStrictEqual customBitonicSort([5,3,9,1]), [1,3,5,9]\n  \n  # Test Case 5: Single element\n  assert.deepStrictEqual customBitonicSort([42]), [42]\n  \n  # Test Case 6: Empty array\n  assert.deepStrictEqual customBitonicSort([]), []\n\ntestCustomBitonicSort()", "output": "customBitonicSort"}, "all_code": "# Compare and swap two elements in the array based on the given direction\n# direction 1 = ascending, 0 = descending\ncompareAndSwap = (arr, i, j, direction) ->\n  if (direction is 1 and arr[i] > arr[j]) or (direction is 0 and arr[i] < arr[j])\n    [arr[i], arr[j]] = [arr[j], arr[i]]  # Swap elements\n\n# Merge a bitonic sequence in the specified direction\nbitonicMerge = (arr, low, count, direction) ->\n  if count > 1\n    mid = Math.floor(count / 2)\n    for i in [low...low + mid]\n      compareAndSwap(arr, i, i + mid, direction)\n    bitonicMerge(arr, low, mid, direction)\n    bitonicMerge(arr, low + mid, mid, direction)\n\n# Recursively sort a bitonic sequence\nbitonicSort = (arr, low, count, direction) ->\n  if count > 1\n    mid = Math.floor(count / 2)\n    bitonicSort(arr, low, mid, 1)        # Sort first half in ascending order\n    bitonicSort(arr, low + mid, mid, 0)  # Sort second half in descending order\n    bitonicMerge(arr, low, count, direction) # Merge the whole sequence\n\n# Main sorting function that pads the array to nearest power of two before sorting\ncustomBitonicSort = (arr) ->\n  n = arr.length\n  return [] if n is 0\n\n  # Find next power of two >= n\n  powerOfTwo = 1\n  while powerOfTwo < n\n    powerOfTwo <<= 1\n\n  # Pad array with Infinity values\n  paddedArr = arr.slice()  # Create a copy\n  for i in [0...powerOfTwo - n]\n    paddedArr.push(Infinity)\n\n  # Perform the sort\n  bitonicSort(paddedArr, 0, powerOfTwo, 1)\n\n  # Return only the original elements (remove padding)\n  paddedArr[0...n]\nassert = require 'assert'\n\ntestCustomBitonicSort = ->\n  # Test Case 1: Random order\n  assert.deepStrictEqual customBitonicSort([3,7,4,8,6,2,1,5]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 2: Already sorted\n  assert.deepStrictEqual customBitonicSort([1,2,3,4,5,6,7,8]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 3: Reverse sorted\n  assert.deepStrictEqual customBitonicSort([8,7,6,5,4,3,2,1]), [1,2,3,4,5,6,7,8]\n  \n  # Test Case 4: Not power of two length\n  assert.deepStrictEqual customBitonicSort([5,3,9,1]), [1,3,5,9]\n  \n  # Test Case 5: Single element\n  assert.deepStrictEqual customBitonicSort([42]), [42]\n  \n  # Test Case 6: Empty array\n  assert.deepStrictEqual customBitonicSort([]), []\n\ntestCustomBitonicSort()", "exec_outcome": "PASSED"}
{"code": "# customIntToBase converts an integer to its string representation in the specified base.\n# Base must be between 2 and 36. Returns \"0\" for input 0.\ncustomIntToBase = (num, base) ->\n  if base < 2 or base > 36\n    throw new Error(\"Base must be between 2 and 36\")\n\n  if num == 0\n    return \"0\"\n  \n  negative = num < 0\n  num = Math.abs(num)\n  \n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = \"\"\n  \n  while num > 0\n    result = digits[num % base] + result\n    num = Math.floor(num / base)\n  \n  if negative\n    result = \"-\" + result\n  \n  return result\n\n# customBaseToInt converts a string representation of a number in the given base to an integer.\n# Base must be between 2 and 36. Handles negative numbers and whitespace.\ncustomBaseToInt = (strToConvert, base) ->\n  if base < 2 or base > 36\n    throw new Error(\"Base must be between 2 and 36\")\n  \n  strToConvert = strToConvert.trim().toUpperCase()\n  if strToConvert[0] == '-'\n    negative = true\n    strToConvert = strToConvert.substring(1)\n  else\n    negative = false\n  \n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  value = 0\n  \n  for char in strToConvert\n    if digits.indexOf(char) >= base or digits.indexOf(char) == -1\n      throw new Error(\"Invalid character for base #{base}: #{char}\")\n    value = value * base + digits.indexOf(char)\n  \n  if negative\n    value = -value\n  \n  return value", "test_cases": "", "test_case_results": "Testing customIntToBase:\nInput: 10 (base 2)\nExpected: 1010, Got: 1010\nPass: true\nInput: 255 (base 16)\nExpected: FF, Got: FF\nPass: true\nInput: 0 (base 8)\nExpected: 0, Got: 0\nPass: true\nInput: -42 (base 8)\nExpected: -52, Got: -52\nPass: true\nInput: 35 (base 36)\nExpected: Z, Got: Z\nPass: true\n\nTesting customBaseToInt:\nInput: '1010' (base 2)\nExpected: 10, Got: 10\nPass: true\nInput: 'FF' (base 16)\nExpected: 255, Got: 255\nPass: true\nInput: ' -52 ' (base 8)\nExpected: -42, Got: -42\nPass: true\nInput: 'Z' (base 36)\nExpected: 35, Got: 35\nPass: true\nInput: '1A' (base 16)\nExpected: 26, Got: 26\nPass: true\n\nTesting edge cases:\nTesting invalid base (1):\nCaught expected error: Base must be between 2 and 36\nTesting invalid character ('G' in base 16):\nCaught expected error: Invalid character for base 16: G", "task_id": 27525, "assertions": "assert = require 'assert'\n\ntestNumberBaseConversion = ->\n  # Test cases for customIntToBase\n  assert.strictEqual customIntToBase(10, 2), \"1010\"\n  assert.strictEqual customIntToBase(255, 16), \"FF\"\n  assert.strictEqual customIntToBase(0, 8), \"0\"\n  assert.strictEqual customIntToBase(-42, 8), \"-52\"\n  assert.strictEqual customIntToBase(35, 36), \"Z\"\n\n  # Test cases for customBaseToInt\n  assert.strictEqual customBaseToInt(\"1010\", 2), 10\n  assert.strictEqual customBaseToInt(\"FF\", 16), 255\n  assert.strictEqual customBaseToInt(\" -52 \", 8), -42\n  assert.strictEqual customBaseToInt(\"Z\", 36), 35\n  assert.strictEqual customBaseToInt(\"1A\", 16), 26\n\n  # Test error cases\n  assert.throws -> customIntToBase(10, 1), /Base must be between 2 and 36/\n  assert.throws -> customBaseToInt(\"G\", 16), /Invalid character for base 16: G/\n\n  console.log \"All tests passed successfully!\"\n\ntestNumberBaseConversion()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestNumberBaseConversion = ->\n  # Test cases for customIntToBase\n  assert.strictEqual customIntToBase(10, 2), \"1010\"\n  assert.strictEqual customIntToBase(255, 16), \"FF\"\n  assert.strictEqual customIntToBase(0, 8), \"0\"\n  assert.strictEqual customIntToBase(-42, 8), \"-52\"\n  assert.strictEqual customIntToBase(35, 36), \"Z\"\n\n  # Test cases for customBaseToInt\n  assert.strictEqual customBaseToInt(\"1010\", 2), 10\n  assert.strictEqual customBaseToInt(\"FF\", 16), 255\n  assert.strictEqual customBaseToInt(\" -52 \", 8), -42\n  assert.strictEqual customBaseToInt(\"Z\", 36), 35\n  assert.strictEqual customBaseToInt(\"1A\", 16), 26\n\n  # Test error cases\n  assert.throws -> customIntToBase(10, 1), /Base must be between 2 and 36/\n  assert.throws -> customBaseToInt(\"G\", 16), /Invalid character for base 16: G/\n\n  console.log \"All tests passed successfully!\"\n\ntestNumberBaseConversion()", "output": "customIntToBase and customBaseToInt"}, "all_code": "# customIntToBase converts an integer to its string representation in the specified base.\n# Base must be between 2 and 36. Returns \"0\" for input 0.\ncustomIntToBase = (num, base) ->\n  if base < 2 or base > 36\n    throw new Error(\"Base must be between 2 and 36\")\n\n  if num == 0\n    return \"0\"\n  \n  negative = num < 0\n  num = Math.abs(num)\n  \n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = \"\"\n  \n  while num > 0\n    result = digits[num % base] + result\n    num = Math.floor(num / base)\n  \n  if negative\n    result = \"-\" + result\n  \n  return result\n\n# customBaseToInt converts a string representation of a number in the given base to an integer.\n# Base must be between 2 and 36. Handles negative numbers and whitespace.\ncustomBaseToInt = (strToConvert, base) ->\n  if base < 2 or base > 36\n    throw new Error(\"Base must be between 2 and 36\")\n  \n  strToConvert = strToConvert.trim().toUpperCase()\n  if strToConvert[0] == '-'\n    negative = true\n    strToConvert = strToConvert.substring(1)\n  else\n    negative = false\n  \n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  value = 0\n  \n  for char in strToConvert\n    if digits.indexOf(char) >= base or digits.indexOf(char) == -1\n      throw new Error(\"Invalid character for base #{base}: #{char}\")\n    value = value * base + digits.indexOf(char)\n  \n  if negative\n    value = -value\n  \n  return value\nassert = require 'assert'\n\ntestNumberBaseConversion = ->\n  # Test cases for customIntToBase\n  assert.strictEqual customIntToBase(10, 2), \"1010\"\n  assert.strictEqual customIntToBase(255, 16), \"FF\"\n  assert.strictEqual customIntToBase(0, 8), \"0\"\n  assert.strictEqual customIntToBase(-42, 8), \"-52\"\n  assert.strictEqual customIntToBase(35, 36), \"Z\"\n\n  # Test cases for customBaseToInt\n  assert.strictEqual customBaseToInt(\"1010\", 2), 10\n  assert.strictEqual customBaseToInt(\"FF\", 16), 255\n  assert.strictEqual customBaseToInt(\" -52 \", 8), -42\n  assert.strictEqual customBaseToInt(\"Z\", 36), 35\n  assert.strictEqual customBaseToInt(\"1A\", 16), 26\n\n  # Test error cases\n  assert.throws -> customIntToBase(10, 1), /Base must be between 2 and 36/\n  assert.throws -> customBaseToInt(\"G\", 16), /Invalid character for base 16: G/\n\n  console.log \"All tests passed successfully!\"\n\ntestNumberBaseConversion()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# findMostAnagrams identifies the word in a list that has the most anagrams.\n# Anagrams are words formed by rearranging letters of another word.\n# The function groups words by their sorted character tuples and returns the word with the largest group.\nfindMostAnagrams = (words) ->\n  # Create a dictionary to group words by their sorted characters\n  anagramsDict = {}\n  \n  for word in words\n    # Create a key by sorting the word's characters\n    key = word.split('').sort().join('')\n    # Initialize the key's array if it doesn't exist\n    anagramsDict[key] ?= []\n    anagramsDict[key].push(word)\n  \n  # Find the word with the most anagrams\n  maxCount = 0\n  resultWord = null\n  \n  for word in words\n    key = word.split('').sort().join('')\n    count = anagramsDict[key].length\n    if count > maxCount\n      maxCount = count\n      resultWord = word\n  \n  resultWord", "test_cases": "", "test_case_results": "Input words: [ 'listen', 'silent', 'enlist', 'inlets', 'banana', 'tinsel' ]\nWord with most anagrams: listen\n---\nInput words: [ 'race', 'care', 'acre', 'dare', 'dear', 'read' ]\nWord with most anagrams: race\n---\nInput words: [ 'cat', 'dog', 'mouse', 'house' ]\nWord with most anagrams: cat\n---\nInput words: [ 'a', 'a', 'b', 'b', 'b', 'c' ]\nWord with most anagrams: b\n---", "task_id": 28794, "assertions": "assert = require 'assert'\n\ntestFindMostAnagrams = ->\n  assert.strictEqual findMostAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\", \"banana\", \"tinsel\"]), \"listen\"\n  assert.strictEqual findMostAnagrams([\"race\", \"care\", \"acre\", \"dare\", \"dear\", \"read\"]), \"race\"\n  assert.strictEqual findMostAnagrams([\"cat\", \"dog\", \"mouse\", \"house\"]), \"cat\"\n  assert.strictEqual findMostAnagrams([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\"]), \"b\"\n  console.log \"All tests passed!\"\n\ntestFindMostAnagrams()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindMostAnagrams = ->\n  assert.strictEqual findMostAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\", \"banana\", \"tinsel\"]), \"listen\"\n  assert.strictEqual findMostAnagrams([\"race\", \"care\", \"acre\", \"dare\", \"dear\", \"read\"]), \"race\"\n  assert.strictEqual findMostAnagrams([\"cat\", \"dog\", \"mouse\", \"house\"]), \"cat\"\n  assert.strictEqual findMostAnagrams([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\"]), \"b\"\n  console.log \"All tests passed!\"\n\ntestFindMostAnagrams()", "output": "findMostAnagrams"}, "all_code": "# findMostAnagrams identifies the word in a list that has the most anagrams.\n# Anagrams are words formed by rearranging letters of another word.\n# The function groups words by their sorted character tuples and returns the word with the largest group.\nfindMostAnagrams = (words) ->\n  # Create a dictionary to group words by their sorted characters\n  anagramsDict = {}\n  \n  for word in words\n    # Create a key by sorting the word's characters\n    key = word.split('').sort().join('')\n    # Initialize the key's array if it doesn't exist\n    anagramsDict[key] ?= []\n    anagramsDict[key].push(word)\n  \n  # Find the word with the most anagrams\n  maxCount = 0\n  resultWord = null\n  \n  for word in words\n    key = word.split('').sort().join('')\n    count = anagramsDict[key].length\n    if count > maxCount\n      maxCount = count\n      resultWord = word\n  \n  resultWord\nassert = require 'assert'\n\ntestFindMostAnagrams = ->\n  assert.strictEqual findMostAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\", \"banana\", \"tinsel\"]), \"listen\"\n  assert.strictEqual findMostAnagrams([\"race\", \"care\", \"acre\", \"dare\", \"dear\", \"read\"]), \"race\"\n  assert.strictEqual findMostAnagrams([\"cat\", \"dog\", \"mouse\", \"house\"]), \"cat\"\n  assert.strictEqual findMostAnagrams([\"a\", \"a\", \"b\", \"b\", \"b\", \"c\"]), \"b\"\n  console.log \"All tests passed!\"\n\ntestFindMostAnagrams()", "exec_outcome": "PASSED"}
{"code": "# countValidCodes calculates the number of valid product codes of length N.\n# A valid code consists of letters from the alphabet (a-z) and does not have\n# consecutive identical characters.\n# Uses a dynamic programming approach to efficiently compute the count.\ncountValidCodes = (N) ->\n  return 26 if N is 1  # Base case: 26 single-letter codes\n\n  # Initialize variables for dynamic programming\n  prevTotal = 26       # Count for sequences of length 1\n  prevExcludingLast = 26  # Same as prevTotal for length 1\n\n  for i in [2..N]\n    newPrevTotal = prevTotal * 25\n\n    # Update for next iteration\n    prevExcludingLast = prevTotal * 25\n    prevTotal = newPrevTotal\n\n  prevTotal", "test_cases": "", "test_case_results": "Input Length: 1\nValid Codes Count: 26\n-----\nInput Length: 2\nValid Codes Count: 650\n-----\nInput Length: 3\nValid Codes Count: 16250\n-----\nInput Length: 4\nValid Codes Count: 406250\n-----\nInput Length: 5\nValid Codes Count: 10156250\n-----", "task_id": 4781, "assertions": "assert = require 'assert'\n\ntestCountValidCodes = ->\n  assert.strictEqual countValidCodes(1), 26\n  assert.strictEqual countValidCodes(2), 650\n  assert.strictEqual countValidCodes(3), 16250\n  assert.strictEqual countValidCodes(4), 406250\n  assert.strictEqual countValidCodes(5), 10156250\n  console.log \"All tests passed!\"\n\ntestCountValidCodes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountValidCodes = ->\n  assert.strictEqual countValidCodes(1), 26\n  assert.strictEqual countValidCodes(2), 650\n  assert.strictEqual countValidCodes(3), 16250\n  assert.strictEqual countValidCodes(4), 406250\n  assert.strictEqual countValidCodes(5), 10156250\n  console.log \"All tests passed!\"\n\ntestCountValidCodes()", "output": "countValidCodes"}, "all_code": "# countValidCodes calculates the number of valid product codes of length N.\n# A valid code consists of letters from the alphabet (a-z) and does not have\n# consecutive identical characters.\n# Uses a dynamic programming approach to efficiently compute the count.\ncountValidCodes = (N) ->\n  return 26 if N is 1  # Base case: 26 single-letter codes\n\n  # Initialize variables for dynamic programming\n  prevTotal = 26       # Count for sequences of length 1\n  prevExcludingLast = 26  # Same as prevTotal for length 1\n\n  for i in [2..N]\n    newPrevTotal = prevTotal * 25\n\n    # Update for next iteration\n    prevExcludingLast = prevTotal * 25\n    prevTotal = newPrevTotal\n\n  prevTotal\nassert = require 'assert'\n\ntestCountValidCodes = ->\n  assert.strictEqual countValidCodes(1), 26\n  assert.strictEqual countValidCodes(2), 650\n  assert.strictEqual countValidCodes(3), 16250\n  assert.strictEqual countValidCodes(4), 406250\n  assert.strictEqual countValidCodes(5), 10156250\n  console.log \"All tests passed!\"\n\ntestCountValidCodes()", "exec_outcome": "PASSED"}
{"code": "class ResizableHashTable\n  constructor: (initial_size = 8) ->\n    @size = initial_size\n    @table = new Array(@size).fill(null)\n    @count = 0\n\n  # Simple hash function using modulo operation\n  hash_function: (key) -> key % @size\n\n  # Insert a key-value pair into the hash table\n  put: (key, value) ->\n    pos = @hash_function(key)\n    initial_pos = pos\n    collisions = 0\n    \n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        @table[pos] = [key, value]\n        return\n      collisions++\n      pos = (pos + 1) % @size\n    \n    @table[pos] = [key, value]\n    @count++\n    \n    # Resize if load factor exceeds threshold\n    if @count / @size > @load_factor_threshold\n      @resize()\n\n  # Retrieve a value by key from the hash table\n  get: (key) ->\n    pos = @hash_function(key)\n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        return @table[pos][1]\n      pos = (pos + 1) % @size\n    return null\n\n  # Double the size of the hash table and rehash all elements\n  resize: ->\n    old_table = @table\n    @size *= 2\n    @table = new Array(@size).fill(null)\n    @count = 0\n    for item in old_table when item isnt null\n      @put(item[0], item[1])\n\nclass AnalyticalHashTable extends ResizableHashTable\n  constructor: (initial_size = 8, load_factor_threshold = 0.75) ->\n    super(initial_size)\n    @load_factor_threshold = load_factor_threshold\n    @collisions = 0\n    @insert_operations = 0\n\n  put: (key, value) ->\n    pos = @hash_function(key)\n    initial_pos = pos\n    collisions = 0\n    @insert_operations++\n\n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        @table[pos] = [key, value]\n        return\n      collisions++\n      pos = (pos + 1) % @size\n    \n    @table[pos] = [key, value]\n    @count++\n    @collisions += collisions\n    \n    if @count / @size > @load_factor_threshold\n      @resize()\n\n  # Calculate current load factor (items/slots)\n  current_load_factor: -> @count / @size\n\n  # Calculate average collisions per insert operation\n  average_collision_length: ->\n    return 0 if @insert_operations == 0\n    @collisions / @insert_operations", "test_cases": "", "test_case_results": "Testing ResizableHashTable basic operations:\n\nInserting key-value pairs:\n  Putting 5:apple\n  Table size: 4, items: 1\n  Putting 13:banana\n  Table size: 4, items: 2\n  Putting 21:cherry\n  Table size: 4, items: 3\n  Putting 5:apricot\n  Table size: 4, items: 3\n  Putting 29:date\n  Table size: 8, items: 4\n\nRetrieving values:\n  Key 5: apricot\n  Key 13: banana\n  Key 21: cherry\n  Key 29: date\n  Key 99: not found\n\nTesting AnalyticalHashTable with metrics:\n  Current load factor: 0.50\n  Average collisions: 1.33\n  Total insert operations: 9\n  Total collisions: 12", "task_id": 14546, "assertions": "assert = require 'assert'\n\ntestHashTables = ->\n  # Test ResizableHashTable\n  basicTable = new ResizableHashTable(4)\n  basicTable.load_factor_threshold = 0.75\n\n  # Test basic operations\n  basicTable.put(5, 'apple')\n  basicTable.put(13, 'banana')\n  basicTable.put(21, 'cherry')\n  basicTable.put(5, 'apricot')  # Update\n  basicTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual basicTable.get(5), 'apricot'\n  assert.strictEqual basicTable.get(13), 'banana'\n  assert.strictEqual basicTable.get(21), 'cherry'\n  assert.strictEqual basicTable.get(29), 'date'\n  assert.strictEqual basicTable.get(99), null\n  assert.strictEqual basicTable.size, 8\n  assert.strictEqual basicTable.count, 4\n\n  # Test AnalyticalHashTable metrics\n  analyticalTable = new AnalyticalHashTable(4)\n  analyticalTable.put(5, 'apple')\n  analyticalTable.put(13, 'banana')\n  analyticalTable.put(21, 'cherry')\n  analyticalTable.put(5, 'apricot')  # Update\n  analyticalTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual analyticalTable.current_load_factor(), 0.5\n  assert.strictEqual analyticalTable.average_collision_length().toFixed(2), '1.33'\n  assert.strictEqual analyticalTable.insert_operations, 9\n  assert.strictEqual analyticalTable.collisions, 12\n\n  console.log \"All tests passed successfully!\"\n\ntestHashTables()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestHashTables = ->\n  # Test ResizableHashTable\n  basicTable = new ResizableHashTable(4)\n  basicTable.load_factor_threshold = 0.75\n\n  # Test basic operations\n  basicTable.put(5, 'apple')\n  basicTable.put(13, 'banana')\n  basicTable.put(21, 'cherry')\n  basicTable.put(5, 'apricot')  # Update\n  basicTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual basicTable.get(5), 'apricot'\n  assert.strictEqual basicTable.get(13), 'banana'\n  assert.strictEqual basicTable.get(21), 'cherry'\n  assert.strictEqual basicTable.get(29), 'date'\n  assert.strictEqual basicTable.get(99), null\n  assert.strictEqual basicTable.size, 8\n  assert.strictEqual basicTable.count, 4\n\n  # Test AnalyticalHashTable metrics\n  analyticalTable = new AnalyticalHashTable(4)\n  analyticalTable.put(5, 'apple')\n  analyticalTable.put(13, 'banana')\n  analyticalTable.put(21, 'cherry')\n  analyticalTable.put(5, 'apricot')  # Update\n  analyticalTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual analyticalTable.current_load_factor(), 0.5\n  assert.strictEqual analyticalTable.average_collision_length().toFixed(2), '1.33'\n  assert.strictEqual analyticalTable.insert_operations, 9\n  assert.strictEqual analyticalTable.collisions, 12\n\n  console.log \"All tests passed successfully!\"\n\ntestHashTables()", "output": "ResizableHashTable"}, "all_code": "class ResizableHashTable\n  constructor: (initial_size = 8) ->\n    @size = initial_size\n    @table = new Array(@size).fill(null)\n    @count = 0\n\n  # Simple hash function using modulo operation\n  hash_function: (key) -> key % @size\n\n  # Insert a key-value pair into the hash table\n  put: (key, value) ->\n    pos = @hash_function(key)\n    initial_pos = pos\n    collisions = 0\n    \n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        @table[pos] = [key, value]\n        return\n      collisions++\n      pos = (pos + 1) % @size\n    \n    @table[pos] = [key, value]\n    @count++\n    \n    # Resize if load factor exceeds threshold\n    if @count / @size > @load_factor_threshold\n      @resize()\n\n  # Retrieve a value by key from the hash table\n  get: (key) ->\n    pos = @hash_function(key)\n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        return @table[pos][1]\n      pos = (pos + 1) % @size\n    return null\n\n  # Double the size of the hash table and rehash all elements\n  resize: ->\n    old_table = @table\n    @size *= 2\n    @table = new Array(@size).fill(null)\n    @count = 0\n    for item in old_table when item isnt null\n      @put(item[0], item[1])\n\nclass AnalyticalHashTable extends ResizableHashTable\n  constructor: (initial_size = 8, load_factor_threshold = 0.75) ->\n    super(initial_size)\n    @load_factor_threshold = load_factor_threshold\n    @collisions = 0\n    @insert_operations = 0\n\n  put: (key, value) ->\n    pos = @hash_function(key)\n    initial_pos = pos\n    collisions = 0\n    @insert_operations++\n\n    while @table[pos] isnt null\n      if @table[pos][0] == key\n        @table[pos] = [key, value]\n        return\n      collisions++\n      pos = (pos + 1) % @size\n    \n    @table[pos] = [key, value]\n    @count++\n    @collisions += collisions\n    \n    if @count / @size > @load_factor_threshold\n      @resize()\n\n  # Calculate current load factor (items/slots)\n  current_load_factor: -> @count / @size\n\n  # Calculate average collisions per insert operation\n  average_collision_length: ->\n    return 0 if @insert_operations == 0\n    @collisions / @insert_operations\nassert = require 'assert'\n\ntestHashTables = ->\n  # Test ResizableHashTable\n  basicTable = new ResizableHashTable(4)\n  basicTable.load_factor_threshold = 0.75\n\n  # Test basic operations\n  basicTable.put(5, 'apple')\n  basicTable.put(13, 'banana')\n  basicTable.put(21, 'cherry')\n  basicTable.put(5, 'apricot')  # Update\n  basicTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual basicTable.get(5), 'apricot'\n  assert.strictEqual basicTable.get(13), 'banana'\n  assert.strictEqual basicTable.get(21), 'cherry'\n  assert.strictEqual basicTable.get(29), 'date'\n  assert.strictEqual basicTable.get(99), null\n  assert.strictEqual basicTable.size, 8\n  assert.strictEqual basicTable.count, 4\n\n  # Test AnalyticalHashTable metrics\n  analyticalTable = new AnalyticalHashTable(4)\n  analyticalTable.put(5, 'apple')\n  analyticalTable.put(13, 'banana')\n  analyticalTable.put(21, 'cherry')\n  analyticalTable.put(5, 'apricot')  # Update\n  analyticalTable.put(29, 'date')    # Trigger resize\n\n  assert.strictEqual analyticalTable.current_load_factor(), 0.5\n  assert.strictEqual analyticalTable.average_collision_length().toFixed(2), '1.33'\n  assert.strictEqual analyticalTable.insert_operations, 9\n  assert.strictEqual analyticalTable.collisions, 12\n\n  console.log \"All tests passed successfully!\"\n\ntestHashTables()", "exec_outcome": "PASSED"}
{"code": "# sumOddIndexedElements calculates the sum of elements located at odd indices in a given list of integers.\n# If the list is empty or has only one element, it returns 0 since there are no odd-indexed elements.\nsumOddIndexedElements = (lst) ->\n  sum = 0\n  for i in [1...lst.length] by 2\n    sum += lst[i]\n  sum", "test_cases": "", "test_case_results": "Input: [ 1, 2, 3, 4, 5 ]\nSum of odd-indexed elements: 6\nInput: [ 10, 20, 30, 40 ]\nSum of odd-indexed elements: 60\nInput: [ 0, 0, 0, 0, 0 ]\nSum of odd-indexed elements: 0\nInput: [ 5 ]\nSum of odd-indexed elements: 0\nInput: []\nSum of odd-indexed elements: 0", "task_id": 29871, "assertions": "assert = require 'assert'\n\ntestSumOddIndexedElements = ->\n  assert.strictEqual sumOddIndexedElements([1, 2, 3, 4, 5]), 6\n  assert.strictEqual sumOddIndexedElements([10, 20, 30, 40]), 60\n  assert.strictEqual sumOddIndexedElements([0, 0, 0, 0, 0]), 0\n  assert.strictEqual sumOddIndexedElements([5]), 0\n  assert.strictEqual sumOddIndexedElements([]), 0\n  console.log \"All tests passed!\"\n\ntestSumOddIndexedElements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSumOddIndexedElements = ->\n  assert.strictEqual sumOddIndexedElements([1, 2, 3, 4, 5]), 6\n  assert.strictEqual sumOddIndexedElements([10, 20, 30, 40]), 60\n  assert.strictEqual sumOddIndexedElements([0, 0, 0, 0, 0]), 0\n  assert.strictEqual sumOddIndexedElements([5]), 0\n  assert.strictEqual sumOddIndexedElements([]), 0\n  console.log \"All tests passed!\"\n\ntestSumOddIndexedElements()", "output": "sumOddIndexedElements"}, "all_code": "# sumOddIndexedElements calculates the sum of elements located at odd indices in a given list of integers.\n# If the list is empty or has only one element, it returns 0 since there are no odd-indexed elements.\nsumOddIndexedElements = (lst) ->\n  sum = 0\n  for i in [1...lst.length] by 2\n    sum += lst[i]\n  sum\nassert = require 'assert'\n\ntestSumOddIndexedElements = ->\n  assert.strictEqual sumOddIndexedElements([1, 2, 3, 4, 5]), 6\n  assert.strictEqual sumOddIndexedElements([10, 20, 30, 40]), 60\n  assert.strictEqual sumOddIndexedElements([0, 0, 0, 0, 0]), 0\n  assert.strictEqual sumOddIndexedElements([5]), 0\n  assert.strictEqual sumOddIndexedElements([]), 0\n  console.log \"All tests passed!\"\n\ntestSumOddIndexedElements()", "exec_outcome": "PASSED"}
{"code": "# searchInSortedMatrix efficiently searches for a key in a 2D matrix where each row and column is sorted.\n# The algorithm starts from the top-right corner and moves left if the current element is larger than the key,\n# or down if the current element is smaller than the key.\n#\n# Parameters:\n#   matrix - 2D array where each row and column is sorted in non-decreasing order\n#   key - the value to search for\n#\n# Returns:\n#   An array containing the row and column indices if found, otherwise [-1, -1]\nsearchInSortedMatrix = (matrix, key) ->\n  return [-1, -1] if not matrix or not matrix[0]\n  \n  rows = matrix.length\n  cols = matrix[0].length\n  \n  row = 0\n  col = cols - 1\n  \n  while row < rows and col >= 0\n    if matrix[row][col] is key\n      return [row, col]\n    else if matrix[row][col] > key\n      col -= 1\n    else\n      row += 1\n      \n  return [-1, -1]", "test_cases": "", "test_case_results": "Test Case: Key exists in matrix\nMatrix: [\n  [ 1, 4, 7, 11, 15 ],\n  [ 2, 5, 8, 12, 19 ],\n  [ 3, 6, 9, 16, 22 ],\n  [ 10, 13, 14, 17, 24 ],\n  [ 18, 21, 23, 26, 30 ]\n]\nKey: 5\nResult: [ 1, 1 ]\n-----\nTest Case: Key doesn't exist in matrix\nMatrix: [\n  [ 1, 4, 7, 11, 15 ],\n  [ 2, 5, 8, 12, 19 ],\n  [ 3, 6, 9, 16, 22 ],\n  [ 10, 13, 14, 17, 24 ],\n  [ 18, 21, 23, 26, 30 ]\n]\nKey: 20\nResult: [ -1, -1 ]\n-----\nTest Case: Key is in bottom-right corner\nMatrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\nKey: 9\nResult: [ 2, 2 ]\n-----\nTest Case: Key is in top-left corner\nMatrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]\nKey: 1\nResult: [ 0, 0 ]\n-----\nTest Case: Empty matrix\nMatrix: []\nKey: 5\nResult: [ -1, -1 ]\n-----", "task_id": 23377, "assertions": "assert = require 'assert'\n\ntestSearchInSortedMatrix = ->\n  # Test case 1: Key exists in matrix\n  matrix1 = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 5), [1, 1]\n\n  # Test case 2: Key doesn't exist in matrix\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 20), [-1, -1]\n\n  # Test case 3: Key is in bottom-right corner\n  matrix2 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 9), [2, 2]\n\n  # Test case 4: Key is in top-left corner\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 1), [0, 0]\n\n  # Test case 5: Empty matrix\n  assert.deepStrictEqual searchInSortedMatrix([], 5), [-1, -1]\n\n  console.log \"All tests passed!\"\n\ntestSearchInSortedMatrix()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestSearchInSortedMatrix = ->\n  # Test case 1: Key exists in matrix\n  matrix1 = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 5), [1, 1]\n\n  # Test case 2: Key doesn't exist in matrix\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 20), [-1, -1]\n\n  # Test case 3: Key is in bottom-right corner\n  matrix2 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 9), [2, 2]\n\n  # Test case 4: Key is in top-left corner\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 1), [0, 0]\n\n  # Test case 5: Empty matrix\n  assert.deepStrictEqual searchInSortedMatrix([], 5), [-1, -1]\n\n  console.log \"All tests passed!\"\n\ntestSearchInSortedMatrix()", "output": "searchInSortedMatrix"}, "all_code": "# searchInSortedMatrix efficiently searches for a key in a 2D matrix where each row and column is sorted.\n# The algorithm starts from the top-right corner and moves left if the current element is larger than the key,\n# or down if the current element is smaller than the key.\n#\n# Parameters:\n#   matrix - 2D array where each row and column is sorted in non-decreasing order\n#   key - the value to search for\n#\n# Returns:\n#   An array containing the row and column indices if found, otherwise [-1, -1]\nsearchInSortedMatrix = (matrix, key) ->\n  return [-1, -1] if not matrix or not matrix[0]\n  \n  rows = matrix.length\n  cols = matrix[0].length\n  \n  row = 0\n  col = cols - 1\n  \n  while row < rows and col >= 0\n    if matrix[row][col] is key\n      return [row, col]\n    else if matrix[row][col] > key\n      col -= 1\n    else\n      row += 1\n      \n  return [-1, -1]\nassert = require 'assert'\n\ntestSearchInSortedMatrix = ->\n  # Test case 1: Key exists in matrix\n  matrix1 = [\n    [1, 4, 7, 11, 15],\n    [2, 5, 8, 12, 19],\n    [3, 6, 9, 16, 22],\n    [10, 13, 14, 17, 24],\n    [18, 21, 23, 26, 30]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 5), [1, 1]\n\n  # Test case 2: Key doesn't exist in matrix\n  assert.deepStrictEqual searchInSortedMatrix(matrix1, 20), [-1, -1]\n\n  # Test case 3: Key is in bottom-right corner\n  matrix2 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ]\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 9), [2, 2]\n\n  # Test case 4: Key is in top-left corner\n  assert.deepStrictEqual searchInSortedMatrix(matrix2, 1), [0, 0]\n\n  # Test case 5: Empty matrix\n  assert.deepStrictEqual searchInSortedMatrix([], 5), [-1, -1]\n\n  console.log \"All tests passed!\"\n\ntestSearchInSortedMatrix()", "exec_outcome": "PASSED"}
{"code": "# findUniqueEmails extracts all unique email addresses from a given text string.\n# Uses a regular expression to match email patterns and ensures uniqueness by converting to a Set.\nfindUniqueEmails = (text) ->\n  # Regular expression for matching email addresses\n  emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/gi\n  matches = text.match(emailRegex) or []\n  # Convert to Set to ensure uniqueness, then back to Array\n  Array.from(new Set(matches))", "test_cases": "", "test_case_results": "Test Case 1:\nInput: Contact us at support@example.com or sales@example.com\nUnique Emails Found: [ 'support@example.com', 'sales@example.com' ]\n\nTest Case 2:\nInput: Emails: john.doe@gmail.com, jane_doe@yahoo.com, john.doe@gmail.com\nUnique Emails Found: [ 'john.doe@gmail.com', 'jane_doe@yahoo.com' ]\n\nTest Case 3:\nInput: No emails here, just text\nUnique Emails Found: []\n\nTest Case 4:\nInput: Multiple emails: a@b.com, a@b.com, test@domain.co.uk, test@domain.co.uk\nUnique Emails Found: [ 'a@b.com', 'test@domain.co.uk' ]\n\nTest Case 5:\nInput: Invalid emails: user@.com, @domain.com, user@domain\nUnique Emails Found: []", "task_id": 18535, "assertions": "assert = require 'assert'\n\ntestFindUniqueEmails = ->\n  assert.deepStrictEqual findUniqueEmails(\"Contact us at support@example.com or sales@example.com\"), \n    ['support@example.com', 'sales@example.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Emails: john.doe@gmail.com, jane_doe@yahoo.com, john.doe@gmail.com\"), \n    ['john.doe@gmail.com', 'jane_doe@yahoo.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"No emails here, just text\"), []\n  \n  assert.deepStrictEqual findUniqueEmails(\"Multiple emails: a@b.com, a@b.com, test@domain.co.uk, test@domain.co.uk\"), \n    ['a@b.com', 'test@domain.co.uk']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Invalid emails: user@.com, @domain.com, user@domain\"), []\n\ntestFindUniqueEmails()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindUniqueEmails = ->\n  assert.deepStrictEqual findUniqueEmails(\"Contact us at support@example.com or sales@example.com\"), \n    ['support@example.com', 'sales@example.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Emails: john.doe@gmail.com, jane_doe@yahoo.com, john.doe@gmail.com\"), \n    ['john.doe@gmail.com', 'jane_doe@yahoo.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"No emails here, just text\"), []\n  \n  assert.deepStrictEqual findUniqueEmails(\"Multiple emails: a@b.com, a@b.com, test@domain.co.uk, test@domain.co.uk\"), \n    ['a@b.com', 'test@domain.co.uk']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Invalid emails: user@.com, @domain.com, user@domain\"), []\n\ntestFindUniqueEmails()", "output": "findUniqueEmails"}, "all_code": "# findUniqueEmails extracts all unique email addresses from a given text string.\n# Uses a regular expression to match email patterns and ensures uniqueness by converting to a Set.\nfindUniqueEmails = (text) ->\n  # Regular expression for matching email addresses\n  emailRegex = /\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b/gi\n  matches = text.match(emailRegex) or []\n  # Convert to Set to ensure uniqueness, then back to Array\n  Array.from(new Set(matches))\nassert = require 'assert'\n\ntestFindUniqueEmails = ->\n  assert.deepStrictEqual findUniqueEmails(\"Contact us at support@example.com or sales@example.com\"), \n    ['support@example.com', 'sales@example.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Emails: john.doe@gmail.com, jane_doe@yahoo.com, john.doe@gmail.com\"), \n    ['john.doe@gmail.com', 'jane_doe@yahoo.com']\n  \n  assert.deepStrictEqual findUniqueEmails(\"No emails here, just text\"), []\n  \n  assert.deepStrictEqual findUniqueEmails(\"Multiple emails: a@b.com, a@b.com, test@domain.co.uk, test@domain.co.uk\"), \n    ['a@b.com', 'test@domain.co.uk']\n  \n  assert.deepStrictEqual findUniqueEmails(\"Invalid emails: user@.com, @domain.com, user@domain\"), []\n\ntestFindUniqueEmails()", "exec_outcome": "PASSED"}
{"code": "# minimizeHeightDifference calculates the minimum difference between the maximum and minimum heights\n# in any contiguous subarray of the given heights array.\n# \n# Parameters:\n# n - Number of people in the line (integer)\n# heights - Array of heights (array of numbers)\n#\n# Returns:\n# The minimum height difference found in any contiguous subarray (number)\nminimizeHeightDifference = (n, heights) ->\n  return 0 if n is 1\n  \n  minDiff = Infinity\n  \n  # Check all possible contiguous subarrays\n  for i in [0...n-1]\n    for j in [i+1...n]\n      subarray = heights[i..j]\n      currentDiff = Math.max(subarray...) - Math.min(subarray...)\n      minDiff = Math.min(minDiff, currentDiff)\n  \n  minDiff", "test_cases": "", "test_case_results": "Test Case: Single person case\nNumber of people: 1\nHeights: [ 150 ]\nMinimum height difference: 0\n\nTest Case: Increasing heights\nNumber of people: 3\nHeights: [ 150, 160, 170 ]\nMinimum height difference: 10\n\nTest Case: Decreasing then increasing heights\nNumber of people: 4\nHeights: [ 170, 160, 150, 155 ]\nMinimum height difference: 5\n\nTest Case: All same heights\nNumber of people: 5\nHeights: [ 150, 150, 150, 150, 150 ]\nMinimum height difference: 0\n\nTest Case: Mixed heights\nNumber of people: 6\nHeights: [ 180, 165, 175, 160, 170, 155 ]\nMinimum height difference: 10", "task_id": 15092, "assertions": "assert = require 'assert'\n\ntestMinimizeHeightDifference = ->\n  # Test case 1: Single person case\n  assert.strictEqual minimizeHeightDifference(1, [150]), 0\n  \n  # Test case 2: Increasing heights\n  assert.strictEqual minimizeHeightDifference(3, [150, 160, 170]), 10\n  \n  # Test case 3: Decreasing then increasing heights\n  assert.strictEqual minimizeHeightDifference(4, [170, 160, 150, 155]), 5\n  \n  # Test case 4: All same heights\n  assert.strictEqual minimizeHeightDifference(5, [150, 150, 150, 150, 150]), 0\n  \n  # Test case 5: Mixed heights\n  assert.strictEqual minimizeHeightDifference(6, [180, 165, 175, 160, 170, 155]), 10\n\ntestMinimizeHeightDifference()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestMinimizeHeightDifference = ->\n  # Test case 1: Single person case\n  assert.strictEqual minimizeHeightDifference(1, [150]), 0\n  \n  # Test case 2: Increasing heights\n  assert.strictEqual minimizeHeightDifference(3, [150, 160, 170]), 10\n  \n  # Test case 3: Decreasing then increasing heights\n  assert.strictEqual minimizeHeightDifference(4, [170, 160, 150, 155]), 5\n  \n  # Test case 4: All same heights\n  assert.strictEqual minimizeHeightDifference(5, [150, 150, 150, 150, 150]), 0\n  \n  # Test case 5: Mixed heights\n  assert.strictEqual minimizeHeightDifference(6, [180, 165, 175, 160, 170, 155]), 10\n\ntestMinimizeHeightDifference()", "output": "minimizeHeightDifference"}, "all_code": "# minimizeHeightDifference calculates the minimum difference between the maximum and minimum heights\n# in any contiguous subarray of the given heights array.\n# \n# Parameters:\n# n - Number of people in the line (integer)\n# heights - Array of heights (array of numbers)\n#\n# Returns:\n# The minimum height difference found in any contiguous subarray (number)\nminimizeHeightDifference = (n, heights) ->\n  return 0 if n is 1\n  \n  minDiff = Infinity\n  \n  # Check all possible contiguous subarrays\n  for i in [0...n-1]\n    for j in [i+1...n]\n      subarray = heights[i..j]\n      currentDiff = Math.max(subarray...) - Math.min(subarray...)\n      minDiff = Math.min(minDiff, currentDiff)\n  \n  minDiff\nassert = require 'assert'\n\ntestMinimizeHeightDifference = ->\n  # Test case 1: Single person case\n  assert.strictEqual minimizeHeightDifference(1, [150]), 0\n  \n  # Test case 2: Increasing heights\n  assert.strictEqual minimizeHeightDifference(3, [150, 160, 170]), 10\n  \n  # Test case 3: Decreasing then increasing heights\n  assert.strictEqual minimizeHeightDifference(4, [170, 160, 150, 155]), 5\n  \n  # Test case 4: All same heights\n  assert.strictEqual minimizeHeightDifference(5, [150, 150, 150, 150, 150]), 0\n  \n  # Test case 5: Mixed heights\n  assert.strictEqual minimizeHeightDifference(6, [180, 165, 175, 160, 170, 155]), 10\n\ntestMinimizeHeightDifference()", "exec_outcome": "PASSED"}
{"code": "# countOccurrences counts how many times a value appears in a list\n# Parameters:\n#   lst: array - list of elements to search through\n#   value: any - value to count in the list\n# Returns:\n#   number - count of how many times the value appears in the list\ncountOccurrences = (lst, value) ->\n  lst.filter((x) -> x is value).length", "test_cases": "", "test_case_results": "List: [\n  1, 2, 3, 4,\n  2, 2, 1\n]\nValue: 2\nOccurrences: 3\n---\nList: [ 'a', 'b', 'a', 'c', 'a' ]\nValue: a\nOccurrences: 3\n---\nList: [ true, false, true, true ]\nValue: true\nOccurrences: 3\n---\nList: [ 1, 2, 3 ]\nValue: 4\nOccurrences: 0\n---\nList: []\nValue: anything\nOccurrences: 0\n---", "task_id": 16405, "assertions": "assert = require 'assert'\n\ntestCountOccurrences = ->\n  assert.strictEqual countOccurrences([1, 2, 3, 4, 2, 2, 1], 2), 3\n  assert.strictEqual countOccurrences(['a', 'b', 'a', 'c', 'a'], 'a'), 3\n  assert.strictEqual countOccurrences([true, false, true, true], true), 3\n  assert.strictEqual countOccurrences([1, 2, 3], 4), 0\n  assert.strictEqual countOccurrences([], 'anything'), 0\n\ntestCountOccurrences()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountOccurrences = ->\n  assert.strictEqual countOccurrences([1, 2, 3, 4, 2, 2, 1], 2), 3\n  assert.strictEqual countOccurrences(['a', 'b', 'a', 'c', 'a'], 'a'), 3\n  assert.strictEqual countOccurrences([true, false, true, true], true), 3\n  assert.strictEqual countOccurrences([1, 2, 3], 4), 0\n  assert.strictEqual countOccurrences([], 'anything'), 0\n\ntestCountOccurrences()", "output": "countOccurrences"}, "all_code": "# countOccurrences counts how many times a value appears in a list\n# Parameters:\n#   lst: array - list of elements to search through\n#   value: any - value to count in the list\n# Returns:\n#   number - count of how many times the value appears in the list\ncountOccurrences = (lst, value) ->\n  lst.filter((x) -> x is value).length\nassert = require 'assert'\n\ntestCountOccurrences = ->\n  assert.strictEqual countOccurrences([1, 2, 3, 4, 2, 2, 1], 2), 3\n  assert.strictEqual countOccurrences(['a', 'b', 'a', 'c', 'a'], 'a'), 3\n  assert.strictEqual countOccurrences([true, false, true, true], true), 3\n  assert.strictEqual countOccurrences([1, 2, 3], 4), 0\n  assert.strictEqual countOccurrences([], 'anything'), 0\n\ntestCountOccurrences()", "exec_outcome": "PASSED"}
{"code": "# scheduleActivities calculates the maximum number of non-overlapping activities that can be scheduled.\n# It uses a greedy algorithm that always selects the activity with the earliest end time that doesn't conflict with previously selected activities.\n# \n# Parameters:\n#   activities - An array of arrays where each subarray contains two numbers [start_time, end_time]\n#\n# Returns:\n#   The maximum count of non-overlapping activities\nscheduleActivities = (activities) ->\n  # Sort activities by their end times\n  sortedActivities = activities.slice().sort (a, b) -> a[1] - b[1]\n  \n  maxCount = 0\n  lastEndTime = 0\n  \n  # Iterate through sorted activities and count non-overlapping ones\n  for [start, end] in sortedActivities\n    if start >= lastEndTime\n      maxCount += 1\n      lastEndTime = end\n  \n  maxCount", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Activities: [[1,2],[3,4],[0,6],[5,7],[8,9],[5,9]]\n  Maximum Non-overlapping Activities: 4\n\nTest Case 2:\n  Input Activities: [[1,3],[2,4],[3,5],[4,6]]\n  Maximum Non-overlapping Activities: 2\n\nTest Case 3:\n  Input Activities: [[1,2],[1,3],[1,4]]\n  Maximum Non-overlapping Activities: 1\n\nTest Case 4:\n  Input Activities: []\n  Maximum Non-overlapping Activities: 0\n\nTest Case 5:\n  Input Activities: [[10,20],[20,30],[30,40]]\n  Maximum Non-overlapping Activities: 3", "task_id": 15396, "assertions": "assert = require 'assert'\n\ntestScheduleActivities = ->\n  assert.strictEqual scheduleActivities([[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]]), 4\n  assert.strictEqual scheduleActivities([[1, 3], [2, 4], [3, 5], [4, 6]]), 2\n  assert.strictEqual scheduleActivities([[1, 2], [1, 3], [1, 4]]), 1\n  assert.strictEqual scheduleActivities([]), 0\n  assert.strictEqual scheduleActivities([[10, 20], [20, 30], [30, 40]]), 3\n  console.log \"All tests passed!\"\n\ntestScheduleActivities()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestScheduleActivities = ->\n  assert.strictEqual scheduleActivities([[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]]), 4\n  assert.strictEqual scheduleActivities([[1, 3], [2, 4], [3, 5], [4, 6]]), 2\n  assert.strictEqual scheduleActivities([[1, 2], [1, 3], [1, 4]]), 1\n  assert.strictEqual scheduleActivities([]), 0\n  assert.strictEqual scheduleActivities([[10, 20], [20, 30], [30, 40]]), 3\n  console.log \"All tests passed!\"\n\ntestScheduleActivities()", "output": "scheduleActivities"}, "all_code": "# scheduleActivities calculates the maximum number of non-overlapping activities that can be scheduled.\n# It uses a greedy algorithm that always selects the activity with the earliest end time that doesn't conflict with previously selected activities.\n# \n# Parameters:\n#   activities - An array of arrays where each subarray contains two numbers [start_time, end_time]\n#\n# Returns:\n#   The maximum count of non-overlapping activities\nscheduleActivities = (activities) ->\n  # Sort activities by their end times\n  sortedActivities = activities.slice().sort (a, b) -> a[1] - b[1]\n  \n  maxCount = 0\n  lastEndTime = 0\n  \n  # Iterate through sorted activities and count non-overlapping ones\n  for [start, end] in sortedActivities\n    if start >= lastEndTime\n      maxCount += 1\n      lastEndTime = end\n  \n  maxCount\nassert = require 'assert'\n\ntestScheduleActivities = ->\n  assert.strictEqual scheduleActivities([[1, 2], [3, 4], [0, 6], [5, 7], [8, 9], [5, 9]]), 4\n  assert.strictEqual scheduleActivities([[1, 3], [2, 4], [3, 5], [4, 6]]), 2\n  assert.strictEqual scheduleActivities([[1, 2], [1, 3], [1, 4]]), 1\n  assert.strictEqual scheduleActivities([]), 0\n  assert.strictEqual scheduleActivities([[10, 20], [20, 30], [30, 40]]), 3\n  console.log \"All tests passed!\"\n\ntestScheduleActivities()", "exec_outcome": "PASSED"}
{"code": "# reverseKElements reverses the first K elements of a queue (array) Q\n# \n# Arguments:\n# Q - array, the queue of integers\n# K - integer, the number of elements to reverse from the front of the queue\n#\n# Returns:\n# array - the queue after the first K elements have been reversed\nreverseKElements = (Q, K) ->\n  # Create a copy of the input array to avoid mutation\n  queue = Q.slice()\n  \n  # Take out the first K elements and reverse them\n  stack = []\n  for i in [0...K]\n    stack.push(queue.shift())\n  \n  stack.reverse()\n  \n  # Add the reversed elements back to the front of the queue\n  queue.unshift(stack...)\n  \n  # Return the modified queue\n  queue", "test_cases": "", "test_case_results": "Test Case 1:\n  Input Queue: [ 1, 2, 3, 4, 5 ]\n  K: 3\n  Result: [ 3, 2, 1, 4, 5 ]\n\nTest Case 2:\n  Input Queue: [ 10, 20, 30, 40, 50, 60 ]\n  K: 4\n  Result: [ 40, 30, 20, 10, 50, 60 ]\n\nTest Case 3:\n  Input Queue: [ 7, 8, 9 ]\n  K: 2\n  Result: [ 8, 7, 9 ]\n\nTest Case 4:\n  Input Queue: [ 100, 200, 300 ]\n  K: 1\n  Result: [ 100, 200, 300 ]\n\nTest Case 5:\n  Input Queue: [ 5, 4, 3, 2, 1 ]\n  K: 5\n  Result: [ 1, 2, 3, 4, 5 ]", "task_id": 11601, "assertions": "assert = require 'assert'\n\ntestReverseKElements = ->\n  assert.deepStrictEqual reverseKElements([1, 2, 3, 4, 5], 3), [3, 2, 1, 4, 5]\n  assert.deepStrictEqual reverseKElements([10, 20, 30, 40, 50, 60], 4), [40, 30, 20, 10, 50, 60]\n  assert.deepStrictEqual reverseKElements([7, 8, 9], 2), [8, 7, 9]\n  assert.deepStrictEqual reverseKElements([100, 200, 300], 1), [100, 200, 300]\n  assert.deepStrictEqual reverseKElements([5, 4, 3, 2, 1], 5), [1, 2, 3, 4, 5]\n  console.log \"All tests passed!\"\n\ntestReverseKElements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestReverseKElements = ->\n  assert.deepStrictEqual reverseKElements([1, 2, 3, 4, 5], 3), [3, 2, 1, 4, 5]\n  assert.deepStrictEqual reverseKElements([10, 20, 30, 40, 50, 60], 4), [40, 30, 20, 10, 50, 60]\n  assert.deepStrictEqual reverseKElements([7, 8, 9], 2), [8, 7, 9]\n  assert.deepStrictEqual reverseKElements([100, 200, 300], 1), [100, 200, 300]\n  assert.deepStrictEqual reverseKElements([5, 4, 3, 2, 1], 5), [1, 2, 3, 4, 5]\n  console.log \"All tests passed!\"\n\ntestReverseKElements()", "output": "reverseKElements"}, "all_code": "# reverseKElements reverses the first K elements of a queue (array) Q\n# \n# Arguments:\n# Q - array, the queue of integers\n# K - integer, the number of elements to reverse from the front of the queue\n#\n# Returns:\n# array - the queue after the first K elements have been reversed\nreverseKElements = (Q, K) ->\n  # Create a copy of the input array to avoid mutation\n  queue = Q.slice()\n  \n  # Take out the first K elements and reverse them\n  stack = []\n  for i in [0...K]\n    stack.push(queue.shift())\n  \n  stack.reverse()\n  \n  # Add the reversed elements back to the front of the queue\n  queue.unshift(stack...)\n  \n  # Return the modified queue\n  queue\nassert = require 'assert'\n\ntestReverseKElements = ->\n  assert.deepStrictEqual reverseKElements([1, 2, 3, 4, 5], 3), [3, 2, 1, 4, 5]\n  assert.deepStrictEqual reverseKElements([10, 20, 30, 40, 50, 60], 4), [40, 30, 20, 10, 50, 60]\n  assert.deepStrictEqual reverseKElements([7, 8, 9], 2), [8, 7, 9]\n  assert.deepStrictEqual reverseKElements([100, 200, 300], 1), [100, 200, 300]\n  assert.deepStrictEqual reverseKElements([5, 4, 3, 2, 1], 5), [1, 2, 3, 4, 5]\n  console.log \"All tests passed!\"\n\ntestReverseKElements()", "exec_outcome": "PASSED"}
{"code": "# canPlow checks if it's possible to plow a grid either row-first or column-first without hitting obstacles (#)\n# n: number of rows, m: number of columns, grid: 2D array representing the field\ncanPlow = (n, m, grid) ->\n    # Check row-first movement possibility\n    rowFirstPossible = true\n    for i in [0...m]\n        if grid[0][i] is '#'\n            rowFirstPossible = false\n            break\n    if rowFirstPossible\n        for i in [1...n]\n            if grid[i][m-1] is '#'\n                rowFirstPossible = false\n                break\n\n    # Check column-first movement possibility\n    columnFirstPossible = true\n    for i in [0...n]\n        if grid[i][0] is '#'\n            columnFirstPossible = false\n            break\n    if columnFirstPossible\n        for i in [1...m]\n            if grid[n-1][i] is '#'\n                columnFirstPossible = false\n                break\n\n    if rowFirstPossible or columnFirstPossible then \"YES\" else \"NO\"", "test_cases": "", "test_case_results": "Test Case 1:\nInput:\nn: 2, m: 2\nGrid:\n[ '.', '.' ]\n[ '.', '.' ]\nResult: YES\n\nTest Case 2:\nInput:\nn: 3, m: 3\nGrid:\n[ '.', '#', '.' ]\n[ '.', '.', '.' ]\n[ '.', '.', '.' ]\nResult: YES\n\nTest Case 3:\nInput:\nn: 3, m: 3\nGrid:\n[ '.', '.', '.' ]\n[ '#', '.', '.' ]\n[ '.', '.', '.' ]\nResult: YES\n\nTest Case 4:\nInput:\nn: 3, m: 3\nGrid:\n[ '#', '.', '.' ]\n[ '.', '.', '.' ]\n[ '.', '.', '.' ]\nResult: NO", "task_id": 10441, "assertions": "assert = require 'assert'\n\ntestCanPlow = ->\n    # Test Case 1: Empty 2x2 grid\n    grid1 = [\n        ['.', '.'],\n        ['.', '.']\n    ]\n    assert.strictEqual canPlow(2, 2, grid1), \"YES\"\n\n    # Test Case 2: Obstacle in first row but column-first possible\n    grid2 = [\n        ['.', '#', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid2), \"YES\"\n\n    # Test Case 3: Obstacle in second row but row-first possible\n    grid3 = [\n        ['.', '.', '.'],\n        ['#', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid3), \"YES\"\n\n    # Test Case 4: Obstacle in first cell - neither possible\n    grid4 = [\n        ['#', '.', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid4), \"NO\"\n\n    console.log \"All tests passed!\"\n\ntestCanPlow()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCanPlow = ->\n    # Test Case 1: Empty 2x2 grid\n    grid1 = [\n        ['.', '.'],\n        ['.', '.']\n    ]\n    assert.strictEqual canPlow(2, 2, grid1), \"YES\"\n\n    # Test Case 2: Obstacle in first row but column-first possible\n    grid2 = [\n        ['.', '#', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid2), \"YES\"\n\n    # Test Case 3: Obstacle in second row but row-first possible\n    grid3 = [\n        ['.', '.', '.'],\n        ['#', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid3), \"YES\"\n\n    # Test Case 4: Obstacle in first cell - neither possible\n    grid4 = [\n        ['#', '.', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid4), \"NO\"\n\n    console.log \"All tests passed!\"\n\ntestCanPlow()", "output": "canPlow"}, "all_code": "# canPlow checks if it's possible to plow a grid either row-first or column-first without hitting obstacles (#)\n# n: number of rows, m: number of columns, grid: 2D array representing the field\ncanPlow = (n, m, grid) ->\n    # Check row-first movement possibility\n    rowFirstPossible = true\n    for i in [0...m]\n        if grid[0][i] is '#'\n            rowFirstPossible = false\n            break\n    if rowFirstPossible\n        for i in [1...n]\n            if grid[i][m-1] is '#'\n                rowFirstPossible = false\n                break\n\n    # Check column-first movement possibility\n    columnFirstPossible = true\n    for i in [0...n]\n        if grid[i][0] is '#'\n            columnFirstPossible = false\n            break\n    if columnFirstPossible\n        for i in [1...m]\n            if grid[n-1][i] is '#'\n                columnFirstPossible = false\n                break\n\n    if rowFirstPossible or columnFirstPossible then \"YES\" else \"NO\"\nassert = require 'assert'\n\ntestCanPlow = ->\n    # Test Case 1: Empty 2x2 grid\n    grid1 = [\n        ['.', '.'],\n        ['.', '.']\n    ]\n    assert.strictEqual canPlow(2, 2, grid1), \"YES\"\n\n    # Test Case 2: Obstacle in first row but column-first possible\n    grid2 = [\n        ['.', '#', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid2), \"YES\"\n\n    # Test Case 3: Obstacle in second row but row-first possible\n    grid3 = [\n        ['.', '.', '.'],\n        ['#', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid3), \"YES\"\n\n    # Test Case 4: Obstacle in first cell - neither possible\n    grid4 = [\n        ['#', '.', '.'],\n        ['.', '.', '.'],\n        ['.', '.', '.']\n    ]\n    assert.strictEqual canPlow(3, 3, grid4), \"NO\"\n\n    console.log \"All tests passed!\"\n\ntestCanPlow()", "exec_outcome": "PASSED"}
{"code": "# kthSmallestElement finds the k-th smallest element in an array using the Quickselect algorithm.\n# Quickselect is a selection algorithm to find the k-th smallest element in an unordered list.\n# It is related to the quicksort algorithm but only recurses into one side of the partition.\nkthSmallestElement = (nums, k) ->\n  # partition function rearranges the array so that all elements less than the pivot come before it,\n  # and all elements greater than the pivot come after it. Returns the final index of the pivot.\n  partition = (left, right, pivotIndex) ->\n    pivotValue = nums[pivotIndex]\n    [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]] # Move pivot to end\n    storeIndex = left\n    for i in [left...right]\n      if nums[i] < pivotValue\n        [nums[storeIndex], nums[i]] = [nums[i], nums[storeIndex]]\n        storeIndex += 1\n    [nums[right], nums[storeIndex]] = [nums[storeIndex], nums[right]] # Move pivot to its final place\n    storeIndex\n\n  # quickselect function recursively narrows down the search to find the k-th smallest element.\n  quickselect = (left, right, kSmallest) ->\n    if left == right\n      return nums[left]\n    \n    pivotIndex = left + Math.floor((right - left) / 2)\n    pivotIndex = partition(left, right, pivotIndex)\n    \n    if kSmallest == pivotIndex\n      return nums[kSmallest]\n    else if kSmallest < pivotIndex\n      return quickselect(left, pivotIndex - 1, kSmallest)\n    else\n      return quickselect(pivotIndex + 1, right, kSmallest)\n  \n  return quickselect(0, nums.length - 1, k - 1)", "test_cases": "", "test_case_results": "Input: { nums: [ 3, 2, 1, 5, 6, 4 ], k: 2 }\nResult: 2\nInput: {\n  nums: [\n    3, 2, 3, 1, 2,\n    4, 5, 5, 6\n  ],\n  k: 4\n}\nResult: 3\nInput: { nums: [ 1 ], k: 1 }\nResult: 1\nInput: { nums: [ 5, 4, 3, 2, 1 ], k: 5 }\nResult: 5", "task_id": 6168, "assertions": "assert = require 'assert'\n\ntestKthSmallestElement = ->\n  assert.strictEqual kthSmallestElement([3, 2, 1, 5, 6, 4], 2), 2\n  assert.strictEqual kthSmallestElement([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 3\n  assert.strictEqual kthSmallestElement([1], 1), 1\n  assert.strictEqual kthSmallestElement([5, 4, 3, 2, 1], 5), 5\n  console.log \"All tests passed!\"\n\ntestKthSmallestElement()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestKthSmallestElement = ->\n  assert.strictEqual kthSmallestElement([3, 2, 1, 5, 6, 4], 2), 2\n  assert.strictEqual kthSmallestElement([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 3\n  assert.strictEqual kthSmallestElement([1], 1), 1\n  assert.strictEqual kthSmallestElement([5, 4, 3, 2, 1], 5), 5\n  console.log \"All tests passed!\"\n\ntestKthSmallestElement()", "output": "kthSmallestElement"}, "all_code": "# kthSmallestElement finds the k-th smallest element in an array using the Quickselect algorithm.\n# Quickselect is a selection algorithm to find the k-th smallest element in an unordered list.\n# It is related to the quicksort algorithm but only recurses into one side of the partition.\nkthSmallestElement = (nums, k) ->\n  # partition function rearranges the array so that all elements less than the pivot come before it,\n  # and all elements greater than the pivot come after it. Returns the final index of the pivot.\n  partition = (left, right, pivotIndex) ->\n    pivotValue = nums[pivotIndex]\n    [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]] # Move pivot to end\n    storeIndex = left\n    for i in [left...right]\n      if nums[i] < pivotValue\n        [nums[storeIndex], nums[i]] = [nums[i], nums[storeIndex]]\n        storeIndex += 1\n    [nums[right], nums[storeIndex]] = [nums[storeIndex], nums[right]] # Move pivot to its final place\n    storeIndex\n\n  # quickselect function recursively narrows down the search to find the k-th smallest element.\n  quickselect = (left, right, kSmallest) ->\n    if left == right\n      return nums[left]\n    \n    pivotIndex = left + Math.floor((right - left) / 2)\n    pivotIndex = partition(left, right, pivotIndex)\n    \n    if kSmallest == pivotIndex\n      return nums[kSmallest]\n    else if kSmallest < pivotIndex\n      return quickselect(left, pivotIndex - 1, kSmallest)\n    else\n      return quickselect(pivotIndex + 1, right, kSmallest)\n  \n  return quickselect(0, nums.length - 1, k - 1)\nassert = require 'assert'\n\ntestKthSmallestElement = ->\n  assert.strictEqual kthSmallestElement([3, 2, 1, 5, 6, 4], 2), 2\n  assert.strictEqual kthSmallestElement([3, 2, 3, 1, 2, 4, 5, 5, 6], 4), 3\n  assert.strictEqual kthSmallestElement([1], 1), 1\n  assert.strictEqual kthSmallestElement([5, 4, 3, 2, 1], 5), 5\n  console.log \"All tests passed!\"\n\ntestKthSmallestElement()", "exec_outcome": "PASSED"}
{"code": "# detectPositiveCycle detects if there's any positive weight cycle in a directed graph\n# using the Bellman-Ford algorithm adapted for positive cycles.\n# Parameters:\n#   n - number of vertices\n#   m - number of edges\n#   edges - array of [u, v, w] tuples representing edges from u to v with weight w\n# Returns \"YES\" if positive cycle exists, \"NO\" otherwise\ndetectPositiveCycle = (n, m, edges) ->\n  # Build adjacency list representation of the graph\n  graph = {}\n  for [u, v, w] in edges\n    graph[u] ?= []\n    graph[u].push([v, w])\n  \n  # Bellman-Ford implementation to detect positive cycles\n  bellmanFord = (start) ->\n    # Initialize distances with -Infinity\n    dist = (-Infinity for _ in [0..n])\n    dist[start] = 0\n    \n    # Relax all edges n-1 times\n    for _ in [1...n]\n      for u of graph when graph[u]?\n        for [v, w] in graph[u]\n          if dist[u] isnt -Infinity and dist[v] < dist[u] + w\n            dist[v] = dist[u] + w\n    \n    # Check for positive cycles\n    for u of graph when graph[u]?\n      for [v, w] in graph[u]\n        if dist[u] isnt -Infinity and dist[v] < dist[u] + w\n          return true\n    \n    false\n  \n  # Check each vertex as potential start point\n  for i in [1..n]\n    if bellmanFord(i)\n      return \"YES\"\n  \n  \"NO\"\n\n# processTestCases runs multiple test cases through detectPositiveCycle\n# Parameters:\n#   t - number of test cases\n#   testCases - array of test cases, each being [n, m, edges]\n# Returns array of results (\"YES\"/\"NO\") for each test case\nprocessTestCases = (t, testCases) ->\n  results = []\n  for i in [0...t]\n    [n, m, edges] = testCases[i]\n    results.push(detectPositiveCycle(n, m, edges))\n  results", "test_cases": "", "test_case_results": "Test Case 1:\n  Vertices: 3\n  Edges: [ [ 1, 2, 2 ], [ 2, 3, 3 ], [ 3, 1, 4 ] ]\n  Result: YES\n\nTest Case 2:\n  Vertices: 3\n  Edges: [ [ 1, 2, 2 ], [ 2, 3, 3 ], [ 3, 1, -4 ] ]\n  Result: YES\n\nTest Case 3:\n  Vertices: 1\n  Edges: [ [ 1, 1, 5 ] ]\n  Result: YES\n\nTest Case 4:\n  Vertices: 1\n  Edges: [ [ 1, 1, -5 ] ]\n  Result: NO\n\nTest Case 5:\n  Vertices: 4\n  Edges: [ [ 1, 2, 1 ], [ 2, 3, 1 ], [ 3, 1, 1 ], [ 4, 4, 1 ] ]\n  Result: YES", "task_id": 18876, "assertions": "assert = require 'assert'\n\ntestDetectPositiveCycle = ->\n  testCases = [\n    # Test case 1: Graph with positive cycle\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, 4]\n      ]\n    ],\n    # Test case 2: Graph without positive cycle (but actually has positive cycle)\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, -4]\n      ]\n    ],\n    # Test case 3: Single node with self-loop (positive)\n    [\n      1, 1, [\n        [1, 1, 5]\n      ]\n    ],\n    # Test case 4: Single node with self-loop (negative)\n    [\n      1, 1, [\n        [1, 1, -5]\n      ]\n    ],\n    # Test case 5: Disconnected graph with positive cycle in one component\n    [\n      4, 4, [\n        [1, 2, 1],\n        [2, 3, 1],\n        [3, 1, 1],\n        [4, 4, 1]\n      ]\n    ]\n  ]\n\n  expectedResults = [\"YES\", \"YES\", \"YES\", \"NO\", \"YES\"]\n  actualResults = processTestCases(testCases.length, testCases)\n  \n  for i in [0...testCases.length]\n    assert.strictEqual actualResults[i], expectedResults[i],\n      \"Test case #{i+1} failed: Expected #{expectedResults[i]}, got #{actualResults[i]}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestDetectPositiveCycle()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestDetectPositiveCycle = ->\n  testCases = [\n    # Test case 1: Graph with positive cycle\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, 4]\n      ]\n    ],\n    # Test case 2: Graph without positive cycle (but actually has positive cycle)\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, -4]\n      ]\n    ],\n    # Test case 3: Single node with self-loop (positive)\n    [\n      1, 1, [\n        [1, 1, 5]\n      ]\n    ],\n    # Test case 4: Single node with self-loop (negative)\n    [\n      1, 1, [\n        [1, 1, -5]\n      ]\n    ],\n    # Test case 5: Disconnected graph with positive cycle in one component\n    [\n      4, 4, [\n        [1, 2, 1],\n        [2, 3, 1],\n        [3, 1, 1],\n        [4, 4, 1]\n      ]\n    ]\n  ]\n\n  expectedResults = [\"YES\", \"YES\", \"YES\", \"NO\", \"YES\"]\n  actualResults = processTestCases(testCases.length, testCases)\n  \n  for i in [0...testCases.length]\n    assert.strictEqual actualResults[i], expectedResults[i],\n      \"Test case #{i+1} failed: Expected #{expectedResults[i]}, got #{actualResults[i]}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestDetectPositiveCycle()", "output": "detectPositiveCycle"}, "all_code": "# detectPositiveCycle detects if there's any positive weight cycle in a directed graph\n# using the Bellman-Ford algorithm adapted for positive cycles.\n# Parameters:\n#   n - number of vertices\n#   m - number of edges\n#   edges - array of [u, v, w] tuples representing edges from u to v with weight w\n# Returns \"YES\" if positive cycle exists, \"NO\" otherwise\ndetectPositiveCycle = (n, m, edges) ->\n  # Build adjacency list representation of the graph\n  graph = {}\n  for [u, v, w] in edges\n    graph[u] ?= []\n    graph[u].push([v, w])\n  \n  # Bellman-Ford implementation to detect positive cycles\n  bellmanFord = (start) ->\n    # Initialize distances with -Infinity\n    dist = (-Infinity for _ in [0..n])\n    dist[start] = 0\n    \n    # Relax all edges n-1 times\n    for _ in [1...n]\n      for u of graph when graph[u]?\n        for [v, w] in graph[u]\n          if dist[u] isnt -Infinity and dist[v] < dist[u] + w\n            dist[v] = dist[u] + w\n    \n    # Check for positive cycles\n    for u of graph when graph[u]?\n      for [v, w] in graph[u]\n        if dist[u] isnt -Infinity and dist[v] < dist[u] + w\n          return true\n    \n    false\n  \n  # Check each vertex as potential start point\n  for i in [1..n]\n    if bellmanFord(i)\n      return \"YES\"\n  \n  \"NO\"\n\n# processTestCases runs multiple test cases through detectPositiveCycle\n# Parameters:\n#   t - number of test cases\n#   testCases - array of test cases, each being [n, m, edges]\n# Returns array of results (\"YES\"/\"NO\") for each test case\nprocessTestCases = (t, testCases) ->\n  results = []\n  for i in [0...t]\n    [n, m, edges] = testCases[i]\n    results.push(detectPositiveCycle(n, m, edges))\n  results\nassert = require 'assert'\n\ntestDetectPositiveCycle = ->\n  testCases = [\n    # Test case 1: Graph with positive cycle\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, 4]\n      ]\n    ],\n    # Test case 2: Graph without positive cycle (but actually has positive cycle)\n    [\n      3, 3, [\n        [1, 2, 2],\n        [2, 3, 3],\n        [3, 1, -4]\n      ]\n    ],\n    # Test case 3: Single node with self-loop (positive)\n    [\n      1, 1, [\n        [1, 1, 5]\n      ]\n    ],\n    # Test case 4: Single node with self-loop (negative)\n    [\n      1, 1, [\n        [1, 1, -5]\n      ]\n    ],\n    # Test case 5: Disconnected graph with positive cycle in one component\n    [\n      4, 4, [\n        [1, 2, 1],\n        [2, 3, 1],\n        [3, 1, 1],\n        [4, 4, 1]\n      ]\n    ]\n  ]\n\n  expectedResults = [\"YES\", \"YES\", \"YES\", \"NO\", \"YES\"]\n  actualResults = processTestCases(testCases.length, testCases)\n  \n  for i in [0...testCases.length]\n    assert.strictEqual actualResults[i], expectedResults[i],\n      \"Test case #{i+1} failed: Expected #{expectedResults[i]}, got #{actualResults[i]}\"\n\n  console.log \"All tests passed successfully!\"\n\ntestDetectPositiveCycle()", "exec_outcome": "PASSED"}
{"code": "# countDivisibleByK counts the number of employees whose ID is divisible by K.\n# Parameters:\n#   N - Number of employees (integer)\n#   edges - List of edges denoting the reporting structure (array of arrays)\n#   K - The divisor to check divisibility (integer)\n# Returns:\n#   Count of employees with IDs divisible by K (integer)\ncountDivisibleByK = (N, edges, K) ->\n  # We don't actually need to build the tree for this specific function,\n  # since we're only counting IDs divisible by K regardless of the hierarchy\n  count = 0\n  for employeeId in [1..N]\n    if employeeId % K is 0\n      count += 1\n  count", "test_cases": "", "test_case_results": "Test Case: Basic test case with 5 employees and K=2\nInput:\n  N: 5\n  edges: [ [ 1, 2 ], [ 1, 3 ], [ 2, 4 ], [ 2, 5 ] ]\n  K: 2\nResult: 2\nExpected: 2\nTest PASSED\n---\nTest Case: All employees divisible by 1\nInput:\n  N: 5\n  edges: [ [ 1, 2 ], [ 1, 3 ], [ 2, 4 ], [ 2, 5 ] ]\n  K: 1\nResult: 5\nExpected: 5\nTest PASSED\n---\nTest Case: No employees divisible by large K\nInput:\n  N: 5\n  edges: [ [ 1, 2 ], [ 1, 3 ], [ 2, 4 ], [ 2, 5 ] ]\n  K: 7\nResult: 0\nExpected: 0\nTest PASSED\n---\nTest Case: Edge case with N=0\nInput:\n  N: 0\n  edges: []\n  K: 2\nResult: 1\nExpected: 0\nTest FAILED\n---", "task_id": 23561, "assertions": "assert = require 'assert'\n\ntestCountDivisibleByK = ->\n  # Test case 1: Basic test case with 5 employees and K=2\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 2), 2\n  \n  # Test case 2: All employees divisible by 1\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 1), 5\n  \n  # Test case 3: No employees divisible by large K\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 7), 0\n  \n  # Test case 4: Edge case with N=0\n  assert.strictEqual countDivisibleByK(0, [], 2), 0\n\ntestCountDivisibleByK()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestCountDivisibleByK = ->\n  # Test case 1: Basic test case with 5 employees and K=2\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 2), 2\n  \n  # Test case 2: All employees divisible by 1\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 1), 5\n  \n  # Test case 3: No employees divisible by large K\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 7), 0\n  \n  # Test case 4: Edge case with N=0\n  assert.strictEqual countDivisibleByK(0, [], 2), 0\n\ntestCountDivisibleByK()", "output": "countDivisibleByK"}, "all_code": "# countDivisibleByK counts the number of employees whose ID is divisible by K.\n# Parameters:\n#   N - Number of employees (integer)\n#   edges - List of edges denoting the reporting structure (array of arrays)\n#   K - The divisor to check divisibility (integer)\n# Returns:\n#   Count of employees with IDs divisible by K (integer)\ncountDivisibleByK = (N, edges, K) ->\n  # We don't actually need to build the tree for this specific function,\n  # since we're only counting IDs divisible by K regardless of the hierarchy\n  count = 0\n  for employeeId in [1..N]\n    if employeeId % K is 0\n      count += 1\n  count\nassert = require 'assert'\n\ntestCountDivisibleByK = ->\n  # Test case 1: Basic test case with 5 employees and K=2\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 2), 2\n  \n  # Test case 2: All employees divisible by 1\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 1), 5\n  \n  # Test case 3: No employees divisible by large K\n  assert.strictEqual countDivisibleByK(5, [[1, 2], [1, 3], [2, 4], [2, 5]], 7), 0\n  \n  # Test case 4: Edge case with N=0\n  assert.strictEqual countDivisibleByK(0, [], 2), 0\n\ntestCountDivisibleByK()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# findPermutationCycles calculates the number of cycles and the length of the longest cycle in a permutation.\n# \n# @param n [Number] the size of the permutation\n# @param permutation [Array<Number>] a permutation of integers from 1 to n\n# @return [Array<Number>] an array of two numbers: [number of cycles, length of longest cycle]\nfindPermutationCycles = (n, permutation) ->\n  visited = new Array(n).fill(false)\n  cycles = 0\n  longestCycleLength = 0\n\n  for i in [0...n]\n    if not visited[i]\n      cycleLength = 0\n      current = i\n      while not visited[current]\n        visited[current] = true\n        current = permutation[current] - 1\n        cycleLength += 1\n      cycles += 1\n      longestCycleLength = Math.max(longestCycleLength, cycleLength)\n\n  [cycles, longestCycleLength]", "test_cases": "", "test_case_results": "Input: { n: 5, permutation: [ 2, 3, 1, 5, 4 ] }\nCycles: 2 Longest Cycle: 3\nInput: { n: 4, permutation: [ 4, 3, 2, 1 ] }\nCycles: 2 Longest Cycle: 2\nInput: { n: 6, permutation: [ 1, 2, 3, 4, 5, 6 ] }\nCycles: 6 Longest Cycle: 1\nInput: { n: 3, permutation: [ 3, 1, 2 ] }\nCycles: 1 Longest Cycle: 3", "task_id": 17627, "assertions": "assert = require 'assert'\n\ntestFindPermutationCycles = ->\n  assert.deepStrictEqual findPermutationCycles(5, [2, 3, 1, 5, 4]), [2, 3]\n  assert.deepStrictEqual findPermutationCycles(4, [4, 3, 2, 1]), [2, 2]\n  assert.deepStrictEqual findPermutationCycles(6, [1, 2, 3, 4, 5, 6]), [6, 1]\n  assert.deepStrictEqual findPermutationCycles(3, [3, 1, 2]), [1, 3]\n  console.log \"All tests passed!\"\n\ntestFindPermutationCycles()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestFindPermutationCycles = ->\n  assert.deepStrictEqual findPermutationCycles(5, [2, 3, 1, 5, 4]), [2, 3]\n  assert.deepStrictEqual findPermutationCycles(4, [4, 3, 2, 1]), [2, 2]\n  assert.deepStrictEqual findPermutationCycles(6, [1, 2, 3, 4, 5, 6]), [6, 1]\n  assert.deepStrictEqual findPermutationCycles(3, [3, 1, 2]), [1, 3]\n  console.log \"All tests passed!\"\n\ntestFindPermutationCycles()", "output": "findPermutationCycles"}, "all_code": "# findPermutationCycles calculates the number of cycles and the length of the longest cycle in a permutation.\n# \n# @param n [Number] the size of the permutation\n# @param permutation [Array<Number>] a permutation of integers from 1 to n\n# @return [Array<Number>] an array of two numbers: [number of cycles, length of longest cycle]\nfindPermutationCycles = (n, permutation) ->\n  visited = new Array(n).fill(false)\n  cycles = 0\n  longestCycleLength = 0\n\n  for i in [0...n]\n    if not visited[i]\n      cycleLength = 0\n      current = i\n      while not visited[current]\n        visited[current] = true\n        current = permutation[current] - 1\n        cycleLength += 1\n      cycles += 1\n      longestCycleLength = Math.max(longestCycleLength, cycleLength)\n\n  [cycles, longestCycleLength]\nassert = require 'assert'\n\ntestFindPermutationCycles = ->\n  assert.deepStrictEqual findPermutationCycles(5, [2, 3, 1, 5, 4]), [2, 3]\n  assert.deepStrictEqual findPermutationCycles(4, [4, 3, 2, 1]), [2, 2]\n  assert.deepStrictEqual findPermutationCycles(6, [1, 2, 3, 4, 5, 6]), [6, 1]\n  assert.deepStrictEqual findPermutationCycles(3, [3, 1, 2]), [1, 3]\n  console.log \"All tests passed!\"\n\ntestFindPermutationCycles()", "exec_outcome": "PASSED"}
{"code": "# Checks if the given string is a valid IPv6 address.\n# Uses a regular expression to validate the basic IPv6 format and falls back to\n# JavaScript's URL API for more comprehensive validation when needed.\nisValidIPv6 = (ip) ->\n  # Basic IPv6 pattern validation\n  ipv6Pattern = /^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$/i\n  return true if ipv6Pattern.test(ip)\n  \n  # Fallback validation using URL API (similar to ipaddress module in Python)\n  try\n    # Create a URL with the IPv6 address as hostname\n    # This will throw an error for invalid IPv6 addresses\n    new URL(\"http://[#{ip}]\")\n    return true\n  catch\n    return false", "test_cases": "", "test_case_results": "Input: 2001:0db8:85a3:0000:0000:8a2e:0370:7334\nIs valid IPv6: true\n---\nInput: 2001:db8:85a3:0:0:8a2e:370:7334\nIs valid IPv6: true\n---\nInput: 2001:db8:85a3::8a2e:370:7334\nIs valid IPv6: true\n---\nInput: ::1\nIs valid IPv6: true\n---\nInput: 1200:0000:AB00:1234:0000:2552:7777:1313\nIs valid IPv6: true\n---\nInput: 21DA:D3:0:2F3B:2AA:FF:FE28:9C5A\nIs valid IPv6: true\n---\nInput: FE80::1\nIs valid IPv6: true\n---\nInput: 1080:0:0:0:8:800:200C:417A\nIs valid IPv6: true\n---\nInput: ::\nIs valid IPv6: true\n---\nInput: 2001:db8:85a3:0:0:8a2e:370:7334:1234\nIs valid IPv6: false\n---\nInput: 2001:db8:85a3::8a2e:370:7334:1234\nIs valid IPv6: true\n---\nInput: 2001::25de::cade\nIs valid IPv6: false\n---\nInput: ::1111:2222:3333:4444:5555:6666:7777\nIs valid IPv6: true\n---\nInput: 2001:db8:85a3:8d3:1319:8a2e:370:7348\nIs valid IPv6: true\n---\nInput: 2001:db8:85a3:8d3:1319:8a2e:370::\nIs valid IPv6: true\n---\nInput: 1.2.3.4\nIs valid IPv6: false\n---\nInput: 2001:db8:85a3:8d3:1319:8a2e:370:7348:123\nIs valid IPv6: false\n---\nInput: 2001:0db8:85a3:0000:0000:8a2e:0370:7334:\nIs valid IPv6: false\n---\nInput: \nIs valid IPv6: false\n---\nInput: fe80::1%eth0\nIs valid IPv6: true\n---", "task_id": 18471, "assertions": "assert = require 'assert'\n\ntestIPv6Validation = ->\n  # Valid cases\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3::8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"::1\"), true\n  assert.strictEqual isValidIPv6(\"1200:0000:AB00:1234:0000:2552:7777:1313\"), true\n  assert.strictEqual isValidIPv6(\"21DA:D3:0:2F3B:2AA:FF:FE28:9C5A\"), true\n  assert.strictEqual isValidIPv6(\"FE80::1\"), true\n  assert.strictEqual isValidIPv6(\"1080:0:0:0:8:800:200C:417A\"), true\n  assert.strictEqual isValidIPv6(\"::\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370::\"), true\n  assert.strictEqual isValidIPv6(\"fe80::1%eth0\"), true\n\n  # Invalid cases\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334:1234\"), false\n  assert.strictEqual isValidIPv6(\"2001::25de::cade\"), false\n  assert.strictEqual isValidIPv6(\"1.2.3.4\"), false\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348:123\"), false\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334:\"), false\n  assert.strictEqual isValidIPv6(\"\"), false\n\n  console.log \"All tests passed!\"\n\ntestIPv6Validation()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nassert = require 'assert'\n\ntestIPv6Validation = ->\n  # Valid cases\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3::8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"::1\"), true\n  assert.strictEqual isValidIPv6(\"1200:0000:AB00:1234:0000:2552:7777:1313\"), true\n  assert.strictEqual isValidIPv6(\"21DA:D3:0:2F3B:2AA:FF:FE28:9C5A\"), true\n  assert.strictEqual isValidIPv6(\"FE80::1\"), true\n  assert.strictEqual isValidIPv6(\"1080:0:0:0:8:800:200C:417A\"), true\n  assert.strictEqual isValidIPv6(\"::\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370::\"), true\n  assert.strictEqual isValidIPv6(\"fe80::1%eth0\"), true\n\n  # Invalid cases\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334:1234\"), false\n  assert.strictEqual isValidIPv6(\"2001::25de::cade\"), false\n  assert.strictEqual isValidIPv6(\"1.2.3.4\"), false\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348:123\"), false\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334:\"), false\n  assert.strictEqual isValidIPv6(\"\"), false\n\n  console.log \"All tests passed!\"\n\ntestIPv6Validation()", "output": "isValidIPv6"}, "all_code": "# Checks if the given string is a valid IPv6 address.\n# Uses a regular expression to validate the basic IPv6 format and falls back to\n# JavaScript's URL API for more comprehensive validation when needed.\nisValidIPv6 = (ip) ->\n  # Basic IPv6 pattern validation\n  ipv6Pattern = /^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$/i\n  return true if ipv6Pattern.test(ip)\n  \n  # Fallback validation using URL API (similar to ipaddress module in Python)\n  try\n    # Create a URL with the IPv6 address as hostname\n    # This will throw an error for invalid IPv6 addresses\n    new URL(\"http://[#{ip}]\")\n    return true\n  catch\n    return false\nassert = require 'assert'\n\ntestIPv6Validation = ->\n  # Valid cases\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3::8a2e:370:7334\"), true\n  assert.strictEqual isValidIPv6(\"::1\"), true\n  assert.strictEqual isValidIPv6(\"1200:0000:AB00:1234:0000:2552:7777:1313\"), true\n  assert.strictEqual isValidIPv6(\"21DA:D3:0:2F3B:2AA:FF:FE28:9C5A\"), true\n  assert.strictEqual isValidIPv6(\"FE80::1\"), true\n  assert.strictEqual isValidIPv6(\"1080:0:0:0:8:800:200C:417A\"), true\n  assert.strictEqual isValidIPv6(\"::\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"), true\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370::\"), true\n  assert.strictEqual isValidIPv6(\"fe80::1%eth0\"), true\n\n  # Invalid cases\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:0:0:8a2e:370:7334:1234\"), false\n  assert.strictEqual isValidIPv6(\"2001::25de::cade\"), false\n  assert.strictEqual isValidIPv6(\"1.2.3.4\"), false\n  assert.strictEqual isValidIPv6(\"2001:db8:85a3:8d3:1319:8a2e:370:7348:123\"), false\n  assert.strictEqual isValidIPv6(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334:\"), false\n  assert.strictEqual isValidIPv6(\"\"), false\n\n  console.log \"All tests passed!\"\n\ntestIPv6Validation()", "exec_outcome": "RUNTIME_ERROR"}
