{"code": ";;; Function to calculate minimum knights needed on an N x M chessboard\n;;; The logic follows specific rules based on the dimensions:\n;;; - For N=1: knights equal to M\n;;; - For N=2: special cases for M=1,2 and pattern for larger M\n;;; - For N=3: special cases for M=1,2 and pattern for larger M\n(defun minimum-knights (n m)\n  (cond\n   ;; Case when N is 1\n   ((= n 1) m)\n   \n   ;; Case when N is 2\n   ((= n 2)\n    (cond\n     ((= m 1) 2)\n     ((= m 2) 4)\n     ((zerop (mod m 2)) m)\n     (t (1+ m))))\n   \n   ;; Case when N is 3\n   ((= n 3)\n    (cond\n     ((= m 1) 3)\n     ((= m 2) 4)\n     ((zerop (mod m 2)) m)\n     (t (1+ m))))\n   \n   ;; Default case (not handled in original code)\n   (t 0)))", "test_cases": "", "test_case_results": "", "task_id": 803, "assertions": "(require 'cl-lib)\n\n(defun test-minimum-knights ()\n  ;; Test cases from the original code\n  (cl-assert (= (minimum-knights 1 1) 1))\n  (cl-assert (= (minimum-knights 1 5) 5))\n  (cl-assert (= (minimum-knights 2 1) 2))\n  (cl-assert (= (minimum-knights 2 2) 4))\n  (cl-assert (= (minimum-knights 2 3) 4))\n  (cl-assert (= (minimum-knights 2 4) 4))\n  (cl-assert (= (minimum-knights 3 1) 3))\n  (cl-assert (= (minimum-knights 3 2) 4))\n  (cl-assert (= (minimum-knights 3 3) 4))\n  (cl-assert (= (minimum-knights 3 4) 4)))\n\n(test-minimum-knights)", "all_code": ";;; Function to calculate minimum knights needed on an N x M chessboard\n;;; The logic follows specific rules based on the dimensions:\n;;; - For N=1: knights equal to M\n;;; - For N=2: special cases for M=1,2 and pattern for larger M\n;;; - For N=3: special cases for M=1,2 and pattern for larger M\n(defun minimum-knights (n m)\n  (cond\n   ;; Case when N is 1\n   ((= n 1) m)\n   \n   ;; Case when N is 2\n   ((= n 2)\n    (cond\n     ((= m 1) 2)\n     ((= m 2) 4)\n     ((zerop (mod m 2)) m)\n     (t (1+ m))))\n   \n   ;; Case when N is 3\n   ((= n 3)\n    (cond\n     ((= m 1) 3)\n     ((= m 2) 4)\n     ((zerop (mod m 2)) m)\n     (t (1+ m))))\n   \n   ;; Default case (not handled in original code)\n   (t 0)))\n(require 'cl-lib)\n\n(defun test-minimum-knights ()\n  ;; Test cases from the original code\n  (cl-assert (= (minimum-knights 1 1) 1))\n  (cl-assert (= (minimum-knights 1 5) 5))\n  (cl-assert (= (minimum-knights 2 1) 2))\n  (cl-assert (= (minimum-knights 2 2) 4))\n  (cl-assert (= (minimum-knights 2 3) 4))\n  (cl-assert (= (minimum-knights 2 4) 4))\n  (cl-assert (= (minimum-knights 3 1) 3))\n  (cl-assert (= (minimum-knights 3 2) 4))\n  (cl-assert (= (minimum-knights 3 3) 4))\n  (cl-assert (= (minimum-knights 3 4) 4)))\n\n(test-minimum-knights)", "exec_outcome": "PASSED"}
{"code": ";;; This function calculates the minimum number of rounds needed to transport packages,\n;;; where each round can carry at most max-weight, and each round can carry at most two packages.\n;;; The algorithm uses a greedy approach by sorting the weights and pairing the heaviest\n;;; package with the lightest if their combined weight is within the limit.\n\n(defun min-rounds (weights max-weight)\n  \"Calculate the minimum number of rounds to transport all packages.\nWEIGHTS is a list of package weights.\nMAX-WEIGHT is the maximum weight that can be carried in a single round.\"\n  (let ((sorted-weights (sort (copy-sequence weights) '<))\n        (left 0)\n        (right (1- (length weights)))\n        (rounds 0))\n    (while (<= left right)\n      (when (<= (+ (nth left sorted-weights) (nth right sorted-weights)) max-weight)\n        (setq left (1+ left)))\n      (setq right (1- right))\n      (setq rounds (1+ rounds)))\n    rounds))", "test_cases": "", "test_case_results": "", "task_id": 27337, "assertions": "(require 'cl-lib)\n\n(defun test-min-rounds ()\n  \"Test function for min-rounds with various test cases.\"\n  (cl-assert (= (min-rounds '(3 2 2 1) 3) 3))\n  (cl-assert (= (min-rounds '(1 2 3 4 5) 5) 3))\n  (cl-assert (= (min-rounds '(1 1 1 1) 2) 2))\n  (cl-assert (= (min-rounds '(5) 10) 1)))\n\n(test-min-rounds)", "all_code": ";;; This function calculates the minimum number of rounds needed to transport packages,\n;;; where each round can carry at most max-weight, and each round can carry at most two packages.\n;;; The algorithm uses a greedy approach by sorting the weights and pairing the heaviest\n;;; package with the lightest if their combined weight is within the limit.\n\n(defun min-rounds (weights max-weight)\n  \"Calculate the minimum number of rounds to transport all packages.\nWEIGHTS is a list of package weights.\nMAX-WEIGHT is the maximum weight that can be carried in a single round.\"\n  (let ((sorted-weights (sort (copy-sequence weights) '<))\n        (left 0)\n        (right (1- (length weights)))\n        (rounds 0))\n    (while (<= left right)\n      (when (<= (+ (nth left sorted-weights) (nth right sorted-weights)) max-weight)\n        (setq left (1+ left)))\n      (setq right (1- right))\n      (setq rounds (1+ rounds)))\n    rounds))\n(require 'cl-lib)\n\n(defun test-min-rounds ()\n  \"Test function for min-rounds with various test cases.\"\n  (cl-assert (= (min-rounds '(3 2 2 1) 3) 3))\n  (cl-assert (= (min-rounds '(1 2 3 4 5) 5) 3))\n  (cl-assert (= (min-rounds '(1 1 1 1) 2) 2))\n  (cl-assert (= (min-rounds '(5) 10) 1)))\n\n(test-min-rounds)", "exec_outcome": "PASSED"}
{"code": ";; This Emacs Lisp code implements a solution to find the K-th smallest sum\n;; from pairs of elements from two sorted lists A and B. It uses binary search\n;; to efficiently determine the result.\n\n;; count-le counts the number of pairs (a, b) where a is from A, b is from B,\n;; and a + b <= mid. This is used in the binary search to find the K-th smallest sum.\n(defun count-le (A B mid)\n  (let ((cnt 0)\n        (j (1- (length B))))\n    (dolist (a A cnt)\n      (while (and (>= j 0) (> (+ a (nth j B)) mid))\n        (setq j (1- j)))\n      (setq cnt (+ cnt (1+ j))))))\n\n;; find-kth-smallest-sum finds the K-th smallest sum of pairs from sorted lists A and B.\n;; It uses binary search between the smallest and largest possible sums.\n(defun find-kth-smallest-sum (A B K)\n  (let* ((left (+ (car A) (car B)))\n         (right (+ (car (last A)) (car (last B)))))\n    (while (< left right)\n      (let* ((mid (/ (+ left right) 2))\n             (cnt (count-le A B mid)))\n        (if (>= cnt K)\n            (setq right mid)\n          (setq left (1+ mid)))))\n    left))", "test_cases": "", "test_case_results": "", "task_id": 27156, "assertions": "(require 'cl-lib)\n\n(defun test-find-kth-smallest-sum ()\n  (cl-assert (= (find-kth-smallest-sum '(1 2 3) '(4 5 6) 3) 6))\n  (cl-assert (= (find-kth-smallest-sum '(1 3 5) '(2 4 6) 5) 7))\n  (cl-assert (= (find-kth-smallest-sum '(1 1) '(1 1) 1) 2)))\n\n(test-find-kth-smallest-sum)", "all_code": ";; This Emacs Lisp code implements a solution to find the K-th smallest sum\n;; from pairs of elements from two sorted lists A and B. It uses binary search\n;; to efficiently determine the result.\n\n;; count-le counts the number of pairs (a, b) where a is from A, b is from B,\n;; and a + b <= mid. This is used in the binary search to find the K-th smallest sum.\n(defun count-le (A B mid)\n  (let ((cnt 0)\n        (j (1- (length B))))\n    (dolist (a A cnt)\n      (while (and (>= j 0) (> (+ a (nth j B)) mid))\n        (setq j (1- j)))\n      (setq cnt (+ cnt (1+ j))))))\n\n;; find-kth-smallest-sum finds the K-th smallest sum of pairs from sorted lists A and B.\n;; It uses binary search between the smallest and largest possible sums.\n(defun find-kth-smallest-sum (A B K)\n  (let* ((left (+ (car A) (car B)))\n         (right (+ (car (last A)) (car (last B)))))\n    (while (< left right)\n      (let* ((mid (/ (+ left right) 2))\n             (cnt (count-le A B mid)))\n        (if (>= cnt K)\n            (setq right mid)\n          (setq left (1+ mid)))))\n    left))\n(require 'cl-lib)\n\n(defun test-find-kth-smallest-sum ()\n  (cl-assert (= (find-kth-smallest-sum '(1 2 3) '(4 5 6) 3) 6))\n  (cl-assert (= (find-kth-smallest-sum '(1 3 5) '(2 4 6) 5) 7))\n  (cl-assert (= (find-kth-smallest-sum '(1 1) '(1 1) 1) 2)))\n\n(test-find-kth-smallest-sum)", "exec_outcome": "PASSED"}
{"code": ";;; Function to count the possible number of teams that can be formed\n;;; under the given constraints.\n;;;\n;;; Parameters:\n;;; - N: Total number of players\n;;; - K: Number of players per team\n;;; - D: Maximum allowed difference between the best and worst player in a team\n;;; - S: List of player skill levels\n;;;\n;;; Returns: The number of valid teams that can be formed\n\n(require 'cl-lib) ; For cl-subseq function\n\n(defun count-possible-teams (N K D S)\n  (let ((count 0))\n    (dotimes (i (- N K -1) count)\n      (let* ((start i)\n             (end (+ i K))\n             (team (cl-subseq S start end))\n             (max-skill (apply 'max team))\n             (min-skill (apply 'min team)))\n        (when (<= (- max-skill min-skill) D)\n          (setq count (1+ count)))))))", "test_cases": "", "test_case_results": "", "task_id": 15765, "assertions": "(require 'cl-lib)\n\n(defun test-count-possible-teams ()\n  ;; Test case 1: N=5, K=3, D=2, S=(1 2 3 4 5)\n  ;; Expected result: 3 (teams (1 2 3), (2 3 4), (3 4 5))\n  (cl-assert (= (count-possible-teams 5 3 2 '(1 2 3 4 5)) 3))\n  \n  ;; Test case 2: N=4, K=2, D=1, S=(4 3 2 1)\n  ;; Expected result: 3 (teams (4 3), (3 2), (2 1))\n  (cl-assert (= (count-possible-teams 4 2 1 '(4 3 2 1)) 3))\n  \n  ;; Test case 3: N=6, K=4, D=3, S=(10 7 5 8 2 6)\n  ;; Expected result: 1 (only team (7 5 8 6) meets the criteria)\n  (cl-assert (= (count-possible-teams 6 4 3 '(10 7 5 8 2 6)) 1)))\n\n(test-count-possible-teams)", "all_code": ";;; Function to count the possible number of teams that can be formed\n;;; under the given constraints.\n;;;\n;;; Parameters:\n;;; - N: Total number of players\n;;; - K: Number of players per team\n;;; - D: Maximum allowed difference between the best and worst player in a team\n;;; - S: List of player skill levels\n;;;\n;;; Returns: The number of valid teams that can be formed\n\n(require 'cl-lib) ; For cl-subseq function\n\n(defun count-possible-teams (N K D S)\n  (let ((count 0))\n    (dotimes (i (- N K -1) count)\n      (let* ((start i)\n             (end (+ i K))\n             (team (cl-subseq S start end))\n             (max-skill (apply 'max team))\n             (min-skill (apply 'min team)))\n        (when (<= (- max-skill min-skill) D)\n          (setq count (1+ count)))))))\n(require 'cl-lib)\n\n(defun test-count-possible-teams ()\n  ;; Test case 1: N=5, K=3, D=2, S=(1 2 3 4 5)\n  ;; Expected result: 3 (teams (1 2 3), (2 3 4), (3 4 5))\n  (cl-assert (= (count-possible-teams 5 3 2 '(1 2 3 4 5)) 3))\n  \n  ;; Test case 2: N=4, K=2, D=1, S=(4 3 2 1)\n  ;; Expected result: 3 (teams (4 3), (3 2), (2 1))\n  (cl-assert (= (count-possible-teams 4 2 1 '(4 3 2 1)) 3))\n  \n  ;; Test case 3: N=6, K=4, D=3, S=(10 7 5 8 2 6)\n  ;; Expected result: 1 (only team (7 5 8 6) meets the criteria)\n  (cl-assert (= (count-possible-teams 6 4 3 '(10 7 5 8 2 6)) 1)))\n\n(test-count-possible-teams)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; sum-with-previous calculates a new list where each element is the sum of the original\n;; element and the element immediately preceding it. If there is no preceding element,\n;; the original element is returned as is.\n(defun sum-with-previous (lst)\n  (if (null lst)\n      '()\n    (let ((result '()))\n      (dotimes (i (length lst) (nreverse result))\n        (let ((current (nth i lst))\n              (previous (if (> i 0) (nth (1- i) lst) 0)))\n          (setq result (cons (+ current previous) result)))))))", "test_cases": "", "test_case_results": "", "task_id": 11442, "assertions": "(defun test-sum-with-previous ()\n  (cl-assert (equal (sum-with-previous '(1 2 3 4)) '(1 3 5 7)))\n  (cl-assert (equal (sum-with-previous '(5 6 7 0)) '(5 11 13 7)))\n  (cl-assert (equal (sum-with-previous '(0 0 0 0)) '(0 0 0 0)))\n  (cl-assert (equal (sum-with-previous '()) '())))\n\n(test-sum-with-previous)", "all_code": ";; sum-with-previous calculates a new list where each element is the sum of the original\n;; element and the element immediately preceding it. If there is no preceding element,\n;; the original element is returned as is.\n(defun sum-with-previous (lst)\n  (if (null lst)\n      '()\n    (let ((result '()))\n      (dotimes (i (length lst) (nreverse result))\n        (let ((current (nth i lst))\n              (previous (if (> i 0) (nth (1- i) lst) 0)))\n          (setq result (cons (+ current previous) result)))))))\n(defun test-sum-with-previous ()\n  (cl-assert (equal (sum-with-previous '(1 2 3 4)) '(1 3 5 7)))\n  (cl-assert (equal (sum-with-previous '(5 6 7 0)) '(5 11 13 7)))\n  (cl-assert (equal (sum-with-previous '(0 0 0 0)) '(0 0 0 0)))\n  (cl-assert (equal (sum-with-previous '()) '())))\n\n(test-sum-with-previous)", "exec_outcome": "PASSED"}
{"code": ";;; This function calculates the maximum possible sum of any subsequence of length exactly m from the array.\n;;; The array is first sorted in descending order, then the first m elements are taken and summed.\n(defun max-subsequence-sum (arr m)\n  \"Returns the maximum possible sum of any subsequence of length exactly m from the array ARR.\"\n  (let ((sorted-arr (sort (copy-sequence arr) (lambda (a b) (> a b)))))\n    (apply '+ (seq-take sorted-arr m))))", "test_cases": "", "test_case_results": "", "task_id": 4386, "assertions": "(require 'cl-lib)\n\n(defun test-max-subsequence-sum ()\n  (cl-assert (= (max-subsequence-sum '(1 2 3 4 5) 3) 12))\n  (cl-assert (= (max-subsequence-sum '(10 20 30 40 50) 2) 90))\n  (cl-assert (= (max-subsequence-sum '(5 3 1 7 9) 4) 24))\n  (cl-assert (= (max-subsequence-sum '(1 1 1 1 1) 5) 5)))\n\n(test-max-subsequence-sum)", "all_code": ";;; This function calculates the maximum possible sum of any subsequence of length exactly m from the array.\n;;; The array is first sorted in descending order, then the first m elements are taken and summed.\n(defun max-subsequence-sum (arr m)\n  \"Returns the maximum possible sum of any subsequence of length exactly m from the array ARR.\"\n  (let ((sorted-arr (sort (copy-sequence arr) (lambda (a b) (> a b)))))\n    (apply '+ (seq-take sorted-arr m))))\n(require 'cl-lib)\n\n(defun test-max-subsequence-sum ()\n  (cl-assert (= (max-subsequence-sum '(1 2 3 4 5) 3) 12))\n  (cl-assert (= (max-subsequence-sum '(10 20 30 40 50) 2) 90))\n  (cl-assert (= (max-subsequence-sum '(5 3 1 7 9) 4) 24))\n  (cl-assert (= (max-subsequence-sum '(1 1 1 1 1) 5) 5)))\n\n(test-max-subsequence-sum)", "exec_outcome": "PASSED"}
{"code": ";; This program reads a grid of numbers and then answers queries about positions\n;; of specific values in that grid. If a value is found, its coordinates are returned;\n;; otherwise, (-1 -1) is returned.\n\n;; build-position-map creates a hash table mapping values to their (row, col) positions\n;; in the grid.\n(defun build-position-map (grid)\n  (let ((pos (make-hash-table :test 'equal)))\n    (dotimes (i (length grid) pos)\n      (let ((row (nth i grid)))\n        (dotimes (j (length row))\n          (let ((v (nth j row)))\n            (unless (gethash v pos)\n              (puthash v (cons i j) pos))))))))\n\n;; answer-queries processes a list of queries against a position map,\n;; returning the coordinates for each query value.\n(defun answer-queries (pos queries)\n  (mapcar (lambda (v)\n            (let ((coord (gethash v pos)))\n              (if coord coord '(-1 . -1))))\n          queries))", "test_cases": "", "test_case_results": "", "task_id": 905, "assertions": "(require 'cl-lib)\n\n(defun test-grid-query ()\n  (let* ((test-grid '((1 2 3)\n                      (4 5 6)\n                      (7 8 9)))\n         (pos-map (build-position-map test-grid)))\n    (cl-assert (equal (answer-queries pos-map '(1)) '((0 . 0))))\n    (cl-assert (equal (answer-queries pos-map '(5)) '((1 . 1))))\n    (cl-assert (equal (answer-queries pos-map '(9)) '((2 . 2))))\n    (cl-assert (equal (answer-queries pos-map '(10)) '((-1 . -1))))\n    (cl-assert (equal (answer-queries pos-map '(2)) '((0 . 1))))\n    (cl-assert (equal (answer-queries pos-map '(1 5 9 10 2)) \n                      '((0 . 0) (1 . 1) (2 . 2) (-1 . -1) (0 . 1))))))\n\n(test-grid-query)", "all_code": ";; This program reads a grid of numbers and then answers queries about positions\n;; of specific values in that grid. If a value is found, its coordinates are returned;\n;; otherwise, (-1 -1) is returned.\n\n;; build-position-map creates a hash table mapping values to their (row, col) positions\n;; in the grid.\n(defun build-position-map (grid)\n  (let ((pos (make-hash-table :test 'equal)))\n    (dotimes (i (length grid) pos)\n      (let ((row (nth i grid)))\n        (dotimes (j (length row))\n          (let ((v (nth j row)))\n            (unless (gethash v pos)\n              (puthash v (cons i j) pos))))))))\n\n;; answer-queries processes a list of queries against a position map,\n;; returning the coordinates for each query value.\n(defun answer-queries (pos queries)\n  (mapcar (lambda (v)\n            (let ((coord (gethash v pos)))\n              (if coord coord '(-1 . -1))))\n          queries))\n(require 'cl-lib)\n\n(defun test-grid-query ()\n  (let* ((test-grid '((1 2 3)\n                      (4 5 6)\n                      (7 8 9)))\n         (pos-map (build-position-map test-grid)))\n    (cl-assert (equal (answer-queries pos-map '(1)) '((0 . 0))))\n    (cl-assert (equal (answer-queries pos-map '(5)) '((1 . 1))))\n    (cl-assert (equal (answer-queries pos-map '(9)) '((2 . 2))))\n    (cl-assert (equal (answer-queries pos-map '(10)) '((-1 . -1))))\n    (cl-assert (equal (answer-queries pos-map '(2)) '((0 . 1))))\n    (cl-assert (equal (answer-queries pos-map '(1 5 9 10 2)) \n                      '((0 . 0) (1 . 1) (2 . 2) (-1 . -1) (0 . 1))))))\n\n(test-grid-query)", "exec_outcome": "PASSED"}
{"code": ";;; Returns a list of the first N even natural numbers.\n;;; Raises an error if n is less than 1.\n(defun first-n-even-numbers (n)\n  \"Return a list of the first N even natural numbers.\nIf N is less than 1, signal an error.\"\n  (if (< n 1)\n      (error \"The input must be greater than or equal to 1\")\n    (let ((result '()))\n      (dotimes (i n result)\n        (setq result (cons (* 2 (1+ i)) result)))\n      (reverse result))))", "test_cases": "", "test_case_results": "", "task_id": 8950, "assertions": "(require 'cl-lib)\n\n(defun test-first-n-even-numbers ()\n  ;; Test normal cases\n  (cl-assert (equal (first-n-even-numbers 1) '(2)))\n  (cl-assert (equal (first-n-even-numbers 5) '(2 4 6 8 10)))\n  (cl-assert (equal (first-n-even-numbers 10) '(2 4 6 8 10 12 14 16 18 20)))\n  \n  ;; Test error case\n  (let ((error-occurred nil))\n    (condition-case err\n        (first-n-even-numbers 0)\n      (error (setq error-occurred t)))\n    (cl-assert error-occurred))\n  \n  (let ((error-occurred nil))\n    (condition-case err\n        (first-n-even-numbers -1)\n      (error (setq error-occurred t)))\n    (cl-assert error-occurred)))\n\n(test-first-n-even-numbers)", "all_code": ";;; Returns a list of the first N even natural numbers.\n;;; Raises an error if n is less than 1.\n(defun first-n-even-numbers (n)\n  \"Return a list of the first N even natural numbers.\nIf N is less than 1, signal an error.\"\n  (if (< n 1)\n      (error \"The input must be greater than or equal to 1\")\n    (let ((result '()))\n      (dotimes (i n result)\n        (setq result (cons (* 2 (1+ i)) result)))\n      (reverse result))))\n(require 'cl-lib)\n\n(defun test-first-n-even-numbers ()\n  ;; Test normal cases\n  (cl-assert (equal (first-n-even-numbers 1) '(2)))\n  (cl-assert (equal (first-n-even-numbers 5) '(2 4 6 8 10)))\n  (cl-assert (equal (first-n-even-numbers 10) '(2 4 6 8 10 12 14 16 18 20)))\n  \n  ;; Test error case\n  (let ((error-occurred nil))\n    (condition-case err\n        (first-n-even-numbers 0)\n      (error (setq error-occurred t)))\n    (cl-assert error-occurred))\n  \n  (let ((error-occurred nil))\n    (condition-case err\n        (first-n-even-numbers -1)\n      (error (setq error-occurred t)))\n    (cl-assert error-occurred)))\n\n(test-first-n-even-numbers)", "exec_outcome": "PASSED"}
{"code": ";; This Emacs Lisp code calculates the \"joy\" value based on two lists of integers, a and b.\n;; For each pair of elements (ai, bi), it finds the optimal x that maximizes x*(bi - x)\n;; within the range [max(1, bi - ai), min(ai, bi - 1)].\n\n;; calculate-joy computes the joy value for given lists a and b.\n;; The joy value is calculated by finding the optimal x for each pair (ai, bi)\n;; that maximizes x*(bi - x) within a specific range.\n(defun calculate-joy (a b)\n  (let ((joy 0))\n    (dotimes (i (length a) joy)\n      (let* ((ai (nth i a))\n             (bi (nth i b))\n             (low (max 1 (- bi ai)))\n             (high (min ai (1- bi))))\n        (if (> low high)\n            (setq joy (1- joy))\n          (let* ((x (/ bi 2))\n                 (candidates (list x (1+ x) (1- x)))\n                 (max-val 0))\n            (dolist (cand candidates)\n              (when (and (>= cand low) (<= cand high))\n                (let ((current (* cand (- bi cand))))\n                  (when (> current max-val)\n                    (setq max-val current)))))\n            (setq joy (+ joy max-val))))))))", "test_cases": "", "test_case_results": "", "task_id": 7625, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-joy ()\n  (cl-assert (= (calculate-joy '(1 2 3 4) '(5 6 7 8)) 10))\n  (cl-assert (= (calculate-joy '(5 6 7 0) '(5 6 7 0)) -1))\n  (cl-assert (= (calculate-joy '(0 0 0 0) '(0 0 0 0)) -4)))\n\n(test-calculate-joy)", "all_code": ";; This Emacs Lisp code calculates the \"joy\" value based on two lists of integers, a and b.\n;; For each pair of elements (ai, bi), it finds the optimal x that maximizes x*(bi - x)\n;; within the range [max(1, bi - ai), min(ai, bi - 1)].\n\n;; calculate-joy computes the joy value for given lists a and b.\n;; The joy value is calculated by finding the optimal x for each pair (ai, bi)\n;; that maximizes x*(bi - x) within a specific range.\n(defun calculate-joy (a b)\n  (let ((joy 0))\n    (dotimes (i (length a) joy)\n      (let* ((ai (nth i a))\n             (bi (nth i b))\n             (low (max 1 (- bi ai)))\n             (high (min ai (1- bi))))\n        (if (> low high)\n            (setq joy (1- joy))\n          (let* ((x (/ bi 2))\n                 (candidates (list x (1+ x) (1- x)))\n                 (max-val 0))\n            (dolist (cand candidates)\n              (when (and (>= cand low) (<= cand high))\n                (let ((current (* cand (- bi cand))))\n                  (when (> current max-val)\n                    (setq max-val current)))))\n            (setq joy (+ joy max-val))))))))\n(require 'cl-lib)\n\n(defun test-calculate-joy ()\n  (cl-assert (= (calculate-joy '(1 2 3 4) '(5 6 7 8)) 10))\n  (cl-assert (= (calculate-joy '(5 6 7 0) '(5 6 7 0)) -1))\n  (cl-assert (= (calculate-joy '(0 0 0 0) '(0 0 0 0)) -4)))\n\n(test-calculate-joy)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Function to calculate the minimum number of days needed to complete all tasks.\n;;; The function takes a list of tasks (each representing hours needed) and the number of workers available.\n;;; Tasks are sorted in descending order to distribute the heaviest tasks first.\n;;; Each day, each worker takes one task if available, and the process repeats until all tasks are completed.\n\n(defun minimum-days-to-complete-tasks (tasks d)\n  \"Calculate the minimum number of days needed to complete all tasks.\nTASKS is a list of integers representing hours needed for each task.\nD is the number of workers available.\nReturns the minimum number of days needed.\"\n  (if (null tasks)\n      0\n    (let ((sorted-tasks (sort (copy-sequence tasks) '>))\n          (days 0))\n      (while sorted-tasks\n        (setq days (1+ days))\n        (dotimes (_ d)\n          (when sorted-tasks\n            (setq sorted-tasks (cdr sorted-tasks)))))\n      days)))", "test_cases": "", "test_case_results": "", "task_id": 19756, "assertions": "(require 'cl-lib)\n\n(defun test-minimum-days-to-complete-tasks ()\n  \"Test cases for minimum-days-to-complete-tasks function.\"\n  (cl-assert (= (minimum-days-to-complete-tasks '(1 2 3 4) 2) 2))\n  (cl-assert (= (minimum-days-to-complete-tasks '(5 3 1) 1) 3))\n  (cl-assert (= (minimum-days-to-complete-tasks '(10 20 30 40 50) 3) 2))\n  (cl-assert (= (minimum-days-to-complete-tasks nil 4) 0))\n  (cl-assert (= (minimum-days-to-complete-tasks '(7) 2) 1)))\n\n(test-minimum-days-to-complete-tasks)", "all_code": ";;; Function to calculate the minimum number of days needed to complete all tasks.\n;;; The function takes a list of tasks (each representing hours needed) and the number of workers available.\n;;; Tasks are sorted in descending order to distribute the heaviest tasks first.\n;;; Each day, each worker takes one task if available, and the process repeats until all tasks are completed.\n\n(defun minimum-days-to-complete-tasks (tasks d)\n  \"Calculate the minimum number of days needed to complete all tasks.\nTASKS is a list of integers representing hours needed for each task.\nD is the number of workers available.\nReturns the minimum number of days needed.\"\n  (if (null tasks)\n      0\n    (let ((sorted-tasks (sort (copy-sequence tasks) '>))\n          (days 0))\n      (while sorted-tasks\n        (setq days (1+ days))\n        (dotimes (_ d)\n          (when sorted-tasks\n            (setq sorted-tasks (cdr sorted-tasks)))))\n      days)))\n(require 'cl-lib)\n\n(defun test-minimum-days-to-complete-tasks ()\n  \"Test cases for minimum-days-to-complete-tasks function.\"\n  (cl-assert (= (minimum-days-to-complete-tasks '(1 2 3 4) 2) 2))\n  (cl-assert (= (minimum-days-to-complete-tasks '(5 3 1) 1) 3))\n  (cl-assert (= (minimum-days-to-complete-tasks '(10 20 30 40 50) 3) 2))\n  (cl-assert (= (minimum-days-to-complete-tasks nil 4) 0))\n  (cl-assert (= (minimum-days-to-complete-tasks '(7) 2) 1)))\n\n(test-minimum-days-to-complete-tasks)", "exec_outcome": "PASSED"}
{"code": ";;; This function calculates the maximum \"score\" of nested brackets in a string.\n;;; The score is calculated by summing the nesting levels when encountering digits.\n;;; Different bracket types have different weights:\n;;;   '(' = 1, '{' = 2, '[' = 3\n;;; Closing brackets simply pop the current level from the stack.\n\n(defun calculate-max-bracket-score (input-string)\n  \"Calculate the maximum bracket score for INPUT-STRING.\nThe score is the sum of nesting levels when digits are encountered.\"\n  (let ((stack '())\n        (max-score 0))\n    (dolist (char (string-to-list input-string))\n      (cond\n       ((eq char ?\\( ) (push 1 stack))\n       ((eq char ?\\{ ) (push 2 stack))\n       ((eq char ?\\[ ) (push 3 stack))\n       ((eq char ?\\) ) (pop stack))\n       ((eq char ?\\} ) (pop stack))\n       ((eq char ?\\] ) (pop stack))\n       ((<= ?0 char ?9)\n        (let ((current-score (apply '+ stack)))\n          (when (> current-score max-score)\n            (setq max-score current-score))))))\n    max-score))", "test_cases": "", "test_case_results": "", "task_id": 25766, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-max-bracket-score ()\n  (cl-assert (= (calculate-max-bracket-score \"(1){2}[3]\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"a1(b2)c3\") 1))\n  (cl-assert (= (calculate-max-bracket-score \"(1[2{3}4]5)\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"123\") 0))\n  (cl-assert (= (calculate-max-bracket-score \"([{1}])\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"(a{b[c]d}e)\") 0))\n  (cl-assert (= (calculate-max-bracket-score \"(9){8}[7]\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"((1))\") 2)))\n\n(test-calculate-max-bracket-score)", "all_code": ";;; This function calculates the maximum \"score\" of nested brackets in a string.\n;;; The score is calculated by summing the nesting levels when encountering digits.\n;;; Different bracket types have different weights:\n;;;   '(' = 1, '{' = 2, '[' = 3\n;;; Closing brackets simply pop the current level from the stack.\n\n(defun calculate-max-bracket-score (input-string)\n  \"Calculate the maximum bracket score for INPUT-STRING.\nThe score is the sum of nesting levels when digits are encountered.\"\n  (let ((stack '())\n        (max-score 0))\n    (dolist (char (string-to-list input-string))\n      (cond\n       ((eq char ?\\( ) (push 1 stack))\n       ((eq char ?\\{ ) (push 2 stack))\n       ((eq char ?\\[ ) (push 3 stack))\n       ((eq char ?\\) ) (pop stack))\n       ((eq char ?\\} ) (pop stack))\n       ((eq char ?\\] ) (pop stack))\n       ((<= ?0 char ?9)\n        (let ((current-score (apply '+ stack)))\n          (when (> current-score max-score)\n            (setq max-score current-score))))))\n    max-score))\n(require 'cl-lib)\n\n(defun test-calculate-max-bracket-score ()\n  (cl-assert (= (calculate-max-bracket-score \"(1){2}[3]\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"a1(b2)c3\") 1))\n  (cl-assert (= (calculate-max-bracket-score \"(1[2{3}4]5)\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"123\") 0))\n  (cl-assert (= (calculate-max-bracket-score \"([{1}])\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"(a{b[c]d}e)\") 0))\n  (cl-assert (= (calculate-max-bracket-score \"(9){8}[7]\") 6))\n  (cl-assert (= (calculate-max-bracket-score \"((1))\") 2)))\n\n(test-calculate-max-bracket-score)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This code implements a grid flipping problem where we determine if we can\n;;; transform a grid of 'o's and '.'s to all 'o's with at most K flips.\n\n;;; Function to determine if the grid can be transformed with given flips\n(defun can-transform-grid (grid k)\n  \"Determine if GRID can be transformed to all 'o's with at most K flips.\nGRID is a list of strings representing rows, K is the maximum allowed flips.\"\n  (let* ((n (length grid))\n         (flips-needed 0))\n    (if (= n 1)\n        ;; Special case for 1x1 grid\n        (setq flips-needed (if (eq (aref (car grid) 0) ?o) 0 1))\n      ;; General case for nxn grid\n      (let ((a00 (if (eq (aref (car grid) 0) ?o) 1 0)))\n        (dotimes (i n)\n          (dotimes (j n)\n            (let* ((aij (if (eq (aref (nth i grid) j) ?o) 1 0))\n                   (a0j (if (eq (aref (car grid) j) ?o) 1 0))\n                   (ai0 (if (eq (aref (nth i grid) 0) ?o) 1 0))\n                   (bij (logxor aij a0j ai0 a00)))\n              (setq flips-needed (+ flips-needed bij)))))))\n    ;; Return whether flips needed is <= k\n    (<= flips-needed k)))", "test_cases": "", "test_case_results": "", "task_id": 10511, "assertions": "(require 'cl-lib)\n\n(defun test-can-transform-grid ()\n  \"Test the can-transform-grid function with various inputs.\"\n  (cl-assert (can-transform-grid '(\"o\") 0))\n  (cl-assert (can-transform-grid '(\".\") 1))\n  (cl-assert (not (can-transform-grid '(\".\") 0)))\n  (cl-assert (can-transform-grid '(\"oo\" \"oo\") 0))\n  (cl-assert (can-transform-grid '(\"o.\" \".o\") 2))\n  (cl-assert (not (can-transform-grid '(\"o.\" \".o\") 1)))\n  (cl-assert (can-transform-grid '(\"ooo\" \"ooo\" \"ooo\") 0))\n  (cl-assert (can-transform-grid '(\"o.o\" \"o.o\" \"ooo\") 2))\n  (cl-assert (not (can-transform-grid '(\"...\" \"...\" \"...\") 4))))\n\n(test-can-transform-grid)", "all_code": ";;; This code implements a grid flipping problem where we determine if we can\n;;; transform a grid of 'o's and '.'s to all 'o's with at most K flips.\n\n;;; Function to determine if the grid can be transformed with given flips\n(defun can-transform-grid (grid k)\n  \"Determine if GRID can be transformed to all 'o's with at most K flips.\nGRID is a list of strings representing rows, K is the maximum allowed flips.\"\n  (let* ((n (length grid))\n         (flips-needed 0))\n    (if (= n 1)\n        ;; Special case for 1x1 grid\n        (setq flips-needed (if (eq (aref (car grid) 0) ?o) 0 1))\n      ;; General case for nxn grid\n      (let ((a00 (if (eq (aref (car grid) 0) ?o) 1 0)))\n        (dotimes (i n)\n          (dotimes (j n)\n            (let* ((aij (if (eq (aref (nth i grid) j) ?o) 1 0))\n                   (a0j (if (eq (aref (car grid) j) ?o) 1 0))\n                   (ai0 (if (eq (aref (nth i grid) 0) ?o) 1 0))\n                   (bij (logxor aij a0j ai0 a00)))\n              (setq flips-needed (+ flips-needed bij)))))))\n    ;; Return whether flips needed is <= k\n    (<= flips-needed k)))\n(require 'cl-lib)\n\n(defun test-can-transform-grid ()\n  \"Test the can-transform-grid function with various inputs.\"\n  (cl-assert (can-transform-grid '(\"o\") 0))\n  (cl-assert (can-transform-grid '(\".\") 1))\n  (cl-assert (not (can-transform-grid '(\".\") 0)))\n  (cl-assert (can-transform-grid '(\"oo\" \"oo\") 0))\n  (cl-assert (can-transform-grid '(\"o.\" \".o\") 2))\n  (cl-assert (not (can-transform-grid '(\"o.\" \".o\") 1)))\n  (cl-assert (can-transform-grid '(\"ooo\" \"ooo\" \"ooo\") 0))\n  (cl-assert (can-transform-grid '(\"o.o\" \"o.o\" \"ooo\") 2))\n  (cl-assert (not (can-transform-grid '(\"...\" \"...\" \"...\") 4))))\n\n(test-can-transform-grid)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function calculates the final capital after investing in bonds over several years.\n;;; The investment strategy involves purchasing bonds that maximize the annual interest.\n\n(defun maximize-interest (initial-capital years bonds)\n  \"Calculate the final capital after investing in bonds over a number of years.\nINITIAL-CAPITAL is the starting amount of money.\nYEARS is the number of years to invest.\nBONDS is a list of (value interest) pairs where value is the bond's price and interest is the annual return.\"\n  (let ((current-capital initial-capital))\n    (dotimes (_ years current-capital)\n      (let* ((units (/ current-capital 1000))\n             (max-interest (make-vector (1+ units) 0)))\n        ;; Dynamic programming to find the maximum interest for each possible investment\n        (dotimes (i (1+ units))\n          (dolist (bond bonds)\n            (let* ((bond-value (/ (car bond) 1000))\n                   (bond-interest (cadr bond)))\n              (when (<= bond-value i)\n                (let ((potential-interest (+ (aref max-interest (- i bond-value)) bond-interest)))\n                  (when (> potential-interest (aref max-interest i))\n                    (aset max-interest i potential-interest)))))))\n        (setq current-capital (+ current-capital (aref max-interest units)))))))", "test_cases": "", "test_case_results": "", "task_id": 17581, "assertions": "(require 'cl-lib)\n\n(defun test-maximize-interest ()\n  ;; Test case 1: Initial capital: 10000, Years: 2, Bonds: (4000 400) and (3000 250)\n  (cl-assert (= (maximize-interest 10000 2 '((4000 400) (3000 250))) 10800))\n  \n  ;; Test case 2: Initial capital: 5000, Years: 3, Bonds: (2000 150) and (1000 100)\n  (cl-assert (= (maximize-interest 5000 3 '((2000 150) (1000 100))) 5450))\n  \n  ;; Test case 3: Initial capital: 20000, Years: 1, Bonds: (5000 600) and (3000 300)\n  (cl-assert (= (maximize-interest 20000 1 '((5000 600) (3000 300))) 20600)))\n\n(test-maximize-interest)", "all_code": ";;; This function calculates the final capital after investing in bonds over several years.\n;;; The investment strategy involves purchasing bonds that maximize the annual interest.\n\n(defun maximize-interest (initial-capital years bonds)\n  \"Calculate the final capital after investing in bonds over a number of years.\nINITIAL-CAPITAL is the starting amount of money.\nYEARS is the number of years to invest.\nBONDS is a list of (value interest) pairs where value is the bond's price and interest is the annual return.\"\n  (let ((current-capital initial-capital))\n    (dotimes (_ years current-capital)\n      (let* ((units (/ current-capital 1000))\n             (max-interest (make-vector (1+ units) 0)))\n        ;; Dynamic programming to find the maximum interest for each possible investment\n        (dotimes (i (1+ units))\n          (dolist (bond bonds)\n            (let* ((bond-value (/ (car bond) 1000))\n                   (bond-interest (cadr bond)))\n              (when (<= bond-value i)\n                (let ((potential-interest (+ (aref max-interest (- i bond-value)) bond-interest)))\n                  (when (> potential-interest (aref max-interest i))\n                    (aset max-interest i potential-interest)))))))\n        (setq current-capital (+ current-capital (aref max-interest units)))))))\n(require 'cl-lib)\n\n(defun test-maximize-interest ()\n  ;; Test case 1: Initial capital: 10000, Years: 2, Bonds: (4000 400) and (3000 250)\n  (cl-assert (= (maximize-interest 10000 2 '((4000 400) (3000 250))) 10800))\n  \n  ;; Test case 2: Initial capital: 5000, Years: 3, Bonds: (2000 150) and (1000 100)\n  (cl-assert (= (maximize-interest 5000 3 '((2000 150) (1000 100))) 5450))\n  \n  ;; Test case 3: Initial capital: 20000, Years: 1, Bonds: (5000 600) and (3000 300)\n  (cl-assert (= (maximize-interest 20000 1 '((5000 600) (3000 300))) 20600)))\n\n(test-maximize-interest)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This Emacs Lisp code implements a game winner determination logic based on given parameters n and k.\n;;; The function `determine-winner` checks if n modulo (k + 1) is non-zero to decide the winner.\n;;; The function `card-game-outcomes` processes multiple test cases and returns the winners for each case.\n\n;;; determine-winner checks the condition n % (k + 1) != 0 to decide the winner.\n;;; If the condition is true, Ali wins; otherwise, Bashir wins.\n(defun determine-winner (n k)\n  \"Determine the winner of the game given n and k.\nAli wins if n modulo (k + 1) is non-zero, otherwise Bashir wins.\"\n  (if (not (zerop (mod n (1+ k))))\n      \"Ali\"\n    \"Bashir\"))\n\n;;; card-game-outcomes processes a list of test cases and returns a list of winners.\n;;; Each test case is a cons cell (n . k).\n(defun card-game-outcomes (test-cases)\n  \"Compute the outcomes for multiple test cases.\nEach test case is a cons cell (n . k).\"\n  (mapcar (lambda (test-case)\n            (determine-winner (car test-case) (cdr test-case)))\n          test-cases))", "test_cases": "", "test_case_results": "", "task_id": 6720, "assertions": "(require 'cl-lib)\n\n(defun test-card-game ()\n  \"Test function for card game winner determination.\"\n  (let ((test-cases '((5 . 1)    ; Ali wins (5 % 2 = 1 != 0)\n                      (6 . 2)    ; Bashir wins (6 % 3 = 0)\n                      (10 . 3)   ; Ali wins (10 % 4 = 2 != 0)\n                      (12 . 3)))) ; Bashir wins (12 % 4 = 0)\n    (cl-assert (equal (card-game-outcomes test-cases)\n                      '(\"Ali\" \"Bashir\" \"Ali\" \"Bashir\")))))\n\n(test-card-game)", "all_code": ";;; This Emacs Lisp code implements a game winner determination logic based on given parameters n and k.\n;;; The function `determine-winner` checks if n modulo (k + 1) is non-zero to decide the winner.\n;;; The function `card-game-outcomes` processes multiple test cases and returns the winners for each case.\n\n;;; determine-winner checks the condition n % (k + 1) != 0 to decide the winner.\n;;; If the condition is true, Ali wins; otherwise, Bashir wins.\n(defun determine-winner (n k)\n  \"Determine the winner of the game given n and k.\nAli wins if n modulo (k + 1) is non-zero, otherwise Bashir wins.\"\n  (if (not (zerop (mod n (1+ k))))\n      \"Ali\"\n    \"Bashir\"))\n\n;;; card-game-outcomes processes a list of test cases and returns a list of winners.\n;;; Each test case is a cons cell (n . k).\n(defun card-game-outcomes (test-cases)\n  \"Compute the outcomes for multiple test cases.\nEach test case is a cons cell (n . k).\"\n  (mapcar (lambda (test-case)\n            (determine-winner (car test-case) (cdr test-case)))\n          test-cases))\n(require 'cl-lib)\n\n(defun test-card-game ()\n  \"Test function for card game winner determination.\"\n  (let ((test-cases '((5 . 1)    ; Ali wins (5 % 2 = 1 != 0)\n                      (6 . 2)    ; Bashir wins (6 % 3 = 0)\n                      (10 . 3)   ; Ali wins (10 % 4 = 2 != 0)\n                      (12 . 3)))) ; Bashir wins (12 % 4 = 0)\n    (cl-assert (equal (card-game-outcomes test-cases)\n                      '(\"Ali\" \"Bashir\" \"Ali\" \"Bashir\")))))\n\n(test-card-game)", "exec_outcome": "PASSED"}
{"code": ";;; Function to find the lexicographically smallest string u such that\n;;; u + v = s and u is lexicographically smaller than v.\n;;; If no such u is found, returns the first character of s as a fallback.\n\n(defun lexicographically-smallest-u (n s)\n  \"Returns the lexicographically smallest possible string u such that\nu + v = s and u is lexicographically smaller than v.\nN is the length of the string S.\"\n  ;; Loop through the string and check pairs (u, v)\n  (catch 'found\n    (dotimes (i (1- n) (substring s 0 1)) ; Fallback: return first character\n      (let ((u (substring s 0 (1+ i)))\n            (v (substring s (1+ i))))\n        (when (string< u v)\n          (throw 'found u))))))", "test_cases": "", "test_case_results": "", "task_id": 23338, "assertions": "(require 'cl-lib)\n\n(defun test-lexicographically-smallest-u ()\n  (cl-assert (string= (lexicographically-smallest-u 4 \"abac\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 4 \"aaaa\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 5 \"abcde\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 3 \"zxy\") \"z\")))\n\n(test-lexicographically-smallest-u)", "all_code": ";;; Function to find the lexicographically smallest string u such that\n;;; u + v = s and u is lexicographically smaller than v.\n;;; If no such u is found, returns the first character of s as a fallback.\n\n(defun lexicographically-smallest-u (n s)\n  \"Returns the lexicographically smallest possible string u such that\nu + v = s and u is lexicographically smaller than v.\nN is the length of the string S.\"\n  ;; Loop through the string and check pairs (u, v)\n  (catch 'found\n    (dotimes (i (1- n) (substring s 0 1)) ; Fallback: return first character\n      (let ((u (substring s 0 (1+ i)))\n            (v (substring s (1+ i))))\n        (when (string< u v)\n          (throw 'found u))))))\n(require 'cl-lib)\n\n(defun test-lexicographically-smallest-u ()\n  (cl-assert (string= (lexicographically-smallest-u 4 \"abac\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 4 \"aaaa\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 5 \"abcde\") \"a\"))\n  (cl-assert (string= (lexicographically-smallest-u 3 \"zxy\") \"z\")))\n\n(test-lexicographically-smallest-u)", "exec_outcome": "PASSED"}
{"code": ";;; Solution for the clothes selection problem using dynamic programming\n\n;;; Constants and helper functions\n(defconst *inf* most-negative-fixnum \"Representation of negative infinity\")\n\n;;; Main function to calculate maximum fashion difference\n(defun max-fashion-difference (days num-clothes temperatures clothes)\n  \"Calculate the maximum cumulative fashion difference over DAYS days.\nNUM-CLOTHES is the total number of clothing options.\nTEMPERATURES is a list of daily temperatures.\nCLOTHES is a list of (MIN-TEMP MAX-TEMP FASHION-VALUE) tuples.\"\n  ;; Preprocess usable clothes for each day\n  (let ((usable-clothes (make-vector days nil)))\n    (dotimes (i days)\n      (let ((current-temp (nth i temperatures)))\n        (dotimes (j num-clothes)\n          (let* ((clothing (nth j clothes))\n                 (min-temp (nth 0 clothing))\n                 (max-temp (nth 1 clothing)))\n            (when (and (>= current-temp min-temp)\n                       (<= current-temp max-temp))\n              (push j (aref usable-clothes i)))))))\n    \n    ;; Initialize DP table\n    (let ((prev-dp (make-vector num-clothes *inf*)))\n      ;; First day initialization\n      (dolist (j (aref usable-clothes 0))\n        (aset prev-dp j 0))\n      \n      ;; Process subsequent days\n      (dotimes (i (1- days))\n        (let ((curr-dp (make-vector num-clothes *inf*))\n              (current-day (+ i 1)))\n          (dolist (j (aref usable-clothes current-day))\n            (let ((max-val -1))\n              (dolist (k (aref usable-clothes i))\n                (when (/= (aref prev-dp k) *inf*)\n                  (let* ((current-diff (abs (- (nth 2 (nth j clothes))\n                                               (nth 2 (nth k clothes)))))\n                         (candidate (+ (aref prev-dp k) current-diff)))\n                    (when (> candidate max-val)\n                      (setq max-val candidate)))))\n              (aset curr-dp j max-val)))\n          (setq prev-dp curr-dp)))\n      \n      ;; Find the maximum value in the final DP table\n      (let ((result (apply 'max (append prev-dp nil))))\n        (if (= result *inf*) 0 result)))))", "test_cases": "", "test_case_results": "", "task_id": 19311, "assertions": "(require 'cl-lib)\n\n(defun test-max-fashion-difference ()\n  ;; Test Case 1\n  (cl-assert (= (max-fashion-difference 2 3\n                                       '(20 30)\n                                       '((15 25 50) (20 30 100) (30 40 200)))\n                50))\n  \n  ;; Test Case 2\n  (cl-assert (= (max-fashion-difference 3 4\n                                       '(10 20 15)\n                                       '((5 15 30) (10 20 50) (15 25 80) (20 30 120)))\n                100))\n  \n  ;; Test Case 3\n  (cl-assert (= (max-fashion-difference 4 2\n                                       '(25 25 25 25)\n                                       '((20 30 10) (20 30 20)))\n                10)))\n\n(test-max-fashion-difference)", "all_code": ";;; Solution for the clothes selection problem using dynamic programming\n\n;;; Constants and helper functions\n(defconst *inf* most-negative-fixnum \"Representation of negative infinity\")\n\n;;; Main function to calculate maximum fashion difference\n(defun max-fashion-difference (days num-clothes temperatures clothes)\n  \"Calculate the maximum cumulative fashion difference over DAYS days.\nNUM-CLOTHES is the total number of clothing options.\nTEMPERATURES is a list of daily temperatures.\nCLOTHES is a list of (MIN-TEMP MAX-TEMP FASHION-VALUE) tuples.\"\n  ;; Preprocess usable clothes for each day\n  (let ((usable-clothes (make-vector days nil)))\n    (dotimes (i days)\n      (let ((current-temp (nth i temperatures)))\n        (dotimes (j num-clothes)\n          (let* ((clothing (nth j clothes))\n                 (min-temp (nth 0 clothing))\n                 (max-temp (nth 1 clothing)))\n            (when (and (>= current-temp min-temp)\n                       (<= current-temp max-temp))\n              (push j (aref usable-clothes i)))))))\n    \n    ;; Initialize DP table\n    (let ((prev-dp (make-vector num-clothes *inf*)))\n      ;; First day initialization\n      (dolist (j (aref usable-clothes 0))\n        (aset prev-dp j 0))\n      \n      ;; Process subsequent days\n      (dotimes (i (1- days))\n        (let ((curr-dp (make-vector num-clothes *inf*))\n              (current-day (+ i 1)))\n          (dolist (j (aref usable-clothes current-day))\n            (let ((max-val -1))\n              (dolist (k (aref usable-clothes i))\n                (when (/= (aref prev-dp k) *inf*)\n                  (let* ((current-diff (abs (- (nth 2 (nth j clothes))\n                                               (nth 2 (nth k clothes)))))\n                         (candidate (+ (aref prev-dp k) current-diff)))\n                    (when (> candidate max-val)\n                      (setq max-val candidate)))))\n              (aset curr-dp j max-val)))\n          (setq prev-dp curr-dp)))\n      \n      ;; Find the maximum value in the final DP table\n      (let ((result (apply 'max (append prev-dp nil))))\n        (if (= result *inf*) 0 result)))))\n(require 'cl-lib)\n\n(defun test-max-fashion-difference ()\n  ;; Test Case 1\n  (cl-assert (= (max-fashion-difference 2 3\n                                       '(20 30)\n                                       '((15 25 50) (20 30 100) (30 40 200)))\n                50))\n  \n  ;; Test Case 2\n  (cl-assert (= (max-fashion-difference 3 4\n                                       '(10 20 15)\n                                       '((5 15 30) (10 20 50) (15 25 80) (20 30 120)))\n                100))\n  \n  ;; Test Case 3\n  (cl-assert (= (max-fashion-difference 4 2\n                                       '(25 25 25 25)\n                                       '((20 30 10) (20 30 20)))\n                10)))\n\n(test-max-fashion-difference)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Solution for the subset sum problem in Emacs Lisp\n\n;;; is-subset-sum determines if there is a subset of numbers in the list that sums up to x.\n;;; It uses dynamic programming to solve the problem.\n;;;\n;;; Parameters:\n;;; arr - List of positive integers\n;;; x   - Target sum\n;;;\n;;; Returns:\n;;; t if a subset exists that sums to x, nil otherwise\n(defun is-subset-sum (arr x)\n  (let* ((n (length arr))\n         (subset (make-vector (1+ n) nil)))\n    ;; Initialize the DP table\n    (dotimes (i (1+ n))\n      (aset subset i (make-vector (1+ x) nil))\n      (aset (aref subset i) 0 t))  ; Empty subset sums to 0\n    \n    ;; Fill the DP table\n    (dotimes (i n (aref (aref subset n) x))\n      (let ((current-i (1+ i)))\n        (dotimes (j (1+ x))\n          (when (>= j (nth i arr))\n            (aset (aref subset current-i) j\n                  (or (aref (aref subset i) j)\n                      (aref (aref subset i) (- j (nth i arr))))))\n          (when (< j (nth i arr))\n            (aset (aref subset current-i) j\n                  (aref (aref subset i) j))))))))", "test_cases": "", "test_case_results": "", "task_id": 2855, "assertions": "(require 'cl-lib)\n\n(defun test-is-subset-sum ()\n  (cl-assert (equal (is-subset-sum '(3 34 4 12 5 2) 9) t))   ; Subset exists (4,5)\n  (cl-assert (equal (is-subset-sum '(3 34 4 12 5 2) 10) nil)) ; No subset exists\n  (cl-assert (equal (is-subset-sum '(1 2 3) 5) t))            ; Subset exists (2,3)\n  (cl-assert (equal (is-subset-sum '(1 2 3) 7) nil))          ; No subset exists\n  (cl-assert (equal (is-subset-sum '(1 2 3 4 5) 15) t))       ; All elements sum to target\n  (cl-assert (equal (is-subset-sum '(1 2 3 4 5) 16) nil)))    ; No subset exists\n\n(test-is-subset-sum)", "all_code": ";;; Solution for the subset sum problem in Emacs Lisp\n\n;;; is-subset-sum determines if there is a subset of numbers in the list that sums up to x.\n;;; It uses dynamic programming to solve the problem.\n;;;\n;;; Parameters:\n;;; arr - List of positive integers\n;;; x   - Target sum\n;;;\n;;; Returns:\n;;; t if a subset exists that sums to x, nil otherwise\n(defun is-subset-sum (arr x)\n  (let* ((n (length arr))\n         (subset (make-vector (1+ n) nil)))\n    ;; Initialize the DP table\n    (dotimes (i (1+ n))\n      (aset subset i (make-vector (1+ x) nil))\n      (aset (aref subset i) 0 t))  ; Empty subset sums to 0\n    \n    ;; Fill the DP table\n    (dotimes (i n (aref (aref subset n) x))\n      (let ((current-i (1+ i)))\n        (dotimes (j (1+ x))\n          (when (>= j (nth i arr))\n            (aset (aref subset current-i) j\n                  (or (aref (aref subset i) j)\n                      (aref (aref subset i) (- j (nth i arr))))))\n          (when (< j (nth i arr))\n            (aset (aref subset current-i) j\n                  (aref (aref subset i) j))))))))\n(require 'cl-lib)\n\n(defun test-is-subset-sum ()\n  (cl-assert (equal (is-subset-sum '(3 34 4 12 5 2) 9) t))   ; Subset exists (4,5)\n  (cl-assert (equal (is-subset-sum '(3 34 4 12 5 2) 10) nil)) ; No subset exists\n  (cl-assert (equal (is-subset-sum '(1 2 3) 5) t))            ; Subset exists (2,3)\n  (cl-assert (equal (is-subset-sum '(1 2 3) 7) nil))          ; No subset exists\n  (cl-assert (equal (is-subset-sum '(1 2 3 4 5) 15) t))       ; All elements sum to target\n  (cl-assert (equal (is-subset-sum '(1 2 3 4 5) 16) nil)))    ; No subset exists\n\n(test-is-subset-sum)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Find the duplicate and missing numbers in a list where:\n;;; - One number appears exactly twice\n;;; - One number from the expected sequence is missing\n;;; Returns a cons cell (duplicate . missing)\n\n(defun find-error-nums (nums)\n  \"Returns a cons cell (duplicate . missing) for the given list of integers.\nThe list should contain numbers from 1 to n with one duplicate and one missing.\"\n  (let* ((n (length nums))\n         (sum-of-nums (apply '+ nums))\n         (sum-of-squares (apply '+ (mapcar (lambda (x) (* x x)) nums)))\n         (expected-sum (/ (* n (1+ n)) 2))\n         (expected-sum-of-squares (/ (* n (1+ n) (1+ (* 2 n))) 6))\n         (diff1 (- sum-of-nums expected-sum))\n         (diff2 (/ (- sum-of-squares expected-sum-of-squares) diff1))\n         (duplicate (/ (+ diff1 diff2) 2))\n         (missing (- duplicate diff1)))\n    (cons duplicate missing)))", "test_cases": "", "test_case_results": "", "task_id": 21587, "assertions": "(require 'cl-lib)\n\n(defun test-find-error-nums ()\n  (let ((test-cases '(((1 2 2 4) . (2 . 3))\n                      ((1 2 3 3 5) . (3 . 4))\n                      ((1 1 3 4) . (1 . 2))\n                      ((2 2 3 4 5 6) . (2 . 1)))))\n    (dolist (test-case test-cases)\n      (let* ((input (car test-case))\n             (expected (cdr test-case))\n             (result (find-error-nums input)))\n        (cl-assert (equal result expected) nil\n                  \"Test failed for input %S: expected %S but got %S\"\n                  input expected result)))))\n\n(test-find-error-nums)", "all_code": ";;; Find the duplicate and missing numbers in a list where:\n;;; - One number appears exactly twice\n;;; - One number from the expected sequence is missing\n;;; Returns a cons cell (duplicate . missing)\n\n(defun find-error-nums (nums)\n  \"Returns a cons cell (duplicate . missing) for the given list of integers.\nThe list should contain numbers from 1 to n with one duplicate and one missing.\"\n  (let* ((n (length nums))\n         (sum-of-nums (apply '+ nums))\n         (sum-of-squares (apply '+ (mapcar (lambda (x) (* x x)) nums)))\n         (expected-sum (/ (* n (1+ n)) 2))\n         (expected-sum-of-squares (/ (* n (1+ n) (1+ (* 2 n))) 6))\n         (diff1 (- sum-of-nums expected-sum))\n         (diff2 (/ (- sum-of-squares expected-sum-of-squares) diff1))\n         (duplicate (/ (+ diff1 diff2) 2))\n         (missing (- duplicate diff1)))\n    (cons duplicate missing)))\n(require 'cl-lib)\n\n(defun test-find-error-nums ()\n  (let ((test-cases '(((1 2 2 4) . (2 . 3))\n                      ((1 2 3 3 5) . (3 . 4))\n                      ((1 1 3 4) . (1 . 2))\n                      ((2 2 3 4 5 6) . (2 . 1)))))\n    (dolist (test-case test-cases)\n      (let* ((input (car test-case))\n             (expected (cdr test-case))\n             (result (find-error-nums input)))\n        (cl-assert (equal result expected) nil\n                  \"Test failed for input %S: expected %S but got %S\"\n                  input expected result)))))\n\n(test-find-error-nums)", "exec_outcome": "PASSED"}
{"code": ";;; largest-square-of-plants.el --- Find largest square areas of plants in gardens\n\n;; Function to find the size of the largest square areas of plants for each garden\n;; The input is a list of gardens, where each garden is a list of lists (matrix) of 0s and 1s\n;; The output is a list of integers representing the largest square side for each garden\n(defun largest-square-of-plants (gardens)\n  \"Returns a list containing the size of the largest square areas of plants for each garden.\"\n  (let ((results '()))\n    (dolist (garden gardens results)\n      (let* ((n (length garden))\n             (dp (make-vector n (make-vector n 0)))\n             (max-side 0))\n        (when (> n 0)\n          (dotimes (i n)\n            (dotimes (j n)\n              (when (= (nth j (nth i garden)) 1)\n                (if (or (= i 0) (= j 0))\n                    (aset (aref dp i) j 1)\n                  (aset (aref dp i) j (1+ (min (aref (aref dp (1- i)) j)\n                                              (aref (aref dp i) (1- j))\n                                              (aref (aref dp (1- i)) (1- j))))))\n                (setq max-side (max max-side (aref (aref dp i) j)))))))\n        (setq results (cons max-side results))))\n    (reverse results)))", "test_cases": "", "test_case_results": "", "task_id": 4374, "assertions": "(require 'cl-lib)\n\n(defun test-largest-square-of-plants ()\n  (let ((test-case1 '(((1 1)\n                       (1 1))\n                      ((0 0 0)\n                       (0 0 0)\n                       (0 0 0))\n                      ((1 0 1)\n                       (1 1 1)\n                       (1 1 1))))\n        (test-case2 '(((1 0 1 0)\n                       (1 1 1 1)\n                       (1 1 1 1)\n                       (1 0 1 0))\n                      ((1))\n                      ((1 1)\n                       (0 1)))))\n    (cl-assert (equal (largest-square-of-plants test-case1) '(2 0 2)))\n    (cl-assert (equal (largest-square-of-plants test-case2) '(2 1 1)))))\n\n(test-largest-square-of-plants)", "all_code": ";;; largest-square-of-plants.el --- Find largest square areas of plants in gardens\n\n;; Function to find the size of the largest square areas of plants for each garden\n;; The input is a list of gardens, where each garden is a list of lists (matrix) of 0s and 1s\n;; The output is a list of integers representing the largest square side for each garden\n(defun largest-square-of-plants (gardens)\n  \"Returns a list containing the size of the largest square areas of plants for each garden.\"\n  (let ((results '()))\n    (dolist (garden gardens results)\n      (let* ((n (length garden))\n             (dp (make-vector n (make-vector n 0)))\n             (max-side 0))\n        (when (> n 0)\n          (dotimes (i n)\n            (dotimes (j n)\n              (when (= (nth j (nth i garden)) 1)\n                (if (or (= i 0) (= j 0))\n                    (aset (aref dp i) j 1)\n                  (aset (aref dp i) j (1+ (min (aref (aref dp (1- i)) j)\n                                              (aref (aref dp i) (1- j))\n                                              (aref (aref dp (1- i)) (1- j))))))\n                (setq max-side (max max-side (aref (aref dp i) j)))))))\n        (setq results (cons max-side results))))\n    (reverse results)))\n(require 'cl-lib)\n\n(defun test-largest-square-of-plants ()\n  (let ((test-case1 '(((1 1)\n                       (1 1))\n                      ((0 0 0)\n                       (0 0 0)\n                       (0 0 0))\n                      ((1 0 1)\n                       (1 1 1)\n                       (1 1 1))))\n        (test-case2 '(((1 0 1 0)\n                       (1 1 1 1)\n                       (1 1 1 1)\n                       (1 0 1 0))\n                      ((1))\n                      ((1 1)\n                       (0 1)))))\n    (cl-assert (equal (largest-square-of-plants test-case1) '(2 0 2)))\n    (cl-assert (equal (largest-square-of-plants test-case2) '(2 1 1)))))\n\n(test-largest-square-of-plants)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Tree Connectivity Check via BFS in Emacs Lisp\n\n;; We'll use a queue implementation based on lists for BFS.\n;; Note: Emacs Lisp doesn't have a built-in deque, so we'll use lists with\n;;       `push' for append and `pop' for popleft.\n\n;; bfs-check-tree-connectivity performs a BFS starting from node 1 to check\n;; if all nodes in the tree are reachable (i.e., the tree is connected).\n;; The adjacency list is 1-based indexed.\n(defun bfs-check-tree-connectivity (adj)\n  (let* ((n (1- (length adj)))\n         (visited (make-vector (length adj) nil))\n         (queue (list 1))\n         (count 0))\n    (aset visited 1 t)\n    (while queue\n      (let ((node (pop queue)))\n        (setq count (1+ count))\n        (dolist (neighbor (aref adj node))\n          (when (not (aref visited neighbor))\n            (aset visited neighbor t)\n            (push neighbor queue)))))\n    (if (= count n) \"Yes\" \"No\")))\n\n;; build-adjacency-list constructs an adjacency list from a list of edges.\n;; The nodes are 1-based indexed, and we create a vector of lists for adjacency.\n(defun build-adjacency-list (n edges)\n  (let ((adj (make-vector (1+ n) nil)))  ; 1-based indexing\n    (dolist (edge edges adj)\n      (let ((a (car edge))\n            (b (cadr edge)))\n        (aset adj a (cons b (aref adj a)))\n        (aset adj b (cons a (aref adj b)))))))", "test_cases": "", "test_case_results": "", "task_id": 7956, "assertions": "(require 'cl-lib)\n\n(defun test-tree-connectivity ()\n  ;; Test case 1: Connected tree\n  (let ((adj (build-adjacency-list 5 '((1 2) (2 3) (3 4) (4 5)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 2: Disconnected tree (two components: 1-2 and 3-4-5)\n  (let ((adj (build-adjacency-list 5 '((1 2) (3 4) (4 5)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"No\")))\n  \n  ;; Test case 3: Single node\n  (let ((adj (build-adjacency-list 1 '())))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 4: Two connected nodes\n  (let ((adj (build-adjacency-list 2 '((1 2)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 5: Two disconnected nodes\n  (let ((adj (build-adjacency-list 2 '())))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"No\")))\n  \n  ;; Test case 6: Star topology\n  (let ((adj (build-adjacency-list 4 '((1 2) (1 3) (1 4)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\"))))\n\n(test-tree-connectivity)", "all_code": ";;; Tree Connectivity Check via BFS in Emacs Lisp\n\n;; We'll use a queue implementation based on lists for BFS.\n;; Note: Emacs Lisp doesn't have a built-in deque, so we'll use lists with\n;;       `push' for append and `pop' for popleft.\n\n;; bfs-check-tree-connectivity performs a BFS starting from node 1 to check\n;; if all nodes in the tree are reachable (i.e., the tree is connected).\n;; The adjacency list is 1-based indexed.\n(defun bfs-check-tree-connectivity (adj)\n  (let* ((n (1- (length adj)))\n         (visited (make-vector (length adj) nil))\n         (queue (list 1))\n         (count 0))\n    (aset visited 1 t)\n    (while queue\n      (let ((node (pop queue)))\n        (setq count (1+ count))\n        (dolist (neighbor (aref adj node))\n          (when (not (aref visited neighbor))\n            (aset visited neighbor t)\n            (push neighbor queue)))))\n    (if (= count n) \"Yes\" \"No\")))\n\n;; build-adjacency-list constructs an adjacency list from a list of edges.\n;; The nodes are 1-based indexed, and we create a vector of lists for adjacency.\n(defun build-adjacency-list (n edges)\n  (let ((adj (make-vector (1+ n) nil)))  ; 1-based indexing\n    (dolist (edge edges adj)\n      (let ((a (car edge))\n            (b (cadr edge)))\n        (aset adj a (cons b (aref adj a)))\n        (aset adj b (cons a (aref adj b)))))))\n(require 'cl-lib)\n\n(defun test-tree-connectivity ()\n  ;; Test case 1: Connected tree\n  (let ((adj (build-adjacency-list 5 '((1 2) (2 3) (3 4) (4 5)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 2: Disconnected tree (two components: 1-2 and 3-4-5)\n  (let ((adj (build-adjacency-list 5 '((1 2) (3 4) (4 5)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"No\")))\n  \n  ;; Test case 3: Single node\n  (let ((adj (build-adjacency-list 1 '())))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 4: Two connected nodes\n  (let ((adj (build-adjacency-list 2 '((1 2)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\")))\n  \n  ;; Test case 5: Two disconnected nodes\n  (let ((adj (build-adjacency-list 2 '())))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"No\")))\n  \n  ;; Test case 6: Star topology\n  (let ((adj (build-adjacency-list 4 '((1 2) (1 3) (1 4)))))\n    (cl-assert (string= (bfs-check-tree-connectivity adj) \"Yes\"))))\n\n(test-tree-connectivity)", "exec_outcome": "PASSED"}
{"code": ";;; State Transition Path Counter\n\n;; This program counts the number of paths of length n in a state transition graph\n;; that start and end at state 1, following given transitions.\n\n;; The graph has k states (1-based), and transitions are defined by hexadecimal digit inputs.\n\n;; Main function that counts paths in state transition graph\n(defun count-transition-paths (k n r transitions)\n  \"Count paths of length n from state 1 back to state 1.\nK is the number of states, N is the path length, R is the number of transitions.\nTRANSITIONS is a list of (source digit target) tuples.\"\n  ;; Initialize transition table: vector of alists (digit . target-state)\n  (let ((transition-table (make-vector (1+ k) nil)))\n    ;; Populate transition table\n    (dolist (transition transitions)\n      (let* ((source (nth 0 transition))\n             (digit (nth 1 transition))\n             (target (nth 2 transition))\n             (state-trans (aref transition-table source)))\n        (aset transition-table source (cons (cons digit target) state-trans))))\n    \n    ;; Initialize DP arrays\n    (let ((dp-prev (make-vector (1+ k) 0)))\n      (aset dp-prev 1 1)  ; Start at state 1 with 0 digits processed\n      \n      ;; Process each digit position\n      (dotimes (_ n dp-prev)\n        (let ((dp-curr (make-vector (1+ k) 0)))\n          ;; For each possible previous state\n          (dotimes (s-prev (1+ k))\n            (let ((count (aref dp-prev s-prev)))\n              (when (> count 0)\n                ;; For each possible transition from this state\n                (dolist (trans (aref transition-table s-prev))\n                  (let* ((digit (car trans))\n                         (next-s (cdr trans)))\n                    (aset dp-curr next-s (+ (aref dp-curr next s) count)))))))\n          (setq dp-prev dp-curr)))\n      \n      ;; Return count of paths ending at state 1\n      (aref dp-prev 1))))", "test_cases": "", "test_case_results": "", "task_id": 1918, "assertions": "(require 'cl-lib)\n\n(defun test-count-transition-paths ()\n  \"Test function for count-transition-paths with various test cases.\"\n  ;; Test case 1: 3 states, 2 digits, 3 transitions\n  (cl-assert (= (count-transition-paths \n                 3 2 3 \n                 '((1 1 2) (1 2 3) (2 3 1)))\n                4))\n  \n  ;; Test case 2: 4 states, 3 digits, 5 transitions\n  (cl-assert (= (count-transition-paths \n                 4 3 5 \n                 '((1 1 2) (1 2 3) (2 3 4) (3 4 1) (4 1 1)))\n                2))\n  \n  ;; Test case 3: 2 states, 1 digit, 2 transitions\n  (cl-assert (= (count-transition-paths \n                 2 1 2 \n                 '((1 1 2) (2 1 1)))\n                1)))\n\n(test-count-transition-paths)", "all_code": ";;; State Transition Path Counter\n\n;; This program counts the number of paths of length n in a state transition graph\n;; that start and end at state 1, following given transitions.\n\n;; The graph has k states (1-based), and transitions are defined by hexadecimal digit inputs.\n\n;; Main function that counts paths in state transition graph\n(defun count-transition-paths (k n r transitions)\n  \"Count paths of length n from state 1 back to state 1.\nK is the number of states, N is the path length, R is the number of transitions.\nTRANSITIONS is a list of (source digit target) tuples.\"\n  ;; Initialize transition table: vector of alists (digit . target-state)\n  (let ((transition-table (make-vector (1+ k) nil)))\n    ;; Populate transition table\n    (dolist (transition transitions)\n      (let* ((source (nth 0 transition))\n             (digit (nth 1 transition))\n             (target (nth 2 transition))\n             (state-trans (aref transition-table source)))\n        (aset transition-table source (cons (cons digit target) state-trans))))\n    \n    ;; Initialize DP arrays\n    (let ((dp-prev (make-vector (1+ k) 0)))\n      (aset dp-prev 1 1)  ; Start at state 1 with 0 digits processed\n      \n      ;; Process each digit position\n      (dotimes (_ n dp-prev)\n        (let ((dp-curr (make-vector (1+ k) 0)))\n          ;; For each possible previous state\n          (dotimes (s-prev (1+ k))\n            (let ((count (aref dp-prev s-prev)))\n              (when (> count 0)\n                ;; For each possible transition from this state\n                (dolist (trans (aref transition-table s-prev))\n                  (let* ((digit (car trans))\n                         (next-s (cdr trans)))\n                    (aset dp-curr next-s (+ (aref dp-curr next s) count)))))))\n          (setq dp-prev dp-curr)))\n      \n      ;; Return count of paths ending at state 1\n      (aref dp-prev 1))))\n(require 'cl-lib)\n\n(defun test-count-transition-paths ()\n  \"Test function for count-transition-paths with various test cases.\"\n  ;; Test case 1: 3 states, 2 digits, 3 transitions\n  (cl-assert (= (count-transition-paths \n                 3 2 3 \n                 '((1 1 2) (1 2 3) (2 3 1)))\n                4))\n  \n  ;; Test case 2: 4 states, 3 digits, 5 transitions\n  (cl-assert (= (count-transition-paths \n                 4 3 5 \n                 '((1 1 2) (1 2 3) (2 3 4) (3 4 1) (4 1 1)))\n                2))\n  \n  ;; Test case 3: 2 states, 1 digit, 2 transitions\n  (cl-assert (= (count-transition-paths \n                 2 1 2 \n                 '((1 1 2) (2 1 1)))\n                1)))\n\n(test-count-transition-paths)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Strobogrammatic Number Functions\n\n;; A strobogrammatic number is a number that looks the same when rotated 180 degrees.\n;; This code provides functions to check if a number is strobogrammatic and to find\n;; the next strobogrammatic number greater than a given number.\n\n;; Define the mapping of strobogrammatic digits\n(defconst *strobo-map*\n  '((?0 . ?0)\n    (?1 . ?1)\n    (?6 . ?9)\n    (?8 . ?8)\n    (?9 . ?6))\n  \"Mapping of strobogrammatic digits to their rotated counterparts.\")\n\n;; is-strobogrammatic checks if a number is strobogrammatic.\n;; It converts the number to a string, reverses it, and checks if the reversed string\n;; matches the original string when each digit is replaced by its strobogrammatic counterpart.\n(defun is-strobogrammatic (num)\n  (let* ((str-num (number-to-string num))\n         (reversed-str (reverse str-num))\n         (rotated-str (mapconcat (lambda (ch)\n                                   (let ((mapped (cdr (assq ch *strobo-map*))))\n                                     (if mapped (char-to-string mapped) \"\")))\n                                 reversed-str \"\")))\n    (string= str-num rotated-str)))\n\n;; next-strobogrammatic-number finds the next strobogrammatic number greater than n.\n;; It increments n until it finds a number that is strobogrammatic.\n(defun next-strobogrammatic-number (n)\n  (let ((next-num (1+ n)))\n    (while (not (is-strobogrammatic next-num))\n      (setq next-num (1+ next-num)))\n    next-num))", "test_cases": "", "test_case_results": "", "task_id": 16088, "assertions": "(require 'cl-lib)\n\n(defun test-strobogrammatic ()\n  ;; Test is-strobogrammatic with known strobogrammatic numbers\n  (cl-assert (is-strobogrammatic 0))\n  (cl-assert (is-strobogrammatic 1))\n  (cl-assert (is-strobogrammatic 8))\n  (cl-assert (is-strobogrammatic 11))\n  (cl-assert (is-strobogrammatic 69))\n  (cl-assert (is-strobogrammatic 88))\n  (cl-assert (is-strobogrammatic 96))\n  (cl-assert (is-strobogrammatic 101))\n  (cl-assert (is-strobogrammatic 111))\n  (cl-assert (is-strobogrammatic 181))\n  (cl-assert (is-strobogrammatic 609))\n  (cl-assert (is-strobogrammatic 689))\n  (cl-assert (is-strobogrammatic 808))\n  (cl-assert (is-strobogrammatic 888))\n  (cl-assert (is-strobogrammatic 906))\n  (cl-assert (is-strobogrammatic 916))\n  (cl-assert (is-strobogrammatic 986))\n  (cl-assert (is-strobogrammatic 1001))\n\n  ;; Test next-strobogrammatic-number\n  (cl-assert (= (next-strobogrammatic-number 0) 1))\n  (cl-assert (= (next-strobogrammatic-number 1) 8))\n  (cl-assert (= (next-strobogrammatic-number 8) 11))\n  (cl-assert (= (next-strobogrammatic-number 11) 69))\n  (cl-assert (= (next-strobogrammatic-number 69) 88))\n  (cl-assert (= (next-strobogrammatic-number 88) 96))\n  (cl-assert (= (next-strobogrammatic-number 96) 101))\n  (cl-assert (= (next-strobogrammatic-number 101) 111))\n  (cl-assert (= (next-strobogrammatic-number 111) 181))\n  (cl-assert (= (next-strobogrammatic-number 181) 609)))\n\n(test-strobogrammatic)", "all_code": ";;; Strobogrammatic Number Functions\n\n;; A strobogrammatic number is a number that looks the same when rotated 180 degrees.\n;; This code provides functions to check if a number is strobogrammatic and to find\n;; the next strobogrammatic number greater than a given number.\n\n;; Define the mapping of strobogrammatic digits\n(defconst *strobo-map*\n  '((?0 . ?0)\n    (?1 . ?1)\n    (?6 . ?9)\n    (?8 . ?8)\n    (?9 . ?6))\n  \"Mapping of strobogrammatic digits to their rotated counterparts.\")\n\n;; is-strobogrammatic checks if a number is strobogrammatic.\n;; It converts the number to a string, reverses it, and checks if the reversed string\n;; matches the original string when each digit is replaced by its strobogrammatic counterpart.\n(defun is-strobogrammatic (num)\n  (let* ((str-num (number-to-string num))\n         (reversed-str (reverse str-num))\n         (rotated-str (mapconcat (lambda (ch)\n                                   (let ((mapped (cdr (assq ch *strobo-map*))))\n                                     (if mapped (char-to-string mapped) \"\")))\n                                 reversed-str \"\")))\n    (string= str-num rotated-str)))\n\n;; next-strobogrammatic-number finds the next strobogrammatic number greater than n.\n;; It increments n until it finds a number that is strobogrammatic.\n(defun next-strobogrammatic-number (n)\n  (let ((next-num (1+ n)))\n    (while (not (is-strobogrammatic next-num))\n      (setq next-num (1+ next-num)))\n    next-num))\n(require 'cl-lib)\n\n(defun test-strobogrammatic ()\n  ;; Test is-strobogrammatic with known strobogrammatic numbers\n  (cl-assert (is-strobogrammatic 0))\n  (cl-assert (is-strobogrammatic 1))\n  (cl-assert (is-strobogrammatic 8))\n  (cl-assert (is-strobogrammatic 11))\n  (cl-assert (is-strobogrammatic 69))\n  (cl-assert (is-strobogrammatic 88))\n  (cl-assert (is-strobogrammatic 96))\n  (cl-assert (is-strobogrammatic 101))\n  (cl-assert (is-strobogrammatic 111))\n  (cl-assert (is-strobogrammatic 181))\n  (cl-assert (is-strobogrammatic 609))\n  (cl-assert (is-strobogrammatic 689))\n  (cl-assert (is-strobogrammatic 808))\n  (cl-assert (is-strobogrammatic 888))\n  (cl-assert (is-strobogrammatic 906))\n  (cl-assert (is-strobogrammatic 916))\n  (cl-assert (is-strobogrammatic 986))\n  (cl-assert (is-strobogrammatic 1001))\n\n  ;; Test next-strobogrammatic-number\n  (cl-assert (= (next-strobogrammatic-number 0) 1))\n  (cl-assert (= (next-strobogrammatic-number 1) 8))\n  (cl-assert (= (next-strobogrammatic-number 8) 11))\n  (cl-assert (= (next-strobogrammatic-number 11) 69))\n  (cl-assert (= (next-strobogrammatic-number 69) 88))\n  (cl-assert (= (next-strobogrammatic-number 88) 96))\n  (cl-assert (= (next-strobogrammatic-number 96) 101))\n  (cl-assert (= (next-strobogrammatic-number 101) 111))\n  (cl-assert (= (next-strobogrammatic-number 111) 181))\n  (cl-assert (= (next-strobogrammatic-number 181) 609)))\n\n(test-strobogrammatic)", "exec_outcome": "PASSED"}
{"code": ";;; Group integers by their remainder when divided by a given number\n\n;; group-by-remainder groups a list of integers into subsets based on their\n;; remainder when divided by x. The result is an alist where each key is a\n;; remainder and the value is the list of integers with that remainder.\n;; Example: (group-by-remainder '(1 2 3 4 5) 2) => ((1 . (1 3 5)) (0 . (2 4)))\n(defun group-by-remainder (nums x)\n  \"Groups the integers in NUMS into subsets based on their remainder when divided by X.\nReturns an alist with the remainder as the key and the corresponding list of integers as the value.\"\n  (let ((result '()))\n    (dolist (num nums result)\n      (let ((remainder (mod num x)))\n        (let ((cell (assoc remainder result)))\n          (if cell\n              (setcdr cell (cons num (cdr cell)))\n            (setq result (cons (cons remainder (list num)) result))))))))", "test_cases": "", "test_case_results": "", "task_id": 13897, "assertions": "(require 'cl-lib)\n\n(defun test-group-by-remainder ()\n  \"Test function for group-by-remainder with various test cases.\"\n  (cl-assert (equal (group-by-remainder '(1 2 3 4 5) 2)\n                    '((1 . (5 3 1)) (0 . (4 2)))))\n  (cl-assert (equal (group-by-remainder '(10 15 20 25 30) 5)\n                    '((0 . (30 25 20 15 10)))))\n  (cl-assert (equal (group-by-remainder '(7 14 21 28) 7)\n                    '((0 . (28 21 14 7)))))\n  (cl-assert (equal (group-by-remainder '(1 3 5 7 9) 3)\n                    '((1 . (7 1)) (0 . (9 3)) (2 . (5))))))\n\n(test-group-by-remainder)", "all_code": ";;; Group integers by their remainder when divided by a given number\n\n;; group-by-remainder groups a list of integers into subsets based on their\n;; remainder when divided by x. The result is an alist where each key is a\n;; remainder and the value is the list of integers with that remainder.\n;; Example: (group-by-remainder '(1 2 3 4 5) 2) => ((1 . (1 3 5)) (0 . (2 4)))\n(defun group-by-remainder (nums x)\n  \"Groups the integers in NUMS into subsets based on their remainder when divided by X.\nReturns an alist with the remainder as the key and the corresponding list of integers as the value.\"\n  (let ((result '()))\n    (dolist (num nums result)\n      (let ((remainder (mod num x)))\n        (let ((cell (assoc remainder result)))\n          (if cell\n              (setcdr cell (cons num (cdr cell)))\n            (setq result (cons (cons remainder (list num)) result))))))))\n(require 'cl-lib)\n\n(defun test-group-by-remainder ()\n  \"Test function for group-by-remainder with various test cases.\"\n  (cl-assert (equal (group-by-remainder '(1 2 3 4 5) 2)\n                    '((1 . (5 3 1)) (0 . (4 2)))))\n  (cl-assert (equal (group-by-remainder '(10 15 20 25 30) 5)\n                    '((0 . (30 25 20 15 10)))))\n  (cl-assert (equal (group-by-remainder '(7 14 21 28) 7)\n                    '((0 . (28 21 14 7)))))\n  (cl-assert (equal (group-by-remainder '(1 3 5 7 9) 3)\n                    '((1 . (7 1)) (0 . (9 3)) (2 . (5))))))\n\n(test-group-by-remainder)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Emacs Lisp implementation of median and k-closest-to-median functions\n\n;; find-median calculates the median of a list of numbers.\n;; The median is the middle value of a sorted list. If the list has an even\n;; number of elements, the median is the average of the two middle values.\n(defun find-median (arr)\n  (let* ((arr-sorted (sort (copy-sequence arr) '<))\n         (n (length arr-sorted)))\n    (if (= (% n 2) 1)\n        (float (nth (/ n 2) arr-sorted))\n      (/ (+ (nth (1- (/ n 2)) arr-sorted)\n            (nth (/ n 2) arr-sorted))\n         2.0))))\n\n;; k-closest-to-median finds the k elements closest to the median.\n;; The elements are sorted by their absolute distance to the median,\n;; and in case of ties, by their value.\n(defun k-closest-to-median (arr k)\n  (let* ((median (find-median arr))\n         (arr-sorted (sort (copy-sequence arr)\n                           (lambda (x y)\n                             (let ((diff-x (abs (- x median)))\n                                   (diff-y (abs (- y median))))\n                               (or (< diff-x diff-y)\n                                   (and (= diff-x diff-y) (< x y))))))))\n    (seq-take arr-sorted k)))", "test_cases": "", "test_case_results": "", "task_id": 21154, "assertions": "(require 'cl-lib)\n\n(defun test-median-functions ()\n  ;; Test find-median function\n  (cl-assert (= (find-median '(1 2 3 4 5)) 3.0))\n  (cl-assert (= (find-median '(1 2 3 4)) 2.5))\n  (cl-assert (= (find-median '(5 1 3 4 2)) 3.0))\n  (cl-assert (= (find-median '(10 20 30 40 50 60)) 35.0))\n  \n  ;; Test k-closest-to-median function\n  (cl-assert (equal (k-closest-to-median '(1 2 3 4 5) 3) '(3 2 4)))\n  (cl-assert (equal (k-closest-to-median '(1 2 3 4) 2) '(2 3)))\n  (cl-assert (equal (k-closest-to-median '(5 1 3 4 2) 3) '(3 2 4)))\n  (cl-assert (equal (k-closest-to-median '(10 20 30 40 50 60) 4) '(30 40 20 50))))\n\n(test-median-functions)", "all_code": ";;; Emacs Lisp implementation of median and k-closest-to-median functions\n\n;; find-median calculates the median of a list of numbers.\n;; The median is the middle value of a sorted list. If the list has an even\n;; number of elements, the median is the average of the two middle values.\n(defun find-median (arr)\n  (let* ((arr-sorted (sort (copy-sequence arr) '<))\n         (n (length arr-sorted)))\n    (if (= (% n 2) 1)\n        (float (nth (/ n 2) arr-sorted))\n      (/ (+ (nth (1- (/ n 2)) arr-sorted)\n            (nth (/ n 2) arr-sorted))\n         2.0))))\n\n;; k-closest-to-median finds the k elements closest to the median.\n;; The elements are sorted by their absolute distance to the median,\n;; and in case of ties, by their value.\n(defun k-closest-to-median (arr k)\n  (let* ((median (find-median arr))\n         (arr-sorted (sort (copy-sequence arr)\n                           (lambda (x y)\n                             (let ((diff-x (abs (- x median)))\n                                   (diff-y (abs (- y median))))\n                               (or (< diff-x diff-y)\n                                   (and (= diff-x diff-y) (< x y))))))))\n    (seq-take arr-sorted k)))\n(require 'cl-lib)\n\n(defun test-median-functions ()\n  ;; Test find-median function\n  (cl-assert (= (find-median '(1 2 3 4 5)) 3.0))\n  (cl-assert (= (find-median '(1 2 3 4)) 2.5))\n  (cl-assert (= (find-median '(5 1 3 4 2)) 3.0))\n  (cl-assert (= (find-median '(10 20 30 40 50 60)) 35.0))\n  \n  ;; Test k-closest-to-median function\n  (cl-assert (equal (k-closest-to-median '(1 2 3 4 5) 3) '(3 2 4)))\n  (cl-assert (equal (k-closest-to-median '(1 2 3 4) 2) '(2 3)))\n  (cl-assert (equal (k-closest-to-median '(5 1 3 4 2) 3) '(3 2 4)))\n  (cl-assert (equal (k-closest-to-median '(10 20 30 40 50 60) 4) '(30 40 20 50))))\n\n(test-median-functions)", "exec_outcome": "PASSED"}
{"code": ";; Calculate the final position of the drone on a 2D plane after executing all the movement instructions.\n;; The movements are given as a string containing characters U (up), D (down), L (left), R (right).\n;; Returns a cons cell (x . y) representing the final coordinates.\n(defun final-position (movements)\n  (let ((x 0)\n        (y 0))\n    (dolist (move (string-to-list movements) (cons x y))\n      (cond\n       ((eq move ?U) (setq y (1+ y)))\n       ((eq move ?D) (setq y (1- y)))\n       ((eq move ?L) (setq x (1- x)))\n       ((eq move ?R) (setq x (1+ x)))))))", "test_cases": "", "test_case_results": "", "task_id": 25650, "assertions": "(require 'cl-lib)\n\n(defun test-final-position ()\n  ;; Test cases derived from the original test cases in the code\n  (cl-assert (equal (final-position \"UDLR\") '(0 . 0)))\n  (cl-assert (equal (final-position \"UUU\") '(0 . 3)))\n  (cl-assert (equal (final-position \"DDD\") '(0 . -3)))\n  (cl-assert (equal (final-position \"LLL\") '(-3 . 0)))\n  (cl-assert (equal (final-position \"RRR\") '(3 . 0)))\n  (cl-assert (equal (final-position \"URDL\") '(0 . 0)))\n  (cl-assert (equal (final-position \"ULDR\") '(0 . 0))))\n\n(test-final-position)", "all_code": ";; Calculate the final position of the drone on a 2D plane after executing all the movement instructions.\n;; The movements are given as a string containing characters U (up), D (down), L (left), R (right).\n;; Returns a cons cell (x . y) representing the final coordinates.\n(defun final-position (movements)\n  (let ((x 0)\n        (y 0))\n    (dolist (move (string-to-list movements) (cons x y))\n      (cond\n       ((eq move ?U) (setq y (1+ y)))\n       ((eq move ?D) (setq y (1- y)))\n       ((eq move ?L) (setq x (1- x)))\n       ((eq move ?R) (setq x (1+ x)))))))\n(require 'cl-lib)\n\n(defun test-final-position ()\n  ;; Test cases derived from the original test cases in the code\n  (cl-assert (equal (final-position \"UDLR\") '(0 . 0)))\n  (cl-assert (equal (final-position \"UUU\") '(0 . 3)))\n  (cl-assert (equal (final-position \"DDD\") '(0 . -3)))\n  (cl-assert (equal (final-position \"LLL\") '(-3 . 0)))\n  (cl-assert (equal (final-position \"RRR\") '(3 . 0)))\n  (cl-assert (equal (final-position \"URDL\") '(0 . 0)))\n  (cl-assert (equal (final-position \"ULDR\") '(0 . 0))))\n\n(test-final-position)", "exec_outcome": "PASSED"}
{"code": ";; This program calculates the minimum sum of absolute differences between\n;; higher and lower scores across divisions for various threshold values T.\n;; It processes multiple test cases where each case contains several divisions\n;; of sorted scores.\n\n(require 'cl-lib) ; For cl-loop and other common lisp functions\n\n;; Find the position where T would be inserted to maintain order (similar to bisect_right)\n(defun bisect-right (lst x)\n  \"Return the index where X would be inserted in sorted list LST to maintain order.\nThis is equivalent to Python's bisect.bisect_right.\"\n  (let ((low 0)\n        (high (length lst)))\n    (while (< low high)\n      (let ((mid (/ (+ low high) 2)))\n        (if (< x (nth mid lst))\n            (setq high mid)\n          (setq low (1+ mid)))))\n    low))\n\n;; Calculate the minimum sum of absolute differences for all possible T values\n(defun calculate-min-sum (divisions)\n  \"Calculate the minimum sum of absolute differences for given DIVISIONS.\nEach division is a sorted list of scores. Returns the minimum sum found.\"\n  (let ((min-sum most-positive-fixnum))\n    ;; Check all possible T from 0 to 1001 inclusive\n    (cl-loop for T from 0 to 1001 do\n             (let ((current-sum 0))\n               (cl-loop for scores in divisions do\n                        (let* ((ki (length scores))\n                               (pos (bisect-right scores (1- T)))\n                               (higher (- ki pos))\n                               (diff (abs (- ki (* 2 higher)))))\n                          (setq current-sum (+ current-sum diff))))\n               (when (< current-sum min-sum)\n                 (setq min-sum current-sum))))\n    min-sum))", "test_cases": "", "test_case_results": "", "task_id": 26133, "assertions": "(require 'cl-lib)\n\n(defun test-min-sum-calculations ()\n  \"Test the calculate-min-sum function with various division cases.\"\n  ;; Test case 1: Two divisions\n  (let ((divisions '((10 20 30) (15 25 35 45))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 1 passed\"))\n  \n  ;; Test case 2: Three divisions\n  (let ((divisions '((5 10 15) (20 25) (30 35 40))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 2 passed\"))\n  \n  ;; Test case 3: Single division\n  (let ((divisions '((100 200 300 400))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 3 passed\")))\n\n(test-min-sum-calculations)", "all_code": ";; This program calculates the minimum sum of absolute differences between\n;; higher and lower scores across divisions for various threshold values T.\n;; It processes multiple test cases where each case contains several divisions\n;; of sorted scores.\n\n(require 'cl-lib) ; For cl-loop and other common lisp functions\n\n;; Find the position where T would be inserted to maintain order (similar to bisect_right)\n(defun bisect-right (lst x)\n  \"Return the index where X would be inserted in sorted list LST to maintain order.\nThis is equivalent to Python's bisect.bisect_right.\"\n  (let ((low 0)\n        (high (length lst)))\n    (while (< low high)\n      (let ((mid (/ (+ low high) 2)))\n        (if (< x (nth mid lst))\n            (setq high mid)\n          (setq low (1+ mid)))))\n    low))\n\n;; Calculate the minimum sum of absolute differences for all possible T values\n(defun calculate-min-sum (divisions)\n  \"Calculate the minimum sum of absolute differences for given DIVISIONS.\nEach division is a sorted list of scores. Returns the minimum sum found.\"\n  (let ((min-sum most-positive-fixnum))\n    ;; Check all possible T from 0 to 1001 inclusive\n    (cl-loop for T from 0 to 1001 do\n             (let ((current-sum 0))\n               (cl-loop for scores in divisions do\n                        (let* ((ki (length scores))\n                               (pos (bisect-right scores (1- T)))\n                               (higher (- ki pos))\n                               (diff (abs (- ki (* 2 higher)))))\n                          (setq current-sum (+ current-sum diff))))\n               (when (< current-sum min-sum)\n                 (setq min-sum current-sum))))\n    min-sum))\n(require 'cl-lib)\n\n(defun test-min-sum-calculations ()\n  \"Test the calculate-min-sum function with various division cases.\"\n  ;; Test case 1: Two divisions\n  (let ((divisions '((10 20 30) (15 25 35 45))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 1 passed\"))\n  \n  ;; Test case 2: Three divisions\n  (let ((divisions '((5 10 15) (20 25) (30 35 40))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 2 passed\"))\n  \n  ;; Test case 3: Single division\n  (let ((divisions '((100 200 300 400))))\n    (cl-assert (integerp (calculate-min-sum divisions)))\n    (message \"Test case 3 passed\")))\n\n(test-min-sum-calculations)", "exec_outcome": "PASSED"}
{"code": ";;; Implementation of bomb detonation problem in Emacs Lisp\n\n;;; The following function calculates the maximum number of bombs that can be detonated\n;;; by a single initial detonation. Each bomb is represented as (x y radius).\n\n;;; Helper function to calculate squared distance between two points\n(defun squared-distance (x1 y1 x2 y2)\n  (let ((dx (- x1 x2))\n        (dy (- y1 y2)))\n    (+ (* dx dx) (* dy dy))))\n\n;;; Build adjacency list for bombs\n(defun build-adjacency-list (bombs)\n  (let* ((n (length bombs))\n         (adj (make-vector n nil)))\n    (dotimes (i n adj)\n      (let* ((bomb-i (nth i bombs))\n             (xi (nth 0 bomb-i))\n             (yi (nth 1 bomb-i))\n             (ri (nth 2 bomb-i))\n             (ri-sq (* ri ri)))\n        (dotimes (j n)\n          (unless (= i j)\n            (let* ((bomb-j (nth j bombs))\n                   (xj (nth 0 bomb-j))\n                   (yj (nth 1 bomb-j)))\n              (when (<= (squared-distance xi yi xj yj) ri-sq)\n                (setf (aref adj i) (cons j (aref adj i)))))))))))\n\n;;; Perform BFS to count reachable nodes from a given start node\n(defun bfs-count (adj start)\n  (let ((visited (make-vector (length adj) nil))\n        (queue (list start))\n        (count 0))\n    (setf (aref visited start) t)\n    (while queue\n      (let ((current (pop queue)))\n        (setq count (1+ count))\n        (dolist (neighbor (aref adj current))\n          (unless (aref visited neighbor)\n            (setf (aref visited neighbor) t)\n            (push neighbor queue)))))\n    count))\n\n;;; Main function to find maximum detonation count\n(defun maximum-detonation (bombs)\n  (let* ((adj (build-adjacency-list bombs))\n         (max-count 0)\n         (n (length bombs)))\n    (dotimes (i n max-count)\n      (let ((count (bfs-count adj i)))\n        (when (> count max-count)\n          (setq max-count count))))))", "test_cases": "", "test_case_results": "", "task_id": 8345, "assertions": "(require 'cl-lib)\n\n(defun test-bomb-detonation ()\n  ;; Test case 1: Two bombs where one can detonate the other\n  (cl-assert (= (maximum-detonation '((2 1 3) (6 1 4))) 1))\n  \n  ;; Test case 2: Two identical bombs that can detonate each other\n  (cl-assert (= (maximum-detonation '((1 1 5) (1 1 5))) 2))\n  \n  ;; Test case 3: Chain of bombs where each can detonate the next\n  (cl-assert (= (maximum-detonation '((1 2 3) (2 3 1) (3 4 2) (4 5 3) (5 6 4))) 5)))\n\n(test-bomb-detonation)", "all_code": ";;; Implementation of bomb detonation problem in Emacs Lisp\n\n;;; The following function calculates the maximum number of bombs that can be detonated\n;;; by a single initial detonation. Each bomb is represented as (x y radius).\n\n;;; Helper function to calculate squared distance between two points\n(defun squared-distance (x1 y1 x2 y2)\n  (let ((dx (- x1 x2))\n        (dy (- y1 y2)))\n    (+ (* dx dx) (* dy dy))))\n\n;;; Build adjacency list for bombs\n(defun build-adjacency-list (bombs)\n  (let* ((n (length bombs))\n         (adj (make-vector n nil)))\n    (dotimes (i n adj)\n      (let* ((bomb-i (nth i bombs))\n             (xi (nth 0 bomb-i))\n             (yi (nth 1 bomb-i))\n             (ri (nth 2 bomb-i))\n             (ri-sq (* ri ri)))\n        (dotimes (j n)\n          (unless (= i j)\n            (let* ((bomb-j (nth j bombs))\n                   (xj (nth 0 bomb-j))\n                   (yj (nth 1 bomb-j)))\n              (when (<= (squared-distance xi yi xj yj) ri-sq)\n                (setf (aref adj i) (cons j (aref adj i)))))))))))\n\n;;; Perform BFS to count reachable nodes from a given start node\n(defun bfs-count (adj start)\n  (let ((visited (make-vector (length adj) nil))\n        (queue (list start))\n        (count 0))\n    (setf (aref visited start) t)\n    (while queue\n      (let ((current (pop queue)))\n        (setq count (1+ count))\n        (dolist (neighbor (aref adj current))\n          (unless (aref visited neighbor)\n            (setf (aref visited neighbor) t)\n            (push neighbor queue)))))\n    count))\n\n;;; Main function to find maximum detonation count\n(defun maximum-detonation (bombs)\n  (let* ((adj (build-adjacency-list bombs))\n         (max-count 0)\n         (n (length bombs)))\n    (dotimes (i n max-count)\n      (let ((count (bfs-count adj i)))\n        (when (> count max-count)\n          (setq max-count count))))))\n(require 'cl-lib)\n\n(defun test-bomb-detonation ()\n  ;; Test case 1: Two bombs where one can detonate the other\n  (cl-assert (= (maximum-detonation '((2 1 3) (6 1 4))) 1))\n  \n  ;; Test case 2: Two identical bombs that can detonate each other\n  (cl-assert (= (maximum-detonation '((1 1 5) (1 1 5))) 2))\n  \n  ;; Test case 3: Chain of bombs where each can detonate the next\n  (cl-assert (= (maximum-detonation '((1 2 3) (2 3 1) (3 4 2) (4 5 3) (5 6 4))) 5)))\n\n(test-bomb-detonation)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; find-substrings returns all unique substrings of length n in lexicographical order.\n;;; The function is case-sensitive.\n;;; If n is greater than the length of the input string, it returns nil.\n\n(defun find-substrings (s n)\n  \"Returns all unique substrings of length N in string S.\nThe substrings are returned in lexicographical order and are case-sensitive.\nIf N is greater than the length of S, returns nil.\"\n  (if (> n (length s))\n      nil\n    (let ((substrings ()))\n      ;; Generate all possible substrings of length n\n      (dotimes (i (- (length s) n -1))\n        (push (substring s i (+ i n)) substrings))\n      ;; Remove duplicates and sort\n      (sort (delete-dups substrings) 'string<))))", "test_cases": "", "test_case_results": "", "task_id": 17461, "assertions": "(require 'cl-lib)\n\n(defun test-find-substrings ()\n  (cl-assert (equal (find-substrings \"abcde\" 2) '(\"ab\" \"bc\" \"cd\" \"de\")))\n  (cl-assert (equal (find-substrings \"hello\" 3) '(\"ell\" \"hel\" \"llo\" \"lo\")))\n  (cl-assert (equal (find-substrings \"aabbb\" 2) '(\"aa\" \"ab\" \"bb\")))\n  (cl-assert (equal (find-substrings \"xyz\" 5) nil))\n  (cl-assert (equal (find-substrings \"CaseSensitive\" 4)\n                    '(\"Case\" \"Sens\" \"ensi\" \"itiv\" \"nsit\" \"sit\" \"siti\" \"tive\"))))\n\n(test-find-substrings)", "all_code": ";;; find-substrings returns all unique substrings of length n in lexicographical order.\n;;; The function is case-sensitive.\n;;; If n is greater than the length of the input string, it returns nil.\n\n(defun find-substrings (s n)\n  \"Returns all unique substrings of length N in string S.\nThe substrings are returned in lexicographical order and are case-sensitive.\nIf N is greater than the length of S, returns nil.\"\n  (if (> n (length s))\n      nil\n    (let ((substrings ()))\n      ;; Generate all possible substrings of length n\n      (dotimes (i (- (length s) n -1))\n        (push (substring s i (+ i n)) substrings))\n      ;; Remove duplicates and sort\n      (sort (delete-dups substrings) 'string<))))\n(require 'cl-lib)\n\n(defun test-find-substrings ()\n  (cl-assert (equal (find-substrings \"abcde\" 2) '(\"ab\" \"bc\" \"cd\" \"de\")))\n  (cl-assert (equal (find-substrings \"hello\" 3) '(\"ell\" \"hel\" \"llo\" \"lo\")))\n  (cl-assert (equal (find-substrings \"aabbb\" 2) '(\"aa\" \"ab\" \"bb\")))\n  (cl-assert (equal (find-substrings \"xyz\" 5) nil))\n  (cl-assert (equal (find-substrings \"CaseSensitive\" 4)\n                    '(\"Case\" \"Sens\" \"ensi\" \"itiv\" \"nsit\" \"sit\" \"siti\" \"tive\"))))\n\n(test-find-substrings)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Prime Binary Count Problem in Emacs Lisp\n\n;;; This code calculates how many numbers in a range [L, R] have a prime number\n;;; of 1's in their binary representation. It uses a sieve approach with prefix sums.\n\n;; Standard library requirements\n(require 'cl-lib)\n\n;; Define constants\n(defconst *max-n* 100000)\n(defconst *primes* '(2 3 5 7 11 13 17))\n\n;; count-ones returns the number of 1's in the binary representation of a number\n(defun count-ones (x)\n  \"Count the number of 1's in the binary representation of X.\"\n  (let ((count 0))\n    (while (> x 0)\n      (when (= (logand x 1) 1)\n        (cl-incf count))\n      (setq x (ash x -1)))\n    count))\n\n;; precompute-valid creates a vector where each element indicates if the number\n;; has a prime count of 1's in its binary representation\n(defun precompute-valid ()\n  \"Precompute a vector of valid numbers (prime binary 1's count).\"\n  (let ((valid (make-vector (1+ *max-n*) 0)))\n    (dotimes (x (1+ *max-n*))\n      (let ((cnt (count-ones x)))\n        (when (member cnt *primes*)\n          (aset valid x 1))))\n    valid))\n\n;; compute-prefix-sums creates a prefix sum array from the valid array\n(defun compute-prefix-sums (valid)\n  \"Compute prefix sums of the valid array.\"\n  (let ((prefix (make-vector (1+ *max-n*) 0)))\n    (aset prefix 0 (aref valid 0))\n    (dotimes (i *max-n*)\n      (aset prefix (1+ i) (+ (aref prefix i) (aref valid (1+ i)))))\n    prefix))\n\n;; count-primes-in-range calculates how many numbers in [L, R] have prime binary 1's\n(defun count-primes-in-range (prefix L R)\n  \"Count numbers with prime binary 1's in range [L, R] using prefix sums.\"\n  (if (= L 0)\n      (aref prefix R)\n    (- (aref prefix R) (aref prefix (1- L)))))", "test_cases": "", "test_case_results": "", "task_id": 21393, "assertions": "(require 'cl-lib)\n\n(defun test-prime-binary-count ()\n  (let* ((valid (precompute-valid))\n         (prefix (compute-prefix-sums valid)))\n    ;; Test cases from the original code\n    (cl-assert (= (count-primes-in-range prefix 0 10) 6))\n    (cl-assert (= (count-primes-in-range prefix 5 15) 5))\n    (cl-assert (= (count-primes-in-range prefix 10 20) 5))\n    (cl-assert (= (count-primes-in-range prefix 0 100) 33))\n    (cl-assert (= (count-primes-in-range prefix 99900 100000) 53))\n    (message \"All tests passed successfully!\")))\n\n(test-prime-binary-count)", "all_code": ";;; Prime Binary Count Problem in Emacs Lisp\n\n;;; This code calculates how many numbers in a range [L, R] have a prime number\n;;; of 1's in their binary representation. It uses a sieve approach with prefix sums.\n\n;; Standard library requirements\n(require 'cl-lib)\n\n;; Define constants\n(defconst *max-n* 100000)\n(defconst *primes* '(2 3 5 7 11 13 17))\n\n;; count-ones returns the number of 1's in the binary representation of a number\n(defun count-ones (x)\n  \"Count the number of 1's in the binary representation of X.\"\n  (let ((count 0))\n    (while (> x 0)\n      (when (= (logand x 1) 1)\n        (cl-incf count))\n      (setq x (ash x -1)))\n    count))\n\n;; precompute-valid creates a vector where each element indicates if the number\n;; has a prime count of 1's in its binary representation\n(defun precompute-valid ()\n  \"Precompute a vector of valid numbers (prime binary 1's count).\"\n  (let ((valid (make-vector (1+ *max-n*) 0)))\n    (dotimes (x (1+ *max-n*))\n      (let ((cnt (count-ones x)))\n        (when (member cnt *primes*)\n          (aset valid x 1))))\n    valid))\n\n;; compute-prefix-sums creates a prefix sum array from the valid array\n(defun compute-prefix-sums (valid)\n  \"Compute prefix sums of the valid array.\"\n  (let ((prefix (make-vector (1+ *max-n*) 0)))\n    (aset prefix 0 (aref valid 0))\n    (dotimes (i *max-n*)\n      (aset prefix (1+ i) (+ (aref prefix i) (aref valid (1+ i)))))\n    prefix))\n\n;; count-primes-in-range calculates how many numbers in [L, R] have prime binary 1's\n(defun count-primes-in-range (prefix L R)\n  \"Count numbers with prime binary 1's in range [L, R] using prefix sums.\"\n  (if (= L 0)\n      (aref prefix R)\n    (- (aref prefix R) (aref prefix (1- L)))))\n(require 'cl-lib)\n\n(defun test-prime-binary-count ()\n  (let* ((valid (precompute-valid))\n         (prefix (compute-prefix-sums valid)))\n    ;; Test cases from the original code\n    (cl-assert (= (count-primes-in-range prefix 0 10) 6))\n    (cl-assert (= (count-primes-in-range prefix 5 15) 5))\n    (cl-assert (= (count-primes-in-range prefix 10 20) 5))\n    (cl-assert (= (count-primes-in-range prefix 0 100) 33))\n    (cl-assert (= (count-primes-in-range prefix 99900 100000) 53))\n    (message \"All tests passed successfully!\")))\n\n(test-prime-binary-count)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This Emacs Lisp code implements the core logic of the provided Python code,\n;;; which counts the number of valid split points in a binary string with wildcards ('?').\n;;; A split point is valid if all characters before it can be interpreted as '1's\n;;; and all characters after it can be interpreted as '0's (with '?' being wildcards).\n\n;;; Function to check if all characters up to index i-1 can be '1's (or '?')\n(defun all-prefix-1-or-question (s i)\n  \"Check if all characters in string S up to index I-1 are '1' or '?'.\"\n  (catch 'break\n    (dotimes (j i t)\n      (let ((c (aref s j)))\n        (when (not (or (eq c ?1) (eq c ??)))\n          (throw 'break nil))))))\n\n;;; Function to check if all characters from index i to end can be '0's (or '?')\n(defun all-suffix-0-or-question (s i)\n  \"Check if all characters in string S from index I to end are '0' or '?'.\"\n  (catch 'break\n    (dotimes (j (- (length s) i) t)\n      (let ((c (aref s (+ i j))))\n        (when (not (or (eq c ?0) (eq c ??)))\n          (throw 'break nil))))))\n\n;;; Main function to count valid split points\n(defun count-valid-splits (s)\n  \"Count the number of valid split points in string S.\"\n  (let ((n (length s))\n        (res 0))\n    (dotimes (i n res)\n      (when (and (all-prefix-1-or-question s i)\n                 (all-suffix-0-or-question s i))\n        (setq res (1+ res))))))", "test_cases": "", "test_case_results": "", "task_id": 16277, "assertions": "(require 'cl-lib)\n\n(defun test-valid-splits ()\n  (cl-assert (= (count-valid-splits \"1?0\") 2))\n  (cl-assert (= (count-valid-splits \"0?1\") 0))\n  (cl-assert (= (count-valid-splits \"???\") 4))\n  (cl-assert (= (count-valid-splits \"1010\") 1))\n  (cl-assert (= (count-valid-splits \"1?1?0\") 2)))\n\n(test-valid-splits)", "all_code": ";;; This Emacs Lisp code implements the core logic of the provided Python code,\n;;; which counts the number of valid split points in a binary string with wildcards ('?').\n;;; A split point is valid if all characters before it can be interpreted as '1's\n;;; and all characters after it can be interpreted as '0's (with '?' being wildcards).\n\n;;; Function to check if all characters up to index i-1 can be '1's (or '?')\n(defun all-prefix-1-or-question (s i)\n  \"Check if all characters in string S up to index I-1 are '1' or '?'.\"\n  (catch 'break\n    (dotimes (j i t)\n      (let ((c (aref s j)))\n        (when (not (or (eq c ?1) (eq c ??)))\n          (throw 'break nil))))))\n\n;;; Function to check if all characters from index i to end can be '0's (or '?')\n(defun all-suffix-0-or-question (s i)\n  \"Check if all characters in string S from index I to end are '0' or '?'.\"\n  (catch 'break\n    (dotimes (j (- (length s) i) t)\n      (let ((c (aref s (+ i j))))\n        (when (not (or (eq c ?0) (eq c ??)))\n          (throw 'break nil))))))\n\n;;; Main function to count valid split points\n(defun count-valid-splits (s)\n  \"Count the number of valid split points in string S.\"\n  (let ((n (length s))\n        (res 0))\n    (dotimes (i n res)\n      (when (and (all-prefix-1-or-question s i)\n                 (all-suffix-0-or-question s i))\n        (setq res (1+ res))))))\n(require 'cl-lib)\n\n(defun test-valid-splits ()\n  (cl-assert (= (count-valid-splits \"1?0\") 2))\n  (cl-assert (= (count-valid-splits \"0?1\") 0))\n  (cl-assert (= (count-valid-splits \"???\") 4))\n  (cl-assert (= (count-valid-splits \"1010\") 1))\n  (cl-assert (= (count-valid-splits \"1?1?0\") 2)))\n\n(test-valid-splits)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Calculate payroll for an employee based on wage, hours worked, and bonus criteria.\n\n;; calculate-payroll computes the total weekly earnings for an employee.\n;; The function takes:\n;; - wage: hourly wage (integer)\n;; - hours: hours worked in the week (integer)\n;; - threshold: hours that must be exceeded to gain extra bonus (integer)\n;; - extra-bonus: additional bonus per hour beyond threshold (integer)\n;; Returns the total weekly earnings (integer).\n(defun calculate-payroll (wage hours threshold extra-bonus)\n  (let ((base-pay (* wage hours))\n        (bonus-pay (if (> hours threshold)\n                       (* (- hours threshold) extra-bonus)\n                     0)))\n    (+ base-pay bonus-pay)))", "test_cases": "", "test_case_results": "", "task_id": 28284, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-payroll ()\n  (cl-assert (= (calculate-payroll 10 40 40 5) 400))    ; No bonus\n  (cl-assert (= (calculate-payroll 15 45 40 10) 725))   ; 5 bonus hours (15*45 + 5*10)\n  (cl-assert (= (calculate-payroll 20 35 40 8) 700))   ; Below threshold\n  (cl-assert (= (calculate-payroll 12 50 45 15) 675)))  ; 5 bonus hours (12*50 + 5*15)\n\n(test-calculate-payroll)", "all_code": ";;; Calculate payroll for an employee based on wage, hours worked, and bonus criteria.\n\n;; calculate-payroll computes the total weekly earnings for an employee.\n;; The function takes:\n;; - wage: hourly wage (integer)\n;; - hours: hours worked in the week (integer)\n;; - threshold: hours that must be exceeded to gain extra bonus (integer)\n;; - extra-bonus: additional bonus per hour beyond threshold (integer)\n;; Returns the total weekly earnings (integer).\n(defun calculate-payroll (wage hours threshold extra-bonus)\n  (let ((base-pay (* wage hours))\n        (bonus-pay (if (> hours threshold)\n                       (* (- hours threshold) extra-bonus)\n                     0)))\n    (+ base-pay bonus-pay)))\n(require 'cl-lib)\n\n(defun test-calculate-payroll ()\n  (cl-assert (= (calculate-payroll 10 40 40 5) 400))    ; No bonus\n  (cl-assert (= (calculate-payroll 15 45 40 10) 725))   ; 5 bonus hours (15*45 + 5*10)\n  (cl-assert (= (calculate-payroll 20 35 40 8) 700))   ; Below threshold\n  (cl-assert (= (calculate-payroll 12 50 45 15) 675)))  ; 5 bonus hours (12*50 + 5*15)\n\n(test-calculate-payroll)", "exec_outcome": "PASSED"}
{"code": ";; Calculate the maximum area of a rectangle formed by 1s in a given binary matrix.\n;; The algorithm uses a histogram approach with a stack to efficiently compute the maximum area.\n(defun maximal-rectangle (matrix)\n  \"Calculate the maximum area of a rectangle formed by 1s in MATRIX.\nMATRIX should be a list of lists containing 0s and 1s as strings.\"\n  (if (or (null matrix) (null (car matrix)))\n      0\n    (let* ((n (length (car matrix)))\n           (heights (make-list (1+ n) 0))\n           (max-area 0))\n      (dolist (row matrix)\n        ;; Update heights for current row\n        (dotimes (i n)\n          (if (string= (nth i row) \"1\")\n              (setf (nth i heights) (1+ (nth i heights)))\n            (setf (nth i heights) 0)))\n        \n        ;; Calculate max area in current histogram using stack\n        (let ((stack '()))\n          (dotimes (i (1+ n))\n            (while (and stack (> (nth (car stack) heights) (nth i heights)))\n              (let* ((h (nth (pop stack) heights))\n                     (w (if (not stack) i (- i (car stack) 1))))\n                (setq max-area (max max-area (* h w)))))\n            (push i stack))))\n      max-area)))", "test_cases": "", "test_case_results": "", "task_id": 20642, "assertions": "(require 'cl-lib)\n\n(defun test-maximal-rectangle ()\n  \"Test cases for maximal-rectangle function.\"\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\" \"0\" \"1\" \"0\" \"0\")\n                   (\"1\" \"0\" \"1\" \"1\" \"1\")\n                   (\"1\" \"1\" \"1\" \"1\" \"1\")\n                   (\"1\" \"0\" \"0\" \"1\" \"0\")))\n                6))\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\" \"1\" \"0\" \"1\")))\n                2))\n  (cl-assert (= (maximal-rectangle '()) 0))\n  (cl-assert (= (maximal-rectangle\n                 '((\"0\" \"0\" \"0\")\n                   (\"0\" \"0\" \"0\")))\n                0))\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\") (\"1\") (\"0\")))\n                2)))\n\n(test-maximal-rectangle)", "all_code": ";; Calculate the maximum area of a rectangle formed by 1s in a given binary matrix.\n;; The algorithm uses a histogram approach with a stack to efficiently compute the maximum area.\n(defun maximal-rectangle (matrix)\n  \"Calculate the maximum area of a rectangle formed by 1s in MATRIX.\nMATRIX should be a list of lists containing 0s and 1s as strings.\"\n  (if (or (null matrix) (null (car matrix)))\n      0\n    (let* ((n (length (car matrix)))\n           (heights (make-list (1+ n) 0))\n           (max-area 0))\n      (dolist (row matrix)\n        ;; Update heights for current row\n        (dotimes (i n)\n          (if (string= (nth i row) \"1\")\n              (setf (nth i heights) (1+ (nth i heights)))\n            (setf (nth i heights) 0)))\n        \n        ;; Calculate max area in current histogram using stack\n        (let ((stack '()))\n          (dotimes (i (1+ n))\n            (while (and stack (> (nth (car stack) heights) (nth i heights)))\n              (let* ((h (nth (pop stack) heights))\n                     (w (if (not stack) i (- i (car stack) 1))))\n                (setq max-area (max max-area (* h w)))))\n            (push i stack))))\n      max-area)))\n(require 'cl-lib)\n\n(defun test-maximal-rectangle ()\n  \"Test cases for maximal-rectangle function.\"\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\" \"0\" \"1\" \"0\" \"0\")\n                   (\"1\" \"0\" \"1\" \"1\" \"1\")\n                   (\"1\" \"1\" \"1\" \"1\" \"1\")\n                   (\"1\" \"0\" \"0\" \"1\" \"0\")))\n                6))\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\" \"1\" \"0\" \"1\")))\n                2))\n  (cl-assert (= (maximal-rectangle '()) 0))\n  (cl-assert (= (maximal-rectangle\n                 '((\"0\" \"0\" \"0\")\n                   (\"0\" \"0\" \"0\")))\n                0))\n  (cl-assert (= (maximal-rectangle\n                 '((\"1\") (\"1\") (\"0\")))\n                2)))\n\n(test-maximal-rectangle)", "exec_outcome": "PASSED"}
{"code": ";;; Calculate total resistance of resistors arranged in series-parallel configuration\n\n;;; calculate-total-resistance computes the total resistance of resistors arranged in series-parallel.\n;;; Each sublist in the input represents a parallel group, and these groups are connected in series.\n;;; Input must be a list of lists with positive resistance values.\n;;; Returns the total resistance rounded to 3 decimal places.\n(defun calculate-total-resistance (resistors)\n  (cond\n   ;; Check for empty input or empty sublists\n   ((or (null resistors)\n        (not (seq-every-p #'identity resistors))\n        (catch 'negative-value\n          (dolist (group resistors)\n            (dolist (r group)\n              (when (<= r 0)\n                (throw 'negative-value t))))\n          nil))\n    (error \"Input must be a list of lists with positive resistance values.\"))\n   (t\n    (let ((total-resistance 0.0))\n      (dolist (parallel-group resistors total-resistance)\n        (let ((reciprocal-sum (apply '+ (mapcar (lambda (r) (/ 1.0 r)) parallel-group))))\n          (setq total-resistance (+ total-resistance (/ 1.0 reciprocal-sum)))))\n      (round (* total-resistance 1000) 3)))))", "test_cases": "", "test_case_results": "", "task_id": 12889, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-total-resistance ()\n  ;; Test cases from the original code\n  (cl-assert (= (calculate-total-resistance '((1 2 3))) 545))\n  (cl-assert (= (calculate-total-resistance '((1 1) (2 2 2))) 1500))\n  (cl-assert (= (calculate-total-resistance '((10 10 10) (20 20))) 1500))\n  (cl-assert (= (calculate-total-resistance '((0.5 1.0 1.5))) 818))\n  \n  ;; Test for error case (negative value)\n  (cl-assert (equal (condition-case err\n                        (calculate-total-resistance '((1 -1)))\n                      (error (error-message-string err)))\n                    \"Input must be a list of lists with positive resistance values.\")))\n\n(test-calculate-total-resistance)", "all_code": ";;; Calculate total resistance of resistors arranged in series-parallel configuration\n\n;;; calculate-total-resistance computes the total resistance of resistors arranged in series-parallel.\n;;; Each sublist in the input represents a parallel group, and these groups are connected in series.\n;;; Input must be a list of lists with positive resistance values.\n;;; Returns the total resistance rounded to 3 decimal places.\n(defun calculate-total-resistance (resistors)\n  (cond\n   ;; Check for empty input or empty sublists\n   ((or (null resistors)\n        (not (seq-every-p #'identity resistors))\n        (catch 'negative-value\n          (dolist (group resistors)\n            (dolist (r group)\n              (when (<= r 0)\n                (throw 'negative-value t))))\n          nil))\n    (error \"Input must be a list of lists with positive resistance values.\"))\n   (t\n    (let ((total-resistance 0.0))\n      (dolist (parallel-group resistors total-resistance)\n        (let ((reciprocal-sum (apply '+ (mapcar (lambda (r) (/ 1.0 r)) parallel-group))))\n          (setq total-resistance (+ total-resistance (/ 1.0 reciprocal-sum)))))\n      (round (* total-resistance 1000) 3)))))\n(require 'cl-lib)\n\n(defun test-calculate-total-resistance ()\n  ;; Test cases from the original code\n  (cl-assert (= (calculate-total-resistance '((1 2 3))) 545))\n  (cl-assert (= (calculate-total-resistance '((1 1) (2 2 2))) 1500))\n  (cl-assert (= (calculate-total-resistance '((10 10 10) (20 20))) 1500))\n  (cl-assert (= (calculate-total-resistance '((0.5 1.0 1.5))) 818))\n  \n  ;; Test for error case (negative value)\n  (cl-assert (equal (condition-case err\n                        (calculate-total-resistance '((1 -1)))\n                      (error (error-message-string err)))\n                    \"Input must be a list of lists with positive resistance values.\")))\n\n(test-calculate-total-resistance)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Solution for counting record days in a list of values\n\n;; count-record-days counts the number of record days in a list of values.\n;; A record day is defined as a day where the value is:\n;; 1. Greater than all previous values, and\n;; 2. Greater than the next day's value (or it's the last day)\n;; \n;; Parameters:\n;; - values: A list of integers representing daily values\n;;\n;; Returns:\n;; The number of record days in the input list\n(defun count-record-days (values)\n  (let ((max-so-far -1)\n        (record-days 0))\n    (dotimes (i (length values) record-days)\n      (let ((current (nth i values)))\n        ;; Check first condition: current > all previous days\n        (let ((condition1 (> current max-so-far)))\n          ;; Check second condition: current > next day or it's the last day\n          (let ((condition2 (or (= i (1- (length values)))\n                                (> current (nth (1+ i) values)))))\n            (when (and condition1 condition2)\n              (setq record-days (1+ record-days))))\n          ;; Update max-so-far for next iterations\n          (when (> current max-so-far)\n            (setq max-so-far current)))))))", "test_cases": "", "test_case_results": "", "task_id": 6378, "assertions": "(require 'cl-lib)\n\n(defun test-count-record-days ()\n  (cl-assert (= (count-record-days '(1 2 0 7 2 0 2 0)) 2))\n  (cl-assert (= (count-record-days '(4 8 15 16 23 42)) 1))\n  (cl-assert (= (count-record-days '(5 4 3 2 1)) 1))\n  (cl-assert (= (count-record-days '(1 1 1 1 1)) 0))\n  (cl-assert (= (count-record-days '(10 9 8 7 6 11)) 2)))\n\n(test-count-record-days)", "all_code": ";;; Solution for counting record days in a list of values\n\n;; count-record-days counts the number of record days in a list of values.\n;; A record day is defined as a day where the value is:\n;; 1. Greater than all previous values, and\n;; 2. Greater than the next day's value (or it's the last day)\n;; \n;; Parameters:\n;; - values: A list of integers representing daily values\n;;\n;; Returns:\n;; The number of record days in the input list\n(defun count-record-days (values)\n  (let ((max-so-far -1)\n        (record-days 0))\n    (dotimes (i (length values) record-days)\n      (let ((current (nth i values)))\n        ;; Check first condition: current > all previous days\n        (let ((condition1 (> current max-so-far)))\n          ;; Check second condition: current > next day or it's the last day\n          (let ((condition2 (or (= i (1- (length values)))\n                                (> current (nth (1+ i) values)))))\n            (when (and condition1 condition2)\n              (setq record-days (1+ record-days))))\n          ;; Update max-so-far for next iterations\n          (when (> current max-so-far)\n            (setq max-so-far current)))))))\n(require 'cl-lib)\n\n(defun test-count-record-days ()\n  (cl-assert (= (count-record-days '(1 2 0 7 2 0 2 0)) 2))\n  (cl-assert (= (count-record-days '(4 8 15 16 23 42)) 1))\n  (cl-assert (= (count-record-days '(5 4 3 2 1)) 1))\n  (cl-assert (= (count-record-days '(1 1 1 1 1)) 0))\n  (cl-assert (= (count-record-days '(10 9 8 7 6 11)) 2)))\n\n(test-count-record-days)", "exec_outcome": "PASSED"}
{"code": ";; This function processes a string L by applying a series of rotations\n;; specified by commands, where each command is a number followed by 'L' or 'R'.\n;; The number indicates how many positions to rotate, and the letter indicates direction.\n(defun process-password-case (L commands)\n  \"Process password case with string L and list of rotation commands.\nL is the input string, commands is a list of strings where each string\nis a number followed by 'L' or 'R' (e.g., \\\"3L\\\" or \\\"2R\\\").\"\n  (let ((len-L (length L))\n        (current-pos 0))\n    ;; Process each command\n    (dolist (cmd commands)\n      (let* ((d-part (substring cmd (1- (length cmd)))) ; Last character (L/R)\n             (m-part (substring cmd 0 (1- (length cmd)))) ; Everything except last char\n             (M (string-to-number m-part))\n             (effective-m (mod M len-L)))\n        (unless (zerop effective-m)\n          (let ((delta (if (string= d-part \"L\")\n                           effective-m\n                         (- effective-m))))\n            (setq current-pos (mod (+ current-pos delta) len-L))))))\n    ;; Generate the password by rotating the string\n    (let ((password \"\"))\n      (dotimes (i len-L)\n        (let ((idx (mod (+ current-pos i) len-L)))\n          (setq password (concat password (substring L idx (1+ idx))))))\n      password)))", "test_cases": "", "test_case_results": "", "task_id": 15890, "assertions": "(require 'cl-lib)\n\n(defun test-process-password-case ()\n  \"Test the process-password-case function with assertions.\"\n  (cl-assert (string= (process-password-case \"abcde\" '(\"1L\" \"2R\" \"3L\")) \"bcdea\"))\n  (cl-assert (string= (process-password-case \"hello\" '(\"2R\" \"3L\" \"1R\")) \"lohel\"))\n  (cl-assert (string= (process-password-case \"world\" '(\"5L\" \"5R\" \"1L\")) \"orldw\"))\n  (cl-assert (string= (process-password-case \"emacs\" '(\"0L\" \"0R\" \"1R\")) \"macse\")))\n\n(test-process-password-case)", "all_code": ";; This function processes a string L by applying a series of rotations\n;; specified by commands, where each command is a number followed by 'L' or 'R'.\n;; The number indicates how many positions to rotate, and the letter indicates direction.\n(defun process-password-case (L commands)\n  \"Process password case with string L and list of rotation commands.\nL is the input string, commands is a list of strings where each string\nis a number followed by 'L' or 'R' (e.g., \\\"3L\\\" or \\\"2R\\\").\"\n  (let ((len-L (length L))\n        (current-pos 0))\n    ;; Process each command\n    (dolist (cmd commands)\n      (let* ((d-part (substring cmd (1- (length cmd)))) ; Last character (L/R)\n             (m-part (substring cmd 0 (1- (length cmd)))) ; Everything except last char\n             (M (string-to-number m-part))\n             (effective-m (mod M len-L)))\n        (unless (zerop effective-m)\n          (let ((delta (if (string= d-part \"L\")\n                           effective-m\n                         (- effective-m))))\n            (setq current-pos (mod (+ current-pos delta) len-L))))))\n    ;; Generate the password by rotating the string\n    (let ((password \"\"))\n      (dotimes (i len-L)\n        (let ((idx (mod (+ current-pos i) len-L)))\n          (setq password (concat password (substring L idx (1+ idx))))))\n      password)))\n(require 'cl-lib)\n\n(defun test-process-password-case ()\n  \"Test the process-password-case function with assertions.\"\n  (cl-assert (string= (process-password-case \"abcde\" '(\"1L\" \"2R\" \"3L\")) \"bcdea\"))\n  (cl-assert (string= (process-password-case \"hello\" '(\"2R\" \"3L\" \"1R\")) \"lohel\"))\n  (cl-assert (string= (process-password-case \"world\" '(\"5L\" \"5R\" \"1L\")) \"orldw\"))\n  (cl-assert (string= (process-password-case \"emacs\" '(\"0L\" \"0R\" \"1R\")) \"macse\")))\n\n(test-process-password-case)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Function to extract unique characters from a string while preserving order\n\n;; unique-characters converts a string to a list containing all unique characters\n;; of the string, preserving the order in which they were first encountered.\n;; This implementation uses a hash table to track seen characters for O(1) lookups.\n(defun unique-characters (s)\n  (let ((seen (make-hash-table :test 'equal)) ; Use equal for character comparison\n        (unique-chars '()))\n    (dolist (char (string-to-list s) (nreverse unique-chars)) ; Convert string to list of chars\n      (unless (gethash char seen)\n        (puthash char t seen)\n        (setq unique-chars (cons char unique-chars))))))", "test_cases": "", "test_case_results": "", "task_id": 23145, "assertions": "(require 'cl-lib)\n\n(defun test-unique-characters ()\n  (cl-assert (equal (unique-characters \"\") nil))\n  (cl-assert (equal (unique-characters \"abc\") '(?a ?b ?c)))\n  (cl-assert (equal (unique-characters \"aaa\") '(?a)))\n  (cl-assert (equal (unique-characters \"abcabc\") '(?a ?b ?c)))\n  (cl-assert (equal (unique-characters \"hello world\") '(?h ?e ?l ?o ? ?w ?r ?d))))\n\n(test-unique-characters)", "all_code": ";;; Function to extract unique characters from a string while preserving order\n\n;; unique-characters converts a string to a list containing all unique characters\n;; of the string, preserving the order in which they were first encountered.\n;; This implementation uses a hash table to track seen characters for O(1) lookups.\n(defun unique-characters (s)\n  (let ((seen (make-hash-table :test 'equal)) ; Use equal for character comparison\n        (unique-chars '()))\n    (dolist (char (string-to-list s) (nreverse unique-chars)) ; Convert string to list of chars\n      (unless (gethash char seen)\n        (puthash char t seen)\n        (setq unique-chars (cons char unique-chars))))))\n(require 'cl-lib)\n\n(defun test-unique-characters ()\n  (cl-assert (equal (unique-characters \"\") nil))\n  (cl-assert (equal (unique-characters \"abc\") '(?a ?b ?c)))\n  (cl-assert (equal (unique-characters \"aaa\") '(?a)))\n  (cl-assert (equal (unique-characters \"abcabc\") '(?a ?b ?c)))\n  (cl-assert (equal (unique-characters \"hello world\") '(?h ?e ?l ?o ? ?w ?r ?d))))\n\n(test-unique-characters)", "exec_outcome": "PASSED"}
{"code": ";; largest-sum-of-two-elements calculates the largest sum obtainable by summing exactly two distinct elements from the list.\n;; If there are fewer than two elements in the input list, it returns -1.\n(defun largest-sum-of-two-elements (lst)\n  (if (< (length lst) 2)\n      -1\n    (let ((sorted-lst (sort (copy-sequence lst) '>)))\n      (+ (nth 0 sorted-lst) (nth 1 sorted-lst)))))", "test_cases": "", "test_case_results": "", "task_id": 25096, "assertions": "(require 'cl-lib)\n\n(defun test-largest-sum-of-two-elements ()\n  (cl-assert (= (largest-sum-of-two-elements '(1 2 3 4)) 7))\n  (cl-assert (= (largest-sum-of-two-elements '(5 6 7 0)) 13))\n  (cl-assert (= (largest-sum-of-two-elements '(0 0 0 0)) 0))\n  (cl-assert (= (largest-sum-of-two-elements '(1)) -1))\n  (cl-assert (= (largest-sum-of-two-elements '()) -1)))\n\n(test-largest-sum-of-two-elements)", "all_code": ";; largest-sum-of-two-elements calculates the largest sum obtainable by summing exactly two distinct elements from the list.\n;; If there are fewer than two elements in the input list, it returns -1.\n(defun largest-sum-of-two-elements (lst)\n  (if (< (length lst) 2)\n      -1\n    (let ((sorted-lst (sort (copy-sequence lst) '>)))\n      (+ (nth 0 sorted-lst) (nth 1 sorted-lst)))))\n(require 'cl-lib)\n\n(defun test-largest-sum-of-two-elements ()\n  (cl-assert (= (largest-sum-of-two-elements '(1 2 3 4)) 7))\n  (cl-assert (= (largest-sum-of-two-elements '(5 6 7 0)) 13))\n  (cl-assert (= (largest-sum-of-two-elements '(0 0 0 0)) 0))\n  (cl-assert (= (largest-sum-of-two-elements '(1)) -1))\n  (cl-assert (= (largest-sum-of-two-elements '()) -1)))\n\n(test-largest-sum-of-two-elements)", "exec_outcome": "PASSED"}
{"code": ";; Function to count the number of divisors for a given number\n(defun count-divisors (m)\n  \"Count the number of divisors for a given integer M.\nReturns 0 if M is 0, otherwise returns the count of divisors.\"\n  (if (= m 0)\n      0\n    (let ((count 0)\n          (sqrt-m (floor (sqrt m))))\n      (dotimes (d sqrt-m count)\n        (setq d (1+ d)) ; dotimes starts from 0, we need from 1\n        (when (= 0 (% m d))\n          (if (= d (/ m d))\n              (setq count (1+ count))\n            (setq count (+ count 2))))))))\n\n;; Function to generate and print the grid based on divisor counts\n(defun generate-divisor-grid (n k)\n  \"Generate an N x N grid where each cell contains '*' if its number\nhas K or fewer divisors, otherwise contains '.'.\"\n  (dotimes (i n)\n    (let ((row \"\"))\n      (dotimes (j n)\n        (let* ((num (+ (* i n) j 1))\n               (cnt (count-divisors num)))\n          (setq row (concat row (if (<= cnt k) \"*\" \".\")))))\n      (message \"%s\" row))))", "test_cases": "", "test_case_results": "", "task_id": 25468, "assertions": "(require 'cl-lib)\n\n(defun test-divisor-functions ()\n  \"Test the count-divisors function with known values.\"\n  (cl-assert (= (count-divisors 0) 0))\n  (cl-assert (= (count-divisors 1) 1))\n  (cl-assert (= (count-divisors 2) 2))\n  (cl-assert (= (count-divisors 3) 2))\n  (cl-assert (= (count-divisors 4) 3))\n  (cl-assert (= (count-divisors 5) 2))\n  (cl-assert (= (count-divisors 6) 4))\n  (cl-assert (= (count-divisors 7) 2))\n  (cl-assert (= (count-divisors 8) 4))\n  (cl-assert (= (count-divisors 9) 3))\n  (cl-assert (= (count-divisors 10) 4))\n  (message \"All tests passed!\"))\n\n(test-divisor-functions)", "all_code": ";; Function to count the number of divisors for a given number\n(defun count-divisors (m)\n  \"Count the number of divisors for a given integer M.\nReturns 0 if M is 0, otherwise returns the count of divisors.\"\n  (if (= m 0)\n      0\n    (let ((count 0)\n          (sqrt-m (floor (sqrt m))))\n      (dotimes (d sqrt-m count)\n        (setq d (1+ d)) ; dotimes starts from 0, we need from 1\n        (when (= 0 (% m d))\n          (if (= d (/ m d))\n              (setq count (1+ count))\n            (setq count (+ count 2))))))))\n\n;; Function to generate and print the grid based on divisor counts\n(defun generate-divisor-grid (n k)\n  \"Generate an N x N grid where each cell contains '*' if its number\nhas K or fewer divisors, otherwise contains '.'.\"\n  (dotimes (i n)\n    (let ((row \"\"))\n      (dotimes (j n)\n        (let* ((num (+ (* i n) j 1))\n               (cnt (count-divisors num)))\n          (setq row (concat row (if (<= cnt k) \"*\" \".\")))))\n      (message \"%s\" row))))\n(require 'cl-lib)\n\n(defun test-divisor-functions ()\n  \"Test the count-divisors function with known values.\"\n  (cl-assert (= (count-divisors 0) 0))\n  (cl-assert (= (count-divisors 1) 1))\n  (cl-assert (= (count-divisors 2) 2))\n  (cl-assert (= (count-divisors 3) 2))\n  (cl-assert (= (count-divisors 4) 3))\n  (cl-assert (= (count-divisors 5) 2))\n  (cl-assert (= (count-divisors 6) 4))\n  (cl-assert (= (count-divisors 7) 2))\n  (cl-assert (= (count-divisors 8) 4))\n  (cl-assert (= (count-divisors 9) 3))\n  (cl-assert (= (count-divisors 10) 4))\n  (message \"All tests passed!\"))\n\n(test-divisor-functions)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; This function calculates the maximum number of groups of 3 elements that can be formed\n;; from a sorted list where the difference between the first and last element in each group is <= k.\n;; The function sorts the list first, then iterates through it to form valid groups.\n;; n is the length of the list, k is the maximum allowed difference, and arr is the list of numbers.\n(defun max-groups (n k arr)\n  (let ((sorted-arr (sort (copy-sequence arr) '<))\n        (count 0)\n        (i 0))\n    (while (< (+ i 2) n)\n      (if (<= (- (nth (+ i 2) sorted-arr) (nth i sorted-arr)) k)\n          (progn\n            (setq count (1+ count))\n            (setq i (+ i 3)))\n        (setq i (1+ i))))\n    count))", "test_cases": "", "test_case_results": "", "task_id": 29004, "assertions": "(require 'cl-lib)\n\n(defun test-max-groups ()\n  (cl-assert (= (max-groups 5 2 '(3 1 4 2 5)) 1))\n  (cl-assert (= (max-groups 6 3 '(1 2 3 4 5 6)) 2))\n  (cl-assert (= (max-groups 7 1 '(1 1 1 2 2 2 3)) 2)))\n\n(test-max-groups)", "all_code": ";; This function calculates the maximum number of groups of 3 elements that can be formed\n;; from a sorted list where the difference between the first and last element in each group is <= k.\n;; The function sorts the list first, then iterates through it to form valid groups.\n;; n is the length of the list, k is the maximum allowed difference, and arr is the list of numbers.\n(defun max-groups (n k arr)\n  (let ((sorted-arr (sort (copy-sequence arr) '<))\n        (count 0)\n        (i 0))\n    (while (< (+ i 2) n)\n      (if (<= (- (nth (+ i 2) sorted-arr) (nth i sorted-arr)) k)\n          (progn\n            (setq count (1+ count))\n            (setq i (+ i 3)))\n        (setq i (1+ i))))\n    count))\n(require 'cl-lib)\n\n(defun test-max-groups ()\n  (cl-assert (= (max-groups 5 2 '(3 1 4 2 5)) 1))\n  (cl-assert (= (max-groups 6 3 '(1 2 3 4 5 6)) 2))\n  (cl-assert (= (max-groups 7 1 '(1 1 1 2 2 2 3)) 2)))\n\n(test-max-groups)", "exec_outcome": "PASSED"}
{"code": ";;; Function to calculate the minimum number of changes required to follow health guidelines\n;;; The guideline states that there should be no two consecutive '1's in the string.\n;;; The function iterates through the string and counts the changes needed to ensure this.\n\n(defun min-changes-to-follow-guideline (s)\n  \"Returns the minimum number of changes required to follow the health guidelines.\nThe input S is a string consisting of '0's and '1's. The function ensures that\nthere are no two consecutive '1's by changing the second '1' to '0' and counting\nthe number of such changes.\"\n  (let ((prev-char nil)\n        (changes 0))\n    (dolist (char (string-to-list s) changes)\n      (when (and (eq prev-char ?1) (eq char ?1))\n        (setq changes (1+ changes))\n        (setq char ?0)) ; Change current '1' to '0'\n      (setq prev-char char))))", "test_cases": "", "test_case_results": "", "task_id": 2967, "assertions": "(require 'cl-lib)\n\n(defun test-min-changes-to-follow-guideline ()\n  (cl-assert (= (min-changes-to-follow-guideline \"1101\") 1))\n  (cl-assert (= (min-changes-to-follow-guideline \"1111\") 2))\n  (cl-assert (= (min-changes-to-follow-guideline \"1010\") 0))\n  (cl-assert (= (min-changes-to-follow-guideline \"0000\") 0))\n  (cl-assert (= (min-changes-to-follow-guideline \"0101\") 0)))\n\n(test-min-changes-to-follow-guideline)", "all_code": ";;; Function to calculate the minimum number of changes required to follow health guidelines\n;;; The guideline states that there should be no two consecutive '1's in the string.\n;;; The function iterates through the string and counts the changes needed to ensure this.\n\n(defun min-changes-to-follow-guideline (s)\n  \"Returns the minimum number of changes required to follow the health guidelines.\nThe input S is a string consisting of '0's and '1's. The function ensures that\nthere are no two consecutive '1's by changing the second '1' to '0' and counting\nthe number of such changes.\"\n  (let ((prev-char nil)\n        (changes 0))\n    (dolist (char (string-to-list s) changes)\n      (when (and (eq prev-char ?1) (eq char ?1))\n        (setq changes (1+ changes))\n        (setq char ?0)) ; Change current '1' to '0'\n      (setq prev-char char))))\n(require 'cl-lib)\n\n(defun test-min-changes-to-follow-guideline ()\n  (cl-assert (= (min-changes-to-follow-guideline \"1101\") 1))\n  (cl-assert (= (min-changes-to-follow-guideline \"1111\") 2))\n  (cl-assert (= (min-changes-to-follow-guideline \"1010\") 0))\n  (cl-assert (= (min-changes-to-follow-guideline \"0000\") 0))\n  (cl-assert (= (min-changes-to-follow-guideline \"0101\") 0)))\n\n(test-min-changes-to-follow-guideline)", "exec_outcome": "PASSED"}
{"code": ";;; This function converts a time string in \"HH:MM\" format to total minutes.\n;;; For example, \"01:30\" becomes 90 minutes.\n(defun to-minutes (hh-mm)\n  \"Convert HH:MM time string to total minutes.\"\n  (let ((time-parts (split-string hh-mm \":\")))\n    (+ (* (string-to-number (nth 0 time-parts)) 60)\n       (string-to-number (nth 1 time-parts)))))\n\n;;; Determines the usage category based on total usage time.\n;;; The input is a list of sessions, where each session is a cons cell of start and end times in \"HH:MM\" format.\n;;; Returns 'Light' if total hours <= 2, 'Moderate' if <= 5, otherwise 'Heavy'.\n(defun usage-category (sessions)\n  \"Determine usage category from list of (start . end) time sessions.\"\n  (let ((total-minutes 0))\n    (dolist (session sessions total-minutes)\n      (let ((start-minutes (to-minutes (car session)))\n            (end-minutes (to-minutes (cdr session))))\n        (setq total-minutes (+ total-minutes (- end-minutes start-minutes)))))\n    (let ((hours (/ total-minutes 60.0)))\n      (cond\n       ((<= hours 2) \"Light\")\n       ((<= hours 5) \"Moderate\")\n       (t \"Heavy\")))))", "test_cases": "", "test_case_results": "", "task_id": 13925, "assertions": "(require 'cl-lib)\n\n(defun test-usage-category ()\n  (cl-assert (string= (usage-category '((\"09:00\" . \"10:30\"))) \"Light\"))\n  (cl-assert (string= (usage-category '((\"08:00\" . \"10:00\") (\"13:00\" . \"14:30\"))) \"Moderate\"))\n  (cl-assert (string= (usage-category '((\"09:00\" . \"12:00\") (\"13:00\" . \"17:00\"))) \"Heavy\")))\n\n(test-usage-category)", "all_code": ";;; This function converts a time string in \"HH:MM\" format to total minutes.\n;;; For example, \"01:30\" becomes 90 minutes.\n(defun to-minutes (hh-mm)\n  \"Convert HH:MM time string to total minutes.\"\n  (let ((time-parts (split-string hh-mm \":\")))\n    (+ (* (string-to-number (nth 0 time-parts)) 60)\n       (string-to-number (nth 1 time-parts)))))\n\n;;; Determines the usage category based on total usage time.\n;;; The input is a list of sessions, where each session is a cons cell of start and end times in \"HH:MM\" format.\n;;; Returns 'Light' if total hours <= 2, 'Moderate' if <= 5, otherwise 'Heavy'.\n(defun usage-category (sessions)\n  \"Determine usage category from list of (start . end) time sessions.\"\n  (let ((total-minutes 0))\n    (dolist (session sessions total-minutes)\n      (let ((start-minutes (to-minutes (car session)))\n            (end-minutes (to-minutes (cdr session))))\n        (setq total-minutes (+ total-minutes (- end-minutes start-minutes)))))\n    (let ((hours (/ total-minutes 60.0)))\n      (cond\n       ((<= hours 2) \"Light\")\n       ((<= hours 5) \"Moderate\")\n       (t \"Heavy\")))))\n(require 'cl-lib)\n\n(defun test-usage-category ()\n  (cl-assert (string= (usage-category '((\"09:00\" . \"10:30\"))) \"Light\"))\n  (cl-assert (string= (usage-category '((\"08:00\" . \"10:00\") (\"13:00\" . \"14:30\"))) \"Moderate\"))\n  (cl-assert (string= (usage-category '((\"09:00\" . \"12:00\") (\"13:00\" . \"17:00\"))) \"Heavy\")))\n\n(test-usage-category)", "exec_outcome": "PASSED"}
{"code": ";; Extended GCD implementation in Emacs Lisp\n;; This function computes the greatest common divisor (g) of two numbers (a and b)\n;; and also finds the coefficients x and y such that: a*x + b*y = g\n(defun extended-gcd (a b)\n  \"Compute extended GCD of A and B, returning (g x y) where:\ng is the GCD of A and B,\nx and y are coefficients satisfying A*x + B*y = g.\"\n  (if (= b 0)\n      (list a 1 0)\n    (let* ((result (extended-gcd b (% a b)))\n           (g (nth 0 result))\n           (x (nth 1 result))\n           (y (nth 2 result)))\n      (list g y (- x (* (/ a b) y))))))\n\n;; Function to compute the modular inverse using extended GCD\n(defun modular-inverse (a b)\n  \"Compute the modular inverse of A modulo B.\nReturns the smallest positive x such that (A*x) mod B = 1.\"\n  (let* ((result (extended-gcd a b))\n         (g (nth 0 result))\n         (x (nth 1 result))\n         (x0 (% x b)))\n    (if (<= x0 0)\n        (+ x0 b)\n      x0)))", "test_cases": "", "test_case_results": "", "task_id": 1672, "assertions": "(require 'cl-lib)\n\n(defun test-modular-inverse ()\n  (cl-assert (= (modular-inverse 7 11) 8))\n  (cl-assert (= (modular-inverse 3 10) 7))\n  (cl-assert (= (modular-inverse 5 12) 5))\n  (cl-assert (= (modular-inverse 2 9) 5))\n  ;; Verification tests\n  (cl-assert (= (% (* 7 8) 11) 1))\n  (cl-assert (= (% (* 3 7) 10) 1))\n  (cl-assert (= (% (* 5 5) 12) 1))\n  (cl-assert (= (% (* 2 5) 9) 1)))\n\n(test-modular-inverse)", "all_code": ";; Extended GCD implementation in Emacs Lisp\n;; This function computes the greatest common divisor (g) of two numbers (a and b)\n;; and also finds the coefficients x and y such that: a*x + b*y = g\n(defun extended-gcd (a b)\n  \"Compute extended GCD of A and B, returning (g x y) where:\ng is the GCD of A and B,\nx and y are coefficients satisfying A*x + B*y = g.\"\n  (if (= b 0)\n      (list a 1 0)\n    (let* ((result (extended-gcd b (% a b)))\n           (g (nth 0 result))\n           (x (nth 1 result))\n           (y (nth 2 result)))\n      (list g y (- x (* (/ a b) y))))))\n\n;; Function to compute the modular inverse using extended GCD\n(defun modular-inverse (a b)\n  \"Compute the modular inverse of A modulo B.\nReturns the smallest positive x such that (A*x) mod B = 1.\"\n  (let* ((result (extended-gcd a b))\n         (g (nth 0 result))\n         (x (nth 1 result))\n         (x0 (% x b)))\n    (if (<= x0 0)\n        (+ x0 b)\n      x0)))\n(require 'cl-lib)\n\n(defun test-modular-inverse ()\n  (cl-assert (= (modular-inverse 7 11) 8))\n  (cl-assert (= (modular-inverse 3 10) 7))\n  (cl-assert (= (modular-inverse 5 12) 5))\n  (cl-assert (= (modular-inverse 2 9) 5))\n  ;; Verification tests\n  (cl-assert (= (% (* 7 8) 11) 1))\n  (cl-assert (= (% (* 3 7) 10) 1))\n  (cl-assert (= (% (* 5 5) 12) 1))\n  (cl-assert (= (% (* 2 5) 9) 1)))\n\n(test-modular-inverse)", "exec_outcome": "PASSED"}
{"code": ";;; Simulate a battle between Godzilla and MechaGodzilla armies\n;;; The winner is determined by comparing the strongest monsters from each army\n\n;;; determine-winner takes two lists representing army strengths and returns the winner\n;;; The army with the strongest monster wins; if equal, Godzilla wins by default\n(defun determine-winner (godzilla mecha)\n  (let ((g-max (apply 'max godzilla))\n        (m-max (apply 'max mecha)))\n    (if (>= g-max m-max)\n        \"Godzilla\"\n      \"MechaGodzilla\")))", "test_cases": "", "test_case_results": "", "task_id": 1768, "assertions": "(require 'cl-lib)\n\n(defun test-battle-simulation ()\n  (cl-assert (string= (determine-winner '(1 2 3 4) '(5 6 7 8)) \"MechaGodzilla\"))\n  (cl-assert (string= (determine-winner '(10 20 30) '(5 15 25)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(5 10 15) '(5 10 15)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(0) '(0)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(100) '(99)) \"Godzilla\")))\n\n(test-battle-simulation)", "all_code": ";;; Simulate a battle between Godzilla and MechaGodzilla armies\n;;; The winner is determined by comparing the strongest monsters from each army\n\n;;; determine-winner takes two lists representing army strengths and returns the winner\n;;; The army with the strongest monster wins; if equal, Godzilla wins by default\n(defun determine-winner (godzilla mecha)\n  (let ((g-max (apply 'max godzilla))\n        (m-max (apply 'max mecha)))\n    (if (>= g-max m-max)\n        \"Godzilla\"\n      \"MechaGodzilla\")))\n(require 'cl-lib)\n\n(defun test-battle-simulation ()\n  (cl-assert (string= (determine-winner '(1 2 3 4) '(5 6 7 8)) \"MechaGodzilla\"))\n  (cl-assert (string= (determine-winner '(10 20 30) '(5 15 25)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(5 10 15) '(5 10 15)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(0) '(0)) \"Godzilla\"))\n  (cl-assert (string= (determine-winner '(100) '(99)) \"Godzilla\")))\n\n(test-battle-simulation)", "exec_outcome": "PASSED"}
{"code": ";;; Function to rearrange characters of a string according to given indices\n\n;; restore-string rearranges the characters of the string according to the specified indices.\n;; It takes a string and a list of indices, then returns a new string with characters in the specified order.\n(defun restore-string (s indices)\n  \"Rearrange characters of string S according to positions in INDICES.\nS should be a string of lowercase English letters.\nINDICES should be a list of integers specifying final positions.\nReturns the rearranged string.\"\n  (let ((restored (make-list (length s) nil)))\n    (dotimes (i (length s))\n      (setf (nth (nth i indices) restored) (substring s i (1+ i))))\n    (apply 'concat restored)))", "test_cases": "", "test_case_results": "", "task_id": 1868, "assertions": "(require 'cl-lib)\n\n(defun test-restore-string ()\n  (cl-assert (string= (restore-string \"code\" '(3 1 2 0)) \"dcoe\"))\n  (cl-assert (string= (restore-string \"abc\" '(0 1 2)) \"abc\"))\n  (cl-assert (string= (restore-string \"aiohn\" '(3 1 4 2 0)) \"nihao\"))\n  (cl-assert (string= (restore-string \"art\" '(1 0 2)) \"rat\")))\n\n(test-restore-string)", "all_code": ";;; Function to rearrange characters of a string according to given indices\n\n;; restore-string rearranges the characters of the string according to the specified indices.\n;; It takes a string and a list of indices, then returns a new string with characters in the specified order.\n(defun restore-string (s indices)\n  \"Rearrange characters of string S according to positions in INDICES.\nS should be a string of lowercase English letters.\nINDICES should be a list of integers specifying final positions.\nReturns the rearranged string.\"\n  (let ((restored (make-list (length s) nil)))\n    (dotimes (i (length s))\n      (setf (nth (nth i indices) restored) (substring s i (1+ i))))\n    (apply 'concat restored)))\n(require 'cl-lib)\n\n(defun test-restore-string ()\n  (cl-assert (string= (restore-string \"code\" '(3 1 2 0)) \"dcoe\"))\n  (cl-assert (string= (restore-string \"abc\" '(0 1 2)) \"abc\"))\n  (cl-assert (string= (restore-string \"aiohn\" '(3 1 4 2 0)) \"nihao\"))\n  (cl-assert (string= (restore-string \"art\" '(1 0 2)) \"rat\")))\n\n(test-restore-string)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This Emacs Lisp code implements the rotation of an array to the right by k steps in-place.\n;;; The core logic involves reversing parts of the array to achieve the rotation.\n\n(require 'cl-lib) ; Required for cl-subseq function\n\n;; rotate-array rotates the given list to the right by k steps in-place.\n;; The function modifies the original list and does not return a new list.\n(defun rotate-array (nums k)\n  \"Rotate the list NUMS to the right by K steps in-place.\"\n  (let* ((n (length nums))\n         (k (mod k n))) ; Calculate modulo to handle k greater than the length of nums\n    ;; Reverse the entire list\n    (setq nums (reverse nums))\n    ;; Reverse the first k elements\n    (setq nums (append (reverse (cl-subseq nums 0 k)) (cl-subseq nums k)))\n    ;; Reverse the remaining elements\n    (setq nums (append (cl-subseq nums 0 k) (reverse (cl-subseq nums k))))\n    nums))", "test_cases": "", "test_case_results": "", "task_id": 15022, "assertions": "(require 'cl-lib)\n\n(defun test-rotate-array ()\n  (cl-assert (equal (rotate-array '(1 2 3 4 5 6 7) 3) '(5 6 7 1 2 3 4)))\n  (cl-assert (equal (rotate-array '(-1 -100 3 99) 2) '(3 99 -1 -100)))\n  (cl-assert (equal (rotate-array '(1 2 3 4) 4) '(1 2 3 4))))\n\n(test-rotate-array)", "all_code": ";;; This Emacs Lisp code implements the rotation of an array to the right by k steps in-place.\n;;; The core logic involves reversing parts of the array to achieve the rotation.\n\n(require 'cl-lib) ; Required for cl-subseq function\n\n;; rotate-array rotates the given list to the right by k steps in-place.\n;; The function modifies the original list and does not return a new list.\n(defun rotate-array (nums k)\n  \"Rotate the list NUMS to the right by K steps in-place.\"\n  (let* ((n (length nums))\n         (k (mod k n))) ; Calculate modulo to handle k greater than the length of nums\n    ;; Reverse the entire list\n    (setq nums (reverse nums))\n    ;; Reverse the first k elements\n    (setq nums (append (reverse (cl-subseq nums 0 k)) (cl-subseq nums k)))\n    ;; Reverse the remaining elements\n    (setq nums (append (cl-subseq nums 0 k) (reverse (cl-subseq nums k))))\n    nums))\n(require 'cl-lib)\n\n(defun test-rotate-array ()\n  (cl-assert (equal (rotate-array '(1 2 3 4 5 6 7) 3) '(5 6 7 1 2 3 4)))\n  (cl-assert (equal (rotate-array '(-1 -100 3 99) 2) '(3 99 -1 -100)))\n  (cl-assert (equal (rotate-array '(1 2 3 4) 4) '(1 2 3 4))))\n\n(test-rotate-array)", "exec_outcome": "PASSED"}
{"code": ";;; This code implements a lookup function for precomputed values of permutations\n;;; avoiding the consecutive pattern 123 (OEIS sequence A117158).\n;;; The function simply returns the value from a precomputed list based on the input index.\n\n;; Define the precomputed values as a list where the index corresponds to n\n(defconst *precomputed-permutation-counts*\n  '(1    ; n=0\n    1    ; n=1\n    2    ; n=2\n    5    ; n=3\n    16   ; n=4\n    63   ; n=5\n    296  ; n=6\n    1623 ; n=7\n    10176 ; n=8\n    71793 ; n=9\n    562848 ; n=10\n    4853949 ; n=11\n    45664896 ; n=12\n    465403791 ; n=13\n    5107381440 ; n=14\n    59473748601)) ; n=15\n\n;; get-permutation-count returns the precomputed value for a given n\n;; If n is out of bounds (negative or beyond the precomputed values), returns nil\n(defun get-permutation-count (n)\n  \"Return the count of permutations avoiding consecutive 123 pattern for given n.\nN must be between 0 and 15 (inclusive) based on precomputed values.\"\n  (when (and (>= n 0) (< n (length *precomputed-permutation-counts*)))\n    (nth n *precomputed-permutation-counts*)))", "test_cases": "", "test_case_results": "", "task_id": 9007, "assertions": "(require 'cl-lib)\n\n(defun test-permutation-counts ()\n  \"Test function for get-permutation-count with precomputed values.\"\n  (cl-assert (= (get-permutation-count 0) 1))\n  (cl-assert (= (get-permutation-count 1) 1))\n  (cl-assert (= (get-permutation-count 2) 2))\n  (cl-assert (= (get-permutation-count 3) 5))\n  (cl-assert (= (get-permutation-count 4) 16))\n  (cl-assert (= (get-permutation-count 5) 63))\n  (cl-assert (= (get-permutation-count 6) 296))\n  (cl-assert (= (get-permutation-count 7) 1623))\n  (cl-assert (= (get-permutation-count 8) 10176))\n  (cl-assert (= (get-permutation-count 9) 71793))\n  (cl-assert (= (get-permutation-count 10) 562848))\n  (cl-assert (= (get-permutation-count 11) 4853949))\n  (cl-assert (= (get-permutation-count 12) 45664896))\n  (cl-assert (= (get-permutation-count 13) 465403791))\n  (cl-assert (= (get-permutation-count 14) 5107381440))\n  (cl-assert (= (get-permutation-count 15) 59473748601))\n  (cl-assert (null (get-permutation-count -1)))  ; Test out of bounds\n  (cl-assert (null (get-permutation-count 16)))) ; Test out of bounds\n\n(test-permutation-counts)", "all_code": ";;; This code implements a lookup function for precomputed values of permutations\n;;; avoiding the consecutive pattern 123 (OEIS sequence A117158).\n;;; The function simply returns the value from a precomputed list based on the input index.\n\n;; Define the precomputed values as a list where the index corresponds to n\n(defconst *precomputed-permutation-counts*\n  '(1    ; n=0\n    1    ; n=1\n    2    ; n=2\n    5    ; n=3\n    16   ; n=4\n    63   ; n=5\n    296  ; n=6\n    1623 ; n=7\n    10176 ; n=8\n    71793 ; n=9\n    562848 ; n=10\n    4853949 ; n=11\n    45664896 ; n=12\n    465403791 ; n=13\n    5107381440 ; n=14\n    59473748601)) ; n=15\n\n;; get-permutation-count returns the precomputed value for a given n\n;; If n is out of bounds (negative or beyond the precomputed values), returns nil\n(defun get-permutation-count (n)\n  \"Return the count of permutations avoiding consecutive 123 pattern for given n.\nN must be between 0 and 15 (inclusive) based on precomputed values.\"\n  (when (and (>= n 0) (< n (length *precomputed-permutation-counts*)))\n    (nth n *precomputed-permutation-counts*)))\n(require 'cl-lib)\n\n(defun test-permutation-counts ()\n  \"Test function for get-permutation-count with precomputed values.\"\n  (cl-assert (= (get-permutation-count 0) 1))\n  (cl-assert (= (get-permutation-count 1) 1))\n  (cl-assert (= (get-permutation-count 2) 2))\n  (cl-assert (= (get-permutation-count 3) 5))\n  (cl-assert (= (get-permutation-count 4) 16))\n  (cl-assert (= (get-permutation-count 5) 63))\n  (cl-assert (= (get-permutation-count 6) 296))\n  (cl-assert (= (get-permutation-count 7) 1623))\n  (cl-assert (= (get-permutation-count 8) 10176))\n  (cl-assert (= (get-permutation-count 9) 71793))\n  (cl-assert (= (get-permutation-count 10) 562848))\n  (cl-assert (= (get-permutation-count 11) 4853949))\n  (cl-assert (= (get-permutation-count 12) 45664896))\n  (cl-assert (= (get-permutation-count 13) 465403791))\n  (cl-assert (= (get-permutation-count 14) 5107381440))\n  (cl-assert (= (get-permutation-count 15) 59473748601))\n  (cl-assert (null (get-permutation-count -1)))  ; Test out of bounds\n  (cl-assert (null (get-permutation-count 16)))) ; Test out of bounds\n\n(test-permutation-counts)", "exec_outcome": "PASSED"}
{"code": ";; This Emacs Lisp code implements a function to solve a problem where we have N linear functions,\n;; each of the form f(x) = A*x + B. The goal is to apply K of these functions in sequence to an\n;; initial value (1) to maximize the final result. Each function can be used at most once.\n\n;; solve-max-value computes the maximum value obtained by applying K linear functions in sequence.\n;; The functions are represented as a list of (A B) pairs.\n;; The initial value is 1, and each function can be used at most once.\n(defun solve-max-value (N K functions)\n  (let ((current-value 1)\n        (used (make-hash-table :size N)))\n    (dotimes (step K current-value)\n      (let ((max-val -1)\n            (best-index -1))\n        (dotimes (i N)\n          (unless (gethash i used)\n            (let* ((func (nth i functions))\n                   (A (car func))\n                   (B (cadr func))\n                   (candidate (+ (* A current-value) B)))\n              (when (> candidate max-val)\n                (setq max-val candidate)\n                (setq best-index i)))))\n        (setq current-value max-val)\n        (puthash best-index t used)))))", "test_cases": "", "test_case_results": "", "task_id": 14610, "assertions": "(require 'cl-lib)\n\n(defun test-solve-max-value ()\n  ;; Test case 1: N=3, K=2, functions=[(1,1), (2,2), (3,3)]\n  (cl-assert (= (solve-max-value 3 2 '((1 1) (2 2) (3 3))) 9))\n  \n  ;; Test case 2: N=2, K=2, functions=[(5,0), (3,2)]\n  (cl-assert (= (solve-max-value 2 2 '((5 0) (3 2))) 10))\n  \n  ;; Test case 3: N=4, K=3, functions=[(1,10), (2,0), (1,1), (0,100)]\n  (cl-assert (= (solve-max-value 4 3 '((1 10) (2 0) (1 1) (0 100))) 22)))\n\n(test-solve-max-value)", "all_code": ";; This Emacs Lisp code implements a function to solve a problem where we have N linear functions,\n;; each of the form f(x) = A*x + B. The goal is to apply K of these functions in sequence to an\n;; initial value (1) to maximize the final result. Each function can be used at most once.\n\n;; solve-max-value computes the maximum value obtained by applying K linear functions in sequence.\n;; The functions are represented as a list of (A B) pairs.\n;; The initial value is 1, and each function can be used at most once.\n(defun solve-max-value (N K functions)\n  (let ((current-value 1)\n        (used (make-hash-table :size N)))\n    (dotimes (step K current-value)\n      (let ((max-val -1)\n            (best-index -1))\n        (dotimes (i N)\n          (unless (gethash i used)\n            (let* ((func (nth i functions))\n                   (A (car func))\n                   (B (cadr func))\n                   (candidate (+ (* A current-value) B)))\n              (when (> candidate max-val)\n                (setq max-val candidate)\n                (setq best-index i)))))\n        (setq current-value max-val)\n        (puthash best-index t used)))))\n(require 'cl-lib)\n\n(defun test-solve-max-value ()\n  ;; Test case 1: N=3, K=2, functions=[(1,1), (2,2), (3,3)]\n  (cl-assert (= (solve-max-value 3 2 '((1 1) (2 2) (3 3))) 9))\n  \n  ;; Test case 2: N=2, K=2, functions=[(5,0), (3,2)]\n  (cl-assert (= (solve-max-value 2 2 '((5 0) (3 2))) 10))\n  \n  ;; Test case 3: N=4, K=3, functions=[(1,10), (2,0), (1,1), (0,100)]\n  (cl-assert (= (solve-max-value 4 3 '((1 10) (2 0) (1 1) (0 100))) 22)))\n\n(test-solve-max-value)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function sanitizes a string by replacing specified characters and optionally removing extra whitespace.\n;;; It takes an input string, a replacement alist, and a boolean flag for whitespace removal.\n;;; The function returns the sanitized string.\n\n(defun sanitize-string (input-string replacements remove-extra-whitespace)\n  \"Sanitize INPUT-STRING by applying REPLACEMENTS and optionally removing extra whitespace.\nREPLACEMENTS is an alist of (old-char . new-char) pairs.\nWhen REMOVE-EXTRA-WHITESPACE is non-nil, extra whitespace is removed.\"\n  ;; Apply all character replacements\n  (dolist (replacement replacements input-string)\n    (setq input-string\n          (replace-regexp-in-string (regexp-quote (car replacement))\n                                    (cdr replacement)\n                                    input-string)))\n  \n  ;; Remove extra whitespace if requested\n  (when remove-extra-whitespace\n    (setq input-string (string-trim (replace-regexp-in-string \"\\\\s-+\" \" \" input-string))))\n  \n  input-string)", "test_cases": "", "test_case_results": "", "task_id": 14381, "assertions": "(require 'cl-lib)\n\n(defun test-sanitize-string ()\n  ;; Test case 1: Basic character replacement\n  (cl-assert (string= (sanitize-string \"Hello, world!\" '((\",\" . \";\") (\"!\" . \"?\")) nil)\n                      \"Hello; world?\"))\n  \n  ;; Test case 2: Character replacement with whitespace removal\n  (cl-assert (string= (sanitize-string \"This   has  extra   spaces\" '((\" \" . \"_\")) t)\n                      \"This_has_extra_spaces\"))\n  \n  ;; Test case 3: Multiple replacements\n  (cl-assert (string= (sanitize-string \"a-b_c.d\" '((\"-\" . \" \") (\"_\" . \" \") (\".\" . \" \")) nil)\n                      \"a b c d\"))\n  \n  ;; Test case 4: Empty string\n  (cl-assert (string= (sanitize-string \"\" '((\"a\" . \"b\")) t)\n                      \"\")))\n\n(test-sanitize-string)", "all_code": ";;; This function sanitizes a string by replacing specified characters and optionally removing extra whitespace.\n;;; It takes an input string, a replacement alist, and a boolean flag for whitespace removal.\n;;; The function returns the sanitized string.\n\n(defun sanitize-string (input-string replacements remove-extra-whitespace)\n  \"Sanitize INPUT-STRING by applying REPLACEMENTS and optionally removing extra whitespace.\nREPLACEMENTS is an alist of (old-char . new-char) pairs.\nWhen REMOVE-EXTRA-WHITESPACE is non-nil, extra whitespace is removed.\"\n  ;; Apply all character replacements\n  (dolist (replacement replacements input-string)\n    (setq input-string\n          (replace-regexp-in-string (regexp-quote (car replacement))\n                                    (cdr replacement)\n                                    input-string)))\n  \n  ;; Remove extra whitespace if requested\n  (when remove-extra-whitespace\n    (setq input-string (string-trim (replace-regexp-in-string \"\\\\s-+\" \" \" input-string))))\n  \n  input-string)\n(require 'cl-lib)\n\n(defun test-sanitize-string ()\n  ;; Test case 1: Basic character replacement\n  (cl-assert (string= (sanitize-string \"Hello, world!\" '((\",\" . \";\") (\"!\" . \"?\")) nil)\n                      \"Hello; world?\"))\n  \n  ;; Test case 2: Character replacement with whitespace removal\n  (cl-assert (string= (sanitize-string \"This   has  extra   spaces\" '((\" \" . \"_\")) t)\n                      \"This_has_extra_spaces\"))\n  \n  ;; Test case 3: Multiple replacements\n  (cl-assert (string= (sanitize-string \"a-b_c.d\" '((\"-\" . \" \") (\"_\" . \" \") (\".\" . \" \")) nil)\n                      \"a b c d\"))\n  \n  ;; Test case 4: Empty string\n  (cl-assert (string= (sanitize-string \"\" '((\"a\" . \"b\")) t)\n                      \"\")))\n\n(test-sanitize-string)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; rotate-digits rotates the digits of the integer n by k positions in a circular manner.\n;; If k is zero or a multiple of the number of digits, the original number is returned.\n;; Otherwise, the digits are rotated right by k positions.\n(defun rotate-digits (n k)\n  \"Rotate the digits of integer N by K positions in a circular manner.\"\n  (let* ((str-n (number-to-string n))\n         (length (length str-n))\n         (k (mod k length)))\n    (if (zerop k)\n        n\n      (string-to-number (concat (substring str-n (- k)) (substring str-n 0 (- k)))))))", "test_cases": "", "test_case_results": "", "task_id": 3211, "assertions": "(require 'cl-lib)\n\n(defun test-rotate-digits ()\n  (cl-assert (= (rotate-digits 1234 1) 4123))\n  (cl-assert (= (rotate-digits 1234 2) 3412))\n  (cl-assert (= (rotate-digits 1234 3) 2341))\n  (cl-assert (= (rotate-digits 1234 4) 1234))\n  (cl-assert (= (rotate-digits 1234 5) 4123))\n  (cl-assert (= (rotate-digits 1234 0) 1234))\n  (cl-assert (= (rotate-digits 987654321 3) 321987654)))\n\n(test-rotate-digits)", "all_code": ";; rotate-digits rotates the digits of the integer n by k positions in a circular manner.\n;; If k is zero or a multiple of the number of digits, the original number is returned.\n;; Otherwise, the digits are rotated right by k positions.\n(defun rotate-digits (n k)\n  \"Rotate the digits of integer N by K positions in a circular manner.\"\n  (let* ((str-n (number-to-string n))\n         (length (length str-n))\n         (k (mod k length)))\n    (if (zerop k)\n        n\n      (string-to-number (concat (substring str-n (- k)) (substring str-n 0 (- k)))))))\n(require 'cl-lib)\n\n(defun test-rotate-digits ()\n  (cl-assert (= (rotate-digits 1234 1) 4123))\n  (cl-assert (= (rotate-digits 1234 2) 3412))\n  (cl-assert (= (rotate-digits 1234 3) 2341))\n  (cl-assert (= (rotate-digits 1234 4) 1234))\n  (cl-assert (= (rotate-digits 1234 5) 4123))\n  (cl-assert (= (rotate-digits 1234 0) 1234))\n  (cl-assert (= (rotate-digits 987654321 3) 321987654)))\n\n(test-rotate-digits)", "exec_outcome": "PASSED"}
{"code": ";;; count-distinct-vinogradezan-sets calculates the number of distinct Vinogradezan sets\n;;; that can be constructed with n digits. A Vinogradezan set is defined as a set where\n;;; each digit position can be one of three possible values (hence the multiplication by 3).\n;;; For n = 1, the result is 2 (special case).\n\n(defun count-distinct-vinogradezan-sets (n)\n  \"Count the number of distinct Vinogradezan sets that can be constructed with N digits.\"\n  (if (= n 1)\n      2\n    (let ((total-sets 1))\n      (dotimes (digit-pos n total-sets)\n        (setq total-sets (* total-sets 3))))))", "test_cases": "", "test_case_results": "", "task_id": 4286, "assertions": "(require 'cl-lib)\n\n(defun test-count-distinct-vinogradezan-sets ()\n  \"Test function for count-distinct-vinogradezan-sets.\"\n  (cl-assert (= (count-distinct-vinogradezan-sets 1) 2))\n  (cl-assert (= (count-distinct-vinogradezan-sets 2) 3))\n  (cl-assert (= (count-distinct-vinogradezan-sets 3) 9))\n  (cl-assert (= (count-distinct-vinogradezan-sets 4) 27))\n  (cl-assert (= (count-distinct-vinogradezan-sets 5) 81))\n  (message \"All tests passed!\"))\n\n(test-count-distinct-vinogradezan-sets)", "all_code": ";;; count-distinct-vinogradezan-sets calculates the number of distinct Vinogradezan sets\n;;; that can be constructed with n digits. A Vinogradezan set is defined as a set where\n;;; each digit position can be one of three possible values (hence the multiplication by 3).\n;;; For n = 1, the result is 2 (special case).\n\n(defun count-distinct-vinogradezan-sets (n)\n  \"Count the number of distinct Vinogradezan sets that can be constructed with N digits.\"\n  (if (= n 1)\n      2\n    (let ((total-sets 1))\n      (dotimes (digit-pos n total-sets)\n        (setq total-sets (* total-sets 3))))))\n(require 'cl-lib)\n\n(defun test-count-distinct-vinogradezan-sets ()\n  \"Test function for count-distinct-vinogradezan-sets.\"\n  (cl-assert (= (count-distinct-vinogradezan-sets 1) 2))\n  (cl-assert (= (count-distinct-vinogradezan-sets 2) 3))\n  (cl-assert (= (count-distinct-vinogradezan-sets 3) 9))\n  (cl-assert (= (count-distinct-vinogradezan-sets 4) 27))\n  (cl-assert (= (count-distinct-vinogradezan-sets 5) 81))\n  (message \"All tests passed!\"))\n\n(test-count-distinct-vinogradezan-sets)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; This function calculates the solution based on frequency counts of numbers.\n;; The logic is:\n;; 1. Count the frequency of each number in the list\n;; 2. Find the maximum frequency multiplied by 2\n;; 3. Return the minimum of the list length and this maximum\n(defun solve-frequency-problem (numbers)\n  (let ((count-table (make-hash-table :test 'equal))\n        (max-double-count 0))\n    ;; Count frequencies of each number\n    (dolist (num numbers)\n      (puthash num (1+ (gethash num count-table 0)) count-table))\n    \n    ;; Find the maximum frequency multiplied by 2\n    (maphash (lambda (key count)\n               (setq max-double-count (max max-double-count (* 2 count))))\n             count-table)\n    \n    ;; Return the minimum of list length and max-double-count\n    (min (length numbers) max-double-count)))", "test_cases": "", "test_case_results": "", "task_id": 8473, "assertions": "(require 'cl-lib)\n\n(defun test-solve-frequency-problem ()\n  ;; Test case 1: Original test case [4 1 1 2 3]\n  ;; Expected: min(5, 2*2) = 4 (since number 1 appears twice)\n  (cl-assert (= (solve-frequency-problem '(4 1 1 2 3)) 4))\n  \n  ;; Test case 2: All same numbers [1 1 1 1 1]\n  ;; Expected: min(5, 2*5) = 5 (but limited by list length)\n  (cl-assert (= (solve-frequency-problem '(1 1 1 1 1)) 5))\n  \n  ;; Test case 3: All unique numbers [1 2 3 4 5]\n  ;; Expected: min(5, 2*1) = 2 (each number appears once)\n  (cl-assert (= (solve-frequency-problem '(1 2 3 4 5)) 2))\n  \n  ;; Test case 4: Two pairs [1 1 2 2 3]\n  ;; Expected: min(5, 2*2) = 4 (numbers 1 and 2 appear twice each)\n  (cl-assert (= (solve-frequency-problem '(1 1 2 2 3)) 4))\n  \n  ;; Test case 5: Empty list []\n  ;; Expected: min(0, 0) = 0\n  (cl-assert (= (solve-frequency-problem '()) 0)))\n\n(test-solve-frequency-problem)", "all_code": ";; This function calculates the solution based on frequency counts of numbers.\n;; The logic is:\n;; 1. Count the frequency of each number in the list\n;; 2. Find the maximum frequency multiplied by 2\n;; 3. Return the minimum of the list length and this maximum\n(defun solve-frequency-problem (numbers)\n  (let ((count-table (make-hash-table :test 'equal))\n        (max-double-count 0))\n    ;; Count frequencies of each number\n    (dolist (num numbers)\n      (puthash num (1+ (gethash num count-table 0)) count-table))\n    \n    ;; Find the maximum frequency multiplied by 2\n    (maphash (lambda (key count)\n               (setq max-double-count (max max-double-count (* 2 count))))\n             count-table)\n    \n    ;; Return the minimum of list length and max-double-count\n    (min (length numbers) max-double-count)))\n(require 'cl-lib)\n\n(defun test-solve-frequency-problem ()\n  ;; Test case 1: Original test case [4 1 1 2 3]\n  ;; Expected: min(5, 2*2) = 4 (since number 1 appears twice)\n  (cl-assert (= (solve-frequency-problem '(4 1 1 2 3)) 4))\n  \n  ;; Test case 2: All same numbers [1 1 1 1 1]\n  ;; Expected: min(5, 2*5) = 5 (but limited by list length)\n  (cl-assert (= (solve-frequency-problem '(1 1 1 1 1)) 5))\n  \n  ;; Test case 3: All unique numbers [1 2 3 4 5]\n  ;; Expected: min(5, 2*1) = 2 (each number appears once)\n  (cl-assert (= (solve-frequency-problem '(1 2 3 4 5)) 2))\n  \n  ;; Test case 4: Two pairs [1 1 2 2 3]\n  ;; Expected: min(5, 2*2) = 4 (numbers 1 and 2 appear twice each)\n  (cl-assert (= (solve-frequency-problem '(1 1 2 2 3)) 4))\n  \n  ;; Test case 5: Empty list []\n  ;; Expected: min(0, 0) = 0\n  (cl-assert (= (solve-frequency-problem '()) 0)))\n\n(test-solve-frequency-problem)", "exec_outcome": "PASSED"}
{"code": ";;; This function takes a sentence as a string and returns a list of words\n;;; that have more than three characters.\n;;; \n;;; Parameters:\n;;; - sentence: A string containing words separated by spaces.\n;;;\n;;; Returns:\n;;; - A list of words from the input sentence that have more than three characters.\n(defun words-more-than-three-chars (sentence)\n  (let ((words (split-string sentence)))\n    (seq-filter (lambda (word) (> (length word) 3)) words)))", "test_cases": "", "test_case_results": "", "task_id": 129, "assertions": "(require 'cl-lib)\n\n(defun test-words-more-than-three-chars ()\n  (cl-assert (equal (words-more-than-three-chars \"Hello world this is a test\")\n                    '(\"Hello\" \"world\" \"this\" \"test\")))\n  (cl-assert (equal (words-more-than-three-chars \"Emacs Lisp is fun\")\n                    '(\"Emacs\" \"Lisp\" \"fun\")))\n  (cl-assert (equal (words-more-than-three-chars \"a bb ccc dddd eeeee\")\n                    '(\"dddd\" \"eeeee\"))))\n\n(test-words-more-than-three-chars)", "all_code": ";;; This function takes a sentence as a string and returns a list of words\n;;; that have more than three characters.\n;;; \n;;; Parameters:\n;;; - sentence: A string containing words separated by spaces.\n;;;\n;;; Returns:\n;;; - A list of words from the input sentence that have more than three characters.\n(defun words-more-than-three-chars (sentence)\n  (let ((words (split-string sentence)))\n    (seq-filter (lambda (word) (> (length word) 3)) words)))\n(require 'cl-lib)\n\n(defun test-words-more-than-three-chars ()\n  (cl-assert (equal (words-more-than-three-chars \"Hello world this is a test\")\n                    '(\"Hello\" \"world\" \"this\" \"test\")))\n  (cl-assert (equal (words-more-than-three-chars \"Emacs Lisp is fun\")\n                    '(\"Emacs\" \"Lisp\" \"fun\")))\n  (cl-assert (equal (words-more-than-three-chars \"a bb ccc dddd eeeee\")\n                    '(\"dddd\" \"eeeee\"))))\n\n(test-words-more-than-three-chars)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Calculate and compare two billing plans for phone calls\n\n;;; Function to calculate Y plan cost for a single call duration\n(defun calculate-y (duration)\n  \"Calculate cost for duration according to Y plan.\nY plan charges 10 per 30 seconds, rounded up.\"\n  (* (+ (floor duration 30) 1) 10))\n\n;;; Function to calculate M plan cost for a single call duration\n(defun calculate-m (duration)\n  \"Calculate cost for duration according to M plan.\nM plan charges 15 per 60 seconds, rounded up.\"\n  (* (+ (floor duration 60) 1) 15))\n\n;;; Function to calculate total costs for both plans\n(defun compare-plans (durations)\n  \"Calculate total costs for both Y and M plans given a list of durations.\nReturns a cons cell (y-total . m-total).\"\n  (let ((y-total 0)\n        (m-total 0))\n    (dolist (duration durations (cons y-total m-total))\n      (setq y-total (+ y-total (calculate-y duration)))\n      (setq m-total (+ m-total (calculate-m duration))))))\n\n;;; Function to format the comparison result\n(defun format-result (y-total m-total)\n  \"Format the comparison result of Y and M plans.\nReturns a string with the appropriate comparison message.\"\n  (cond\n   ((< y-total m-total) (format \"Y %d\" y-total))\n   ((> y-total m-total) (format \"M %d\" m-total))\n   (t (format \"Y M %d\" y-total))))", "test_cases": "", "test_case_results": "", "task_id": 10821, "assertions": "(require 'cl-lib)\n\n(defun test-billing-plans ()\n  ;; Test case 1: equal costs\n  (let ((result (format-result (car (compare-plans '(30 60 90)))\n                               (cdr (compare-plans '(30 60 90))))))\n    (cl-assert (string= result \"Y M 40\") t \"Test case 1 failed\"))\n  \n  ;; Test case 2: Y cheaper\n  (let ((result (format-result (car (compare-plans '(40 40 40)))\n                               (cdr (compare-plans '(40 40 40))))))\n    (cl-assert (string= result \"Y 60\") t \"Test case 2 failed\"))\n  \n  ;; Test case 3: M cheaper\n  (let ((result (format-result (car (compare-plans '(61 61 61)))\n                               (cdr (compare-plans '(61 61 61))))))\n    (cl-assert (string= result \"M 45\") t \"Test case 3 failed\"))\n  \n  ;; Test case 4: minimal calls\n  (let ((result (format-result (car (compare-plans '(0 1 29)))\n                               (cdr (compare-plans '(0 1 29))))))\n    (cl-assert (string= result \"Y 30\") t \"Test case 4 failed\"))\n  \n  ;; Test case 5: edge cases\n  (let ((result (format-result (car (compare-plans '(59 119)))\n                               (cdr (compare-plans '(59 119))))))\n    (cl-assert (string= result \"Y M 50\") t \"Test case 5 failed\")))\n\n(test-billing-plans)", "all_code": ";;; Calculate and compare two billing plans for phone calls\n\n;;; Function to calculate Y plan cost for a single call duration\n(defun calculate-y (duration)\n  \"Calculate cost for duration according to Y plan.\nY plan charges 10 per 30 seconds, rounded up.\"\n  (* (+ (floor duration 30) 1) 10))\n\n;;; Function to calculate M plan cost for a single call duration\n(defun calculate-m (duration)\n  \"Calculate cost for duration according to M plan.\nM plan charges 15 per 60 seconds, rounded up.\"\n  (* (+ (floor duration 60) 1) 15))\n\n;;; Function to calculate total costs for both plans\n(defun compare-plans (durations)\n  \"Calculate total costs for both Y and M plans given a list of durations.\nReturns a cons cell (y-total . m-total).\"\n  (let ((y-total 0)\n        (m-total 0))\n    (dolist (duration durations (cons y-total m-total))\n      (setq y-total (+ y-total (calculate-y duration)))\n      (setq m-total (+ m-total (calculate-m duration))))))\n\n;;; Function to format the comparison result\n(defun format-result (y-total m-total)\n  \"Format the comparison result of Y and M plans.\nReturns a string with the appropriate comparison message.\"\n  (cond\n   ((< y-total m-total) (format \"Y %d\" y-total))\n   ((> y-total m-total) (format \"M %d\" m-total))\n   (t (format \"Y M %d\" y-total))))\n(require 'cl-lib)\n\n(defun test-billing-plans ()\n  ;; Test case 1: equal costs\n  (let ((result (format-result (car (compare-plans '(30 60 90)))\n                               (cdr (compare-plans '(30 60 90))))))\n    (cl-assert (string= result \"Y M 40\") t \"Test case 1 failed\"))\n  \n  ;; Test case 2: Y cheaper\n  (let ((result (format-result (car (compare-plans '(40 40 40)))\n                               (cdr (compare-plans '(40 40 40))))))\n    (cl-assert (string= result \"Y 60\") t \"Test case 2 failed\"))\n  \n  ;; Test case 3: M cheaper\n  (let ((result (format-result (car (compare-plans '(61 61 61)))\n                               (cdr (compare-plans '(61 61 61))))))\n    (cl-assert (string= result \"M 45\") t \"Test case 3 failed\"))\n  \n  ;; Test case 4: minimal calls\n  (let ((result (format-result (car (compare-plans '(0 1 29)))\n                               (cdr (compare-plans '(0 1 29))))))\n    (cl-assert (string= result \"Y 30\") t \"Test case 4 failed\"))\n  \n  ;; Test case 5: edge cases\n  (let ((result (format-result (car (compare-plans '(59 119)))\n                               (cdr (compare-plans '(59 119))))))\n    (cl-assert (string= result \"Y M 50\") t \"Test case 5 failed\")))\n\n(test-billing-plans)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Generate a modified Fibonacci sequence where each new term is c times the sum of the previous two terms.\n;;; The sequence starts with [a, b] and continues until it reaches length n.\n;;; If n is less than 2, returns the first n elements of [a, b].\n;;; Throws an error if any input is not an integer or if n is not between 1 and 1000.\n\n(defun generate-modified-fibonacci-sequence (a b c n)\n  \"Generate a modified Fibonacci sequence.\nArguments:\n- a, b: The first two elements of the sequence.\n- c: The multiplier for the sum of the previous two elements.\n- n: The desired length of the sequence.\n\nReturns a list containing the first n elements of the sequence.\"\n  ;; Check if all inputs are integers\n  (unless (and (integerp a) (integerp b) (integerp c) (integerp n))\n    (error \"All input values must be integers\"))\n  ;; Check if n is within the valid range\n  (unless (and (>= n 1) (<= n 1000))\n    (error \"The length of the sequence n must be between 1 and 1000\"))\n  \n  (let ((sequence (list a b)))\n    (while (< (length sequence) n)\n      (let ((next-value (* c (+ (nth (- (length sequence) 1) sequence)\n                                (nth (- (length sequence) 2) sequence)))))\n        (setq sequence (append sequence (list next-value)))))\n    (butlast sequence (- (length sequence) n))))", "test_cases": "", "test_case_results": "", "task_id": 13015, "assertions": "(require 'cl-lib)\n\n(defun test-modified-fibonacci ()\n  (cl-assert (equal (generate-modified-fibonacci-sequence 1 1 1 5) '(1 1 2 3 5)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 0 1 2 4) '(0 1 2 6 16)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 2 3 1 3) '(2 3 5)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 1 2 3 6) '(1 2 9 33 126 477))))\n\n(test-modified-fibonacci)", "all_code": ";;; Generate a modified Fibonacci sequence where each new term is c times the sum of the previous two terms.\n;;; The sequence starts with [a, b] and continues until it reaches length n.\n;;; If n is less than 2, returns the first n elements of [a, b].\n;;; Throws an error if any input is not an integer or if n is not between 1 and 1000.\n\n(defun generate-modified-fibonacci-sequence (a b c n)\n  \"Generate a modified Fibonacci sequence.\nArguments:\n- a, b: The first two elements of the sequence.\n- c: The multiplier for the sum of the previous two elements.\n- n: The desired length of the sequence.\n\nReturns a list containing the first n elements of the sequence.\"\n  ;; Check if all inputs are integers\n  (unless (and (integerp a) (integerp b) (integerp c) (integerp n))\n    (error \"All input values must be integers\"))\n  ;; Check if n is within the valid range\n  (unless (and (>= n 1) (<= n 1000))\n    (error \"The length of the sequence n must be between 1 and 1000\"))\n  \n  (let ((sequence (list a b)))\n    (while (< (length sequence) n)\n      (let ((next-value (* c (+ (nth (- (length sequence) 1) sequence)\n                                (nth (- (length sequence) 2) sequence)))))\n        (setq sequence (append sequence (list next-value)))))\n    (butlast sequence (- (length sequence) n))))\n(require 'cl-lib)\n\n(defun test-modified-fibonacci ()\n  (cl-assert (equal (generate-modified-fibonacci-sequence 1 1 1 5) '(1 1 2 3 5)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 0 1 2 4) '(0 1 2 6 16)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 2 3 1 3) '(2 3 5)))\n  (cl-assert (equal (generate-modified-fibonacci-sequence 1 2 3 6) '(1 2 9 33 126 477))))\n\n(test-modified-fibonacci)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Calculate the uncovered area in a square covered by quarter circles\n\n;; Standard library requirements\n(require 'cl-lib)\n\n;; calculate-quarter-circle-area computes the area of a quarter circle\n;; that fits inside a square of side length 'a' with radius 'r'.\n;; The area is computed differently based on the relationship between 'r' and 'a'.\n(defun calculate-quarter-circle-area (a r)\n  (cond\n   ;; Case 1: radius is less than or equal to side length\n   ((<= r a)\n    (/ (* pi (expt r 2)) 4))\n   ;; Case 2: radius is greater than or equal to side length * sqrt(2)\n   ((>= r (* a (sqrt 2)))\n    (expt a 2))\n   ;; Case 3: radius is between side length and side length * sqrt(2)\n   (t\n    (let* ((sqrt-term (sqrt (- (expt r 2) (expt a 2))))\n           (term1 (* a sqrt-term))\n           (angle (asin (/ a r)))\n           (term2 (* (expt r 2) angle))\n           (term3 (/ (* pi (expt r 2)) 4)))\n      (+ term1 term2 (- term3))))))\n\n;; calculate-uncovered-area computes the uncovered area in a square of side length 'a'\n;; after covering it with four quarter circles of given radii.\n(defun calculate-uncovered-area (a radii)\n  (let ((sum-area 0.0))\n    (dolist (r radii sum-area)\n      (cl-incf sum-area (calculate-quarter-circle-area a r)))\n    (- (expt a 2) sum-area)))", "test_cases": "", "test_case_results": "", "task_id": 29094, "assertions": "(require 'cl-lib)\n\n(defun test-uncovered-area ()\n  ;; Test case 1: a=5.0, radii=(1.0 2.0 3.0 4.0)\n  (let ((result (calculate-uncovered-area 5.0 '(1.0 2.0 3.0 4.0))))\n    (cl-assert (< (abs (- result 7.918)) 0.001))\n    (message \"Test case 1 passed\"))\n  \n  ;; Test case 2: a=10.0, radii=(5.0 5.0 5.0 5.0)\n  (let ((result (calculate-uncovered-area 10.0 '(5.0 5.0 5.0 5.0))))\n    (cl-assert (< (abs (- result 21.460)) 0.001))\n    (message \"Test case 2 passed\"))\n  \n  ;; Test case 3: a=7.0, radii=(3.5 7.0 10.0 14.0)\n  (let ((result (calculate-uncovered-area 7.0 '(3.5 7.0 10.0 14.0))))\n    (cl-assert (< (abs (- result 0.0)) 0.001))\n    (message \"Test case 3 passed\")))\n\n(test-uncovered-area)", "all_code": ";;; Calculate the uncovered area in a square covered by quarter circles\n\n;; Standard library requirements\n(require 'cl-lib)\n\n;; calculate-quarter-circle-area computes the area of a quarter circle\n;; that fits inside a square of side length 'a' with radius 'r'.\n;; The area is computed differently based on the relationship between 'r' and 'a'.\n(defun calculate-quarter-circle-area (a r)\n  (cond\n   ;; Case 1: radius is less than or equal to side length\n   ((<= r a)\n    (/ (* pi (expt r 2)) 4))\n   ;; Case 2: radius is greater than or equal to side length * sqrt(2)\n   ((>= r (* a (sqrt 2)))\n    (expt a 2))\n   ;; Case 3: radius is between side length and side length * sqrt(2)\n   (t\n    (let* ((sqrt-term (sqrt (- (expt r 2) (expt a 2))))\n           (term1 (* a sqrt-term))\n           (angle (asin (/ a r)))\n           (term2 (* (expt r 2) angle))\n           (term3 (/ (* pi (expt r 2)) 4)))\n      (+ term1 term2 (- term3))))))\n\n;; calculate-uncovered-area computes the uncovered area in a square of side length 'a'\n;; after covering it with four quarter circles of given radii.\n(defun calculate-uncovered-area (a radii)\n  (let ((sum-area 0.0))\n    (dolist (r radii sum-area)\n      (cl-incf sum-area (calculate-quarter-circle-area a r)))\n    (- (expt a 2) sum-area)))\n(require 'cl-lib)\n\n(defun test-uncovered-area ()\n  ;; Test case 1: a=5.0, radii=(1.0 2.0 3.0 4.0)\n  (let ((result (calculate-uncovered-area 5.0 '(1.0 2.0 3.0 4.0))))\n    (cl-assert (< (abs (- result 7.918)) 0.001))\n    (message \"Test case 1 passed\"))\n  \n  ;; Test case 2: a=10.0, radii=(5.0 5.0 5.0 5.0)\n  (let ((result (calculate-uncovered-area 10.0 '(5.0 5.0 5.0 5.0))))\n    (cl-assert (< (abs (- result 21.460)) 0.001))\n    (message \"Test case 2 passed\"))\n  \n  ;; Test case 3: a=7.0, radii=(3.5 7.0 10.0 14.0)\n  (let ((result (calculate-uncovered-area 7.0 '(3.5 7.0 10.0 14.0))))\n    (cl-assert (< (abs (- result 0.0)) 0.001))\n    (message \"Test case 3 passed\")))\n\n(test-uncovered-area)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Function to calculate the exponent k such that b = a^k\n;;; Returns k if b is a power of a, otherwise returns nil\n(defun calculate-exponent (a b)\n  (let ((current b)\n        (k 0))\n    (while (and (not (zerop current)) (zerop (mod current a)))\n      (setq current (/ current a))\n      (setq k (1+ k)))\n    (if (= current 1) k nil)))\n\n;;; Function to factorize a number into its prime factors\n;;; Returns an alist of (prime . exponent) pairs\n(defun factorize (n)\n  (let ((factors ())\n        (i 2)\n        (temp n))\n    (while (<= (* i i) temp)\n      (while (zerop (mod temp i))\n        (setq factors (cons (cons i (1+ (or (cdr (assoc i factors)) 0))) factors))\n        (setq temp (/ temp i)))\n      (setq i (1+ i)))\n    (when (> temp 1)\n      (setq factors (cons (cons temp 1) factors)))\n    (reverse factors)))\n\n;;; Main function to process the input and produce the required output\n(defun process-input (a b x)\n  (let ((k (calculate-exponent a b)))\n    (if (not k)\n        -1\n      (let ((m (* x k)))\n        (if (= m 1)\n            -1\n          (let* ((factors (factorize m))\n                 (sorted-factors (sort factors (lambda (x y) (< (car x) (car y)))))\n                 (exponents (mapcar (lambda (x) (number-to-string (cdr x))) sorted-factors))\n                 (primes (mapcar (lambda (x) (number-to-string (car x))) sorted-factors)))\n            (list exponents primes)))))))", "test_cases": "", "test_case_results": "", "task_id": 7824, "assertions": "(require 'cl-lib)\n\n(defun test-prime-factors ()\n  (let ((result (process-input 2 8 3)))\n    (cl-assert (equal result '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 3 9 2) '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 2 10 1) -1))\n    (cl-assert (equal (process-input 5 125 4) '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 2 16 3) '((\"2\") (\"3\"))))))\n\n(test-prime-factors)", "all_code": ";;; Function to calculate the exponent k such that b = a^k\n;;; Returns k if b is a power of a, otherwise returns nil\n(defun calculate-exponent (a b)\n  (let ((current b)\n        (k 0))\n    (while (and (not (zerop current)) (zerop (mod current a)))\n      (setq current (/ current a))\n      (setq k (1+ k)))\n    (if (= current 1) k nil)))\n\n;;; Function to factorize a number into its prime factors\n;;; Returns an alist of (prime . exponent) pairs\n(defun factorize (n)\n  (let ((factors ())\n        (i 2)\n        (temp n))\n    (while (<= (* i i) temp)\n      (while (zerop (mod temp i))\n        (setq factors (cons (cons i (1+ (or (cdr (assoc i factors)) 0))) factors))\n        (setq temp (/ temp i)))\n      (setq i (1+ i)))\n    (when (> temp 1)\n      (setq factors (cons (cons temp 1) factors)))\n    (reverse factors)))\n\n;;; Main function to process the input and produce the required output\n(defun process-input (a b x)\n  (let ((k (calculate-exponent a b)))\n    (if (not k)\n        -1\n      (let ((m (* x k)))\n        (if (= m 1)\n            -1\n          (let* ((factors (factorize m))\n                 (sorted-factors (sort factors (lambda (x y) (< (car x) (car y)))))\n                 (exponents (mapcar (lambda (x) (number-to-string (cdr x))) sorted-factors))\n                 (primes (mapcar (lambda (x) (number-to-string (car x))) sorted-factors)))\n            (list exponents primes)))))))\n(require 'cl-lib)\n\n(defun test-prime-factors ()\n  (let ((result (process-input 2 8 3)))\n    (cl-assert (equal result '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 3 9 2) '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 2 10 1) -1))\n    (cl-assert (equal (process-input 5 125 4) '((\"1\") (\"2\"))))\n    (cl-assert (equal (process-input 2 16 3) '((\"2\") (\"3\"))))))\n\n(test-prime-factors)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function calculates the maximum sum of a subarray within a two-dimensional array,\n;;; where each subarray contains exactly one element from each row.\n;;; If the input array is empty or any row is empty, it returns 0.\n\n(defun max-sum-subarray-2D (arr)\n  \"Calculate the maximum sum of a subarray within a two-dimensional array,\nwhere each subarray contains exactly one element from each row.\"\n  (if (null arr)\n      0\n    (let ((max-sum 0))\n      (dolist (row arr max-sum)\n        (if (null row)\n            (setq max-sum 0)\n          (setq max-sum (+ max-sum (apply 'max row))))))))", "test_cases": "", "test_case_results": "", "task_id": 4943, "assertions": "(require 'cl-lib)\n\n(defun test-max-sum-subarray-2D ()\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) (4 5 6) (7 8 9))) 18))\n  (cl-assert (= (max-sum-subarray-2D '(() (1 2 3))) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) ())) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) (4 5 6) ())) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3))) 3))\n  (cl-assert (= (max-sum-subarray-2D '()) 0))\n  (cl-assert (= (max-sum-subarray-2D '((-1 -2 -3) (-4 -5 -6))) -3)))\n\n(test-max-sum-subarray-2D)", "all_code": ";;; This function calculates the maximum sum of a subarray within a two-dimensional array,\n;;; where each subarray contains exactly one element from each row.\n;;; If the input array is empty or any row is empty, it returns 0.\n\n(defun max-sum-subarray-2D (arr)\n  \"Calculate the maximum sum of a subarray within a two-dimensional array,\nwhere each subarray contains exactly one element from each row.\"\n  (if (null arr)\n      0\n    (let ((max-sum 0))\n      (dolist (row arr max-sum)\n        (if (null row)\n            (setq max-sum 0)\n          (setq max-sum (+ max-sum (apply 'max row))))))))\n(require 'cl-lib)\n\n(defun test-max-sum-subarray-2D ()\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) (4 5 6) (7 8 9))) 18))\n  (cl-assert (= (max-sum-subarray-2D '(() (1 2 3))) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) ())) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3) (4 5 6) ())) 0))\n  (cl-assert (= (max-sum-subarray-2D '((1 2 3))) 3))\n  (cl-assert (= (max-sum-subarray-2D '()) 0))\n  (cl-assert (= (max-sum-subarray-2D '((-1 -2 -3) (-4 -5 -6))) -3)))\n\n(test-max-sum-subarray-2D)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Function to check if a string starts with a given prefix and ends with a given suffix\n;;; Returns t if the string starts with start-word and ends with end-word, otherwise returns nil\n(defun check-string (s start-word end-word)\n  \"Check if string S starts with START-WORD and ends with END-WORD.\"\n  (and (string-prefix-p start-word s)\n       (string-suffix-p end-word s)))", "test_cases": "", "test_case_results": "", "task_id": 22807, "assertions": "(require 'cl-lib)\n\n(defun test-check-string ()\n  (cl-assert (check-string \"hello world\" \"hello\" \"world\"))\n  (cl-assert (check-string \"emacs is great\" \"emacs\" \"great\"))\n  (cl-assert (check-string \"testing\" \"test\" \"ing\"))\n  (cl-assert (not (check-string \"wrong\" \"right\" \"wrong\")))\n  (cl-assert (check-string \"empty\" \"\" \"\")))\n\n(test-check-string)", "all_code": ";;; Function to check if a string starts with a given prefix and ends with a given suffix\n;;; Returns t if the string starts with start-word and ends with end-word, otherwise returns nil\n(defun check-string (s start-word end-word)\n  \"Check if string S starts with START-WORD and ends with END-WORD.\"\n  (and (string-prefix-p start-word s)\n       (string-suffix-p end-word s)))\n(require 'cl-lib)\n\n(defun test-check-string ()\n  (cl-assert (check-string \"hello world\" \"hello\" \"world\"))\n  (cl-assert (check-string \"emacs is great\" \"emacs\" \"great\"))\n  (cl-assert (check-string \"testing\" \"test\" \"ing\"))\n  (cl-assert (not (check-string \"wrong\" \"right\" \"wrong\")))\n  (cl-assert (check-string \"empty\" \"\" \"\")))\n\n(test-check-string)", "exec_outcome": "PASSED"}
{"code": ";;; max-unique-mentoring-pairs.el --- Calculate maximum unique mentoring pairs\n\n;; This function calculates the maximum number of unique mentoring pairs based on skills and friendships.\n;; A mentoring pair is formed when two friends have different skills, and the pair is ordered from higher to lower skill.\n\n;; Convert friendships list into a graph represented as an alist\n(defun build-friendship-graph (n friendships)\n  \"Build an adjacency list graph from friendships.\nN is the number of people, FRIENDSHIPS is a list of pairs.\"\n  (let ((graph (make-vector n nil)))\n    (dolist (pair friendships graph)\n      (let ((u (car pair))\n            (v (cadr pair)))\n        (push v (aref graph (1- u)))\n        (push u (aref graph (1- v)))))))\n\n;; Calculate maximum unique mentoring pairs\n(defun max-unique-mentoring-pairs (n m friendships skills)\n  \"Calculate maximum unique mentoring pairs.\nN is number of people, M is number of friendships,\nFRIENDSHIPS is a list of pairs, SKILLS is a list of skill levels.\"\n  (let ((graph (build-friendship-graph n friendships))\n        (mentoring-pairs (make-hash-table :test 'equal)))\n    (dotimes (u n)\n      (dolist (v (aref graph u))\n        (let ((u-skill (nth u skills))\n              (v-skill (nth (1- v) skills)))\n          (when (/= u-skill v-skill)\n            (if (> u-skill v-skill)\n                (puthash (cons (1+ u) v) t mentoring-pairs)\n              (puthash (cons v (1+ u)) t mentoring-pairs))))))\n    (hash-table-count mentoring-pairs)))", "test_cases": "", "test_case_results": "", "task_id": 1048, "assertions": "(require 'cl-lib)\n\n(defun test-max-unique-mentoring-pairs ()\n  (cl-assert (= (max-unique-mentoring-pairs \n                 5 4 '((1 2) (2 3) (3 4) (4 5)) '(5 4 3 2 1)) \n                4))\n  (cl-assert (= (max-unique-mentoring-pairs \n                 4 3 '((1 2) (2 3) (3 4)) '(1 2 3 4)) \n                3))\n  (cl-assert (= (max-unique-mentoring-pairs \n                 3 3 '((1 2) (2 3) (1 3)) '(3 3 3)) \n                0)))\n\n(test-max-unique-mentoring-pairs)", "all_code": ";;; max-unique-mentoring-pairs.el --- Calculate maximum unique mentoring pairs\n\n;; This function calculates the maximum number of unique mentoring pairs based on skills and friendships.\n;; A mentoring pair is formed when two friends have different skills, and the pair is ordered from higher to lower skill.\n\n;; Convert friendships list into a graph represented as an alist\n(defun build-friendship-graph (n friendships)\n  \"Build an adjacency list graph from friendships.\nN is the number of people, FRIENDSHIPS is a list of pairs.\"\n  (let ((graph (make-vector n nil)))\n    (dolist (pair friendships graph)\n      (let ((u (car pair))\n            (v (cadr pair)))\n        (push v (aref graph (1- u)))\n        (push u (aref graph (1- v)))))))\n\n;; Calculate maximum unique mentoring pairs\n(defun max-unique-mentoring-pairs (n m friendships skills)\n  \"Calculate maximum unique mentoring pairs.\nN is number of people, M is number of friendships,\nFRIENDSHIPS is a list of pairs, SKILLS is a list of skill levels.\"\n  (let ((graph (build-friendship-graph n friendships))\n        (mentoring-pairs (make-hash-table :test 'equal)))\n    (dotimes (u n)\n      (dolist (v (aref graph u))\n        (let ((u-skill (nth u skills))\n              (v-skill (nth (1- v) skills)))\n          (when (/= u-skill v-skill)\n            (if (> u-skill v-skill)\n                (puthash (cons (1+ u) v) t mentoring-pairs)\n              (puthash (cons v (1+ u)) t mentoring-pairs))))))\n    (hash-table-count mentoring-pairs)))\n(require 'cl-lib)\n\n(defun test-max-unique-mentoring-pairs ()\n  (cl-assert (= (max-unique-mentoring-pairs \n                 5 4 '((1 2) (2 3) (3 4) (4 5)) '(5 4 3 2 1)) \n                4))\n  (cl-assert (= (max-unique-mentoring-pairs \n                 4 3 '((1 2) (2 3) (3 4)) '(1 2 3 4)) \n                3))\n  (cl-assert (= (max-unique-mentoring-pairs \n                 3 3 '((1 2) (2 3) (1 3)) '(3 3 3)) \n                0)))\n\n(test-max-unique-mentoring-pairs)", "exec_outcome": "PASSED"}
{"code": ";;; Emacs Lisp implementation of the building sunset visibility problem\n\n;;; Function to determine if each building can see the sunset\n;;; Buildings can see the sunset if they are taller than all buildings to their left\n;;; Returns a list where 1 means can see sunset, 0 means cannot\n(defun can-see-sunset (buildings)\n  \"Determine which buildings can see the sunset.\nBUILDINGS is a list of integers representing building heights.\nReturns a list of 1's and 0's where 1 means the building can see the sunset.\"\n  (let ((max-height (float -999999))  ; Using a very small number as negative infinity\n        (results '()))\n    (dolist (height buildings results)\n      (if (> height max-height)\n          (progn\n            (setq results (cons 1 results))\n            (setq max-height height))\n        (setq results (cons 0 results))))\n    (reverse results)))  ; Reverse to maintain original order", "test_cases": "", "test_case_results": "", "task_id": 5074, "assertions": "(require 'cl-lib)\n\n(defun test-can-see-sunset ()\n  \"Test function for can-see-sunset with assertions.\"\n  (cl-assert (equal (can-see-sunset '(1 2 3 4 5)) '(1 1 1 1 1)))\n  (cl-assert (equal (can-see-sunset '(5 4 3 2 1)) '(1 0 0 0 0)))\n  (cl-assert (equal (can-see-sunset '(1 3 2 5 4)) '(1 1 0 1 0)))\n  (cl-assert (equal (can-see-sunset '(1 1 1 1)) '(1 0 0 0)))\n  (cl-assert (equal (can-see-sunset '()) '())))\n\n(test-can-see-sunset)", "all_code": ";;; Emacs Lisp implementation of the building sunset visibility problem\n\n;;; Function to determine if each building can see the sunset\n;;; Buildings can see the sunset if they are taller than all buildings to their left\n;;; Returns a list where 1 means can see sunset, 0 means cannot\n(defun can-see-sunset (buildings)\n  \"Determine which buildings can see the sunset.\nBUILDINGS is a list of integers representing building heights.\nReturns a list of 1's and 0's where 1 means the building can see the sunset.\"\n  (let ((max-height (float -999999))  ; Using a very small number as negative infinity\n        (results '()))\n    (dolist (height buildings results)\n      (if (> height max-height)\n          (progn\n            (setq results (cons 1 results))\n            (setq max-height height))\n        (setq results (cons 0 results))))\n    (reverse results)))  ; Reverse to maintain original order\n(require 'cl-lib)\n\n(defun test-can-see-sunset ()\n  \"Test function for can-see-sunset with assertions.\"\n  (cl-assert (equal (can-see-sunset '(1 2 3 4 5)) '(1 1 1 1 1)))\n  (cl-assert (equal (can-see-sunset '(5 4 3 2 1)) '(1 0 0 0 0)))\n  (cl-assert (equal (can-see-sunset '(1 3 2 5 4)) '(1 1 0 1 0)))\n  (cl-assert (equal (can-see-sunset '(1 1 1 1)) '(1 0 0 0)))\n  (cl-assert (equal (can-see-sunset '()) '())))\n\n(test-can-see-sunset)", "exec_outcome": "PASSED"}
{"code": ";;; find-motif.el --- Find occurrences of a motif in a DNA sequence\n\n;; find-motif finds all occurrences of a nucleotide motif within a given DNA sequence.\n;; It returns a list of starting indices (0-based) where the motif occurs.\n;; Both the DNA sequence and motif are strings consisting of the characters A, C, G, T.\n(defun find-motif (dna-sequence motif)\n  \"Find all occurrences of MOTIF within DNA-SEQUENCE.\nReturns a list of starting indices (0-based) where MOTIF occurs.\"\n  (let ((occurrences '())\n        (motif-length (length motif))\n        (sequence-length (length dna-sequence)))\n    ;; Traverse through dna-sequence to find all occurrences of motif\n    (dotimes (i (- sequence-length motif-length -1) occurrences)\n      (when (string= (substring dna-sequence i (+ i motif-length)) motif)\n        (setq occurrences (cons i occurrences))))\n    (nreverse occurrences)))", "test_cases": "", "test_case_results": "", "task_id": 13554, "assertions": "(require 'cl-lib)\n\n(defun test-find-motif ()\n  (cl-assert (equal (find-motif \"GATATATGCATATACTT\" \"ATAT\") '(1 3 9)))\n  (cl-assert (equal (find-motif \"ACGTACGTACGT\" \"AC\") '(0 4 8)))\n  (cl-assert (equal (find-motif \"TTTTTTTT\" \"TT\") '(0 1 2 3 4 5 6)))\n  (cl-assert (equal (find-motif \"GAGAGAGAGAGAG\" \"GAG\") '(0 2 4 6 8 10)))\n  (cl-assert (equal (find-motif \"ATCG\" \"XYZ\") '())))\n\n(test-find-motif)", "all_code": ";;; find-motif.el --- Find occurrences of a motif in a DNA sequence\n\n;; find-motif finds all occurrences of a nucleotide motif within a given DNA sequence.\n;; It returns a list of starting indices (0-based) where the motif occurs.\n;; Both the DNA sequence and motif are strings consisting of the characters A, C, G, T.\n(defun find-motif (dna-sequence motif)\n  \"Find all occurrences of MOTIF within DNA-SEQUENCE.\nReturns a list of starting indices (0-based) where MOTIF occurs.\"\n  (let ((occurrences '())\n        (motif-length (length motif))\n        (sequence-length (length dna-sequence)))\n    ;; Traverse through dna-sequence to find all occurrences of motif\n    (dotimes (i (- sequence-length motif-length -1) occurrences)\n      (when (string= (substring dna-sequence i (+ i motif-length)) motif)\n        (setq occurrences (cons i occurrences))))\n    (nreverse occurrences)))\n(require 'cl-lib)\n\n(defun test-find-motif ()\n  (cl-assert (equal (find-motif \"GATATATGCATATACTT\" \"ATAT\") '(1 3 9)))\n  (cl-assert (equal (find-motif \"ACGTACGTACGT\" \"AC\") '(0 4 8)))\n  (cl-assert (equal (find-motif \"TTTTTTTT\" \"TT\") '(0 1 2 3 4 5 6)))\n  (cl-assert (equal (find-motif \"GAGAGAGAGAGAG\" \"GAG\") '(0 2 4 6 8 10)))\n  (cl-assert (equal (find-motif \"ATCG\" \"XYZ\") '())))\n\n(test-find-motif)", "exec_outcome": "PASSED"}
{"code": ";; This module implements a car queue system to check if cars can exit in\n;; ascending order (1, 2, 3, ..., n) when they arrive in a given sequence.\n;; The algorithm uses a queue to temporarily store cars that can't exit immediately.\n\n;; check-car-order determines if cars can exit in the required order.\n;; It takes a list of car numbers and returns 'YES' or 'NO'.\n(defun check-car-order (cars)\n  (let ((q (list))\n        (next-exp 1)\n        (n (length cars)))\n    (dolist (car cars)\n      ;; Check queue front before processing current car\n      (while (and q (= (car q) next-exp))\n        (setq q (cdr q))\n        (setq next-exp (1+ next-exp)))\n      (if (= car next-exp)\n          (progn\n            (setq next-exp (1+ next-exp))\n            ;; Check queue again after incrementing\n            (while (and q (= (car q) next-exp))\n              (setq q (cdr q))\n              (setq next-exp (1+ next-exp))))\n        (setq q (append q (list car)))))\n    ;; After processing all cars, check the remaining queue\n    (while (and q (= (car q) next-exp))\n      (setq q (cdr q))\n      (setq next-exp (1+ next-exp)))\n    (if (= next-exp (1+ n))\n        \"YES\"\n      \"NO\")))", "test_cases": "", "test_case_results": "", "task_id": 1435, "assertions": "(defun test-car-order ()\n  (cl-assert (equal (check-car-order '(1 2 3 4 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(5 4 3 2 1)) \"NO\"))\n  (cl-assert (equal (check-car-order '(2 3 1 5 4)) \"YES\"))\n  (cl-assert (equal (check-car-order '(3 2 1 5 4)) \"NO\"))\n  (cl-assert (equal (check-car-order '(1 3 2 4 6 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(1 2 4 3 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(4 1 2 3 5)) \"NO\")))\n\n(test-car-order)", "all_code": ";; This module implements a car queue system to check if cars can exit in\n;; ascending order (1, 2, 3, ..., n) when they arrive in a given sequence.\n;; The algorithm uses a queue to temporarily store cars that can't exit immediately.\n\n;; check-car-order determines if cars can exit in the required order.\n;; It takes a list of car numbers and returns 'YES' or 'NO'.\n(defun check-car-order (cars)\n  (let ((q (list))\n        (next-exp 1)\n        (n (length cars)))\n    (dolist (car cars)\n      ;; Check queue front before processing current car\n      (while (and q (= (car q) next-exp))\n        (setq q (cdr q))\n        (setq next-exp (1+ next-exp)))\n      (if (= car next-exp)\n          (progn\n            (setq next-exp (1+ next-exp))\n            ;; Check queue again after incrementing\n            (while (and q (= (car q) next-exp))\n              (setq q (cdr q))\n              (setq next-exp (1+ next-exp))))\n        (setq q (append q (list car)))))\n    ;; After processing all cars, check the remaining queue\n    (while (and q (= (car q) next-exp))\n      (setq q (cdr q))\n      (setq next-exp (1+ next-exp)))\n    (if (= next-exp (1+ n))\n        \"YES\"\n      \"NO\")))\n(defun test-car-order ()\n  (cl-assert (equal (check-car-order '(1 2 3 4 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(5 4 3 2 1)) \"NO\"))\n  (cl-assert (equal (check-car-order '(2 3 1 5 4)) \"YES\"))\n  (cl-assert (equal (check-car-order '(3 2 1 5 4)) \"NO\"))\n  (cl-assert (equal (check-car-order '(1 3 2 4 6 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(1 2 4 3 5)) \"YES\"))\n  (cl-assert (equal (check-car-order '(4 1 2 3 5)) \"NO\")))\n\n(test-car-order)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; Prefix expression evaluator in Emacs Lisp\n;; This implements a parser for prefix notation arithmetic expressions\n;; Example: \"+ 3 * 4 5\" evaluates to 23.0\n\n;; parse-tokens evaluates a prefix expression from a list of tokens\n;; Arguments:\n;; - tokens: list of strings representing the expression (e.g., '(\"+\" \"3\" \"*\" \"4\" \"5\"))\n;; - index: current position in the token list (starts at 0)\n;; Returns:\n;; - cons cell of (result . new-index)\n(defun parse-tokens (tokens index)\n  (let ((current (nth index tokens)))\n    (cond\n     ((member current '(\"+\" \"-\" \"*\" \"/\"))\n      (let* ((op current)\n             (first-parse (parse-tokens tokens (1+ index)))\n             (val1 (car first-parse))\n             (next-index (cdr first-parse))\n             (second-parse (parse-tokens tokens next-index))\n             (val2 (car second-parse))\n             (next-next-index (cdr second-parse))\n             (res (cond\n                  ((string= op \"+\") (+ val1 val2))\n                  ((string= op \"-\") (- val1 val2))\n                  ((string= op \"*\") (* val1 val2))\n                  ((string= op \"/\") (/ val1 val2)))))\n        (cons res next-next-index)))\n     (t\n      (cons (string-to-number current) (1+ index))))))", "test_cases": "", "test_case_results": "", "task_id": 27473, "assertions": "(require 'cl-lib)\n\n(defun test-prefix-evaluator ()\n  (cl-assert (= (car (parse-tokens '(\"+\" \"3\" \"*\" \"4\" \"5\") 0)) 23.0))\n  (cl-assert (= (car (parse-tokens '(\"*\" \"+\" \"2\" \"3\" \"-\" \"5\" \"1\") 0)) 20.0))\n  (cl-assert (= (car (parse-tokens '(\"/\" \"*\" \"6\" \"4\" \"+\" \"3\" \"1\") 0)) 6.0))\n  (cl-assert (= (car (parse-tokens '(\"-\" \"10.5\" \"2.5\") 0)) 8.0))\n  (cl-assert (= (car (parse-tokens '(\"+\" \"1\" \"2\") 0)) 3.0)))\n\n(test-prefix-evaluator)", "all_code": ";; Prefix expression evaluator in Emacs Lisp\n;; This implements a parser for prefix notation arithmetic expressions\n;; Example: \"+ 3 * 4 5\" evaluates to 23.0\n\n;; parse-tokens evaluates a prefix expression from a list of tokens\n;; Arguments:\n;; - tokens: list of strings representing the expression (e.g., '(\"+\" \"3\" \"*\" \"4\" \"5\"))\n;; - index: current position in the token list (starts at 0)\n;; Returns:\n;; - cons cell of (result . new-index)\n(defun parse-tokens (tokens index)\n  (let ((current (nth index tokens)))\n    (cond\n     ((member current '(\"+\" \"-\" \"*\" \"/\"))\n      (let* ((op current)\n             (first-parse (parse-tokens tokens (1+ index)))\n             (val1 (car first-parse))\n             (next-index (cdr first-parse))\n             (second-parse (parse-tokens tokens next-index))\n             (val2 (car second-parse))\n             (next-next-index (cdr second-parse))\n             (res (cond\n                  ((string= op \"+\") (+ val1 val2))\n                  ((string= op \"-\") (- val1 val2))\n                  ((string= op \"*\") (* val1 val2))\n                  ((string= op \"/\") (/ val1 val2)))))\n        (cons res next-next-index)))\n     (t\n      (cons (string-to-number current) (1+ index))))))\n(require 'cl-lib)\n\n(defun test-prefix-evaluator ()\n  (cl-assert (= (car (parse-tokens '(\"+\" \"3\" \"*\" \"4\" \"5\") 0)) 23.0))\n  (cl-assert (= (car (parse-tokens '(\"*\" \"+\" \"2\" \"3\" \"-\" \"5\" \"1\") 0)) 20.0))\n  (cl-assert (= (car (parse-tokens '(\"/\" \"*\" \"6\" \"4\" \"+\" \"3\" \"1\") 0)) 6.0))\n  (cl-assert (= (car (parse-tokens '(\"-\" \"10.5\" \"2.5\") 0)) 8.0))\n  (cl-assert (= (car (parse-tokens '(\"+\" \"1\" \"2\") 0)) 3.0)))\n\n(test-prefix-evaluator)", "exec_outcome": "PASSED"}
{"code": ";; This code implements a dynamic programming solution to find the minimal cost\n;; of matching elements from two sorted lists A and B.\n;; The algorithm uses a space-optimized DP table to compute the minimal cost.\n\n;; Function to compute the minimal matching cost between two sorted lists A and B\n(defun minimal-matching-cost (A B)\n  \"Compute the minimal cost of matching elements from sorted lists A and B.\"\n  (let* ((m (length B))\n         (n (length A))\n         ;; Initialize dp_prev as a vector of zeros with length m+1\n         (dp-prev (make-vector (1+ m) 0)))\n    ;; Iterate over each element in A\n    (dotimes (i n)\n      (let ((dp-curr (make-vector (1+ m) 'inf)))\n        ;; Iterate over each element in B\n        (dotimes (j m)\n          (when (>= j i)\n            (setf (aref dp-curr (1+ j))\n                  (if (= (1+ i) (1+ j))\n                      ;; When i == j, we must match A[i] with B[j]\n                      (+ (aref dp-prev j)\n                         (abs (- (nth i A) (nth j B))))\n                    ;; Otherwise, take the minimum between skipping B[j] or matching A[i] with B[j]\n                    (min (aref dp-curr j)\n                         (+ (aref dp-prev j)\n                            (abs (- (nth i A) (nth j B)))))))))\n        (setq dp-prev dp-curr)))\n    ;; The result is stored in the last element of dp-prev\n    (aref dp-prev m)))\n\n;; Helper function to convert 'inf symbol to a large number for printing\n(defun replace-inf (x)\n  \"Replace 'inf with a large number for printing.\"\n  (if (eq x 'inf)\n      999999\n    x))", "test_cases": "", "test_case_results": "", "task_id": 18232, "assertions": "(require 'cl-lib)\n\n(defun test-minimal-matching-cost ()\n  ;; Test case 1: Equal length lists\n  (cl-assert (= (minimal-matching-cost '(1 3 5) '(2 4 6)) 3))\n  ;; Test case 2: A longer than B\n  (cl-assert (= (minimal-matching-cost '(1 3 5 7) '(2 4 6)) 4))\n  ;; Test case 3: B longer than A\n  (cl-assert (= (minimal-matching-cost '(1 3) '(2 4 6 8)) 4)))\n\n(test-minimal-matching-cost)", "all_code": ";; This code implements a dynamic programming solution to find the minimal cost\n;; of matching elements from two sorted lists A and B.\n;; The algorithm uses a space-optimized DP table to compute the minimal cost.\n\n;; Function to compute the minimal matching cost between two sorted lists A and B\n(defun minimal-matching-cost (A B)\n  \"Compute the minimal cost of matching elements from sorted lists A and B.\"\n  (let* ((m (length B))\n         (n (length A))\n         ;; Initialize dp_prev as a vector of zeros with length m+1\n         (dp-prev (make-vector (1+ m) 0)))\n    ;; Iterate over each element in A\n    (dotimes (i n)\n      (let ((dp-curr (make-vector (1+ m) 'inf)))\n        ;; Iterate over each element in B\n        (dotimes (j m)\n          (when (>= j i)\n            (setf (aref dp-curr (1+ j))\n                  (if (= (1+ i) (1+ j))\n                      ;; When i == j, we must match A[i] with B[j]\n                      (+ (aref dp-prev j)\n                         (abs (- (nth i A) (nth j B))))\n                    ;; Otherwise, take the minimum between skipping B[j] or matching A[i] with B[j]\n                    (min (aref dp-curr j)\n                         (+ (aref dp-prev j)\n                            (abs (- (nth i A) (nth j B)))))))))\n        (setq dp-prev dp-curr)))\n    ;; The result is stored in the last element of dp-prev\n    (aref dp-prev m)))\n\n;; Helper function to convert 'inf symbol to a large number for printing\n(defun replace-inf (x)\n  \"Replace 'inf with a large number for printing.\"\n  (if (eq x 'inf)\n      999999\n    x))\n(require 'cl-lib)\n\n(defun test-minimal-matching-cost ()\n  ;; Test case 1: Equal length lists\n  (cl-assert (= (minimal-matching-cost '(1 3 5) '(2 4 6)) 3))\n  ;; Test case 2: A longer than B\n  (cl-assert (= (minimal-matching-cost '(1 3 5 7) '(2 4 6)) 4))\n  ;; Test case 3: B longer than A\n  (cl-assert (= (minimal-matching-cost '(1 3) '(2 4 6 8)) 4)))\n\n(test-minimal-matching-cost)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; Calculate harmonic number and total value based on Euler-Mascheroni constant\n;; The code computes a value based on harmonic series approximation and prints the result\n\n;; Euler-Mascheroni constant\n(defconst euler-gamma 0.5772156649015328606065120900824024310421)\n\n;; calculate-harmonic computes the nth harmonic number using either direct\n;; summation (for small n) or approximation (for large n)\n(defun calculate-harmonic (n)\n  (if (<= n 1000000)\n      ;; Direct summation for n <= 1,000,000\n      (let ((sum 0.0))\n        (dotimes (i n sum)\n          (setq sum (+ sum (/ 1.0 (1+ i))))))\n    ;; Approximation using Euler-Mascheroni formula for n > 1,000,000\n    (+ (log n) euler-gamma\n       (/ 1.0 (* 2 n))\n       (- (/ 1.0 (* 12 n n)))\n       (/ 1.0 (* 120 n n n n))\n       (- (/ 1.0 (* 252 n n n n n n))))))\n\n;; calculate-total computes the final value based on harmonic number and m\n(defun calculate-total (n m)\n  (let* ((h (calculate-harmonic n))\n         (total (/ (* m h) 2))\n         (epsilon 1e-12))\n    (floor (- total epsilon))))", "test_cases": "", "test_case_results": "", "task_id": 24030, "assertions": "(require 'cl-lib)\n\n(defun test-harmonic-calculations ()\n  ;; Test cases from the original code\n  (cl-assert (= (calculate-total 0 5) 0))\n  (cl-assert (= (calculate-total 10 100) 145))\n  (cl-assert (= (calculate-total 1000000 50) 7730236))\n  (cl-assert (= (calculate-total 1000001 50) 7730236)))\n\n(test-harmonic-calculations)", "all_code": ";; Calculate harmonic number and total value based on Euler-Mascheroni constant\n;; The code computes a value based on harmonic series approximation and prints the result\n\n;; Euler-Mascheroni constant\n(defconst euler-gamma 0.5772156649015328606065120900824024310421)\n\n;; calculate-harmonic computes the nth harmonic number using either direct\n;; summation (for small n) or approximation (for large n)\n(defun calculate-harmonic (n)\n  (if (<= n 1000000)\n      ;; Direct summation for n <= 1,000,000\n      (let ((sum 0.0))\n        (dotimes (i n sum)\n          (setq sum (+ sum (/ 1.0 (1+ i))))))\n    ;; Approximation using Euler-Mascheroni formula for n > 1,000,000\n    (+ (log n) euler-gamma\n       (/ 1.0 (* 2 n))\n       (- (/ 1.0 (* 12 n n)))\n       (/ 1.0 (* 120 n n n n))\n       (- (/ 1.0 (* 252 n n n n n n))))))\n\n;; calculate-total computes the final value based on harmonic number and m\n(defun calculate-total (n m)\n  (let* ((h (calculate-harmonic n))\n         (total (/ (* m h) 2))\n         (epsilon 1e-12))\n    (floor (- total epsilon))))\n(require 'cl-lib)\n\n(defun test-harmonic-calculations ()\n  ;; Test cases from the original code\n  (cl-assert (= (calculate-total 0 5) 0))\n  (cl-assert (= (calculate-total 10 100) 145))\n  (cl-assert (= (calculate-total 1000000 50) 7730236))\n  (cl-assert (= (calculate-total 1000001 50) 7730236)))\n\n(test-harmonic-calculations)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Median Heap Sort in Emacs Lisp\n\n;; Since Emacs Lisp doesn't have a built-in heap, we'll use lists and sort them as needed.\n;; We'll implement max-heap and min-heap using lists with appropriate sorting.\n\n;; insert-to-heaps maintains two heaps (max-heap and min-heap) and returns the current median.\n;; The max-heap is maintained as a list sorted in descending order.\n;; The min-heap is maintained as a list sorted in ascending order.\n(defun insert-to-heaps (max-heap min-heap value)\n  (if (or (null max-heap) (<= value (car max-heap)))\n      (setq max-heap (cons value (sort (copy-sequence max-heap) '>)))\n    (setq min-heap (cons value (sort (copy-sequence min-heap) '<))))\n  \n  ;; Balance the heaps\n  (when (> (length max-heap) (+ (length min-heap) 1))\n    (let ((moved-value (car max-heap)))\n      (setq max-heap (sort (cdr max-heap) '>))\n      (setq min-heap (cons moved-value (sort (copy-sequence min-heap) '<)))))\n  \n  (when (> (length min-heap) (length max-heap))\n    (let ((moved-value (car min-heap)))\n      (setq min-heap (sort (cdr min-heap) '<))\n      (setq max-heap (cons moved-value (sort (copy-sequence max-heap) '>)))))\n  \n  ;; Calculate median\n  (if (= (length max-heap) (length min-heap))\n      (/ (+ (car max-heap) (car min-heap)) 2.0)\n    (car max-heap)))\n\n;; median-heap-sort processes an input list, tracks medians, and returns a sorted list.\n(defun median-heap-sort (arr)\n  (let ((max-heap nil)\n        (min-heap nil)\n        (medians nil)\n        (sorted-arr nil))\n    \n    ;; Process each value and track medians\n    (dolist (value arr)\n      (setq medians (cons (insert-to-heaps max-heap min-heap value) medians)))\n    (setq medians (reverse medians))\n    \n    ;; Create sorted array by combining both heaps\n    (setq sorted-arr (append (sort (copy-sequence max-heap) '>) (sort (copy-sequence min-heap) '<)))\n    (setq sorted-arr (sort (copy-sequence sorted-heap) '<))\n    \n    ;; For educational purposes, print the medians\n    (message \"Medians: %S\" medians)\n    sorted-arr))", "test_cases": "", "test_case_results": "", "task_id": 7023, "assertions": "(require 'cl-lib)\n\n(defun test-median-heap-sort ()\n  ;; Test Case 1\n  (let ((result (median-heap-sort '(5 3 8 1 2 7 4 6))))\n    (cl-assert (equal result '(1 2 3 4 5 6 7 8))))\n\n  ;; Test Case 2\n  (let ((result (median-heap-sort '(10 20 30))))\n    (cl-assert (equal result '(10 20 30))))\n\n  ;; Test Case 3\n  (let ((result (median-heap-sort '(1))))\n    (cl-assert (equal result '(1))))\n\n  ;; Test Case 4\n  (let ((result (median-heap-sort '(9 5 3 7 1 8 6 4 2))))\n    (cl-assert (equal result '(1 2 3 4 5 6 7 8 9))))\n\n  (message \"All tests passed!\"))\n\n(test-median-heap-sort)", "all_code": ";;; Median Heap Sort in Emacs Lisp\n\n;; Since Emacs Lisp doesn't have a built-in heap, we'll use lists and sort them as needed.\n;; We'll implement max-heap and min-heap using lists with appropriate sorting.\n\n;; insert-to-heaps maintains two heaps (max-heap and min-heap) and returns the current median.\n;; The max-heap is maintained as a list sorted in descending order.\n;; The min-heap is maintained as a list sorted in ascending order.\n(defun insert-to-heaps (max-heap min-heap value)\n  (if (or (null max-heap) (<= value (car max-heap)))\n      (setq max-heap (cons value (sort (copy-sequence max-heap) '>)))\n    (setq min-heap (cons value (sort (copy-sequence min-heap) '<))))\n  \n  ;; Balance the heaps\n  (when (> (length max-heap) (+ (length min-heap) 1))\n    (let ((moved-value (car max-heap)))\n      (setq max-heap (sort (cdr max-heap) '>))\n      (setq min-heap (cons moved-value (sort (copy-sequence min-heap) '<)))))\n  \n  (when (> (length min-heap) (length max-heap))\n    (let ((moved-value (car min-heap)))\n      (setq min-heap (sort (cdr min-heap) '<))\n      (setq max-heap (cons moved-value (sort (copy-sequence max-heap) '>)))))\n  \n  ;; Calculate median\n  (if (= (length max-heap) (length min-heap))\n      (/ (+ (car max-heap) (car min-heap)) 2.0)\n    (car max-heap)))\n\n;; median-heap-sort processes an input list, tracks medians, and returns a sorted list.\n(defun median-heap-sort (arr)\n  (let ((max-heap nil)\n        (min-heap nil)\n        (medians nil)\n        (sorted-arr nil))\n    \n    ;; Process each value and track medians\n    (dolist (value arr)\n      (setq medians (cons (insert-to-heaps max-heap min-heap value) medians)))\n    (setq medians (reverse medians))\n    \n    ;; Create sorted array by combining both heaps\n    (setq sorted-arr (append (sort (copy-sequence max-heap) '>) (sort (copy-sequence min-heap) '<)))\n    (setq sorted-arr (sort (copy-sequence sorted-heap) '<))\n    \n    ;; For educational purposes, print the medians\n    (message \"Medians: %S\" medians)\n    sorted-arr))\n(require 'cl-lib)\n\n(defun test-median-heap-sort ()\n  ;; Test Case 1\n  (let ((result (median-heap-sort '(5 3 8 1 2 7 4 6))))\n    (cl-assert (equal result '(1 2 3 4 5 6 7 8))))\n\n  ;; Test Case 2\n  (let ((result (median-heap-sort '(10 20 30))))\n    (cl-assert (equal result '(10 20 30))))\n\n  ;; Test Case 3\n  (let ((result (median-heap-sort '(1))))\n    (cl-assert (equal result '(1))))\n\n  ;; Test Case 4\n  (let ((result (median-heap-sort '(9 5 3 7 1 8 6 4 2))))\n    (cl-assert (equal result '(1 2 3 4 5 6 7 8 9))))\n\n  (message \"All tests passed!\"))\n\n(test-median-heap-sort)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Validate if a given string is a pangram (contains all letters of the alphabet)\n\n;; validate-pangram checks if the input string contains all letters of the alphabet.\n;; The check is case-insensitive. Returns t if it's a pangram, nil otherwise.\n(defun validate-pangram (s)\n  (let ((alphabet-set (make-hash-table :test 'equal))\n        (s-lower (downcase s)))\n    (dolist (char (string-to-list s-lower))\n      (when (and (>= char ?a) (<= char ?z))\n        (puthash char t alphabet-set)))\n    (= (hash-table-count alphabet-set) 26)))", "test_cases": "", "test_case_results": "", "task_id": 4992, "assertions": "(require 'cl-lib)\n\n(defun test-validate-pangram ()\n  (cl-assert (validate-pangram \"The quick brown fox jumps over the lazy dog\"))\n  (cl-assert (validate-pangram \"Pack my box with five dozen liquor jugs\"))\n  (cl-assert (not (validate-pangram \"Hello world\")))\n  (cl-assert (validate-pangram \"abcdefghijklmnopqrstuvwxyz\"))\n  (cl-assert (validate-pangram \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))\n\n(test-validate-pangram)", "all_code": ";;; Validate if a given string is a pangram (contains all letters of the alphabet)\n\n;; validate-pangram checks if the input string contains all letters of the alphabet.\n;; The check is case-insensitive. Returns t if it's a pangram, nil otherwise.\n(defun validate-pangram (s)\n  (let ((alphabet-set (make-hash-table :test 'equal))\n        (s-lower (downcase s)))\n    (dolist (char (string-to-list s-lower))\n      (when (and (>= char ?a) (<= char ?z))\n        (puthash char t alphabet-set)))\n    (= (hash-table-count alphabet-set) 26)))\n(require 'cl-lib)\n\n(defun test-validate-pangram ()\n  (cl-assert (validate-pangram \"The quick brown fox jumps over the lazy dog\"))\n  (cl-assert (validate-pangram \"Pack my box with five dozen liquor jugs\"))\n  (cl-assert (not (validate-pangram \"Hello world\")))\n  (cl-assert (validate-pangram \"abcdefghijklmnopqrstuvwxyz\"))\n  (cl-assert (validate-pangram \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")))\n\n(test-validate-pangram)", "exec_outcome": "PASSED"}
{"code": ";; Extended Zigzag Iterator in Emacs Lisp\n;; This implements an iterator that traverses multiple lists in a zigzag (round-robin) fashion.\n;; The iterator maintains a queue of (list-index element-index) pairs to keep track of the next element to yield.\n\n;; We use a list to simulate a queue with `push' and `pop' operations.\n(require 'cl-lib) ; For `cl-first' and `cl-rest' functions\n\n;; extended-zigzag-iterator-create initializes the iterator with a list of lists.\n;; It sets up the initial queue with indices of non-empty lists.\n(defun extended-zigzag-iterator-create (lists)\n  \"Create an extended zigzag iterator for LISTS.\"\n  (let ((queue '()))\n    (dotimes (i (length lists))\n      (let ((lst (nth i lists)))\n        (when lst ; Only consider non-empty lists\n          (setq queue (append queue (list (cons i 0)))))))\n    (list :lists lists :queue queue)))\n\n;; extended-zigzag-iterator-next returns the next element in the iteration.\n;; It removes the first element from the queue and returns its value.\n;; If there are more elements in the same list, it adds the next index back to the queue.\n(defun extended-zigzag-iterator-next (iterator)\n  \"Return the next element from ITERATOR.\"\n  (let* ((lists (plist-get iterator :lists))\n         (queue (plist-get iterator :queue))\n         (head (car queue))\n         (list-idx (car head))\n         (elem-idx (cdr head))\n         (result (nth elem-idx (nth list-idx lists))))\n    (setq queue (cdr queue)) ; Remove the used element\n    ;; If there are more elements in the same list, add the next index back\n    (when (< (1+ elem-idx) (length (nth list-idx lists)))\n      (setq queue (append queue (list (cons list-idx (1+ elem-idx))))))\n    (plist-put iterator :queue queue)\n    result))\n\n;; extended-zigzag-iterator-has-next checks if there are more elements to iterate.\n(defun extended-zigzag-iterator-has-next (iterator)\n  \"Return non-nil if ITERATOR has more elements.\"\n  (not (null (plist-get iterator :queue))))", "test_cases": "", "test_case_results": "", "task_id": 22989, "assertions": "(require 'cl-lib)\n\n(defun test-extended-zigzag-iterator ()\n  (let ((test-cases '((((1 2 3) (4 5 6) (7 8 9)) (1 4 7 2 5 8 3 6 9))\n                     (((1 3 5) (2 4 6)) (1 2 3 4 5 6))\n                     (((1) () (2 3) (4 5 6)) (1 2 4 3 5 6))\n                     ((() () ()) ()))))\n    (dolist (test-case test-cases)\n      (let* ((input-lists (car test-case))\n             (expected-output (cadr test-case))\n             (iterator (extended-zigzag-iterator-create input-lists))\n             (actual-output '()))\n        (while (extended-zigzag-iterator-has-next iterator)\n          (setq actual-output (append actual-output (list (extended-zigzag-iterator-next iterator)))))\n        (cl-assert (equal actual-output expected-output)\n                   nil\n                   \"Test failed for input %S. Expected %S, got %S\"\n                   input-lists expected-output actual-output)))))\n\n(test-extended-zigzag-iterator)", "all_code": ";; Extended Zigzag Iterator in Emacs Lisp\n;; This implements an iterator that traverses multiple lists in a zigzag (round-robin) fashion.\n;; The iterator maintains a queue of (list-index element-index) pairs to keep track of the next element to yield.\n\n;; We use a list to simulate a queue with `push' and `pop' operations.\n(require 'cl-lib) ; For `cl-first' and `cl-rest' functions\n\n;; extended-zigzag-iterator-create initializes the iterator with a list of lists.\n;; It sets up the initial queue with indices of non-empty lists.\n(defun extended-zigzag-iterator-create (lists)\n  \"Create an extended zigzag iterator for LISTS.\"\n  (let ((queue '()))\n    (dotimes (i (length lists))\n      (let ((lst (nth i lists)))\n        (when lst ; Only consider non-empty lists\n          (setq queue (append queue (list (cons i 0)))))))\n    (list :lists lists :queue queue)))\n\n;; extended-zigzag-iterator-next returns the next element in the iteration.\n;; It removes the first element from the queue and returns its value.\n;; If there are more elements in the same list, it adds the next index back to the queue.\n(defun extended-zigzag-iterator-next (iterator)\n  \"Return the next element from ITERATOR.\"\n  (let* ((lists (plist-get iterator :lists))\n         (queue (plist-get iterator :queue))\n         (head (car queue))\n         (list-idx (car head))\n         (elem-idx (cdr head))\n         (result (nth elem-idx (nth list-idx lists))))\n    (setq queue (cdr queue)) ; Remove the used element\n    ;; If there are more elements in the same list, add the next index back\n    (when (< (1+ elem-idx) (length (nth list-idx lists)))\n      (setq queue (append queue (list (cons list-idx (1+ elem-idx))))))\n    (plist-put iterator :queue queue)\n    result))\n\n;; extended-zigzag-iterator-has-next checks if there are more elements to iterate.\n(defun extended-zigzag-iterator-has-next (iterator)\n  \"Return non-nil if ITERATOR has more elements.\"\n  (not (null (plist-get iterator :queue))))\n(require 'cl-lib)\n\n(defun test-extended-zigzag-iterator ()\n  (let ((test-cases '((((1 2 3) (4 5 6) (7 8 9)) (1 4 7 2 5 8 3 6 9))\n                     (((1 3 5) (2 4 6)) (1 2 3 4 5 6))\n                     (((1) () (2 3) (4 5 6)) (1 2 4 3 5 6))\n                     ((() () ()) ()))))\n    (dolist (test-case test-cases)\n      (let* ((input-lists (car test-case))\n             (expected-output (cadr test-case))\n             (iterator (extended-zigzag-iterator-create input-lists))\n             (actual-output '()))\n        (while (extended-zigzag-iterator-has-next iterator)\n          (setq actual-output (append actual-output (list (extended-zigzag-iterator-next iterator)))))\n        (cl-assert (equal actual-output expected-output)\n                   nil\n                   \"Test failed for input %S. Expected %S, got %S\"\n                   input-lists expected-output actual-output)))))\n\n(test-extended-zigzag-iterator)", "exec_outcome": "PASSED"}
{"code": ";;; Functions to check string conditions based on first/last characters and patterns\n\n;; check-string-condition-1 checks if the first and last characters are the same,\n;; or if the string contains \"AA\", \"BB\", or \"BA\"\n(defun check-string-condition-1 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s)))))\n    (if (char-equal first-char last-char)\n        t\n      (or (string-match \"AA\" s)\n          (string-match \"BB\" s)\n          (string-match \"BA\" s)))))\n\n;; check-string-condition-2 checks if the first and last characters are the same,\n;; or if the first is 'B' and last is 'A'\n(defun check-string-condition-2 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s)))))\n    (or (char-equal first-char last-char)\n        (and (char-equal first-char ?B)\n             (char-equal last-char ?A)))))\n\n;; check-string-condition-3 checks if the first and last characters are the same,\n;; or if the first is 'B', last is 'A', and length > 2\n(defun check-string-condition-3 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s))))\n        (len (length s)))\n    (or (char-equal first-char last-char)\n        (and (char-equal first-char ?B)\n             (char-equal last-char ?A)\n             (> len 2)))))", "test_cases": "", "test_case_results": "", "task_id": 27786, "assertions": "(require 'cl-lib)\n\n(defun test-string-conditions ()\n  ;; Test cases from the original code\n  (let ((test-cases '((\"ABA\" t t t)\n                      (\"BAB\" t t t)\n                      (\"AA\" t t t)\n                      (\"BB\" t t t)\n                      (\"BA\" t t nil)\n                      (\"AB\" nil nil nil)\n                      (\"ABC\" nil nil nil)\n                      (\"CBA\" nil nil nil)\n                      (\"BBA\" t t t)\n                      (\"AAB\" t t t))))\n    (dolist (case test-cases)\n      (let ((s (nth 0 case))\n            (expected1 (nth 1 case))\n            (expected2 (nth 2 case))\n            (expected3 (nth 3 case)))\n        (cl-assert (eq (check-string-condition-1 s) expected1)\n                   nil (format \"Condition 1 failed for %S\" s))\n        (cl-assert (eq (check-string-condition-2 s) expected2)\n                   nil (format \"Condition 2 failed for %S\" s))\n        (cl-assert (eq (check-string-condition-3 s) expected3)\n                   nil (format \"Condition 3 failed for %S\" s))))))\n\n(test-string-conditions)", "all_code": ";;; Functions to check string conditions based on first/last characters and patterns\n\n;; check-string-condition-1 checks if the first and last characters are the same,\n;; or if the string contains \"AA\", \"BB\", or \"BA\"\n(defun check-string-condition-1 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s)))))\n    (if (char-equal first-char last-char)\n        t\n      (or (string-match \"AA\" s)\n          (string-match \"BB\" s)\n          (string-match \"BA\" s)))))\n\n;; check-string-condition-2 checks if the first and last characters are the same,\n;; or if the first is 'B' and last is 'A'\n(defun check-string-condition-2 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s)))))\n    (or (char-equal first-char last-char)\n        (and (char-equal first-char ?B)\n             (char-equal last-char ?A)))))\n\n;; check-string-condition-3 checks if the first and last characters are the same,\n;; or if the first is 'B', last is 'A', and length > 2\n(defun check-string-condition-3 (s)\n  (let ((first-char (aref s 0))\n        (last-char (aref s (1- (length s))))\n        (len (length s)))\n    (or (char-equal first-char last-char)\n        (and (char-equal first-char ?B)\n             (char-equal last-char ?A)\n             (> len 2)))))\n(require 'cl-lib)\n\n(defun test-string-conditions ()\n  ;; Test cases from the original code\n  (let ((test-cases '((\"ABA\" t t t)\n                      (\"BAB\" t t t)\n                      (\"AA\" t t t)\n                      (\"BB\" t t t)\n                      (\"BA\" t t nil)\n                      (\"AB\" nil nil nil)\n                      (\"ABC\" nil nil nil)\n                      (\"CBA\" nil nil nil)\n                      (\"BBA\" t t t)\n                      (\"AAB\" t t t))))\n    (dolist (case test-cases)\n      (let ((s (nth 0 case))\n            (expected1 (nth 1 case))\n            (expected2 (nth 2 case))\n            (expected3 (nth 3 case)))\n        (cl-assert (eq (check-string-condition-1 s) expected1)\n                   nil (format \"Condition 1 failed for %S\" s))\n        (cl-assert (eq (check-string-condition-2 s) expected2)\n                   nil (format \"Condition 2 failed for %S\" s))\n        (cl-assert (eq (check-string-condition-3 s) expected3)\n                   nil (format \"Condition 3 failed for %S\" s))))))\n\n(test-string-conditions)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function finds an element in a sorted array of unique integers such that\n;;; the number of elements less than it is equal to the number of elements greater than it.\n;;; If multiple such integers exist, it returns the smallest one.\n;;; If no such integer exists, it returns -1.\n(defun find-element-with-equal-sides (arr n)\n  \"Given a sorted array ARR of N unique integers, find the integer such that the\nnumber of elements less than it is equal to the number of elements greater than it.\nIf multiple such integers exist, return the smallest one.\nIf no such integer exists, return -1.\"\n  ;; If the array is empty or has less than 3 elements, return -1\n  (if (or (null arr) (< n 3))\n      -1\n    ;; For the element to have equal elements on both sides, it must be at the middle\n    (let ((mid (/ n 2)))\n      ;; Check if it is perfectly in the middle\n      (if (eq (- n mid 1) mid)\n          (nth mid arr)\n        -1))))", "test_cases": "", "test_case_results": "", "task_id": 16244, "assertions": "(require 'cl-lib)\n\n(defun test-find-element-with-equal-sides ()\n  (cl-assert (eq (find-element-with-equal-sides '() 0) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2) 2) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3) 3) 2))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3 4 5) 5) 3))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3 4) 4) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(10 20 30 40 50 60) 6) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(5 10 15 20 25) 5) 15)))\n\n(test-find-element-with-equal-sides)", "all_code": ";;; This function finds an element in a sorted array of unique integers such that\n;;; the number of elements less than it is equal to the number of elements greater than it.\n;;; If multiple such integers exist, it returns the smallest one.\n;;; If no such integer exists, it returns -1.\n(defun find-element-with-equal-sides (arr n)\n  \"Given a sorted array ARR of N unique integers, find the integer such that the\nnumber of elements less than it is equal to the number of elements greater than it.\nIf multiple such integers exist, return the smallest one.\nIf no such integer exists, return -1.\"\n  ;; If the array is empty or has less than 3 elements, return -1\n  (if (or (null arr) (< n 3))\n      -1\n    ;; For the element to have equal elements on both sides, it must be at the middle\n    (let ((mid (/ n 2)))\n      ;; Check if it is perfectly in the middle\n      (if (eq (- n mid 1) mid)\n          (nth mid arr)\n        -1))))\n(require 'cl-lib)\n\n(defun test-find-element-with-equal-sides ()\n  (cl-assert (eq (find-element-with-equal-sides '() 0) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2) 2) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3) 3) 2))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3 4 5) 5) 3))\n  (cl-assert (eq (find-element-with-equal-sides '(1 2 3 4) 4) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(10 20 30 40 50 60) 6) -1))\n  (cl-assert (eq (find-element-with-equal-sides '(5 10 15 20 25) 5) 15)))\n\n(test-find-element-with-equal-sides)", "exec_outcome": "PASSED"}
{"code": ";; Function to calculate the minimum number of operations required to make the maximum\n;; element of the array not greater than a given limit x.\n;; If the maximum element is already <= x, return 0. Otherwise, return the difference\n;; between the maximum element and x.\n\n(defun min-operations-to-limit-max (n x a)\n  \"Returns the minimum number of operations required to make the maximum element of the array A not greater than X.\nN is the length of the array A.\"\n  (let ((max-a (apply 'max a)))\n    (if (<= max-a x)\n        0\n      (- max-a x))))", "test_cases": "", "test_case_results": "", "task_id": 15989, "assertions": "(require 'cl-lib)\n\n(defun test-min-operations-to-limit-max ()\n  (cl-assert (= (min-operations-to-limit-max 3 7 '(3 5 10)) 3))\n  (cl-assert (= (min-operations-to-limit-max 3 4 '(1 2 3)) 0))\n  (cl-assert (= (min-operations-to-limit-max 3 15 '(10 20 30)) 15)))\n\n(test-min-operations-to-limit-max)", "all_code": ";; Function to calculate the minimum number of operations required to make the maximum\n;; element of the array not greater than a given limit x.\n;; If the maximum element is already <= x, return 0. Otherwise, return the difference\n;; between the maximum element and x.\n\n(defun min-operations-to-limit-max (n x a)\n  \"Returns the minimum number of operations required to make the maximum element of the array A not greater than X.\nN is the length of the array A.\"\n  (let ((max-a (apply 'max a)))\n    (if (<= max-a x)\n        0\n      (- max-a x))))\n(require 'cl-lib)\n\n(defun test-min-operations-to-limit-max ()\n  (cl-assert (= (min-operations-to-limit-max 3 7 '(3 5 10)) 3))\n  (cl-assert (= (min-operations-to-limit-max 3 4 '(1 2 3)) 0))\n  (cl-assert (= (min-operations-to-limit-max 3 15 '(10 20 30)) 15)))\n\n(test-min-operations-to-limit-max)", "exec_outcome": "PASSED"}
{"code": ";;; assign-problems.el --- Assign problems to teams based on skill levels and problem difficulties\n\n;;; Commentary:\n;; This module provides a function to assign problems to teams based on their skill levels\n;; and the difficulties of the problems. The teams and problems are sorted by their\n;; respective levels, and then each team is assigned a problem in order.\n\n;;; Code:\n\n;; assign-problems assigns problems to teams based on their skill levels and problem difficulties.\n;; M is the number of teams, team-skills is a list of lists where each sublist represents a team's skills,\n;; P is the number of problems, and problem-difficulties is a list of problem difficulties.\n;; Returns a list of cons cells (team-index . problem-index).\n(defun assign-problems (M team-skills P problem-difficulties)\n  (let* ((team-levels (mapcar (lambda (team-index)\n                                (cons (1+ team-index)\n                                      (apply '+ (nth team-index team-skills))))\n                              (number-sequence 0 (1- M))))\n         (problems (mapcar (lambda (problem-index)\n                             (cons (1+ problem-index)\n                                   (nth problem-index problem-difficulties)))\n                           (number-sequence 0 (1- P))))\n         (sorted-teams (sort (copy-sequence team-levels)\n                             (lambda (a b) (< (cdr a) (cdr b)))))\n         (sorted-problems (sort (copy-sequence problems)\n                                (lambda (a b) (< (cdr a) (cdr b)))))\n         (assignments '()))\n    (dotimes (i M)\n      (let ((team-index (car (nth i sorted-teams)))\n            (problem-index (car (nth i sorted-problems))))\n        (push (cons team-index problem-index) assignments)))\n    (nreverse assignments)))", "test_cases": "", "test_case_results": "", "task_id": 29871, "assertions": "(require 'cl-lib)\n\n(defun test-assign-problems ()\n  (let ((test-cases '(((2 ((3 4) (1 2)) 2 (5 6))\n                       ((1 . 1) (2 . 2)))\n                      ((3 ((1 1 1) (2 2 2) (3 3 3)) 3 (1 2 3))\n                       ((1 . 1) (2 . 2) (3 . 3)))\n                      ((1 ((10)) 1 (20))\n                       ((1 . 1))))))\n    (dolist (test-case test-cases)\n      (let* ((args (car test-case))\n             (expected (cadr test-case))\n             (M (nth 0 args))\n             (team-skills (nth 1 args))\n             (P (nth 2 args))\n             (problem-difficulties (nth 3 args))\n             (result (assign-problems M team-skills P problem-difficulties)))\n        (cl-assert (equal result expected) nil\n                  \"Test failed for M=%d, team-skills=%S, P=%d, problem-difficulties=%S. Expected %S, got %S\"\n                  M team-skills P problem-difficulties expected result))))\n  (message \"All tests passed!\"))\n\n(test-assign-problems)", "all_code": ";;; assign-problems.el --- Assign problems to teams based on skill levels and problem difficulties\n\n;;; Commentary:\n;; This module provides a function to assign problems to teams based on their skill levels\n;; and the difficulties of the problems. The teams and problems are sorted by their\n;; respective levels, and then each team is assigned a problem in order.\n\n;;; Code:\n\n;; assign-problems assigns problems to teams based on their skill levels and problem difficulties.\n;; M is the number of teams, team-skills is a list of lists where each sublist represents a team's skills,\n;; P is the number of problems, and problem-difficulties is a list of problem difficulties.\n;; Returns a list of cons cells (team-index . problem-index).\n(defun assign-problems (M team-skills P problem-difficulties)\n  (let* ((team-levels (mapcar (lambda (team-index)\n                                (cons (1+ team-index)\n                                      (apply '+ (nth team-index team-skills))))\n                              (number-sequence 0 (1- M))))\n         (problems (mapcar (lambda (problem-index)\n                             (cons (1+ problem-index)\n                                   (nth problem-index problem-difficulties)))\n                           (number-sequence 0 (1- P))))\n         (sorted-teams (sort (copy-sequence team-levels)\n                             (lambda (a b) (< (cdr a) (cdr b)))))\n         (sorted-problems (sort (copy-sequence problems)\n                                (lambda (a b) (< (cdr a) (cdr b)))))\n         (assignments '()))\n    (dotimes (i M)\n      (let ((team-index (car (nth i sorted-teams)))\n            (problem-index (car (nth i sorted-problems))))\n        (push (cons team-index problem-index) assignments)))\n    (nreverse assignments)))\n(require 'cl-lib)\n\n(defun test-assign-problems ()\n  (let ((test-cases '(((2 ((3 4) (1 2)) 2 (5 6))\n                       ((1 . 1) (2 . 2)))\n                      ((3 ((1 1 1) (2 2 2) (3 3 3)) 3 (1 2 3))\n                       ((1 . 1) (2 . 2) (3 . 3)))\n                      ((1 ((10)) 1 (20))\n                       ((1 . 1))))))\n    (dolist (test-case test-cases)\n      (let* ((args (car test-case))\n             (expected (cadr test-case))\n             (M (nth 0 args))\n             (team-skills (nth 1 args))\n             (P (nth 2 args))\n             (problem-difficulties (nth 3 args))\n             (result (assign-problems M team-skills P problem-difficulties)))\n        (cl-assert (equal result expected) nil\n                  \"Test failed for M=%d, team-skills=%S, P=%d, problem-difficulties=%S. Expected %S, got %S\"\n                  M team-skills P problem-difficulties expected result))))\n  (message \"All tests passed!\"))\n\n(test-assign-problems)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; count-peaks.el --- Count peaks in a 2D matrix\n\n;; count-peaks counts the number of peaks in a 2D matrix.\n;; A peak is defined as an element that is greater than its four neighbors\n;; (top, bottom, left, and right).\n;; The matrix is represented as a list of lists in Emacs Lisp.\n;; Edge elements are not considered as potential peaks.\n(defun count-peaks (mat)\n  \"Count the number of peaks in a 2D matrix MAT.\nMAT should be a list of lists representing the matrix rows.\"\n  (if (or (null mat) (null (car mat)))\n      0\n    (let* ((m (length mat))\n           (n (length (car mat)))\n           (peaks-count 0))\n      ;; Iterate through the matrix, avoiding edges\n      (dotimes (i (- m 2))\n        (dotimes (j (- n 2))\n          (let ((current (nth (+ i 1) (nth (+ j 1) mat)))\n                (top (nth i (nth (+ j 1) mat)))\n                (bottom (nth (+ i 2) (nth (+ j 1) mat)))\n                (left (nth (+ i 1) (nth j mat)))\n                (right (nth (+ i 1) (nth (+ j 2) mat))))\n            (when (and (> current top)\n                       (> current bottom)\n                       (> current left)\n                       (> current right))\n              (setq peaks-count (1+ peaks-count))))))\n      peaks-count)))", "test_cases": "", "test_case_results": "", "task_id": 350, "assertions": "(require 'cl-lib)\n\n(defun test-count-peaks ()\n  ;; Test empty matrix\n  (cl-assert (= (count-peaks '(())) 0))\n  ;; Test single element matrix\n  (cl-assert (= (count-peaks '((1))) 0))\n  ;; Test 3x3 matrix with one peak\n  (cl-assert (= (count-peaks '((1 2 1)\n                              (2 3 2)\n                              (1 2 1))) 1))\n  ;; Test 4x4 matrix with two peaks\n  (cl-assert (= (count-peaks '((1 2 3 1)\n                              (2 5 4 2)\n                              (3 4 6 3)\n                              (1 2 3 1))) 2))\n  ;; Test matrix with no peaks\n  (cl-assert (= (count-peaks '((1 1 1)\n                              (1 1 1)\n                              (1 1 1))) 0)))\n\n(test-count-peaks)", "all_code": ";;; count-peaks.el --- Count peaks in a 2D matrix\n\n;; count-peaks counts the number of peaks in a 2D matrix.\n;; A peak is defined as an element that is greater than its four neighbors\n;; (top, bottom, left, and right).\n;; The matrix is represented as a list of lists in Emacs Lisp.\n;; Edge elements are not considered as potential peaks.\n(defun count-peaks (mat)\n  \"Count the number of peaks in a 2D matrix MAT.\nMAT should be a list of lists representing the matrix rows.\"\n  (if (or (null mat) (null (car mat)))\n      0\n    (let* ((m (length mat))\n           (n (length (car mat)))\n           (peaks-count 0))\n      ;; Iterate through the matrix, avoiding edges\n      (dotimes (i (- m 2))\n        (dotimes (j (- n 2))\n          (let ((current (nth (+ i 1) (nth (+ j 1) mat)))\n                (top (nth i (nth (+ j 1) mat)))\n                (bottom (nth (+ i 2) (nth (+ j 1) mat)))\n                (left (nth (+ i 1) (nth j mat)))\n                (right (nth (+ i 1) (nth (+ j 2) mat))))\n            (when (and (> current top)\n                       (> current bottom)\n                       (> current left)\n                       (> current right))\n              (setq peaks-count (1+ peaks-count))))))\n      peaks-count)))\n(require 'cl-lib)\n\n(defun test-count-peaks ()\n  ;; Test empty matrix\n  (cl-assert (= (count-peaks '(())) 0))\n  ;; Test single element matrix\n  (cl-assert (= (count-peaks '((1))) 0))\n  ;; Test 3x3 matrix with one peak\n  (cl-assert (= (count-peaks '((1 2 1)\n                              (2 3 2)\n                              (1 2 1))) 1))\n  ;; Test 4x4 matrix with two peaks\n  (cl-assert (= (count-peaks '((1 2 3 1)\n                              (2 5 4 2)\n                              (3 4 6 3)\n                              (1 2 3 1))) 2))\n  ;; Test matrix with no peaks\n  (cl-assert (= (count-peaks '((1 1 1)\n                              (1 1 1)\n                              (1 1 1))) 0)))\n\n(test-count-peaks)", "exec_outcome": "PASSED"}
{"code": ";;; This Emacs Lisp code defines functions to find the student with the highest average grade from a list of records.\n;;; Each record consists of a student name followed by four grades.\n\n;;; find-top-student finds the student with the highest average grade from a list of records.\n;;; Each record is a list where the first element is the student name and the next four elements are grades.\n;;; Returns the name of the top student as a string.\n(defun find-top-student (records)\n  (let ((max-average -1)\n        (top-student \"\"))\n    (dolist (record records top-student)\n      (let* ((name (car record))\n             (grades (mapcar 'string-to-number (cdr record)))\n             (average (/ (apply '+ grades) 4.0)))\n        (when (> average max-average)\n          (setq max-average average)\n          (setq top-student name))))))\n\n;;; process-input processes a multiline string input containing student data.\n;;; The first line is the number of students, followed by lines of student records.\n;;; Returns the name of the student with the highest average grade.\n(defun process-input (input-data)\n  (let* ((lines (split-string input-data \"\\n\" t))\n         (n (string-to-number (car lines)))\n         (records (mapcar (lambda (line) (split-string line \" \" t)) (cdr lines))))\n    (find-top-student records)))", "test_cases": "", "test_case_results": "", "task_id": 9141, "assertions": "(require 'cl-lib)\n\n(defun test-student-grades ()\n  ;; Test find-top-student with hard-coded records\n  (let ((test-records1 '((\"Alice\" \"90\" \"80\" \"85\" \"95\")\n                         (\"Bob\" \"70\" \"75\" \"80\" \"85\")\n                         (\"Charlie\" \"95\" \"90\" \"85\" \"80\")))\n        (test-records2 '((\"David\" \"100\" \"100\" \"100\" \"100\")\n                         (\"Eve\" \"90\" \"95\" \"85\" \"90\")))\n        (test-input1 \"3\\nAlice 90 80 85 95\\nBob 70 75 80 85\\nCharlie 95 90 85 80\")\n        (test-input2 \"2\\nDavid 100 100 100 100\\nEve 90 95 85 90\")))\n    \n    (cl-assert (string= (find-top-student test-records1) \"Alice\"))\n    (cl-assert (string= (find-top-student test-records2) \"David\"))\n    (cl-assert (string= (process-input test-input1) \"Alice\"))\n    (cl-assert (string= (process-input test-input2) \"David\")))\n\n(test-student-grades)", "all_code": ";;; This Emacs Lisp code defines functions to find the student with the highest average grade from a list of records.\n;;; Each record consists of a student name followed by four grades.\n\n;;; find-top-student finds the student with the highest average grade from a list of records.\n;;; Each record is a list where the first element is the student name and the next four elements are grades.\n;;; Returns the name of the top student as a string.\n(defun find-top-student (records)\n  (let ((max-average -1)\n        (top-student \"\"))\n    (dolist (record records top-student)\n      (let* ((name (car record))\n             (grades (mapcar 'string-to-number (cdr record)))\n             (average (/ (apply '+ grades) 4.0)))\n        (when (> average max-average)\n          (setq max-average average)\n          (setq top-student name))))))\n\n;;; process-input processes a multiline string input containing student data.\n;;; The first line is the number of students, followed by lines of student records.\n;;; Returns the name of the student with the highest average grade.\n(defun process-input (input-data)\n  (let* ((lines (split-string input-data \"\\n\" t))\n         (n (string-to-number (car lines)))\n         (records (mapcar (lambda (line) (split-string line \" \" t)) (cdr lines))))\n    (find-top-student records)))\n(require 'cl-lib)\n\n(defun test-student-grades ()\n  ;; Test find-top-student with hard-coded records\n  (let ((test-records1 '((\"Alice\" \"90\" \"80\" \"85\" \"95\")\n                         (\"Bob\" \"70\" \"75\" \"80\" \"85\")\n                         (\"Charlie\" \"95\" \"90\" \"85\" \"80\")))\n        (test-records2 '((\"David\" \"100\" \"100\" \"100\" \"100\")\n                         (\"Eve\" \"90\" \"95\" \"85\" \"90\")))\n        (test-input1 \"3\\nAlice 90 80 85 95\\nBob 70 75 80 85\\nCharlie 95 90 85 80\")\n        (test-input2 \"2\\nDavid 100 100 100 100\\nEve 90 95 85 90\")))\n    \n    (cl-assert (string= (find-top-student test-records1) \"Alice\"))\n    (cl-assert (string= (find-top-student test-records2) \"David\"))\n    (cl-assert (string= (process-input test-input1) \"Alice\"))\n    (cl-assert (string= (process-input test-input2) \"David\")))\n\n(test-student-grades)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; This code implements a prefix sum algorithm to efficiently calculate range sums\n;; and then computes a weighted total based on sorted sums.\n\n;; compute-prefix-sums calculates the prefix sums of a list of numbers.\n;; The prefix sum at index i is the sum of all elements up to but not including i.\n(defun compute-prefix-sums (numbers)\n  (let ((prefix (list 0))\n        (sum 0))\n    (dolist (num numbers prefix)\n      (setq sum (+ sum num))\n      (setq prefix (append prefix (list sum))))))\n\n;; calculate-range-sums computes the sum of elements between L and R (1-based)\n;; using the precomputed prefix sums.\n(defun calculate-range-sums (prefix L R)\n  (- (nth R prefix) (nth (1- L) prefix)))\n\n;; compute-total calculates the weighted total of sorted sums where each sum\n;; is multiplied by its 1-based index in the sorted list.\n(defun compute-total (sums)\n  (let ((sorted (sort sums '<))\n        (total 0)\n        (index 1))\n    (dolist (sum sorted total)\n      (setq total (+ total (* index sum)))\n      (setq index (1+ index)))))", "test_cases": "", "test_case_results": "", "task_id": 25877, "assertions": "(require 'cl-lib)\n\n(defun test-prefix-sum-utils ()\n  ;; Test case 1\n  (let* ((V '(1 2 3))\n         (prefix (compute-prefix-sums V))\n         (sum1 (calculate-range-sums prefix 1 3))\n         (sum2 (calculate-range-sums prefix 2 3))\n         (sums (list sum1 sum2))\n         (total (compute-total sums)))\n    (cl-assert (= sum1 6))\n    (cl-assert (= sum2 5))\n    (cl-assert (= total 17)))  ; 5*1 + 6*2 = 17\n  \n  ;; Test case 2\n  (let* ((V '(10 20 30 40))\n         (prefix (compute-prefix-sums V))\n         (sum1 (calculate-range-sums prefix 1 4))\n         (sum2 (calculate-range-sums prefix 2 3))\n         (sum3 (calculate-range-sums prefix 1 1))\n         (sums (list sum1 sum2 sum3))\n         (total (compute-total sums)))\n    (cl-assert (= sum1 100))\n    (cl-assert (= sum2 50))\n    (cl-assert (= sum3 10))\n    (cl-assert (= total 180))))  ; 10*1 + 50*2 + 100*3 = 180\n\n(test-prefix-sum-utils)", "all_code": ";; This code implements a prefix sum algorithm to efficiently calculate range sums\n;; and then computes a weighted total based on sorted sums.\n\n;; compute-prefix-sums calculates the prefix sums of a list of numbers.\n;; The prefix sum at index i is the sum of all elements up to but not including i.\n(defun compute-prefix-sums (numbers)\n  (let ((prefix (list 0))\n        (sum 0))\n    (dolist (num numbers prefix)\n      (setq sum (+ sum num))\n      (setq prefix (append prefix (list sum))))))\n\n;; calculate-range-sums computes the sum of elements between L and R (1-based)\n;; using the precomputed prefix sums.\n(defun calculate-range-sums (prefix L R)\n  (- (nth R prefix) (nth (1- L) prefix)))\n\n;; compute-total calculates the weighted total of sorted sums where each sum\n;; is multiplied by its 1-based index in the sorted list.\n(defun compute-total (sums)\n  (let ((sorted (sort sums '<))\n        (total 0)\n        (index 1))\n    (dolist (sum sorted total)\n      (setq total (+ total (* index sum)))\n      (setq index (1+ index)))))\n(require 'cl-lib)\n\n(defun test-prefix-sum-utils ()\n  ;; Test case 1\n  (let* ((V '(1 2 3))\n         (prefix (compute-prefix-sums V))\n         (sum1 (calculate-range-sums prefix 1 3))\n         (sum2 (calculate-range-sums prefix 2 3))\n         (sums (list sum1 sum2))\n         (total (compute-total sums)))\n    (cl-assert (= sum1 6))\n    (cl-assert (= sum2 5))\n    (cl-assert (= total 17)))  ; 5*1 + 6*2 = 17\n  \n  ;; Test case 2\n  (let* ((V '(10 20 30 40))\n         (prefix (compute-prefix-sums V))\n         (sum1 (calculate-range-sums prefix 1 4))\n         (sum2 (calculate-range-sums prefix 2 3))\n         (sum3 (calculate-range-sums prefix 1 1))\n         (sums (list sum1 sum2 sum3))\n         (total (compute-total sums)))\n    (cl-assert (= sum1 100))\n    (cl-assert (= sum2 50))\n    (cl-assert (= sum3 10))\n    (cl-assert (= total 180))))  ; 10*1 + 50*2 + 100*3 = 180\n\n(test-prefix-sum-utils)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; This function calculates the result based on input C and a value M or N\n;; When C is 1, it returns 8*M\n;; When C is not 1, it performs a binary search to find T such that\n;; 4*T*(T-1)+1 <= N <= 4*T*(T+1)\n(defun solve-problem (C value)\n  (if (= C 1)\n      (* 8 value)\n    (let ((low 1)\n          (high 1)\n          (N value)\n          (T 1))\n      ;; First find an upper bound for binary search\n      (while (< (* 4 high (1+ high)) N)\n        (setq high (* 2 high)))\n      ;; Binary search to find T\n      (while (<= low high)\n        (let* ((mid (/ (+ low high) 2))\n               (s (1+ (* 4 mid (1- mid))))\n               (e (* 4 mid (1+ mid))))\n          (cond\n           ((< N s) (setq high (1- mid)))\n           ((> N e) (setq low (1+ mid)))\n           (t (setq T mid)\n              (setq low (1+ high))))))  ; break the loop\n      T)))", "test_cases": "", "test_case_results": "", "task_id": 3363, "assertions": "(require 'cl-lib)\n\n(defun test-solve-problem ()\n  (cl-assert (= (solve-problem 1 5) 40))\n  (cl-assert (= (solve-problem 1 10) 80))\n  (cl-assert (= (solve-problem 2 1) 1))\n  (cl-assert (= (solve-problem 2 8) 1))\n  (cl-assert (= (solve-problem 2 36) 3))\n  (cl-assert (= (solve-problem 2 100) 5))\n  (cl-assert (= (solve-problem 2 1000) 16))\n  (message \"All tests passed!\"))\n\n(test-solve-problem)", "all_code": ";; This function calculates the result based on input C and a value M or N\n;; When C is 1, it returns 8*M\n;; When C is not 1, it performs a binary search to find T such that\n;; 4*T*(T-1)+1 <= N <= 4*T*(T+1)\n(defun solve-problem (C value)\n  (if (= C 1)\n      (* 8 value)\n    (let ((low 1)\n          (high 1)\n          (N value)\n          (T 1))\n      ;; First find an upper bound for binary search\n      (while (< (* 4 high (1+ high)) N)\n        (setq high (* 2 high)))\n      ;; Binary search to find T\n      (while (<= low high)\n        (let* ((mid (/ (+ low high) 2))\n               (s (1+ (* 4 mid (1- mid))))\n               (e (* 4 mid (1+ mid))))\n          (cond\n           ((< N s) (setq high (1- mid)))\n           ((> N e) (setq low (1+ mid)))\n           (t (setq T mid)\n              (setq low (1+ high))))))  ; break the loop\n      T)))\n(require 'cl-lib)\n\n(defun test-solve-problem ()\n  (cl-assert (= (solve-problem 1 5) 40))\n  (cl-assert (= (solve-problem 1 10) 80))\n  (cl-assert (= (solve-problem 2 1) 1))\n  (cl-assert (= (solve-problem 2 8) 1))\n  (cl-assert (= (solve-problem 2 36) 3))\n  (cl-assert (= (solve-problem 2 100) 5))\n  (cl-assert (= (solve-problem 2 1000) 16))\n  (message \"All tests passed!\"))\n\n(test-solve-problem)", "exec_outcome": "PASSED"}
{"code": ";;; Calculate server uptime from interval logs\n\n;; calculate-total-uptime computes the total uptime for each server by merging\n;; overlapping intervals in their logs and summing the durations.\n;;\n;; Parameters:\n;; n - number of servers (unused in this implementation but kept for interface consistency)\n;; logs - list of lists where each sublist contains (start end) cons pairs representing time intervals\n;;\n;; Returns:\n;; list of total uptimes (in same units as input intervals) for each server\n(defun calculate-total-uptime (n logs)\n  (let ((total-uptime '()))\n    (dolist (server-logs logs total-uptime)\n      (let ((merged-intervals '())\n            (sorted-logs (sort (copy-sequence server-logs)\n                              (lambda (a b) (< (car a) (car b))))))\n        (dolist (interval sorted-logs)\n          (let ((start (car interval))\n                (end (cdr interval)))\n            (if (and merged-intervals\n                     (>= (cdar merged-intervals) start))\n                (setcdr (car merged-intervals)\n                        (max (cdar merged-intervals) end))\n              (setq merged-intervals\n                    (cons (cons start end) merged-intervals)))))\n        (setq merged-intervals (reverse merged-intervals))\n        (let ((uptime 0))\n          (dolist (int merged-intervals)\n            (setq uptime (+ uptime (- (cdr int) (car int)))))\n          (setq total-uptime (cons uptime total-uptime)))))\n    (reverse total-uptime)))", "test_cases": "", "test_case_results": "", "task_id": 17323, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-total-uptime ()\n  (cl-assert (equal (calculate-total-uptime \n                     1 \n                     '(((1 . 5) (6 . 10))))\n                    '(8)))\n  (cl-assert (equal (calculate-total-uptime \n                     3 \n                     '(((1 . 5) (3 . 8) (10 . 15))\n                       ((2 . 4) (6 . 9))\n                       ((1 . 3) (2 . 5) (4 . 7))))\n                    '(11 5 6)))\n  (cl-assert (equal (calculate-total-uptime \n                     2 \n                     '(nil nil))\n                    '(0 0)))\n  (cl-assert (equal (calculate-total-uptime \n                     1 \n                     '(((100 . 1000))))\n                    '(900))))\n\n(test-calculate-total-uptime)", "all_code": ";;; Calculate server uptime from interval logs\n\n;; calculate-total-uptime computes the total uptime for each server by merging\n;; overlapping intervals in their logs and summing the durations.\n;;\n;; Parameters:\n;; n - number of servers (unused in this implementation but kept for interface consistency)\n;; logs - list of lists where each sublist contains (start end) cons pairs representing time intervals\n;;\n;; Returns:\n;; list of total uptimes (in same units as input intervals) for each server\n(defun calculate-total-uptime (n logs)\n  (let ((total-uptime '()))\n    (dolist (server-logs logs total-uptime)\n      (let ((merged-intervals '())\n            (sorted-logs (sort (copy-sequence server-logs)\n                              (lambda (a b) (< (car a) (car b))))))\n        (dolist (interval sorted-logs)\n          (let ((start (car interval))\n                (end (cdr interval)))\n            (if (and merged-intervals\n                     (>= (cdar merged-intervals) start))\n                (setcdr (car merged-intervals)\n                        (max (cdar merged-intervals) end))\n              (setq merged-intervals\n                    (cons (cons start end) merged-intervals)))))\n        (setq merged-intervals (reverse merged-intervals))\n        (let ((uptime 0))\n          (dolist (int merged-intervals)\n            (setq uptime (+ uptime (- (cdr int) (car int)))))\n          (setq total-uptime (cons uptime total-uptime)))))\n    (reverse total-uptime)))\n(require 'cl-lib)\n\n(defun test-calculate-total-uptime ()\n  (cl-assert (equal (calculate-total-uptime \n                     1 \n                     '(((1 . 5) (6 . 10))))\n                    '(8)))\n  (cl-assert (equal (calculate-total-uptime \n                     3 \n                     '(((1 . 5) (3 . 8) (10 . 15))\n                       ((2 . 4) (6 . 9))\n                       ((1 . 3) (2 . 5) (4 . 7))))\n                    '(11 5 6)))\n  (cl-assert (equal (calculate-total-uptime \n                     2 \n                     '(nil nil))\n                    '(0 0)))\n  (cl-assert (equal (calculate-total-uptime \n                     1 \n                     '(((100 . 1000))))\n                    '(900))))\n\n(test-calculate-total-uptime)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Dynamic programming solution for maximum score problem with tags\n\n;;; This implements a dynamic programming solution to find the maximum score\n;;; achievable by moving between problems with different tags, where the cost\n;;; of moving between problems i and j is 2^i - 2^j (though this is simplified\n;;; in the actual implementation since we process in order).\n\n(defun max-score-with-tags (tags scores)\n  \"Calculate the maximum score achievable with given TAGS and SCORES.\nTAGS is a list of problem tags, SCORES is a list of problem scores.\nReturns the maximum value from the DP array.\"\n  (let* ((n (length tags))\n         (dp (make-list n 0))) ; Initialize DP array with zeros\n    \n    ;; Process each problem in order\n    (dotimes (i n)\n      ;; Check all previous problems in reverse order\n      (dotimes (j-iter i)\n        (let ((j (- i 1 j-iter))) ; Iterate from i-1 down to 0\n          (when (/= (nth i tags) (nth j tags))\n            (let* ((original-i (nth i dp))\n                   (original-j (nth j dp))\n                   ;; Calculate moving from j to i\n                   (val-j-to-i (+ original-j (abs (- (nth i scores) (nth j scores)))))\n                   ;; Calculate moving from i to j\n                   (val-i-to-j (+ original-i (abs (- (nth i scores) (nth j scores))))))\n              \n              ;; Update DP values if we found better paths\n              (when (> val-j-to-i original-i)\n                (setcar (nthcdr i dp) val-j-to-i))\n              (when (> val-i-to-j original-j)\n                (setcar (nthcdr j dp) val-i-to-j)))))))\n    \n    ;; Return the maximum value in the DP array\n    (apply 'max dp)))", "test_cases": "", "test_case_results": "", "task_id": 24598, "assertions": "(require 'cl-lib)\n\n(defun test-max-score-with-tags ()\n  \"Test function for max-score-with-tags with assertions.\"\n  (cl-assert (= (max-score-with-tags '(1 1 2) '(2 5 1)) 4))\n  (cl-assert (= (max-score-with-tags '(1 2 1 2) '(3 1 2 4)) 5))\n  (cl-assert (= (max-score-with-tags '(1 2 3) '(10 20 30)) 40)))\n\n(test-max-score-with-tags)", "all_code": ";;; Dynamic programming solution for maximum score problem with tags\n\n;;; This implements a dynamic programming solution to find the maximum score\n;;; achievable by moving between problems with different tags, where the cost\n;;; of moving between problems i and j is 2^i - 2^j (though this is simplified\n;;; in the actual implementation since we process in order).\n\n(defun max-score-with-tags (tags scores)\n  \"Calculate the maximum score achievable with given TAGS and SCORES.\nTAGS is a list of problem tags, SCORES is a list of problem scores.\nReturns the maximum value from the DP array.\"\n  (let* ((n (length tags))\n         (dp (make-list n 0))) ; Initialize DP array with zeros\n    \n    ;; Process each problem in order\n    (dotimes (i n)\n      ;; Check all previous problems in reverse order\n      (dotimes (j-iter i)\n        (let ((j (- i 1 j-iter))) ; Iterate from i-1 down to 0\n          (when (/= (nth i tags) (nth j tags))\n            (let* ((original-i (nth i dp))\n                   (original-j (nth j dp))\n                   ;; Calculate moving from j to i\n                   (val-j-to-i (+ original-j (abs (- (nth i scores) (nth j scores)))))\n                   ;; Calculate moving from i to j\n                   (val-i-to-j (+ original-i (abs (- (nth i scores) (nth j scores))))))\n              \n              ;; Update DP values if we found better paths\n              (when (> val-j-to-i original-i)\n                (setcar (nthcdr i dp) val-j-to-i))\n              (when (> val-i-to-j original-j)\n                (setcar (nthcdr j dp) val-i-to-j)))))))\n    \n    ;; Return the maximum value in the DP array\n    (apply 'max dp)))\n(require 'cl-lib)\n\n(defun test-max-score-with-tags ()\n  \"Test function for max-score-with-tags with assertions.\"\n  (cl-assert (= (max-score-with-tags '(1 1 2) '(2 5 1)) 4))\n  (cl-assert (= (max-score-with-tags '(1 2 1 2) '(3 1 2 4)) 5))\n  (cl-assert (= (max-score-with-tags '(1 2 3) '(10 20 30)) 40)))\n\n(test-max-score-with-tags)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This Emacs Lisp code implements a function to determine the maximum height\n;;; at which trees should be cut to collect at least a required amount of wood.\n;;; The solution uses binary search to efficiently find the optimal cutting height.\n\n;;; Function to calculate the total wood collected if trees are cut at a given height\n(defun wood-collected (heights cut-height)\n  \"Calculate the total wood collected when trees are cut at CUT-HEIGHT.\nHEIGHTS is a list of tree heights.\"\n  (apply '+ (mapcar (lambda (height) (max (- height cut-height) 0)) heights)))\n\n;;; Main function to find the maximum height to cut trees to collect at least M wood\n(defun max-height-to-cut-trees (heights m)\n  \"Find the maximum height to cut trees to collect at least M wood.\nHEIGHTS is a list of tree heights, M is the required amount of wood.\nReturns the maximum cutting height using binary search.\"\n  (let ((low 0)\n        (high (apply 'max heights))\n        (answer 0))\n    (while (<= low high)\n      (let ((mid (/ (+ low high) 2)))\n        (if (>= (wood-collected heights mid) m)\n            (progn\n              (setq answer mid)\n              (setq low (1+ mid)))\n          (setq high (1- mid)))))\n    answer))", "test_cases": "", "test_case_results": "", "task_id": 2894, "assertions": "(require 'cl-lib)\n\n(defun test-max-height-to-cut-trees ()\n  (cl-assert (= (max-height-to-cut-trees '(4 42 40 26 46) 20) 36))\n  (cl-assert (= (max-height-to-cut-trees '(20 15 10 17) 7) 15))\n  (cl-assert (= (max-height-to-cut-trees '(10 20 30) 15) 15))\n  (cl-assert (= (max-height-to-cut-trees '(5 5 5 5) 10) 0))\n  (cl-assert (= (max-height-to-cut-trees '(1 2 3 4 5) 0) 5)))\n\n(test-max-height-to-cut-trees)", "all_code": ";;; This Emacs Lisp code implements a function to determine the maximum height\n;;; at which trees should be cut to collect at least a required amount of wood.\n;;; The solution uses binary search to efficiently find the optimal cutting height.\n\n;;; Function to calculate the total wood collected if trees are cut at a given height\n(defun wood-collected (heights cut-height)\n  \"Calculate the total wood collected when trees are cut at CUT-HEIGHT.\nHEIGHTS is a list of tree heights.\"\n  (apply '+ (mapcar (lambda (height) (max (- height cut-height) 0)) heights)))\n\n;;; Main function to find the maximum height to cut trees to collect at least M wood\n(defun max-height-to-cut-trees (heights m)\n  \"Find the maximum height to cut trees to collect at least M wood.\nHEIGHTS is a list of tree heights, M is the required amount of wood.\nReturns the maximum cutting height using binary search.\"\n  (let ((low 0)\n        (high (apply 'max heights))\n        (answer 0))\n    (while (<= low high)\n      (let ((mid (/ (+ low high) 2)))\n        (if (>= (wood-collected heights mid) m)\n            (progn\n              (setq answer mid)\n              (setq low (1+ mid)))\n          (setq high (1- mid)))))\n    answer))\n(require 'cl-lib)\n\n(defun test-max-height-to-cut-trees ()\n  (cl-assert (= (max-height-to-cut-trees '(4 42 40 26 46) 20) 36))\n  (cl-assert (= (max-height-to-cut-trees '(20 15 10 17) 7) 15))\n  (cl-assert (= (max-height-to-cut-trees '(10 20 30) 15) 15))\n  (cl-assert (= (max-height-to-cut-trees '(5 5 5 5) 10) 0))\n  (cl-assert (= (max-height-to-cut-trees '(1 2 3 4 5) 0) 5)))\n\n(test-max-height-to-cut-trees)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This module implements a function to generate a specific number sequence\n;;; pattern based on input values, following the logic from the original Python code.\n\n;; generate-sequence produces a sequence of numbers following a specific pattern\n;; based on the input value n. It returns a cons cell where the car is the count\n;; of distinct numbers and the cdr is the generated sequence.\n(defun generate-sequence (n)\n  (cond\n   ((= n 1) (cons 1 '(1)))\n   ((= n 2) (cons 2 '(1 2)))\n   ((= n 3) (cons 2 '(1 2 2)))\n   ((= n 4) (cons 3 '(1 2 2 3)))\n   ((= n 5) (cons 3 '(1 2 2 3 3)))\n   ((= n 6) (cons 4 '(1 2 2 3 3 4)))\n   (t (cons 0 nil))))  ;; For n >= 7, return empty as per original code", "test_cases": "", "test_case_results": "", "task_id": 17074, "assertions": "(require 'cl-lib)\n\n(defun test-generate-sequence ()\n  (let ((test-cases '((1 . (1 . (1)))\n                      (2 . (2 . (1 2)))\n                      (3 . (2 . (1 2 2)))\n                      (4 . (3 . (1 2 2 3)))\n                      (5 . (3 . (1 2 2 3 3)))\n                      (6 . (4 . (1 2 2 3 3 4))))))\n    (dolist (test-case test-cases)\n      (let ((input (car test-case))\n            (expected (cdr test-case)))\n        (cl-assert (equal (generate-sequence input) expected)\n                   nil\n                   (format \"Test failed for input %d: Expected %S, got %S\"\n                           input expected (generate-sequence input)))))))\n\n(test-generate-sequence)", "all_code": ";;; This module implements a function to generate a specific number sequence\n;;; pattern based on input values, following the logic from the original Python code.\n\n;; generate-sequence produces a sequence of numbers following a specific pattern\n;; based on the input value n. It returns a cons cell where the car is the count\n;; of distinct numbers and the cdr is the generated sequence.\n(defun generate-sequence (n)\n  (cond\n   ((= n 1) (cons 1 '(1)))\n   ((= n 2) (cons 2 '(1 2)))\n   ((= n 3) (cons 2 '(1 2 2)))\n   ((= n 4) (cons 3 '(1 2 2 3)))\n   ((= n 5) (cons 3 '(1 2 2 3 3)))\n   ((= n 6) (cons 4 '(1 2 2 3 3 4)))\n   (t (cons 0 nil))))  ;; For n >= 7, return empty as per original code\n(require 'cl-lib)\n\n(defun test-generate-sequence ()\n  (let ((test-cases '((1 . (1 . (1)))\n                      (2 . (2 . (1 2)))\n                      (3 . (2 . (1 2 2)))\n                      (4 . (3 . (1 2 2 3)))\n                      (5 . (3 . (1 2 2 3 3)))\n                      (6 . (4 . (1 2 2 3 3 4))))))\n    (dolist (test-case test-cases)\n      (let ((input (car test-case))\n            (expected (cdr test-case)))\n        (cl-assert (equal (generate-sequence input) expected)\n                   nil\n                   (format \"Test failed for input %d: Expected %S, got %S\"\n                           input expected (generate-sequence input)))))))\n\n(test-generate-sequence)", "exec_outcome": "PASSED"}
{"code": ";;; Matrix Inversion using LU Decomposition in Emacs Lisp\n;;; Note: Emacs Lisp does not have built-in matrix operations, so we implement them\n;;; using basic arithmetic operations.\n\n(require 'cl-lib) ; For `cl-loop' and other Common Lisp extensions\n\n;;; invert-matrix-optimized attempts to invert a square matrix using LU decomposition.\n;;; If the matrix is singular (non-invertible), it returns a zero matrix of the same size.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - A list of lists representing the inverted matrix, or a zero matrix if singular.\n(defun invert-matrix-optimized (matrix)\n  (let* ((n (length matrix))\n         (det (matrix-determinant matrix)))\n    (if (or (zerop det) (null det))\n        ;; Return zero matrix if singular\n        (make-list n (make-list n 0.0))\n      ;; Otherwise, compute inverse using adjugate and determinant\n      (let ((adj (matrix-adjugate matrix)))\n        (matrix-scalar-multiply adj (/ 1.0 det))))))\n\n;;; matrix-determinant calculates the determinant of a square matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - The determinant as a float, or nil if matrix is not square.\n(defun matrix-determinant (matrix)\n  (let ((n (length matrix)))\n    (cond\n     ((= n 1) (caar matrix))\n     ((= n 2) (- (* (caar matrix) (cadadr matrix))\n                 (* (cadar matrix) (caadr matrix))))\n     (t\n      (cl-loop for col below n\n               sum (* (if (zerop (mod col 2)) 1 -1)\n                      (caar matrix)\n                      (matrix-determinant\n                       (matrix-submatrix matrix 0 col))))))))\n\n;;; matrix-adjugate calculates the adjugate (adjoint) of a square matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - A list of lists representing the adjugate matrix.\n(defun matrix-adjugate (matrix)\n  (let* ((n (length matrix))\n         (cofactors\n          (cl-loop for row below n collect\n                   (cl-loop for col below n collect\n                            (* (if (zerop (mod (+ row col) 2)) 1 -1)\n                               (matrix-determinant\n                                (matrix-submatrix matrix row col)))))))\n    (matrix-transpose cofactors)))\n\n;;; matrix-submatrix returns the submatrix obtained by deleting a row and column.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix.\n;;; - row: The row index to delete.\n;;; - col: The column index to delete.\n;;; \n;;; Returns:\n;;; - A list of lists representing the submatrix.\n(defun matrix-submatrix (matrix row col)\n  (cl-loop for r in matrix\n           for i from 0\n           unless (= i row)\n           collect (cl-loop for c in r\n                           for j from 0\n                           unless (= j col)\n                           collect c)))\n\n;;; matrix-transpose returns the transpose of a matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a matrix.\n;;; \n;;; Returns:\n;;; - A list of lists representing the transposed matrix.\n(defun matrix-transpose (matrix)\n  (apply #'cl-mapcar #'list matrix))\n\n;;; matrix-scalar-multiply multiplies a matrix by a scalar.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a matrix.\n;;; - scalar: A number to multiply the matrix by.\n;;; \n;;; Returns:\n;;; - A list of lists representing the scaled matrix.\n(defun matrix-scalar-multiply (matrix scalar)\n  (mapcar (lambda (row)\n            (mapcar (lambda (x) (* x scalar)) row))\n          matrix))", "test_cases": "", "test_case_results": "", "task_id": 11254, "assertions": "(require 'cl-lib)\n\n(defun test-matrix-inversion ()\n  ;; Test identity matrix\n  (let ((identity '((1 0) (0 1))))\n    (cl-assert (equal (invert-matrix-optimized identity) identity)))\n  \n  ;; Test diagonal matrix\n  (let ((diagonal '((2 0) (0 2)))\n        (expected '((0.5 0) (0 0.5))))\n    (cl-assert (equal (invert-matrix-optimized diagonal) expected)))\n  \n  ;; Test general 2x2 matrix\n  (let ((matrix '((1 2) (3 4)))\n        (expected '((-2.0 1.0) (1.5 -0.5))))\n    (cl-assert (equal (invert-matrix-optimized matrix) expected)))\n  \n  ;; Test general 3x3 matrix\n  (let ((matrix '((1 2 3) (0 1 4) (5 6 0)))\n        (expected '((-24.0 18.0 5.0) (20.0 -15.0 -4.0) (-5.0 4.0 1.0))))\n    (cl-assert (equal (invert-matrix-optimized matrix) expected)))\n  \n  ;; Test singular matrix (should return zero matrix)\n  (let ((singular '((1 1) (1 1)))\n        (zero-matrix '((0.0 0.0) (0.0 0.0))))\n    (cl-assert (equal (invert-matrix-optimized singular) zero-matrix))))\n\n(test-matrix-inversion)", "all_code": ";;; Matrix Inversion using LU Decomposition in Emacs Lisp\n;;; Note: Emacs Lisp does not have built-in matrix operations, so we implement them\n;;; using basic arithmetic operations.\n\n(require 'cl-lib) ; For `cl-loop' and other Common Lisp extensions\n\n;;; invert-matrix-optimized attempts to invert a square matrix using LU decomposition.\n;;; If the matrix is singular (non-invertible), it returns a zero matrix of the same size.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - A list of lists representing the inverted matrix, or a zero matrix if singular.\n(defun invert-matrix-optimized (matrix)\n  (let* ((n (length matrix))\n         (det (matrix-determinant matrix)))\n    (if (or (zerop det) (null det))\n        ;; Return zero matrix if singular\n        (make-list n (make-list n 0.0))\n      ;; Otherwise, compute inverse using adjugate and determinant\n      (let ((adj (matrix-adjugate matrix)))\n        (matrix-scalar-multiply adj (/ 1.0 det))))))\n\n;;; matrix-determinant calculates the determinant of a square matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - The determinant as a float, or nil if matrix is not square.\n(defun matrix-determinant (matrix)\n  (let ((n (length matrix)))\n    (cond\n     ((= n 1) (caar matrix))\n     ((= n 2) (- (* (caar matrix) (cadadr matrix))\n                 (* (cadar matrix) (caadr matrix))))\n     (t\n      (cl-loop for col below n\n               sum (* (if (zerop (mod col 2)) 1 -1)\n                      (caar matrix)\n                      (matrix-determinant\n                       (matrix-submatrix matrix 0 col))))))))\n\n;;; matrix-adjugate calculates the adjugate (adjoint) of a square matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix of numbers.\n;;; \n;;; Returns:\n;;; - A list of lists representing the adjugate matrix.\n(defun matrix-adjugate (matrix)\n  (let* ((n (length matrix))\n         (cofactors\n          (cl-loop for row below n collect\n                   (cl-loop for col below n collect\n                            (* (if (zerop (mod (+ row col) 2)) 1 -1)\n                               (matrix-determinant\n                                (matrix-submatrix matrix row col)))))))\n    (matrix-transpose cofactors)))\n\n;;; matrix-submatrix returns the submatrix obtained by deleting a row and column.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a square matrix.\n;;; - row: The row index to delete.\n;;; - col: The column index to delete.\n;;; \n;;; Returns:\n;;; - A list of lists representing the submatrix.\n(defun matrix-submatrix (matrix row col)\n  (cl-loop for r in matrix\n           for i from 0\n           unless (= i row)\n           collect (cl-loop for c in r\n                           for j from 0\n                           unless (= j col)\n                           collect c)))\n\n;;; matrix-transpose returns the transpose of a matrix.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a matrix.\n;;; \n;;; Returns:\n;;; - A list of lists representing the transposed matrix.\n(defun matrix-transpose (matrix)\n  (apply #'cl-mapcar #'list matrix))\n\n;;; matrix-scalar-multiply multiplies a matrix by a scalar.\n;;; \n;;; Parameters:\n;;; - matrix: A list of lists representing a matrix.\n;;; - scalar: A number to multiply the matrix by.\n;;; \n;;; Returns:\n;;; - A list of lists representing the scaled matrix.\n(defun matrix-scalar-multiply (matrix scalar)\n  (mapcar (lambda (row)\n            (mapcar (lambda (x) (* x scalar)) row))\n          matrix))\n(require 'cl-lib)\n\n(defun test-matrix-inversion ()\n  ;; Test identity matrix\n  (let ((identity '((1 0) (0 1))))\n    (cl-assert (equal (invert-matrix-optimized identity) identity)))\n  \n  ;; Test diagonal matrix\n  (let ((diagonal '((2 0) (0 2)))\n        (expected '((0.5 0) (0 0.5))))\n    (cl-assert (equal (invert-matrix-optimized diagonal) expected)))\n  \n  ;; Test general 2x2 matrix\n  (let ((matrix '((1 2) (3 4)))\n        (expected '((-2.0 1.0) (1.5 -0.5))))\n    (cl-assert (equal (invert-matrix-optimized matrix) expected)))\n  \n  ;; Test general 3x3 matrix\n  (let ((matrix '((1 2 3) (0 1 4) (5 6 0)))\n        (expected '((-24.0 18.0 5.0) (20.0 -15.0 -4.0) (-5.0 4.0 1.0))))\n    (cl-assert (equal (invert-matrix-optimized matrix) expected)))\n  \n  ;; Test singular matrix (should return zero matrix)\n  (let ((singular '((1 1) (1 1)))\n        (zero-matrix '((0.0 0.0) (0.0 0.0))))\n    (cl-assert (equal (invert-matrix-optimized singular) zero-matrix))))\n\n(test-matrix-inversion)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Calculate properties of a regular octahedron in Emacs Lisp\n\n;;; octahedron-surface-area calculates the surface area of a regular octahedron.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: surface area as a float\n;;; Raises an error if edge is not positive\n(defun octahedron-surface-area (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (* 2 (sqrt 3) edge edge)))\n\n;;; octahedron-volume calculates the volume of a regular octahedron.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: volume as a float\n;;; Raises an error if edge is not positive\n(defun octahedron-volume (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (* (/ (sqrt 2) 3) edge edge edge)))\n\n;;; describe-octahedron returns a list describing the octahedron's properties.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: list with surface area and volume\n;;; Raises an error if edge is not positive\n(defun describe-octahedron (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (list (cons 'surface-area (octahedron-surface-area edge))\n          (cons 'volume (octahedron-volume edge)))))", "test_cases": "", "test_case_results": "", "task_id": 21176, "assertions": "(require 'cl-lib)\n\n(defun test-octahedron-properties ()\n  ;; Test valid edge lengths\n  (let ((result-1 (describe-octahedron 1)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-1)) 3.464102 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-1)) 0.471405 0.000001)))\n  \n  (let ((result-2 (describe-octahedron 2)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-2)) 13.856406 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-2)) 3.771236 0.000001)))\n  \n  (let ((result-3 (describe-octahedron 3.5)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-3)) 42.435244 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-3)) 20.225253 0.000001)))\n  \n  ;; Test invalid edge lengths\n  (cl-assert (eq (condition-case err\n                     (describe-octahedron 0)\n                   (error t))\n                 t))\n  \n  (cl-assert (eq (condition-case err\n                     (describe-octahedron -1)\n                   (error t))\n                 t)))\n\n;; Helper function for floating point comparison\n(defun approx-equal (a b tolerance)\n  (< (abs (- a b)) tolerance))\n\n(test-octahedron-properties)", "all_code": ";;; Calculate properties of a regular octahedron in Emacs Lisp\n\n;;; octahedron-surface-area calculates the surface area of a regular octahedron.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: surface area as a float\n;;; Raises an error if edge is not positive\n(defun octahedron-surface-area (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (* 2 (sqrt 3) edge edge)))\n\n;;; octahedron-volume calculates the volume of a regular octahedron.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: volume as a float\n;;; Raises an error if edge is not positive\n(defun octahedron-volume (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (* (/ (sqrt 2) 3) edge edge edge)))\n\n;;; describe-octahedron returns a list describing the octahedron's properties.\n;;; edge: length of the edge of the octahedron (must be positive)\n;;; Returns: list with surface area and volume\n;;; Raises an error if edge is not positive\n(defun describe-octahedron (edge)\n  (if (<= edge 0)\n      (error \"Edge length must be a positive number\")\n    (list (cons 'surface-area (octahedron-surface-area edge))\n          (cons 'volume (octahedron-volume edge)))))\n(require 'cl-lib)\n\n(defun test-octahedron-properties ()\n  ;; Test valid edge lengths\n  (let ((result-1 (describe-octahedron 1)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-1)) 3.464102 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-1)) 0.471405 0.000001)))\n  \n  (let ((result-2 (describe-octahedron 2)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-2)) 13.856406 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-2)) 3.771236 0.000001)))\n  \n  (let ((result-3 (describe-octahedron 3.5)))\n    (cl-assert (approx-equal (cdr (assoc 'surface-area result-3)) 42.435244 0.000001))\n    (cl-assert (approx-equal (cdr (assoc 'volume result-3)) 20.225253 0.000001)))\n  \n  ;; Test invalid edge lengths\n  (cl-assert (eq (condition-case err\n                     (describe-octahedron 0)\n                   (error t))\n                 t))\n  \n  (cl-assert (eq (condition-case err\n                     (describe-octahedron -1)\n                   (error t))\n                 t)))\n\n;; Helper function for floating point comparison\n(defun approx-equal (a b tolerance)\n  (< (abs (- a b)) tolerance))\n\n(test-octahedron-properties)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Library System in Emacs Lisp\n\n;;; The following code implements a simple library system that allows adding books,\n;;; looking them up by ISBN, and listing books by author.\n\n;;; Data Structures:\n;;; - books-by-isbn: An alist mapping ISBNs to book details (title, author, year).\n;;; - books-by-author: An alist mapping authors to lists of books sorted by year.\n;;;   Each book is represented as a list (year title isbn).\n\n;;; Add a book to the library system.\n;;; The book is added to both books-by-isbn and books-by-author.\n(defun library-add-book (books-by-isbn books-by-author isbn title author year)\n  \"Add a book to the library system.\nBOOKS-BY-ISBN and BOOKS-BY-AUTHOR are modified in place.\nISBN is the book's ISBN, TITLE its title, AUTHOR its author, and YEAR its publication year.\"\n  ;; Add to ISBN index\n  (setq books-by-isbn (cons (cons isbn (list title author year)) books-by-isbn))\n  \n  ;; Add to author index\n  (let ((author-entry (assoc author books-by-author)))\n    (if author-entry\n        ;; Author exists - add book and sort by year\n        (setcdr author-entry\n                (sort (cons (list year title isbn) (cdr author-entry))\n                      (lambda (a b) (< (car a) (car b)))))\n      ;; New author - create entry\n      (setq books-by-author (cons (list author (list year title isbn)) books-by-author))))\n  \n  (list books-by-isbn books-by-author))\n\n;;; Look up a book by ISBN.\n(defun library-lookup-by-isbn (books-by-isbn isbn)\n  \"Look up a book by ISBN in BOOKS-BY-ISBN.\nReturns a string with book details or 'Book not found'.\"\n  (let ((book (assoc isbn books-by-isbn)))\n    (if book\n        (let ((title (nth 0 (cdr book)))\n              (author (nth 1 (cdr book)))\n              (year (nth 2 (cdr book))))\n          (format \"%s %s %d\" title author year))\n      \"Book not found\")))\n\n;;; List all books by a given author.\n(defun library-list-books-by-author (books-by-author author)\n  \"List all books by AUTHOR in BOOKS-BY-AUTHOR.\nReturns a list of formatted strings or a not found message.\"\n  (let ((author-books (assoc author books-by-author)))\n    (if author-books\n        (mapcar (lambda (book)\n                  (let ((year (nth 0 book))\n                        (title (nth 1 book))\n                        (isbn (nth 2 book)))\n                    (format \"%s %s %d\" title isbn year)))\n                (cdr author-books))\n      (format \"No books found by %s\" author))))", "test_cases": "", "test_case_results": "", "task_id": 11307, "assertions": "(require 'cl-lib)\n\n(defun test-library-system ()\n  (let ((books-by-isbn '())\n        (books-by-author '()))\n    ;; Test adding books\n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"123\" \"The Hobbit\" \"Tolkien\" 1937)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"123\")\n                       \"The Hobbit Tolkien 1937\")))\n    \n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"456\" \"The Lord of the Rings\" \"Tolkien\" 1954)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"456\")\n                       \"The Lord of the Rings Tolkien 1954\")))\n    \n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"789\" \"Dune\" \"Herbert\" 1965)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"789\")\n                       \"Dune Herbert 1965\")))\n    \n    ;; Test ISBN lookup\n    (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"123\")\n                     \"The Hobbit Tolkien 1937\"))\n    (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"999\")\n                     \"Book not found\"))\n    \n    ;; Test author listing\n    (cl-assert (equal (library-list-books-by-author books-by-author \"Tolkien\")\n                     '(\"The Hobbit 123 1937\" \"The Lord of the Rings 456 1954\")))\n    (cl-assert (equal (library-list-books-by-author books-by-author \"Asimov\")\n                     \"No books found by Asimov\"))))\n\n(test-library-system)", "all_code": ";;; Library System in Emacs Lisp\n\n;;; The following code implements a simple library system that allows adding books,\n;;; looking them up by ISBN, and listing books by author.\n\n;;; Data Structures:\n;;; - books-by-isbn: An alist mapping ISBNs to book details (title, author, year).\n;;; - books-by-author: An alist mapping authors to lists of books sorted by year.\n;;;   Each book is represented as a list (year title isbn).\n\n;;; Add a book to the library system.\n;;; The book is added to both books-by-isbn and books-by-author.\n(defun library-add-book (books-by-isbn books-by-author isbn title author year)\n  \"Add a book to the library system.\nBOOKS-BY-ISBN and BOOKS-BY-AUTHOR are modified in place.\nISBN is the book's ISBN, TITLE its title, AUTHOR its author, and YEAR its publication year.\"\n  ;; Add to ISBN index\n  (setq books-by-isbn (cons (cons isbn (list title author year)) books-by-isbn))\n  \n  ;; Add to author index\n  (let ((author-entry (assoc author books-by-author)))\n    (if author-entry\n        ;; Author exists - add book and sort by year\n        (setcdr author-entry\n                (sort (cons (list year title isbn) (cdr author-entry))\n                      (lambda (a b) (< (car a) (car b)))))\n      ;; New author - create entry\n      (setq books-by-author (cons (list author (list year title isbn)) books-by-author))))\n  \n  (list books-by-isbn books-by-author))\n\n;;; Look up a book by ISBN.\n(defun library-lookup-by-isbn (books-by-isbn isbn)\n  \"Look up a book by ISBN in BOOKS-BY-ISBN.\nReturns a string with book details or 'Book not found'.\"\n  (let ((book (assoc isbn books-by-isbn)))\n    (if book\n        (let ((title (nth 0 (cdr book)))\n              (author (nth 1 (cdr book)))\n              (year (nth 2 (cdr book))))\n          (format \"%s %s %d\" title author year))\n      \"Book not found\")))\n\n;;; List all books by a given author.\n(defun library-list-books-by-author (books-by-author author)\n  \"List all books by AUTHOR in BOOKS-BY-AUTHOR.\nReturns a list of formatted strings or a not found message.\"\n  (let ((author-books (assoc author books-by-author)))\n    (if author-books\n        (mapcar (lambda (book)\n                  (let ((year (nth 0 book))\n                        (title (nth 1 book))\n                        (isbn (nth 2 book)))\n                    (format \"%s %s %d\" title isbn year)))\n                (cdr author-books))\n      (format \"No books found by %s\" author))))\n(require 'cl-lib)\n\n(defun test-library-system ()\n  (let ((books-by-isbn '())\n        (books-by-author '()))\n    ;; Test adding books\n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"123\" \"The Hobbit\" \"Tolkien\" 1937)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"123\")\n                       \"The Hobbit Tolkien 1937\")))\n    \n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"456\" \"The Lord of the Rings\" \"Tolkien\" 1954)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"456\")\n                       \"The Lord of the Rings Tolkien 1954\")))\n    \n    (let ((result (library-add-book books-by-isbn books-by-author \n                                   \"789\" \"Dune\" \"Herbert\" 1965)))\n      (setq books-by-isbn (nth 0 result))\n      (setq books-by-author (nth 1 result))\n      (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"789\")\n                       \"Dune Herbert 1965\")))\n    \n    ;; Test ISBN lookup\n    (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"123\")\n                     \"The Hobbit Tolkien 1937\"))\n    (cl-assert (equal (library-lookup-by-isbn books-by-isbn \"999\")\n                     \"Book not found\"))\n    \n    ;; Test author listing\n    (cl-assert (equal (library-list-books-by-author books-by-author \"Tolkien\")\n                     '(\"The Hobbit 123 1937\" \"The Lord of the Rings 456 1954\")))\n    (cl-assert (equal (library-list-books-by-author books-by-author \"Asimov\")\n                     \"No books found by Asimov\"))))\n\n(test-library-system)", "exec_outcome": "PASSED"}
{"code": ";; This function calculates the total savings based on a special pricing scheme:\n;; - Items are sorted in descending order\n;; - Processed in triplets when possible\n;; - For each triplet, if the smallest item meets a certain percentage threshold,\n;;   we get that item for free (only pay for the two more expensive items)\n;; - Otherwise, apply a percentage discount to the whole triplet\n;; - Remaining items (not in complete triplets) get the percentage discount\n(defun calculate-total-savings (prices q)\n  \"Calculate total savings given PRICES list and percentage Q.\nPRICES should be a list of integers, Q an integer percentage.\"\n  (let ((sorted-prices (sort (copy-sequence prices) '>))\n        (total 0)\n        (i 0)\n        (n (length prices)))\n    (while (< i n)\n      (if (<= (+ i 2) (- n 1))  ; Check if we can form a triplet\n          (let* ((a (nth i sorted-prices))\n                 (b (nth (+ i 1) sorted-prices))\n                 (c (nth (+ i 2) sorted-prices))\n                 (sum3 (+ a b c))\n                 (saved c))\n            (if (> (* saved 100) (* q sum3))\n                (progn\n                  (setq total (+ total a b))  ; Pay for two most expensive\n                  (setq i (+ i 3)))\n              (progn\n                (setq total (+ total (/ (* sum3 (- 100 q)) 100)))\n                (setq i (+ i 3)))))\n        (progn  ; Process remaining items\n          (let ((sum-remaining (apply '+ (seq-subseq sorted-prices i))))\n            (setq total (+ total (/ (* sum-remaining (- 100 q)) 100)))\n            (setq i n)))))  ; Break the loop\n    total))", "test_cases": "", "test_case_results": "", "task_id": 28531, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-total-savings ()\n  ;; Test cases derived from the original test cases in the code\n  (cl-assert (= (calculate-total-savings '(100 200 300 400 500) 50) 750))\n  (cl-assert (= (calculate-total-savings '(50 50 50 50) 33) 134))\n  (cl-assert (= (calculate-total-savings '(1000 500 100 50 20) 10) 1503))\n  (cl-assert (= (calculate-total-savings '(10 20 30) 25) 45))\n  (cl-assert (= (calculate-total-savings '(5) 10) 4)))\n\n(test-calculate-total-savings)", "all_code": ";; This function calculates the total savings based on a special pricing scheme:\n;; - Items are sorted in descending order\n;; - Processed in triplets when possible\n;; - For each triplet, if the smallest item meets a certain percentage threshold,\n;;   we get that item for free (only pay for the two more expensive items)\n;; - Otherwise, apply a percentage discount to the whole triplet\n;; - Remaining items (not in complete triplets) get the percentage discount\n(defun calculate-total-savings (prices q)\n  \"Calculate total savings given PRICES list and percentage Q.\nPRICES should be a list of integers, Q an integer percentage.\"\n  (let ((sorted-prices (sort (copy-sequence prices) '>))\n        (total 0)\n        (i 0)\n        (n (length prices)))\n    (while (< i n)\n      (if (<= (+ i 2) (- n 1))  ; Check if we can form a triplet\n          (let* ((a (nth i sorted-prices))\n                 (b (nth (+ i 1) sorted-prices))\n                 (c (nth (+ i 2) sorted-prices))\n                 (sum3 (+ a b c))\n                 (saved c))\n            (if (> (* saved 100) (* q sum3))\n                (progn\n                  (setq total (+ total a b))  ; Pay for two most expensive\n                  (setq i (+ i 3)))\n              (progn\n                (setq total (+ total (/ (* sum3 (- 100 q)) 100)))\n                (setq i (+ i 3)))))\n        (progn  ; Process remaining items\n          (let ((sum-remaining (apply '+ (seq-subseq sorted-prices i))))\n            (setq total (+ total (/ (* sum-remaining (- 100 q)) 100)))\n            (setq i n)))))  ; Break the loop\n    total))\n(require 'cl-lib)\n\n(defun test-calculate-total-savings ()\n  ;; Test cases derived from the original test cases in the code\n  (cl-assert (= (calculate-total-savings '(100 200 300 400 500) 50) 750))\n  (cl-assert (= (calculate-total-savings '(50 50 50 50) 33) 134))\n  (cl-assert (= (calculate-total-savings '(1000 500 100 50 20) 10) 1503))\n  (cl-assert (= (calculate-total-savings '(10 20 30) 25) 45))\n  (cl-assert (= (calculate-total-savings '(5) 10) 4)))\n\n(test-calculate-total-savings)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; Define the mapping of each character to its number of presses\n(defconst *char-cost*\n  '((?a . 1) (?b . 2) (?c . 3)\n    (?d . 1) (?e . 2) (?f . 3)\n    (?g . 1) (?h . 2) (?i . 3)\n    (?j . 1) (?k . 2) (?l . 3)\n    (?m . 1) (?n . 2) (?o . 3)\n    (?p . 1) (?q . 2) (?r . 3)\n    (?s . 1) (?t . 2) (?u . 3)\n    (?v . 1) (?w . 2) (?x . 3)\n    (?y . 1) (?z . 2)\n    (?\\s . 1) (?. . 1) (?, . 2) (?! . 3)))\n\n;; calculate-total-presses computes the total number of key presses\n;; required for a given string based on the *char-cost* mapping.\n(defun calculate-total-presses (slogan)\n  (let ((total 0))\n    (dolist (char (string-to-list slogan) total)\n      (setq total (+ total (or (cdr (assq char *char-cost*)) 0)))))", "test_cases": "", "test_case_results": "", "task_id": 4648, "assertions": "(require 'cl-lib)\n\n(defun test-calculate-total-presses ()\n  ;; Test basic words\n  (cl-assert (= (calculate-total-presses \"hello\") 10))\n  (cl-assert (= (calculate-total-presses \"world\") 11))\n  ;; Test with spaces and punctuation\n  (cl-assert (= (calculate-total-presses \"hello world\") 17))\n  (cl-assert (= (calculate-total-presses \"emacs lisp!\") 18))\n  ;; Test mixed characters\n  (cl-assert (= (calculate-total-presses \"a.b,c d!e\") 9))\n  ;; Test empty string\n  (cl-assert (= (calculate-total-presses \"\") 0)))\n\n(test-calculate-total-presses)", "all_code": ";; Define the mapping of each character to its number of presses\n(defconst *char-cost*\n  '((?a . 1) (?b . 2) (?c . 3)\n    (?d . 1) (?e . 2) (?f . 3)\n    (?g . 1) (?h . 2) (?i . 3)\n    (?j . 1) (?k . 2) (?l . 3)\n    (?m . 1) (?n . 2) (?o . 3)\n    (?p . 1) (?q . 2) (?r . 3)\n    (?s . 1) (?t . 2) (?u . 3)\n    (?v . 1) (?w . 2) (?x . 3)\n    (?y . 1) (?z . 2)\n    (?\\s . 1) (?. . 1) (?, . 2) (?! . 3)))\n\n;; calculate-total-presses computes the total number of key presses\n;; required for a given string based on the *char-cost* mapping.\n(defun calculate-total-presses (slogan)\n  (let ((total 0))\n    (dolist (char (string-to-list slogan) total)\n      (setq total (+ total (or (cdr (assq char *char-cost*)) 0)))))\n(require 'cl-lib)\n\n(defun test-calculate-total-presses ()\n  ;; Test basic words\n  (cl-assert (= (calculate-total-presses \"hello\") 10))\n  (cl-assert (= (calculate-total-presses \"world\") 11))\n  ;; Test with spaces and punctuation\n  (cl-assert (= (calculate-total-presses \"hello world\") 17))\n  (cl-assert (= (calculate-total-presses \"emacs lisp!\") 18))\n  ;; Test mixed characters\n  (cl-assert (= (calculate-total-presses \"a.b,c d!e\") 9))\n  ;; Test empty string\n  (cl-assert (= (calculate-total-presses \"\") 0)))\n\n(test-calculate-total-presses)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function calculates the maximum length of a subarray that has the same first and last elements.\n;;; The function iterates through all possible subarrays and checks if the first and last elements are the same.\n;;; If they are, it updates the maximum length found so far.\n\n(defun max-length-subarray-with-same-ends (arr)\n  \"Returns the maximum number of elements in a subarray that has the same first and last elements.\n   \n   Parameters:\n   ARR - A list of integers\n   \n   Returns:\n   The maximum length of such subarray.\"\n  (let ((n (length arr))\n        (max-len 0))\n    (if (eq n 0)\n        0\n      (dotimes (i n max-len)\n        (dotimes (j (- n i))\n          (when (eq (nth i arr) (nth (+ i j) arr))\n            (setq max-len (max max-len (1+ j)))))))))", "test_cases": "", "test_case_results": "", "task_id": 12022, "assertions": "(require 'cl-lib)\n\n(defun test-max-length-subarray ()\n  (cl-assert (= (max-length-subarray-with-same-ends '(1 2 3 4 1)) 5))\n  (cl-assert (= (max-length-subarray-with-same-ends '(5 6 7 0 0)) 2))\n  (cl-assert (= (max-length-subarray-with-same-ends '(0 0 0 0)) 4))\n  (cl-assert (= (max-length-subarray-with-same-ends '(1 2 3 4)) 1))\n  (cl-assert (= (max-length-subarray-with-same-ends '()) 0)))\n\n(test-max-length-subarray)", "all_code": ";;; This function calculates the maximum length of a subarray that has the same first and last elements.\n;;; The function iterates through all possible subarrays and checks if the first and last elements are the same.\n;;; If they are, it updates the maximum length found so far.\n\n(defun max-length-subarray-with-same-ends (arr)\n  \"Returns the maximum number of elements in a subarray that has the same first and last elements.\n   \n   Parameters:\n   ARR - A list of integers\n   \n   Returns:\n   The maximum length of such subarray.\"\n  (let ((n (length arr))\n        (max-len 0))\n    (if (eq n 0)\n        0\n      (dotimes (i n max-len)\n        (dotimes (j (- n i))\n          (when (eq (nth i arr) (nth (+ i j) arr))\n            (setq max-len (max max-len (1+ j)))))))))\n(require 'cl-lib)\n\n(defun test-max-length-subarray ()\n  (cl-assert (= (max-length-subarray-with-same-ends '(1 2 3 4 1)) 5))\n  (cl-assert (= (max-length-subarray-with-same-ends '(5 6 7 0 0)) 2))\n  (cl-assert (= (max-length-subarray-with-same-ends '(0 0 0 0)) 4))\n  (cl-assert (= (max-length-subarray-with-same-ends '(1 2 3 4)) 1))\n  (cl-assert (= (max-length-subarray-with-same-ends '()) 0)))\n\n(test-max-length-subarray)", "exec_outcome": "PASSED"}
{"code": ";;; This code implements a dynamic programming solution to find the maximum path sum\n;;; in a grid where you can only move right or down, but only to cells with greater values.\n\n;;; Function to create a 2D list (matrix) filled with zeros\n(defun make-zero-matrix (rows cols)\n  \"Create a ROWS x COLS matrix filled with zeros.\"\n  (make-list rows (make-list cols 0)))\n\n;;; Function to compute the right dynamic programming matrix\n(defun compute-right-dp (matrix)\n  \"Compute the right DP matrix where each cell contains the maximum sum path\nstarting from that cell and moving right to increasing values.\"\n  (let* ((rows (length matrix))\n         (cols (length (car matrix)))\n         (dp (make-zero-matrix rows cols)))\n    (dotimes (i rows)\n      (dotimes (j cols)\n        (let ((j-rev (- cols j 1))) ; Process columns in reverse order\n          (setf (nth j-rev (nth i dp))\n                (cond ((= j-rev (1- cols)) (nth j-rev (nth i matrix)))\n                      ((< (nth j-rev (nth i matrix)) (nth (1+ j-rev) (nth i matrix)))\n                       (+ (nth j-rev (nth i matrix)) (nth (1+ j-rev) (nth i dp))))\n                      (t (nth j-rev (nth i matrix))))))))\n    dp))\n\n;;; Function to compute the down dynamic programming matrix\n(defun compute-down-dp (matrix)\n  \"Compute the down DP matrix where each cell contains the maximum sum path\nstarting from that cell and moving down to increasing values.\"\n  (let* ((rows (length matrix))\n         (cols (length (car matrix)))\n         (dp (make-zero-matrix rows cols)))\n    (dotimes (j cols)\n      (dotimes (i rows)\n        (let ((i-rev (- rows i 1))) ; Process rows in reverse order\n          (setf (nth j (nth i-rev dp))\n                (cond ((= i-rev (1- rows)) (nth j (nth i-rev matrix)))\n                      ((< (nth j (nth i-rev matrix)) (nth j (nth (1+ i-rev) matrix)))\n                       (+ (nth j (nth i-rev matrix)) (nth j (nth (1+ i-rev) dp))))\n                      (t (nth j (nth i-rev matrix))))))))\n    dp))\n\n;;; Function to find the maximum value in both DP matrices\n(defun find-max-value (right-dp down-dp)\n  \"Find the maximum value between the right and down DP matrices.\"\n  (let ((max-val 0))\n    (dolist (row right-dp)\n      (dolist (val row)\n        (when (> val max-val)\n          (setq max-val val))))\n    (dolist (row down-dp)\n      (dolist (val row)\n        (when (> val max-val)\n          (setq max-val val))))\n    max-val))\n\n;;; Main function that combines all steps\n(defun find-max-path-sum (matrix)\n  \"Find the maximum path sum in the matrix where you can only move right or down\nto cells with greater values.\"\n  (let ((right-dp (compute-right-dp matrix))\n        (down-dp (compute-down-dp matrix)))\n    (find-max-value right-dp down-dp)))", "test_cases": "", "test_case_results": "", "task_id": 29956, "assertions": "(require 'cl-lib)\n\n(defun test-max-path-sum ()\n  (let ((test-cases '((((1 2 3) (4 5 6) (7 8 9)) . 45)  ; Simple increasing matrix\n                      (((9 8 7) (6 5 4) (3 2 1)) . 9)   ; Simple decreasing matrix\n                      (((1 2 1) (2 1 2) (1 2 1)) . 5)   ; Checkerboard pattern\n                      (((3 1 4) (2 5 6) (7 2 8)) . 25)))) ; Random values\n    (dolist (test-case test-cases)\n      (let ((matrix (car test-case))\n            (expected (cdr test-case))\n            (result (find-max-path-sum matrix)))\n        (cl-assert (= result expected) nil\n                   \"Test failed for matrix %S: expected %d, got %d\"\n                   matrix expected result)))))\n\n(test-max-path-sum)", "all_code": ";;; This code implements a dynamic programming solution to find the maximum path sum\n;;; in a grid where you can only move right or down, but only to cells with greater values.\n\n;;; Function to create a 2D list (matrix) filled with zeros\n(defun make-zero-matrix (rows cols)\n  \"Create a ROWS x COLS matrix filled with zeros.\"\n  (make-list rows (make-list cols 0)))\n\n;;; Function to compute the right dynamic programming matrix\n(defun compute-right-dp (matrix)\n  \"Compute the right DP matrix where each cell contains the maximum sum path\nstarting from that cell and moving right to increasing values.\"\n  (let* ((rows (length matrix))\n         (cols (length (car matrix)))\n         (dp (make-zero-matrix rows cols)))\n    (dotimes (i rows)\n      (dotimes (j cols)\n        (let ((j-rev (- cols j 1))) ; Process columns in reverse order\n          (setf (nth j-rev (nth i dp))\n                (cond ((= j-rev (1- cols)) (nth j-rev (nth i matrix)))\n                      ((< (nth j-rev (nth i matrix)) (nth (1+ j-rev) (nth i matrix)))\n                       (+ (nth j-rev (nth i matrix)) (nth (1+ j-rev) (nth i dp))))\n                      (t (nth j-rev (nth i matrix))))))))\n    dp))\n\n;;; Function to compute the down dynamic programming matrix\n(defun compute-down-dp (matrix)\n  \"Compute the down DP matrix where each cell contains the maximum sum path\nstarting from that cell and moving down to increasing values.\"\n  (let* ((rows (length matrix))\n         (cols (length (car matrix)))\n         (dp (make-zero-matrix rows cols)))\n    (dotimes (j cols)\n      (dotimes (i rows)\n        (let ((i-rev (- rows i 1))) ; Process rows in reverse order\n          (setf (nth j (nth i-rev dp))\n                (cond ((= i-rev (1- rows)) (nth j (nth i-rev matrix)))\n                      ((< (nth j (nth i-rev matrix)) (nth j (nth (1+ i-rev) matrix)))\n                       (+ (nth j (nth i-rev matrix)) (nth j (nth (1+ i-rev) dp))))\n                      (t (nth j (nth i-rev matrix))))))))\n    dp))\n\n;;; Function to find the maximum value in both DP matrices\n(defun find-max-value (right-dp down-dp)\n  \"Find the maximum value between the right and down DP matrices.\"\n  (let ((max-val 0))\n    (dolist (row right-dp)\n      (dolist (val row)\n        (when (> val max-val)\n          (setq max-val val))))\n    (dolist (row down-dp)\n      (dolist (val row)\n        (when (> val max-val)\n          (setq max-val val))))\n    max-val))\n\n;;; Main function that combines all steps\n(defun find-max-path-sum (matrix)\n  \"Find the maximum path sum in the matrix where you can only move right or down\nto cells with greater values.\"\n  (let ((right-dp (compute-right-dp matrix))\n        (down-dp (compute-down-dp matrix)))\n    (find-max-value right-dp down-dp)))\n(require 'cl-lib)\n\n(defun test-max-path-sum ()\n  (let ((test-cases '((((1 2 3) (4 5 6) (7 8 9)) . 45)  ; Simple increasing matrix\n                      (((9 8 7) (6 5 4) (3 2 1)) . 9)   ; Simple decreasing matrix\n                      (((1 2 1) (2 1 2) (1 2 1)) . 5)   ; Checkerboard pattern\n                      (((3 1 4) (2 5 6) (7 2 8)) . 25)))) ; Random values\n    (dolist (test-case test-cases)\n      (let ((matrix (car test-case))\n            (expected (cdr test-case))\n            (result (find-max-path-sum matrix)))\n        (cl-assert (= result expected) nil\n                   \"Test failed for matrix %S: expected %d, got %d\"\n                   matrix expected result)))))\n\n(test-max-path-sum)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function calculates the maximum number of participants Anastasia can cater to\n;;; with the given resources of pizzas, sandwiches, and drinks.\n;;; \n;;; Args:\n;;; p - Number of pizzas (1 pizza per participant).\n;;; s - Number of sandwiches (2 sandwiches per participant).\n;;; d - Number of drinks (3 drinks per participant).\n;;;\n;;; Returns:\n;;; The maximum number of participants based on the limiting resource.\n(defun max-participants (p s d)\n  (let ((participants-by-pizza p)\n        (participants-by-sandwiches (/ s 2))\n        (participants-by-drinks (/ d 3)))\n    (min participants-by-pizza participants-by-sandwiches participants-by-drinks)))", "test_cases": "", "test_case_results": "", "task_id": 6943, "assertions": "(require 'cl-lib)\n\n(defun test-max-participants ()\n  (cl-assert (= (max-participants 10 20 30) 10))   ; All resources allow 10 participants\n  (cl-assert (= (max-participants 5 20 30) 5))     ; Pizza limits to 5 participants\n  (cl-assert (= (max-participants 10 10 30) 5))    ; Sandwiches limit to 5 participants\n  (cl-assert (= (max-participants 10 20 9) 3)))    ; Drinks limit to 3 participants\n\n(test-max-participants)", "all_code": ";;; This function calculates the maximum number of participants Anastasia can cater to\n;;; with the given resources of pizzas, sandwiches, and drinks.\n;;; \n;;; Args:\n;;; p - Number of pizzas (1 pizza per participant).\n;;; s - Number of sandwiches (2 sandwiches per participant).\n;;; d - Number of drinks (3 drinks per participant).\n;;;\n;;; Returns:\n;;; The maximum number of participants based on the limiting resource.\n(defun max-participants (p s d)\n  (let ((participants-by-pizza p)\n        (participants-by-sandwiches (/ s 2))\n        (participants-by-drinks (/ d 3)))\n    (min participants-by-pizza participants-by-sandwiches participants-by-drinks)))\n(require 'cl-lib)\n\n(defun test-max-participants ()\n  (cl-assert (= (max-participants 10 20 30) 10))   ; All resources allow 10 participants\n  (cl-assert (= (max-participants 5 20 30) 5))     ; Pizza limits to 5 participants\n  (cl-assert (= (max-participants 10 10 30) 5))    ; Sandwiches limit to 5 participants\n  (cl-assert (= (max-participants 10 20 9) 3)))    ; Drinks limit to 3 participants\n\n(test-max-participants)", "exec_outcome": "PASSED"}
{"code": ";; This Emacs Lisp code implements a dynamic programming solution to the problem of\n;; distributing K candies to n children with constraints on the maximum candies per child.\n;; The solution uses prefix sums to optimize the computation.\n\n(defconst *mod* (+ (expt 10 9) 7))  ; Define the modulus value\n\n;; compute-candy-distribution calculates the number of ways to distribute K candies\n;; to n children with each child getting at most a_i candies.\n;; Parameters:\n;; - a: list of integers representing the maximum candies each child can take\n;; - K: total number of candies to distribute\n;; Returns: number of ways modulo 10^9 + 7\n(defun compute-candy-distribution (a K)\n  (let ((prev-dp (make-vector (+ K 1) 0)))\n    (aset prev-dp 0 1)  ; Base case: 0 candies to 0 children\n    (dolist (ai a)\n      (let ((current-dp (make-vector (+ K 1) 0))\n            (pre-sum (make-vector (+ K 1) 0)))\n        (aset pre-sum 0 (aref prev-dp 0))\n        ;; Compute prefix sums for the previous DP state\n        (dotimes (j K)\n          (aset pre-sum (+ j 1) (mod (+ (aref pre-sum j) (aref prev-dp (+ j 1))) *mod*)))\n        ;; Calculate current DP values using prefix sums\n        (dotimes (j (+ K 1))\n          (let ((lower (max 0 (- j ai))))\n            (if (= lower 0)\n                (aset current-dp j (mod (aref pre-sum j) *mod*))\n              (aset current-dp j (mod (- (aref pre-sum j) (aref pre-sum (- lower 1))) *mod*)))))\n        (setq prev-dp current-dp)))\n    (aref prev-dp K)))", "test_cases": "", "test_case_results": "", "task_id": 15452, "assertions": "(require 'cl-lib)\n\n(defun test-candy-distribution ()\n  ;; Test case 1: a=(2,3,5), K=5\n  (cl-assert (= (compute-candy-distribution '(2 3 5) 5) 3))\n  \n  ;; Test case 2: a=(1,2,3), K=3\n  (cl-assert (= (compute-candy-distribution '(1 2 3) 3) 4))\n  \n  ;; Test case 3: a=(10,10), K=20\n  (cl-assert (= (compute-candy-distribution '(10 10) 20) 1)))\n\n(test-candy-distribution)", "all_code": ";; This Emacs Lisp code implements a dynamic programming solution to the problem of\n;; distributing K candies to n children with constraints on the maximum candies per child.\n;; The solution uses prefix sums to optimize the computation.\n\n(defconst *mod* (+ (expt 10 9) 7))  ; Define the modulus value\n\n;; compute-candy-distribution calculates the number of ways to distribute K candies\n;; to n children with each child getting at most a_i candies.\n;; Parameters:\n;; - a: list of integers representing the maximum candies each child can take\n;; - K: total number of candies to distribute\n;; Returns: number of ways modulo 10^9 + 7\n(defun compute-candy-distribution (a K)\n  (let ((prev-dp (make-vector (+ K 1) 0)))\n    (aset prev-dp 0 1)  ; Base case: 0 candies to 0 children\n    (dolist (ai a)\n      (let ((current-dp (make-vector (+ K 1) 0))\n            (pre-sum (make-vector (+ K 1) 0)))\n        (aset pre-sum 0 (aref prev-dp 0))\n        ;; Compute prefix sums for the previous DP state\n        (dotimes (j K)\n          (aset pre-sum (+ j 1) (mod (+ (aref pre-sum j) (aref prev-dp (+ j 1))) *mod*)))\n        ;; Calculate current DP values using prefix sums\n        (dotimes (j (+ K 1))\n          (let ((lower (max 0 (- j ai))))\n            (if (= lower 0)\n                (aset current-dp j (mod (aref pre-sum j) *mod*))\n              (aset current-dp j (mod (- (aref pre-sum j) (aref pre-sum (- lower 1))) *mod*)))))\n        (setq prev-dp current-dp)))\n    (aref prev-dp K)))\n(require 'cl-lib)\n\n(defun test-candy-distribution ()\n  ;; Test case 1: a=(2,3,5), K=5\n  (cl-assert (= (compute-candy-distribution '(2 3 5) 5) 3))\n  \n  ;; Test case 2: a=(1,2,3), K=3\n  (cl-assert (= (compute-candy-distribution '(1 2 3) 3) 4))\n  \n  ;; Test case 3: a=(10,10), K=20\n  (cl-assert (= (compute-candy-distribution '(10 10) 20) 1)))\n\n(test-candy-distribution)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; Generate all possible combinations of characters from a list where each character is used at most once.\n;; The combinations range in length from 1 to the total number of characters in the list.\n\n;; all-combinations generates all possible combinations of characters from the input list.\n;; The combinations are returned as a list of lists.\n(defun all-combinations (char-list)\n  \"Generate all possible combinations of characters from CHAR-LIST.\nEach character is used at most once in a combination, and the length of\ncombinations ranges from 1 to the length of CHAR-LIST.\"\n  (let ((result '()))\n    (dotimes (i (length char-list))\n      (setq i (1+ i)) ; because dotimes starts from 0 to (length char-list - 1)\n      (dolist (comb (combinations char-list i))\n        (setq result (cons comb result))))\n    (reverse result)))\n\n;; Helper function to generate combinations of a specific length.\n(defun combinations (lst n)\n  \"Generate all combinations of LST taken N at a time.\"\n  (cond ((zerop n) '(()))\n        ((null lst) '())\n        (t (append (mapcar (lambda (x) (cons (car lst) x))\n                           (combinations (cdr lst) (1- n)))\n                   (combinations (cdr lst) n)))))", "test_cases": "", "test_case_results": "", "task_id": 12069, "assertions": "(require 'cl-lib)\n\n(defun test-combinations ()\n  ;; Test case 1: (?a ?b ?c)\n  (cl-assert (equal (all-combinations '(?a ?b ?c))\n                    '((?a) (?b) (?c) \n                      (?a ?b) (?a ?c) (?b ?c) \n                      (?a ?b ?c))))\n  \n  ;; Test case 2: (?x ?y)\n  (cl-assert (equal (all-combinations '(?x ?y))\n                    '((?x) (?y) (?x ?y))))\n  \n  ;; Test case 3: (?1 ?2 ?3 ?4)\n  (cl-assert (equal (all-combinations '(?1 ?2 ?3 ?4))\n                    '((?1) (?2) (?3) (?4)\n                      (?1 ?2) (?1 ?3) (?1 ?4) (?2 ?3) (?2 ?4) (?3 ?4)\n                      (?1 ?2 ?3) (?1 ?2 ?4) (?1 ?3 ?4) (?2 ?3 ?4)\n                      (?1 ?2 ?3 ?4)))))\n\n(test-combinations)", "all_code": ";; Generate all possible combinations of characters from a list where each character is used at most once.\n;; The combinations range in length from 1 to the total number of characters in the list.\n\n;; all-combinations generates all possible combinations of characters from the input list.\n;; The combinations are returned as a list of lists.\n(defun all-combinations (char-list)\n  \"Generate all possible combinations of characters from CHAR-LIST.\nEach character is used at most once in a combination, and the length of\ncombinations ranges from 1 to the length of CHAR-LIST.\"\n  (let ((result '()))\n    (dotimes (i (length char-list))\n      (setq i (1+ i)) ; because dotimes starts from 0 to (length char-list - 1)\n      (dolist (comb (combinations char-list i))\n        (setq result (cons comb result))))\n    (reverse result)))\n\n;; Helper function to generate combinations of a specific length.\n(defun combinations (lst n)\n  \"Generate all combinations of LST taken N at a time.\"\n  (cond ((zerop n) '(()))\n        ((null lst) '())\n        (t (append (mapcar (lambda (x) (cons (car lst) x))\n                           (combinations (cdr lst) (1- n)))\n                   (combinations (cdr lst) n)))))\n(require 'cl-lib)\n\n(defun test-combinations ()\n  ;; Test case 1: (?a ?b ?c)\n  (cl-assert (equal (all-combinations '(?a ?b ?c))\n                    '((?a) (?b) (?c) \n                      (?a ?b) (?a ?c) (?b ?c) \n                      (?a ?b ?c))))\n  \n  ;; Test case 2: (?x ?y)\n  (cl-assert (equal (all-combinations '(?x ?y))\n                    '((?x) (?y) (?x ?y))))\n  \n  ;; Test case 3: (?1 ?2 ?3 ?4)\n  (cl-assert (equal (all-combinations '(?1 ?2 ?3 ?4))\n                    '((?1) (?2) (?3) (?4)\n                      (?1 ?2) (?1 ?3) (?1 ?4) (?2 ?3) (?2 ?4) (?3 ?4)\n                      (?1 ?2 ?3) (?1 ?2 ?4) (?1 ?3 ?4) (?2 ?3 ?4)\n                      (?1 ?2 ?3 ?4)))))\n\n(test-combinations)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function filters and sorts a list of strings, returning only those with more than 3 characters\n;;; and sorting them alphabetically.\n;;;\n;;; Parameters:\n;;; strings - A list of strings to be processed\n;;;\n;;; Returns:\n;;; A sorted list of strings with length greater than 3\n\n(defun filter-and-sort-strings (strings)\n  \"Returns a sorted list of strings that have more than three characters.\"\n  (let ((filtered-strings (seq-filter (lambda (s) (> (length s) 3)) strings)))\n    (sort filtered-strings 'string<)))", "test_cases": "", "test_case_results": "", "task_id": 6772, "assertions": "(require 'cl-lib)\n\n(defun test-filter-and-sort-strings ()\n  (cl-assert (equal (filter-and-sort-strings '(\"a\" \"bb\" \"ccc\" \"dddd\" \"eeeee\" \"fffffff\"))\n                    '(\"dddd\" \"eeeee\" \"fffffff\")))\n  (cl-assert (equal (filter-and-sort-strings '(\"one\" \"two\" \"three\" \"four\" \"five\"))\n                    '(\"five\" \"four\" \"three\")))\n  (cl-assert (equal (filter-and-sort-strings '(\"cat\" \"dog\" \"elephant\" \"fish\" \"giraffe\"))\n                    '(\"elephant\" \"fish\" \"giraffe\"))))\n\n(test-filter-and-sort-strings)", "all_code": ";;; This function filters and sorts a list of strings, returning only those with more than 3 characters\n;;; and sorting them alphabetically.\n;;;\n;;; Parameters:\n;;; strings - A list of strings to be processed\n;;;\n;;; Returns:\n;;; A sorted list of strings with length greater than 3\n\n(defun filter-and-sort-strings (strings)\n  \"Returns a sorted list of strings that have more than three characters.\"\n  (let ((filtered-strings (seq-filter (lambda (s) (> (length s) 3)) strings)))\n    (sort filtered-strings 'string<)))\n(require 'cl-lib)\n\n(defun test-filter-and-sort-strings ()\n  (cl-assert (equal (filter-and-sort-strings '(\"a\" \"bb\" \"ccc\" \"dddd\" \"eeeee\" \"fffffff\"))\n                    '(\"dddd\" \"eeeee\" \"fffffff\")))\n  (cl-assert (equal (filter-and-sort-strings '(\"one\" \"two\" \"three\" \"four\" \"five\"))\n                    '(\"five\" \"four\" \"three\")))\n  (cl-assert (equal (filter-and-sort-strings '(\"cat\" \"dog\" \"elephant\" \"fish\" \"giraffe\"))\n                    '(\"elephant\" \"fish\" \"giraffe\"))))\n\n(test-filter-and-sort-strings)", "exec_outcome": "PASSED"}
{"code": ";;; Solution for the modified unbounded knapsack problem\n;;; The problem involves calculating maximum profit from remaining weight after\n;;; accounting for required items, with items being usable multiple times.\n\n;;; solve-knapsack-case handles a single test case of the problem\n;;; Parameters:\n;;;   n - number of different item types\n;;;   W - total weight capacity\n;;;   items - list of items where each item is (weight profit)\n;;;   required-weight - weight that must be taken\n;;; Returns either 'impossible or the maximum profit\n(defun solve-knapsack-case (n W items required-weight)\n  (cond\n   ((> required-weight W) 'impossible)\n   ((= (- W required-weight) 0) 0)\n   (t\n    (let* ((rem (- W required-weight))\n           (dp (make-vector (1+ rem) 0)))\n      (dotimes (j (1+ rem))\n        (when (> j 0)\n          (dolist (item items)\n            (let ((w (car item))\n                  (p (cadr item)))\n              (when (>= j w)\n                (aset dp j (max (aref dp j)\n                                (+ (aref dp (- j w)) p))))))))\n      (aref dp rem)))))", "test_cases": "", "test_case_results": "", "task_id": 17435, "assertions": "(require 'cl-lib)\n\n(defun test-knapsack-solution ()\n  (cl-assert (equal (solve-knapsack-case 3 50 '((10 20) (20 30) (30 40)) 30) 40))\n  (cl-assert (equal (solve-knapsack-case 2 100 '((20 50) (30 60)) 120) 'impossible))\n  (cl-assert (equal (solve-knapsack-case 4 80 '((5 10) (10 15) (15 20) (20 25)) 40) 40))\n  (cl-assert (equal (solve-knapsack-case 1 50 '((10 5)) 50) 0))\n  (cl-assert (equal (solve-knapsack-case 2 60 '((15 25) (20 35)) 30) 50)))\n\n(test-knapsack-solution)", "all_code": ";;; Solution for the modified unbounded knapsack problem\n;;; The problem involves calculating maximum profit from remaining weight after\n;;; accounting for required items, with items being usable multiple times.\n\n;;; solve-knapsack-case handles a single test case of the problem\n;;; Parameters:\n;;;   n - number of different item types\n;;;   W - total weight capacity\n;;;   items - list of items where each item is (weight profit)\n;;;   required-weight - weight that must be taken\n;;; Returns either 'impossible or the maximum profit\n(defun solve-knapsack-case (n W items required-weight)\n  (cond\n   ((> required-weight W) 'impossible)\n   ((= (- W required-weight) 0) 0)\n   (t\n    (let* ((rem (- W required-weight))\n           (dp (make-vector (1+ rem) 0)))\n      (dotimes (j (1+ rem))\n        (when (> j 0)\n          (dolist (item items)\n            (let ((w (car item))\n                  (p (cadr item)))\n              (when (>= j w)\n                (aset dp j (max (aref dp j)\n                                (+ (aref dp (- j w)) p))))))))\n      (aref dp rem)))))\n(require 'cl-lib)\n\n(defun test-knapsack-solution ()\n  (cl-assert (equal (solve-knapsack-case 3 50 '((10 20) (20 30) (30 40)) 30) 40))\n  (cl-assert (equal (solve-knapsack-case 2 100 '((20 50) (30 60)) 120) 'impossible))\n  (cl-assert (equal (solve-knapsack-case 4 80 '((5 10) (10 15) (15 20) (20 25)) 40) 40))\n  (cl-assert (equal (solve-knapsack-case 1 50 '((10 5)) 50) 0))\n  (cl-assert (equal (solve-knapsack-case 2 60 '((15 25) (20 35)) 30) 50)))\n\n(test-knapsack-solution)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This code implements a mathematical problem solution that:\n;;; 1. For a given number N, finds the largest k where k(k+1)/2 <= N\n;;; 2. If the sum equals N, prints all numbers from 1 to k\n;;; 3. Otherwise, prints all numbers from 1 to k+1 excluding one number\n\n;; find-largest-k finds the largest k where k(k+1)/2 <= N using binary search\n(defun find-largest-k (N)\n  (let ((low 1)\n        (high 200000)  ; Sufficiently large upper bound\n        (k 1))\n    (while (<= low high)\n      (let* ((mid (/ (+ low high) 2))\n             (s (/ (* mid (1+ mid)) 2)))\n        (if (<= s N)\n            (progn\n              (setq k mid)\n              (setq low (1+ mid)))\n          (setq high (1- mid)))))\n    k))\n\n;; print-numbers prints either:\n;; - numbers from 1 to k if their sum equals N\n;; - numbers from 1 to k+1 excluding one number otherwise\n(defun print-numbers (N)\n  (if (= N 1)\n      (message \"1\")\n    (let* ((k (find-largest-k N))\n           (total (/ (* k (1+ k)) 2)))\n      (if (= total N)\n          (message \"%S\" (number-sequence 1 k))\n        (let* ((excluded (+ (1+ k) (- total N)))\n               (numbers (delete excluded (number-sequence 1 (1+ k)))))\n          (message \"%S\" numbers))))))", "test_cases": "", "test_case_results": "", "task_id": 17699, "assertions": "(require 'cl-lib)\n\n(defun test-number-sequences ()\n  ;; Test cases inferred from the original code\n  (cl-assert (equal (print-numbers 1) \"1\"))\n  (cl-assert (equal (print-numbers 2) '(1)))\n  (cl-assert (equal (print-numbers 3) '(1 2)))\n  (cl-assert (equal (print-numbers 6) '(1 2 3)))\n  (cl-assert (equal (print-numbers 7) '(1 2 4)))\n  (cl-assert (equal (print-numbers 10) '(1 2 3 4)))\n  (cl-assert (equal (print-numbers 15) '(1 2 3 4 5)))\n  (cl-assert (equal (print-numbers 16) '(1 2 3 4 6)))\n  (cl-assert (equal (print-numbers 21) '(1 2 3 4 5 6)))\n  (cl-assert (equal (print-numbers 22) '(1 2 3 4 5 7))))\n\n(test-number-sequences)", "all_code": ";;; This code implements a mathematical problem solution that:\n;;; 1. For a given number N, finds the largest k where k(k+1)/2 <= N\n;;; 2. If the sum equals N, prints all numbers from 1 to k\n;;; 3. Otherwise, prints all numbers from 1 to k+1 excluding one number\n\n;; find-largest-k finds the largest k where k(k+1)/2 <= N using binary search\n(defun find-largest-k (N)\n  (let ((low 1)\n        (high 200000)  ; Sufficiently large upper bound\n        (k 1))\n    (while (<= low high)\n      (let* ((mid (/ (+ low high) 2))\n             (s (/ (* mid (1+ mid)) 2)))\n        (if (<= s N)\n            (progn\n              (setq k mid)\n              (setq low (1+ mid)))\n          (setq high (1- mid)))))\n    k))\n\n;; print-numbers prints either:\n;; - numbers from 1 to k if their sum equals N\n;; - numbers from 1 to k+1 excluding one number otherwise\n(defun print-numbers (N)\n  (if (= N 1)\n      (message \"1\")\n    (let* ((k (find-largest-k N))\n           (total (/ (* k (1+ k)) 2)))\n      (if (= total N)\n          (message \"%S\" (number-sequence 1 k))\n        (let* ((excluded (+ (1+ k) (- total N)))\n               (numbers (delete excluded (number-sequence 1 (1+ k)))))\n          (message \"%S\" numbers))))))\n(require 'cl-lib)\n\n(defun test-number-sequences ()\n  ;; Test cases inferred from the original code\n  (cl-assert (equal (print-numbers 1) \"1\"))\n  (cl-assert (equal (print-numbers 2) '(1)))\n  (cl-assert (equal (print-numbers 3) '(1 2)))\n  (cl-assert (equal (print-numbers 6) '(1 2 3)))\n  (cl-assert (equal (print-numbers 7) '(1 2 4)))\n  (cl-assert (equal (print-numbers 10) '(1 2 3 4)))\n  (cl-assert (equal (print-numbers 15) '(1 2 3 4 5)))\n  (cl-assert (equal (print-numbers 16) '(1 2 3 4 6)))\n  (cl-assert (equal (print-numbers 21) '(1 2 3 4 5 6)))\n  (cl-assert (equal (print-numbers 22) '(1 2 3 4 5 7))))\n\n(test-number-sequences)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This function moves all integer zeros (0) to the end of the list while preserving the order of other elements.\n;;; It takes a list as input and returns a new list with zeros moved to the end.\n(defun move-zeros-to-end (array)\n  (let ((non-zeros '())\n        (zeros '()))\n    (dolist (element array)\n      (if (and (numberp element) (zerop element) (not (booleanp element)))\n          (push element zeros)\n        (push element non-zeros)))\n    (append (reverse non-zeros) (reverse zeros))))", "test_cases": "", "test_case_results": "", "task_id": 28365, "assertions": "(require 'cl-lib)\n\n(defun test-move-zeros-to-end ()\n  (cl-assert (equal (move-zeros-to-end '(0 1 0 2 3)) '(1 2 3 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(1 2 3 4 5)) '(1 2 3 4 5)))\n  (cl-assert (equal (move-zeros-to-end '(0 0 0)) '(0 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(1 0 \"a\" 0 nil 2)) '(1 \"a\" nil 2 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(0 t 0 f 0)) '(t f 0 0 0))))\n\n(test-move-zeros-to-end)", "all_code": ";;; This function moves all integer zeros (0) to the end of the list while preserving the order of other elements.\n;;; It takes a list as input and returns a new list with zeros moved to the end.\n(defun move-zeros-to-end (array)\n  (let ((non-zeros '())\n        (zeros '()))\n    (dolist (element array)\n      (if (and (numberp element) (zerop element) (not (booleanp element)))\n          (push element zeros)\n        (push element non-zeros)))\n    (append (reverse non-zeros) (reverse zeros))))\n(require 'cl-lib)\n\n(defun test-move-zeros-to-end ()\n  (cl-assert (equal (move-zeros-to-end '(0 1 0 2 3)) '(1 2 3 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(1 2 3 4 5)) '(1 2 3 4 5)))\n  (cl-assert (equal (move-zeros-to-end '(0 0 0)) '(0 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(1 0 \"a\" 0 nil 2)) '(1 \"a\" nil 2 0 0)))\n  (cl-assert (equal (move-zeros-to-end '(0 t 0 f 0)) '(t f 0 0 0))))\n\n(test-move-zeros-to-end)", "exec_outcome": "PASSED"}
{"code": ";;; This function finds the length of the longest subarray where the bitwise AND\n;;; of all elements in the subarray is as large as possible.\n;;; If multiple subarrays have the same maximum AND value, it returns the longest one.\n(defun longest-and-subarray (nums)\n  (let ((max-k 0)\n        (max-length 0)\n        (current (make-hash-table :test 'equal)))\n    (dolist (num nums)\n      (let ((temp (make-hash-table :test 'equal)))\n        ;; Update temp with new values from current\n        (maphash (lambda (val length)\n                   (let ((new-val (logand val num)))\n                     (if (gethash new-val temp)\n                         (when (> (1+ length) (gethash new-val temp))\n                           (puthash new-val (1+ length) temp))\n                       (puthash new-val (1+ length) temp))))\n                 current)\n        ;; Handle the current number itself\n        (if (gethash num temp)\n            (when (> 1 (gethash num temp))\n              (puthash num 1 temp))\n          (puthash num 1 temp))\n        ;; Update current to be temp for next iteration\n        (setq current (copy-hash-table temp))\n        ;; Update max-k and max-length\n        (maphash (lambda (val length)\n                   (cond ((> val max-k)\n                          (setq max-k val)\n                          (setq max-length length))\n                         ((= val max-k)\n                          (when (> length max-length)\n                            (setq max-length length)))))\n                 current)))\n    max-length))", "test_cases": "", "test_case_results": "", "task_id": 21151, "assertions": "(require 'cl-lib)\n\n(defun test-longest-and-subarray ()\n  ;; Test case 1: (1 2 3 4)\n  ;; Expected: The maximum AND is 4 (single element), length 1\n  (cl-assert (= (longest-and-subarray '(1 2 3 4)) 1))\n  \n  ;; Test case 2: (5 6 7 0)\n  ;; Expected: The maximum AND is probably 6 (from [6]), length 1\n  (cl-assert (= (longest-and-subarray '(5 6 7 0)) 1))\n  \n  ;; Test case 3: (0 0 0 0)\n  ;; Expected: The maximum AND is 0, length 4 (whole array)\n  (cl-assert (= (longest-and-subarray '(0 0 0 0)) 4))\n  \n  ;; Test case 4: (15 10 8 4 2)\n  ;; Expected: The maximum AND is probably 8 (from [8]), length 1\n  (cl-assert (= (longest-and-subarray '(15 10 8 4 2)) 1))\n  \n  ;; Test case 5: (1 3 5 7)\n  ;; Expected: The maximum AND is probably 1 (from multiple subarrays), length might be 3\n  (cl-assert (= (longest-and-subarray '(1 3 5 7)) 3)))\n\n(test-longest-and-subarray)", "all_code": ";;; This function finds the length of the longest subarray where the bitwise AND\n;;; of all elements in the subarray is as large as possible.\n;;; If multiple subarrays have the same maximum AND value, it returns the longest one.\n(defun longest-and-subarray (nums)\n  (let ((max-k 0)\n        (max-length 0)\n        (current (make-hash-table :test 'equal)))\n    (dolist (num nums)\n      (let ((temp (make-hash-table :test 'equal)))\n        ;; Update temp with new values from current\n        (maphash (lambda (val length)\n                   (let ((new-val (logand val num)))\n                     (if (gethash new-val temp)\n                         (when (> (1+ length) (gethash new-val temp))\n                           (puthash new-val (1+ length) temp))\n                       (puthash new-val (1+ length) temp))))\n                 current)\n        ;; Handle the current number itself\n        (if (gethash num temp)\n            (when (> 1 (gethash num temp))\n              (puthash num 1 temp))\n          (puthash num 1 temp))\n        ;; Update current to be temp for next iteration\n        (setq current (copy-hash-table temp))\n        ;; Update max-k and max-length\n        (maphash (lambda (val length)\n                   (cond ((> val max-k)\n                          (setq max-k val)\n                          (setq max-length length))\n                         ((= val max-k)\n                          (when (> length max-length)\n                            (setq max-length length)))))\n                 current)))\n    max-length))\n(require 'cl-lib)\n\n(defun test-longest-and-subarray ()\n  ;; Test case 1: (1 2 3 4)\n  ;; Expected: The maximum AND is 4 (single element), length 1\n  (cl-assert (= (longest-and-subarray '(1 2 3 4)) 1))\n  \n  ;; Test case 2: (5 6 7 0)\n  ;; Expected: The maximum AND is probably 6 (from [6]), length 1\n  (cl-assert (= (longest-and-subarray '(5 6 7 0)) 1))\n  \n  ;; Test case 3: (0 0 0 0)\n  ;; Expected: The maximum AND is 0, length 4 (whole array)\n  (cl-assert (= (longest-and-subarray '(0 0 0 0)) 4))\n  \n  ;; Test case 4: (15 10 8 4 2)\n  ;; Expected: The maximum AND is probably 8 (from [8]), length 1\n  (cl-assert (= (longest-and-subarray '(15 10 8 4 2)) 1))\n  \n  ;; Test case 5: (1 3 5 7)\n  ;; Expected: The maximum AND is probably 1 (from multiple subarrays), length might be 3\n  (cl-assert (= (longest-and-subarray '(1 3 5 7)) 3)))\n\n(test-longest-and-subarray)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; This code implements a decision algorithm between \"SHOOT\", \"ROTATE\", or \"EQUAL\"\n;;; based on the analysis of a binary string's zero positions.\n\n(defun count-zeros (s)\n  \"Count the number of '0' characters in string S.\"\n  (let ((count 0))\n    (dotimes (i (length s) count)\n      (when (eq (aref s i) ?0)\n        (setq count (1+ count))))))\n\n(defun find-zero-positions (s)\n  \"Return a list of positions where the next character (mod n) is '0'.\"\n  (let ((n (length s))\n        (result '()))\n    (dotimes (x n (reverse result))\n      (when (eq (aref s (mod (1+ x) n)) ?0)\n        (push x result)))))\n\n(defun count-next-next-zeros (s positions)\n  \"Count how many positions in POSITIONS have '0' two positions ahead.\"\n  (let ((n (length s))\n        (count 0))\n    (dolist (x positions count)\n      (when (eq (aref s (mod (+ x 2) n)) ?0)\n        (setq count (1+ count))))))\n\n(defun decide-action (s)\n  \"Determine whether to SHOOT, ROTATE, or EQUAL based on string S.\"\n  (let* ((n (length s))\n         (zeros (count-zeros s))\n         (S (find-zero-positions s))\n         (s-len (length S))\n         (c1 (count-next-next-zeros s S))\n         (shoot-val (* c1 n))\n         (rotate-val (* zeros s-len)))\n    (cond\n     ((> shoot-val rotate-val) \"SHOOT\")\n     ((< shoot-val rotate-val) \"ROTATE\")\n     (t \"EQUAL\"))))", "test_cases": "", "test_case_results": "", "task_id": 3767, "assertions": "(require 'cl-lib)\n\n(defun test-decision-algorithm ()\n  (cl-assert (equal (decide-action \"010\") \"SHOOT\"))\n  (cl-assert (equal (decide-action \"1001\") \"ROTATE\"))\n  (cl-assert (equal (decide-action \"0000\") \"EQUAL\"))\n  (cl-assert (equal (decide-action \"1111\") \"EQUAL\"))\n  (cl-assert (equal (decide-action \"1010\") \"EQUAL\")))\n\n(test-decision-algorithm)", "all_code": ";;; This code implements a decision algorithm between \"SHOOT\", \"ROTATE\", or \"EQUAL\"\n;;; based on the analysis of a binary string's zero positions.\n\n(defun count-zeros (s)\n  \"Count the number of '0' characters in string S.\"\n  (let ((count 0))\n    (dotimes (i (length s) count)\n      (when (eq (aref s i) ?0)\n        (setq count (1+ count))))))\n\n(defun find-zero-positions (s)\n  \"Return a list of positions where the next character (mod n) is '0'.\"\n  (let ((n (length s))\n        (result '()))\n    (dotimes (x n (reverse result))\n      (when (eq (aref s (mod (1+ x) n)) ?0)\n        (push x result)))))\n\n(defun count-next-next-zeros (s positions)\n  \"Count how many positions in POSITIONS have '0' two positions ahead.\"\n  (let ((n (length s))\n        (count 0))\n    (dolist (x positions count)\n      (when (eq (aref s (mod (+ x 2) n)) ?0)\n        (setq count (1+ count))))))\n\n(defun decide-action (s)\n  \"Determine whether to SHOOT, ROTATE, or EQUAL based on string S.\"\n  (let* ((n (length s))\n         (zeros (count-zeros s))\n         (S (find-zero-positions s))\n         (s-len (length S))\n         (c1 (count-next-next-zeros s S))\n         (shoot-val (* c1 n))\n         (rotate-val (* zeros s-len)))\n    (cond\n     ((> shoot-val rotate-val) \"SHOOT\")\n     ((< shoot-val rotate-val) \"ROTATE\")\n     (t \"EQUAL\"))))\n(require 'cl-lib)\n\n(defun test-decision-algorithm ()\n  (cl-assert (equal (decide-action \"010\") \"SHOOT\"))\n  (cl-assert (equal (decide-action \"1001\") \"ROTATE\"))\n  (cl-assert (equal (decide-action \"0000\") \"EQUAL\"))\n  (cl-assert (equal (decide-action \"1111\") \"EQUAL\"))\n  (cl-assert (equal (decide-action \"1010\") \"EQUAL\")))\n\n(test-decision-algorithm)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Calculate the minimum timespan required to complete all tasks including rest periods.\n;;;\n;;; Args:\n;;; - nums: List of integers representing the number of hours each task takes to complete.\n;;; - r: The fixed rest period in hours between two tasks.\n;;;\n;;; Returns:\n;;; The total number of hours required to complete all tasks.\n(defun min-timespan-to-complete-tasks (nums r)\n  (if (null nums)\n      0\n    (let ((total-time (apply '+ nums))\n          (rest-time (* r (1- (length nums)))))\n      (+ total-time rest-time))))", "test_cases": "", "test_case_results": "", "task_id": 15355, "assertions": "(require 'cl-lib)\n\n(defun test-min-timespan-to-complete-tasks ()\n  (cl-assert (= (min-timespan-to-complete-tasks '(1 2 3) 1) 7))\n  (cl-assert (= (min-timespan-to-complete-tasks '(5 5 5 5) 2) 21))\n  (cl-assert (= (min-timespan-to-complete-tasks '(10) 3) 10))\n  (cl-assert (= (min-timespan-to-complete-tasks nil 5) 0)))\n\n(test-min-timespan-to-complete-tasks)", "all_code": ";;; Calculate the minimum timespan required to complete all tasks including rest periods.\n;;;\n;;; Args:\n;;; - nums: List of integers representing the number of hours each task takes to complete.\n;;; - r: The fixed rest period in hours between two tasks.\n;;;\n;;; Returns:\n;;; The total number of hours required to complete all tasks.\n(defun min-timespan-to-complete-tasks (nums r)\n  (if (null nums)\n      0\n    (let ((total-time (apply '+ nums))\n          (rest-time (* r (1- (length nums)))))\n      (+ total-time rest-time))))\n(require 'cl-lib)\n\n(defun test-min-timespan-to-complete-tasks ()\n  (cl-assert (= (min-timespan-to-complete-tasks '(1 2 3) 1) 7))\n  (cl-assert (= (min-timespan-to-complete-tasks '(5 5 5 5) 2) 21))\n  (cl-assert (= (min-timespan-to-complete-tasks '(10) 3) 10))\n  (cl-assert (= (min-timespan-to-complete-tasks nil 5) 0)))\n\n(test-min-timespan-to-complete-tasks)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";; This implementation calculates temperature statistics for a given city and date range\n;; using in-memory data structures instead of file I/O.\n\n;; Sample temperature data structure:\n;; Each record is a list of (city date temperature)\n(defvar *temperature-data*\n  '((\"New York\" \"2023-01-01\" 32.0)\n    (\"New York\" \"2023-01-02\" 34.0)\n    (\"New York\" \"2023-01-03\" 30.0)\n    (\"London\" \"2023-01-01\" 41.0)\n    (\"London\" \"2023-01-02\" 42.0)\n    (\"London\" \"2023-01-03\" 40.0)\n    (\"Tokyo\" \"2023-01-01\" 45.0)\n    (\"Tokyo\" \"2023-01-02\" 46.0)\n    (\"Tokyo\" \"2023-01-03\" 44.0)))\n\n;; Helper function to parse date string into a list (year month day)\n(defun parse-date (date-str)\n  (mapcar 'string-to-number (split-string date-str \"-\")))\n\n;; Compare two dates (as strings in \"YYYY-MM-DD\" format)\n(defun date<= (date1 date2)\n  (let ((d1 (parse-date date1))\n        (d2 (parse-date date2)))\n    (or (< (car d1) (car d2)) ; year\n        (and (= (car d1) (car d2))\n             (or (< (cadr d1) (cadr d2)) ; month\n                 (and (= (cadr d1) (cadr d2))\n                      (<= (caddr d1) (caddr d2)))))))) ; day\n\n;; Calculate temperature statistics for a given city and date range\n(defun calculate-statistics (city start-date end-date)\n  \"Calculate temperature statistics for CITY between START-DATE and END-DATE.\nReturns an alist with mean, median, max, and min temperatures.\"\n  (let ((filtered-data\n         (seq-filter (lambda (record)\n                       (and (string= (car record) city)\n                            (date<= start-date (nth 1 record))\n                            (date<= (nth 1 record) end-date)))\n                     *temperature-data*))\n        (temperatures ()))\n    \n    (when filtered-data\n      (setq temperatures (mapcar (lambda (x) (nth 2 x)) filtered-data))\n      (let ((mean (/ (apply '+ temperatures) (length temperatures)))\n            (sorted-temps (sort temperatures '<)))\n        `((mean . ,mean)\n          (median . ,(nth (/ (length sorted-temps) 2) sorted-temps))\n          (max . ,(apply 'max temperatures))\n          (min . ,(apply 'min temperatures)))))))", "test_cases": "", "test_case_results": "", "task_id": 19537, "assertions": "(require 'cl-lib)\n\n(defun test-temperature-statistics ()\n  ;; Test Case 1: New York 2023-01-01 to 2023-01-03\n  (let ((result (calculate-statistics \"New York\" \"2023-01-01\" \"2023-01-03\")))\n    (cl-assert (equal (assoc-default 'mean result) 32.0))\n    (cl-assert (equal (assoc-default 'median result) 32.0))\n    (cl-assert (equal (assoc-default 'max result) 34.0))\n    (cl-assert (equal (assoc-default 'min result) 30.0)))\n  \n  ;; Test Case 2: London 2023-01-02 to 2023-01-03\n  (let ((result (calculate-statistics \"London\" \"2023-01-02\" \"2023-01-03\")))\n    (cl-assert (equal (assoc-default 'mean result) 41.0))\n    (cl-assert (equal (assoc-default 'median result) 41.0))\n    (cl-assert (equal (assoc-default 'max result) 42.0))\n    (cl-assert (equal (assoc-default 'min result) 40.0)))\n  \n  ;; Test Case 3: Tokyo 2023-01-01 to 2023-01-01\n  (let ((result (calculate-statistics \"Tokyo\" \"2023-01-01\" \"2023-01-01\")))\n    (cl-assert (equal (assoc-default 'mean result) 45.0))\n    (cl-assert (equal (assoc-default 'median result) 45.0))\n    (cl-assert (equal (assoc-default 'max result) 45.0))\n    (cl-assert (equal (assoc-default 'min result) 45.0)))\n  \n  ;; Test Case 4: Non-existent city\n  (cl-assert (null (calculate-statistics \"Paris\" \"2023-01-01\" \"2023-01-03\"))))\n\n(test-temperature-statistics)", "all_code": ";; This implementation calculates temperature statistics for a given city and date range\n;; using in-memory data structures instead of file I/O.\n\n;; Sample temperature data structure:\n;; Each record is a list of (city date temperature)\n(defvar *temperature-data*\n  '((\"New York\" \"2023-01-01\" 32.0)\n    (\"New York\" \"2023-01-02\" 34.0)\n    (\"New York\" \"2023-01-03\" 30.0)\n    (\"London\" \"2023-01-01\" 41.0)\n    (\"London\" \"2023-01-02\" 42.0)\n    (\"London\" \"2023-01-03\" 40.0)\n    (\"Tokyo\" \"2023-01-01\" 45.0)\n    (\"Tokyo\" \"2023-01-02\" 46.0)\n    (\"Tokyo\" \"2023-01-03\" 44.0)))\n\n;; Helper function to parse date string into a list (year month day)\n(defun parse-date (date-str)\n  (mapcar 'string-to-number (split-string date-str \"-\")))\n\n;; Compare two dates (as strings in \"YYYY-MM-DD\" format)\n(defun date<= (date1 date2)\n  (let ((d1 (parse-date date1))\n        (d2 (parse-date date2)))\n    (or (< (car d1) (car d2)) ; year\n        (and (= (car d1) (car d2))\n             (or (< (cadr d1) (cadr d2)) ; month\n                 (and (= (cadr d1) (cadr d2))\n                      (<= (caddr d1) (caddr d2)))))))) ; day\n\n;; Calculate temperature statistics for a given city and date range\n(defun calculate-statistics (city start-date end-date)\n  \"Calculate temperature statistics for CITY between START-DATE and END-DATE.\nReturns an alist with mean, median, max, and min temperatures.\"\n  (let ((filtered-data\n         (seq-filter (lambda (record)\n                       (and (string= (car record) city)\n                            (date<= start-date (nth 1 record))\n                            (date<= (nth 1 record) end-date)))\n                     *temperature-data*))\n        (temperatures ()))\n    \n    (when filtered-data\n      (setq temperatures (mapcar (lambda (x) (nth 2 x)) filtered-data))\n      (let ((mean (/ (apply '+ temperatures) (length temperatures)))\n            (sorted-temps (sort temperatures '<)))\n        `((mean . ,mean)\n          (median . ,(nth (/ (length sorted-temps) 2) sorted-temps))\n          (max . ,(apply 'max temperatures))\n          (min . ,(apply 'min temperatures)))))))\n(require 'cl-lib)\n\n(defun test-temperature-statistics ()\n  ;; Test Case 1: New York 2023-01-01 to 2023-01-03\n  (let ((result (calculate-statistics \"New York\" \"2023-01-01\" \"2023-01-03\")))\n    (cl-assert (equal (assoc-default 'mean result) 32.0))\n    (cl-assert (equal (assoc-default 'median result) 32.0))\n    (cl-assert (equal (assoc-default 'max result) 34.0))\n    (cl-assert (equal (assoc-default 'min result) 30.0)))\n  \n  ;; Test Case 2: London 2023-01-02 to 2023-01-03\n  (let ((result (calculate-statistics \"London\" \"2023-01-02\" \"2023-01-03\")))\n    (cl-assert (equal (assoc-default 'mean result) 41.0))\n    (cl-assert (equal (assoc-default 'median result) 41.0))\n    (cl-assert (equal (assoc-default 'max result) 42.0))\n    (cl-assert (equal (assoc-default 'min result) 40.0)))\n  \n  ;; Test Case 3: Tokyo 2023-01-01 to 2023-01-01\n  (let ((result (calculate-statistics \"Tokyo\" \"2023-01-01\" \"2023-01-01\")))\n    (cl-assert (equal (assoc-default 'mean result) 45.0))\n    (cl-assert (equal (assoc-default 'median result) 45.0))\n    (cl-assert (equal (assoc-default 'max result) 45.0))\n    (cl-assert (equal (assoc-default 'min result) 45.0)))\n  \n  ;; Test Case 4: Non-existent city\n  (cl-assert (null (calculate-statistics \"Paris\" \"2023-01-01\" \"2023-01-03\"))))\n\n(test-temperature-statistics)", "exec_outcome": "RUNTIME_ERROR"}
{"code": ";;; Function to determine if a stream of operations results in exactly one value with a non-zero count\n\n;; one-sparse processes a stream of operations (value, sign) and checks if there's exactly one value\n;; with a non-zero count after all operations. If so, it returns that value; otherwise, it returns nil.\n;; The stream is a list of cons cells where the car is the value and the cdr is the sign ('+' or '-').\n(require 'cl-lib) ; For cl-loop\n\n(defun one-sparse (stream)\n  (let ((count-map (make-hash-table)))\n    (dolist (operation stream)\n      (let ((value (car operation))\n            (sign (cdr operation)))\n        (cond\n         ((equal sign \"+\") (puthash value (1+ (gethash value count-map 0)) count-map))\n         ((equal sign \"-\") (puthash value (1- (gethash value count-map 0)) count-map)))))\n    (let ((non-zero-counts\n           (cl-loop for key being the hash-keys of count-map\n                    for count = (gethash key count-map)\n                    unless (zerop count)\n                    collect key)))\n      (if (= (length non-zero-counts) 1)\n          (car non-zero-counts)\n        nil))))", "test_cases": "", "test_case_results": "", "task_id": 22114, "assertions": "(require 'cl-lib)\n\n(defun test-one-sparse ()\n  (cl-assert (null (one-sparse '((1 . \"+\") (2 . \"+\") (1 . \"-\") (2 . \"-\")))))\n  (cl-assert (= (one-sparse '((1 . \"+\") (2 . \"+\") (1 . \"-\"))) 2))\n  (cl-assert (null (one-sparse '((1 . \"+\") (1 . \"+\") (2 . \"-\"))))))\n\n(test-one-sparse)", "all_code": ";;; Function to determine if a stream of operations results in exactly one value with a non-zero count\n\n;; one-sparse processes a stream of operations (value, sign) and checks if there's exactly one value\n;; with a non-zero count after all operations. If so, it returns that value; otherwise, it returns nil.\n;; The stream is a list of cons cells where the car is the value and the cdr is the sign ('+' or '-').\n(require 'cl-lib) ; For cl-loop\n\n(defun one-sparse (stream)\n  (let ((count-map (make-hash-table)))\n    (dolist (operation stream)\n      (let ((value (car operation))\n            (sign (cdr operation)))\n        (cond\n         ((equal sign \"+\") (puthash value (1+ (gethash value count-map 0)) count-map))\n         ((equal sign \"-\") (puthash value (1- (gethash value count-map 0)) count-map)))))\n    (let ((non-zero-counts\n           (cl-loop for key being the hash-keys of count-map\n                    for count = (gethash key count-map)\n                    unless (zerop count)\n                    collect key)))\n      (if (= (length non-zero-counts) 1)\n          (car non-zero-counts)\n        nil))))\n(require 'cl-lib)\n\n(defun test-one-sparse ()\n  (cl-assert (null (one-sparse '((1 . \"+\") (2 . \"+\") (1 . \"-\") (2 . \"-\")))))\n  (cl-assert (= (one-sparse '((1 . \"+\") (2 . \"+\") (1 . \"-\"))) 2))\n  (cl-assert (null (one-sparse '((1 . \"+\") (1 . \"+\") (2 . \"-\"))))))\n\n(test-one-sparse)", "exec_outcome": "PASSED"}
{"code": ";;; This function decodes an encoded message according to the secret code machine rules:\n;;; \"A\" becomes \"D\", \"B\" becomes \"E\", ..., \"Z\" becomes \"C\".\n;;; Non-alphabetic characters are left unchanged.\n\n(defun decode-message (encoded-message)\n  \"Decode an ENCODED-MESSAGE by shifting each alphabetic character back by 3 positions.\nNon-alphabetic characters remain unchanged.\"\n  (let ((decoded-chars '()))\n    (dolist (char (string-to-list encoded-message) (concat (nreverse decoded-chars)))\n      (cond\n       ;; Ignore non-alphabetic characters\n       ((not (and (>= char ?A) (<= char ?Z)))\n        (push char decoded-chars))\n       ;; Shift alphabetic characters\n       (t\n        (let ((shifted-char (+ ?A (mod (- (- char ?A) 3) 26))))\n          (push shifted-char decoded-chars)))))))", "test_cases": "", "test_case_results": "", "task_id": 21341, "assertions": "(require 'cl-lib)\n\n(defun test-decode-message ()\n  (cl-assert (string= (decode-message \"DEF\") \"ABC\"))\n  (cl-assert (string= (decode-message \"GHI\") \"DEF\"))\n  (cl-assert (string= (decode-message \"JKLMNO\") \"GHIJKL\"))\n  (cl-assert (string= (decode-message \"XYZABC\") \"VWXYZ\"))\n  (cl-assert (string= (decode-message \"HELLO, WORLD!\") \"EBIIL, TLOIA!\"))\n  (cl-assert (string= (decode-message \"123!@#\") \"123!@#\")))\n\n(test-decode-message)", "all_code": ";;; This function decodes an encoded message according to the secret code machine rules:\n;;; \"A\" becomes \"D\", \"B\" becomes \"E\", ..., \"Z\" becomes \"C\".\n;;; Non-alphabetic characters are left unchanged.\n\n(defun decode-message (encoded-message)\n  \"Decode an ENCODED-MESSAGE by shifting each alphabetic character back by 3 positions.\nNon-alphabetic characters remain unchanged.\"\n  (let ((decoded-chars '()))\n    (dolist (char (string-to-list encoded-message) (concat (nreverse decoded-chars)))\n      (cond\n       ;; Ignore non-alphabetic characters\n       ((not (and (>= char ?A) (<= char ?Z)))\n        (push char decoded-chars))\n       ;; Shift alphabetic characters\n       (t\n        (let ((shifted-char (+ ?A (mod (- (- char ?A) 3) 26))))\n          (push shifted-char decoded-chars)))))))\n(require 'cl-lib)\n\n(defun test-decode-message ()\n  (cl-assert (string= (decode-message \"DEF\") \"ABC\"))\n  (cl-assert (string= (decode-message \"GHI\") \"DEF\"))\n  (cl-assert (string= (decode-message \"JKLMNO\") \"GHIJKL\"))\n  (cl-assert (string= (decode-message \"XYZABC\") \"VWXYZ\"))\n  (cl-assert (string= (decode-message \"HELLO, WORLD!\") \"EBIIL, TLOIA!\"))\n  (cl-assert (string= (decode-message \"123!@#\") \"123!@#\")))\n\n(test-decode-message)", "exec_outcome": "RUNTIME_ERROR"}
