{"code": "#lang racket\n\n; judge-circle determines if a sequence of moves returns a robot to its original starting position.\n; The moves are represented as a string where:\n; - 'L' means left (decreases horizontal position)\n; - 'R' means right (increases horizontal position)\n; - 'U' means up (increases vertical position)\n; - 'D' means down (decreases vertical position)\n; The function returns #t if the robot ends at the starting position (0, 0), otherwise #f.\n(define (judge-circle moves)\n  (let loop ([horizontal 0]\n             [vertical 0]\n             [moves (string->list moves)])\n    (if (empty? moves)\n        (and (zero? horizontal) (zero? vertical))\n        (let ([move (car moves)])\n          (cond\n            [(char=? move #\\L) (loop (sub1 horizontal) vertical (cdr moves))]\n            [(char=? move #\\R) (loop (add1 horizontal) vertical (cdr moves))]\n            [(char=? move #\\U) (loop horizontal (add1 vertical) (cdr moves))]\n            [(char=? move #\\D) (loop horizontal (sub1 vertical) (cdr moves))])))))", "test_cases": "", "test_case_results": "Input: LR\nResult: #t\nInput: UD\nResult: #t\nInput: LL\nResult: #f\nInput: URDL\nResult: #t\nInput: LDRU\nResult: #t\nInput: UUUDDD\nResult: #t", "task_id": 4543, "assertions": "#lang racket\n\n(define (test-judge-circle)\n  (unless (judge-circle \"LR\")\n    (error \"Test 1 failed: LR should return #t\"))\n  (unless (judge-circle \"UD\")\n    (error \"Test 2 failed: UD should return #t\"))\n  (unless (not (judge-circle \"LL\"))\n    (error \"Test 3 failed: LL should return #f\"))\n  (unless (judge-circle \"URDL\")\n    (error \"Test 4 failed: URDL should return #t\"))\n  (unless (judge-circle \"LDRU\")\n    (error \"Test 5 failed: LDRU should return #t\"))\n  (unless (judge-circle \"UUUDDD\")\n    (error \"Test 6 failed: UUUDDD should return #t\")))\n\n(test-judge-circle)", "all_code": "#lang racket\n\n\n; judge-circle determines if a sequence of moves returns a robot to its original starting position.\n; The moves are represented as a string where:\n; - 'L' means left (decreases horizontal position)\n; - 'R' means right (increases horizontal position)\n; - 'U' means up (increases vertical position)\n; - 'D' means down (decreases vertical position)\n; The function returns #t if the robot ends at the starting position (0, 0), otherwise #f.\n(define (judge-circle moves)\n  (let loop ([horizontal 0]\n             [vertical 0]\n             [moves (string->list moves)])\n    (if (empty? moves)\n        (and (zero? horizontal) (zero? vertical))\n        (let ([move (car moves)])\n          (cond\n            [(char=? move #\\L) (loop (sub1 horizontal) vertical (cdr moves))]\n            [(char=? move #\\R) (loop (add1 horizontal) vertical (cdr moves))]\n            [(char=? move #\\U) (loop horizontal (add1 vertical) (cdr moves))]\n            [(char=? move #\\D) (loop horizontal (sub1 vertical) (cdr moves))])))))\n\n\n(define (test-judge-circle)\n  (unless (judge-circle \"LR\")\n    (error \"Test 1 failed: LR should return #t\"))\n  (unless (judge-circle \"UD\")\n    (error \"Test 2 failed: UD should return #t\"))\n  (unless (not (judge-circle \"LL\"))\n    (error \"Test 3 failed: LL should return #f\"))\n  (unless (judge-circle \"URDL\")\n    (error \"Test 4 failed: URDL should return #t\"))\n  (unless (judge-circle \"LDRU\")\n    (error \"Test 5 failed: LDRU should return #t\"))\n  (unless (judge-circle \"UUUDDD\")\n    (error \"Test 6 failed: UUUDDD should return #t\")))\n\n(test-judge-circle)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for sorting and list operations\n(require racket/list)\n\n; minimum-containers calculates the minimum number of containers needed to hold the items\n; without exceeding the maximum container weight. The algorithm sorts the items in descending\n; order and then uses a greedy approach to pack items into containers.\n; Parameters:\n;   items: A list of integers representing the weights of the items.\n;   max-weight: The maximum weight a container can hold.\n; Returns:\n;   The minimum number of containers required.\n(define (minimum-containers items max-weight)\n  (let loop ([sorted-items (sort items >)]\n             [containers 0])\n    (if (empty? sorted-items)\n        containers\n        (let-values ([(remaining current-weight)\n                      (for/fold ([remaining '()]\n                                 [current-weight 0])\n                                ([item (in-list sorted-items)])\n                        (if (<= (+ current-weight item) max-weight)\n                            (values remaining (+ current-weight item))\n                            (values (cons item remaining) current-weight)))])\n          (loop (reverse remaining) (add1 containers))))))\n\n; is-valid-distribution checks if a specific distribution of weights into containers is valid.\n; Parameters:\n;   containers: A list of lists of integers where each inner list represents the weights of items in a container.\n;   max-weight: The maximum weight a container can hold.\n; Returns:\n;   #t if the distribution is valid (no container exceeds max-weight), #f otherwise.\n(define (is-valid-distribution containers max-weight)\n  (for/and ([container (in-list containers)])\n    (<= (apply + container) max-weight)))", "test_cases": "", "test_case_results": "Items: (3 2 2 1), Max weight: 3\nMinimum containers needed: 3\nSample distribution valid? #t\n\nItems: (5 4 3 2 1), Max weight: 5\nMinimum containers needed: 3\nSample distribution valid? #t\n\nItems: (10 20 30), Max weight: 50\nMinimum containers needed: 2\nSample distribution valid? #t\n\nItems: (1 1 1 1 1), Max weight: 2\nMinimum containers needed: 3\nSample distribution valid? #t", "task_id": 11846, "assertions": "#lang racket\n\n(require racket/list)\n\n(define (test-container-functions)\n  (unless (= (minimum-containers '(3 2 2 1) 3) 3)\n    (error \"Test case 1 failed: (3 2 2 1) with max weight 3\"))\n  (unless (= (minimum-containers '(5 4 3 2 1) 5) 3)\n    (error \"Test case 2 failed: (5 4 3 2 1) with max weight 5\"))\n  (unless (= (minimum-containers '(10 20 30) 50) 2)\n    (error \"Test case 3 failed: (10 20 30) with max weight 50\"))\n  (unless (= (minimum-containers '(1 1 1 1 1) 2) 3)\n    (error \"Test case 4 failed: (1 1 1 1 1) with max weight 2\"))\n  \n  (unless (is-valid-distribution (map list '(3 2 2 1)) 3)\n    (error \"Validation test 1 failed\"))\n  (unless (is-valid-distribution (map list '(5 4 3 2 1)) 5)\n    (error \"Validation test 2 failed\"))\n  (unless (is-valid-distribution (map list '(10 20 30)) 50)\n    (error \"Validation test 3 failed\"))\n  (unless (is-valid-distribution (map list '(1 1 1 1 1)) 2)\n    (error \"Validation test 4 failed\")))\n\n(test-container-functions)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for sorting and list operations\n(require racket/list)\n\n; minimum-containers calculates the minimum number of containers needed to hold the items\n; without exceeding the maximum container weight. The algorithm sorts the items in descending\n; order and then uses a greedy approach to pack items into containers.\n; Parameters:\n;   items: A list of integers representing the weights of the items.\n;   max-weight: The maximum weight a container can hold.\n; Returns:\n;   The minimum number of containers required.\n(define (minimum-containers items max-weight)\n  (let loop ([sorted-items (sort items >)]\n             [containers 0])\n    (if (empty? sorted-items)\n        containers\n        (let-values ([(remaining current-weight)\n                      (for/fold ([remaining '()]\n                                 [current-weight 0])\n                                ([item (in-list sorted-items)])\n                        (if (<= (+ current-weight item) max-weight)\n                            (values remaining (+ current-weight item))\n                            (values (cons item remaining) current-weight)))])\n          (loop (reverse remaining) (add1 containers))))))\n\n; is-valid-distribution checks if a specific distribution of weights into containers is valid.\n; Parameters:\n;   containers: A list of lists of integers where each inner list represents the weights of items in a container.\n;   max-weight: The maximum weight a container can hold.\n; Returns:\n;   #t if the distribution is valid (no container exceeds max-weight), #f otherwise.\n(define (is-valid-distribution containers max-weight)\n  (for/and ([container (in-list containers)])\n    (<= (apply + container) max-weight)))\n\n\n(require racket/list)\n\n(define (test-container-functions)\n  (unless (= (minimum-containers '(3 2 2 1) 3) 3)\n    (error \"Test case 1 failed: (3 2 2 1) with max weight 3\"))\n  (unless (= (minimum-containers '(5 4 3 2 1) 5) 3)\n    (error \"Test case 2 failed: (5 4 3 2 1) with max weight 5\"))\n  (unless (= (minimum-containers '(10 20 30) 50) 2)\n    (error \"Test case 3 failed: (10 20 30) with max weight 50\"))\n  (unless (= (minimum-containers '(1 1 1 1 1) 2) 3)\n    (error \"Test case 4 failed: (1 1 1 1 1) with max weight 2\"))\n  \n  (unless (is-valid-distribution (map list '(3 2 2 1)) 3)\n    (error \"Validation test 1 failed\"))\n  (unless (is-valid-distribution (map list '(5 4 3 2 1)) 5)\n    (error \"Validation test 2 failed\"))\n  (unless (is-valid-distribution (map list '(10 20 30)) 50)\n    (error \"Validation test 3 failed\"))\n  (unless (is-valid-distribution (map list '(1 1 1 1 1)) 2)\n    (error \"Validation test 4 failed\")))\n\n(test-container-functions)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; fill-buffer takes an input list and returns a new list of length 100.\n; The new list contains the elements of the input list followed by zeros\n; to fill the remaining space up to 100 elements.\n(define (fill-buffer input-array)\n  (append input-array (make-list (- 100 (length input-array)) 0)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5 6 7 8 9 10)\nResult: (1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)\nInput: (1 2 3)\nResult: (1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)\nInput: ()\nResult: (0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)\nInput: (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100)\nResult: (1 2 3 4 5 6 7 8 9 10 11 12 1", "task_id": 24733, "assertions": "#lang racket\n\n(define (test-fill-buffer)\n  (unless (equal? (fill-buffer '(1 2 3 4 5 6 7 8 9 10))\n                  '(1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (fill-buffer '(1 2 3))\n                  '(1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (fill-buffer '())\n                  '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (fill-buffer '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))\n                  '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))\n    (error \"Test case 4 failed\")))\n\n(test-fill-buffer)", "all_code": "#lang racket\n\n\n; fill-buffer takes an input list and returns a new list of length 100.\n; The new list contains the elements of the input list followed by zeros\n; to fill the remaining space up to 100 elements.\n(define (fill-buffer input-array)\n  (append input-array (make-list (- 100 (length input-array)) 0)))\n\n\n(define (test-fill-buffer)\n  (unless (equal? (fill-buffer '(1 2 3 4 5 6 7 8 9 10))\n                  '(1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (fill-buffer '(1 2 3))\n                  '(1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (fill-buffer '())\n                  '(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (fill-buffer '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))\n                  '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100))\n    (error \"Test case 4 failed\")))\n\n(test-fill-buffer)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sum-of-digits-of-largest-number calculates the sum of the digits of the largest number in a list.\n; If the list is empty, it returns 0.\n; The function first finds the largest number in the list, then converts it to a string to iterate over each digit,\n; converts each digit back to an integer, and sums them up.\n(define (sum-of-digits-of-largest-number lst)\n  (if (empty? lst)\n      0\n      (let* ([largest-number (apply max lst)]\n             [digits (string->list (number->string largest-number))])\n        (apply + (map (lambda (d) (- (char->integer d) (char->integer #\\0))) digits)))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4)\nResult: 4\nInput: (5 66 7 0)\nResult: 12\nInput: (0 0 0 0)\nResult: 0\nInput: (123 456 789)\nResult: 24\nInput: ()\nResult: 0", "task_id": 2738, "assertions": "#lang racket\n\n(define (test-sum-of-digits)\n  (unless (= (sum-of-digits-of-largest-number '(1 2 3 4)) 4)\n    (error \"Test case 1 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(5 66 7 0)) 12)\n    (error \"Test case 2 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(0 0 0 0)) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(123 456 789)) 24)\n    (error \"Test case 4 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-sum-of-digits)", "all_code": "#lang racket\n\n\n; sum-of-digits-of-largest-number calculates the sum of the digits of the largest number in a list.\n; If the list is empty, it returns 0.\n; The function first finds the largest number in the list, then converts it to a string to iterate over each digit,\n; converts each digit back to an integer, and sums them up.\n(define (sum-of-digits-of-largest-number lst)\n  (if (empty? lst)\n      0\n      (let* ([largest-number (apply max lst)]\n             [digits (string->list (number->string largest-number))])\n        (apply + (map (lambda (d) (- (char->integer d) (char->integer #\\0))) digits)))))\n\n\n(define (test-sum-of-digits)\n  (unless (= (sum-of-digits-of-largest-number '(1 2 3 4)) 4)\n    (error \"Test case 1 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(5 66 7 0)) 12)\n    (error \"Test case 2 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(0 0 0 0)) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '(123 456 789)) 24)\n    (error \"Test case 4 failed\"))\n  (unless (= (sum-of-digits-of-largest-number '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-sum-of-digits)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; count-valid-arrangements calculates the number of valid arrangements of stalls with different genres.\n; n: number of stalls\n; m: number of genres\n; The function uses modular arithmetic to avoid overflow, with MOD = 10^9 + 7.\n; The recurrence relation used is: f(n, m) = m * (m-1)^(n-1) % MOD\n; - The first stall can have m choices.\n; - Each subsequent stall can have (m-1) choices (different from the previous stall).\n(define (count-valid-arrangements n m)\n  (define MOD (expt 10 9))\n  (set! MOD (+ MOD 7)) ; MOD = 10^9 + 7\n  (cond\n    [(= m 1) (if (> n 1) 0 1)] ; If only 1 genre, no valid arrangement unless n=1\n    [(= n 1) m] ; If only 1 stall, all genres are valid\n    [else (modulo (* m (expt (sub1 m) (sub1 n))) MOD)]))", "test_cases": "", "test_case_results": "Input: n=1, m=1\nResult: 1\nInput: n=2, m=1\nResult: 0\nInput: n=1, m=5\nResult: 5\nInput: n=3, m=2\nResult: 2\nInput: n=4, m=3\nResult: 24", "task_id": 16556, "assertions": "#lang racket\n\n(define (test-count-valid-arrangements)\n  (unless (= (count-valid-arrangements 1 1) 1)\n    (error \"Test case 1 failed: (1 1)\"))\n  (unless (= (count-valid-arrangements 2 1) 0)\n    (error \"Test case 2 failed: (2 1)\"))\n  (unless (= (count-valid-arrangements 1 5) 5)\n    (error \"Test case 3 failed: (1 5)\"))\n  (unless (= (count-valid-arrangements 3 2) 2)\n    (error \"Test case 4 failed: (3 2)\"))\n  (unless (= (count-valid-arrangements 4 3) 24)\n    (error \"Test case 5 failed: (4 3)\"))\n  (displayln \"All tests passed!\"))\n\n(test-count-valid-arrangements)", "all_code": "#lang racket\n\n\n; count-valid-arrangements calculates the number of valid arrangements of stalls with different genres.\n; n: number of stalls\n; m: number of genres\n; The function uses modular arithmetic to avoid overflow, with MOD = 10^9 + 7.\n; The recurrence relation used is: f(n, m) = m * (m-1)^(n-1) % MOD\n; - The first stall can have m choices.\n; - Each subsequent stall can have (m-1) choices (different from the previous stall).\n(define (count-valid-arrangements n m)\n  (define MOD (expt 10 9))\n  (set! MOD (+ MOD 7)) ; MOD = 10^9 + 7\n  (cond\n    [(= m 1) (if (> n 1) 0 1)] ; If only 1 genre, no valid arrangement unless n=1\n    [(= n 1) m] ; If only 1 stall, all genres are valid\n    [else (modulo (* m (expt (sub1 m) (sub1 n))) MOD)]))\n\n\n(define (test-count-valid-arrangements)\n  (unless (= (count-valid-arrangements 1 1) 1)\n    (error \"Test case 1 failed: (1 1)\"))\n  (unless (= (count-valid-arrangements 2 1) 0)\n    (error \"Test case 2 failed: (2 1)\"))\n  (unless (= (count-valid-arrangements 1 5) 5)\n    (error \"Test case 3 failed: (1 5)\"))\n  (unless (= (count-valid-arrangements 3 2) 2)\n    (error \"Test case 4 failed: (3 2)\"))\n  (unless (= (count-valid-arrangements 4 3) 24)\n    (error \"Test case 5 failed: (4 3)\"))\n  (displayln \"All tests passed!\"))\n\n(test-count-valid-arrangements)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; intergalactic-balance-point finds the intergalactic balance point of a list of integers.\n; The balance point is defined as the median of the sorted list. For an odd number of elements,\n; it is the middle element. For an even number of elements, it is the smaller of the two middle elements.\n; \n; Args:\n; n: the number of elements in the list.\n; s: the list of integers.\n;\n; Returns:\n; The intergalactic balance point (median or smaller middle element for even-length lists).\n(define (intergalactic-balance-point n s)\n  (let ([sorted-s (sort s <)])\n    (list-ref sorted-s (quotient (- n 1) 2))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5)\nBalance Point: 3\nInput: (6 1 3 2 4 5)\nBalance Point: 3\nInput: (10 20)\nBalance Point: 10\nInput: (7)\nBalance Point: 7", "task_id": 11637, "assertions": "#lang racket\n\n(define (test-intergalactic-balance-point)\n  (unless (= (intergalactic-balance-point 5 '(1 2 3 4 5)) 3)\n    (error \"Test 1 failed\"))\n  (unless (= (intergalactic-balance-point 6 '(6 1 3 2 4 5)) 3)\n    (error \"Test 2 failed\"))\n  (unless (= (intergalactic-balance-point 2 '(10 20)) 10)\n    (error \"Test 3 failed\"))\n  (unless (= (intergalactic-balance-point 1 '(7)) 7)\n    (error \"Test 4 failed\")))\n\n(test-intergalactic-balance-point)", "all_code": "#lang racket\n\n\n; intergalactic-balance-point finds the intergalactic balance point of a list of integers.\n; The balance point is defined as the median of the sorted list. For an odd number of elements,\n; it is the middle element. For an even number of elements, it is the smaller of the two middle elements.\n; \n; Args:\n; n: the number of elements in the list.\n; s: the list of integers.\n;\n; Returns:\n; The intergalactic balance point (median or smaller middle element for even-length lists).\n(define (intergalactic-balance-point n s)\n  (let ([sorted-s (sort s <)])\n    (list-ref sorted-s (quotient (- n 1) 2))))\n\n\n(define (test-intergalactic-balance-point)\n  (unless (= (intergalactic-balance-point 5 '(1 2 3 4 5)) 3)\n    (error \"Test 1 failed\"))\n  (unless (= (intergalactic-balance-point 6 '(6 1 3 2 4 5)) 3)\n    (error \"Test 2 failed\"))\n  (unless (= (intergalactic-balance-point 2 '(10 20)) 10)\n    (error \"Test 3 failed\"))\n  (unless (= (intergalactic-balance-point 1 '(7)) 7)\n    (error \"Test 4 failed\")))\n\n(test-intergalactic-balance-point)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; find-highest-sales-spike-index determines the day with the highest sales spike.\n; A sales spike is defined as the difference between sales on a day and the previous day.\n; The function takes two arguments:\n;   - N: the number of days (length of the sales list)\n;   - sales: a list of sales figures for each day\n; If N is less than 2, the function returns -1 since no spike can be calculated.\n; Otherwise, it returns the day (1-based index) with the highest spike.\n(define (find-highest-sales-spike-index N sales)\n  (if (< N 2)\n      -1\n      (let loop ([i 1] [max-spike 0] [spike-day -1])\n        (if (>= i N)\n            spike-day\n            (let ([spike (- (list-ref sales i) (list-ref sales (- i 1)))])\n              (if (> spike max-spike)\n                  (loop (+ i 1) spike (+ i 1))\n                  (loop (+ i 1) max-spike spike-day)))))))", "test_cases": "", "test_case_results": "Input N: 2, Sales: (100 150)\nResult: 2\nInput N: 3, Sales: (50 40 30)\nResult: -1\nInput N: 5, Sales: (10 20 10 30 50)\nResult: 4\nInput N: 1, Sales: (100)\nResult: -1\nInput N: 4, Sales: (100 100 100 100)\nResult: -1", "task_id": 22914, "assertions": "#lang racket\n\n(define (test-sales-spike)\n  (unless (= (find-highest-sales-spike-index 2 '(100 150)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (find-highest-sales-spike-index 3 '(50 40 30)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (find-highest-sales-spike-index 5 '(10 20 10 30 50)) 4)\n    (error \"Test case 3 failed\"))\n  (unless (= (find-highest-sales-spike-index 1 '(100)) -1)\n    (error \"Test case 4 failed\"))\n  (unless (= (find-highest-sales-spike-index 4 '(100 100 100 100)) -1)\n    (error \"Test case 5 failed\")))\n\n(test-sales-spike)", "all_code": "#lang racket\n\n\n; find-highest-sales-spike-index determines the day with the highest sales spike.\n; A sales spike is defined as the difference between sales on a day and the previous day.\n; The function takes two arguments:\n;   - N: the number of days (length of the sales list)\n;   - sales: a list of sales figures for each day\n; If N is less than 2, the function returns -1 since no spike can be calculated.\n; Otherwise, it returns the day (1-based index) with the highest spike.\n(define (find-highest-sales-spike-index N sales)\n  (if (< N 2)\n      -1\n      (let loop ([i 1] [max-spike 0] [spike-day -1])\n        (if (>= i N)\n            spike-day\n            (let ([spike (- (list-ref sales i) (list-ref sales (- i 1)))])\n              (if (> spike max-spike)\n                  (loop (+ i 1) spike (+ i 1))\n                  (loop (+ i 1) max-spike spike-day)))))))\n\n\n(define (test-sales-spike)\n  (unless (= (find-highest-sales-spike-index 2 '(100 150)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (find-highest-sales-spike-index 3 '(50 40 30)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (find-highest-sales-spike-index 5 '(10 20 10 30 50)) 4)\n    (error \"Test case 3 failed\"))\n  (unless (= (find-highest-sales-spike-index 1 '(100)) -1)\n    (error \"Test case 4 failed\"))\n  (unless (= (find-highest-sales-spike-index 4 '(100 100 100 100)) -1)\n    (error \"Test case 5 failed\")))\n\n(test-sales-spike)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for regular expressions\n(require racket/string)\n\n; clean-string cleans the input string according to the following conditions:\n; 1. Removes all special characters except spaces.\n; 2. Converts all letters to lowercase.\n; 3. Ensures no extra spaces at the beginning or end, and no more than one space between words.\n; Parameters:\n; s : string - The string to be cleaned (0 <= (string-length s) <= 1000).\n; Returns:\n; string - The cleaned and standardized string.\n(define (clean-string s)\n  (let* ([cleaned (regexp-replace* #px\"[^a-zA-Z0-9\\\\s]\" s \"\")]\n         [cleaned (string-downcase cleaned)]\n         [cleaned (regexp-replace* #px\"\\\\s+\" cleaned \" \")]\n         [cleaned (string-trim cleaned)])\n    cleaned))", "test_cases": "", "test_case_results": "Input: \"Hello, World!\"\nCleaned: \"hello world\"\nInput: \"  This   is a  TEST string...  \"\nCleaned: \"this is a test string\"\nInput: \"123 Special Chars!@#\"\nCleaned: \"123 special chars\"\nInput: \"\"\nCleaned: \"\"\nInput: \"   \"\nCleaned: \"\"", "task_id": 19174, "assertions": "#lang racket\n\n(require racket/string)\n\n(define (test-clean-string)\n  (unless (equal? (clean-string \"Hello, World!\") \"hello world\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (clean-string \"  This   is a  TEST string...  \") \"this is a test string\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (clean-string \"123 Special Chars!@#\") \"123 special chars\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (clean-string \"\") \"\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (clean-string \"   \") \"\")\n    (error \"Test 5 failed\")))\n\n(test-clean-string)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for regular expressions\n(require racket/string)\n\n; clean-string cleans the input string according to the following conditions:\n; 1. Removes all special characters except spaces.\n; 2. Converts all letters to lowercase.\n; 3. Ensures no extra spaces at the beginning or end, and no more than one space between words.\n; Parameters:\n; s : string - The string to be cleaned (0 <= (string-length s) <= 1000).\n; Returns:\n; string - The cleaned and standardized string.\n(define (clean-string s)\n  (let* ([cleaned (regexp-replace* #px\"[^a-zA-Z0-9\\\\s]\" s \"\")]\n         [cleaned (string-downcase cleaned)]\n         [cleaned (regexp-replace* #px\"\\\\s+\" cleaned \" \")]\n         [cleaned (string-trim cleaned)])\n    cleaned))\n\n\n(require racket/string)\n\n(define (test-clean-string)\n  (unless (equal? (clean-string \"Hello, World!\") \"hello world\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (clean-string \"  This   is a  TEST string...  \") \"this is a test string\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (clean-string \"123 Special Chars!@#\") \"123 special chars\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (clean-string \"\") \"\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (clean-string \"   \") \"\")\n    (error \"Test 5 failed\")))\n\n(test-clean-string)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for string operations\n(require racket/string)\n\n; is-valid-identifier checks if a string is a valid Racket identifier.\n; A valid identifier starts with a letter (A-Z, a-z) or certain special characters,\n; followed by letters, digits (0-9), or certain special characters.\n; This function uses Racket's built-in `string->symbol` and `symbol-interned?` to check validity.\n(define (is-valid-identifier s)\n  (with-handlers ([exn:fail? (lambda (ex) #f)])\n    (and (symbol-interned? (string->symbol s)) #t)))", "test_cases": "", "test_case_results": "Input: valid_identifier\nResult: #t\nInput: 123invalid\nResult: #t\nInput: _valid_underscore\nResult: #t\nInput: invalid!char\nResult: #t\nInput: \nResult: #t", "task_id": 9628, "assertions": "#lang racket\n\n(require racket/string)\n\n(define (test-valid-identifier)\n  (unless (is-valid-identifier \"valid_identifier\")\n    (error \"Test 1 failed\"))\n  (unless (is-valid-identifier \"123invalid\")\n    (error \"Test 2 failed\"))\n  (unless (is-valid-identifier \"_valid_underscore\")\n    (error \"Test 3 failed\"))\n  (unless (is-valid-identifier \"invalid!char\")\n    (error \"Test 4 failed\"))\n  (unless (is-valid-identifier \"\")\n    (error \"Test 5 failed\")))\n\n(test-valid-identifier)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for string operations\n(require racket/string)\n\n; is-valid-identifier checks if a string is a valid Racket identifier.\n; A valid identifier starts with a letter (A-Z, a-z) or certain special characters,\n; followed by letters, digits (0-9), or certain special characters.\n; This function uses Racket's built-in `string->symbol` and `symbol-interned?` to check validity.\n(define (is-valid-identifier s)\n  (with-handlers ([exn:fail? (lambda (ex) #f)])\n    (and (symbol-interned? (string->symbol s)) #t)))\n\n\n(require racket/string)\n\n(define (test-valid-identifier)\n  (unless (is-valid-identifier \"valid_identifier\")\n    (error \"Test 1 failed\"))\n  (unless (is-valid-identifier \"123invalid\")\n    (error \"Test 2 failed\"))\n  (unless (is-valid-identifier \"_valid_underscore\")\n    (error \"Test 3 failed\"))\n  (unless (is-valid-identifier \"invalid!char\")\n    (error \"Test 4 failed\"))\n  (unless (is-valid-identifier \"\")\n    (error \"Test 5 failed\")))\n\n(test-valid-identifier)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; caesar-shift: Shifts each alphabetic character in the text by the given shift amount in the Caesar cipher manner.\n; Non-alphabetic characters are left unchanged.\n; text: string - the input text to be shifted\n; shift: integer - the number of positions to shift each character\n; returns: string - the shifted text\n(define (caesar-shift text shift)\n  (list->string\n   (for/list ([char (in-string text)])\n     (cond\n       [(char-upper-case? char)\n        (integer->char (+ (modulo (+ (- (char->integer char) (char->integer #\\A)) shift) 26)\n                          (char->integer #\\A)))]\n       [(char-lower-case? char)\n        (integer->char (+ (modulo (+ (- (char->integer char) (char->integer #\\a)) shift) 26)\n                          (char->integer #\\a)))]\n       [else char]))))\n\n; crack-caesar-cipher: Attempts to crack a Caesar cipher by trying all possible shifts (1 to 25).\n; For each shift, it decrypts the cipher text and collects the results.\n; cipher-text: string - the encrypted text to be decrypted\n; returns: list of pairs (shift, decrypted-text) - all possible decrypted texts with their corresponding shifts\n(define (crack-caesar-cipher cipher-text)\n  (for/list ([shift (in-range 1 26)])\n    (cons shift (caesar-shift cipher-text (- shift)))))", "test_cases": "", "test_case_results": "Testing caesar-shift:\nInput: Hello, World!, Shift: 3\nOutput: Khoor, Zruog!\nInput: XYZ, Shift: 5\nOutput: CDE\nInput: abc, Shift: 1\nOutput: bcd\nInput: 123!@#, Shift: 10\nOutput: 123!@#\n\nTesting crack-caesar-cipher:\nInput: Khoor, Zruog!\nOutput: ((1 . Jgnnq, Yqtnf!) (2 . Ifmmp, Xpsme!) (3 . Hello, World!) (4 . Gdkkn, Vnqkc!) (5 . Fcjjm, Umpjb!) (6 . Ebiil, Tloia!) (7 . Dahhk, Sknhz!) (8 . Czggj, Rjmgy!) (9 . Byffi, Qilfx!) (10 . Axeeh, Phkew!) (11 . Zwddg, Ogjdv!) (12 . Yvccf, Nficu!) (13 . Xubbe, Mehbt!) (14 . Wtaad, Ldgas!) (15 . Vszzc, Kcfzr!) (16 . Uryyb, Jbeyq!) (17 . Tqxxa, Iadxp!) (18 . Spwwz, Hzcwo!) (19 . Rovvy, Gybvn!) (20 . Qnuux, Fxaum!) (21 . Pmttw, Ewztl!) (22 . Olssv, Dvysk!) (23 . Nkrru, Cuxrj!) (24 . Mjqqt, Btwqi!) (25 . Lipps, Asvph!))\nInput: CDE\nOutput: ((1 . BCD) (2 . ABC) (3 . ZAB) (4 . YZA) (5 . XYZ) (6 . WXY) (7 . VWX) (8 . UVW) (9 . TUV) (10 . STU) (11 . RST) (12 . QRS) (13 . PQR) (14 . OPQ) (15 . NOP) (16 . MNO) (17 . LMN) (18 . KLM) (19 . JKL) (20 . IJK) (21 . HIJ) (22 . GHI) (23 . FGH) (2", "task_id": 1324, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-caesar-cipher)\n  ; Test caesar-shift function\n  (unless (equal? (caesar-shift \"Hello, World!\" 3) \"Khoor, Zruog!\")\n    (error \"caesar-shift test 1 failed\"))\n  (unless (equal? (caesar-shift \"XYZ\" 5) \"CDE\")\n    (error \"caesar-shift test 2 failed\"))\n  (unless (equal? (caesar-shift \"abc\" 1) \"bcd\")\n    (error \"caesar-shift test 3 failed\"))\n  (unless (equal? (caesar-shift \"123!@#\" 10) \"123!@#\")\n    (error \"caesar-shift test 4 failed\"))\n\n  ; Test crack-caesar-cipher function\n  (unless (equal? (car (crack-caesar-cipher \"Khoor, Zruog!\"))\n                  '(1 . \"Jgnnq, Yqtnf!\"))\n    (error \"crack-caesar-cipher test 1 failed\"))\n  (unless (equal? (list-ref (crack-caesar-cipher \"CDE\") 4)\n                  '(5 . \"XYZ\"))\n    (error \"crack-caesar-cipher test 2 failed\"))\n  (unless (equal? (list-ref (crack-caesar-cipher \"bcd\") 1)\n                  '(2 . \"abc\"))\n    (error \"crack-caesar-cipher test 3 failed\")))\n\n(test-caesar-cipher)", "all_code": "#lang racket\n\n\n; caesar-shift: Shifts each alphabetic character in the text by the given shift amount in the Caesar cipher manner.\n; Non-alphabetic characters are left unchanged.\n; text: string - the input text to be shifted\n; shift: integer - the number of positions to shift each character\n; returns: string - the shifted text\n(define (caesar-shift text shift)\n  (list->string\n   (for/list ([char (in-string text)])\n     (cond\n       [(char-upper-case? char)\n        (integer->char (+ (modulo (+ (- (char->integer char) (char->integer #\\A)) shift) 26)\n                          (char->integer #\\A)))]\n       [(char-lower-case? char)\n        (integer->char (+ (modulo (+ (- (char->integer char) (char->integer #\\a)) shift) 26)\n                          (char->integer #\\a)))]\n       [else char]))))\n\n; crack-caesar-cipher: Attempts to crack a Caesar cipher by trying all possible shifts (1 to 25).\n; For each shift, it decrypts the cipher text and collects the results.\n; cipher-text: string - the encrypted text to be decrypted\n; returns: list of pairs (shift, decrypted-text) - all possible decrypted texts with their corresponding shifts\n(define (crack-caesar-cipher cipher-text)\n  (for/list ([shift (in-range 1 26)])\n    (cons shift (caesar-shift cipher-text (- shift)))))\n\n\n(require rackunit)\n\n(define (test-caesar-cipher)\n  ; Test caesar-shift function\n  (unless (equal? (caesar-shift \"Hello, World!\" 3) \"Khoor, Zruog!\")\n    (error \"caesar-shift test 1 failed\"))\n  (unless (equal? (caesar-shift \"XYZ\" 5) \"CDE\")\n    (error \"caesar-shift test 2 failed\"))\n  (unless (equal? (caesar-shift \"abc\" 1) \"bcd\")\n    (error \"caesar-shift test 3 failed\"))\n  (unless (equal? (caesar-shift \"123!@#\" 10) \"123!@#\")\n    (error \"caesar-shift test 4 failed\"))\n\n  ; Test crack-caesar-cipher function\n  (unless (equal? (car (crack-caesar-cipher \"Khoor, Zruog!\"))\n                  '(1 . \"Jgnnq, Yqtnf!\"))\n    (error \"crack-caesar-cipher test 1 failed\"))\n  (unless (equal? (list-ref (crack-caesar-cipher \"CDE\") 4)\n                  '(5 . \"XYZ\"))\n    (error \"crack-caesar-cipher test 2 failed\"))\n  (unless (equal? (list-ref (crack-caesar-cipher \"bcd\") 1)\n                  '(2 . \"abc\"))\n    (error \"crack-caesar-cipher test 3 failed\")))\n\n(test-caesar-cipher)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; power calculates a^n efficiently using the exponentiation by squaring method.\n; If a modulus mod is provided, it computes (a^n) % mod.\n; This is useful for large numbers where direct computation would be inefficient or overflow.\n; The function handles both cases (with and without modulus) by checking if mod is provided.\n(define (power a n [mod #f])\n  (let loop ([result 1]\n             [base (if mod (modulo a mod) a)]\n             [exponent n])\n    (cond\n      [(zero? exponent) result]\n      [(odd? exponent)\n       (loop (if mod (modulo (* result base) mod) (* result base))\n             (if mod (modulo (* base base) mod) (* base base))\n             (quotient exponent 2))]\n      [else\n       (loop result\n             (if mod (modulo (* base base) mod) (* base base))\n             (quotient exponent 2))])))", "test_cases": "", "test_case_results": "Input: a=2, n=10, mod=#f\nResult: 1024\nInput: a=3, n=5, mod=#f\nResult: 243\nInput: a=2, n=10, mod=1000\nResult: 24\nInput: a=3, n=5, mod=13\nResult: 9\nInput: a=5, n=0, mod=#f\nResult: 1\nInput: a=5, n=0, mod=7\nResult: 1", "task_id": 63, "assertions": "#lang racket\n\n(define (test-power)\n  (unless (= (power 2 10 #f) 1024)\n    (error \"Test 1 failed: (power 2 10 #f) should be 1024\"))\n  (unless (= (power 3 5 #f) 243)\n    (error \"Test 2 failed: (power 3 5 #f) should be 243\"))\n  (unless (= (power 2 10 1000) 24)\n    (error \"Test 3 failed: (power 2 10 1000) should be 24\"))\n  (unless (= (power 3 5 13) 9)\n    (error \"Test 4 failed: (power 3 5 13) should be 9\"))\n  (unless (= (power 5 0 #f) 1)\n    (error \"Test 5 failed: (power 5 0 #f) should be 1\"))\n  (unless (= (power 5 0 7) 1)\n    (error \"Test 6 failed: (power 5 0 7) should be 1\")))\n\n(test-power)", "all_code": "#lang racket\n\n\n; power calculates a^n efficiently using the exponentiation by squaring method.\n; If a modulus mod is provided, it computes (a^n) % mod.\n; This is useful for large numbers where direct computation would be inefficient or overflow.\n; The function handles both cases (with and without modulus) by checking if mod is provided.\n(define (power a n [mod #f])\n  (let loop ([result 1]\n             [base (if mod (modulo a mod) a)]\n             [exponent n])\n    (cond\n      [(zero? exponent) result]\n      [(odd? exponent)\n       (loop (if mod (modulo (* result base) mod) (* result base))\n             (if mod (modulo (* base base) mod) (* base base))\n             (quotient exponent 2))]\n      [else\n       (loop result\n             (if mod (modulo (* base base) mod) (* base base))\n             (quotient exponent 2))])))\n\n\n(define (test-power)\n  (unless (= (power 2 10 #f) 1024)\n    (error \"Test 1 failed: (power 2 10 #f) should be 1024\"))\n  (unless (= (power 3 5 #f) 243)\n    (error \"Test 2 failed: (power 3 5 #f) should be 243\"))\n  (unless (= (power 2 10 1000) 24)\n    (error \"Test 3 failed: (power 2 10 1000) should be 24\"))\n  (unless (= (power 3 5 13) 9)\n    (error \"Test 4 failed: (power 3 5 13) should be 9\"))\n  (unless (= (power 5 0 #f) 1)\n    (error \"Test 5 failed: (power 5 0 #f) should be 1\"))\n  (unless (= (power 5 0 7) 1)\n    (error \"Test 6 failed: (power 5 0 7) should be 1\")))\n\n(test-power)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; calculate-combinations computes the number of combinations C(n, r) using dynamic programming.\n; It returns the number of ways to choose r elements from a set of n elements without regard to order.\n; If r > n, it returns 0 since it's impossible to choose more elements than available.\n; If r is 0 or equal to n, it returns 1 since there's exactly one way to choose nothing or all elements.\n; The function uses a dynamic programming approach to build a table of combinations to avoid redundant calculations.\n(define (calculate-combinations n r)\n  (cond\n    [(> r n) 0]\n    [(or (zero? r) (= r n)) 1]\n    [else\n     (let ([dp (make-vector (+ n 1) (make-vector (+ r 1) 0))])\n       (for ([i (in-range (+ n 1))])\n         (for ([j (in-range (+ (min i r) 1))])\n           (cond\n             [(or (zero? j) (= j i))\n              (vector-set! (vector-ref dp i) j 1)]\n             [else\n              (vector-set! (vector-ref dp i) j\n                           (+ (vector-ref (vector-ref dp (- i 1)) (- j 1))\n                              (vector-ref (vector-ref dp (- i 1)) j)))])))\n       (vector-ref (vector-ref dp n) r))]))", "test_cases": "", "test_case_results": "n: 5, r: 2, C(n, r): 13\nn: 4, r: 4, C(n, r): 1\nn: 3, r: 5, C(n, r): 0\nn: 7, r: 3, C(n, r): 67", "task_id": 3719, "assertions": "#lang racket\n\n(define (test-combinations)\n  (unless (= (calculate-combinations 5 2) 10)\n    (error \"Test case (5, 2) failed\"))\n  (unless (= (calculate-combinations 4 4) 1)\n    (error \"Test case (4, 4) failed\"))\n  (unless (= (calculate-combinations 3 5) 0)\n    (error \"Test case (3, 5) failed\"))\n  (unless (= (calculate-combinations 7 3) 35)\n    (error \"Test case (7, 3) failed\")))\n\n(test-combinations)", "all_code": "#lang racket\n\n\n; calculate-combinations computes the number of combinations C(n, r) using dynamic programming.\n; It returns the number of ways to choose r elements from a set of n elements without regard to order.\n; If r > n, it returns 0 since it's impossible to choose more elements than available.\n; If r is 0 or equal to n, it returns 1 since there's exactly one way to choose nothing or all elements.\n; The function uses a dynamic programming approach to build a table of combinations to avoid redundant calculations.\n(define (calculate-combinations n r)\n  (cond\n    [(> r n) 0]\n    [(or (zero? r) (= r n)) 1]\n    [else\n     (let ([dp (make-vector (+ n 1) (make-vector (+ r 1) 0))])\n       (for ([i (in-range (+ n 1))])\n         (for ([j (in-range (+ (min i r) 1))])\n           (cond\n             [(or (zero? j) (= j i))\n              (vector-set! (vector-ref dp i) j 1)]\n             [else\n              (vector-set! (vector-ref dp i) j\n                           (+ (vector-ref (vector-ref dp (- i 1)) (- j 1))\n                              (vector-ref (vector-ref dp (- i 1)) j)))])))\n       (vector-ref (vector-ref dp n) r))]))\n\n\n(define (test-combinations)\n  (unless (= (calculate-combinations 5 2) 10)\n    (error \"Test case (5, 2) failed\"))\n  (unless (= (calculate-combinations 4 4) 1)\n    (error \"Test case (4, 4) failed\"))\n  (unless (= (calculate-combinations 3 5) 0)\n    (error \"Test case (3, 5) failed\"))\n  (unless (= (calculate-combinations 7 3) 35)\n    (error \"Test case (7, 3) failed\")))\n\n(test-combinations)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; cubes-of-first-n-integers generates a list of cubes for the first n positive integers.\n; If n is less than 1, it returns an empty list.\n; Parameters:\n;   n: integer - the number of first positive integers to cube\n; Returns:\n;   list of integers - the cubes of the first n positive integers\n(define (cubes-of-first-n-integers n)\n  (if (< n 1)\n      '()\n      (for/list ([i (in-range 1 (+ n 1))])\n        (expt i 3))))", "test_cases": "", "test_case_results": "Input n: 5\nCubes: (1 8 27 64 125)\nInput n: 0\nCubes: ()\nInput n: 1\nCubes: (1)\nInput n: 10\nCubes: (1 8 27 64 125 216 343 512 729 1000)", "task_id": 22640, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-cubes-of-first-n-integers)\n  (unless (equal? (cubes-of-first-n-integers 5) '(1 8 27 64 125))\n    (error \"Test case 5 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 0) '())\n    (error \"Test case 0 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 1) '(1))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 10) '(1 8 27 64 125 216 343 512 729 1000))\n    (error \"Test case 10 failed\")))\n\n(test-cubes-of-first-n-integers)", "all_code": "#lang racket\n\n\n; cubes-of-first-n-integers generates a list of cubes for the first n positive integers.\n; If n is less than 1, it returns an empty list.\n; Parameters:\n;   n: integer - the number of first positive integers to cube\n; Returns:\n;   list of integers - the cubes of the first n positive integers\n(define (cubes-of-first-n-integers n)\n  (if (< n 1)\n      '()\n      (for/list ([i (in-range 1 (+ n 1))])\n        (expt i 3))))\n\n\n(require rackunit)\n\n(define (test-cubes-of-first-n-integers)\n  (unless (equal? (cubes-of-first-n-integers 5) '(1 8 27 64 125))\n    (error \"Test case 5 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 0) '())\n    (error \"Test case 0 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 1) '(1))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (cubes-of-first-n-integers 10) '(1 8 27 64 125 216 343 512 729 1000))\n    (error \"Test case 10 failed\")))\n\n(test-cubes-of-first-n-integers)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for hash tables and sorting\n(require racket/hash)\n\n; Define custom exceptions for conflict and event not found errors\n(define (conflict-error) (error 'ConflictError \"Event conflicts with an existing event.\"))\n(define (event-not-found-error) (error 'EventNotFoundError \"Event not found.\"))\n\n; event-scheduler is a struct that holds a hash table of events\n; Each event is stored with its name as the key and a pair of start and end times as the value\n(struct event-scheduler (events) #:mutable)\n\n; make-event-scheduler creates a new event scheduler with an empty hash table\n(define (make-event-scheduler)\n  (event-scheduler (make-hash)))\n\n; add-event adds a new event to the scheduler if it doesn't conflict with existing events\n; name: string, the name of the event\n; start-time: integer, the start time of the event\n; end-time: integer, the end time of the event\n(define (add-event scheduler name start-time end-time)\n  (let ([events (event-scheduler-events scheduler)])\n    (when (for/or ([event (in-hash-values events)])\n            (is-conflict? event start-time end-time))\n      (conflict-error))\n    (hash-set! events name (cons start-time end-time))))\n\n; remove-event removes an event from the scheduler by name\n; name: string, the name of the event to remove\n(define (remove-event scheduler name)\n  (let ([events (event-scheduler-events scheduler)])\n    (unless (hash-has-key? events name)\n      (event-not-found-error))\n    (hash-remove! events name)))\n\n; get-events returns a list of all events sorted by start time\n; Each event is represented as a list (name start-time end-time)\n(define (get-events scheduler)\n  (sort (for/list ([(name times) (in-hash (event-scheduler-events scheduler))])\n          (list name (car times) (cdr times)))\n        (lambda (a b) (< (second a) (second b)))))\n\n; get-conflicting-events returns a list of names of events that conflict with the given time range\n; start-time: integer, the start time of the range to check\n; end-time: integer, the end time of the range to check\n(define (get-conflicting-events scheduler start-time end-time)\n  (for/list ([(name times) (in-hash (event-scheduler-events scheduler))]\n             #:when (is-conflict? times start-time end-time))\n    name))\n\n; is-conflict? checks if a given time range conflicts with an existing event\n; event: a pair of start and end times\n; start-time: integer, the start time of the range to check\n; end-time: integer, the end time of the range to check\n(define (is-conflict? event start-time end-time)\n  (not (or (<= (cdr event) start-time)\n           (>= (car event) end-time))))", "test_cases": "", "test_case_results": "All events:\n(Meeting 10 12)\n(Lunch 13 14)\nConflicting events with 11-13:\n(Meeting)", "task_id": 28078, "assertions": "#lang racket\n\n(require racket/hash)\n\n(define (test-event-scheduler)\n  (let ([scheduler (make-event-scheduler)])\n    ; Test adding events\n    (add-event scheduler \"Meeting\" 10 12)\n    (add-event scheduler \"Lunch\" 13 14)\n    (add-event scheduler \"Break\" 9 10)\n    \n    ; Test conflict detection\n    (unless (equal? (get-conflicting-events scheduler 11 13) '(\"Meeting\"))\n      (error \"Conflict detection failed\"))\n    \n    ; Test removing an event\n    (remove-event scheduler \"Break\")\n    (unless (equal? (length (get-events scheduler)) 2)\n      (error \"Remove event failed\"))\n    \n    ; Test event not found error\n    (unless (with-handlers ([symbol? (lambda (e) #t)])\n              (remove-event scheduler \"Nonexistent\")\n              #f)\n      (error \"Event not found error not raised\"))\n    \n    ; Test conflict error\n    (unless (with-handlers ([symbol? (lambda (e) #t)])\n              (add-event scheduler \"Conflict\" 11 13)\n              #f)\n      (error \"Conflict error not raised\"))\n    \n    ; Test get-events sorting\n    (unless (equal? (get-events scheduler)\n                    '((\"Meeting\" 10 12) (\"Lunch\" 13 14)))\n      (error \"Event sorting failed\"))))\n\n(test-event-scheduler)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for hash tables and sorting\n(require racket/hash)\n\n; Define custom exceptions for conflict and event not found errors\n(define (conflict-error) (error 'ConflictError \"Event conflicts with an existing event.\"))\n(define (event-not-found-error) (error 'EventNotFoundError \"Event not found.\"))\n\n; event-scheduler is a struct that holds a hash table of events\n; Each event is stored with its name as the key and a pair of start and end times as the value\n(struct event-scheduler (events) #:mutable)\n\n; make-event-scheduler creates a new event scheduler with an empty hash table\n(define (make-event-scheduler)\n  (event-scheduler (make-hash)))\n\n; add-event adds a new event to the scheduler if it doesn't conflict with existing events\n; name: string, the name of the event\n; start-time: integer, the start time of the event\n; end-time: integer, the end time of the event\n(define (add-event scheduler name start-time end-time)\n  (let ([events (event-scheduler-events scheduler)])\n    (when (for/or ([event (in-hash-values events)])\n            (is-conflict? event start-time end-time))\n      (conflict-error))\n    (hash-set! events name (cons start-time end-time))))\n\n; remove-event removes an event from the scheduler by name\n; name: string, the name of the event to remove\n(define (remove-event scheduler name)\n  (let ([events (event-scheduler-events scheduler)])\n    (unless (hash-has-key? events name)\n      (event-not-found-error))\n    (hash-remove! events name)))\n\n; get-events returns a list of all events sorted by start time\n; Each event is represented as a list (name start-time end-time)\n(define (get-events scheduler)\n  (sort (for/list ([(name times) (in-hash (event-scheduler-events scheduler))])\n          (list name (car times) (cdr times)))\n        (lambda (a b) (< (second a) (second b)))))\n\n; get-conflicting-events returns a list of names of events that conflict with the given time range\n; start-time: integer, the start time of the range to check\n; end-time: integer, the end time of the range to check\n(define (get-conflicting-events scheduler start-time end-time)\n  (for/list ([(name times) (in-hash (event-scheduler-events scheduler))]\n             #:when (is-conflict? times start-time end-time))\n    name))\n\n; is-conflict? checks if a given time range conflicts with an existing event\n; event: a pair of start and end times\n; start-time: integer, the start time of the range to check\n; end-time: integer, the end time of the range to check\n(define (is-conflict? event start-time end-time)\n  (not (or (<= (cdr event) start-time)\n           (>= (car event) end-time))))\n\n\n(require racket/hash)\n\n(define (test-event-scheduler)\n  (let ([scheduler (make-event-scheduler)])\n    ; Test adding events\n    (add-event scheduler \"Meeting\" 10 12)\n    (add-event scheduler \"Lunch\" 13 14)\n    (add-event scheduler \"Break\" 9 10)\n    \n    ; Test conflict detection\n    (unless (equal? (get-conflicting-events scheduler 11 13) '(\"Meeting\"))\n      (error \"Conflict detection failed\"))\n    \n    ; Test removing an event\n    (remove-event scheduler \"Break\")\n    (unless (equal? (length (get-events scheduler)) 2)\n      (error \"Remove event failed\"))\n    \n    ; Test event not found error\n    (unless (with-handlers ([symbol? (lambda (e) #t)])\n              (remove-event scheduler \"Nonexistent\")\n              #f)\n      (error \"Event not found error not raised\"))\n    \n    ; Test conflict error\n    (unless (with-handlers ([symbol? (lambda (e) #t)])\n              (add-event scheduler \"Conflict\" 11 13)\n              #f)\n      (error \"Conflict error not raised\"))\n    \n    ; Test get-events sorting\n    (unless (equal? (get-events scheduler)\n                    '((\"Meeting\" 10 12) (\"Lunch\" 13 14)))\n      (error \"Event sorting failed\"))))\n\n(test-event-scheduler)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; remove-duplicates removes k adjacent and equal letters from the string s repeatedly until it can no longer be done.\n; It uses a stack to keep track of characters and their counts. Whenever a character's count reaches k, it is removed from the stack.\n; The final string is constructed by joining the remaining characters in the stack with their respective counts.\n; @param s: The input string.\n; @param k: The number of adjacent and equal letters to remove.\n; @returns: The final string after all such duplicate removals have been made.\n(define (remove-duplicates s k)\n  (let loop ([chars (string->list s)] [stack '()])\n    (if (null? chars)\n        (list->string (apply append (map (lambda (pair) (make-list (cadr pair) (car pair))) (reverse stack))))\n        (let ([char (car chars)] [rest (cdr chars)])\n          (if (and (not (null? stack)) (equal? (caar stack) char))\n              (let* ([top (car stack)]\n                     [new-count (+ (cadr top) 1)])\n                (if (= new-count k)\n                    (loop rest (cdr stack))\n                    (loop rest (cons (list char new-count) (cdr stack)))))\n              (loop rest (cons (list char 1) stack)))))))", "test_cases": "", "test_case_results": "Input: abcd, k: 2\nResult: abcd\nInput: deeedbbcccbdaa, k: 3\nResult: aa\nInput: pbbcggttciiippooaais, k: 2\nResult: ps\nInput: yfttttfbbbbnnnnffbgffffgbbbbfbsssssss, k: 4\nResult: ybggfbsss", "task_id": 16682, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-remove-duplicates)\n  (unless (equal? (remove-duplicates \"abcd\" 2) \"abcd\")\n    (error \"Test case 1 failed: Expected 'abcd', got something else\"))\n  (unless (equal? (remove-duplicates \"deeedbbcccbdaa\" 3) \"aa\")\n    (error \"Test case 2 failed: Expected 'aa', got something else\"))\n  (unless (equal? (remove-duplicates \"pbbcggttciiippooaais\" 2) \"ps\")\n    (error \"Test case 3 failed: Expected 'ps', got something else\"))\n  (unless (equal? (remove-duplicates \"yfttttfbbbbnnnnffbgffffgbbbbfbsssssss\" 4) \"ybggfbsss\")\n    (error \"Test case 4 failed: Expected 'ybggfbsss', got something else\")))\n\n(test-remove-duplicates)", "all_code": "#lang racket\n\n\n; remove-duplicates removes k adjacent and equal letters from the string s repeatedly until it can no longer be done.\n; It uses a stack to keep track of characters and their counts. Whenever a character's count reaches k, it is removed from the stack.\n; The final string is constructed by joining the remaining characters in the stack with their respective counts.\n; @param s: The input string.\n; @param k: The number of adjacent and equal letters to remove.\n; @returns: The final string after all such duplicate removals have been made.\n(define (remove-duplicates s k)\n  (let loop ([chars (string->list s)] [stack '()])\n    (if (null? chars)\n        (list->string (apply append (map (lambda (pair) (make-list (cadr pair) (car pair))) (reverse stack))))\n        (let ([char (car chars)] [rest (cdr chars)])\n          (if (and (not (null? stack)) (equal? (caar stack) char))\n              (let* ([top (car stack)]\n                     [new-count (+ (cadr top) 1)])\n                (if (= new-count k)\n                    (loop rest (cdr stack))\n                    (loop rest (cons (list char new-count) (cdr stack)))))\n              (loop rest (cons (list char 1) stack)))))))\n\n\n(require rackunit)\n\n(define (test-remove-duplicates)\n  (unless (equal? (remove-duplicates \"abcd\" 2) \"abcd\")\n    (error \"Test case 1 failed: Expected 'abcd', got something else\"))\n  (unless (equal? (remove-duplicates \"deeedbbcccbdaa\" 3) \"aa\")\n    (error \"Test case 2 failed: Expected 'aa', got something else\"))\n  (unless (equal? (remove-duplicates \"pbbcggttciiippooaais\" 2) \"ps\")\n    (error \"Test case 3 failed: Expected 'ps', got something else\"))\n  (unless (equal? (remove-duplicates \"yfttttfbbbbnnnnffbgffffgbbbbfbsssssss\" 4) \"ybggfbsss\")\n    (error \"Test case 4 failed: Expected 'ybggfbsss', got something else\")))\n\n(test-remove-duplicates)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; find-length calculates the length of the longest subarray that appears in both arrays.\n; It uses dynamic programming to build a matrix that stores the lengths of the longest common suffixes.\n; The function takes three arguments: two lists (arr1 and arr2) and an integer N representing their lengths.\n; The function returns the maximum length found.\n(define (find-length arr1 arr2 N)\n  ; Initialize a (N+1)x(N+1) matrix filled with zeros\n  (define dp (for/vector ([i (in-range (+ N 1))])\n               (make-vector (+ N 1) 0)))\n  (define max-length 0)\n  \n  ; Iterate through each element in both arrays\n  (for ([i (in-range N)])\n    (for ([j (in-range N)])\n      (when (equal? (list-ref arr1 i) (list-ref arr2 j))\n        ; Update the dp matrix\n        (vector-set! (vector-ref dp (+ i 1)) (+ j 1) (+ (vector-ref (vector-ref dp i) j) 1))\n        ; Update the max-length if a longer subarray is found\n        (set! max-length (max max-length (vector-ref (vector-ref dp (+ i 1)) (+ j 1)))))))\n  max-length)", "test_cases": "", "test_case_results": "Input arr1: (1 2 3 4)\nInput arr2: (1 2 3 4)\nLength of longest common subarray: 4\nInput arr1: (1 2 3 4)\nInput arr2: (5 6 7 8)\nLength of longest common subarray: 0\nInput arr1: (1 2 3 4)\nInput arr2: (1 3 2 4)\nLength of longest common subarray: 1\nInput arr1: (1 2 3 4 5)\nInput arr2: (2 3 4 5 6)\nLength of longest common subarray: 4\nInput arr1: ()\nInput arr2: ()\nLength of longest common subarray: 0", "task_id": 19762, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-find-length)\n  (unless (= (find-length '(1 2 3 4) '(1 2 3 4) 4) 4)\n    (error \"Test 1 failed: Identical arrays should return length 4\"))\n  (unless (= (find-length '(1 2 3 4) '(5 6 7 8) 4) 0)\n    (error \"Test 2 failed: No common subarrays should return length 0\"))\n  (unless (= (find-length '(1 2 3 4) '(1 3 2 4) 4) 1)\n    (error \"Test 3 failed: Arrays with some common elements but no long subarrays should return length 1\"))\n  (unless (= (find-length '(1 2 3 4 5) '(2 3 4 5 6) 5) 4)\n    (error \"Test 4 failed: Arrays with longest subarray of length 4 should return 4\"))\n  (unless (= (find-length '() '() 0) 0)\n    (error \"Test 5 failed: Empty arrays should return length 0\")))\n\n(test-find-length)", "all_code": "#lang racket\n\n\n; find-length calculates the length of the longest subarray that appears in both arrays.\n; It uses dynamic programming to build a matrix that stores the lengths of the longest common suffixes.\n; The function takes three arguments: two lists (arr1 and arr2) and an integer N representing their lengths.\n; The function returns the maximum length found.\n(define (find-length arr1 arr2 N)\n  ; Initialize a (N+1)x(N+1) matrix filled with zeros\n  (define dp (for/vector ([i (in-range (+ N 1))])\n               (make-vector (+ N 1) 0)))\n  (define max-length 0)\n  \n  ; Iterate through each element in both arrays\n  (for ([i (in-range N)])\n    (for ([j (in-range N)])\n      (when (equal? (list-ref arr1 i) (list-ref arr2 j))\n        ; Update the dp matrix\n        (vector-set! (vector-ref dp (+ i 1)) (+ j 1) (+ (vector-ref (vector-ref dp i) j) 1))\n        ; Update the max-length if a longer subarray is found\n        (set! max-length (max max-length (vector-ref (vector-ref dp (+ i 1)) (+ j 1)))))))\n  max-length)\n\n\n(require rackunit)\n\n(define (test-find-length)\n  (unless (= (find-length '(1 2 3 4) '(1 2 3 4) 4) 4)\n    (error \"Test 1 failed: Identical arrays should return length 4\"))\n  (unless (= (find-length '(1 2 3 4) '(5 6 7 8) 4) 0)\n    (error \"Test 2 failed: No common subarrays should return length 0\"))\n  (unless (= (find-length '(1 2 3 4) '(1 3 2 4) 4) 1)\n    (error \"Test 3 failed: Arrays with some common elements but no long subarrays should return length 1\"))\n  (unless (= (find-length '(1 2 3 4 5) '(2 3 4 5 6) 5) 4)\n    (error \"Test 4 failed: Arrays with longest subarray of length 4 should return 4\"))\n  (unless (= (find-length '() '() 0) 0)\n    (error \"Test 5 failed: Empty arrays should return length 0\")))\n\n(test-find-length)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; can-form-ap? determines if a sequence of integers can be rearranged to form an arithmetic progression.\n; An arithmetic progression is a sequence where the difference between consecutive elements is constant.\n; The function first sorts the sequence and then checks if the differences between all consecutive elements are equal.\n; \n; Parameters:\n; - seq : list of numbers : the sequence to check\n;\n; Returns:\n; - boolean : #t if the sequence can form an arithmetic progression, #f otherwise\n(define (can-form-ap? seq)\n  (let* ([sorted-seq (sort seq <)]\n         [len (length sorted-seq)])\n    (if (<= len 1)\n        #t\n        (let ([diff (- (second sorted-seq) (first sorted-seq))])\n          (for/and ([i (in-range 1 (- len 1))])\n            (= (- (list-ref sorted-seq (+ i 1)) (list-ref sorted-seq i)) diff))))))", "test_cases": "", "test_case_results": "Input: (1 3 2)\nYES\nInput: (5 5 5 5)\nYES\nInput: (1 2 3 4 6)\nNO\nInput: (10 20)\nYES\nInput: (7)\nYES", "task_id": 29050, "assertions": "#lang racket\n\n(define (test-can-form-ap)\n  (unless (equal? (can-form-ap? '(1 3 2)) #t)\n    (error \"Test 1 failed\"))\n  (unless (equal? (can-form-ap? '(5 5 5 5)) #t)\n    (error \"Test 2 failed\"))\n  (unless (equal? (can-form-ap? '(1 2 3 4 6)) #f)\n    (error \"Test 3 failed\"))\n  (unless (equal? (can-form-ap? '(10 20)) #t)\n    (error \"Test 4 failed\"))\n  (unless (equal? (can-form-ap? '(7)) #t)\n    (error \"Test 5 failed\")))\n\n(test-can-form-ap)", "all_code": "#lang racket\n\n\n; can-form-ap? determines if a sequence of integers can be rearranged to form an arithmetic progression.\n; An arithmetic progression is a sequence where the difference between consecutive elements is constant.\n; The function first sorts the sequence and then checks if the differences between all consecutive elements are equal.\n; \n; Parameters:\n; - seq : list of numbers : the sequence to check\n;\n; Returns:\n; - boolean : #t if the sequence can form an arithmetic progression, #f otherwise\n(define (can-form-ap? seq)\n  (let* ([sorted-seq (sort seq <)]\n         [len (length sorted-seq)])\n    (if (<= len 1)\n        #t\n        (let ([diff (- (second sorted-seq) (first sorted-seq))])\n          (for/and ([i (in-range 1 (- len 1))])\n            (= (- (list-ref sorted-seq (+ i 1)) (list-ref sorted-seq i)) diff))))))\n\n\n(define (test-can-form-ap)\n  (unless (equal? (can-form-ap? '(1 3 2)) #t)\n    (error \"Test 1 failed\"))\n  (unless (equal? (can-form-ap? '(5 5 5 5)) #t)\n    (error \"Test 2 failed\"))\n  (unless (equal? (can-form-ap? '(1 2 3 4 6)) #f)\n    (error \"Test 3 failed\"))\n  (unless (equal? (can-form-ap? '(10 20)) #t)\n    (error \"Test 4 failed\"))\n  (unless (equal? (can-form-ap? '(7)) #t)\n    (error \"Test 5 failed\")))\n\n(test-can-form-ap)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for binary search and sorting\n(require srfi/1) ; For list operations\n\n; CustomDataStructure maintains a sorted list of elements with operations to insert, delete, and get the minimum element.\n; The list is kept in sorted order to allow efficient operations.\n(define (make-custom-data-structure)\n  (let ([elements '()]) ; Initialize an empty list to store elements\n    (lambda (operation . args)\n      (case operation\n        [(insert) ; Insert an element into the list while maintaining sorted order\n         (let ([x (car args)])\n           (set! elements (insert-sorted elements x)))]\n        [(delete) ; Delete an element from the list if it exists\n         (let ([x (car args)])\n           (set! elements (delete-element elements x)))]\n        [(get-min) ; Get the minimum element in the list (first element since list is sorted)\n         (if (null? elements)\n             #f\n             (car elements))]))))\n\n; Helper function to insert an element into a sorted list while maintaining order\n(define (insert-sorted lst x)\n  (let loop ([left '()]\n             [right lst])\n    (cond [(null? right) (append left (list x))]\n          [(<= x (car right)) (append left (list x) right)]\n          [else (loop (append left (list (car right))) (cdr right))])))\n\n; Helper function to delete an element from a sorted list if it exists\n(define (delete-element lst x)\n  (let loop ([left '()]\n             [right lst])\n    (cond [(null? right) left]\n          [(= x (car right)) (append left (cdr right))]\n          [else (loop (append left (list (car right))) (cdr right))])))", "test_cases": "", "test_case_results": "Operation: insert (5)\nOperation: insert (3)\nOperation: insert (7)\nOperation: get-min ()\nResult: 3\nOperation: delete (3)\nOperation: get-min ()\nResult: 5\nOperation: delete (5)\nOperation: get-min ()\nResult: 7\nOperation: delete (7)\nOperation: get-min ()\nResult: #f", "task_id": 7225, "assertions": "#lang racket\n\n(require srfi/1)\n\n(define (test-custom-data-structure)\n  (let ([ds (make-custom-data-structure)])\n    (ds 'insert 5)\n    (ds 'insert 3)\n    (ds 'insert 7)\n    (unless (equal? (ds 'get-min) 3)\n      (error \"Test 1 failed: Expected minimum to be 3\"))\n    (ds 'delete 3)\n    (unless (equal? (ds 'get-min) 5)\n      (error \"Test 2 failed: Expected minimum to be 5\"))\n    (ds 'delete 5)\n    (unless (equal? (ds 'get-min) 7)\n      (error \"Test 3 failed: Expected minimum to be 7\"))\n    (ds 'delete 7)\n    (unless (equal? (ds 'get-min) #f)\n      (error \"Test 4 failed: Expected minimum to be #f\"))))\n\n(test-custom-data-structure)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for binary search and sorting\n(require srfi/1) ; For list operations\n\n; CustomDataStructure maintains a sorted list of elements with operations to insert, delete, and get the minimum element.\n; The list is kept in sorted order to allow efficient operations.\n(define (make-custom-data-structure)\n  (let ([elements '()]) ; Initialize an empty list to store elements\n    (lambda (operation . args)\n      (case operation\n        [(insert) ; Insert an element into the list while maintaining sorted order\n         (let ([x (car args)])\n           (set! elements (insert-sorted elements x)))]\n        [(delete) ; Delete an element from the list if it exists\n         (let ([x (car args)])\n           (set! elements (delete-element elements x)))]\n        [(get-min) ; Get the minimum element in the list (first element since list is sorted)\n         (if (null? elements)\n             #f\n             (car elements))]))))\n\n; Helper function to insert an element into a sorted list while maintaining order\n(define (insert-sorted lst x)\n  (let loop ([left '()]\n             [right lst])\n    (cond [(null? right) (append left (list x))]\n          [(<= x (car right)) (append left (list x) right)]\n          [else (loop (append left (list (car right))) (cdr right))])))\n\n; Helper function to delete an element from a sorted list if it exists\n(define (delete-element lst x)\n  (let loop ([left '()]\n             [right lst])\n    (cond [(null? right) left]\n          [(= x (car right)) (append left (cdr right))]\n          [else (loop (append left (list (car right))) (cdr right))])))\n\n\n(require srfi/1)\n\n(define (test-custom-data-structure)\n  (let ([ds (make-custom-data-structure)])\n    (ds 'insert 5)\n    (ds 'insert 3)\n    (ds 'insert 7)\n    (unless (equal? (ds 'get-min) 3)\n      (error \"Test 1 failed: Expected minimum to be 3\"))\n    (ds 'delete 3)\n    (unless (equal? (ds 'get-min) 5)\n      (error \"Test 2 failed: Expected minimum to be 5\"))\n    (ds 'delete 5)\n    (unless (equal? (ds 'get-min) 7)\n      (error \"Test 3 failed: Expected minimum to be 7\"))\n    (ds 'delete 7)\n    (unless (equal? (ds 'get-min) #f)\n      (error \"Test 4 failed: Expected minimum to be #f\"))))\n\n(test-custom-data-structure)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for string manipulation\n(require racket/string)\n\n; can-be-typed? determines how many words in a given text can be fully typed\n; without using any of the broken letters.\n; text: string - the input sentence\n; broken-letters: string - characters representing broken keys\n; Returns the count of words that can be typed without using any broken letters.\n(define (can-be-typed? text broken-letters)\n  (let* ([lower-text (string-downcase text)]\n         [lower-broken (string-downcase broken-letters)]\n         [broken-set (list->set (string->list lower-broken))]\n         [words (string-split lower-text)])\n    (for/sum ([word words])\n      (if (for/and ([char (string->list word)])\n            (not (set-member? broken-set char)))\n          1\n          0))))", "test_cases": "", "test_case_results": "Text: hello world\nBroken Letters: e\nCount: 1\n\nText: hello world\nBroken Letters: eohw\nCount: 0\n\nText: Hello World\nBroken Letters: z\nCount: 2\n\nText: This is a test\nBroken Letters: ts\nCount: 1\n\nText: \nBroken Letters: abc\nCount: 0\n\nText: no broken letters\nBroken Letters: \nCount: 3", "task_id": 2958, "assertions": "#lang racket\n\n(require racket/string)\n\n(define (test-can-be-typed)\n  (unless (= (can-be-typed? \"hello world\" \"e\") 1)\n    (error \"Test case 1 failed\"))\n  (unless (= (can-be-typed? \"hello world\" \"eohw\") 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (can-be-typed? \"Hello World\" \"z\") 2)\n    (error \"Test case 3 failed\"))\n  (unless (= (can-be-typed? \"This is a test\" \"ts\") 1)\n    (error \"Test case 4 failed\"))\n  (unless (= (can-be-typed? \"\" \"abc\") 0)\n    (error \"Test case 5 failed\"))\n  (unless (= (can-be-typed? \"no broken letters\" \"\") 3)\n    (error \"Test case 6 failed\")))\n\n(test-can-be-typed)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for string manipulation\n(require racket/string)\n\n; can-be-typed? determines how many words in a given text can be fully typed\n; without using any of the broken letters.\n; text: string - the input sentence\n; broken-letters: string - characters representing broken keys\n; Returns the count of words that can be typed without using any broken letters.\n(define (can-be-typed? text broken-letters)\n  (let* ([lower-text (string-downcase text)]\n         [lower-broken (string-downcase broken-letters)]\n         [broken-set (list->set (string->list lower-broken))]\n         [words (string-split lower-text)])\n    (for/sum ([word words])\n      (if (for/and ([char (string->list word)])\n            (not (set-member? broken-set char)))\n          1\n          0))))\n\n\n(require racket/string)\n\n(define (test-can-be-typed)\n  (unless (= (can-be-typed? \"hello world\" \"e\") 1)\n    (error \"Test case 1 failed\"))\n  (unless (= (can-be-typed? \"hello world\" \"eohw\") 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (can-be-typed? \"Hello World\" \"z\") 2)\n    (error \"Test case 3 failed\"))\n  (unless (= (can-be-typed? \"This is a test\" \"ts\") 1)\n    (error \"Test case 4 failed\"))\n  (unless (= (can-be-typed? \"\" \"abc\") 0)\n    (error \"Test case 5 failed\"))\n  (unless (= (can-be-typed? \"no broken letters\" \"\") 3)\n    (error \"Test case 6 failed\")))\n\n(test-can-be-typed)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sum-of-squares calculates the sum of the squares of integers provided as a comma-separated string.\n; It splits the string into individual integers, converts them to numbers, squares each number, and sums the results.\n; If the input string is empty, it returns 0.\n(define (sum-of-squares comma-separated-integers)\n  (let ([number-strings (string-split comma-separated-integers \",\")])\n    (if (empty? number-strings)\n        0\n        (let ([numbers (map string->number number-strings)])\n          (apply + (map (lambda (x) (* x x)) numbers))))))", "test_cases": "", "test_case_results": "Input: 1,2,3,4\nSum of squares: 30\nInput: 5,6,7,0\nSum of squares: 110\nInput: 0,0,0,0\nSum of squares: 0\nInput: \nSum of squares: 0", "task_id": 5958, "assertions": "#lang racket\n\n(define (test-sum-of-squares)\n  (unless (= (sum-of-squares \"1,2,3,4\") 30)\n    (error \"Test case 1 failed: Expected 30\"))\n  (unless (= (sum-of-squares \"5,6,7,0\") 110)\n    (error \"Test case 2 failed: Expected 110\"))\n  (unless (= (sum-of-squares \"0,0,0,0\") 0)\n    (error \"Test case 3 failed: Expected 0\"))\n  (unless (= (sum-of-squares \"\") 0)\n    (error \"Test case 4 failed: Expected 0\")))\n\n(test-sum-of-squares)", "all_code": "#lang racket\n\n\n; sum-of-squares calculates the sum of the squares of integers provided as a comma-separated string.\n; It splits the string into individual integers, converts them to numbers, squares each number, and sums the results.\n; If the input string is empty, it returns 0.\n(define (sum-of-squares comma-separated-integers)\n  (let ([number-strings (string-split comma-separated-integers \",\")])\n    (if (empty? number-strings)\n        0\n        (let ([numbers (map string->number number-strings)])\n          (apply + (map (lambda (x) (* x x)) numbers))))))\n\n\n(define (test-sum-of-squares)\n  (unless (= (sum-of-squares \"1,2,3,4\") 30)\n    (error \"Test case 1 failed: Expected 30\"))\n  (unless (= (sum-of-squares \"5,6,7,0\") 110)\n    (error \"Test case 2 failed: Expected 110\"))\n  (unless (= (sum-of-squares \"0,0,0,0\") 0)\n    (error \"Test case 3 failed: Expected 0\"))\n  (unless (= (sum-of-squares \"\") 0)\n    (error \"Test case 4 failed: Expected 0\")))\n\n(test-sum-of-squares)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-yield calculates the maximum yield for each grid in the input list.\n; Each grid is represented as a list with dimensions (m, n, d) and a grid of growth rates.\n; The maximum yield for a grid is the maximum growth rate in the grid multiplied by d.\n(define (max-yield grids)\n  (for/list ([grid grids])\n    (let* ([dimensions (first grid)]\n           [m (first dimensions)]\n           [n (second dimensions)]\n           [d (third dimensions)]\n           [grid-data (second grid)]\n           [max-growth (apply max (flatten grid-data))])\n      (* max-growth d))))\n\n; parse-input converts a string of input data into a list of grids.\n; Each grid is represented as a list with dimensions (m, n, d) and a grid of growth rates.\n; The input data is expected to be a string with lines separated by newline characters.\n; The parsing stops when a line with '0 0' is encountered.\n(define (parse-input input-data)\n  (let ([lines (string-split input-data \"\\n\")]\n        [grids '()])\n    (let loop ([i 0])\n      (if (>= i (length lines))\n          grids\n          (let ([line (list-ref lines i)])\n            (if (string=? line \"0 0\")\n                grids\n                (let* ([parts (string-split line)]\n                       [m (string->number (first parts))]\n                       [n (string->number (second parts))]\n                       [d (string->number (third parts))])\n                  (let ([grid (for/list ([j (in-range 1 (add1 m))])\n                                (let ([row (string-split (list-ref lines (+ i j)))])\n                                  (map string->number row)))])\n                    (loop (+ i m 1))\n                    (cons (list (list m n d) grid) grids)))))))))", "test_cases": "", "test_case_results": "Input data:\n2 2 10\n1 2\n3 4\n0 0\nParsed grids: (((2 2 10) ((1 2) (3 4))))\nMax yields: (40)\nInput data:\n3 3 5\n1 2 3\n4 5 6\n7 8 9\n1 1 2\n10\n0 0\nParsed grids: (((3 3 5) ((1 2 3) (4 5 6) (7 8 9))))\nMax yields: (45)", "task_id": 1289, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-max-yield)\n  (let* ([test-input-1 \"2 2 10\\n1 2\\n3 4\\n0 0\"]\n         [test-input-2 \"3 3 5\\n1 2 3\\n4 5 6\\n7 8 9\\n1 1 2\\n10\\n0 0\"]\n         [grids1 (parse-input test-input-1)]\n         [grids2 (parse-input test-input-2)]\n         [yields1 (max-yield grids1)]\n         [yields2 (max-yield grids2)])\n    \n    (unless (equal? yields1 '(40))\n      (error \"Test 1 failed: Expected '(40), got \" yields1))\n    \n    (unless (equal? yields2 '(45))\n      (error \"Test 2 failed: Expected '(45), got \" yields2))))\n\n(test-max-yield)", "all_code": "#lang racket\n\n\n; max-yield calculates the maximum yield for each grid in the input list.\n; Each grid is represented as a list with dimensions (m, n, d) and a grid of growth rates.\n; The maximum yield for a grid is the maximum growth rate in the grid multiplied by d.\n(define (max-yield grids)\n  (for/list ([grid grids])\n    (let* ([dimensions (first grid)]\n           [m (first dimensions)]\n           [n (second dimensions)]\n           [d (third dimensions)]\n           [grid-data (second grid)]\n           [max-growth (apply max (flatten grid-data))])\n      (* max-growth d))))\n\n; parse-input converts a string of input data into a list of grids.\n; Each grid is represented as a list with dimensions (m, n, d) and a grid of growth rates.\n; The input data is expected to be a string with lines separated by newline characters.\n; The parsing stops when a line with '0 0' is encountered.\n(define (parse-input input-data)\n  (let ([lines (string-split input-data \"\\n\")]\n        [grids '()])\n    (let loop ([i 0])\n      (if (>= i (length lines))\n          grids\n          (let ([line (list-ref lines i)])\n            (if (string=? line \"0 0\")\n                grids\n                (let* ([parts (string-split line)]\n                       [m (string->number (first parts))]\n                       [n (string->number (second parts))]\n                       [d (string->number (third parts))])\n                  (let ([grid (for/list ([j (in-range 1 (add1 m))])\n                                (let ([row (string-split (list-ref lines (+ i j)))])\n                                  (map string->number row)))])\n                    (loop (+ i m 1))\n                    (cons (list (list m n d) grid) grids)))))))))\n\n\n(require rackunit)\n\n(define (test-max-yield)\n  (let* ([test-input-1 \"2 2 10\\n1 2\\n3 4\\n0 0\"]\n         [test-input-2 \"3 3 5\\n1 2 3\\n4 5 6\\n7 8 9\\n1 1 2\\n10\\n0 0\"]\n         [grids1 (parse-input test-input-1)]\n         [grids2 (parse-input test-input-2)]\n         [yields1 (max-yield grids1)]\n         [yields2 (max-yield grids2)])\n    \n    (unless (equal? yields1 '(40))\n      (error \"Test 1 failed: Expected '(40), got \" yields1))\n    \n    (unless (equal? yields2 '(45))\n      (error \"Test 2 failed: Expected '(45), got \" yields2))))\n\n(test-max-yield)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require necessary standard libraries\n(require math/statistics)\n\n; fruit-sales-trend analyzes monthly fruit sales data\n; It takes two lists of equal length: months and sales\n; Returns a list of statistics about the sales data\n(define (fruit-sales-trend months sales)\n  (cond\n    [(or (empty? months) (empty? sales)) \n     (error \"Input lists cannot be empty\")]\n    [(not (= (length months) (length sales)))\n     (error \"Month and sales lists must be of equal length\")]\n    [else\n     (let ([mean-sales (mean sales)]\n           [max-sales (apply max sales)]\n           [min-sales (apply min sales)]\n           [total-sales (apply + sales)])\n       (list (cons 'mean-sales mean-sales)\n             (cons 'max-sales max-sales)\n             (cons 'min-sales min-sales)\n             (cons 'total-sales total-sales)))]))", "test_cases": "", "test_case_results": "Test Case 1:\nMonths: (Jan Feb Mar Apr May Jun)\nSales: (120 150 180 200 210 190)\nStatistics: ((mean-sales . 175) (max-sales . 210) (min-sales . 120) (total-sales . 1050))\n\nTest Case 2:\nMonths: (Jul Aug Sep Oct Nov Dec)\nSales: (220 240 230 250 260 300)\nStatistics: ((mean-sales . 250) (max-sales . 300) (min-sales . 220) (total-sales . 1500))\n\nTest Case 3:\nInput lists cannot be empty\n\nTest Case 4:\nMonth and sales lists must be of equal length", "task_id": 7068, "assertions": "#lang racket\n\n(require math/statistics)\n\n(define (test-fruit-sales-trend)\n  ; Test case 1 - Normal case\n  (let ([result (fruit-sales-trend '(Jan Feb Mar Apr May Jun) '(120 150 180 200 210 190))])\n    (unless (equal? (assoc 'mean-sales result) '(mean-sales . 175))\n      (error \"Test 1 mean-sales failed\"))\n    (unless (equal? (assoc 'max-sales result) '(max-sales . 210))\n      (error \"Test 1 max-sales failed\"))\n    (unless (equal? (assoc 'min-sales result) '(min-sales . 120))\n      (error \"Test 1 min-sales failed\"))\n    (unless (equal? (assoc 'total-sales result) '(total-sales . 1050))\n      (error \"Test 1 total-sales failed\")))\n  \n  ; Test case 2 - Another normal case\n  (let ([result (fruit-sales-trend '(Jul Aug Sep Oct Nov Dec) '(220 240 230 250 260 300))])\n    (unless (equal? (assoc 'mean-sales result) '(mean-sales . 250))\n      (error \"Test 2 mean-sales failed\"))\n    (unless (equal? (assoc 'max-sales result) '(max-sales . 300))\n      (error \"Test 2 max-sales failed\"))\n    (unless (equal? (assoc 'min-sales result) '(min-sales . 220))\n      (error \"Test 2 min-sales failed\"))\n    (unless (equal? (assoc 'total-sales result) '(total-sales . 1500))\n      (error \"Test 2 total-sales failed\")))\n  \n  ; Test case 3 - Error case (empty list)\n  (unless (with-handlers ([exn:fail? (λ (e) #t)])\n            (fruit-sales-trend '() '(100 200))\n            #f)\n    (error \"Test 3 empty list check failed\"))\n  \n  ; Test case 4 - Error case (mismatched lengths)\n  (unless (with-handlers ([exn:fail? (λ (e) #t)])\n            (fruit-sales-trend '(Jan) '(100 200))\n            #f)\n    (error \"Test 4 length mismatch check failed\")))\n\n(test-fruit-sales-trend)", "all_code": "#lang racket\n\n\n; Require necessary standard libraries\n(require math/statistics)\n\n; fruit-sales-trend analyzes monthly fruit sales data\n; It takes two lists of equal length: months and sales\n; Returns a list of statistics about the sales data\n(define (fruit-sales-trend months sales)\n  (cond\n    [(or (empty? months) (empty? sales)) \n     (error \"Input lists cannot be empty\")]\n    [(not (= (length months) (length sales)))\n     (error \"Month and sales lists must be of equal length\")]\n    [else\n     (let ([mean-sales (mean sales)]\n           [max-sales (apply max sales)]\n           [min-sales (apply min sales)]\n           [total-sales (apply + sales)])\n       (list (cons 'mean-sales mean-sales)\n             (cons 'max-sales max-sales)\n             (cons 'min-sales min-sales)\n             (cons 'total-sales total-sales)))]))\n\n\n(require math/statistics)\n\n(define (test-fruit-sales-trend)\n  ; Test case 1 - Normal case\n  (let ([result (fruit-sales-trend '(Jan Feb Mar Apr May Jun) '(120 150 180 200 210 190))])\n    (unless (equal? (assoc 'mean-sales result) '(mean-sales . 175))\n      (error \"Test 1 mean-sales failed\"))\n    (unless (equal? (assoc 'max-sales result) '(max-sales . 210))\n      (error \"Test 1 max-sales failed\"))\n    (unless (equal? (assoc 'min-sales result) '(min-sales . 120))\n      (error \"Test 1 min-sales failed\"))\n    (unless (equal? (assoc 'total-sales result) '(total-sales . 1050))\n      (error \"Test 1 total-sales failed\")))\n  \n  ; Test case 2 - Another normal case\n  (let ([result (fruit-sales-trend '(Jul Aug Sep Oct Nov Dec) '(220 240 230 250 260 300))])\n    (unless (equal? (assoc 'mean-sales result) '(mean-sales . 250))\n      (error \"Test 2 mean-sales failed\"))\n    (unless (equal? (assoc 'max-sales result) '(max-sales . 300))\n      (error \"Test 2 max-sales failed\"))\n    (unless (equal? (assoc 'min-sales result) '(min-sales . 220))\n      (error \"Test 2 min-sales failed\"))\n    (unless (equal? (assoc 'total-sales result) '(total-sales . 1500))\n      (error \"Test 2 total-sales failed\")))\n  \n  ; Test case 3 - Error case (empty list)\n  (unless (with-handlers ([exn:fail? (λ (e) #t)])\n            (fruit-sales-trend '() '(100 200))\n            #f)\n    (error \"Test 3 empty list check failed\"))\n  \n  ; Test case 4 - Error case (mismatched lengths)\n  (unless (with-handlers ([exn:fail? (λ (e) #t)])\n            (fruit-sales-trend '(Jan) '(100 200))\n            #f)\n    (error \"Test 4 length mismatch check failed\")))\n\n(test-fruit-sales-trend)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; find-winner determines the winner for each test case by calculating total points \n; for each participant based on their problems solved and points earned.\n; \n; Parameters:\n; test-cases : list of lists, where each inner list represents a test case.\n;   Each test case is a list where the first element is the number of problems (P),\n;   and the second element is a list of problems. Each problem is represented as a list\n;   of the form (name points), where name is a symbol and points is a number.\n;\n; Returns:\n; list of lists, where each inner list contains the winner's name and their score.\n(define (find-winner test-cases)\n  (map \n   (lambda (test-case)\n     (let* ([P (first test-case)]\n            [problems (second test-case)]\n            [scores (make-hash)])\n       (for-each \n        (lambda (problem)\n          (let ([name (first problem)]\n                [points (second problem)])\n            (hash-update! scores name (lambda (current) (+ current points)) points)))\n        problems)\n       (let ([winner (argmax (lambda (kv) (cdr kv)) (hash->list scores))])\n         (list (car winner) (cdr winner)))))\n   test-cases))", "test_cases": "", "test_case_results": "Test Cases:\nInput: (2 ((Alice 10) (Bob 20) (Alice 30)))\nInput: (3 ((Charlie 5) (Bob 15) (Alice 10)))\nInput: (1 ((Dave 50) (Dave 50)))\n\nResults:\nWinner: Alice, Score: 50\nWinner: Bob, Score: 30\nWinner: Dave, Score: 150", "task_id": 321, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-find-winner)\n  (let ([results (find-winner '((2 ((Alice 10) (Bob 20) (Alice 30)))\n                                (3 ((Charlie 5) (Bob 15) (Alice 10)))\n                                (1 ((Dave 50) (Dave 50)))))])\n    (unless (equal? (first (first results)) 'Alice)\n      (error \"Test 1 failed: Expected winner Alice\"))\n    (unless (= (second (first results)) 40)\n      (error \"Test 1 failed: Expected score 40\"))\n    \n    (unless (equal? (first (second results)) 'Bob)\n      (error \"Test 2 failed: Expected winner Bob\"))\n    (unless (= (second (second results)) 15)\n      (error \"Test 2 failed: Expected score 15\"))\n    \n    (unless (equal? (first (third results)) 'Dave)\n      (error \"Test 3 failed: Expected winner Dave\"))\n    (unless (= (second (third results)) 100)\n      (error \"Test 3 failed: Expected score 100\"))))\n\n(test-find-winner)", "all_code": "#lang racket\n\n\n; find-winner determines the winner for each test case by calculating total points \n; for each participant based on their problems solved and points earned.\n; \n; Parameters:\n; test-cases : list of lists, where each inner list represents a test case.\n;   Each test case is a list where the first element is the number of problems (P),\n;   and the second element is a list of problems. Each problem is represented as a list\n;   of the form (name points), where name is a symbol and points is a number.\n;\n; Returns:\n; list of lists, where each inner list contains the winner's name and their score.\n(define (find-winner test-cases)\n  (map \n   (lambda (test-case)\n     (let* ([P (first test-case)]\n            [problems (second test-case)]\n            [scores (make-hash)])\n       (for-each \n        (lambda (problem)\n          (let ([name (first problem)]\n                [points (second problem)])\n            (hash-update! scores name (lambda (current) (+ current points)) points)))\n        problems)\n       (let ([winner (argmax (lambda (kv) (cdr kv)) (hash->list scores))])\n         (list (car winner) (cdr winner)))))\n   test-cases))\n\n\n(require rackunit)\n\n(define (test-find-winner)\n  (let ([results (find-winner '((2 ((Alice 10) (Bob 20) (Alice 30)))\n                                (3 ((Charlie 5) (Bob 15) (Alice 10)))\n                                (1 ((Dave 50) (Dave 50)))))])\n    (unless (equal? (first (first results)) 'Alice)\n      (error \"Test 1 failed: Expected winner Alice\"))\n    (unless (= (second (first results)) 40)\n      (error \"Test 1 failed: Expected score 40\"))\n    \n    (unless (equal? (first (second results)) 'Bob)\n      (error \"Test 2 failed: Expected winner Bob\"))\n    (unless (= (second (second results)) 15)\n      (error \"Test 2 failed: Expected score 15\"))\n    \n    (unless (equal? (first (third results)) 'Dave)\n      (error \"Test 3 failed: Expected winner Dave\"))\n    (unless (= (second (third results)) 100)\n      (error \"Test 3 failed: Expected score 100\"))))\n\n(test-find-winner)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; is-convex-polygon determines if a set of points in a 2D plane form a convex polygon.\n; The function checks the cross product of consecutive edges to ensure all turns are consistently\n; either clockwise or counter-clockwise.\n; Input: points - a list of pairs (x y) representing the coordinates of the points in order.\n; Output: 'YES if the points form a convex polygon, 'NO otherwise.\n(define (is-convex-polygon points)\n  ; cross-product calculates the cross product of vectors OA and OB.\n  ; o, a, b are points represented as lists (x y).\n  ; Returns:\n  ;   Positive for counter-clockwise turn,\n  ;   Negative for clockwise turn,\n  ;   Zero for collinear points.\n  (define (cross-product o a b)\n    (- (* (- (first a) (first o)) (- (second b) (second o)))\n       (* (- (second a) (second o)) (- (first b) (first o)))))\n  \n  (let ([n (length points)])\n    (if (< n 3)\n        'NO\n        (let loop ([i 0] [prev-cross-prod 0])\n          (if (>= i n)\n              'YES\n              (let* ([a (list-ref points i)]\n                     [b (list-ref points (modulo (+ i 1) n))]\n                     [c (list-ref points (modulo (+ i 2) n))]\n                     [cross-prod (cross-product a b c)])\n                (cond\n                  [(= cross-prod 0) (loop (+ i 1) prev-cross-prod)]\n                  [(< (* cross-prod prev-cross-prod) 0) 'NO]\n                  [else (loop (+ i 1) (if (= prev-cross-prod 0) cross-prod prev-cross-prod))])))))))", "test_cases": "", "test_case_results": "Points: ((0 0) (0 1) (1 1) (1 0))\nConvex? YES\n\nPoints: ((0 0) (0 1) (1 1) (0.5 0.5) (1 0))\nConvex? NO\n\nPoints: ((0 0) (1 0) (1 1) (0 1))\nConvex? YES\n\nPoints: ((0 0) (1 0) (0.5 1))\nConvex? YES\n\nPoints: ((0 0) (1 0) (0.5 1) (0.5 0.5))\nConvex? NO\n\nPoints: ((0 0) (1 0))\nConvex? NO\n\nPoints: ((0 0))\nConvex? NO\n\nPoints: ()\nConvex? NO", "task_id": 4486, "assertions": "#lang racket\n\n(define (test-convex-polygon)\n  (unless (equal? (is-convex-polygon '((0 0) (0 1) (1 1) (1 0))) 'YES)\n    (error \"Test 1 failed: Square should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (0 1) (1 1) (0.5 0.5) (1 0))) 'NO)\n    (error \"Test 2 failed: Star-like shape should not be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (1 1) (0 1))) 'YES)\n    (error \"Test 3 failed: Another square should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (0.5 1))) 'YES)\n    (error \"Test 4 failed: Triangle should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (0.5 1) (0.5 0.5))) 'NO)\n    (error \"Test 5 failed: Triangle with extra point should not be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0))) 'NO)\n    (error \"Test 6 failed: Two points should not form a convex polygon\"))\n  (unless (equal? (is-convex-polygon '((0 0))) 'NO)\n    (error \"Test 7 failed: One point should not form a convex polygon\"))\n  (unless (equal? (is-convex-polygon '()) 'NO)\n    (error \"Test 8 failed: Empty list should not form a convex polygon\")))\n\n(test-convex-polygon)", "all_code": "#lang racket\n\n\n; is-convex-polygon determines if a set of points in a 2D plane form a convex polygon.\n; The function checks the cross product of consecutive edges to ensure all turns are consistently\n; either clockwise or counter-clockwise.\n; Input: points - a list of pairs (x y) representing the coordinates of the points in order.\n; Output: 'YES if the points form a convex polygon, 'NO otherwise.\n(define (is-convex-polygon points)\n  ; cross-product calculates the cross product of vectors OA and OB.\n  ; o, a, b are points represented as lists (x y).\n  ; Returns:\n  ;   Positive for counter-clockwise turn,\n  ;   Negative for clockwise turn,\n  ;   Zero for collinear points.\n  (define (cross-product o a b)\n    (- (* (- (first a) (first o)) (- (second b) (second o)))\n       (* (- (second a) (second o)) (- (first b) (first o)))))\n  \n  (let ([n (length points)])\n    (if (< n 3)\n        'NO\n        (let loop ([i 0] [prev-cross-prod 0])\n          (if (>= i n)\n              'YES\n              (let* ([a (list-ref points i)]\n                     [b (list-ref points (modulo (+ i 1) n))]\n                     [c (list-ref points (modulo (+ i 2) n))]\n                     [cross-prod (cross-product a b c)])\n                (cond\n                  [(= cross-prod 0) (loop (+ i 1) prev-cross-prod)]\n                  [(< (* cross-prod prev-cross-prod) 0) 'NO]\n                  [else (loop (+ i 1) (if (= prev-cross-prod 0) cross-prod prev-cross-prod))])))))))\n\n\n(define (test-convex-polygon)\n  (unless (equal? (is-convex-polygon '((0 0) (0 1) (1 1) (1 0))) 'YES)\n    (error \"Test 1 failed: Square should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (0 1) (1 1) (0.5 0.5) (1 0))) 'NO)\n    (error \"Test 2 failed: Star-like shape should not be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (1 1) (0 1))) 'YES)\n    (error \"Test 3 failed: Another square should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (0.5 1))) 'YES)\n    (error \"Test 4 failed: Triangle should be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0) (0.5 1) (0.5 0.5))) 'NO)\n    (error \"Test 5 failed: Triangle with extra point should not be convex\"))\n  (unless (equal? (is-convex-polygon '((0 0) (1 0))) 'NO)\n    (error \"Test 6 failed: Two points should not form a convex polygon\"))\n  (unless (equal? (is-convex-polygon '((0 0))) 'NO)\n    (error \"Test 7 failed: One point should not form a convex polygon\"))\n  (unless (equal? (is-convex-polygon '()) 'NO)\n    (error \"Test 8 failed: Empty list should not form a convex polygon\")))\n\n(test-convex-polygon)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for hash tables and iteration\n(require racket/hash)\n\n; least-time-in-office calculates the employee(s) with the least total time spent in the office.\n; n: number of employees\n; d: number of days of records\n; records: list of strings, each string is in the format \"emp_id entry_time exit_time\"\n; Returns a list of employee IDs with the least total time in minutes.\n(define (least-time-in-office n d records)\n  (define total-times (make-hash))\n  \n  ; Process each record to calculate total time for each employee\n  (for ([record records])\n    (match-let ([(list emp-id entry exit) (string-split record)])\n      (define entry-hours (string->number (substring entry 0 2)))\n      (define entry-minutes (string->number (substring entry 2 4)))\n      (define exit-hours (string->number (substring exit 0 2)))\n      (define exit-minutes (string->number (substring exit 2 4)))\n      \n      (define entry-time (+ (* entry-hours 60) entry-minutes))\n      (define exit-time (+ (* exit-hours 60) exit-minutes))\n      (define time-spent (- exit-time entry-time))\n      \n      (hash-update! total-times emp-id (lambda (old) (+ old time-spent)) 0)))\n  \n  ; Find the minimum time and corresponding employees\n  (define min-time (apply min (hash-values total-times)))\n  (define smallest-time-employees\n    (for/list ([(emp-id time) (in-hash total-times)]\n               #:when (= time min-time))\n      emp-id))\n  \n  smallest-time-employees)", "test_cases": "", "test_case_results": "'(\"emp2\")", "task_id": 8885, "assertions": "#lang racket\n\n(require racket/hash)\n\n(define (test-least-time-in-office)\n  (define test-n 3)\n  (define test-d 4)\n  (define test-records\n    '(\"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"))\n  \n  (unless (equal? (least-time-in-office test-n test-d test-records) '(\"emp2\"))\n    (error \"Test failed: Expected output was not '(\\\"emp2\\\")\")))\n\n(test-least-time-in-office)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for hash tables and iteration\n(require racket/hash)\n\n; least-time-in-office calculates the employee(s) with the least total time spent in the office.\n; n: number of employees\n; d: number of days of records\n; records: list of strings, each string is in the format \"emp_id entry_time exit_time\"\n; Returns a list of employee IDs with the least total time in minutes.\n(define (least-time-in-office n d records)\n  (define total-times (make-hash))\n  \n  ; Process each record to calculate total time for each employee\n  (for ([record records])\n    (match-let ([(list emp-id entry exit) (string-split record)])\n      (define entry-hours (string->number (substring entry 0 2)))\n      (define entry-minutes (string->number (substring entry 2 4)))\n      (define exit-hours (string->number (substring exit 0 2)))\n      (define exit-minutes (string->number (substring exit 2 4)))\n      \n      (define entry-time (+ (* entry-hours 60) entry-minutes))\n      (define exit-time (+ (* exit-hours 60) exit-minutes))\n      (define time-spent (- exit-time entry-time))\n      \n      (hash-update! total-times emp-id (lambda (old) (+ old time-spent)) 0)))\n  \n  ; Find the minimum time and corresponding employees\n  (define min-time (apply min (hash-values total-times)))\n  (define smallest-time-employees\n    (for/list ([(emp-id time) (in-hash total-times)]\n               #:when (= time min-time))\n      emp-id))\n  \n  smallest-time-employees)\n\n\n(require racket/hash)\n\n(define (test-least-time-in-office)\n  (define test-n 3)\n  (define test-d 4)\n  (define test-records\n    '(\"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"\n      \"emp1 0900 1700\"\n      \"emp2 1000 1500\"\n      \"emp3 1030 1800\"))\n  \n  (unless (equal? (least-time-in-office test-n test-d test-records) '(\"emp2\"))\n    (error \"Test failed: Expected output was not '(\\\"emp2\\\")\")))\n\n(test-least-time-in-office)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; parse-key-value-string parses a string formatted as \"Key1=Value1;Key2=Value2;...;KeyN=ValueN\"\n; and returns a hash table (dictionary) with the keys and values.\n; If the input string is empty, it returns an empty hash table.\n; Each pair in the string is separated by a semicolon, and each key and value are separated by an equals sign.\n(define (parse-key-value-string input-string)\n  (if (non-empty-string? input-string)\n      (let* ([pairs (string-split input-string \";\")]\n             [result (make-hash)])\n        (for ([pair pairs])\n          (let ([key-value (string-split pair \"=\")])\n            (when (and (not (empty? key-value)) \n                       (= (length key-value) 2))\n              (hash-set! result (first key-value) (second key-value)))))\n        result)\n      (make-hash)))\n\n; Helper function to check if a string is non-empty\n(define (non-empty-string? str)\n  (and (string? str) (not (string=? str \"\"))))", "test_cases": "", "test_case_results": "Input: Key1=Value1;Key2=Value2;Key3=Value3\nResult: #hash((Key2 . Value2) (Key1 . Value1) (Key3 . Value3))\nInput: Name=John;Age=30;City=New York\nResult: #hash((Age . 30) (Name . John) (City . New York))\nInput: SingleKey=SingleValue\nResult: #hash((SingleKey . SingleValue))\nInput: \nResult: #hash()\nInput: InvalidPair\nResult: #hash()\nInput: KeyOnly=\nResult: #hash()\nInput: =ValueOnly\nResult: #hash()", "task_id": 18909, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-parse-key-value-string)\n  (let ([test1 (parse-key-value-string \"Key1=Value1;Key2=Value2;Key3=Value3\")]\n        [test2 (parse-key-value-string \"Name=John;Age=30;City=New York\")]\n        [test3 (parse-key-value-string \"SingleKey=SingleValue\")]\n        [test4 (parse-key-value-string \"\")]\n        [test5 (parse-key-value-string \"InvalidPair\")]\n        [test6 (parse-key-value-string \"KeyOnly=\")]\n        [test7 (parse-key-value-string \"=ValueOnly\")])\n    \n    (unless (equal? test1 (hash \"Key1\" \"Value1\" \"Key2\" \"Value2\" \"Key3\" \"Value3\"))\n      (error \"Test 1 failed\"))\n    (unless (equal? test2 (hash \"Name\" \"John\" \"Age\" \"30\" \"City\" \"New York\"))\n      (error \"Test 2 failed\"))\n    (unless (equal? test3 (hash \"SingleKey\" \"SingleValue\"))\n      (error \"Test 3 failed\"))\n    (unless (equal? test4 (hash))\n      (error \"Test 4 failed\"))\n    (unless (equal? test5 (hash))\n      (error \"Test 5 failed\"))\n    (unless (equal? test6 (hash))\n      (error \"Test 6 failed\"))\n    (unless (equal? test7 (hash))\n      (error \"Test 7 failed\"))))\n\n(test-parse-key-value-string)", "all_code": "#lang racket\n\n\n; parse-key-value-string parses a string formatted as \"Key1=Value1;Key2=Value2;...;KeyN=ValueN\"\n; and returns a hash table (dictionary) with the keys and values.\n; If the input string is empty, it returns an empty hash table.\n; Each pair in the string is separated by a semicolon, and each key and value are separated by an equals sign.\n(define (parse-key-value-string input-string)\n  (if (non-empty-string? input-string)\n      (let* ([pairs (string-split input-string \";\")]\n             [result (make-hash)])\n        (for ([pair pairs])\n          (let ([key-value (string-split pair \"=\")])\n            (when (and (not (empty? key-value)) \n                       (= (length key-value) 2))\n              (hash-set! result (first key-value) (second key-value)))))\n        result)\n      (make-hash)))\n\n; Helper function to check if a string is non-empty\n(define (non-empty-string? str)\n  (and (string? str) (not (string=? str \"\"))))\n\n\n(require rackunit)\n\n(define (test-parse-key-value-string)\n  (let ([test1 (parse-key-value-string \"Key1=Value1;Key2=Value2;Key3=Value3\")]\n        [test2 (parse-key-value-string \"Name=John;Age=30;City=New York\")]\n        [test3 (parse-key-value-string \"SingleKey=SingleValue\")]\n        [test4 (parse-key-value-string \"\")]\n        [test5 (parse-key-value-string \"InvalidPair\")]\n        [test6 (parse-key-value-string \"KeyOnly=\")]\n        [test7 (parse-key-value-string \"=ValueOnly\")])\n    \n    (unless (equal? test1 (hash \"Key1\" \"Value1\" \"Key2\" \"Value2\" \"Key3\" \"Value3\"))\n      (error \"Test 1 failed\"))\n    (unless (equal? test2 (hash \"Name\" \"John\" \"Age\" \"30\" \"City\" \"New York\"))\n      (error \"Test 2 failed\"))\n    (unless (equal? test3 (hash \"SingleKey\" \"SingleValue\"))\n      (error \"Test 3 failed\"))\n    (unless (equal? test4 (hash))\n      (error \"Test 4 failed\"))\n    (unless (equal? test5 (hash))\n      (error \"Test 5 failed\"))\n    (unless (equal? test6 (hash))\n      (error \"Test 6 failed\"))\n    (unless (equal? test7 (hash))\n      (error \"Test 7 failed\"))))\n\n(test-parse-key-value-string)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; compute-items-packaged calculates the number of items each machine will package after time t.\n; Each machine can work for x seconds consecutively before needing to cool down for y seconds.\n; The function computes the total items packaged by each of the m machines in t seconds.\n; The result is a list where each element represents the items packaged by a machine.\n(define (compute-items-packaged x y m t)\n  (let* ([cycle-time (+ x y)]                          ; total duration of one work+rest cycle\n         [full-cycles (quotient t cycle-time)]         ; number of complete cycles in time t\n         [remaining-time (remainder t cycle-time)]     ; remaining time after complete cycles\n         [items-per-machine (* full-cycles x)])        ; items packaged in full cycles\n    ; add items packaged in the remaining time, ensuring it doesn't exceed x\n    (set! items-per-machine\n          (if (>= remaining-time x)\n              (+ items-per-machine x)\n              (+ items-per-machine remaining-time)))\n    ; return a list with m elements, each equal to items-per-machine\n    (make-list m items-per-machine)))", "test_cases": "", "test_case_results": "Input: x=5, y=2, m=3, t=10\nResult: (8 8 8)\nInput: x=3, y=1, m=2, t=7\nResult: (6 6)\nInput: x=4, y=3, m=1, t=12\nResult: (8)", "task_id": 27926, "assertions": "#lang racket\n\n(define (test-compute-items-packaged)\n  (unless (equal? (compute-items-packaged 5 2 3 10) '(8 8 8))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (compute-items-packaged 3 1 2 7) '(6 6))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (compute-items-packaged 4 3 1 12) '(8))\n    (error \"Test case 3 failed\")))\n\n(test-compute-items-packaged)", "all_code": "#lang racket\n\n\n; compute-items-packaged calculates the number of items each machine will package after time t.\n; Each machine can work for x seconds consecutively before needing to cool down for y seconds.\n; The function computes the total items packaged by each of the m machines in t seconds.\n; The result is a list where each element represents the items packaged by a machine.\n(define (compute-items-packaged x y m t)\n  (let* ([cycle-time (+ x y)]                          ; total duration of one work+rest cycle\n         [full-cycles (quotient t cycle-time)]         ; number of complete cycles in time t\n         [remaining-time (remainder t cycle-time)]     ; remaining time after complete cycles\n         [items-per-machine (* full-cycles x)])        ; items packaged in full cycles\n    ; add items packaged in the remaining time, ensuring it doesn't exceed x\n    (set! items-per-machine\n          (if (>= remaining-time x)\n              (+ items-per-machine x)\n              (+ items-per-machine remaining-time)))\n    ; return a list with m elements, each equal to items-per-machine\n    (make-list m items-per-machine)))\n\n\n(define (test-compute-items-packaged)\n  (unless (equal? (compute-items-packaged 5 2 3 10) '(8 8 8))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (compute-items-packaged 3 1 2 7) '(6 6))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (compute-items-packaged 4 3 1 12) '(8))\n    (error \"Test case 3 failed\")))\n\n(test-compute-items-packaged)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; interleave-helper is a helper function that recursively generates all possible interleavings of two words.\n; It builds the result string character by character, choosing at each step to take the next character from either word1 or word2.\n; When both words are fully consumed, the result is added to the results list.\n; w1: remaining part of word1\n; w2: remaining part of word2\n; result: the current interleaved string being built\n; idx1: current index in word1\n; idx2: current index in word2\n; results: accumulator for storing all interleaved strings\n(define (interleave-helper w1 w2 result idx1 idx2 results)\n  (cond\n    [(and (= idx1 (string-length w1)) (= idx2 (string-length w2)))\n     (cons result results)]\n    [(< idx1 (string-length w1))\n     (interleave-helper w1 w2 (string-append result (string (string-ref w1 idx1))) (+ idx1 1) idx2 results)]\n    [(< idx2 (string-length w2))\n     (interleave-helper w1 w2 (string-append result (string (string-ref w2 idx2))) idx1 (+ idx2 1) results)]\n    [else results]))\n\n; interleave generates all possible interleavings of two input words, word1 and word2.\n; The results are sorted lexicographically before returning.\n; word1: first input word\n; word2: second input word\n(define (interleave word1 word2)\n  (sort (interleave-helper word1 word2 \"\" 0 0 '()) string<?))", "test_cases": "", "test_case_results": "Input: ab and cd\nInterleavings: (abcd)\nInput: a and b\nInterleavings: (ab)\nInput:  and xyz\nInterleavings: (xyz)\nInput: hello and \nInterleavings: (hello)", "task_id": 18481, "assertions": "#lang racket\n\n(define (test-interleave)\n  (unless (equal? (interleave \"ab\" \"cd\") '(\"abcd\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (interleave \"a\" \"b\") '(\"ab\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (interleave \"\" \"xyz\") '(\"xyz\"))\n    (error \"Test 3 failed\"))\n  (unless (equal? (interleave \"hello\" \"\") '(\"hello\"))\n    (error \"Test 4 failed\")))\n\n(test-interleave)", "all_code": "#lang racket\n\n\n; interleave-helper is a helper function that recursively generates all possible interleavings of two words.\n; It builds the result string character by character, choosing at each step to take the next character from either word1 or word2.\n; When both words are fully consumed, the result is added to the results list.\n; w1: remaining part of word1\n; w2: remaining part of word2\n; result: the current interleaved string being built\n; idx1: current index in word1\n; idx2: current index in word2\n; results: accumulator for storing all interleaved strings\n(define (interleave-helper w1 w2 result idx1 idx2 results)\n  (cond\n    [(and (= idx1 (string-length w1)) (= idx2 (string-length w2)))\n     (cons result results)]\n    [(< idx1 (string-length w1))\n     (interleave-helper w1 w2 (string-append result (string (string-ref w1 idx1))) (+ idx1 1) idx2 results)]\n    [(< idx2 (string-length w2))\n     (interleave-helper w1 w2 (string-append result (string (string-ref w2 idx2))) idx1 (+ idx2 1) results)]\n    [else results]))\n\n; interleave generates all possible interleavings of two input words, word1 and word2.\n; The results are sorted lexicographically before returning.\n; word1: first input word\n; word2: second input word\n(define (interleave word1 word2)\n  (sort (interleave-helper word1 word2 \"\" 0 0 '()) string<?))\n\n\n(define (test-interleave)\n  (unless (equal? (interleave \"ab\" \"cd\") '(\"abcd\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (interleave \"a\" \"b\") '(\"ab\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (interleave \"\" \"xyz\") '(\"xyz\"))\n    (error \"Test 3 failed\"))\n  (unless (equal? (interleave \"hello\" \"\") '(\"hello\"))\n    (error \"Test 4 failed\")))\n\n(test-interleave)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; efficient-lcs calculates the length of the longest common subsequence (LCS) between two strings.\n; It uses a memory-optimized dynamic programming approach that only keeps track of the current and previous rows.\n; This reduces the space complexity from O(n*m) to O(min(n, m)), where n and m are the lengths of the input strings.\n; The function first ensures that the first string (s1) is the longer one to minimize space usage.\n(define (efficient-lcs s1 s2)\n  (let* ([s1 (if (< (string-length s1) (string-length s2)) s2 s1)]\n         [s2 (if (< (string-length s1) (string-length s2)) s1 s2)]\n         [m (string-length s1)]\n         [n (string-length s2)]\n         ; Initialize previous and current rows with zeros\n         [previous (make-vector (+ n 1) 0)]\n         [current (make-vector (+ n 1) 0)])\n    (for ([i (in-range 1 (+ m 1))])\n      (for ([j (in-range 1 (+ n 1))])\n        (if (equal? (string-ref s1 (- i 1)) (string-ref s2 (- j 1)))\n            (vector-set! current j (+ (vector-ref previous (- j 1)) 1))\n            (vector-set! current j (max (vector-ref previous j) (vector-ref current (- j 1))))))\n      ; Swap previous and current\n      (let ([temp previous])\n        (set! previous current)\n        (set! current temp)))\n    (vector-ref previous n)))", "test_cases": "", "test_case_results": "Input: ABCBDAB and BDCABA\nLCS Length: 4\nInput: ABCDGH and AEDFHR\nLCS Length: 3\nInput: AGGTAB and GXTXAYB\nLCS Length: 7\nInput: abc and def\nLCS Length: 0\nInput: a and a\nLCS Length: 1", "task_id": 18612, "assertions": "#lang racket\n\n(define (test-efficient-lcs)\n  (unless (= (efficient-lcs \"ABCBDAB\" \"BDCABA\") 4)\n    (error \"Test case 1 failed: ABCBDAB and BDCABA\"))\n  (unless (= (efficient-lcs \"ABCDGH\" \"AEDFHR\") 3)\n    (error \"Test case 2 failed: ABCDGH and AEDFHR\"))\n  (unless (= (efficient-lcs \"AGGTAB\" \"GXTXAYB\") 4)  ; Note: Original test result shows 7, but this appears incorrect\n    (error \"Test case 3 failed: AGGTAB and GXTXAYB\"))\n  (unless (= (efficient-lcs \"abc\" \"def\") 0)\n    (error \"Test case 4 failed: abc and def\"))\n  (unless (= (efficient-lcs \"a\" \"a\") 1)\n    (error \"Test case 5 failed: a and a\")))\n\n(test-efficient-lcs)", "all_code": "#lang racket\n\n\n; efficient-lcs calculates the length of the longest common subsequence (LCS) between two strings.\n; It uses a memory-optimized dynamic programming approach that only keeps track of the current and previous rows.\n; This reduces the space complexity from O(n*m) to O(min(n, m)), where n and m are the lengths of the input strings.\n; The function first ensures that the first string (s1) is the longer one to minimize space usage.\n(define (efficient-lcs s1 s2)\n  (let* ([s1 (if (< (string-length s1) (string-length s2)) s2 s1)]\n         [s2 (if (< (string-length s1) (string-length s2)) s1 s2)]\n         [m (string-length s1)]\n         [n (string-length s2)]\n         ; Initialize previous and current rows with zeros\n         [previous (make-vector (+ n 1) 0)]\n         [current (make-vector (+ n 1) 0)])\n    (for ([i (in-range 1 (+ m 1))])\n      (for ([j (in-range 1 (+ n 1))])\n        (if (equal? (string-ref s1 (- i 1)) (string-ref s2 (- j 1)))\n            (vector-set! current j (+ (vector-ref previous (- j 1)) 1))\n            (vector-set! current j (max (vector-ref previous j) (vector-ref current (- j 1))))))\n      ; Swap previous and current\n      (let ([temp previous])\n        (set! previous current)\n        (set! current temp)))\n    (vector-ref previous n)))\n\n\n(define (test-efficient-lcs)\n  (unless (= (efficient-lcs \"ABCBDAB\" \"BDCABA\") 4)\n    (error \"Test case 1 failed: ABCBDAB and BDCABA\"))\n  (unless (= (efficient-lcs \"ABCDGH\" \"AEDFHR\") 3)\n    (error \"Test case 2 failed: ABCDGH and AEDFHR\"))\n  (unless (= (efficient-lcs \"AGGTAB\" \"GXTXAYB\") 4)  ; Note: Original test result shows 7, but this appears incorrect\n    (error \"Test case 3 failed: AGGTAB and GXTXAYB\"))\n  (unless (= (efficient-lcs \"abc\" \"def\") 0)\n    (error \"Test case 4 failed: abc and def\"))\n  (unless (= (efficient-lcs \"a\" \"a\") 1)\n    (error \"Test case 5 failed: a and a\")))\n\n(test-efficient-lcs)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; can-construct determines if the target string can be constructed by concatenating elements from the word-bank.\n; It uses memoization to optimize the recursive checking process.\n; The function returns #t if the target can be constructed, otherwise #f.\n(define (can-construct target word-bank)\n  (let ([memo (make-hash)])\n    (define (can-construct-memo target)\n      (cond\n        [(hash-has-key? memo target) (hash-ref memo target)]\n        [(string=? target \"\") #t]\n        [else\n         (let loop ([words word-bank])\n           (cond\n             [(empty? words) \n              (hash-set! memo target #f)\n              #f]\n             [(string-prefix? target (first words))\n              (let ([suffix (substring target (string-length (first words)))])\n                (if (can-construct-memo suffix)\n                    (begin\n                      (hash-set! memo target #t)\n                      #t)\n                    (loop (rest words))))]\n             [else (loop (rest words))]))]))\n    (can-construct-memo target)))", "test_cases": "", "test_case_results": "Target: abcdef\nWord Bank: (ab abc cd def abcd)\nCan Construct: #t\n\nTarget: skateboard\nWord Bank: (bo rd ate t ska sk boar)\nCan Construct: #f\n\nTarget: enterapotentpot\nWord Bank: (a p ent enter ot o t)\nCan Construct: #t\n\nTarget: eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef\nWord Bank: (e ee eee eeee eeeee eeeeee)\nCan Construct: #f", "task_id": 9263, "assertions": "#lang racket\n\n(define (test-can-construct)\n  (unless (can-construct \"abcdef\" '(\"ab\" \"abc\" \"cd\" \"def\" \"abcd\"))\n    (error \"Test 1 failed\"))\n  (unless (not (can-construct \"skateboard\" '(\"bo\" \"rd\" \"ate\" \"t\" \"ska\" \"sk\" \"boar\")))\n    (error \"Test 2 failed\"))\n  (unless (can-construct \"enterapotentpot\" '(\"a\" \"p\" \"ent\" \"enter\" \"ot\" \"o\" \"t\"))\n    (error \"Test 3 failed\"))\n  (unless (not (can-construct \"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef\" '(\"e\" \"ee\" \"eee\" \"eeee\" \"eeeee\" \"eeeeee\")))\n    (error \"Test 4 failed\")))\n\n(test-can-construct)", "all_code": "#lang racket\n\n\n; can-construct determines if the target string can be constructed by concatenating elements from the word-bank.\n; It uses memoization to optimize the recursive checking process.\n; The function returns #t if the target can be constructed, otherwise #f.\n(define (can-construct target word-bank)\n  (let ([memo (make-hash)])\n    (define (can-construct-memo target)\n      (cond\n        [(hash-has-key? memo target) (hash-ref memo target)]\n        [(string=? target \"\") #t]\n        [else\n         (let loop ([words word-bank])\n           (cond\n             [(empty? words) \n              (hash-set! memo target #f)\n              #f]\n             [(string-prefix? target (first words))\n              (let ([suffix (substring target (string-length (first words)))])\n                (if (can-construct-memo suffix)\n                    (begin\n                      (hash-set! memo target #t)\n                      #t)\n                    (loop (rest words))))]\n             [else (loop (rest words))]))]))\n    (can-construct-memo target)))\n\n\n(define (test-can-construct)\n  (unless (can-construct \"abcdef\" '(\"ab\" \"abc\" \"cd\" \"def\" \"abcd\"))\n    (error \"Test 1 failed\"))\n  (unless (not (can-construct \"skateboard\" '(\"bo\" \"rd\" \"ate\" \"t\" \"ska\" \"sk\" \"boar\")))\n    (error \"Test 2 failed\"))\n  (unless (can-construct \"enterapotentpot\" '(\"a\" \"p\" \"ent\" \"enter\" \"ot\" \"o\" \"t\"))\n    (error \"Test 3 failed\"))\n  (unless (not (can-construct \"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef\" '(\"e\" \"ee\" \"eee\" \"eeee\" \"eeeee\" \"eeeeee\")))\n    (error \"Test 4 failed\")))\n\n(test-can-construct)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; compress-vector compresses a vector into a list of index-value pairs, excluding zeros.\n; The input is a list of numbers, and the output is a list of pairs (index value).\n; For example, (compress-vector '(0 1.5 0 3.0)) returns '((1 1.5) (3 3.0)).\n(define (compress-vector vector)\n  (for/list ([(value i) (in-indexed vector)]\n             #:when (not (equal? value 0.0)))\n    (list i value)))\n\n; optimized-dot-product computes the dot product of two sparse vectors represented as lists.\n; The vectors are first compressed to exclude zeros, then the dot product is computed by\n; iterating through the compressed vectors and multiplying values at matching indices.\n; For example, (optimized-dot-product '(0 1.5 0 3.0) '(1.0 0 2.0 3.0)) returns 9.0.\n(define (optimized-dot-product vector1 vector2)\n  (define compressed1 (compress-vector vector1))\n  (define compressed2 (compress-vector vector2))\n  (let loop ([i 0] [j 0] [dot-product 0.0])\n    (cond\n      [(or (>= i (length compressed1)) (>= j (length compressed2))) dot-product]\n      [else\n       (define index1 (first (list-ref compressed1 i)))\n       (define value1 (second (list-ref compressed1 i)))\n       (define index2 (first (list-ref compressed2 j)))\n       (define value2 (second (list-ref compressed2 j)))\n       (cond\n         [(= index1 index2)\n          (loop (add1 i) (add1 j) (+ dot-product (* value1 value2)))]\n         [(< index1 index2)\n          (loop (add1 i) j dot-product)]\n         [else\n          (loop i (add1 j) dot-product)])])))", "test_cases": "", "test_case_results": "Vector1: (0 1.5 0 3.0)\nVector2: (1.0 0 2.0 3.0)\nCompressed Vector1: ((0 0) (1 1.5) (2 0) (3 3.0))\nCompressed Vector2: ((0 1.0) (1 0) (2 2.0) (3 3.0))\nDot Product: 9.0\n\nVector1: (1.0 0 2.0 0)\nVector2: (0 3.0 0 4.0)\nCompressed Vector1: ((0 1.0) (1 0) (2 2.0) (3 0))\nCompressed Vector2: ((0 0) (1 3.0) (2 0) (3 4.0))\nDot Product: 0.0\n\nVector1: (0 0 0 0)\nVector2: (0 0 0 0)\nCompressed Vector1: ((0 0) (1 0) (2 0) (3 0))\nCompressed Vector2: ((0 0) (1 0) (2 0) (3 0))\nDot Product: 0.0\n\nVector1: (1.0 2.0 3.0)\nVector2: (4.0 5.0 6.0)\nCompressed Vector1: ((0 1.0) (1 2.0) (2 3.0))\nCompressed Vector2: ((0 4.0) (1 5.0) (2 6.0))\nDot Product: 32.0", "task_id": 28321, "assertions": "#lang racket\n\n(define (test-sparse-vectors)\n  (unless (equal? (compress-vector '(0 1.5 0 3.0)) '((1 1.5) (3 3.0)))\n    (error \"Test 1 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(1.0 0 2.0 0)) '((0 1.0) (2 2.0)))\n    (error \"Test 2 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(0 0 0 0)) '())\n    (error \"Test 3 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(1.0 2.0 3.0)) '((0 1.0) (1 2.0) (2 3.0)))\n    (error \"Test 4 (compress-vector) failed\"))\n  \n  (unless (equal? (optimized-dot-product '(0 1.5 0 3.0) '(1.0 0 2.0 3.0)) 9.0)\n    (error \"Test 5 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(1.0 0 2.0 0) '(0 3.0 0 4.0)) 0.0)\n    (error \"Test 6 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(0 0 0 0) '(0 0 0 0)) 0.0)\n    (error \"Test 7 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(1.0 2.0 3.0) '(4.0 5.0 6.0)) 32.0)\n    (error \"Test 8 (optimized-dot-product) failed\")))\n\n(test-sparse-vectors)", "all_code": "#lang racket\n\n\n; compress-vector compresses a vector into a list of index-value pairs, excluding zeros.\n; The input is a list of numbers, and the output is a list of pairs (index value).\n; For example, (compress-vector '(0 1.5 0 3.0)) returns '((1 1.5) (3 3.0)).\n(define (compress-vector vector)\n  (for/list ([(value i) (in-indexed vector)]\n             #:when (not (equal? value 0.0)))\n    (list i value)))\n\n; optimized-dot-product computes the dot product of two sparse vectors represented as lists.\n; The vectors are first compressed to exclude zeros, then the dot product is computed by\n; iterating through the compressed vectors and multiplying values at matching indices.\n; For example, (optimized-dot-product '(0 1.5 0 3.0) '(1.0 0 2.0 3.0)) returns 9.0.\n(define (optimized-dot-product vector1 vector2)\n  (define compressed1 (compress-vector vector1))\n  (define compressed2 (compress-vector vector2))\n  (let loop ([i 0] [j 0] [dot-product 0.0])\n    (cond\n      [(or (>= i (length compressed1)) (>= j (length compressed2))) dot-product]\n      [else\n       (define index1 (first (list-ref compressed1 i)))\n       (define value1 (second (list-ref compressed1 i)))\n       (define index2 (first (list-ref compressed2 j)))\n       (define value2 (second (list-ref compressed2 j)))\n       (cond\n         [(= index1 index2)\n          (loop (add1 i) (add1 j) (+ dot-product (* value1 value2)))]\n         [(< index1 index2)\n          (loop (add1 i) j dot-product)]\n         [else\n          (loop i (add1 j) dot-product)])])))\n\n\n(define (test-sparse-vectors)\n  (unless (equal? (compress-vector '(0 1.5 0 3.0)) '((1 1.5) (3 3.0)))\n    (error \"Test 1 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(1.0 0 2.0 0)) '((0 1.0) (2 2.0)))\n    (error \"Test 2 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(0 0 0 0)) '())\n    (error \"Test 3 (compress-vector) failed\"))\n  (unless (equal? (compress-vector '(1.0 2.0 3.0)) '((0 1.0) (1 2.0) (2 3.0)))\n    (error \"Test 4 (compress-vector) failed\"))\n  \n  (unless (equal? (optimized-dot-product '(0 1.5 0 3.0) '(1.0 0 2.0 3.0)) 9.0)\n    (error \"Test 5 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(1.0 0 2.0 0) '(0 3.0 0 4.0)) 0.0)\n    (error \"Test 6 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(0 0 0 0) '(0 0 0 0)) 0.0)\n    (error \"Test 7 (optimized-dot-product) failed\"))\n  (unless (equal? (optimized-dot-product '(1.0 2.0 3.0) '(4.0 5.0 6.0)) 32.0)\n    (error \"Test 8 (optimized-dot-product) failed\")))\n\n(test-sparse-vectors)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for date and time operations\n(require racket/date)\n\n; create-log-file-name generates a log file name based on the current date and time.\n; The log file name follows the format \"log_YYYY-MM-DD_HH-MM-SS.log\".\n; It uses the current-seconds function to get the current time and then formats it accordingly.\n(define (create-log-file-name)\n  (let* ([current-time (current-seconds)]\n         [date-time (seconds->date current-time)]\n         [year (date-year date-time)]\n         [month (date-month date-time)]\n         [day (date-day date-time)]\n         [hour (date-hour date-time)]\n         [minute (date-minute date-time)]\n         [second (date-second date-time)])\n    (format \"log_~a-~a-~a_~a-~a-~a.log\"\n            year\n            (if (< month 10) (format \"0~a\" month) month)\n            (if (< day 10) (format \"0~a\" day) day)\n            (if (< hour 10) (format \"0~a\" hour) hour)\n            (if (< minute 10) (format \"0~a\" minute) minute)\n            (if (< second 10) (format \"0~a\" second) second))))", "test_cases": "", "test_case_results": "Generated log file name: log_2025-05-24_18-07-34.log", "task_id": 28282, "assertions": "#lang racket\n\n(require racket/date)\n\n(define (test-create-log-file-name)\n  ; Since the function generates time-based output, we can't test for exact values\n  ; Instead, we'll test the format of the output string\n  (let ([log-file-name (create-log-file-name)])\n    (unless (regexp-match? #px\"^log_\\\\d{4}-\\\\d{2}-\\\\d{2}_\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.log$\" log-file-name)\n      (error \"Test failed: Output format is incorrect\"))\n    (printf \"Test passed: Output format is correct\\n\")))\n\n(test-create-log-file-name)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for date and time operations\n(require racket/date)\n\n; create-log-file-name generates a log file name based on the current date and time.\n; The log file name follows the format \"log_YYYY-MM-DD_HH-MM-SS.log\".\n; It uses the current-seconds function to get the current time and then formats it accordingly.\n(define (create-log-file-name)\n  (let* ([current-time (current-seconds)]\n         [date-time (seconds->date current-time)]\n         [year (date-year date-time)]\n         [month (date-month date-time)]\n         [day (date-day date-time)]\n         [hour (date-hour date-time)]\n         [minute (date-minute date-time)]\n         [second (date-second date-time)])\n    (format \"log_~a-~a-~a_~a-~a-~a.log\"\n            year\n            (if (< month 10) (format \"0~a\" month) month)\n            (if (< day 10) (format \"0~a\" day) day)\n            (if (< hour 10) (format \"0~a\" hour) hour)\n            (if (< minute 10) (format \"0~a\" minute) minute)\n            (if (< second 10) (format \"0~a\" second) second))))\n\n\n(require racket/date)\n\n(define (test-create-log-file-name)\n  ; Since the function generates time-based output, we can't test for exact values\n  ; Instead, we'll test the format of the output string\n  (let ([log-file-name (create-log-file-name)])\n    (unless (regexp-match? #px\"^log_\\\\d{4}-\\\\d{2}-\\\\d{2}_\\\\d{2}-\\\\d{2}-\\\\d{2}\\\\.log$\" log-file-name)\n      (error \"Test failed: Output format is incorrect\"))\n    (printf \"Test passed: Output format is correct\\n\")))\n\n(test-create-log-file-name)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; calculate-scores computes the 'can't lose' score for each player based on their spins.\n; The 'can't lose' score is the maximum between the sum of all positive spins (final_score)\n; and the sum of all spins (running_total).\n; Args:\n;   spins: A list of lists where each sublist contains a player name (string) followed by their spin results (numbers).\n; Returns:\n;   A hash table with player names as keys and their 'can't lose' scores as values.\n(define (calculate-scores spins)\n  (for/hash ([player spins])\n    (let* ([name (first player)]\n           [spins-list (rest player)]\n           [final-score (apply + (filter positive? spins-list))]\n           [running-total (apply + spins-list)]\n           [cant-lose-score (max final-score running-total)])\n      (values name cant-lose-score))))", "test_cases": "", "test_case_results": "Test Cases:\nInput: (Alice 5 -3 2 0 4)\nInput: (Bob -1 -2 -3)\nInput: (Charlie 1 2 3 4 5)\n\nResults:\nBob: 0\nCharlie: 15\nAlice: 11", "task_id": 11224, "assertions": "#lang racket\n\n(define (test-calculate-scores)\n  (let ([result (calculate-scores '((\"Alice\" 5 -3 2 0 4)\n                                   (\"Bob\" -1 -2 -3)\n                                   (\"Charlie\" 1 2 3 4 5)))])\n    (unless (equal? (hash-ref result \"Alice\") 11)\n      (error \"Test case 1 failed: Alice's score should be 11\"))\n    (unless (equal? (hash-ref result \"Bob\") 0)\n      (error \"Test case 2 failed: Bob's score should be 0\"))\n    (unless (equal? (hash-ref result \"Charlie\") 15)\n      (error \"Test case 3 failed: Charlie's score should be 15\"))))\n\n(test-calculate-scores)", "all_code": "#lang racket\n\n\n; calculate-scores computes the 'can't lose' score for each player based on their spins.\n; The 'can't lose' score is the maximum between the sum of all positive spins (final_score)\n; and the sum of all spins (running_total).\n; Args:\n;   spins: A list of lists where each sublist contains a player name (string) followed by their spin results (numbers).\n; Returns:\n;   A hash table with player names as keys and their 'can't lose' scores as values.\n(define (calculate-scores spins)\n  (for/hash ([player spins])\n    (let* ([name (first player)]\n           [spins-list (rest player)]\n           [final-score (apply + (filter positive? spins-list))]\n           [running-total (apply + spins-list)]\n           [cant-lose-score (max final-score running-total)])\n      (values name cant-lose-score))))\n\n\n(define (test-calculate-scores)\n  (let ([result (calculate-scores '((\"Alice\" 5 -3 2 0 4)\n                                   (\"Bob\" -1 -2 -3)\n                                   (\"Charlie\" 1 2 3 4 5)))])\n    (unless (equal? (hash-ref result \"Alice\") 11)\n      (error \"Test case 1 failed: Alice's score should be 11\"))\n    (unless (equal? (hash-ref result \"Bob\") 0)\n      (error \"Test case 2 failed: Bob's score should be 0\"))\n    (unless (equal? (hash-ref result \"Charlie\") 15)\n      (error \"Test case 3 failed: Charlie's score should be 15\"))))\n\n(test-calculate-scores)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; first-occurrence finds the index of the first occurrence of a value in a list.\n; If the value is not found, it returns -1.\n; This function mimics the behavior of Python's list.index method but returns -1 instead of raising an error when the value is not found.\n(define (first-occurrence lst value)\n  (let loop ([lst lst] [index 0])\n    (cond\n      [(empty? lst) -1]\n      [(equal? (first lst) value) index]\n      [else (loop (rest lst) (add1 index))])))", "test_cases": "", "test_case_results": "List: (1 2 3 4 5), Value: 3, First occurrence index: 2\nList: (1 2 3 4 5), Value: 6, First occurrence index: -1\nList: (a b c), Value: b, First occurrence index: 1\nList: (a b c), Value: d, First occurrence index: -1\nList: (1 2 3 2 1), Value: 2, First occurrence index: 1\nList: (), Value: 1, First occurrence index: -1", "task_id": 1921, "assertions": "#lang racket\n\n(define (test-first-occurrence)\n  (unless (= (first-occurrence '(1 2 3 4 5) 3) 2)\n    (error \"Test 1 failed\"))\n  (unless (= (first-occurrence '(1 2 3 4 5) 6) -1)\n    (error \"Test 2 failed\"))\n  (unless (= (first-occurrence '(\"a\" \"b\" \"c\") \"b\") 1)\n    (error \"Test 3 failed\"))\n  (unless (= (first-occurrence '(\"a\" \"b\" \"c\") \"d\") -1)\n    (error \"Test 4 failed\"))\n  (unless (= (first-occurrence '(1 2 3 2 1) 2) 1)\n    (error \"Test 5 failed\"))\n  (unless (= (first-occurrence '() 1) -1)\n    (error \"Test 6 failed\")))\n\n(test-first-occurrence)", "all_code": "#lang racket\n\n\n; first-occurrence finds the index of the first occurrence of a value in a list.\n; If the value is not found, it returns -1.\n; This function mimics the behavior of Python's list.index method but returns -1 instead of raising an error when the value is not found.\n(define (first-occurrence lst value)\n  (let loop ([lst lst] [index 0])\n    (cond\n      [(empty? lst) -1]\n      [(equal? (first lst) value) index]\n      [else (loop (rest lst) (add1 index))])))\n\n\n(define (test-first-occurrence)\n  (unless (= (first-occurrence '(1 2 3 4 5) 3) 2)\n    (error \"Test 1 failed\"))\n  (unless (= (first-occurrence '(1 2 3 4 5) 6) -1)\n    (error \"Test 2 failed\"))\n  (unless (= (first-occurrence '(\"a\" \"b\" \"c\") \"b\") 1)\n    (error \"Test 3 failed\"))\n  (unless (= (first-occurrence '(\"a\" \"b\" \"c\") \"d\") -1)\n    (error \"Test 4 failed\"))\n  (unless (= (first-occurrence '(1 2 3 2 1) 2) 1)\n    (error \"Test 5 failed\"))\n  (unless (= (first-occurrence '() 1) -1)\n    (error \"Test 6 failed\")))\n\n(test-first-occurrence)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; lexicographical-minimal-string returns the lexicographically smallest string\n; that can be obtained by repeatedly moving any character to the end of the string.\n; This is achieved by simply sorting the characters of the string in ascending order.\n(define (lexicographical-minimal-string s)\n  (list->string (sort (string->list s) char<?)))\n\n; process-cases takes a list of strings and returns a list of their lexicographically\n; minimal versions by applying lexicographical-minimal-string to each string.\n(define (process-cases cases)\n  (map lexicographical-minimal-string cases))", "test_cases": "", "test_case_results": "Testing individual strings:\nInput: bac, Output: abc\nInput: abc, Output: abc\nInput: cba, Output: abc\nInput: a, Output: a\nInput: zzz, Output: zzz\nInput: dcab, Output: abcd\n\nTesting process-cases:\nInput: (bac abc cba a zzz dcab)\nOutput: (abc abc abc a zzz abcd)", "task_id": 20408, "assertions": "#lang racket\n\n(define (test-lexicographical-minimal)\n  (unless (equal? (lexicographical-minimal-string \"bac\") \"abc\")\n    (error \"Test 1 failed: bac -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"abc\") \"abc\")\n    (error \"Test 2 failed: abc -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"cba\") \"abc\")\n    (error \"Test 3 failed: cba -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"a\") \"a\")\n    (error \"Test 4 failed: a -> a\"))\n  (unless (equal? (lexicographical-minimal-string \"zzz\") \"zzz\")\n    (error \"Test 5 failed: zzz -> zzz\"))\n  (unless (equal? (lexicographical-minimal-string \"dcab\") \"abcd\")\n    (error \"Test 6 failed: dcab -> abcd\"))\n  (unless (equal? (process-cases '(\"bac\" \"abc\" \"cba\" \"a\" \"zzz\" \"dcab\"))\n                  '(\"abc\" \"abc\" \"abc\" \"a\" \"zzz\" \"abcd\"))\n    (error \"Test 7 failed: process-cases\"))\n  (displayln \"All tests passed!\"))\n\n(test-lexicographical-minimal)", "all_code": "#lang racket\n\n\n; lexicographical-minimal-string returns the lexicographically smallest string\n; that can be obtained by repeatedly moving any character to the end of the string.\n; This is achieved by simply sorting the characters of the string in ascending order.\n(define (lexicographical-minimal-string s)\n  (list->string (sort (string->list s) char<?)))\n\n; process-cases takes a list of strings and returns a list of their lexicographically\n; minimal versions by applying lexicographical-minimal-string to each string.\n(define (process-cases cases)\n  (map lexicographical-minimal-string cases))\n\n\n(define (test-lexicographical-minimal)\n  (unless (equal? (lexicographical-minimal-string \"bac\") \"abc\")\n    (error \"Test 1 failed: bac -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"abc\") \"abc\")\n    (error \"Test 2 failed: abc -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"cba\") \"abc\")\n    (error \"Test 3 failed: cba -> abc\"))\n  (unless (equal? (lexicographical-minimal-string \"a\") \"a\")\n    (error \"Test 4 failed: a -> a\"))\n  (unless (equal? (lexicographical-minimal-string \"zzz\") \"zzz\")\n    (error \"Test 5 failed: zzz -> zzz\"))\n  (unless (equal? (lexicographical-minimal-string \"dcab\") \"abcd\")\n    (error \"Test 6 failed: dcab -> abcd\"))\n  (unless (equal? (process-cases '(\"bac\" \"abc\" \"cba\" \"a\" \"zzz\" \"dcab\"))\n                  '(\"abc\" \"abc\" \"abc\" \"a\" \"zzz\" \"abcd\"))\n    (error \"Test 7 failed: process-cases\"))\n  (displayln \"All tests passed!\"))\n\n(test-lexicographical-minimal)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for dictionary operations\n(require racket/dict)\n\n; categorize-products organizes the product-category assignments and returns a report for each category.\n; Parameters:\n;   n: Number of products (unused in this implementation, but kept for consistency with the original)\n;   c: Number of categories\n;   m: Number of assignments (unused in this implementation, but kept for consistency with the original)\n;   assignments: List of pairs (product-id, category-id)\n; Returns:\n;   A list of strings representing the category report\n(define (categorize-products n c m assignments)\n  ; Initialize a dictionary to hold category ids and their corresponding product lists\n  (define category-dict (make-hash))\n  \n  ; Populate the dictionary with given assignments\n  (for ([assignment assignments])\n    (match-define (list p k) assignment)\n    (hash-update! category-dict k (lambda (products) (cons p products)) '()))\n  \n  ; Prepare the result for each category in ascending order\n  (for/list ([i (in-range 1 (+ c 1))])\n    (if (hash-has-key? category-dict i)\n        (let ([products (sort (hash-ref category-dict i) <)])\n          (format \"Category ~a: ~a\" i (string-join (map number->string products) \" \")))\n        (format \"Category ~a:\" i))))", "test_cases": "", "test_case_results": "Input:\n  n: 5, c: 3, m: 4\n  assignments: ((1 1) (2 2) (3 1) (4 3))\nOutput:\n(Category 1: 1 3 Category 2: 2 Category 3: 4)\nInput:\n  n: 5, c: 4, m: 3\n  assignments: ((1 1) (2 1) (3 2))\nOutput:\n(Category 1: 1 2 Category 2: 3 Category 3: Category 4:)\nInput:\n  n: 3, c: 2, m: 3\n  assignments: ((1 1) (2 1) (3 1))\nOutput:\n(Category 1: 1 2 3 Category 2:)\nInput:\n  n: 0, c: 2, m: 0\n  assignments: ()\nOutput:\n(Category 1: Category 2:)", "task_id": 19212, "assertions": "#lang racket\n\n(require racket/dict)\n\n(define (test-categorize-products)\n  (unless (equal? (categorize-products 5 3 4 '((1 1) (2 2) (3 1) (4 3)))\n                  '(\"Category 1: 1 3\" \"Category 2: 2\" \"Category 3: 4\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (categorize-products 5 4 3 '((1 1) (2 1) (3 2)))\n                  '(\"Category 1: 1 2\" \"Category 2: 3\" \"Category 3:\" \"Category 4:\"))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (categorize-products 3 2 3 '((1 1) (2 1) (3 1)))\n                  '(\"Category 1: 1 2 3\" \"Category 2:\"))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (categorize-products 0 2 0 '())\n                  '(\"Category 1:\" \"Category 2:\"))\n    (error \"Test case 4 failed\")))\n\n(test-categorize-products)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for dictionary operations\n(require racket/dict)\n\n; categorize-products organizes the product-category assignments and returns a report for each category.\n; Parameters:\n;   n: Number of products (unused in this implementation, but kept for consistency with the original)\n;   c: Number of categories\n;   m: Number of assignments (unused in this implementation, but kept for consistency with the original)\n;   assignments: List of pairs (product-id, category-id)\n; Returns:\n;   A list of strings representing the category report\n(define (categorize-products n c m assignments)\n  ; Initialize a dictionary to hold category ids and their corresponding product lists\n  (define category-dict (make-hash))\n  \n  ; Populate the dictionary with given assignments\n  (for ([assignment assignments])\n    (match-define (list p k) assignment)\n    (hash-update! category-dict k (lambda (products) (cons p products)) '()))\n  \n  ; Prepare the result for each category in ascending order\n  (for/list ([i (in-range 1 (+ c 1))])\n    (if (hash-has-key? category-dict i)\n        (let ([products (sort (hash-ref category-dict i) <)])\n          (format \"Category ~a: ~a\" i (string-join (map number->string products) \" \")))\n        (format \"Category ~a:\" i))))\n\n\n(require racket/dict)\n\n(define (test-categorize-products)\n  (unless (equal? (categorize-products 5 3 4 '((1 1) (2 2) (3 1) (4 3)))\n                  '(\"Category 1: 1 3\" \"Category 2: 2\" \"Category 3: 4\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (categorize-products 5 4 3 '((1 1) (2 1) (3 2)))\n                  '(\"Category 1: 1 2\" \"Category 2: 3\" \"Category 3:\" \"Category 4:\"))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (categorize-products 3 2 3 '((1 1) (2 1) (3 1)))\n                  '(\"Category 1: 1 2 3\" \"Category 2:\"))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (categorize-products 0 2 0 '())\n                  '(\"Category 1:\" \"Category 2:\"))\n    (error \"Test case 4 failed\")))\n\n(test-categorize-products)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; library-insertion-sort implements the insertion sort algorithm on a list of book IDs.\n; It sorts the list in ascending order and counts the number of comparisons made during the sorting process.\n; If track-simulation? is #t, it prints the state of the list after each iteration.\n; Returns the sorted list and the total number of comparisons.\n(define (library-insertion-sort book-ids [track-simulation? #f] [comparisons 0])\n  (for ([i (in-range 1 (length book-ids))])\n    (define key (list-ref book-ids i))\n    (define j (sub1 i))\n    (define (inner-loop j comparisons)\n      (cond\n        [(and (>= j 0) (> (list-ref book-ids j) key))\n         (set! book-ids (list-set book-ids (add1 j) (list-ref book-ids j)))\n         (inner-loop (sub1 j) (add1 comparisons))]\n        [else\n         (values j (if (>= j 0) (add1 comparisons) comparisons))]))\n    (define-values (new-j new-comparisons) (inner-loop j comparisons))\n    (set! comparisons new-comparisons)\n    (set! book-ids (list-set book-ids (add1 new-j) key))\n    (when track-simulation?\n      (printf \"iteration ~a : ~a\\n\" i (string-join (map number->string book-ids) \" \"))))\n  (values book-ids comparisons))", "test_cases": "", "test_case_results": "Input: (5 3 8 6 2 7 1 4)\nSorted: (1 2 3 4 5 6 7 8)\nComparisons: 21\nInput: (1 2 3 4 5 6 7 8)\nSorted: (1 2 3 4 5 6 7 8)\nComparisons: 7\nInput: (8 7 6 5 4 3 2 1)\nSorted: (1 2 3 4 5 6 7 8)\nComparisons: 28\nInput: ()\nSorted: ()\nComparisons: 0", "task_id": 6780, "assertions": "#lang racket\n\n(define (test-library-insertion-sort)\n  (let-values ([(sorted1 comparisons1) (library-insertion-sort '(5 3 8 6 2 7 1 4))])\n    (unless (equal? sorted1 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 1 failed: incorrect sorting\"))\n    (unless (= comparisons1 21)\n      (error \"Test case 1 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted2 comparisons2) (library-insertion-sort '(1 2 3 4 5 6 7 8))])\n    (unless (equal? sorted2 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 2 failed: incorrect sorting\"))\n    (unless (= comparisons2 7)\n      (error \"Test case 2 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted3 comparisons3) (library-insertion-sort '(8 7 6 5 4 3 2 1))])\n    (unless (equal? sorted3 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 3 failed: incorrect sorting\"))\n    (unless (= comparisons3 28)\n      (error \"Test case 3 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted4 comparisons4) (library-insertion-sort '())])\n    (unless (equal? sorted4 '())\n      (error \"Test case 4 failed: incorrect sorting\"))\n    (unless (= comparisons4 0)\n      (error \"Test case 4 failed: incorrect comparison count\"))))\n\n(test-library-insertion-sort)", "all_code": "#lang racket\n\n\n; library-insertion-sort implements the insertion sort algorithm on a list of book IDs.\n; It sorts the list in ascending order and counts the number of comparisons made during the sorting process.\n; If track-simulation? is #t, it prints the state of the list after each iteration.\n; Returns the sorted list and the total number of comparisons.\n(define (library-insertion-sort book-ids [track-simulation? #f] [comparisons 0])\n  (for ([i (in-range 1 (length book-ids))])\n    (define key (list-ref book-ids i))\n    (define j (sub1 i))\n    (define (inner-loop j comparisons)\n      (cond\n        [(and (>= j 0) (> (list-ref book-ids j) key))\n         (set! book-ids (list-set book-ids (add1 j) (list-ref book-ids j)))\n         (inner-loop (sub1 j) (add1 comparisons))]\n        [else\n         (values j (if (>= j 0) (add1 comparisons) comparisons))]))\n    (define-values (new-j new-comparisons) (inner-loop j comparisons))\n    (set! comparisons new-comparisons)\n    (set! book-ids (list-set book-ids (add1 new-j) key))\n    (when track-simulation?\n      (printf \"iteration ~a : ~a\\n\" i (string-join (map number->string book-ids) \" \"))))\n  (values book-ids comparisons))\n\n\n(define (test-library-insertion-sort)\n  (let-values ([(sorted1 comparisons1) (library-insertion-sort '(5 3 8 6 2 7 1 4))])\n    (unless (equal? sorted1 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 1 failed: incorrect sorting\"))\n    (unless (= comparisons1 21)\n      (error \"Test case 1 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted2 comparisons2) (library-insertion-sort '(1 2 3 4 5 6 7 8))])\n    (unless (equal? sorted2 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 2 failed: incorrect sorting\"))\n    (unless (= comparisons2 7)\n      (error \"Test case 2 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted3 comparisons3) (library-insertion-sort '(8 7 6 5 4 3 2 1))])\n    (unless (equal? sorted3 '(1 2 3 4 5 6 7 8))\n      (error \"Test case 3 failed: incorrect sorting\"))\n    (unless (= comparisons3 28)\n      (error \"Test case 3 failed: incorrect comparison count\")))\n  \n  (let-values ([(sorted4 comparisons4) (library-insertion-sort '())])\n    (unless (equal? sorted4 '())\n      (error \"Test case 4 failed: incorrect sorting\"))\n    (unless (= comparisons4 0)\n      (error \"Test case 4 failed: incorrect comparison count\"))))\n\n(test-library-insertion-sort)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-jumps-on-circular-track calculates the minimum number of jumps required for a frog to reach from point a to point b on a circular track.\n; The function calculates both clockwise and counter-clockwise distances between points a and b on a circular track with n points.\n; The result is the minimum of these two distances.\n; Parameters:\n;   n: Number of points on the circular track.\n;   a: Starting point on the track.\n;   b: Ending point on the track.\n; Returns:\n;   The minimum number of jumps required.\n(define (min-jumps-on-circular-track n a b)\n  (let ([clockwise-distance (modulo (- b a) n)]\n        [counter-clockwise-distance (modulo (- a b) n)])\n    (min clockwise-distance counter-clockwise-distance)))", "test_cases": "", "test_case_results": "Input: n=10, a=2, b=5\nResult: 3\nInput: n=8, a=1, b=7\nResult: 2\nInput: n=5, a=0, b=4\nResult: 1\nInput: n=12, a=11, b=0\nResult: 1", "task_id": 9615, "assertions": "#lang racket\n\n(define (test-min-jumps)\n  (unless (= (min-jumps-on-circular-track 10 2 5) 3)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-jumps-on-circular-track 8 1 7) 2)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-jumps-on-circular-track 5 0 4) 1)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-jumps-on-circular-track 12 11 0) 1)\n    (error \"Test case 4 failed\")))\n\n(test-min-jumps)", "all_code": "#lang racket\n\n\n; min-jumps-on-circular-track calculates the minimum number of jumps required for a frog to reach from point a to point b on a circular track.\n; The function calculates both clockwise and counter-clockwise distances between points a and b on a circular track with n points.\n; The result is the minimum of these two distances.\n; Parameters:\n;   n: Number of points on the circular track.\n;   a: Starting point on the track.\n;   b: Ending point on the track.\n; Returns:\n;   The minimum number of jumps required.\n(define (min-jumps-on-circular-track n a b)\n  (let ([clockwise-distance (modulo (- b a) n)]\n        [counter-clockwise-distance (modulo (- a b) n)])\n    (min clockwise-distance counter-clockwise-distance)))\n\n\n(define (test-min-jumps)\n  (unless (= (min-jumps-on-circular-track 10 2 5) 3)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-jumps-on-circular-track 8 1 7) 2)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-jumps-on-circular-track 5 0 4) 1)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-jumps-on-circular-track 12 11 0) 1)\n    (error \"Test case 4 failed\")))\n\n(test-min-jumps)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; are-collinear? determines if three given points (x1, y1), (x2, y2), (x3, y3) are collinear.\n; Collinear points lie on the same line if the area of the triangle formed by the points is zero.\n; The area of the triangle is calculated as:\n; 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n; If this value is zero, the points are collinear.\n(define (are-collinear? x1 y1 x2 y2 x3 y3)\n  (let ([area-twice (+ (* x1 (- y2 y3)) (* x2 (- y3 y1)) (* x3 (- y1 y2)))])\n    (if (zero? area-twice) \"Yes\" \"No\")))", "test_cases": "", "test_case_results": "Points: (0, 0), (1, 1), (2, 2)\nCollinear? Yes\nPoints: (0, 0), (1, 1), (2, 3)\nCollinear? No\nPoints: (1, 1), (2, 2), (3, 3)\nCollinear? Yes\nPoints: (1, 2), (3, 4), (5, 6)\nCollinear? Yes\nPoints: (1, 2), (3, 4), (5, 7)\nCollinear? No", "task_id": 12349, "assertions": "#lang racket\n\n(define (test-collinear)\n  (unless (equal? (are-collinear? 0 0 1 1 2 2) \"Yes\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (are-collinear? 0 0 1 1 2 3) \"No\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (are-collinear? 1 1 2 2 3 3) \"Yes\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (are-collinear? 1 2 3 4 5 6) \"Yes\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (are-collinear? 1 2 3 4 5 7) \"No\")\n    (error \"Test 5 failed\")))\n\n(test-collinear)", "all_code": "#lang racket\n\n\n; are-collinear? determines if three given points (x1, y1), (x2, y2), (x3, y3) are collinear.\n; Collinear points lie on the same line if the area of the triangle formed by the points is zero.\n; The area of the triangle is calculated as:\n; 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))\n; If this value is zero, the points are collinear.\n(define (are-collinear? x1 y1 x2 y2 x3 y3)\n  (let ([area-twice (+ (* x1 (- y2 y3)) (* x2 (- y3 y1)) (* x3 (- y1 y2)))])\n    (if (zero? area-twice) \"Yes\" \"No\")))\n\n\n(define (test-collinear)\n  (unless (equal? (are-collinear? 0 0 1 1 2 2) \"Yes\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (are-collinear? 0 0 1 1 2 3) \"No\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (are-collinear? 1 1 2 2 3 3) \"Yes\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (are-collinear? 1 2 3 4 5 6) \"Yes\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (are-collinear? 1 2 3 4 5 7) \"No\")\n    (error \"Test 5 failed\")))\n\n(test-collinear)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; calculate-fare computes the total fare for a trip based on distance, time, start and end zones,\n; base fare per kilometer, and surge multiplier. If there's a flat rate fare for the given zones,\n; it returns that; otherwise, it calculates the standard fare and applies surge pricing during peak hours.\n; Peak hours are defined as 18:00 to 21:00.\n; Parameters:\n; d: distance in kilometers (number)\n; t: time in \"HH:MM\" format (string)\n; s: start zone (string)\n; e: end zone (string)\n; zones: hash table mapping (start zone, end zone) pairs to flat rate fares\n; b: base fare per kilometer (number)\n; m: surge multiplier (number)\n; Returns: total fare rounded to two decimal places (number)\n(define (calculate-fare d t s e zones b m)\n  (cond\n    [(hash-has-key? zones (cons s e)) (round-to (hash-ref zones (cons s e)) 2)]\n    [else\n     (let* ([standard-fare (* d b)]\n            [hour (string->number (car (string-split t \":\")))])\n       (round-to (if (and (>= hour 18) (< hour 21))\n                     (* standard-fare m)\n                     standard-fare)\n                 2))]))\n\n; Helper function to round a number to a specified number of decimal places\n(define (round-to num places)\n  (let ([mult (expt 10 places)])\n    (/ (round (* num mult)) mult)))", "test_cases": "", "test_case_results": "Input: (5 12:00 A B #hash(((A . B) . 10.5) ((C . D) . 15.75)) 2 1.5)\nResult: 10.5\nInput: (10 10:00 X Y #hash(((A . B) . 10.5) ((C . D) . 15.75)) 2 1.5)\nResult: 20\nInput: (10 19:00 X Y #hash(((A . B) . 10.5) ((C . D) . 15.75)) 2 1.5)\nResult: 30.0\nInput: (8 14:30 C D #hash(((A . B) . 10.5) ((C . D) . 15.75)) 2 1.5)\nResult: 15.75", "task_id": 4862, "assertions": "#lang racket\n\n(define (test-calculate-fare)\n  (define test-zones\n    (hash\n     (cons \"A\" \"B\") 10.50\n     (cons \"C\" \"D\") 15.75))\n  \n  (unless (equal? (calculate-fare 5 \"12:00\" \"A\" \"B\" test-zones 2 1.5) 10.5)\n    (error \"Test 1 failed\"))\n  (unless (equal? (calculate-fare 10 \"10:00\" \"X\" \"Y\" test-zones 2 1.5) 20)\n    (error \"Test 2 failed\"))\n  (unless (equal? (calculate-fare 10 \"19:00\" \"X\" \"Y\" test-zones 2 1.5) 30.0)\n    (error \"Test 3 failed\"))\n  (unless (equal? (calculate-fare 8 \"14:30\" \"C\" \"D\" test-zones 2 1.5) 15.75)\n    (error \"Test 4 failed\")))\n\n(test-calculate-fare)", "all_code": "#lang racket\n\n\n; calculate-fare computes the total fare for a trip based on distance, time, start and end zones,\n; base fare per kilometer, and surge multiplier. If there's a flat rate fare for the given zones,\n; it returns that; otherwise, it calculates the standard fare and applies surge pricing during peak hours.\n; Peak hours are defined as 18:00 to 21:00.\n; Parameters:\n; d: distance in kilometers (number)\n; t: time in \"HH:MM\" format (string)\n; s: start zone (string)\n; e: end zone (string)\n; zones: hash table mapping (start zone, end zone) pairs to flat rate fares\n; b: base fare per kilometer (number)\n; m: surge multiplier (number)\n; Returns: total fare rounded to two decimal places (number)\n(define (calculate-fare d t s e zones b m)\n  (cond\n    [(hash-has-key? zones (cons s e)) (round-to (hash-ref zones (cons s e)) 2)]\n    [else\n     (let* ([standard-fare (* d b)]\n            [hour (string->number (car (string-split t \":\")))])\n       (round-to (if (and (>= hour 18) (< hour 21))\n                     (* standard-fare m)\n                     standard-fare)\n                 2))]))\n\n; Helper function to round a number to a specified number of decimal places\n(define (round-to num places)\n  (let ([mult (expt 10 places)])\n    (/ (round (* num mult)) mult)))\n\n\n(define (test-calculate-fare)\n  (define test-zones\n    (hash\n     (cons \"A\" \"B\") 10.50\n     (cons \"C\" \"D\") 15.75))\n  \n  (unless (equal? (calculate-fare 5 \"12:00\" \"A\" \"B\" test-zones 2 1.5) 10.5)\n    (error \"Test 1 failed\"))\n  (unless (equal? (calculate-fare 10 \"10:00\" \"X\" \"Y\" test-zones 2 1.5) 20)\n    (error \"Test 2 failed\"))\n  (unless (equal? (calculate-fare 10 \"19:00\" \"X\" \"Y\" test-zones 2 1.5) 30.0)\n    (error \"Test 3 failed\"))\n  (unless (equal? (calculate-fare 8 \"14:30\" \"C\" \"D\" test-zones 2 1.5) 15.75)\n    (error \"Test 4 failed\")))\n\n(test-calculate-fare)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; total-manhattan-distance calculates the total Manhattan distance the robots need to travel to complete all tasks.\n; Each task is represented as a list (r1 c1 r2 c2), where (r1, c1) is the starting position and (r2, c2) is the destination.\n; The Manhattan distance for a single task is calculated as |r1 - r2| + |c1 - c2|.\n; The function sums the Manhattan distances for all tasks in the input list.\n(define (total-manhattan-distance tasks)\n  (for/sum ([task tasks])\n    (match task\n      [(list r1 c1 r2 c2) (+ (abs (- r1 r2)) (abs (- c1 c2)))])))", "test_cases": "", "test_case_results": "Test Case 1:\nInput Tasks: ((1 2 3 4) (5 6 7 8))\nTotal Manhattan Distance: 8\n\nTest Case 2:\nInput Tasks: ((0 0 0 0))\nTotal Manhattan Distance: 0\n\nTest Case 3:\nInput Tasks: ((1 1 2 2) (2 2 3 3) (3 3 4 4))\nTotal Manhattan Distance: 6", "task_id": 10052, "assertions": "#lang racket\n\n(define (test-total-manhattan-distance)\n  (unless (= (total-manhattan-distance '((1 2 3 4) (5 6 7 8))) 8)\n    (error \"Test Case 1 failed\"))\n  (unless (= (total-manhattan-distance '((0 0 0 0))) 0)\n    (error \"Test Case 2 failed\"))\n  (unless (= (total-manhattan-distance '((1 1 2 2) (2 2 3 3) (3 3 4 4))) 6)\n    (error \"Test Case 3 failed\")))\n\n(test-total-manhattan-distance)", "all_code": "#lang racket\n\n\n; total-manhattan-distance calculates the total Manhattan distance the robots need to travel to complete all tasks.\n; Each task is represented as a list (r1 c1 r2 c2), where (r1, c1) is the starting position and (r2, c2) is the destination.\n; The Manhattan distance for a single task is calculated as |r1 - r2| + |c1 - c2|.\n; The function sums the Manhattan distances for all tasks in the input list.\n(define (total-manhattan-distance tasks)\n  (for/sum ([task tasks])\n    (match task\n      [(list r1 c1 r2 c2) (+ (abs (- r1 r2)) (abs (- c1 c2)))])))\n\n\n(define (test-total-manhattan-distance)\n  (unless (= (total-manhattan-distance '((1 2 3 4) (5 6 7 8))) 8)\n    (error \"Test Case 1 failed\"))\n  (unless (= (total-manhattan-distance '((0 0 0 0))) 0)\n    (error \"Test Case 2 failed\"))\n  (unless (= (total-manhattan-distance '((1 1 2 2) (2 2 3 3) (3 3 4 4))) 6)\n    (error \"Test Case 3 failed\")))\n\n(test-total-manhattan-distance)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; propagate modifies the given list of integers by propagating higher values to adjacent smaller values.\n; The propagation continues until no more changes can be made in a full pass through the list.\n; The function returns the modified list after propagation is complete.\n; If the input list is empty or has only one element, it is returned unchanged.\n(define (propagate arr)\n  (if (or (empty? arr) (empty? (rest arr)))\n      arr\n      (let loop ([lst arr] [changed? #t])\n        (if (not changed?)\n            lst\n            (let-values ([(new-lst new-changed?) \n                          (for/fold ([current-lst lst] [current-changed? #f])\n                                    ([i (length lst)])\n                            (let ([val (list-ref current-lst i)])\n                              (let ([left (if (> i 0) (list-ref current-lst (- i 1)) -inf.0)]\n                                    [right (if (< i (- (length lst) 1)) (list-ref current-lst (+ i 1)) -inf.0)])\n                                (cond\n                                  [(and (> i 0) (< left val))\n                                   (values (list-set current-lst (- i 1) val) #t)]\n                                  [(and (< i (- (length lst) 1)) (< right val))\n                                   (values (list-set current-lst (+ i 1) val) #t)]\n                                  [else (values current-lst current-changed?)]))))])\n              (loop new-lst new-changed?))))))", "test_cases": "", "test_case_results": "Input: (1 2 3 4 5)\nResult: (5 5 5 5 5)\nInput: (5 4 3 2 1)\nResult: (5 5 5 5 5)\nInput: (1 5 2 4 3)\nResult: (5 5 5 5 5)\nInput: (1)\nResult: (1)\nInput: ()\nResult: ()", "task_id": 5069, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-propagate)\n  (unless (equal? (propagate '(1 2 3 4 5)) '(5 5 5 5 5))\n    (error \"Test 1 failed\"))\n  (unless (equal? (propagate '(5 4 3 2 1)) '(5 5 5 5 5))\n    (error \"Test 2 failed\"))\n  (unless (equal? (propagate '(1 5 2 4 3)) '(5 5 5 5 5))\n    (error \"Test 3 failed\"))\n  (unless (equal? (propagate '(1)) '(1))\n    (error \"Test 4 failed\"))\n  (unless (equal? (propagate '()) '())\n    (error \"Test 5 failed\")))\n\n(test-propagate)", "all_code": "#lang racket\n\n\n; propagate modifies the given list of integers by propagating higher values to adjacent smaller values.\n; The propagation continues until no more changes can be made in a full pass through the list.\n; The function returns the modified list after propagation is complete.\n; If the input list is empty or has only one element, it is returned unchanged.\n(define (propagate arr)\n  (if (or (empty? arr) (empty? (rest arr)))\n      arr\n      (let loop ([lst arr] [changed? #t])\n        (if (not changed?)\n            lst\n            (let-values ([(new-lst new-changed?) \n                          (for/fold ([current-lst lst] [current-changed? #f])\n                                    ([i (length lst)])\n                            (let ([val (list-ref current-lst i)])\n                              (let ([left (if (> i 0) (list-ref current-lst (- i 1)) -inf.0)]\n                                    [right (if (< i (- (length lst) 1)) (list-ref current-lst (+ i 1)) -inf.0)])\n                                (cond\n                                  [(and (> i 0) (< left val))\n                                   (values (list-set current-lst (- i 1) val) #t)]\n                                  [(and (< i (- (length lst) 1)) (< right val))\n                                   (values (list-set current-lst (+ i 1) val) #t)]\n                                  [else (values current-lst current-changed?)]))))])\n              (loop new-lst new-changed?))))))\n\n\n(require rackunit)\n\n(define (test-propagate)\n  (unless (equal? (propagate '(1 2 3 4 5)) '(5 5 5 5 5))\n    (error \"Test 1 failed\"))\n  (unless (equal? (propagate '(5 4 3 2 1)) '(5 5 5 5 5))\n    (error \"Test 2 failed\"))\n  (unless (equal? (propagate '(1 5 2 4 3)) '(5 5 5 5 5))\n    (error \"Test 3 failed\"))\n  (unless (equal? (propagate '(1)) '(1))\n    (error \"Test 4 failed\"))\n  (unless (equal? (propagate '()) '())\n    (error \"Test 5 failed\")))\n\n(test-propagate)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; is-substring-of checks if string1 is a substring of string2.\n; It returns #t if string1 is found within string2, otherwise #f.\n(define (is-substring-of string1 string2)\n  (regexp-match? (regexp (regexp-quote string1)) string2))", "test_cases": "", "test_case_results": "Input: abc, abcdef\nResult: #t\nInput: xyz, abcdef\nResult: #f\nInput: , abcdef\nResult: #t\nInput: abc, \nResult: #f", "task_id": 17764, "assertions": "#lang racket\n\n(define (test-substring)\n  (unless (equal? (is-substring-of \"abc\" \"abcdef\") #t)\n    (error \"Test 1 failed: (is-substring-of \\\"abc\\\" \\\"abcdef\\\") should be #t\"))\n  (unless (equal? (is-substring-of \"xyz\" \"abcdef\") #f)\n    (error \"Test 2 failed: (is-substring-of \\\"xyz\\\" \\\"abcdef\\\") should be #f\"))\n  (unless (equal? (is-substring-of \"\" \"abcdef\") #t)\n    (error \"Test 3 failed: (is-substring-of \\\"\\\" \\\"abcdef\\\") should be #t\"))\n  (unless (equal? (is-substring-of \"abc\" \"\") #f)\n    (error \"Test 4 failed: (is-substring-of \\\"abc\\\" \\\"\\\") should be #f\")))\n\n(test-substring)", "all_code": "#lang racket\n\n\n; is-substring-of checks if string1 is a substring of string2.\n; It returns #t if string1 is found within string2, otherwise #f.\n(define (is-substring-of string1 string2)\n  (regexp-match? (regexp (regexp-quote string1)) string2))\n\n\n(define (test-substring)\n  (unless (equal? (is-substring-of \"abc\" \"abcdef\") #t)\n    (error \"Test 1 failed: (is-substring-of \\\"abc\\\" \\\"abcdef\\\") should be #t\"))\n  (unless (equal? (is-substring-of \"xyz\" \"abcdef\") #f)\n    (error \"Test 2 failed: (is-substring-of \\\"xyz\\\" \\\"abcdef\\\") should be #f\"))\n  (unless (equal? (is-substring-of \"\" \"abcdef\") #t)\n    (error \"Test 3 failed: (is-substring-of \\\"\\\" \\\"abcdef\\\") should be #t\"))\n  (unless (equal? (is-substring-of \"abc\" \"\") #f)\n    (error \"Test 4 failed: (is-substring-of \\\"abc\\\" \\\"\\\") should be #f\")))\n\n(test-substring)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; minimum-total-amount calculates the minimum total amount to be paid after applying discounts.\n; The function sorts the prices in descending order and applies the discount to the highest prices first.\n; n : integer : number of items\n; m : integer : maximum number of coupons\n; d : integer : discount percentage\n; prices : list : list of item prices\n; return : integer : minimum total amount to be paid\n(define (minimum-total-amount n m d prices)\n  (let* ([sorted-prices (sort prices >)] ; Sort prices in descending order\n         [discounted-prices (for/list ([i (in-range (length sorted-prices))])\n                              (if (< i m)\n                                  (* (list-ref sorted-prices i) (/ (- 100 d) 100))\n                                  (list-ref sorted-prices i)))])\n    (exact-floor (apply + discounted-prices)))) ; Sum the prices and convert to integer", "test_cases": "", "test_case_results": "Input: n=5, m=2, d=20, prices=(100 200 300 400 500)\nResult: 1320\nInput: n=4, m=4, d=50, prices=(1000 1000 1000 1000)\nResult: 2000\nInput: n=3, m=1, d=10, prices=(150 100 200)\nResult: 430", "task_id": 10185, "assertions": "#lang racket\n\n(define (test-minimum-total-amount)\n  (unless (= (minimum-total-amount 5 2 20 '(100 200 300 400 500)) 1320)\n    (error \"Test case 1 failed\"))\n  (unless (= (minimum-total-amount 4 4 50 '(1000 1000 1000 1000)) 2000)\n    (error \"Test case 2 failed\"))\n  (unless (= (minimum-total-amount 3 1 10 '(150 100 200)) 430)\n    (error \"Test case 3 failed\")))\n\n(test-minimum-total-amount)", "all_code": "#lang racket\n\n\n; minimum-total-amount calculates the minimum total amount to be paid after applying discounts.\n; The function sorts the prices in descending order and applies the discount to the highest prices first.\n; n : integer : number of items\n; m : integer : maximum number of coupons\n; d : integer : discount percentage\n; prices : list : list of item prices\n; return : integer : minimum total amount to be paid\n(define (minimum-total-amount n m d prices)\n  (let* ([sorted-prices (sort prices >)] ; Sort prices in descending order\n         [discounted-prices (for/list ([i (in-range (length sorted-prices))])\n                              (if (< i m)\n                                  (* (list-ref sorted-prices i) (/ (- 100 d) 100))\n                                  (list-ref sorted-prices i)))])\n    (exact-floor (apply + discounted-prices)))) ; Sum the prices and convert to integer\n\n\n(define (test-minimum-total-amount)\n  (unless (= (minimum-total-amount 5 2 20 '(100 200 300 400 500)) 1320)\n    (error \"Test case 1 failed\"))\n  (unless (= (minimum-total-amount 4 4 50 '(1000 1000 1000 1000)) 2000)\n    (error \"Test case 2 failed\"))\n  (unless (= (minimum-total-amount 3 1 10 '(150 100 200)) 430)\n    (error \"Test case 3 failed\")))\n\n(test-minimum-total-amount)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-difficulty-score calculates the maximum difficulty score achievable given a list of difficulties and a maximum limit L.\n; It uses dynamic programming to solve the problem, similar to the 0/1 knapsack problem.\n; n: the number of difficulty items (unused in the function but kept for consistency with the original)\n; L: the maximum limit for the total difficulty\n; difficulties: a list of integers representing the difficulty of each item\n(define (max-difficulty-score n L difficulties)\n  (define dp (make-vector (+ L 1) 0))\n  (for ([difficulty difficulties])\n    (for ([j (in-range L (- difficulty 1) -1)])\n      (vector-set! dp j (max (vector-ref dp j)\n                             (+ (vector-ref dp (- j difficulty)) difficulty)))))\n  (vector-ref dp L))", "test_cases": "", "test_case_results": "Input: n=3, L=5, difficulties=(1 2 3)\nResult: 5\n\nInput: n=4, L=10, difficulties=(3 4 5 6)\nResult: 10\n\nInput: n=2, L=6, difficulties=(2 4)\nResult: 6\n\nInput: n=1, L=3, difficulties=(5)\nResult: 0\n\nInput: n=0, L=0, difficulties=()\nResult: 0", "task_id": 25918, "assertions": "#lang racket\n\n(define (test-max-difficulty-score)\n  (unless (= (max-difficulty-score 3 5 '(1 2 3)) 5)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-difficulty-score 4 10 '(3 4 5 6)) 10)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-difficulty-score 2 6 '(2 4)) 6)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-difficulty-score 1 3 '(5)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-difficulty-score 0 0 '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-max-difficulty-score)", "all_code": "#lang racket\n\n\n; max-difficulty-score calculates the maximum difficulty score achievable given a list of difficulties and a maximum limit L.\n; It uses dynamic programming to solve the problem, similar to the 0/1 knapsack problem.\n; n: the number of difficulty items (unused in the function but kept for consistency with the original)\n; L: the maximum limit for the total difficulty\n; difficulties: a list of integers representing the difficulty of each item\n(define (max-difficulty-score n L difficulties)\n  (define dp (make-vector (+ L 1) 0))\n  (for ([difficulty difficulties])\n    (for ([j (in-range L (- difficulty 1) -1)])\n      (vector-set! dp j (max (vector-ref dp j)\n                             (+ (vector-ref dp (- j difficulty)) difficulty)))))\n  (vector-ref dp L))\n\n\n(define (test-max-difficulty-score)\n  (unless (= (max-difficulty-score 3 5 '(1 2 3)) 5)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-difficulty-score 4 10 '(3 4 5 6)) 10)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-difficulty-score 2 6 '(2 4)) 6)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-difficulty-score 1 3 '(5)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-difficulty-score 0 0 '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-max-difficulty-score)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-element-with-rotation returns the maximum possible element in the array with at most one rotation.\n; Since the original function simply returns the maximum element in the array (as a rotation doesn't change the maximum element),\n; this function directly computes the maximum element in the list.\n; Parameters:\n;   n: number of elements in the array (unused in this implementation, but kept for consistency with the original function)\n;   arr: list of integers representing the array elements\n; Returns:\n;   The maximum element in the list\n(define (max-element-with-rotation n arr)\n  (apply max arr))", "test_cases": "", "test_case_results": "Input: (1 2 3)\nMax element: 3", "task_id": 11996, "assertions": "#lang racket\n\n(define (test-max-element-with-rotation)\n  (unless (= (max-element-with-rotation 3 '(1 2 3)) 3)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-element-with-rotation 4 '(4 3 2 1)) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-element-with-rotation 5 '(5 1 2 3 4)) 5)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-element-with-rotation 1 '(10)) 10)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-element-with-rotation 2 '(2 2)) 2)\n    (error \"Test case 5 failed\")))\n\n(test-max-element-with-rotation)", "all_code": "#lang racket\n\n\n; max-element-with-rotation returns the maximum possible element in the array with at most one rotation.\n; Since the original function simply returns the maximum element in the array (as a rotation doesn't change the maximum element),\n; this function directly computes the maximum element in the list.\n; Parameters:\n;   n: number of elements in the array (unused in this implementation, but kept for consistency with the original function)\n;   arr: list of integers representing the array elements\n; Returns:\n;   The maximum element in the list\n(define (max-element-with-rotation n arr)\n  (apply max arr))\n\n\n(define (test-max-element-with-rotation)\n  (unless (= (max-element-with-rotation 3 '(1 2 3)) 3)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-element-with-rotation 4 '(4 3 2 1)) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-element-with-rotation 5 '(5 1 2 3 4)) 5)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-element-with-rotation 1 '(10)) 10)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-element-with-rotation 2 '(2 2)) 2)\n    (error \"Test case 5 failed\")))\n\n(test-max-element-with-rotation)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-dessert-combination finds the maximum combination of spicy and sweet desserts.\n; It takes three arguments:\n; - n: the number of desserts\n; - desserts: a list of integers representing the dessert values\n; - dessert-types: a list of characters representing the type of each dessert ('S' for spicy, 'W' for sweet)\n; The function returns the sum of the maximum spicy and maximum sweet dessert values.\n; If there are no spicy or no sweet desserts, it returns -1.\n(define (max-dessert-combination n desserts dessert-types)\n  (let ([max-spicy -1]\n        [max-sweet -1])\n    (for ([i (in-range n)])\n      (let ([current-dessert (list-ref desserts i)]\n            [current-type (list-ref dessert-types i)])\n        (cond\n          [(equal? current-type 'S)\n           (when (> current-dessert max-spicy)\n             (set! max-spicy current-dessert))]\n          [(equal? current-type 'W)\n           (when (> current-dessert max-sweet)\n             (set! max-sweet current-dessert))])))\n    (if (or (= max-spicy -1) (= max-sweet -1))\n        -1\n        (+ max-spicy max-sweet))))", "test_cases": "", "test_case_results": "Input: n=4, desserts=(1 2 3 4), dessert-types=(S W S W)\nResult: 7\nInput: n=3, desserts=(5 6 7), dessert-types=(S S S)\nResult: -1\nInput: n=3, desserts=(8 9 10), dessert-types=(W W W)\nResult: -1\nInput: n=0, desserts=(), dessert-types=()\nResult: -1\nInput: n=2, desserts=(11 12), dessert-types=(S W)\nResult: 23", "task_id": 25624, "assertions": "#lang racket\n\n(define (test-max-dessert-combination)\n  (unless (= (max-dessert-combination 4 '(1 2 3 4) '(S W S W)) 7)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-dessert-combination 3 '(5 6 7) '(S S S)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-dessert-combination 3 '(8 9 10) '(W W W)) -1)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-dessert-combination 0 '() '()) -1)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-dessert-combination 2 '(11 12) '(S W)) 23)\n    (error \"Test case 5 failed\")))\n\n(test-max-dessert-combination)", "all_code": "#lang racket\n\n\n; max-dessert-combination finds the maximum combination of spicy and sweet desserts.\n; It takes three arguments:\n; - n: the number of desserts\n; - desserts: a list of integers representing the dessert values\n; - dessert-types: a list of characters representing the type of each dessert ('S' for spicy, 'W' for sweet)\n; The function returns the sum of the maximum spicy and maximum sweet dessert values.\n; If there are no spicy or no sweet desserts, it returns -1.\n(define (max-dessert-combination n desserts dessert-types)\n  (let ([max-spicy -1]\n        [max-sweet -1])\n    (for ([i (in-range n)])\n      (let ([current-dessert (list-ref desserts i)]\n            [current-type (list-ref dessert-types i)])\n        (cond\n          [(equal? current-type 'S)\n           (when (> current-dessert max-spicy)\n             (set! max-spicy current-dessert))]\n          [(equal? current-type 'W)\n           (when (> current-dessert max-sweet)\n             (set! max-sweet current-dessert))])))\n    (if (or (= max-spicy -1) (= max-sweet -1))\n        -1\n        (+ max-spicy max-sweet))))\n\n\n(define (test-max-dessert-combination)\n  (unless (= (max-dessert-combination 4 '(1 2 3 4) '(S W S W)) 7)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-dessert-combination 3 '(5 6 7) '(S S S)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-dessert-combination 3 '(8 9 10) '(W W W)) -1)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-dessert-combination 0 '() '()) -1)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-dessert-combination 2 '(11 12) '(S W)) 23)\n    (error \"Test case 5 failed\")))\n\n(test-max-dessert-combination)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; month-to-string converts an integer representing a month to its string equivalent.\n; If the integer is not a valid month (1-12), it returns \"Invalid month\".\n(define (month-to-string month)\n  (let ([months (list \"January\" \"February\" \"March\" \"April\" \"May\" \"June\"\n                      \"July\" \"August\" \"September\" \"October\" \"November\" \"December\")])\n    (if (and (>= month 1) (<= month 12))\n        (list-ref months (sub1 month))\n        \"Invalid month\")))", "test_cases": "", "test_case_results": "January\nFebruary\nDecember\nInvalid month\nInvalid month\nInvalid month", "task_id": 21978, "assertions": "#lang racket\n\n(define (test-month-to-string)\n  (unless (equal? (month-to-string 1) \"January\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (month-to-string 2) \"February\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (month-to-string 12) \"December\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (month-to-string 13) \"Invalid month\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (month-to-string 0) \"Invalid month\")\n    (error \"Test 5 failed\"))\n  (unless (equal? (month-to-string -1) \"Invalid month\")\n    (error \"Test 6 failed\")))\n\n(test-month-to-string)", "all_code": "#lang racket\n\n\n; month-to-string converts an integer representing a month to its string equivalent.\n; If the integer is not a valid month (1-12), it returns \"Invalid month\".\n(define (month-to-string month)\n  (let ([months (list \"January\" \"February\" \"March\" \"April\" \"May\" \"June\"\n                      \"July\" \"August\" \"September\" \"October\" \"November\" \"December\")])\n    (if (and (>= month 1) (<= month 12))\n        (list-ref months (sub1 month))\n        \"Invalid month\")))\n\n\n(define (test-month-to-string)\n  (unless (equal? (month-to-string 1) \"January\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (month-to-string 2) \"February\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (month-to-string 12) \"December\")\n    (error \"Test 3 failed\"))\n  (unless (equal? (month-to-string 13) \"Invalid month\")\n    (error \"Test 4 failed\"))\n  (unless (equal? (month-to-string 0) \"Invalid month\")\n    (error \"Test 5 failed\"))\n  (unless (equal? (month-to-string -1) \"Invalid month\")\n    (error \"Test 6 failed\")))\n\n(test-month-to-string)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-books-on-shelf determines the maximum number of books that can be placed on a shelf\n; without exceeding the given maximum height (H) and ensuring the books are sorted in\n; non-decreasing order of their heights.\n; \n; Parameters:\n;   n: Number of books (unused in the actual logic, but kept for consistency with the original function)\n;   H: Maximum allowed total height of books on the shelf\n;   heights: List of book heights\n; Returns:\n;   Maximum number of books that can be placed on the shelf\n(define (max-books-on-shelf n H heights)\n  (let* ([sorted-heights (sort heights <)]  ; Sort the book heights in non-decreasing order\n         [current-height 0]                ; Initialize current total height of books on the shelf\n         [max-books 0])                    ; Initialize count of maximum books on the shelf\n    (for ([height (in-list sorted-heights)])\n      (when (<= (+ current-height height) H)\n        (set! current-height (+ current-height height))\n        (set! max-books (add1 max-books))))\n    max-books))", "test_cases": "", "test_case_results": "Input: n=5, H=10, heights=(4 3 1 2 5)\nResult: 4\nInput: n=3, H=5, heights=(6 7 8)\nResult: 0\nInput: n=4, H=15, heights=(1 2 3 4)\nResult: 4\nInput: n=0, H=10, heights=()\nResult: 0\nInput: n=2, H=3, heights=(1 1)\nResult: 2", "task_id": 23559, "assertions": "#lang racket\n\n(define (test-max-books-on-shelf)\n  (unless (= (max-books-on-shelf 5 10 '(4 3 1 2 5)) 4)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-books-on-shelf 3 5 '(6 7 8)) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-books-on-shelf 4 15 '(1 2 3 4)) 4)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-books-on-shelf 0 10 '()) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-books-on-shelf 2 3 '(1 1)) 2)\n    (error \"Test case 5 failed\")))\n\n(test-max-books-on-shelf)", "all_code": "#lang racket\n\n\n; max-books-on-shelf determines the maximum number of books that can be placed on a shelf\n; without exceeding the given maximum height (H) and ensuring the books are sorted in\n; non-decreasing order of their heights.\n; \n; Parameters:\n;   n: Number of books (unused in the actual logic, but kept for consistency with the original function)\n;   H: Maximum allowed total height of books on the shelf\n;   heights: List of book heights\n; Returns:\n;   Maximum number of books that can be placed on the shelf\n(define (max-books-on-shelf n H heights)\n  (let* ([sorted-heights (sort heights <)]  ; Sort the book heights in non-decreasing order\n         [current-height 0]                ; Initialize current total height of books on the shelf\n         [max-books 0])                    ; Initialize count of maximum books on the shelf\n    (for ([height (in-list sorted-heights)])\n      (when (<= (+ current-height height) H)\n        (set! current-height (+ current-height height))\n        (set! max-books (add1 max-books))))\n    max-books))\n\n\n(define (test-max-books-on-shelf)\n  (unless (= (max-books-on-shelf 5 10 '(4 3 1 2 5)) 4)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-books-on-shelf 3 5 '(6 7 8)) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-books-on-shelf 4 15 '(1 2 3 4)) 4)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-books-on-shelf 0 10 '()) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-books-on-shelf 2 3 '(1 1)) 2)\n    (error \"Test case 5 failed\")))\n\n(test-max-books-on-shelf)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; count-palindromic-subsequences calculates the number of palindromic subsequences in the array [1, 2, ..., n].\n; A palindromic subsequence is a sequence that reads the same forwards and backwards.\n; For the array [1, 2, ..., n], any single element is a palindrome, and any subsequence [i, ..., i] is also a palindrome.\n; The total number of such subsequences is the sum of the first n natural numbers, which is n * (n + 1) / 2.\n(define (count-palindromic-subsequences n)\n  (quotient (* n (+ n 1)) 2))", "test_cases": "", "test_case_results": "Input: 1\n1\nInput: 2\n3\nInput: 3\n6\nInput: 4\n10\nInput: 5\n15", "task_id": 19218, "assertions": "#lang racket\n\n(define (test-palindromic-subsequences)\n  (unless (= (count-palindromic-subsequences 1) 1)\n    (error \"Test 1 failed\"))\n  (unless (= (count-palindromic-subsequences 2) 3)\n    (error \"Test 2 failed\"))\n  (unless (= (count-palindromic-subsequences 3) 6)\n    (error \"Test 3 failed\"))\n  (unless (= (count-palindromic-subsequences 4) 10)\n    (error \"Test 4 failed\"))\n  (unless (= (count-palindromic-subsequences 5) 15)\n    (error \"Test 5 failed\")))\n\n(test-palindromic-subsequences)", "all_code": "#lang racket\n\n\n; count-palindromic-subsequences calculates the number of palindromic subsequences in the array [1, 2, ..., n].\n; A palindromic subsequence is a sequence that reads the same forwards and backwards.\n; For the array [1, 2, ..., n], any single element is a palindrome, and any subsequence [i, ..., i] is also a palindrome.\n; The total number of such subsequences is the sum of the first n natural numbers, which is n * (n + 1) / 2.\n(define (count-palindromic-subsequences n)\n  (quotient (* n (+ n 1)) 2))\n\n\n(define (test-palindromic-subsequences)\n  (unless (= (count-palindromic-subsequences 1) 1)\n    (error \"Test 1 failed\"))\n  (unless (= (count-palindromic-subsequences 2) 3)\n    (error \"Test 2 failed\"))\n  (unless (= (count-palindromic-subsequences 3) 6)\n    (error \"Test 3 failed\"))\n  (unless (= (count-palindromic-subsequences 4) 10)\n    (error \"Test 4 failed\"))\n  (unless (= (count-palindromic-subsequences 5) 15)\n    (error \"Test 5 failed\")))\n\n(test-palindromic-subsequences)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; alice-wins determines if Alice can guarantee a win given the initial configurations of the stacks.\n; The function takes a list of pairs (a, b) where a and b are the number of stones in the two stacks.\n; For each pair, it checks if the sum of the stones is equal to twice the maximum of the two stacks.\n; If true, Bob wins; otherwise, Alice wins.\n; The function returns a list of strings \"Alice\" or \"Bob\" for each test case.\n(define (alice-wins cases)\n  (for/list ([case cases])\n    (let ([a (first case)]\n          [b (second case)])\n      (if (= (+ a b) (* 2 (max a b)))\n          \"Bob\"\n          \"Alice\"))))", "test_cases": "", "test_case_results": "Test Cases:\nInput: (1 1), Result: Bob\nInput: (2 1), Result: Alice\nInput: (3 6), Result: Alice\nInput: (4 4), Result: Bob\nInput: (5 10), Result: Alice\nInput: (7 3), Result: Alice", "task_id": 2944, "assertions": "#lang racket\n\n(define (test-alice-wins)\n  (unless (equal? (alice-wins '((1 1))) '(\"Bob\"))\n    (error \"Test case (1 1) failed\"))\n  (unless (equal? (alice-wins '((2 1))) '(\"Alice\"))\n    (error \"Test case (2 1) failed\"))\n  (unless (equal? (alice-wins '((3 6))) '(\"Alice\"))\n    (error \"Test case (3 6) failed\"))\n  (unless (equal? (alice-wins '((4 4))) '(\"Bob\"))\n    (error \"Test case (4 4) failed\"))\n  (unless (equal? (alice-wins '((5 10))) '(\"Alice\"))\n    (error \"Test case (5 10) failed\"))\n  (unless (equal? (alice-wins '((7 3))) '(\"Alice\"))\n    (error \"Test case (7 3) failed\")))\n\n(test-alice-wins)", "all_code": "#lang racket\n\n\n; alice-wins determines if Alice can guarantee a win given the initial configurations of the stacks.\n; The function takes a list of pairs (a, b) where a and b are the number of stones in the two stacks.\n; For each pair, it checks if the sum of the stones is equal to twice the maximum of the two stacks.\n; If true, Bob wins; otherwise, Alice wins.\n; The function returns a list of strings \"Alice\" or \"Bob\" for each test case.\n(define (alice-wins cases)\n  (for/list ([case cases])\n    (let ([a (first case)]\n          [b (second case)])\n      (if (= (+ a b) (* 2 (max a b)))\n          \"Bob\"\n          \"Alice\"))))\n\n\n(define (test-alice-wins)\n  (unless (equal? (alice-wins '((1 1))) '(\"Bob\"))\n    (error \"Test case (1 1) failed\"))\n  (unless (equal? (alice-wins '((2 1))) '(\"Alice\"))\n    (error \"Test case (2 1) failed\"))\n  (unless (equal? (alice-wins '((3 6))) '(\"Alice\"))\n    (error \"Test case (3 6) failed\"))\n  (unless (equal? (alice-wins '((4 4))) '(\"Bob\"))\n    (error \"Test case (4 4) failed\"))\n  (unless (equal? (alice-wins '((5 10))) '(\"Alice\"))\n    (error \"Test case (5 10) failed\"))\n  (unless (equal? (alice-wins '((7 3))) '(\"Alice\"))\n    (error \"Test case (7 3) failed\")))\n\n(test-alice-wins)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; create-actor-dict creates a dictionary where the keys are unique names of actors\n; and the values are lists of movies they are in.\n; \n; Parameters:\n; movies (list): A list of dictionaries, each containing a 'title' \n;                and 'cast' list of actors.\n;\n; Returns:\n; dict: A hash table with actor names as keys and list of movies as values.\n(define (create-actor-dict movies)\n  (let ([actors-dict (make-hash)])\n    (for ([movie movies])\n      (let ([title (dict-ref movie 'title)]\n            [cast (dict-ref movie 'cast)])\n        (for ([actor cast])\n          (if (hash-has-key? actors-dict actor)\n              (hash-update! actors-dict actor (lambda (movies) (cons title movies)))\n              (hash-set! actors-dict actor (list title))))))\n    actors-dict))", "test_cases": "", "test_case_results": "Input: (#hash((cast . (Actor1 Actor2)) (title . Movie1)) #hash((cast . (Actor2 Actor3)) (title . Movie2)))\nOutput: ((Actor2 Movie2 Movie1) (Actor1 Movie1) (Actor3 Movie2))\nInput: (#hash((cast . (ActorX ActorY)) (title . MovieA)) #hash((cast . (ActorX ActorZ)) (title . MovieB)) #hash((cast . (ActorY ActorZ)) (title . MovieC)))\nOutput: ((ActorX MovieB MovieA) (ActorZ MovieC MovieB) (ActorY MovieC MovieA))", "task_id": 8154, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-create-actor-dict)\n  (let ([test-case1 (list (hash 'title \"Movie1\" 'cast (list \"Actor1\" \"Actor2\"))\n                          (hash 'title \"Movie2\" 'cast (list \"Actor2\" \"Actor3\")))]\n        [test-case2 (list (hash 'title \"MovieA\" 'cast (list \"ActorX\" \"ActorY\"))\n                          (hash 'title \"MovieB\" 'cast (list \"ActorX\" \"ActorZ\"))\n                          (hash 'title \"MovieC\" 'cast (list \"ActorY\" \"ActorZ\")))])\n    \n    (let ([result1 (create-actor-dict test-case1)]\n          [result2 (create-actor-dict test-case2)])\n      \n      (unless (equal? (hash-ref result1 \"Actor1\") '(\"Movie1\"))\n        (error \"Test 1.1 failed: Actor1 movies don't match\"))\n      (unless (equal? (hash-ref result1 \"Actor2\") '(\"Movie2\" \"Movie1\"))\n        (error \"Test 1.2 failed: Actor2 movies don't match\"))\n      (unless (equal? (hash-ref result1 \"Actor3\") '(\"Movie2\"))\n        (error \"Test 1.3 failed: Actor3 movies don't match\"))\n      \n      (unless (equal? (hash-ref result2 \"ActorX\") '(\"MovieB\" \"MovieA\"))\n        (error \"Test 2.1 failed: ActorX movies don't match\"))\n      (unless (equal? (hash-ref result2 \"ActorY\") '(\"MovieC\" \"MovieA\"))\n        (error \"Test 2.2 failed: ActorY movies don't match\"))\n      (unless (equal? (hash-ref result2 \"ActorZ\") '(\"MovieC\" \"MovieB\"))\n        (error \"Test 2.3 failed: ActorZ movies don't match\")))))\n\n(test-create-actor-dict)", "all_code": "#lang racket\n\n\n; create-actor-dict creates a dictionary where the keys are unique names of actors\n; and the values are lists of movies they are in.\n; \n; Parameters:\n; movies (list): A list of dictionaries, each containing a 'title' \n;                and 'cast' list of actors.\n;\n; Returns:\n; dict: A hash table with actor names as keys and list of movies as values.\n(define (create-actor-dict movies)\n  (let ([actors-dict (make-hash)])\n    (for ([movie movies])\n      (let ([title (dict-ref movie 'title)]\n            [cast (dict-ref movie 'cast)])\n        (for ([actor cast])\n          (if (hash-has-key? actors-dict actor)\n              (hash-update! actors-dict actor (lambda (movies) (cons title movies)))\n              (hash-set! actors-dict actor (list title))))))\n    actors-dict))\n\n\n(require rackunit)\n\n(define (test-create-actor-dict)\n  (let ([test-case1 (list (hash 'title \"Movie1\" 'cast (list \"Actor1\" \"Actor2\"))\n                          (hash 'title \"Movie2\" 'cast (list \"Actor2\" \"Actor3\")))]\n        [test-case2 (list (hash 'title \"MovieA\" 'cast (list \"ActorX\" \"ActorY\"))\n                          (hash 'title \"MovieB\" 'cast (list \"ActorX\" \"ActorZ\"))\n                          (hash 'title \"MovieC\" 'cast (list \"ActorY\" \"ActorZ\")))])\n    \n    (let ([result1 (create-actor-dict test-case1)]\n          [result2 (create-actor-dict test-case2)])\n      \n      (unless (equal? (hash-ref result1 \"Actor1\") '(\"Movie1\"))\n        (error \"Test 1.1 failed: Actor1 movies don't match\"))\n      (unless (equal? (hash-ref result1 \"Actor2\") '(\"Movie2\" \"Movie1\"))\n        (error \"Test 1.2 failed: Actor2 movies don't match\"))\n      (unless (equal? (hash-ref result1 \"Actor3\") '(\"Movie2\"))\n        (error \"Test 1.3 failed: Actor3 movies don't match\"))\n      \n      (unless (equal? (hash-ref result2 \"ActorX\") '(\"MovieB\" \"MovieA\"))\n        (error \"Test 2.1 failed: ActorX movies don't match\"))\n      (unless (equal? (hash-ref result2 \"ActorY\") '(\"MovieC\" \"MovieA\"))\n        (error \"Test 2.2 failed: ActorY movies don't match\"))\n      (unless (equal? (hash-ref result2 \"ActorZ\") '(\"MovieC\" \"MovieB\"))\n        (error \"Test 2.3 failed: ActorZ movies don't match\")))))\n\n(test-create-actor-dict)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for statistics and list operations\n(require math/statistics\n         racket/list)\n\n; process-scores processes a list of scores by removing invalid scores, calculating the average,\n; finding the most frequent score, and returning the sorted list of remaining scores.\n; \n; @param scores: list of integers - list of scores\n; @param invalid-score: integer - score that should be removed from the list\n; \n; @return: (list float integer list) - average score, most frequent score, sorted remaining scores\n(define (process-scores scores invalid-score)\n  ; Step 1: Remove all occurrences of the invalid-score\n  (define filtered-scores (filter (lambda (score) (not (= score invalid-score))) scores))\n  \n  ; Step 2: Calculate the average score\n  (define avg-score (if (empty? filtered-scores)\n                        0\n                        (mean filtered-scores)))\n  \n  ; Step 3: Find the most frequent score\n  (define most-frequent-score\n    (if (empty? filtered-scores)\n        'None\n        (let* ([counts (map (lambda (x) (cons x (count (lambda (y) (= x y)) filtered-scores)))\n                            (remove-duplicates filtered-scores))]\n               [max-count (apply max (map cdr counts))])\n          (car (findf (lambda (x) (= (cdr x) max-count)) counts)))))\n  \n  ; Step 4: Return the sorted list of remaining scores\n  (define sorted-scores (sort filtered-scores <))\n  \n  (list avg-score most-frequent-score sorted-scores))", "test_cases": "", "test_case_results": "Scores: (85 90 78 90 92 85 85), Invalid Score: 78\nAverage: 527/6, Most Frequent: 85, Sorted Scores: (85 85 85 90 90 92)\n\nScores: (65 65 65 65 65), Invalid Score: 65\nAverage: 0, Most Frequent: None, Sorted Scores: ()\n\nScores: (100 95 100 95 90), Invalid Score: 90\nAverage: 195/2, Most Frequent: 100, Sorted Scores: (95 95 100 100)\n\nScores: (), Invalid Score: 100\nAverage: 0, Most Frequent: None, Sorted Scores: ()", "task_id": 12580, "assertions": "#lang racket\n\n(require math/statistics\n         racket/list)\n\n(define (test-process-scores)\n  (let ([result1 (process-scores '(85 90 78 90 92 85 85) 78)]\n        [result2 (process-scores '(65 65 65 65 65) 65)]\n        [result3 (process-scores '(100 95 100 95 90) 90)]\n        [result4 (process-scores '() 100)])\n    \n    (unless (equal? result1 (list (/ 527 6) 85 '(85 85 85 90 90 92)))\n      (error \"Test case 1 failed\"))\n    \n    (unless (equal? result2 (list 0 'None '()))\n      (error \"Test case 2 failed\"))\n    \n    (unless (equal? result3 (list (/ 195 2) 100 '(95 95 100 100)))\n      (error \"Test case 3 failed\"))\n    \n    (unless (equal? result4 (list 0 'None '()))\n      (error \"Test case 4 failed\"))))\n\n(test-process-scores)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for statistics and list operations\n(require math/statistics\n         racket/list)\n\n; process-scores processes a list of scores by removing invalid scores, calculating the average,\n; finding the most frequent score, and returning the sorted list of remaining scores.\n; \n; @param scores: list of integers - list of scores\n; @param invalid-score: integer - score that should be removed from the list\n; \n; @return: (list float integer list) - average score, most frequent score, sorted remaining scores\n(define (process-scores scores invalid-score)\n  ; Step 1: Remove all occurrences of the invalid-score\n  (define filtered-scores (filter (lambda (score) (not (= score invalid-score))) scores))\n  \n  ; Step 2: Calculate the average score\n  (define avg-score (if (empty? filtered-scores)\n                        0\n                        (mean filtered-scores)))\n  \n  ; Step 3: Find the most frequent score\n  (define most-frequent-score\n    (if (empty? filtered-scores)\n        'None\n        (let* ([counts (map (lambda (x) (cons x (count (lambda (y) (= x y)) filtered-scores)))\n                            (remove-duplicates filtered-scores))]\n               [max-count (apply max (map cdr counts))])\n          (car (findf (lambda (x) (= (cdr x) max-count)) counts)))))\n  \n  ; Step 4: Return the sorted list of remaining scores\n  (define sorted-scores (sort filtered-scores <))\n  \n  (list avg-score most-frequent-score sorted-scores))\n\n\n(require math/statistics\n         racket/list)\n\n(define (test-process-scores)\n  (let ([result1 (process-scores '(85 90 78 90 92 85 85) 78)]\n        [result2 (process-scores '(65 65 65 65 65) 65)]\n        [result3 (process-scores '(100 95 100 95 90) 90)]\n        [result4 (process-scores '() 100)])\n    \n    (unless (equal? result1 (list (/ 527 6) 85 '(85 85 85 90 90 92)))\n      (error \"Test case 1 failed\"))\n    \n    (unless (equal? result2 (list 0 'None '()))\n      (error \"Test case 2 failed\"))\n    \n    (unless (equal? result3 (list (/ 195 2) 100 '(95 95 100 100)))\n      (error \"Test case 3 failed\"))\n    \n    (unless (equal? result4 (list 0 'None '()))\n      (error \"Test case 4 failed\"))))\n\n(test-process-scores)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for combinations and sets\n(require racket/set\n         racket/list)\n\n; count-valid-teams calculates the number of valid teams of size k where all members work well together.\n; n: total number of employees\n; relations: list of pairs representing employees who work well together\n; k: size of the team to form\n(define (count-valid-teams n relations k)\n  ; Create an adjacency set for relations\n  (define adj-list (make-hash))\n  (for ([relation relations])\n    (let ([a (first relation)]\n          [b (second relation)])\n      (hash-update! adj-list a (lambda (s) (set-add s b)) (set))\n      (hash-update! adj-list b (lambda (s) (set-add s a)) (set))))\n  \n  ; is-clique checks if every pair in the team works well together\n  (define (is-clique team)\n    (for/and ([pair (in-combinations team 2)])\n      (let ([u (first pair)]\n            [v (second pair)])\n        (set-member? (hash-ref adj-list u (set)) v))))\n  \n  (if (> k n)\n      0\n      (let ([employees (range n)])\n        (for/sum ([team (in-combinations employees k)])\n          (if (is-clique team) 1 0)))))", "test_cases": "", "test_case_results": "Input: n=4, relations=((0 1) (1 2) (2 3)), k=3\nResult: 0\nInput: n=5, relations=((0 1) (1 2) (2 3) (3 4)), k=2\nResult: 4\nInput: n=3, relations=((0 1)), k=3\nResult: 0\nInput: n=4, relations=(), k=2\nResult: 0", "task_id": 3955, "assertions": "#lang racket\n\n(require racket/set\n         racket/list)\n\n(define (test-count-valid-teams)\n  (unless (= (count-valid-teams 4 '((0 1) (1 2) (2 3)) 3) 0)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-valid-teams 5 '((0 1) (1 2) (2 3) (3 4)) 2) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-valid-teams 3 '((0 1)) 3) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-valid-teams 4 '() 2) 0)\n    (error \"Test case 4 failed\")))\n\n(test-count-valid-teams)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for combinations and sets\n(require racket/set\n         racket/list)\n\n; count-valid-teams calculates the number of valid teams of size k where all members work well together.\n; n: total number of employees\n; relations: list of pairs representing employees who work well together\n; k: size of the team to form\n(define (count-valid-teams n relations k)\n  ; Create an adjacency set for relations\n  (define adj-list (make-hash))\n  (for ([relation relations])\n    (let ([a (first relation)]\n          [b (second relation)])\n      (hash-update! adj-list a (lambda (s) (set-add s b)) (set))\n      (hash-update! adj-list b (lambda (s) (set-add s a)) (set))))\n  \n  ; is-clique checks if every pair in the team works well together\n  (define (is-clique team)\n    (for/and ([pair (in-combinations team 2)])\n      (let ([u (first pair)]\n            [v (second pair)])\n        (set-member? (hash-ref adj-list u (set)) v))))\n  \n  (if (> k n)\n      0\n      (let ([employees (range n)])\n        (for/sum ([team (in-combinations employees k)])\n          (if (is-clique team) 1 0)))))\n\n\n(require racket/set\n         racket/list)\n\n(define (test-count-valid-teams)\n  (unless (= (count-valid-teams 4 '((0 1) (1 2) (2 3)) 3) 0)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-valid-teams 5 '((0 1) (1 2) (2 3) (3 4)) 2) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-valid-teams 3 '((0 1)) 3) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-valid-teams 4 '() 2) 0)\n    (error \"Test case 4 failed\")))\n\n(test-count-valid-teams)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Define a custom exception for invalid rectangle dimensions\n(define (invalid-rectangle-error? e)\n  (and (exn:fail? e)\n       (string=? (exn-message e) \"Length and width must be positive values\")))\n\n; area-of-rectangle calculates the area of a rectangle given its length and width.\n; The area is computed by manually performing multiplication and rounding to the nearest integer.\n; If either length or width is not positive, it raises an invalid-rectangle-error.\n(define (area-of-rectangle length width)\n  (if (or (<= length 0) (<= width 0))\n      (raise (make-exn:fail \"Length and width must be positive values\" (current-continuation-marks)))\n      (let ([area 0.0])\n        ; Manually perform multiplication by repeated addition\n        (for ([_ (in-range (exact-floor width))])\n          (set! area (+ area length)))\n        (let ([fractional-part (- width (exact-floor width))])\n          (for ([_ (in-range (exact-floor (* fractional-part 10)))])\n            (set! area (+ area (/ length 10)))))\n        ; Manually perform rounding\n        (let ([area-fractional (- area (exact-floor area))])\n          (if (>= area-fractional 0.5)\n              (add1 (exact-floor area))\n              (exact-floor area))))))", "test_cases": "", "test_case_results": "Input: length=4, width=5\nArea: 20\nInput: length=3.5, width=2\nArea: 7\nInput: length=2, width=3.5\nArea: 7\nInput: length=0, width=5\nException: Length and width must be positive values\nInput: length=5, width=-1\nException: Length and width must be positive values\nInput: length=3, width=0\nException: Length and width must be positive values", "task_id": 12370, "assertions": "#lang racket\n\n(define (test-area-of-rectangle)\n  ; Test cases with positive dimensions\n  (unless (= (area-of-rectangle 4 5) 20)\n    (error \"Test 1 failed: (4 5) should return 20\"))\n  (unless (= (area-of-rectangle 3.5 2) 7)\n    (error \"Test 2 failed: (3.5 2) should return 7\"))\n  (unless (= (area-of-rectangle 2 3.5) 7)\n    (error \"Test 3 failed: (2 3.5) should return 7\"))\n  \n  ; Test cases that should raise exceptions\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 0 5)\n            #f)\n    (error \"Test 4 failed: (0 5) should raise an exception\"))\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 5 -1)\n            #f)\n    (error \"Test 5 failed: (5 -1) should raise an exception\"))\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 3 0)\n            #f)\n    (error \"Test 6 failed: (3 0) should raise an exception\")))\n\n(test-area-of-rectangle)", "all_code": "#lang racket\n\n\n; Define a custom exception for invalid rectangle dimensions\n(define (invalid-rectangle-error? e)\n  (and (exn:fail? e)\n       (string=? (exn-message e) \"Length and width must be positive values\")))\n\n; area-of-rectangle calculates the area of a rectangle given its length and width.\n; The area is computed by manually performing multiplication and rounding to the nearest integer.\n; If either length or width is not positive, it raises an invalid-rectangle-error.\n(define (area-of-rectangle length width)\n  (if (or (<= length 0) (<= width 0))\n      (raise (make-exn:fail \"Length and width must be positive values\" (current-continuation-marks)))\n      (let ([area 0.0])\n        ; Manually perform multiplication by repeated addition\n        (for ([_ (in-range (exact-floor width))])\n          (set! area (+ area length)))\n        (let ([fractional-part (- width (exact-floor width))])\n          (for ([_ (in-range (exact-floor (* fractional-part 10)))])\n            (set! area (+ area (/ length 10)))))\n        ; Manually perform rounding\n        (let ([area-fractional (- area (exact-floor area))])\n          (if (>= area-fractional 0.5)\n              (add1 (exact-floor area))\n              (exact-floor area))))))\n\n\n(define (test-area-of-rectangle)\n  ; Test cases with positive dimensions\n  (unless (= (area-of-rectangle 4 5) 20)\n    (error \"Test 1 failed: (4 5) should return 20\"))\n  (unless (= (area-of-rectangle 3.5 2) 7)\n    (error \"Test 2 failed: (3.5 2) should return 7\"))\n  (unless (= (area-of-rectangle 2 3.5) 7)\n    (error \"Test 3 failed: (2 3.5) should return 7\"))\n  \n  ; Test cases that should raise exceptions\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 0 5)\n            #f)\n    (error \"Test 4 failed: (0 5) should raise an exception\"))\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 5 -1)\n            #f)\n    (error \"Test 5 failed: (5 -1) should raise an exception\"))\n  (unless (with-handlers ([invalid-rectangle-error? (lambda (e) #t)])\n            (area-of-rectangle 3 0)\n            #f)\n    (error \"Test 6 failed: (3 0) should raise an exception\")))\n\n(test-area-of-rectangle)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sum-of-cubes-of-digits calculates the sum of the cubes of each digit in a number.\n; It converts the number to a string to iterate over each digit, then converts each digit back to an integer,\n; cubes it, and sums all the cubes.\n(define (sum-of-cubes-of-digits n)\n  (apply + (map (lambda (digit) (expt (string->number (string digit)) 3)) \n                (string->list (number->string n)))))\n\n; G calculates the next term in the sequence by adding the number to the sum of the cubes of its digits.\n(define (G n)\n  (+ n (sum-of-cubes-of-digits n)))\n\n; find-kth-term computes the k-th term in the sequence starting from X.\n; It iteratively applies the function G to the current term (k-1) times.\n(define (find-kth-term X k)\n  (if (= k 1)\n      X\n      (find-kth-term (G X) (- k 1))))\n\n; solve-multiple-cases processes multiple test cases, each consisting of an initial term X and a number of steps k.\n; It returns a list of results where each result is the k-th term starting from the corresponding X.\n(define (solve-multiple-cases cases)\n  (map (lambda (case) (find-kth-term (car case) (cadr case))) cases))", "test_cases": "", "test_case_results": "(123 1) -> 123\n(123 2) -> 159\n(1 5) -> 13\n(100 3) -> 103", "task_id": 23560, "assertions": "#lang racket\n\n(define (test-sequence-functions)\n  (unless (= (find-kth-term 123 1) 123)\n    (error \"Test case (123 1) failed\"))\n  (unless (= (find-kth-term 123 2) 159)\n    (error \"Test case (123 2) failed\"))\n  (unless (= (find-kth-term 1 5) 13)\n    (error \"Test case (1 5) failed\"))\n  (unless (= (find-kth-term 100 3) 103)\n    (error \"Test case (100 3) failed\")))\n\n(test-sequence-functions)", "all_code": "#lang racket\n\n\n; sum-of-cubes-of-digits calculates the sum of the cubes of each digit in a number.\n; It converts the number to a string to iterate over each digit, then converts each digit back to an integer,\n; cubes it, and sums all the cubes.\n(define (sum-of-cubes-of-digits n)\n  (apply + (map (lambda (digit) (expt (string->number (string digit)) 3)) \n                (string->list (number->string n)))))\n\n; G calculates the next term in the sequence by adding the number to the sum of the cubes of its digits.\n(define (G n)\n  (+ n (sum-of-cubes-of-digits n)))\n\n; find-kth-term computes the k-th term in the sequence starting from X.\n; It iteratively applies the function G to the current term (k-1) times.\n(define (find-kth-term X k)\n  (if (= k 1)\n      X\n      (find-kth-term (G X) (- k 1))))\n\n; solve-multiple-cases processes multiple test cases, each consisting of an initial term X and a number of steps k.\n; It returns a list of results where each result is the k-th term starting from the corresponding X.\n(define (solve-multiple-cases cases)\n  (map (lambda (case) (find-kth-term (car case) (cadr case))) cases))\n\n\n(define (test-sequence-functions)\n  (unless (= (find-kth-term 123 1) 123)\n    (error \"Test case (123 1) failed\"))\n  (unless (= (find-kth-term 123 2) 159)\n    (error \"Test case (123 2) failed\"))\n  (unless (= (find-kth-term 1 5) 13)\n    (error \"Test case (1 5) failed\"))\n  (unless (= (find-kth-term 100 3) 103)\n    (error \"Test case (100 3) failed\")))\n\n(test-sequence-functions)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for list operations\n(require srfi/1) ; For list operations like insert-sorted\n\n; process-operations processes a list of operations and returns the results of query operations.\n; The operations can be either 'add x' or 'query k', where x is a number to add to the list,\n; and k is the 1-based index to query from the sorted list.\n; The list is maintained in sorted order after each 'add' operation.\n; The results of 'query' operations are collected and returned as a list.\n(define (process-operations operations)\n  (let loop ([lst '()]              ; The sorted list\n             [ops operations]       ; Remaining operations\n             [results '()])         ; Accumulated results\n    (if (null? ops)\n        (reverse results)           ; Return results in original order\n        (let* ([op (car ops)]       ; Current operation\n               [parts (string-split op)])\n          (cond\n            [(string=? (car parts) \"add\")\n             (let ([x (string->number (cadr parts))])\n               ; Insert x into the sorted list\n               (loop (insert-sorted x lst) (cdr ops) results))]\n            [(string=? (car parts) \"query\")\n             (let ([k (string->number (cadr parts))])\n               ; Get the (k-1)th element (0-based) and add to results\n               (loop lst (cdr ops) (cons (list-ref lst (sub1 k)) results)))]\n            [else\n             (loop lst (cdr ops) results)])))))\n\n; Helper function to insert a number into a sorted list\n(define (insert-sorted x lst)\n  (let-values ([(before after) (partition (lambda (y) (< y x)) lst)])\n    (append before (cons x after))))", "test_cases": "", "test_case_results": "Input: ((add 10 add 5 query 1 add 20 query 2))\nResult: (5 10)\nInput: ((add 3 add 1 add 4 query 2 add 2 query 3))\nResult: (3 3)\nInput: ((add 100 query 1))\nResult: (100)", "task_id": 19813, "assertions": "#lang racket\n\n(require srfi/1)\n\n(define (test-process-operations)\n  (unless (equal? (process-operations '(\"add 10\" \"add 5\" \"query 1\" \"add 20\" \"query 2\")) '(5 10))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (process-operations '(\"add 3\" \"add 1\" \"add 4\" \"query 2\" \"add 2\" \"query 3\")) '(3 3))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (process-operations '(\"add 100\" \"query 1\")) '(100))\n    (error \"Test case 3 failed\")))\n\n(test-process-operations)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for list operations\n(require srfi/1) ; For list operations like insert-sorted\n\n; process-operations processes a list of operations and returns the results of query operations.\n; The operations can be either 'add x' or 'query k', where x is a number to add to the list,\n; and k is the 1-based index to query from the sorted list.\n; The list is maintained in sorted order after each 'add' operation.\n; The results of 'query' operations are collected and returned as a list.\n(define (process-operations operations)\n  (let loop ([lst '()]              ; The sorted list\n             [ops operations]       ; Remaining operations\n             [results '()])         ; Accumulated results\n    (if (null? ops)\n        (reverse results)           ; Return results in original order\n        (let* ([op (car ops)]       ; Current operation\n               [parts (string-split op)])\n          (cond\n            [(string=? (car parts) \"add\")\n             (let ([x (string->number (cadr parts))])\n               ; Insert x into the sorted list\n               (loop (insert-sorted x lst) (cdr ops) results))]\n            [(string=? (car parts) \"query\")\n             (let ([k (string->number (cadr parts))])\n               ; Get the (k-1)th element (0-based) and add to results\n               (loop lst (cdr ops) (cons (list-ref lst (sub1 k)) results)))]\n            [else\n             (loop lst (cdr ops) results)])))))\n\n; Helper function to insert a number into a sorted list\n(define (insert-sorted x lst)\n  (let-values ([(before after) (partition (lambda (y) (< y x)) lst)])\n    (append before (cons x after))))\n\n\n(require srfi/1)\n\n(define (test-process-operations)\n  (unless (equal? (process-operations '(\"add 10\" \"add 5\" \"query 1\" \"add 20\" \"query 2\")) '(5 10))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (process-operations '(\"add 3\" \"add 1\" \"add 4\" \"query 2\" \"add 2\" \"query 3\")) '(3 3))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (process-operations '(\"add 100\" \"query 1\")) '(100))\n    (error \"Test case 3 failed\")))\n\n(test-process-operations)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; highest-unique-grade finds the highest unique grade among students.\n; If no grade is unique, it returns -1.\n; \n; Parameters:\n;   n: Number of students (unused in the function, but kept for consistency with the original)\n;   students: List of pairs (student-id grade)\n;\n; Returns:\n;   The highest unique grade or -1 if no unique grades exist.\n(define (highest-unique-grade n students)\n  (let ([grade-count (make-hash)])\n    ; Count the occurrence of each grade\n    (for ([student students])\n      (let ([grade (second student)])\n        (hash-update! grade-count grade add1 0)))\n    ; Filter out non-unique grades\n    (let ([unique-grades (filter (lambda (g) (= (hash-ref grade-count g) 1))\n                                 (hash-keys grade-count))])\n      (if (empty? unique-grades)\n          -1\n          (apply max unique-grades)))))", "test_cases": "", "test_case_results": "Input: ((1 85) (2 90) (3 85) (4 80))\nResult: 90\nInput: ((1 75) (2 75) (3 75))\nResult: -1\nInput: ((1 90) (2 95) (3 100) (4 95) (5 90))\nResult: 100\nInput: ((1 88))\nResult: 88", "task_id": 23625, "assertions": "#lang racket\n\n(define (test-highest-unique-grade)\n  (unless (= (highest-unique-grade 4 '((1 85) (2 90) (3 85) (4 80))) 90)\n    (error \"Test case 1 failed\"))\n  (unless (= (highest-unique-grade 3 '((1 75) (2 75) (3 75))) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (highest-unique-grade 5 '((1 90) (2 95) (3 100) (4 95) (5 90))) 100)\n    (error \"Test case 3 failed\"))\n  (unless (= (highest-unique-grade 1 '((1 88))) 88)\n    (error \"Test case 4 failed\")))\n\n(test-highest-unique-grade)", "all_code": "#lang racket\n\n\n; highest-unique-grade finds the highest unique grade among students.\n; If no grade is unique, it returns -1.\n; \n; Parameters:\n;   n: Number of students (unused in the function, but kept for consistency with the original)\n;   students: List of pairs (student-id grade)\n;\n; Returns:\n;   The highest unique grade or -1 if no unique grades exist.\n(define (highest-unique-grade n students)\n  (let ([grade-count (make-hash)])\n    ; Count the occurrence of each grade\n    (for ([student students])\n      (let ([grade (second student)])\n        (hash-update! grade-count grade add1 0)))\n    ; Filter out non-unique grades\n    (let ([unique-grades (filter (lambda (g) (= (hash-ref grade-count g) 1))\n                                 (hash-keys grade-count))])\n      (if (empty? unique-grades)\n          -1\n          (apply max unique-grades)))))\n\n\n(define (test-highest-unique-grade)\n  (unless (= (highest-unique-grade 4 '((1 85) (2 90) (3 85) (4 80))) 90)\n    (error \"Test case 1 failed\"))\n  (unless (= (highest-unique-grade 3 '((1 75) (2 75) (3 75))) -1)\n    (error \"Test case 2 failed\"))\n  (unless (= (highest-unique-grade 5 '((1 90) (2 95) (3 100) (4 95) (5 90))) 100)\n    (error \"Test case 3 failed\"))\n  (unless (= (highest-unique-grade 1 '((1 88))) 88)\n    (error \"Test case 4 failed\")))\n\n(test-highest-unique-grade)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-increasing-subsequences calculates the minimum number of strictly increasing contiguous subsequences\n; in a list of numbers. A new subsequence is started whenever the current element is not greater than the previous one.\n; M is the length of the list B, and B is the list of numbers.\n(define (min-increasing-subsequences M B)\n  (if (zero? M)\n      0\n      (let loop ([i 1] [count 1])\n        (if (>= i M)\n            count\n            (if (<= (list-ref B i) (list-ref B (sub1 i)))\n                (loop (add1 i) (add1 count))\n                (loop (add1 i) count))))))", "test_cases": "", "test_case_results": "Input: ()\nResult: 0\nInput: (1)\nResult: 1\nInput: (1 2 3 4 5)\nResult: 1\nInput: (1 2 2 4 5)\nResult: 2\nInput: (5 4 3 2 1)\nResult: 5\nInput: (1 3 2 4 6 5)\nResult: 3", "task_id": 11394, "assertions": "#lang racket\n\n(define (test-min-increasing-subsequences)\n  (unless (= (min-increasing-subsequences 0 '()) 0)\n    (error \"Test 1 failed: Empty list should return 0\"))\n  (unless (= (min-increasing-subsequences 1 '(1)) 1)\n    (error \"Test 2 failed: Single-element list should return 1\"))\n  (unless (= (min-increasing-subsequences 5 '(1 2 3 4 5)) 1)\n    (error \"Test 3 failed: Strictly increasing list should return 1\"))\n  (unless (= (min-increasing-subsequences 5 '(1 2 2 4 5)) 2)\n    (error \"Test 4 failed: Non-decreasing list with equality should return 2\"))\n  (unless (= (min-increasing-subsequences 5 '(5 4 3 2 1)) 5)\n    (error \"Test 5 failed: Strictly decreasing list should return 5\"))\n  (unless (= (min-increasing-subsequences 6 '(1 3 2 4 6 5)) 3)\n    (error \"Test 6 failed: Mixed list should return 3\")))\n\n(test-min-increasing-subsequences)", "all_code": "#lang racket\n\n\n; min-increasing-subsequences calculates the minimum number of strictly increasing contiguous subsequences\n; in a list of numbers. A new subsequence is started whenever the current element is not greater than the previous one.\n; M is the length of the list B, and B is the list of numbers.\n(define (min-increasing-subsequences M B)\n  (if (zero? M)\n      0\n      (let loop ([i 1] [count 1])\n        (if (>= i M)\n            count\n            (if (<= (list-ref B i) (list-ref B (sub1 i)))\n                (loop (add1 i) (add1 count))\n                (loop (add1 i) count))))))\n\n\n(define (test-min-increasing-subsequences)\n  (unless (= (min-increasing-subsequences 0 '()) 0)\n    (error \"Test 1 failed: Empty list should return 0\"))\n  (unless (= (min-increasing-subsequences 1 '(1)) 1)\n    (error \"Test 2 failed: Single-element list should return 1\"))\n  (unless (= (min-increasing-subsequences 5 '(1 2 3 4 5)) 1)\n    (error \"Test 3 failed: Strictly increasing list should return 1\"))\n  (unless (= (min-increasing-subsequences 5 '(1 2 2 4 5)) 2)\n    (error \"Test 4 failed: Non-decreasing list with equality should return 2\"))\n  (unless (= (min-increasing-subsequences 5 '(5 4 3 2 1)) 5)\n    (error \"Test 5 failed: Strictly decreasing list should return 5\"))\n  (unless (= (min-increasing-subsequences 6 '(1 3 2 4 6 5)) 3)\n    (error \"Test 6 failed: Mixed list should return 3\")))\n\n(test-min-increasing-subsequences)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; minimal-highway-cost calculates the minimum cost to connect n cities with a direct highway\n; between each pair of cities. The cost is computed as k multiplied by the number of unique\n; pairs of cities, which is n choose 2 (i.e., n*(n-1)/2).\n; \n; Arguments:\n; n - an integer, the number of cities\n; k - an integer, the cost multiplier\n;\n; Returns:\n; An integer, the minimum cost\n(define (minimal-highway-cost n k)\n  (* k (/ (* n (- n 1)) 2)))", "test_cases": "", "test_case_results": "Input: n=2, k=10\nMinimal cost: 10\nInput: n=3, k=5\nMinimal cost: 15\nInput: n=5, k=2\nMinimal cost: 20\nInput: n=1, k=100\nMinimal cost: 0", "task_id": 9045, "assertions": "#lang racket\n\n(define (test-minimal-highway-cost)\n  (unless (= (minimal-highway-cost 2 10) 10)\n    (error \"Test case (2, 10) failed\"))\n  (unless (= (minimal-highway-cost 3 5) 15)\n    (error \"Test case (3, 5) failed\"))\n  (unless (= (minimal-highway-cost 5 2) 20)\n    (error \"Test case (5, 2) failed\"))\n  (unless (= (minimal-highway-cost 1 100) 0)\n    (error \"Test case (1, 100) failed\")))\n\n(test-minimal-highway-cost)", "all_code": "#lang racket\n\n\n; minimal-highway-cost calculates the minimum cost to connect n cities with a direct highway\n; between each pair of cities. The cost is computed as k multiplied by the number of unique\n; pairs of cities, which is n choose 2 (i.e., n*(n-1)/2).\n; \n; Arguments:\n; n - an integer, the number of cities\n; k - an integer, the cost multiplier\n;\n; Returns:\n; An integer, the minimum cost\n(define (minimal-highway-cost n k)\n  (* k (/ (* n (- n 1)) 2)))\n\n\n(define (test-minimal-highway-cost)\n  (unless (= (minimal-highway-cost 2 10) 10)\n    (error \"Test case (2, 10) failed\"))\n  (unless (= (minimal-highway-cost 3 5) 15)\n    (error \"Test case (3, 5) failed\"))\n  (unless (= (minimal-highway-cost 5 2) 20)\n    (error \"Test case (5, 2) failed\"))\n  (unless (= (minimal-highway-cost 1 100) 0)\n    (error \"Test case (1, 100) failed\")))\n\n(test-minimal-highway-cost)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; int->bytes converts an integer to a byte string based on the specified endian format.\n; The function handles both positive and negative integers using two's complement representation.\n; num: the integer to convert\n; endian: 'big for big-endian, any other value for little-endian\n(define (int->bytes num endian)\n  (let* ([bit-length (if (zero? num) \n                         1 \n                         (max 1 (integer-length num)))]\n         [num-bytes (max 1 (quotient (+ bit-length 7) 8))]\n         [adjusted-num (if (negative? num)\n                           (+ num (arithmetic-shift 1 (* num-bytes 8)))\n                           num)]\n         [bytes-list (for/list ([i (in-range num-bytes)])\n                       (bitwise-and (arithmetic-shift adjusted-num (* -8 i)) 255))])\n    (if (equal? endian 'big)\n        (apply bytes (reverse bytes-list))\n        (apply bytes bytes-list))))\n\n; bytes->int converts a byte string back to an integer, handling both endian formats.\n; bytestr: the byte string to convert\n; endian: 'big for big-endian, any other value for little-endian\n(define (bytes->int bytestr endian)\n  (let* ([bytes-list (if (equal? endian 'big)\n                         (reverse (bytes->list bytestr))\n                         (bytes->list bytestr))]\n         [length (length bytes-list)]\n         [result (for/sum ([i (in-range length)]\n                           [b (in-list bytes-list)])\n                   (arithmetic-shift b (* 8 i)))]\n         [adjusted-result (if (>= (last bytes-list) #x80)\n                              (- result (arithmetic-shift 1 (* length 8)))\n                              result)])\n    adjusted-result))", "test_cases": "", "test_case_results": "Original: 0, Endian: big\nByte string: \u0000\nConverted back: 0\nMatch: #t\n\nOriginal: 0, Endian: little\nByte string: \u0000\nConverted back: 0\nMatch: #t\n\nOriginal: 123, Endian: big\nByte string: {\nConverted back: 123\nMatch: #t\n\nOriginal: 123, Endian: little\nByte string: {\nConverted back: 123\nMatch: #t\n\nOriginal: -123, Endian: big\nByte string: \nConverted back: -123\nMatch: #t\n\nOriginal: -123, Endian: little\nByte string: \nConverted back: -123\nMatch: #t\n\nOriginal: 65535, Endian: big\nByte string: \nConverted back: -1\nMatch: #f\n\nOriginal: 65535, Endian: little\nByte string: \nConverted back: -1\nMatch: #f\n\nOriginal: -65535, Endian: big\nByte string: \u0000\u0001\nConverted back: 1\nMatch: #f\n\nOriginal: -65535, Endian: little\nByte string: \u0001\u0000\nConverted back: 1\nMatch: #f", "task_id": 6102, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-int-bytes-conversion)\n  ; Test case 1: 0 big-endian\n  (let ([num 0] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 1 failed: 0 big-endian conversion mismatch\")))\n  \n  ; Test case 2: 0 little-endian\n  (let ([num 0] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 2 failed: 0 little-endian conversion mismatch\")))\n  \n  ; Test case 3: 123 big-endian\n  (let ([num 123] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 3 failed: 123 big-endian conversion mismatch\")))\n  \n  ; Test case 4: 123 little-endian\n  (let ([num 123] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 4 failed: 123 little-endian conversion mismatch\")))\n  \n  ; Test case 5: -123 big-endian\n  (let ([num -123] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 5 failed: -123 big-endian conversion mismatch\")))\n  \n  ; Test case 6: -123 little-endian\n  (let ([num -123] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 6 failed: -123 little-endian conversion mismatch\")))\n  \n  ; Test case 7: 65535 big-endian\n  (let ([num 65535] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 7 failed: 65535 big-endian conversion mismatch\")))\n  \n  ; Test case 8: 65535 little-endian\n  (let ([num 65535] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 8 failed: 65535 little-endian conversion mismatch\")))\n  \n  ; Test case 9: -65535 big-endian\n  (let ([num -65535] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 9 failed: -65535 big-endian conversion mismatch\")))\n  \n  ; Test case 10: -65535 little-endian\n  (let ([num -65535] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 10 failed: -65535 little-endian conversion mismatch\"))))\n\n(test-int-bytes-conversion)", "all_code": "#lang racket\n\n\n; int->bytes converts an integer to a byte string based on the specified endian format.\n; The function handles both positive and negative integers using two's complement representation.\n; num: the integer to convert\n; endian: 'big for big-endian, any other value for little-endian\n(define (int->bytes num endian)\n  (let* ([bit-length (if (zero? num) \n                         1 \n                         (max 1 (integer-length num)))]\n         [num-bytes (max 1 (quotient (+ bit-length 7) 8))]\n         [adjusted-num (if (negative? num)\n                           (+ num (arithmetic-shift 1 (* num-bytes 8)))\n                           num)]\n         [bytes-list (for/list ([i (in-range num-bytes)])\n                       (bitwise-and (arithmetic-shift adjusted-num (* -8 i)) 255))])\n    (if (equal? endian 'big)\n        (apply bytes (reverse bytes-list))\n        (apply bytes bytes-list))))\n\n; bytes->int converts a byte string back to an integer, handling both endian formats.\n; bytestr: the byte string to convert\n; endian: 'big for big-endian, any other value for little-endian\n(define (bytes->int bytestr endian)\n  (let* ([bytes-list (if (equal? endian 'big)\n                         (reverse (bytes->list bytestr))\n                         (bytes->list bytestr))]\n         [length (length bytes-list)]\n         [result (for/sum ([i (in-range length)]\n                           [b (in-list bytes-list)])\n                   (arithmetic-shift b (* 8 i)))]\n         [adjusted-result (if (>= (last bytes-list) #x80)\n                              (- result (arithmetic-shift 1 (* length 8)))\n                              result)])\n    adjusted-result))\n\n\n(require rackunit)\n\n(define (test-int-bytes-conversion)\n  ; Test case 1: 0 big-endian\n  (let ([num 0] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 1 failed: 0 big-endian conversion mismatch\")))\n  \n  ; Test case 2: 0 little-endian\n  (let ([num 0] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 2 failed: 0 little-endian conversion mismatch\")))\n  \n  ; Test case 3: 123 big-endian\n  (let ([num 123] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 3 failed: 123 big-endian conversion mismatch\")))\n  \n  ; Test case 4: 123 little-endian\n  (let ([num 123] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 4 failed: 123 little-endian conversion mismatch\")))\n  \n  ; Test case 5: -123 big-endian\n  (let ([num -123] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 5 failed: -123 big-endian conversion mismatch\")))\n  \n  ; Test case 6: -123 little-endian\n  (let ([num -123] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 6 failed: -123 little-endian conversion mismatch\")))\n  \n  ; Test case 7: 65535 big-endian\n  (let ([num 65535] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 7 failed: 65535 big-endian conversion mismatch\")))\n  \n  ; Test case 8: 65535 little-endian\n  (let ([num 65535] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 8 failed: 65535 little-endian conversion mismatch\")))\n  \n  ; Test case 9: -65535 big-endian\n  (let ([num -65535] [endian 'big])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 9 failed: -65535 big-endian conversion mismatch\")))\n  \n  ; Test case 10: -65535 little-endian\n  (let ([num -65535] [endian 'little])\n    (unless (equal? (bytes->int (int->bytes num endian) endian) num)\n      (error \"Test 10 failed: -65535 little-endian conversion mismatch\"))))\n\n(test-int-bytes-conversion)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; max-pos-min-neg-product calculates the product of the largest positive number and the smallest negative number in a list.\n; If there are no positive or negative numbers, it returns 0.\n; The function iterates through the list to find the maximum positive and minimum negative numbers.\n(define (max-pos-min-neg-product lst)\n  (let ([max-pos #f]  ; Initialize max-pos as false (no positive number found yet)\n        [min-neg #f]) ; Initialize min-neg as false (no negative number found yet)\n    (for ([num lst])\n      (cond\n        [(and (positive? num) (or (not max-pos) (> num max-pos)))\n         (set! max-pos num)]\n        [(and (negative? num) (or (not min-neg) (< num min-neg)))\n         (set! min-neg num)]))\n    (if (and max-pos min-neg)\n        (* max-pos min-neg)\n        0)))", "test_cases": "", "test_case_results": "Input: (1 2 3 -1 -2 -3)\nResult: -9\nInput: (1 2 3)\nResult: 0\nInput: (-1 -2 -3)\nResult: 0\nInput: (0 0 0)\nResult: 0\nInput: (1 -1 2 -2 3 -3)\nResult: -9", "task_id": 23163, "assertions": "#lang racket\n\n(define (test-max-pos-min-neg-product)\n  (unless (= (max-pos-min-neg-product '(1 2 3 -1 -2 -3)) -9)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-pos-min-neg-product '(1 2 3)) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-pos-min-neg-product '(-1 -2 -3)) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-pos-min-neg-product '(0 0 0)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-pos-min-neg-product '(1 -1 2 -2 3 -3)) -9)\n    (error \"Test case 5 failed\")))\n\n(test-max-pos-min-neg-product)", "all_code": "#lang racket\n\n\n; max-pos-min-neg-product calculates the product of the largest positive number and the smallest negative number in a list.\n; If there are no positive or negative numbers, it returns 0.\n; The function iterates through the list to find the maximum positive and minimum negative numbers.\n(define (max-pos-min-neg-product lst)\n  (let ([max-pos #f]  ; Initialize max-pos as false (no positive number found yet)\n        [min-neg #f]) ; Initialize min-neg as false (no negative number found yet)\n    (for ([num lst])\n      (cond\n        [(and (positive? num) (or (not max-pos) (> num max-pos)))\n         (set! max-pos num)]\n        [(and (negative? num) (or (not min-neg) (< num min-neg)))\n         (set! min-neg num)]))\n    (if (and max-pos min-neg)\n        (* max-pos min-neg)\n        0)))\n\n\n(define (test-max-pos-min-neg-product)\n  (unless (= (max-pos-min-neg-product '(1 2 3 -1 -2 -3)) -9)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-pos-min-neg-product '(1 2 3)) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-pos-min-neg-product '(-1 -2 -3)) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-pos-min-neg-product '(0 0 0)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-pos-min-neg-product '(1 -1 2 -2 3 -3)) -9)\n    (error \"Test case 5 failed\")))\n\n(test-max-pos-min-neg-product)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sum-of-two checks if there exists one element from each input list (arr1 and arr2)\n; such that their sum equals the target value.\n; It uses a set to store the complements (target - num) for each number in arr1,\n; then checks if any number in arr2 exists in the complement set.\n(define (sum-of-two arr1 arr2 target)\n  (let ([complement-set (mutable-set)])\n    (for ([num arr1])\n      (set-add! complement-set (- target num)))\n    (for/or ([num arr2])\n      (set-member? complement-set num))))", "test_cases": "", "test_case_results": "Test Case 1: Elements 1 and 6 sum to 7\narr1: (1 2 3), arr2: (4 5 6), target: 7\nResult: #t\n\nTest Case 2: No elements sum to 10\narr1: (1 2 3), arr2: (4 5 6), target: 10\nResult: #f\n\nTest Case 3: All zeros sum to 0\narr1: (0 0 0), arr2: (0 0 0), target: 0\nResult: #t\n\nTest Case 4: Negative and positive elements sum to 0\narr1: (-1 -2 -3), arr2: (1 2 3), target: 0\nResult: #t", "task_id": 27310, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-sum-of-two)\n  (unless (sum-of-two '(1 2 3) '(4 5 6) 7)\n    (error \"Test Case 1 failed: Expected #t\"))\n  (unless (not (sum-of-two '(1 2 3) '(4 5 6) 10))\n    (error \"Test Case 2 failed: Expected #f\"))\n  (unless (sum-of-two '(0 0 0) '(0 0 0) 0)\n    (error \"Test Case 3 failed: Expected #t\"))\n  (unless (sum-of-two '(-1 -2 -3) '(1 2 3) 0)\n    (error \"Test Case 4 failed: Expected #t\")))\n\n(test-sum-of-two)", "all_code": "#lang racket\n\n\n; sum-of-two checks if there exists one element from each input list (arr1 and arr2)\n; such that their sum equals the target value.\n; It uses a set to store the complements (target - num) for each number in arr1,\n; then checks if any number in arr2 exists in the complement set.\n(define (sum-of-two arr1 arr2 target)\n  (let ([complement-set (mutable-set)])\n    (for ([num arr1])\n      (set-add! complement-set (- target num)))\n    (for/or ([num arr2])\n      (set-member? complement-set num))))\n\n\n(require rackunit)\n\n(define (test-sum-of-two)\n  (unless (sum-of-two '(1 2 3) '(4 5 6) 7)\n    (error \"Test Case 1 failed: Expected #t\"))\n  (unless (not (sum-of-two '(1 2 3) '(4 5 6) 10))\n    (error \"Test Case 2 failed: Expected #f\"))\n  (unless (sum-of-two '(0 0 0) '(0 0 0) 0)\n    (error \"Test Case 3 failed: Expected #t\"))\n  (unless (sum-of-two '(-1 -2 -3) '(1 2 3) 0)\n    (error \"Test Case 4 failed: Expected #t\")))\n\n(test-sum-of-two)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; find-kth is a helper function to find the k-th smallest element in the merged sorted arrays.\n; It uses a divide-and-conquer approach to efficiently find the k-th element without merging the arrays.\n; arr1 and arr2 are the two sorted lists, and k is the index of the element to find.\n(define (find-kth arr1 arr2 k)\n  (cond\n    [(empty? arr1) (list-ref arr2 k)]\n    [(empty? arr2) (list-ref arr1 k)]\n    [else\n     (let* ([idx1 (quotient (length arr1) 2)]\n            [idx2 (quotient (length arr2) 2)]\n            [med1 (list-ref arr1 idx1)]\n            [med2 (list-ref arr2 idx2)])\n       (if (< (+ idx1 idx2) k)\n           (if (> med1 med2)\n               (find-kth arr1 (drop arr2 (+ idx2 1)) (- k idx2 1))\n               (find-kth (drop arr1 (+ idx1 1)) arr2 (- k idx1 1)))\n           (if (> med1 med2)\n               (find-kth (take arr1 idx1) arr2 k)\n               (find-kth arr1 (take arr2 idx2) k))))]))\n\n; find-median-sorted-arrays calculates the median of two sorted lists.\n; If the total length of the merged lists is odd, it returns the middle element.\n; If the total length is even, it returns the average of the two middle elements.\n(define (find-median-sorted-arrays arr1 arr2)\n  (let ([len-total (+ (length arr1) (length arr2))])\n    (if (odd? len-total)\n        (find-kth arr1 arr2 (quotient len-total 2))\n        (/ (+ (find-kth arr1 arr2 (- (quotient len-total 2) 1))\n              (find-kth arr1 arr2 (quotient len-total 2)))\n           2.0))))", "test_cases": "", "test_case_results": "Input: (1 3) and (2)\nMedian: 2\nInput: (1 2) and (3 4)\nMedian: 2.5\nInput: () and (1)\nMedian: 1\nInput: () and (2 3)\nMedian: 2.5\nInput: (0 0) and (0 0 0 0)\nMedian: 0", "task_id": 1774, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-median-sorted-arrays)\n  (unless (= (find-median-sorted-arrays '(1 3) '(2)) 2)\n    (error \"Test case 1 failed: (1 3) and (2) should return 2\"))\n  (unless (= (find-median-sorted-arrays '(1 2) '(3 4)) 2.5)\n    (error \"Test case 2 failed: (1 2) and (3 4) should return 2.5\"))\n  (unless (= (find-median-sorted-arrays '() '(1)) 1)\n    (error \"Test case 3 failed: () and (1) should return 1\"))\n  (unless (= (find-median-sorted-arrays '() '(2 3)) 2.5)\n    (error \"Test case 4 failed: () and (2 3) should return 2.5\"))\n  (unless (= (find-median-sorted-arrays '(0 0) '(0 0 0 0)) 0)\n    (error \"Test case 5 failed: (0 0) and (0 0 0 0) should return 0\")))\n\n(test-median-sorted-arrays)", "all_code": "#lang racket\n\n\n; find-kth is a helper function to find the k-th smallest element in the merged sorted arrays.\n; It uses a divide-and-conquer approach to efficiently find the k-th element without merging the arrays.\n; arr1 and arr2 are the two sorted lists, and k is the index of the element to find.\n(define (find-kth arr1 arr2 k)\n  (cond\n    [(empty? arr1) (list-ref arr2 k)]\n    [(empty? arr2) (list-ref arr1 k)]\n    [else\n     (let* ([idx1 (quotient (length arr1) 2)]\n            [idx2 (quotient (length arr2) 2)]\n            [med1 (list-ref arr1 idx1)]\n            [med2 (list-ref arr2 idx2)])\n       (if (< (+ idx1 idx2) k)\n           (if (> med1 med2)\n               (find-kth arr1 (drop arr2 (+ idx2 1)) (- k idx2 1))\n               (find-kth (drop arr1 (+ idx1 1)) arr2 (- k idx1 1)))\n           (if (> med1 med2)\n               (find-kth (take arr1 idx1) arr2 k)\n               (find-kth arr1 (take arr2 idx2) k))))]))\n\n; find-median-sorted-arrays calculates the median of two sorted lists.\n; If the total length of the merged lists is odd, it returns the middle element.\n; If the total length is even, it returns the average of the two middle elements.\n(define (find-median-sorted-arrays arr1 arr2)\n  (let ([len-total (+ (length arr1) (length arr2))])\n    (if (odd? len-total)\n        (find-kth arr1 arr2 (quotient len-total 2))\n        (/ (+ (find-kth arr1 arr2 (- (quotient len-total 2) 1))\n              (find-kth arr1 arr2 (quotient len-total 2)))\n           2.0))))\n\n\n(require rackunit)\n\n(define (test-median-sorted-arrays)\n  (unless (= (find-median-sorted-arrays '(1 3) '(2)) 2)\n    (error \"Test case 1 failed: (1 3) and (2) should return 2\"))\n  (unless (= (find-median-sorted-arrays '(1 2) '(3 4)) 2.5)\n    (error \"Test case 2 failed: (1 2) and (3 4) should return 2.5\"))\n  (unless (= (find-median-sorted-arrays '() '(1)) 1)\n    (error \"Test case 3 failed: () and (1) should return 1\"))\n  (unless (= (find-median-sorted-arrays '() '(2 3)) 2.5)\n    (error \"Test case 4 failed: () and (2 3) should return 2.5\"))\n  (unless (= (find-median-sorted-arrays '(0 0) '(0 0 0 0)) 0)\n    (error \"Test case 5 failed: (0 0) and (0 0 0 0) should return 0\")))\n\n(test-median-sorted-arrays)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; calculate-fine computes the fine for overdue books based on the number of days overdue.\n; The fine structure is as follows:\n; - First 5 days: $0.50 per day\n; - Next 5 days (6-10): $1.00 per day\n; - Beyond 10 days: $5.00 per day\n; If the input days are negative, an error is raised.\n(define (calculate-fine overdue-days)\n  (if (< overdue-days 0)\n      (error \"Overdue days cannot be negative!\")\n      (cond\n        [(<= overdue-days 5) (* 0.50 overdue-days)]\n        [(<= overdue-days 10) (+ (* 0.50 5) (* 1.00 (- overdue-days 5)))]\n        [else (+ (* 0.50 5) (* 1.00 5) (* 5.00 (- overdue-days 10)))])))", "test_cases": "", "test_case_results": "Input: -1 days\nError: Overdue days cannot be negative!\nInput: 0 days\nFine: $0\nInput: 1 days\nFine: $0.5\nInput: 5 days\nFine: $2.5\nInput: 6 days\nFine: $3.5\nInput: 10 days\nFine: $7.5\nInput: 11 days\nFine: $12.5\nInput: 15 days\nFine: $32.5", "task_id": 10724, "assertions": "#lang racket\n\n(define (test-calculate-fine)\n  ; Test negative input\n  (unless (with-handlers ([exn:fail? (lambda (e) #t)])\n             (calculate-fine -1)\n             #f)\n    (error \"Test 1 failed: Negative input should raise an error\"))\n  \n  ; Test valid inputs\n  (unless (= (calculate-fine 0) 0)\n    (error \"Test 2 failed: 0 days should have $0 fine\"))\n  (unless (= (calculate-fine 1) 0.5)\n    (error \"Test 3 failed: 1 day should have $0.5 fine\"))\n  (unless (= (calculate-fine 5) 2.5)\n    (error \"Test 4 failed: 5 days should have $2.5 fine\"))\n  (unless (= (calculate-fine 6) 3.5)\n    (error \"Test 5 failed: 6 days should have $3.5 fine\"))\n  (unless (= (calculate-fine 10) 7.5)\n    (error \"Test 6 failed: 10 days should have $7.5 fine\"))\n  (unless (= (calculate-fine 11) 12.5)\n    (error \"Test 7 failed: 11 days should have $12.5 fine\"))\n  (unless (= (calculate-fine 15) 32.5)\n    (error \"Test 8 failed: 15 days should have $32.5 fine\")))\n\n(test-calculate-fine)", "all_code": "#lang racket\n\n\n; calculate-fine computes the fine for overdue books based on the number of days overdue.\n; The fine structure is as follows:\n; - First 5 days: $0.50 per day\n; - Next 5 days (6-10): $1.00 per day\n; - Beyond 10 days: $5.00 per day\n; If the input days are negative, an error is raised.\n(define (calculate-fine overdue-days)\n  (if (< overdue-days 0)\n      (error \"Overdue days cannot be negative!\")\n      (cond\n        [(<= overdue-days 5) (* 0.50 overdue-days)]\n        [(<= overdue-days 10) (+ (* 0.50 5) (* 1.00 (- overdue-days 5)))]\n        [else (+ (* 0.50 5) (* 1.00 5) (* 5.00 (- overdue-days 10)))])))\n\n\n(define (test-calculate-fine)\n  ; Test negative input\n  (unless (with-handlers ([exn:fail? (lambda (e) #t)])\n             (calculate-fine -1)\n             #f)\n    (error \"Test 1 failed: Negative input should raise an error\"))\n  \n  ; Test valid inputs\n  (unless (= (calculate-fine 0) 0)\n    (error \"Test 2 failed: 0 days should have $0 fine\"))\n  (unless (= (calculate-fine 1) 0.5)\n    (error \"Test 3 failed: 1 day should have $0.5 fine\"))\n  (unless (= (calculate-fine 5) 2.5)\n    (error \"Test 4 failed: 5 days should have $2.5 fine\"))\n  (unless (= (calculate-fine 6) 3.5)\n    (error \"Test 5 failed: 6 days should have $3.5 fine\"))\n  (unless (= (calculate-fine 10) 7.5)\n    (error \"Test 6 failed: 10 days should have $7.5 fine\"))\n  (unless (= (calculate-fine 11) 12.5)\n    (error \"Test 7 failed: 11 days should have $12.5 fine\"))\n  (unless (= (calculate-fine 15) 32.5)\n    (error \"Test 8 failed: 15 days should have $32.5 fine\")))\n\n(test-calculate-fine)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; determine-role takes a list of employee records and determines if each employee is a Manager or Employee\n; based on their email address. The email for a Manager is expected to follow the pattern:\n; 'manager.<department>.company.com'\n; Each record is a list of three elements: name, email, department.\n; The function returns a list of roles corresponding to each record.\n(define (determine-role records)\n  (map (lambda (record)\n         (let ([name (first record)]\n               [email (second record)]\n               [department (third record)])\n           (if (string-contains? email (string-append \"manager.\" department \".company.com\"))\n               \"Manager\"\n               \"Employee\")))\n       records))", "test_cases": "", "test_case_results": "Test Cases:\nInput: (Alice alice@manager.engineering.company.com engineering)\nInput: (Bob bob@engineering.company.com engineering)\nInput: (Charlie charlie@manager.hr.company.com hr)\nInput: (David david@hr.company.com hr)\nResults: (Manager Employee Manager Employee)", "task_id": 27840, "assertions": "#lang racket\n\n(define (test-determine-role)\n  (define test-cases\n    '((\"Alice\" \"alice@manager.engineering.company.com\" \"engineering\")\n      (\"Bob\" \"bob@engineering.company.com\" \"engineering\")\n      (\"Charlie\" \"charlie@manager.hr.company.com\" \"hr\")\n      (\"David\" \"david@hr.company.com\" \"hr\")))\n  \n  (define expected-results '(\"Manager\" \"Employee\" \"Manager\" \"Employee\"))\n  (define actual-results (determine-role test-cases))\n  \n  (unless (equal? actual-results expected-results)\n    (error (format \"Test failed. Expected: ~a, Actual: ~a\" expected-results actual-results))))\n\n(test-determine-role)", "all_code": "#lang racket\n\n\n; determine-role takes a list of employee records and determines if each employee is a Manager or Employee\n; based on their email address. The email for a Manager is expected to follow the pattern:\n; 'manager.<department>.company.com'\n; Each record is a list of three elements: name, email, department.\n; The function returns a list of roles corresponding to each record.\n(define (determine-role records)\n  (map (lambda (record)\n         (let ([name (first record)]\n               [email (second record)]\n               [department (third record)])\n           (if (string-contains? email (string-append \"manager.\" department \".company.com\"))\n               \"Manager\"\n               \"Employee\")))\n       records))\n\n\n(define (test-determine-role)\n  (define test-cases\n    '((\"Alice\" \"alice@manager.engineering.company.com\" \"engineering\")\n      (\"Bob\" \"bob@engineering.company.com\" \"engineering\")\n      (\"Charlie\" \"charlie@manager.hr.company.com\" \"hr\")\n      (\"David\" \"david@hr.company.com\" \"hr\")))\n  \n  (define expected-results '(\"Manager\" \"Employee\" \"Manager\" \"Employee\"))\n  (define actual-results (determine-role test-cases))\n  \n  (unless (equal? actual-results expected-results)\n    (error (format \"Test failed. Expected: ~a, Actual: ~a\" expected-results actual-results))))\n\n(test-determine-role)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; This module implements a solution for finding the maximum subtree sum in a tree.\n; The tree is represented as an adjacency list, and we use depth-first search (DFS)\n; to traverse the tree and calculate subtree sums.\n\n; dfs performs a depth-first search to calculate subtree sums and track the maximum sum found.\n; Parameters:\n;   u - current node\n;   parent - parent node of u (to avoid backtracking)\n;   adj - adjacency list representing the tree\n;   values - list of node values\n;   max-sum - a box containing the maximum sum found so far (mutable state)\n; Returns: the sum of the subtree rooted at u\n(define (dfs u parent adj values max-sum)\n  (let ([current-sum (list-ref values (sub1 u))]) ; Racket uses 0-based indexing\n    (for ([v (dict-ref adj u)])\n      (when (not (equal? v parent))\n        (let ([child-sum (dfs v u adj values max-sum)])\n          (set! current-sum (+ current-sum child-sum)))))\n    (when (> current-sum (unbox max-sum))\n      (set-box! max-sum current-sum))\n    current-sum))\n\n; maximum-subtree-sum calculates the maximum sum of any subtree in the given tree.\n; Parameters:\n;   n - number of nodes in the tree\n;   values - list of node values (length should be n)\n;   edges - list of pairs representing edges between nodes\n; Returns: the maximum subtree sum found\n(define (maximum-subtree-sum n values edges)\n  (let* ([adj (make-hash)]\n         [max-sum (box -inf.0)])\n    ; Initialize adjacency list\n    (for ([i (in-range 1 (add1 n))])\n      (hash-set! adj i '()))\n    ; Build adjacency list from edges\n    (for ([edge edges])\n      (let ([u (car edge)]\n            [v (cadr edge)])\n        (hash-update! adj u (λ (lst) (cons v lst)))\n        (hash-update! adj v (λ (lst) (cons u lst)))))\n    ; Perform DFS to find maximum subtree sum\n    (dfs 1 #f adj values max-sum)\n    (unbox max-sum)))", "test_cases": "", "test_case_results": "Test case:\n  Nodes: 3\n  Values: (1 2 3)\n  Edges: ((1 2) (1 3))\n  Maximum subtree sum: 6\n\nTest case:\n  Nodes: 5\n  Values: (-1 2 3 -4 5)\n  Edges: ((1 2) (1 3) (2 4) (2 5))\n  Maximum subtree sum: 5\n\nTest case:\n  Nodes: 1\n  Values: (10)\n  Edges: ()\n  Maximum subtree sum: 10\n\nTest case:\n  Nodes: 4\n  Values: (1 -2 3 -4)\n  Edges: ((1 2) (2 3) (3 4))\n  Maximum subtree sum: -1", "task_id": 26823, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-maximum-subtree-sum)\n  ; Test case 1: Simple tree with 3 nodes\n  (unless (= (maximum-subtree-sum 3 '(1 2 3) '((1 2) (1 3))) 6)\n    (error \"Test case 1 failed\"))\n  \n  ; Test case 2: Binary tree with negative values\n  (unless (= (maximum-subtree-sum 5 '(-1 2 3 -4 5) '((1 2) (1 3) (2 4) (2 5))) 5)\n    (error \"Test case 2 failed\"))\n  \n  ; Test case 3: Single node\n  (unless (= (maximum-subtree-sum 1 '(10) '()) 10)\n    (error \"Test case 3 failed\"))\n  \n  ; Test case 4: Line graph\n  (unless (= (maximum-subtree-sum 4 '(1 -2 3 -4) '((1 2) (2 3) (3 4))) -1)\n    (error \"Test case 4 failed\")))\n\n(test-maximum-subtree-sum)", "all_code": "#lang racket\n\n\n; This module implements a solution for finding the maximum subtree sum in a tree.\n; The tree is represented as an adjacency list, and we use depth-first search (DFS)\n; to traverse the tree and calculate subtree sums.\n\n; dfs performs a depth-first search to calculate subtree sums and track the maximum sum found.\n; Parameters:\n;   u - current node\n;   parent - parent node of u (to avoid backtracking)\n;   adj - adjacency list representing the tree\n;   values - list of node values\n;   max-sum - a box containing the maximum sum found so far (mutable state)\n; Returns: the sum of the subtree rooted at u\n(define (dfs u parent adj values max-sum)\n  (let ([current-sum (list-ref values (sub1 u))]) ; Racket uses 0-based indexing\n    (for ([v (dict-ref adj u)])\n      (when (not (equal? v parent))\n        (let ([child-sum (dfs v u adj values max-sum)])\n          (set! current-sum (+ current-sum child-sum)))))\n    (when (> current-sum (unbox max-sum))\n      (set-box! max-sum current-sum))\n    current-sum))\n\n; maximum-subtree-sum calculates the maximum sum of any subtree in the given tree.\n; Parameters:\n;   n - number of nodes in the tree\n;   values - list of node values (length should be n)\n;   edges - list of pairs representing edges between nodes\n; Returns: the maximum subtree sum found\n(define (maximum-subtree-sum n values edges)\n  (let* ([adj (make-hash)]\n         [max-sum (box -inf.0)])\n    ; Initialize adjacency list\n    (for ([i (in-range 1 (add1 n))])\n      (hash-set! adj i '()))\n    ; Build adjacency list from edges\n    (for ([edge edges])\n      (let ([u (car edge)]\n            [v (cadr edge)])\n        (hash-update! adj u (λ (lst) (cons v lst)))\n        (hash-update! adj v (λ (lst) (cons u lst)))))\n    ; Perform DFS to find maximum subtree sum\n    (dfs 1 #f adj values max-sum)\n    (unbox max-sum)))\n\n\n(require rackunit)\n\n(define (test-maximum-subtree-sum)\n  ; Test case 1: Simple tree with 3 nodes\n  (unless (= (maximum-subtree-sum 3 '(1 2 3) '((1 2) (1 3))) 6)\n    (error \"Test case 1 failed\"))\n  \n  ; Test case 2: Binary tree with negative values\n  (unless (= (maximum-subtree-sum 5 '(-1 2 3 -4 5) '((1 2) (1 3) (2 4) (2 5))) 5)\n    (error \"Test case 2 failed\"))\n  \n  ; Test case 3: Single node\n  (unless (= (maximum-subtree-sum 1 '(10) '()) 10)\n    (error \"Test case 3 failed\"))\n  \n  ; Test case 4: Line graph\n  (unless (= (maximum-subtree-sum 4 '(1 -2 3 -4) '((1 2) (2 3) (3 4))) -1)\n    (error \"Test case 4 failed\")))\n\n(test-maximum-subtree-sum)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-odd-subarrays calculates the minimum number of subarrays such that the sum of elements\n; in each subarray is odd. If it's not possible to partition the array in such a way, it returns -1.\n; The function counts the number of odd numbers in the list and uses this count to determine the result.\n; If there are no odd numbers, it returns -1. Otherwise, it returns the count of odd numbers.\n(define (min-odd-subarrays nums)\n  (let ([count-odd (count odd? nums)])\n    (if (zero? count-odd)\n        -1\n        count-odd)))", "test_cases": "", "test_case_results": "Input: (1 2 3 4)\nResult: 2\nInput: (2 4 6 8)\nResult: -1\nInput: (1 3 5 7 2)\nResult: 4\nInput: (0 0 1 0 0)\nResult: 1", "task_id": 18783, "assertions": "#lang racket\n\n(define (test-min-odd-subarrays)\n  (unless (= (min-odd-subarrays '(1 2 3 4)) 2)\n    (error \"Test case (1 2 3 4) failed\"))\n  (unless (= (min-odd-subarrays '(2 4 6 8)) -1)\n    (error \"Test case (2 4 6 8) failed\"))\n  (unless (= (min-odd-subarrays '(1 3 5 7 2)) 4)\n    (error \"Test case (1 3 5 7 2) failed\"))\n  (unless (= (min-odd-subarrays '(0 0 1 0 0)) 1)\n    (error \"Test case (0 0 1 0 0) failed\")))\n\n(test-min-odd-subarrays)", "all_code": "#lang racket\n\n\n; min-odd-subarrays calculates the minimum number of subarrays such that the sum of elements\n; in each subarray is odd. If it's not possible to partition the array in such a way, it returns -1.\n; The function counts the number of odd numbers in the list and uses this count to determine the result.\n; If there are no odd numbers, it returns -1. Otherwise, it returns the count of odd numbers.\n(define (min-odd-subarrays nums)\n  (let ([count-odd (count odd? nums)])\n    (if (zero? count-odd)\n        -1\n        count-odd)))\n\n\n(define (test-min-odd-subarrays)\n  (unless (= (min-odd-subarrays '(1 2 3 4)) 2)\n    (error \"Test case (1 2 3 4) failed\"))\n  (unless (= (min-odd-subarrays '(2 4 6 8)) -1)\n    (error \"Test case (2 4 6 8) failed\"))\n  (unless (= (min-odd-subarrays '(1 3 5 7 2)) 4)\n    (error \"Test case (1 3 5 7 2) failed\"))\n  (unless (= (min-odd-subarrays '(0 0 1 0 0)) 1)\n    (error \"Test case (0 0 1 0 0) failed\")))\n\n(test-min-odd-subarrays)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sort-string-lexicographically sorts a given string in lexicographical order.\n; It converts the string to a list of characters, sorts the list, and then converts it back to a string.\n; If the input string is empty, it returns an empty string.\n(define (sort-string-lexicographically s)\n  (list->string (sort (string->list s) char<?)))", "test_cases": "", "test_case_results": "Input: hello\nSorted: ehllo\nInput: world\nSorted: dlorw\nInput: racket\nSorted: acekrt\nInput: abc\nSorted: abc\nInput: \nSorted:", "task_id": 12397, "assertions": "#lang racket\n\n(define (test-sort-string)\n  (unless (equal? (sort-string-lexicographically \"hello\") \"ehllo\")\n    (error \"Test 1 failed: 'hello'\"))\n  (unless (equal? (sort-string-lexicographically \"world\") \"dlorw\")\n    (error \"Test 2 failed: 'world'\"))\n  (unless (equal? (sort-string-lexicographically \"racket\") \"acekrt\")\n    (error \"Test 3 failed: 'racket'\"))\n  (unless (equal? (sort-string-lexicographically \"abc\") \"abc\")\n    (error \"Test 4 failed: 'abc'\"))\n  (unless (equal? (sort-string-lexicographically \"\") \"\")\n    (error \"Test 5 failed: empty string\")))\n\n(test-sort-string)", "all_code": "#lang racket\n\n\n; sort-string-lexicographically sorts a given string in lexicographical order.\n; It converts the string to a list of characters, sorts the list, and then converts it back to a string.\n; If the input string is empty, it returns an empty string.\n(define (sort-string-lexicographically s)\n  (list->string (sort (string->list s) char<?)))\n\n\n(define (test-sort-string)\n  (unless (equal? (sort-string-lexicographically \"hello\") \"ehllo\")\n    (error \"Test 1 failed: 'hello'\"))\n  (unless (equal? (sort-string-lexicographically \"world\") \"dlorw\")\n    (error \"Test 2 failed: 'world'\"))\n  (unless (equal? (sort-string-lexicographically \"racket\") \"acekrt\")\n    (error \"Test 3 failed: 'racket'\"))\n  (unless (equal? (sort-string-lexicographically \"abc\") \"abc\")\n    (error \"Test 4 failed: 'abc'\"))\n  (unless (equal? (sort-string-lexicographically \"\") \"\")\n    (error \"Test 5 failed: empty string\")))\n\n(test-sort-string)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; is-valid-candy-chain? checks if a candy chain meets the following requirements:\n; - Each candy piece has a distinct sweetness level (handled by the input list being distinct).\n; - The total sweetness level is an even number.\n; - Among any three consecutive candy pieces, the total sweetness level is not divisible by 3.\n(define (is-valid-candy-chain? candy-chain)\n  (let ([total-sweetness (apply + candy-chain)])\n    (and (even? total-sweetness)\n         (not (exists-three-consecutive-divisible-by-3? candy-chain)))))\n\n; Helper function to check if any three consecutive elements sum to a multiple of 3.\n(define (exists-three-consecutive-divisible-by-3? lst)\n  (for/or ([i (range (- (length lst) 2))])\n    (zero? (modulo (+ (list-ref lst i)\n                      (list-ref lst (+ i 1))\n                      (list-ref lst (+ i 2)))\n                   3))))\n\n; arpas-candy-chain attempts to create a valid candy chain based on the conditions provided.\n; It first checks if the total sweetness is even. If not, it returns -1.\n; For small chains (n < 3), it returns the sorted list if the total is even.\n; For larger chains, it tries to find a valid permutation by swapping adjacent elements.\n(define (arpas-candy-chain n sweetness-levels)\n  (let* ([sorted-levels (sort sweetness-levels <)]\n         [total (apply + sorted-levels)])\n    (cond\n      [(not (even? total)) -1]\n      [(< n 3) sorted-levels]\n      [else\n       (let loop ([levels sorted-levels] [i 0])\n         (cond\n           [(>= i (- n 2)) -1]\n           [(is-valid-candy-chain? levels) levels]\n           [else\n            (let ([new-levels (swap-adjacent levels i)])\n              (if (is-valid-candy-chain? new-levels)\n                  new-levels\n                  (loop levels (+ i 1))))]))])))\n\n; Helper function to swap adjacent elements at position i and i+1.\n(define (swap-adjacent lst i)\n  (if (>= i (- (length lst) 1))\n      lst\n      (append (take lst i)\n              (list (list-ref lst (+ i 1)) (list-ref lst i))\n              (drop lst (+ i 2)))))", "test_cases": "", "test_case_results": "Input: n = 5, sweetness-levels = (3 2 1 6 7)\nResult: -1\nInput: n = 4, sweetness-levels = (1 3 5 7)\nResult: -1\nInput: n = 3, sweetness-levels = (1 2 3)\nResult: -1\nInput: n = 2, sweetness-levels = (1 3)\nResult: (1 3)\nInput: n = 4, sweetness-levels = (1 3 5 8)\nResult: -1", "task_id": 23452, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-candy-chain)\n  (unless (equal? (arpas-candy-chain 5 '(3 2 1 6 7)) -1)\n    (error \"Test case 1 failed\"))\n  (unless (equal? (arpas-candy-chain 4 '(1 3 5 7)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (equal? (arpas-candy-chain 3 '(1 2 3)) -1)\n    (error \"Test case 3 failed\"))\n  (unless (equal? (arpas-candy-chain 2 '(1 3)) '(1 3))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (arpas-candy-chain 4 '(1 3 5 8)) -1)\n    (error \"Test case 5 failed\")))\n\n(test-candy-chain)", "all_code": "#lang racket\n\n\n; is-valid-candy-chain? checks if a candy chain meets the following requirements:\n; - Each candy piece has a distinct sweetness level (handled by the input list being distinct).\n; - The total sweetness level is an even number.\n; - Among any three consecutive candy pieces, the total sweetness level is not divisible by 3.\n(define (is-valid-candy-chain? candy-chain)\n  (let ([total-sweetness (apply + candy-chain)])\n    (and (even? total-sweetness)\n         (not (exists-three-consecutive-divisible-by-3? candy-chain)))))\n\n; Helper function to check if any three consecutive elements sum to a multiple of 3.\n(define (exists-three-consecutive-divisible-by-3? lst)\n  (for/or ([i (range (- (length lst) 2))])\n    (zero? (modulo (+ (list-ref lst i)\n                      (list-ref lst (+ i 1))\n                      (list-ref lst (+ i 2)))\n                   3))))\n\n; arpas-candy-chain attempts to create a valid candy chain based on the conditions provided.\n; It first checks if the total sweetness is even. If not, it returns -1.\n; For small chains (n < 3), it returns the sorted list if the total is even.\n; For larger chains, it tries to find a valid permutation by swapping adjacent elements.\n(define (arpas-candy-chain n sweetness-levels)\n  (let* ([sorted-levels (sort sweetness-levels <)]\n         [total (apply + sorted-levels)])\n    (cond\n      [(not (even? total)) -1]\n      [(< n 3) sorted-levels]\n      [else\n       (let loop ([levels sorted-levels] [i 0])\n         (cond\n           [(>= i (- n 2)) -1]\n           [(is-valid-candy-chain? levels) levels]\n           [else\n            (let ([new-levels (swap-adjacent levels i)])\n              (if (is-valid-candy-chain? new-levels)\n                  new-levels\n                  (loop levels (+ i 1))))]))])))\n\n; Helper function to swap adjacent elements at position i and i+1.\n(define (swap-adjacent lst i)\n  (if (>= i (- (length lst) 1))\n      lst\n      (append (take lst i)\n              (list (list-ref lst (+ i 1)) (list-ref lst i))\n              (drop lst (+ i 2)))))\n\n\n(require rackunit)\n\n(define (test-candy-chain)\n  (unless (equal? (arpas-candy-chain 5 '(3 2 1 6 7)) -1)\n    (error \"Test case 1 failed\"))\n  (unless (equal? (arpas-candy-chain 4 '(1 3 5 7)) -1)\n    (error \"Test case 2 failed\"))\n  (unless (equal? (arpas-candy-chain 3 '(1 2 3)) -1)\n    (error \"Test case 3 failed\"))\n  (unless (equal? (arpas-candy-chain 2 '(1 3)) '(1 3))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (arpas-candy-chain 4 '(1 3 5 8)) -1)\n    (error \"Test case 5 failed\")))\n\n(test-candy-chain)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-number-of-groups calculates the minimum number of groups needed to arrange paintings with consecutive labels\n; such that the difference between the maximum and minimum label in each group is at most k.\n; The function first sorts the labels to facilitate grouping, then iterates through the sorted list to form groups.\n; n: the number of paintings (unused in the actual logic, but kept for consistency with the original function)\n; k: the maximum allowed difference between the max and min label in any group\n; labels: a list of integers representing the labels of the paintings\n(define (min-number-of-groups n k labels)\n  (let* ([sorted-labels (sort labels <)] ; Sort the labels in ascending order\n         [group-start (first sorted-labels)] ; Initialize the start of the first group\n         [groups 1]) ; Initialize the group count to 1\n    (for ([label (rest sorted-labels)]) ; Iterate over the remaining labels\n      (when (> label (+ group-start k)) ; If the current label exceeds the allowed range\n        (set! groups (add1 groups)) ; Increment the group count\n        (set! group-start label))) ; Start a new group with the current label\n    groups)) ; Return the total number of groups", "test_cases": "", "test_case_results": "Input: n=5, k=3, labels=(1 4 2 7 5)\nResult: 2\nInput: n=4, k=2, labels=(3 1 5 9)\nResult: 3\nInput: n=3, k=0, labels=(1 1 1)\nResult: 1\nInput: n=6, k=5, labels=(10 15 20 25 30 35)\nResult: 3", "task_id": 12833, "assertions": "#lang racket\n\n(define (test-min-number-of-groups)\n  (unless (= (min-number-of-groups 5 3 '(1 4 2 7 5)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-number-of-groups 4 2 '(3 1 5 9)) 3)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-number-of-groups 3 0 '(1 1 1)) 1)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-number-of-groups 6 5 '(10 15 20 25 30 35)) 3)\n    (error \"Test case 4 failed\")))\n\n(test-min-number-of-groups)", "all_code": "#lang racket\n\n\n; min-number-of-groups calculates the minimum number of groups needed to arrange paintings with consecutive labels\n; such that the difference between the maximum and minimum label in each group is at most k.\n; The function first sorts the labels to facilitate grouping, then iterates through the sorted list to form groups.\n; n: the number of paintings (unused in the actual logic, but kept for consistency with the original function)\n; k: the maximum allowed difference between the max and min label in any group\n; labels: a list of integers representing the labels of the paintings\n(define (min-number-of-groups n k labels)\n  (let* ([sorted-labels (sort labels <)] ; Sort the labels in ascending order\n         [group-start (first sorted-labels)] ; Initialize the start of the first group\n         [groups 1]) ; Initialize the group count to 1\n    (for ([label (rest sorted-labels)]) ; Iterate over the remaining labels\n      (when (> label (+ group-start k)) ; If the current label exceeds the allowed range\n        (set! groups (add1 groups)) ; Increment the group count\n        (set! group-start label))) ; Start a new group with the current label\n    groups)) ; Return the total number of groups\n\n\n(define (test-min-number-of-groups)\n  (unless (= (min-number-of-groups 5 3 '(1 4 2 7 5)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-number-of-groups 4 2 '(3 1 5 9)) 3)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-number-of-groups 3 0 '(1 1 1)) 1)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-number-of-groups 6 5 '(10 15 20 25 30 35)) 3)\n    (error \"Test case 4 failed\")))\n\n(test-min-number-of-groups)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for combinations and list operations\n(require racket/list)\n\n; min-abs-diff finds the minimum absolute difference between the sums of two non-empty disjoint subsets\n; of the given list of numbers.\n; Parameters:\n;   n: The number of elements in the list.\n;   arr: The list of numbers.\n; Returns:\n;   The minimum absolute difference between the sums of two subsets.\n(define (min-abs-diff n arr)\n  (let* ([total-sum (apply + arr)]\n         [min-diff +inf.0])\n    ; Try all combinations of all possible sizes (from 1 to n-1)\n    (for ([i (in-range 1 n)])\n      (for ([subset (in-list (combinations arr i))])\n        (let* ([subset-sum (apply + subset)]\n               [other-subset-sum (- total-sum subset-sum)]\n               [diff (abs (- subset-sum other-subset-sum))])\n          (when (< diff min-diff)\n            (set! min-diff diff)))))\n    min-diff))", "test_cases": "", "test_case_results": "Input: (1 2 3 4)\nMinimum absolute difference: 0\nInput: (5 6 7)\nMinimum absolute difference: 4\nInput: (0 0)\nMinimum absolute difference: 0", "task_id": 19687, "assertions": "#lang racket\n\n(require racket/list)\n\n(define (test-min-abs-diff)\n  (unless (= (min-abs-diff 4 '(1 2 3 4)) 0)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-abs-diff 3 '(5 6 7)) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-abs-diff 2 '(0 0)) 0)\n    (error \"Test case 3 failed\")))\n\n(test-min-abs-diff)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for combinations and list operations\n(require racket/list)\n\n; min-abs-diff finds the minimum absolute difference between the sums of two non-empty disjoint subsets\n; of the given list of numbers.\n; Parameters:\n;   n: The number of elements in the list.\n;   arr: The list of numbers.\n; Returns:\n;   The minimum absolute difference between the sums of two subsets.\n(define (min-abs-diff n arr)\n  (let* ([total-sum (apply + arr)]\n         [min-diff +inf.0])\n    ; Try all combinations of all possible sizes (from 1 to n-1)\n    (for ([i (in-range 1 n)])\n      (for ([subset (in-list (combinations arr i))])\n        (let* ([subset-sum (apply + subset)]\n               [other-subset-sum (- total-sum subset-sum)]\n               [diff (abs (- subset-sum other-subset-sum))])\n          (when (< diff min-diff)\n            (set! min-diff diff)))))\n    min-diff))\n\n\n(require racket/list)\n\n(define (test-min-abs-diff)\n  (unless (= (min-abs-diff 4 '(1 2 3 4)) 0)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-abs-diff 3 '(5 6 7)) 4)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-abs-diff 2 '(0 0)) 0)\n    (error \"Test case 3 failed\")))\n\n(test-min-abs-diff)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-sections-to-collect-items determines the minimum number of sections needed to collect at least M items.\n; The sections are sorted in descending order based on the number of items they contain.\n; The function iterates through the sorted sections, accumulating items until the total meets or exceeds M.\n; If the total items never reach M, it returns the count of all sections.\n; Parameters:\n;   N: integer, the number of sections (unused in the actual logic but kept for interface consistency)\n;   M: integer, the total number of items needed\n;   items: list of integers, the number of items in each section\n; Returns:\n;   integer, the minimum number of sections required\n(define (min-sections-to-collect-items N M items)\n  (let* ([sorted-items (sort items >)]\n         [total-items 0]\n         [sections-count 0])\n    (for ([num (in-list sorted-items)] #:break (>= total-items M))\n      (set! total-items (+ total-items num))\n      (set! sections-count (add1 sections-count)))\n    (if (>= total-items M)\n        sections-count\n        sections-count)))", "test_cases": "", "test_case_results": "Input: N=4, M=10, items=(3 8 2 1)\nResult: 2\nInput: N=5, M=15, items=(5 5 5 5 5)\nResult: 3\nInput: N=3, M=10, items=(1 2 3)\nResult: 3\nInput: N=4, M=0, items=(1 2 3 4)\nResult: 0\nInput: N=0, M=5, items=()\nResult: 0", "task_id": 13894, "assertions": "#lang racket\n\n(define (test-min-sections)\n  (unless (= (min-sections-to-collect-items 4 10 '(3 8 2 1)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-sections-to-collect-items 5 15 '(5 5 5 5 5)) 3)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-sections-to-collect-items 3 10 '(1 2 3)) 3)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-sections-to-collect-items 4 0 '(1 2 3 4)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (min-sections-to-collect-items 0 5 '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-min-sections)", "all_code": "#lang racket\n\n\n; min-sections-to-collect-items determines the minimum number of sections needed to collect at least M items.\n; The sections are sorted in descending order based on the number of items they contain.\n; The function iterates through the sorted sections, accumulating items until the total meets or exceeds M.\n; If the total items never reach M, it returns the count of all sections.\n; Parameters:\n;   N: integer, the number of sections (unused in the actual logic but kept for interface consistency)\n;   M: integer, the total number of items needed\n;   items: list of integers, the number of items in each section\n; Returns:\n;   integer, the minimum number of sections required\n(define (min-sections-to-collect-items N M items)\n  (let* ([sorted-items (sort items >)]\n         [total-items 0]\n         [sections-count 0])\n    (for ([num (in-list sorted-items)] #:break (>= total-items M))\n      (set! total-items (+ total-items num))\n      (set! sections-count (add1 sections-count)))\n    (if (>= total-items M)\n        sections-count\n        sections-count)))\n\n\n(define (test-min-sections)\n  (unless (= (min-sections-to-collect-items 4 10 '(3 8 2 1)) 2)\n    (error \"Test case 1 failed\"))\n  (unless (= (min-sections-to-collect-items 5 15 '(5 5 5 5 5)) 3)\n    (error \"Test case 2 failed\"))\n  (unless (= (min-sections-to-collect-items 3 10 '(1 2 3)) 3)\n    (error \"Test case 3 failed\"))\n  (unless (= (min-sections-to-collect-items 4 0 '(1 2 3 4)) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (min-sections-to-collect-items 0 5 '()) 0)\n    (error \"Test case 5 failed\")))\n\n(test-min-sections)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for graph operations\n(require data/gvector)\n\n; find-critical-roads identifies critical roads (bridges) in a graph using Tarjan's algorithm.\n; n: number of nodes in the graph\n; m: number of edges in the graph\n; edges: list of pairs representing edges between nodes\n; Returns a list of critical edges sorted in ascending order, or '(\"None\") if no critical edges exist.\n(define (find-critical-roads n m edges)\n  (define graph (make-vector (+ n 1) '())) ; 1-based indexing\n  (define visited (make-vector (+ n 1) #f))\n  (define ids (make-vector (+ n 1) 0))\n  (define low (make-vector (+ n 1) 0))\n  (define critical-edges (gvector))\n  (define time 0)\n\n  ; Build the adjacency list for the graph\n  (for ([edge edges])\n    (let ([u (car edge)]\n          [v (cadr edge)])\n      (vector-set! graph u (cons v (vector-ref graph u)))\n      (vector-set! graph v (cons u (vector-ref graph v)))))\n\n  ; Depth-first search to find bridges\n  (define (dfs node parent)\n    (set! time (+ time 1))\n    (vector-set! visited node #t)\n    (vector-set! ids node time)\n    (vector-set! low node time)\n    (for ([neighbor (vector-ref graph node)])\n      (cond\n        [(equal? neighbor parent) (void)]\n        [(not (vector-ref visited neighbor))\n         (dfs neighbor node)\n         (vector-set! low node (min (vector-ref low node) (vector-ref low neighbor)))\n         (when (> (vector-ref ids node) (vector-ref low neighbor))\n           (gvector-add! critical-edges (sort (list node neighbor) <)))]\n        [else\n         (vector-set! low node (min (vector-ref low node) (vector-ref ids neighbor)))])))\n\n  ; Perform DFS on all unvisited nodes\n  (for ([i (in-range 1 (+ n 1))])\n    (when (not (vector-ref visited i))\n      (dfs i -1)))\n\n  ; Prepare the result\n  (if (> (gvector-count critical-edges) 0)\n      (sort (gvector->list critical-edges) \n            (lambda (a b) (or (< (car a) (car b)) \n                              (and (= (car a) (car b)) (< (cadr a) (cadr b))))))\n      '(\"None\")))", "test_cases": "", "test_case_results": "Input: n=4, m=3, edges=((1 2) (2 3) (3 4))\nCritical roads: (None)\nInput: n=3, m=3, edges=((1 2) (2 3) (3 1))\nCritical roads: ((2 3))\nInput: n=2, m=1, edges=((1 2))\nCritical roads: (None)\nInput: n=5, m=4, edges=((1 2) (2 3) (3 4) (4 5))\nCritical roads: (None)\nInput: n=6, m=6, edges=((1 2) (2 3) (3 1) (4 5) (5 6) (6 4))\nCritical roads: ((2 3) (5 6))", "task_id": 15010, "assertions": "#lang racket\n\n(require data/gvector)\n\n(define (test-critical-roads)\n  (unless (equal? (find-critical-roads 4 3 '((1 2) (2 3) (3 4))) '(\"None\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (find-critical-roads 3 3 '((1 2) (2 3) (3 1))) '((2 3)))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (find-critical-roads 2 1 '((1 2))) '(\"None\"))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (find-critical-roads 5 4 '((1 2) (2 3) (3 4) (4 5))) '(\"None\"))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (find-critical-roads 6 6 '((1 2) (2 3) (3 1) (4 5) (5 6) (6 4))) '((2 3) (5 6)))\n    (error \"Test case 5 failed\")))\n\n(test-critical-roads)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for graph operations\n(require data/gvector)\n\n; find-critical-roads identifies critical roads (bridges) in a graph using Tarjan's algorithm.\n; n: number of nodes in the graph\n; m: number of edges in the graph\n; edges: list of pairs representing edges between nodes\n; Returns a list of critical edges sorted in ascending order, or '(\"None\") if no critical edges exist.\n(define (find-critical-roads n m edges)\n  (define graph (make-vector (+ n 1) '())) ; 1-based indexing\n  (define visited (make-vector (+ n 1) #f))\n  (define ids (make-vector (+ n 1) 0))\n  (define low (make-vector (+ n 1) 0))\n  (define critical-edges (gvector))\n  (define time 0)\n\n  ; Build the adjacency list for the graph\n  (for ([edge edges])\n    (let ([u (car edge)]\n          [v (cadr edge)])\n      (vector-set! graph u (cons v (vector-ref graph u)))\n      (vector-set! graph v (cons u (vector-ref graph v)))))\n\n  ; Depth-first search to find bridges\n  (define (dfs node parent)\n    (set! time (+ time 1))\n    (vector-set! visited node #t)\n    (vector-set! ids node time)\n    (vector-set! low node time)\n    (for ([neighbor (vector-ref graph node)])\n      (cond\n        [(equal? neighbor parent) (void)]\n        [(not (vector-ref visited neighbor))\n         (dfs neighbor node)\n         (vector-set! low node (min (vector-ref low node) (vector-ref low neighbor)))\n         (when (> (vector-ref ids node) (vector-ref low neighbor))\n           (gvector-add! critical-edges (sort (list node neighbor) <)))]\n        [else\n         (vector-set! low node (min (vector-ref low node) (vector-ref ids neighbor)))])))\n\n  ; Perform DFS on all unvisited nodes\n  (for ([i (in-range 1 (+ n 1))])\n    (when (not (vector-ref visited i))\n      (dfs i -1)))\n\n  ; Prepare the result\n  (if (> (gvector-count critical-edges) 0)\n      (sort (gvector->list critical-edges) \n            (lambda (a b) (or (< (car a) (car b)) \n                              (and (= (car a) (car b)) (< (cadr a) (cadr b))))))\n      '(\"None\")))\n\n\n(require data/gvector)\n\n(define (test-critical-roads)\n  (unless (equal? (find-critical-roads 4 3 '((1 2) (2 3) (3 4))) '(\"None\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (find-critical-roads 3 3 '((1 2) (2 3) (3 1))) '((2 3)))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (find-critical-roads 2 1 '((1 2))) '(\"None\"))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (find-critical-roads 5 4 '((1 2) (2 3) (3 4) (4 5))) '(\"None\"))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (find-critical-roads 6 6 '((1 2) (2 3) (3 1) (4 5) (5 6) (6 4))) '((2 3) (5 6)))\n    (error \"Test case 5 failed\")))\n\n(test-critical-roads)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-non-overlapping-films calculates the maximum number of non-overlapping films that can be watched\n; from a festival schedule. The schedule is structured as:\n; - First element is number of test cases (T)\n; - For each test case:\n;   - Next element is number of films (N)\n;   - Then N pairs of start/end times in \"HH:MM\" format\n(define (max-non-overlapping-films festival-schedule)\n  ; convert-to-minutes converts a time string \"HH:MM\" to total minutes\n  (define (convert-to-minutes time-str)\n    (let ([time-parts (string-split time-str \":\")])\n      (+ (* (string->number (first time-parts)) 60)\n         (string->number (second time-parts)))))\n  \n  (let ([T (first festival-schedule)]\n        [idx 1]\n        [results '()])\n    (for ([_ (in-range T)])\n      (let* ([N (list-ref festival-schedule idx)]\n             [idx (+ idx 1)]\n             [films '()])\n        ; Collect all films for this test case with times converted to minutes\n        (for ([_ (in-range N)])\n          (let* ([start-time (first (list-ref festival-schedule idx))]\n                 [end-time (second (list-ref festival-schedule idx))]\n                 [start-min (convert-to-minutes start-time)]\n                 [end-min (convert-to-minutes end-time)])\n            (set! films (cons (cons start-min end-min) films))\n            (set! idx (+ idx 1))))\n        ; Sort films by end time\n        (set! films (sort films (λ (a b) (< (cdr a) (cdr b)))))\n        ; Count non-overlapping films\n        (let ([last-end-time -1]\n              [count 0])\n          (for ([film films])\n            (when (>= (car film) last-end-time)\n              (set! last-end-time (cdr film))\n              (set! count (+ count 1))))\n          (set! results (cons count results)))))\n    (reverse results)))", "test_cases": "", "test_case_results": "Test 1 input: (1 3 (10:00 10:30) (09:00 09:30) (10:30 11:00))\nResult: (3)\n\nTest 2 input: (2 2 (14:00 15:00) (15:00 16:00) 3 (09:00 10:00) (09:30 10:30) (10:00 11:00))\nResult: (2 2)\n\nTest 3 input: (1 4 (08:00 09:00) (08:30 09:30) (09:30 10:00) (10:00 11:00))\nResult: (3)", "task_id": 12972, "assertions": "#lang racket\n\n(define (test-max-non-overlapping-films)\n  (unless (equal? (max-non-overlapping-films \n                   '(1 3 (\"10:00\" \"10:30\") (\"09:00\" \"09:30\") (\"10:30\" \"11:00\")))\n                  '(3))\n    (error \"Test 1 failed\"))\n  (unless (equal? (max-non-overlapping-films \n                   '(2 2 (\"14:00\" \"15:00\") (\"15:00\" \"16:00\") \n                       3 (\"09:00\" \"10:00\") (\"09:30\" \"10:30\") (\"10:00\" \"11:00\")))\n                  '(2 2))\n    (error \"Test 2 failed\"))\n  (unless (equal? (max-non-overlapping-films \n                   '(1 4 (\"08:00\" \"09:00\") (\"08:30\" \"09:30\") (\"09:30\" \"10:00\") (\"10:00\" \"11:00\")))\n                  '(3))\n    (error \"Test 3 failed\")))\n\n(test-max-non-overlapping-films)", "all_code": "#lang racket\n\n\n; max-non-overlapping-films calculates the maximum number of non-overlapping films that can be watched\n; from a festival schedule. The schedule is structured as:\n; - First element is number of test cases (T)\n; - For each test case:\n;   - Next element is number of films (N)\n;   - Then N pairs of start/end times in \"HH:MM\" format\n(define (max-non-overlapping-films festival-schedule)\n  ; convert-to-minutes converts a time string \"HH:MM\" to total minutes\n  (define (convert-to-minutes time-str)\n    (let ([time-parts (string-split time-str \":\")])\n      (+ (* (string->number (first time-parts)) 60)\n         (string->number (second time-parts)))))\n  \n  (let ([T (first festival-schedule)]\n        [idx 1]\n        [results '()])\n    (for ([_ (in-range T)])\n      (let* ([N (list-ref festival-schedule idx)]\n             [idx (+ idx 1)]\n             [films '()])\n        ; Collect all films for this test case with times converted to minutes\n        (for ([_ (in-range N)])\n          (let* ([start-time (first (list-ref festival-schedule idx))]\n                 [end-time (second (list-ref festival-schedule idx))]\n                 [start-min (convert-to-minutes start-time)]\n                 [end-min (convert-to-minutes end-time)])\n            (set! films (cons (cons start-min end-min) films))\n            (set! idx (+ idx 1))))\n        ; Sort films by end time\n        (set! films (sort films (λ (a b) (< (cdr a) (cdr b)))))\n        ; Count non-overlapping films\n        (let ([last-end-time -1]\n              [count 0])\n          (for ([film films])\n            (when (>= (car film) last-end-time)\n              (set! last-end-time (cdr film))\n              (set! count (+ count 1))))\n          (set! results (cons count results)))))\n    (reverse results)))\n\n\n(define (test-max-non-overlapping-films)\n  (unless (equal? (max-non-overlapping-films \n                   '(1 3 (\"10:00\" \"10:30\") (\"09:00\" \"09:30\") (\"10:30\" \"11:00\")))\n                  '(3))\n    (error \"Test 1 failed\"))\n  (unless (equal? (max-non-overlapping-films \n                   '(2 2 (\"14:00\" \"15:00\") (\"15:00\" \"16:00\") \n                       3 (\"09:00\" \"10:00\") (\"09:30\" \"10:30\") (\"10:00\" \"11:00\")))\n                  '(2 2))\n    (error \"Test 2 failed\"))\n  (unless (equal? (max-non-overlapping-films \n                   '(1 4 (\"08:00\" \"09:00\") (\"08:30\" \"09:30\") (\"09:30\" \"10:00\") (\"10:00\" \"11:00\")))\n                  '(3))\n    (error \"Test 3 failed\")))\n\n(test-max-non-overlapping-films)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; min-operations-to-balance calculates the minimum operations required to balance candies among employees.\n; M: total number of candies\n; N: total number of employees\n; If M < N, it returns the difference (N - M) since each employee needs at least one candy.\n; If M >= N, it calculates the remainder of M divided by N and returns the minimum between the remainder and (N - remainder).\n(define (min-operations-to-balance M N)\n  (if (< M N)\n      (- N M)\n      (let ([r (remainder M N)])\n        (min r (- N r)))))", "test_cases": "", "test_case_results": "Input: M=5, N=3\nResult: 1\nInput: M=10, N=4\nResult: 2\nInput: M=2, N=5\nResult: 3\nInput: M=8, N=2\nResult: 0\nInput: M=7, N=7\nResult: 0", "task_id": 5979, "assertions": "#lang racket\n\n(define (test-min-operations-to-balance)\n  (unless (= (min-operations-to-balance 5 3) 1)\n    (error \"Test case (5 3) failed\"))\n  (unless (= (min-operations-to-balance 10 4) 2)\n    (error \"Test case (10 4) failed\"))\n  (unless (= (min-operations-to-balance 2 5) 3)\n    (error \"Test case (2 5) failed\"))\n  (unless (= (min-operations-to-balance 8 2) 0)\n    (error \"Test case (8 2) failed\"))\n  (unless (= (min-operations-to-balance 7 7) 0)\n    (error \"Test case (7 7) failed\")))\n\n(test-min-operations-to-balance)", "all_code": "#lang racket\n\n\n; min-operations-to-balance calculates the minimum operations required to balance candies among employees.\n; M: total number of candies\n; N: total number of employees\n; If M < N, it returns the difference (N - M) since each employee needs at least one candy.\n; If M >= N, it calculates the remainder of M divided by N and returns the minimum between the remainder and (N - remainder).\n(define (min-operations-to-balance M N)\n  (if (< M N)\n      (- N M)\n      (let ([r (remainder M N)])\n        (min r (- N r)))))\n\n\n(define (test-min-operations-to-balance)\n  (unless (= (min-operations-to-balance 5 3) 1)\n    (error \"Test case (5 3) failed\"))\n  (unless (= (min-operations-to-balance 10 4) 2)\n    (error \"Test case (10 4) failed\"))\n  (unless (= (min-operations-to-balance 2 5) 3)\n    (error \"Test case (2 5) failed\"))\n  (unless (= (min-operations-to-balance 8 2) 0)\n    (error \"Test case (8 2) failed\"))\n  (unless (= (min-operations-to-balance 7 7) 0)\n    (error \"Test case (7 7) failed\")))\n\n(test-min-operations-to-balance)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for list operations\n(require srfi/1) ; For list operations like cumsum, diff, etc.\n\n; array-operations takes a string representing a matrix and performs three operations:\n; 1. Cumulative sum along each row (axis=1)\n; 2. Difference between consecutive rows (axis=0)\n; 3. Product of elements in each row (axis=1)\n; The input string should have rows separated by semicolons and elements separated by spaces.\n(define (array-operations input-str)\n  (let* ([rows (string-split input-str \";\")]\n         [B (map (lambda (row) (map string->number (string-split row))) rows)])\n    (values (cumsum-rows B)\n            (diff-rows B)\n            (prod-rows B))))\n\n; cumsum-rows computes the cumulative sum along each row of a matrix\n(define (cumsum-rows matrix)\n  (map (lambda (row) (fold-right (lambda (x acc) (cons x (map + acc (make-list (length acc) x)))) '() row)) matrix))\n\n; diff-rows computes the difference between consecutive rows of a matrix\n(define (diff-rows matrix)\n  (if (<= (length matrix) 1)\n      '()\n      (map (lambda (row1 row2) (map - row2 row1)) (drop-right matrix 1) (cdr matrix))))\n\n; prod-rows computes the product of elements in each row of a matrix\n(define (prod-rows matrix)\n  (map (lambda (row) (foldl * 1 row)) matrix))", "test_cases": "", "test_case_results": "Input: 1 2 3;4 5 6\nCumulative Sum: ((1 3 6) (4 9 15))\nRow Differences: ((3 3 3))\nRow Products: (6 120)\nInput: 1 0 1;0 1 0;1 0 1\nCumulative Sum: ((1 1 2) (0 1 1) (1 1 2))\nRow Differences: ((-1 1 -1) (1 -1 1))\nRow Products: (0 0 0)\nInput: 10 20;30 40\nCumulative Sum: ((10 30) (30 70))\nRow Differences: ((20 20))\nRow Products: (200 1200)", "task_id": 2631, "assertions": "#lang racket\n\n(require srfi/1)\n\n(define (test-array-operations)\n  (let-values ([(cumsum1 diff1 prod1) (array-operations \"1 2 3;4 5 6\")])\n    (unless (equal? cumsum1 '((1 3 6) (4 9 15)))\n      (error \"Cumulative Sum Test 1 failed\"))\n    (unless (equal? diff1 '((3 3 3)))\n      (error \"Row Differences Test 1 failed\"))\n    (unless (equal? prod1 '(6 120))\n      (error \"Row Products Test 1 failed\")))\n  \n  (let-values ([(cumsum2 diff2 prod2) (array-operations \"1 0 1;0 1 0;1 0 1\")])\n    (unless (equal? cumsum2 '((1 1 2) (0 1 1) (1 1 2)))\n      (error \"Cumulative Sum Test 2 failed\"))\n    (unless (equal? diff2 '((-1 1 -1) (1 -1 1)))\n      (error \"Row Differences Test 2 failed\"))\n    (unless (equal? prod2 '(0 0 0))\n      (error \"Row Products Test 2 failed\")))\n  \n  (let-values ([(cumsum3 diff3 prod3) (array-operations \"10 20;30 40\")])\n    (unless (equal? cumsum3 '((10 30) (30 70)))\n      (error \"Cumulative Sum Test 3 failed\"))\n    (unless (equal? diff3 '((20 20)))\n      (error \"Row Differences Test 3 failed\"))\n    (unless (equal? prod3 '(200 1200))\n      (error \"Row Products Test 3 failed\"))))\n\n(test-array-operations)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for list operations\n(require srfi/1) ; For list operations like cumsum, diff, etc.\n\n; array-operations takes a string representing a matrix and performs three operations:\n; 1. Cumulative sum along each row (axis=1)\n; 2. Difference between consecutive rows (axis=0)\n; 3. Product of elements in each row (axis=1)\n; The input string should have rows separated by semicolons and elements separated by spaces.\n(define (array-operations input-str)\n  (let* ([rows (string-split input-str \";\")]\n         [B (map (lambda (row) (map string->number (string-split row))) rows)])\n    (values (cumsum-rows B)\n            (diff-rows B)\n            (prod-rows B))))\n\n; cumsum-rows computes the cumulative sum along each row of a matrix\n(define (cumsum-rows matrix)\n  (map (lambda (row) (fold-right (lambda (x acc) (cons x (map + acc (make-list (length acc) x)))) '() row)) matrix))\n\n; diff-rows computes the difference between consecutive rows of a matrix\n(define (diff-rows matrix)\n  (if (<= (length matrix) 1)\n      '()\n      (map (lambda (row1 row2) (map - row2 row1)) (drop-right matrix 1) (cdr matrix))))\n\n; prod-rows computes the product of elements in each row of a matrix\n(define (prod-rows matrix)\n  (map (lambda (row) (foldl * 1 row)) matrix))\n\n\n(require srfi/1)\n\n(define (test-array-operations)\n  (let-values ([(cumsum1 diff1 prod1) (array-operations \"1 2 3;4 5 6\")])\n    (unless (equal? cumsum1 '((1 3 6) (4 9 15)))\n      (error \"Cumulative Sum Test 1 failed\"))\n    (unless (equal? diff1 '((3 3 3)))\n      (error \"Row Differences Test 1 failed\"))\n    (unless (equal? prod1 '(6 120))\n      (error \"Row Products Test 1 failed\")))\n  \n  (let-values ([(cumsum2 diff2 prod2) (array-operations \"1 0 1;0 1 0;1 0 1\")])\n    (unless (equal? cumsum2 '((1 1 2) (0 1 1) (1 1 2)))\n      (error \"Cumulative Sum Test 2 failed\"))\n    (unless (equal? diff2 '((-1 1 -1) (1 -1 1)))\n      (error \"Row Differences Test 2 failed\"))\n    (unless (equal? prod2 '(0 0 0))\n      (error \"Row Products Test 2 failed\")))\n  \n  (let-values ([(cumsum3 diff3 prod3) (array-operations \"10 20;30 40\")])\n    (unless (equal? cumsum3 '((10 30) (30 70)))\n      (error \"Cumulative Sum Test 3 failed\"))\n    (unless (equal? diff3 '((20 20)))\n      (error \"Row Differences Test 3 failed\"))\n    (unless (equal? prod3 '(200 1200))\n      (error \"Row Products Test 3 failed\"))))\n\n(test-array-operations)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; filter-unique-strings filters a list of strings to remove duplicates (case-insensitive) and empty strings.\n; It returns a new list keeping the first occurrence of each unique string (case-insensitive).\n; The function uses a set to keep track of seen strings in lowercase form.\n(define (filter-unique-strings strings)\n  (let loop ([remaining strings]\n             [seen (set)]\n             [result '()])\n    (if (empty? remaining)\n        (reverse result)\n        (let* ([s (first remaining)]\n               [s-lower (and (string? s) (string-downcase s))])\n          (if (and s (not (set-member? seen s-lower)))\n              (loop (rest remaining) (set-add seen s-lower) (cons s result))\n              (loop (rest remaining) seen result))))))", "test_cases": "", "test_case_results": "Input: (Apple banana apple Banana  cherry)\nFiltered: (Apple banana  cherry)\nInput: (hello Hello HELLO world WORLD )\nFiltered: (hello world )\nInput: (a b A c B d)\nFiltered: (a b c d)", "task_id": 16876, "assertions": "#lang racket\n\n(define (test-filter-unique-strings)\n  (unless (equal? (filter-unique-strings '(\"Apple\" \"banana\" \"apple\" \"Banana\" \"\" \"cherry\")) \n                  '(\"Apple\" \"banana\" \"cherry\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (filter-unique-strings '(\"hello\" \"Hello\" \"HELLO\" \"world\" \"WORLD\" \"\")) \n                  '(\"hello\" \"world\"))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (filter-unique-strings '(\"a\" \"b\" \"A\" \"c\" \"B\" \"d\")) \n                  '(\"a\" \"b\" \"c\" \"d\"))\n    (error \"Test case 3 failed\")))\n\n(test-filter-unique-strings)", "all_code": "#lang racket\n\n\n; filter-unique-strings filters a list of strings to remove duplicates (case-insensitive) and empty strings.\n; It returns a new list keeping the first occurrence of each unique string (case-insensitive).\n; The function uses a set to keep track of seen strings in lowercase form.\n(define (filter-unique-strings strings)\n  (let loop ([remaining strings]\n             [seen (set)]\n             [result '()])\n    (if (empty? remaining)\n        (reverse result)\n        (let* ([s (first remaining)]\n               [s-lower (and (string? s) (string-downcase s))])\n          (if (and s (not (set-member? seen s-lower)))\n              (loop (rest remaining) (set-add seen s-lower) (cons s result))\n              (loop (rest remaining) seen result))))))\n\n\n(define (test-filter-unique-strings)\n  (unless (equal? (filter-unique-strings '(\"Apple\" \"banana\" \"apple\" \"Banana\" \"\" \"cherry\")) \n                  '(\"Apple\" \"banana\" \"cherry\"))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (filter-unique-strings '(\"hello\" \"Hello\" \"HELLO\" \"world\" \"WORLD\" \"\")) \n                  '(\"hello\" \"world\"))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (filter-unique-strings '(\"a\" \"b\" \"A\" \"c\" \"B\" \"d\")) \n                  '(\"a\" \"b\" \"c\" \"d\"))\n    (error \"Test case 3 failed\")))\n\n(test-filter-unique-strings)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; form-array-b constructs a new list 'b' for each test case where each element of 'b' is the product of elements in 'a' at positions i and (i + k) mod n.\n; n: length of the list 'a'\n; k: the offset for the second element in the product\n; a: the input list of numbers\n(define (form-array-b n k a)\n  (for/list ([i (in-range n)])\n    (* (list-ref a i) (list-ref a (modulo (+ i k) n)))))\n\n; parse-input processes the input string into a list of test cases.\n; Each test case is represented as a list (n k a), where:\n; n: length of the list 'a'\n; k: the offset for the second element in the product\n; a: the input list of numbers\n; The input string is expected to have the following format:\n; First line: T (number of test cases)\n; Subsequent lines: For each test case, two lines:\n;   First line: n and k separated by a space\n;   Second line: list 'a' as space-separated integers\n(define (parse-input input-data)\n  (let* ([lines (string-split input-data \"\\n\")]\n         [t (string->number (first lines))]\n         [test-cases '()])\n    (let loop ([line-index 1] [remaining t])\n      (if (zero? remaining)\n          test-cases\n          (let* ([n-k (string-split (list-ref lines line-index))]\n                 [n (string->number (first n-k))]\n                 [k (string->number (second n-k))]\n                 [a (map string->number (string-split (list-ref lines (add1 line-index))))])\n            (loop (+ line-index 2) (sub1 remaining) (cons (list n k a) test-cases)))))))", "test_cases": "", "test_case_results": "Input: n=4, k=1, a=(1 2 3 4)\nOutput: b=(2 6 12 4)\n\nInput: n=3, k=2, a=(5 6 7)\nOutput: b=(35 30 42)\n\nInput: n=5, k=3, a=(0 1 0 1 0)\nOutput: b=(0 0 0 1 0)", "task_id": 4052, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-form-array-b)\n  (let ([test-cases '(((4 1 (1 2 3 4)) (2 6 12 4))\n                      ((3 2 (5 6 7)) (35 30 42))\n                      ((5 3 (0 1 0 1 0)) (0 0 0 1 0)))])\n    (for ([test-case test-cases])\n      (let* ([input (first test-case)]\n             [expected (second test-case)]\n             [n (first input)]\n             [k (second input)]\n             [a (third input)]\n             [actual (form-array-b n k a)])\n        (unless (equal? actual expected)\n          (error (format \"Test failed for input n=~a, k=~a, a=~a. Expected ~a, got ~a\"\n                         n k a expected actual)))))))\n\n(test-form-array-b)", "all_code": "#lang racket\n\n\n; form-array-b constructs a new list 'b' for each test case where each element of 'b' is the product of elements in 'a' at positions i and (i + k) mod n.\n; n: length of the list 'a'\n; k: the offset for the second element in the product\n; a: the input list of numbers\n(define (form-array-b n k a)\n  (for/list ([i (in-range n)])\n    (* (list-ref a i) (list-ref a (modulo (+ i k) n)))))\n\n; parse-input processes the input string into a list of test cases.\n; Each test case is represented as a list (n k a), where:\n; n: length of the list 'a'\n; k: the offset for the second element in the product\n; a: the input list of numbers\n; The input string is expected to have the following format:\n; First line: T (number of test cases)\n; Subsequent lines: For each test case, two lines:\n;   First line: n and k separated by a space\n;   Second line: list 'a' as space-separated integers\n(define (parse-input input-data)\n  (let* ([lines (string-split input-data \"\\n\")]\n         [t (string->number (first lines))]\n         [test-cases '()])\n    (let loop ([line-index 1] [remaining t])\n      (if (zero? remaining)\n          test-cases\n          (let* ([n-k (string-split (list-ref lines line-index))]\n                 [n (string->number (first n-k))]\n                 [k (string->number (second n-k))]\n                 [a (map string->number (string-split (list-ref lines (add1 line-index))))])\n            (loop (+ line-index 2) (sub1 remaining) (cons (list n k a) test-cases)))))))\n\n\n(require rackunit)\n\n(define (test-form-array-b)\n  (let ([test-cases '(((4 1 (1 2 3 4)) (2 6 12 4))\n                      ((3 2 (5 6 7)) (35 30 42))\n                      ((5 3 (0 1 0 1 0)) (0 0 0 1 0)))])\n    (for ([test-case test-cases])\n      (let* ([input (first test-case)]\n             [expected (second test-case)]\n             [n (first input)]\n             [k (second input)]\n             [a (third input)]\n             [actual (form-array-b n k a)])\n        (unless (equal? actual expected)\n          (error (format \"Test failed for input n=~a, k=~a, a=~a. Expected ~a, got ~a\"\n                         n k a expected actual)))))))\n\n(test-form-array-b)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; yearly-sales-data extracts the years and sales amounts from a sales data dictionary.\n; The input is expected to be an association list where keys are years and values are sales amounts.\n; Returns two lists: years and sales amounts in the same order as the input.\n(define (yearly-sales-data sales-data)\n  (values (map car sales-data) (map cdr sales-data)))", "test_cases": "", "test_case_results": "Input sales data: ((2018 . 50000) (2019 . 55000) (2020 . 52000) (2021 . 60000))\nYears: (2018 2019 2020 2021)\nSales amounts: (50000 55000 52000 60000)\n\nInput sales data: ((2015 . 80000) (2016 . 75000) (2017 . 70000) (2018 . 65000))\nYears: (2015 2016 2017 2018)\nSales amounts: (80000 75000 70000 65000)\n\nInput sales data: ((2020 . 45000) (2021 . 45000) (2022 . 45000))\nYears: (2020 2021 2022)\nSales amounts: (45000 45000 45000)", "task_id": 13629, "assertions": "#lang racket\n\n(define (test-yearly-sales-data)\n  (let-values ([(years1 sales1) (yearly-sales-data '((2018 . 50000) (2019 . 55000) (2020 . 52000) (2021 . 60000)))])\n    (unless (equal? years1 '(2018 2019 2020 2021))\n      (error \"Test 1 years failed\"))\n    (unless (equal? sales1 '(50000 55000 52000 60000))\n      (error \"Test 1 sales failed\")))\n  \n  (let-values ([(years2 sales2) (yearly-sales-data '((2015 . 80000) (2016 . 75000) (2017 . 70000) (2018 . 65000)))])\n    (unless (equal? years2 '(2015 2016 2017 2018))\n      (error \"Test 2 years failed\"))\n    (unless (equal? sales2 '(80000 75000 70000 65000))\n      (error \"Test 2 sales failed\")))\n  \n  (let-values ([(years3 sales3) (yearly-sales-data '((2020 . 45000) (2021 . 45000) (2022 . 45000)))])\n    (unless (equal? years3 '(2020 2021 2022))\n      (error \"Test 3 years failed\"))\n    (unless (equal? sales3 '(45000 45000 45000))\n      (error \"Test 3 sales failed\"))))\n\n(test-yearly-sales-data)", "all_code": "#lang racket\n\n\n; yearly-sales-data extracts the years and sales amounts from a sales data dictionary.\n; The input is expected to be an association list where keys are years and values are sales amounts.\n; Returns two lists: years and sales amounts in the same order as the input.\n(define (yearly-sales-data sales-data)\n  (values (map car sales-data) (map cdr sales-data)))\n\n\n(define (test-yearly-sales-data)\n  (let-values ([(years1 sales1) (yearly-sales-data '((2018 . 50000) (2019 . 55000) (2020 . 52000) (2021 . 60000)))])\n    (unless (equal? years1 '(2018 2019 2020 2021))\n      (error \"Test 1 years failed\"))\n    (unless (equal? sales1 '(50000 55000 52000 60000))\n      (error \"Test 1 sales failed\")))\n  \n  (let-values ([(years2 sales2) (yearly-sales-data '((2015 . 80000) (2016 . 75000) (2017 . 70000) (2018 . 65000)))])\n    (unless (equal? years2 '(2015 2016 2017 2018))\n      (error \"Test 2 years failed\"))\n    (unless (equal? sales2 '(80000 75000 70000 65000))\n      (error \"Test 2 sales failed\")))\n  \n  (let-values ([(years3 sales3) (yearly-sales-data '((2020 . 45000) (2021 . 45000) (2022 . 45000)))])\n    (unless (equal? years3 '(2020 2021 2022))\n      (error \"Test 3 years failed\"))\n    (unless (equal? sales3 '(45000 45000 45000))\n      (error \"Test 3 sales failed\"))))\n\n(test-yearly-sales-data)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; sum-divisible-by-k calculates the sum of all elements in a list that are divisible by a given integer k.\n; It filters the list to include only elements divisible by k, then sums them up.\n; If the input list is empty, it returns 0.\n(define (sum-divisible-by-k arr k)\n  (apply + (filter (lambda (x) (= (modulo x k) 0)) arr)))", "test_cases": "", "test_case_results": "Input list: (1 2 3 4 5 6), Divisor: 2\nSum of elements divisible by 2: 12\nInput list: (10 15 20 25 30), Divisor: 5\nSum of elements divisible by 5: 100\nInput list: (0 0 0 0), Divisor: 3\nSum of elements divisible by 3: 0\nInput list: (7 11 13 17), Divisor: 2\nSum of elements divisible by 2: 0\nInput list: (), Divisor: 10\nSum of elements divisible by 10: 0", "task_id": 1043, "assertions": "#lang racket\n\n(define (test-sum-divisible-by-k)\n  (unless (= (sum-divisible-by-k '(1 2 3 4 5 6) 2) 12)\n    (error \"Test case 1 failed\"))\n  (unless (= (sum-divisible-by-k '(10 15 20 25 30) 5) 100)\n    (error \"Test case 2 failed\"))\n  (unless (= (sum-divisible-by-k '(0 0 0 0) 3) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (sum-divisible-by-k '(7 11 13 17) 2) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (sum-divisible-by-k '() 10) 0)\n    (error \"Test case 5 failed\")))\n\n(test-sum-divisible-by-k)", "all_code": "#lang racket\n\n\n; sum-divisible-by-k calculates the sum of all elements in a list that are divisible by a given integer k.\n; It filters the list to include only elements divisible by k, then sums them up.\n; If the input list is empty, it returns 0.\n(define (sum-divisible-by-k arr k)\n  (apply + (filter (lambda (x) (= (modulo x k) 0)) arr)))\n\n\n(define (test-sum-divisible-by-k)\n  (unless (= (sum-divisible-by-k '(1 2 3 4 5 6) 2) 12)\n    (error \"Test case 1 failed\"))\n  (unless (= (sum-divisible-by-k '(10 15 20 25 30) 5) 100)\n    (error \"Test case 2 failed\"))\n  (unless (= (sum-divisible-by-k '(0 0 0 0) 3) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (sum-divisible-by-k '(7 11 13 17) 2) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (sum-divisible-by-k '() 10) 0)\n    (error \"Test case 5 failed\")))\n\n(test-sum-divisible-by-k)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Segment Tree implementation in Racket for range minimum queries.\n; The segment tree is a data structure that allows efficient range queries and updates.\n; This implementation focuses on the range minimum query (RMQ) functionality.\n\n; A segment-tree is a struct that holds the size of the original array (n) and the tree itself.\n(struct segment-tree (n tree))\n\n; build-segment-tree constructs a segment tree from a given list of numbers.\n; The tree is represented as a vector where leaves are the original array elements,\n; and internal nodes store the minimum of their children.\n(define (build-segment-tree arr)\n  (let* ([n (length arr)]\n         [tree (make-vector (* 2 n) +inf.0)]) ; Initialize with infinity for min calculations\n    ; Fill the leaves with the original array elements\n    (for ([i (in-range n)])\n      (vector-set! tree (+ n i) (list-ref arr i)))\n    ; Build the internal nodes by computing minima\n    (for ([i (in-range (sub1 n) 0 -1)])\n      (vector-set! tree i (min (vector-ref tree (* 2 i))\n                               (vector-ref tree (add1 (* 2 i))))))\n    (segment-tree n tree)))\n\n; query-min queries the minimum value in the range [L, R] (0-based, inclusive) in the segment tree.\n; The function uses the segment tree's structure to efficiently compute the minimum in logarithmic time.\n(define (query-min st L R)\n  (let ([n (segment-tree-n st)]\n        [tree (segment-tree-tree st)])\n    (let loop ([L (+ L n)]\n               [R (+ R n)]\n               [minimum +inf.0])\n      (cond\n        [(> L R) minimum]\n        [else\n         (let ([new-min minimum])\n           (when (odd? L)\n             (set! new-min (min new-min (vector-ref tree L)))\n             (set! L (add1 L)))\n           (when (even? R)\n             (set! new-min (min new-min (vector-ref tree R)))\n             (set! R (sub1 R)))\n           (loop (quotient L 2) (quotient R 2) new-min))]))))", "test_cases": "", "test_case_results": "Original array: (1 3 2 5 4 6 8 7)\nQuery range [0, 7]: Minimum = 1.0\nQuery range [1, 3]: Minimum = 2.0\nQuery range [2, 5]: Minimum = 2.0\nQuery range [4, 6]: Minimum = 4.0\nQuery range [0, 0]: Minimum = 1.0\nQuery range [7, 7]: Minimum = 7.0", "task_id": 14805, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-segment-tree)\n  (define test-array '(1 3 2 5 4 6 8 7))\n  (define st (build-segment-tree test-array))\n  \n  (unless (equal? (query-min st 0 7) 1.0)\n    (error \"Test case [0,7] failed\"))\n  (unless (equal? (query-min st 1 3) 2.0)\n    (error \"Test case [1,3] failed\"))\n  (unless (equal? (query-min st 2 5) 2.0)\n    (error \"Test case [2,5] failed\"))\n  (unless (equal? (query-min st 4 6) 4.0)\n    (error \"Test case [4,6] failed\"))\n  (unless (equal? (query-min st 0 0) 1.0)\n    (error \"Test case [0,0] failed\"))\n  (unless (equal? (query-min st 7 7) 7.0)\n    (error \"Test case [7,7] failed\"))\n  \n  (displayln \"All tests passed!\"))\n\n(test-segment-tree)", "all_code": "#lang racket\n\n\n; Segment Tree implementation in Racket for range minimum queries.\n; The segment tree is a data structure that allows efficient range queries and updates.\n; This implementation focuses on the range minimum query (RMQ) functionality.\n\n; A segment-tree is a struct that holds the size of the original array (n) and the tree itself.\n(struct segment-tree (n tree))\n\n; build-segment-tree constructs a segment tree from a given list of numbers.\n; The tree is represented as a vector where leaves are the original array elements,\n; and internal nodes store the minimum of their children.\n(define (build-segment-tree arr)\n  (let* ([n (length arr)]\n         [tree (make-vector (* 2 n) +inf.0)]) ; Initialize with infinity for min calculations\n    ; Fill the leaves with the original array elements\n    (for ([i (in-range n)])\n      (vector-set! tree (+ n i) (list-ref arr i)))\n    ; Build the internal nodes by computing minima\n    (for ([i (in-range (sub1 n) 0 -1)])\n      (vector-set! tree i (min (vector-ref tree (* 2 i))\n                               (vector-ref tree (add1 (* 2 i))))))\n    (segment-tree n tree)))\n\n; query-min queries the minimum value in the range [L, R] (0-based, inclusive) in the segment tree.\n; The function uses the segment tree's structure to efficiently compute the minimum in logarithmic time.\n(define (query-min st L R)\n  (let ([n (segment-tree-n st)]\n        [tree (segment-tree-tree st)])\n    (let loop ([L (+ L n)]\n               [R (+ R n)]\n               [minimum +inf.0])\n      (cond\n        [(> L R) minimum]\n        [else\n         (let ([new-min minimum])\n           (when (odd? L)\n             (set! new-min (min new-min (vector-ref tree L)))\n             (set! L (add1 L)))\n           (when (even? R)\n             (set! new-min (min new-min (vector-ref tree R)))\n             (set! R (sub1 R)))\n           (loop (quotient L 2) (quotient R 2) new-min))]))))\n\n\n(require rackunit)\n\n(define (test-segment-tree)\n  (define test-array '(1 3 2 5 4 6 8 7))\n  (define st (build-segment-tree test-array))\n  \n  (unless (equal? (query-min st 0 7) 1.0)\n    (error \"Test case [0,7] failed\"))\n  (unless (equal? (query-min st 1 3) 2.0)\n    (error \"Test case [1,3] failed\"))\n  (unless (equal? (query-min st 2 5) 2.0)\n    (error \"Test case [2,5] failed\"))\n  (unless (equal? (query-min st 4 6) 4.0)\n    (error \"Test case [4,6] failed\"))\n  (unless (equal? (query-min st 0 0) 1.0)\n    (error \"Test case [0,0] failed\"))\n  (unless (equal? (query-min st 7 7) 7.0)\n    (error \"Test case [7,7] failed\"))\n  \n  (displayln \"All tests passed!\"))\n\n(test-segment-tree)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; schedule-tasks sorts a list of tasks based on their priority (descending) and their original order in the input.\n; Each task is represented as a list of three elements: (id duration priority).\n; The function returns a list of task IDs in the order they should be executed.\n(define (schedule-tasks tasks)\n  ; First, sort by priority in descending order\n  ; If priorities are equal, maintain the original order (stable sort)\n  (define sorted-tasks\n    (sort tasks\n          (lambda (a b)\n            (let ([priority-a (third a)]\n                  [priority-b (third b)])\n              (if (= priority-a priority-b)\n                  (< (index-of tasks a) (index-of tasks b))\n                  (> priority-a priority-b))))))\n  ; Extract the task IDs from the sorted list\n  (map first sorted-tasks))", "test_cases": "", "test_case_results": "Input tasks: ((1 10 3) (2 5 1) (3 7 2))\nExecution order: (1 3 2)\nInput tasks: ((1 10 2) (2 5 2) (3 7 2))\nExecution order: (1 2 3)\nInput tasks: ((1 10 1) (2 5 3) (3 7 2))\nExecution order: (2 3 1)\nInput tasks: ((1 10 5))\nExecution order: (1)\nInput tasks: ()\nExecution order: ()", "task_id": 16520, "assertions": "#lang racket\n\n(define (test-schedule-tasks)\n  (unless (equal? (schedule-tasks '((1 10 3) (2 5 1) (3 7 2))) '(1 3 2))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 2) (2 5 2) (3 7 2))) '(1 2 3))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 1) (2 5 3) (3 7 2))) '(2 3 1))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 5))) '(1))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (schedule-tasks '()) '())\n    (error \"Test case 5 failed\")))\n\n(test-schedule-tasks)", "all_code": "#lang racket\n\n\n; schedule-tasks sorts a list of tasks based on their priority (descending) and their original order in the input.\n; Each task is represented as a list of three elements: (id duration priority).\n; The function returns a list of task IDs in the order they should be executed.\n(define (schedule-tasks tasks)\n  ; First, sort by priority in descending order\n  ; If priorities are equal, maintain the original order (stable sort)\n  (define sorted-tasks\n    (sort tasks\n          (lambda (a b)\n            (let ([priority-a (third a)]\n                  [priority-b (third b)])\n              (if (= priority-a priority-b)\n                  (< (index-of tasks a) (index-of tasks b))\n                  (> priority-a priority-b))))))\n  ; Extract the task IDs from the sorted list\n  (map first sorted-tasks))\n\n\n(define (test-schedule-tasks)\n  (unless (equal? (schedule-tasks '((1 10 3) (2 5 1) (3 7 2))) '(1 3 2))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 2) (2 5 2) (3 7 2))) '(1 2 3))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 1) (2 5 3) (3 7 2))) '(2 3 1))\n    (error \"Test case 3 failed\"))\n  (unless (equal? (schedule-tasks '((1 10 5))) '(1))\n    (error \"Test case 4 failed\"))\n  (unless (equal? (schedule-tasks '()) '())\n    (error \"Test case 5 failed\")))\n\n(test-schedule-tasks)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; count-cells-with-greater-neighbors counts the number of cells in a matrix that have at least one neighboring cell\n; (including diagonals) with a greater value. The function checks all 8 possible neighbors for each cell.\n; If the matrix is empty, it returns 0.\n(define (count-cells-with-greater-neighbors matrix)\n  (if (or (empty? matrix) (empty? (car matrix)))\n      0\n      (let ([m (length matrix)]\n            [n (length (car matrix))])\n        (let loop ([i 0]\n                   [j 0]\n                   [count 0])\n          (cond [(>= i m) count]\n                [(>= j n) (loop (add1 i) 0 count)]\n                [else\n                 (let ([current-value (list-ref (list-ref matrix i) j)]\n                       [directions '((-1 0) (1 0) (0 -1) (0 1) (-1 -1) (-1 1) (1 -1) (1 1))])\n                   (let check-neighbors ([dirs directions]\n                                         [found? #f])\n                     (cond [(or found? (empty? dirs)) \n                            (loop i (add1 j) (if found? (add1 count) count))]\n                           [else \n                            (let* ([di (caar dirs)]\n                                   [dj (cadar dirs)]\n                                   [ni (+ i di)]\n                                   [nj (+ j dj)])\n                              (if (and (>= ni 0) (< ni m) (>= nj 0) (< nj n)\n                                       (> (list-ref (list-ref matrix ni) nj) current-value))\n                                  (check-neighbors (cdr dirs) #t)\n                                  (check-neighbors (cdr dirs) found?)))])))])))))", "test_cases": "", "test_case_results": "Input: ((1 2 3) (4 5 6) (7 8 9))\nCount: 8\nInput: ((5 5) (5 5))\nCount: 0\nInput: ((1))\nCount: 0\nInput: ()\nCount: 0\nInput: ((1 2) (3 4))\nCount: 3", "task_id": 2468, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-count-cells-with-greater-neighbors)\n  (unless (= (count-cells-with-greater-neighbors '((1 2 3) (4 5 6) (7 8 9))) 8)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((5 5) (5 5))) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((1))) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '()) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((1 2) (3 4))) 3)\n    (error \"Test case 5 failed\")))\n\n(test-count-cells-with-greater-neighbors)", "all_code": "#lang racket\n\n\n; count-cells-with-greater-neighbors counts the number of cells in a matrix that have at least one neighboring cell\n; (including diagonals) with a greater value. The function checks all 8 possible neighbors for each cell.\n; If the matrix is empty, it returns 0.\n(define (count-cells-with-greater-neighbors matrix)\n  (if (or (empty? matrix) (empty? (car matrix)))\n      0\n      (let ([m (length matrix)]\n            [n (length (car matrix))])\n        (let loop ([i 0]\n                   [j 0]\n                   [count 0])\n          (cond [(>= i m) count]\n                [(>= j n) (loop (add1 i) 0 count)]\n                [else\n                 (let ([current-value (list-ref (list-ref matrix i) j)]\n                       [directions '((-1 0) (1 0) (0 -1) (0 1) (-1 -1) (-1 1) (1 -1) (1 1))])\n                   (let check-neighbors ([dirs directions]\n                                         [found? #f])\n                     (cond [(or found? (empty? dirs)) \n                            (loop i (add1 j) (if found? (add1 count) count))]\n                           [else \n                            (let* ([di (caar dirs)]\n                                   [dj (cadar dirs)]\n                                   [ni (+ i di)]\n                                   [nj (+ j dj)])\n                              (if (and (>= ni 0) (< ni m) (>= nj 0) (< nj n)\n                                       (> (list-ref (list-ref matrix ni) nj) current-value))\n                                  (check-neighbors (cdr dirs) #t)\n                                  (check-neighbors (cdr dirs) found?)))])))])))))\n\n\n(require rackunit)\n\n(define (test-count-cells-with-greater-neighbors)\n  (unless (= (count-cells-with-greater-neighbors '((1 2 3) (4 5 6) (7 8 9))) 8)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((5 5) (5 5))) 0)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((1))) 0)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '()) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (count-cells-with-greater-neighbors '((1 2) (3 4))) 3)\n    (error \"Test case 5 failed\")))\n\n(test-count-cells-with-greater-neighbors)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for string manipulation and formatting\n(require racket/string\n         racket/format)\n\n; days-of-week is a list of the days of the week in order.\n(define days-of-week '(\"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\" \"Sunday\"))\n\n; parse-time-string takes a time string in the format \"Day HH:MM\" and returns\n; the day index (0-6), hour, and minute as three separate values.\n(define (parse-time-string time-str)\n  (let* ([parts (string-split time-str)]\n         [day (first parts)]\n         [time (second parts)]\n         [day-index (index-of days-of-week day)]\n         [time-parts (string-split time \":\")]\n         [hour (string->number (first time-parts))]\n         [minute (string->number (second time-parts))])\n    (values day-index hour minute)))\n\n; next-reminder takes a current time string and a list of time slots,\n; and returns the next upcoming time slot in the same format.\n; If no slots are found later in the week, it returns the earliest slot next week.\n(define (next-reminder current-time-str slots)\n  (let-values ([(current-day-index current-hour current-minute) (parse-time-string current-time-str)])\n    (let* ([current-time-in-week (+ (* current-day-index 24 60) (* current-hour 60) current-minute)]\n           [slots-in-minutes\n            (for/list ([slot slots])\n              (let-values ([(day-index hour minute) (parse-time-string slot)])\n                (+ (* day-index 24 60) (* hour 60) minute)))]\n           [sorted-slots (sort slots-in-minutes <)]\n           [next-slot\n            (for/first ([slot sorted-slots]\n                        #:when (> slot current-time-in-week))\n              slot)])\n      (if next-slot\n          (let* ([day-index (quotient next-slot (* 24 60))]\n                 [time-in-day (remainder next-slot (* 24 60))]\n                 [hour (quotient time-in-day 60)]\n                 [minute (remainder time-in-day 60)])\n            (~a (list-ref days-of-week day-index) \" \" (~a hour #:min-width 2 #:pad-string \"0\" #:align 'right) \":\" (~a minute #:min-width 2 #:pad-string \"0\" #:align 'right)))\n          (let* ([earliest-slot (first sorted-slots)]\n                 [day-index (quotient earliest-slot (* 24 60))]\n                 [time-in-day (remainder earliest-slot (* 24 60))]\n                 [hour (quotient time-in-day 60)]\n                 [minute (remainder time-in-day 60)])\n            (~a (list-ref days-of-week day-index) \" \" (~a hour #:min-width 2 #:pad-string \"0\" #:align 'right) \":\" (~a minute #:min-width 2 #:pad-string \"0\" #:align 'right)))))))", "test_cases": "", "test_case_results": "Current Time: Monday 08:00\nSlots: (Monday 09:00 Tuesday 10:00 Wednesday 12:00)\nNext Reminder: Monday 09:00\n\nCurrent Time: Friday 23:00\nSlots: (Monday 08:00 Saturday 00:00 Sunday 12:00)\nNext Reminder: Saturday 00:00\n\nCurrent Time: Sunday 23:59\nSlots: (Monday 00:00 Tuesday 08:00)\nNext Reminder: Monday 00:00", "task_id": 27750, "assertions": "#lang racket\n\n(require racket/string\n         racket/format)\n\n(define (test-next-reminder)\n  (unless (equal? (next-reminder \"Monday 08:00\" '(\"Monday 09:00\" \"Tuesday 10:00\" \"Wednesday 12:00\")) \"Monday 09:00\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (next-reminder \"Friday 23:00\" '(\"Monday 08:00\" \"Saturday 00:00\" \"Sunday 12:00\")) \"Saturday 00:00\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (next-reminder \"Sunday 23:59\" '(\"Monday 00:00\" \"Tuesday 08:00\")) \"Monday 00:00\")\n    (error \"Test 3 failed\")))\n\n(test-next-reminder)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for string manipulation and formatting\n(require racket/string\n         racket/format)\n\n; days-of-week is a list of the days of the week in order.\n(define days-of-week '(\"Monday\" \"Tuesday\" \"Wednesday\" \"Thursday\" \"Friday\" \"Saturday\" \"Sunday\"))\n\n; parse-time-string takes a time string in the format \"Day HH:MM\" and returns\n; the day index (0-6), hour, and minute as three separate values.\n(define (parse-time-string time-str)\n  (let* ([parts (string-split time-str)]\n         [day (first parts)]\n         [time (second parts)]\n         [day-index (index-of days-of-week day)]\n         [time-parts (string-split time \":\")]\n         [hour (string->number (first time-parts))]\n         [minute (string->number (second time-parts))])\n    (values day-index hour minute)))\n\n; next-reminder takes a current time string and a list of time slots,\n; and returns the next upcoming time slot in the same format.\n; If no slots are found later in the week, it returns the earliest slot next week.\n(define (next-reminder current-time-str slots)\n  (let-values ([(current-day-index current-hour current-minute) (parse-time-string current-time-str)])\n    (let* ([current-time-in-week (+ (* current-day-index 24 60) (* current-hour 60) current-minute)]\n           [slots-in-minutes\n            (for/list ([slot slots])\n              (let-values ([(day-index hour minute) (parse-time-string slot)])\n                (+ (* day-index 24 60) (* hour 60) minute)))]\n           [sorted-slots (sort slots-in-minutes <)]\n           [next-slot\n            (for/first ([slot sorted-slots]\n                        #:when (> slot current-time-in-week))\n              slot)])\n      (if next-slot\n          (let* ([day-index (quotient next-slot (* 24 60))]\n                 [time-in-day (remainder next-slot (* 24 60))]\n                 [hour (quotient time-in-day 60)]\n                 [minute (remainder time-in-day 60)])\n            (~a (list-ref days-of-week day-index) \" \" (~a hour #:min-width 2 #:pad-string \"0\" #:align 'right) \":\" (~a minute #:min-width 2 #:pad-string \"0\" #:align 'right)))\n          (let* ([earliest-slot (first sorted-slots)]\n                 [day-index (quotient earliest-slot (* 24 60))]\n                 [time-in-day (remainder earliest-slot (* 24 60))]\n                 [hour (quotient time-in-day 60)]\n                 [minute (remainder time-in-day 60)])\n            (~a (list-ref days-of-week day-index) \" \" (~a hour #:min-width 2 #:pad-string \"0\" #:align 'right) \":\" (~a minute #:min-width 2 #:pad-string \"0\" #:align 'right)))))))\n\n\n(require racket/string\n         racket/format)\n\n(define (test-next-reminder)\n  (unless (equal? (next-reminder \"Monday 08:00\" '(\"Monday 09:00\" \"Tuesday 10:00\" \"Wednesday 12:00\")) \"Monday 09:00\")\n    (error \"Test 1 failed\"))\n  (unless (equal? (next-reminder \"Friday 23:00\" '(\"Monday 08:00\" \"Saturday 00:00\" \"Sunday 12:00\")) \"Saturday 00:00\")\n    (error \"Test 2 failed\"))\n  (unless (equal? (next-reminder \"Sunday 23:59\" '(\"Monday 00:00\" \"Tuesday 08:00\")) \"Monday 00:00\")\n    (error \"Test 3 failed\")))\n\n(test-next-reminder)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; find-largest-clique finds the largest clique in a graph with n nodes and given friendships (edges).\n; A clique is a subset of nodes where every two distinct nodes are connected by an edge.\n; The function uses backtracking to explore all possible subsets of nodes and checks if they form a clique.\n\n(define (find-largest-clique n friendships)\n  ; is-clique checks if a given subset of nodes forms a clique.\n  ; It verifies that every pair of nodes in the subset is connected by an edge.\n  (define (is-clique clique edges)\n    (for/and ([i (in-list clique)])\n      (for/and ([j (in-list clique)])\n        (or (equal? i j)\n            (set-member? edges (cons i j))\n            (set-member? edges (cons j i))))))\n  \n  ; backtrack explores all possible subsets of nodes starting from 'start'.\n  ; It maintains the current largest clique found in 'largest-clique'.\n  (define (backtrack start current-clique edges largest-clique)\n    (let ([updated-largest-clique (if (> (length current-clique) (length largest-clique))\n                                     current-clique\n                                     largest-clique)])\n      (for/fold ([largest updated-largest-clique])\n                ([i (in-range start n)])\n        (let ([new-clique (cons i current-clique)])\n          (if (is-clique new-clique edges)\n              (backtrack (add1 i) new-clique edges largest)\n              largest)))))\n  \n  (let ([edges (list->set (map (lambda (x) (cons (car x) (cadr x))) friendships))])\n    (backtrack 0 '() edges '())))", "test_cases": "", "test_case_results": "Input - n: 4, friendships: ((0 1) (0 2) (1 2) (2 3))\nLargest clique: (2 1 0)\nInput - n: 5, friendships: ((0 1) (1 2) (2 3) (3 4))\nLargest clique: (1 0)\nInput - n: 3, friendships: ((0 1) (1 2) (0 2))\nLargest clique: (2 1 0)", "task_id": 11351, "assertions": "#lang racket\n\n(require racket/set)\n\n(define (test-find-largest-clique)\n  (unless (equal? (find-largest-clique 4 '((0 1) (0 2) (1 2) (2 3))) '(2 1 0))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (find-largest-clique 5 '((0 1) (1 2) (2 3) (3 4))) '(1 0))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (find-largest-clique 3 '((0 1) (1 2) (0 2))) '(2 1 0))\n    (error \"Test case 3 failed\")))\n\n(test-find-largest-clique)", "all_code": "#lang racket\n\n\n; find-largest-clique finds the largest clique in a graph with n nodes and given friendships (edges).\n; A clique is a subset of nodes where every two distinct nodes are connected by an edge.\n; The function uses backtracking to explore all possible subsets of nodes and checks if they form a clique.\n\n(define (find-largest-clique n friendships)\n  ; is-clique checks if a given subset of nodes forms a clique.\n  ; It verifies that every pair of nodes in the subset is connected by an edge.\n  (define (is-clique clique edges)\n    (for/and ([i (in-list clique)])\n      (for/and ([j (in-list clique)])\n        (or (equal? i j)\n            (set-member? edges (cons i j))\n            (set-member? edges (cons j i))))))\n  \n  ; backtrack explores all possible subsets of nodes starting from 'start'.\n  ; It maintains the current largest clique found in 'largest-clique'.\n  (define (backtrack start current-clique edges largest-clique)\n    (let ([updated-largest-clique (if (> (length current-clique) (length largest-clique))\n                                     current-clique\n                                     largest-clique)])\n      (for/fold ([largest updated-largest-clique])\n                ([i (in-range start n)])\n        (let ([new-clique (cons i current-clique)])\n          (if (is-clique new-clique edges)\n              (backtrack (add1 i) new-clique edges largest)\n              largest)))))\n  \n  (let ([edges (list->set (map (lambda (x) (cons (car x) (cadr x))) friendships))])\n    (backtrack 0 '() edges '())))\n\n\n(require racket/set)\n\n(define (test-find-largest-clique)\n  (unless (equal? (find-largest-clique 4 '((0 1) (0 2) (1 2) (2 3))) '(2 1 0))\n    (error \"Test case 1 failed\"))\n  (unless (equal? (find-largest-clique 5 '((0 1) (1 2) (2 3) (3 4))) '(1 0))\n    (error \"Test case 2 failed\"))\n  (unless (equal? (find-largest-clique 3 '((0 1) (1 2) (0 2))) '(2 1 0))\n    (error \"Test case 3 failed\")))\n\n(test-find-largest-clique)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; count-squares counts the number of square submatrices with all 1s in a given matrix.\n; The function uses dynamic programming to build a dp table where each cell (i, j) \n; stores the size of the largest square submatrix ending at (i, j) with all 1s.\n; The total count is the sum of all values in the dp table.\n(define (count-squares matrix)\n  (if (or (empty? matrix) (empty? (first matrix)))\n      0\n      (let* ([m (length matrix)]\n             [n (length (first matrix))]\n             [dp (for/vector ([i (in-range m)]) \n                   (make-vector n 0))]\n             [count 0])\n        (for ([i (in-range m)])\n          (for ([j (in-range n)])\n            (when (= (list-ref (list-ref matrix i) j) 1)\n              (if (or (= i 0) (= j 0))\n                  (vector-set! (vector-ref dp i) j 1)\n                  (vector-set! (vector-ref dp i) j \n                               (add1 (min (vector-ref (vector-ref dp (sub1 i)) j)\n                                          (vector-ref (vector-ref dp i) (sub1 j))\n                                          (vector-ref (vector-ref dp (sub1 i)) (sub1 j))))))\n              (set! count (+ count (vector-ref (vector-ref dp i) j))))))\n        count)))", "test_cases": "", "test_case_results": "Test case 1:\nInput: ((1 0 1) (1 1 0) (1 1 0))\nNumber of squares: 7\n\nTest case 2:\nInput: ((0 1 1 1) (1 1 1 1) (0 1 1 1))\nNumber of squares: 15\n\nTest case 3:\nInput: ((1 1 1) (1 1 1) (1 1 1))\nNumber of squares: 14\n\nTest case 4:\nInput: ((0 0 0) (0 0 0) (0 0 0))\nNumber of squares: 0\n\nTest case 5:\nInput: ((1))\nNumber of squares: 1\n\nTest case 6:\nInput: ((0))\nNumber of squares: 0\n\nTest case 7:\nInput: (())\nNumber of squares: 0", "task_id": 19572, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-count-squares)\n  (unless (= (count-squares '((1 0 1) (1 1 0) (1 1 0))) 7)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-squares '((0 1 1 1) (1 1 1 1) (0 1 1 1))) 15)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-squares '((1 1 1) (1 1 1) (1 1 1))) 14)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-squares '((0 0 0) (0 0 0) (0 0 0))) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (count-squares '((1))) 1)\n    (error \"Test case 5 failed\"))\n  (unless (= (count-squares '((0))) 0)\n    (error \"Test case 6 failed\"))\n  (unless (= (count-squares '(())) 0)\n    (error \"Test case 7 failed\")))\n\n(test-count-squares)", "all_code": "#lang racket\n\n\n; count-squares counts the number of square submatrices with all 1s in a given matrix.\n; The function uses dynamic programming to build a dp table where each cell (i, j) \n; stores the size of the largest square submatrix ending at (i, j) with all 1s.\n; The total count is the sum of all values in the dp table.\n(define (count-squares matrix)\n  (if (or (empty? matrix) (empty? (first matrix)))\n      0\n      (let* ([m (length matrix)]\n             [n (length (first matrix))]\n             [dp (for/vector ([i (in-range m)]) \n                   (make-vector n 0))]\n             [count 0])\n        (for ([i (in-range m)])\n          (for ([j (in-range n)])\n            (when (= (list-ref (list-ref matrix i) j) 1)\n              (if (or (= i 0) (= j 0))\n                  (vector-set! (vector-ref dp i) j 1)\n                  (vector-set! (vector-ref dp i) j \n                               (add1 (min (vector-ref (vector-ref dp (sub1 i)) j)\n                                          (vector-ref (vector-ref dp i) (sub1 j))\n                                          (vector-ref (vector-ref dp (sub1 i)) (sub1 j))))))\n              (set! count (+ count (vector-ref (vector-ref dp i) j))))))\n        count)))\n\n\n(require rackunit)\n\n(define (test-count-squares)\n  (unless (= (count-squares '((1 0 1) (1 1 0) (1 1 0))) 7)\n    (error \"Test case 1 failed\"))\n  (unless (= (count-squares '((0 1 1 1) (1 1 1 1) (0 1 1 1))) 15)\n    (error \"Test case 2 failed\"))\n  (unless (= (count-squares '((1 1 1) (1 1 1) (1 1 1))) 14)\n    (error \"Test case 3 failed\"))\n  (unless (= (count-squares '((0 0 0) (0 0 0) (0 0 0))) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (count-squares '((1))) 1)\n    (error \"Test case 5 failed\"))\n  (unless (= (count-squares '((0))) 0)\n    (error \"Test case 6 failed\"))\n  (unless (= (count-squares '(())) 0)\n    (error \"Test case 7 failed\")))\n\n(test-count-squares)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; max-unique-path-length calculates the maximum length of a path in a grid where each cell in the path has a unique value.\n; The grid is represented as a list of lists, where each inner list represents a row.\n; The function uses a depth-first search (DFS) approach to explore all possible paths starting from each cell.\n; The visited values are tracked using a set to ensure uniqueness.\n\n(define (max-unique-path-length grid)\n  (define M (length grid))\n  (define N (if (> M 0) (length (car grid)) 0))\n  \n  ; dfs performs a depth-first search starting from (x, y) with the given visited set.\n  ; It returns the maximum path length found from this starting position.\n  (define (dfs x y visited)\n    (define max-length 1)\n    (for ([delta '((-1 0) (1 0) (0 -1) (0 1))])\n      (define nx (+ x (first delta)))\n      (define ny (+ y (second delta)))\n      (when (and (>= nx 0) (< nx M) (>= ny 0) (< ny N)\n                 (not (set-member? visited (list-ref (list-ref grid nx) ny))))\n        (set! max-length (max max-length\n                              (+ 1 (dfs nx ny (set-add visited (list-ref (list-ref grid nx) ny))))))))\n    max-length)\n  \n  (define max-path 0)\n  (for ([i (in-range M)])\n    (for ([j (in-range N)])\n      (set! max-path (max max-path (dfs i j (set (list-ref (list-ref grid i) j)))))))\n  max-path)", "test_cases": "", "test_case_results": "Input grid: ((1 2 3) (4 5 6) (7 8 9))\nMax unique path length: 9\nInput grid: ((1 1 1) (1 1 1) (1 1 1))\nMax unique path length: 1\nInput grid: ((1 2 3) (3 2 1))\nMax unique path length: 3\nInput grid: (())\nMax unique path length: 0\nInput grid: ((1))\nMax unique path length: 1", "task_id": 19390, "assertions": "#lang racket\n\n(require racket/set)\n\n(define (test-max-unique-path-length)\n  (unless (= (max-unique-path-length '((1 2 3) (4 5 6) (7 8 9))) 9)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-unique-path-length '((1 1 1) (1 1 1) (1 1 1))) 1)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-unique-path-length '((1 2 3) (3 2 1))) 3)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-unique-path-length '(())) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-unique-path-length '((1))) 1)\n    (error \"Test case 5 failed\")))\n\n(test-max-unique-path-length)", "all_code": "#lang racket\n\n\n; max-unique-path-length calculates the maximum length of a path in a grid where each cell in the path has a unique value.\n; The grid is represented as a list of lists, where each inner list represents a row.\n; The function uses a depth-first search (DFS) approach to explore all possible paths starting from each cell.\n; The visited values are tracked using a set to ensure uniqueness.\n\n(define (max-unique-path-length grid)\n  (define M (length grid))\n  (define N (if (> M 0) (length (car grid)) 0))\n  \n  ; dfs performs a depth-first search starting from (x, y) with the given visited set.\n  ; It returns the maximum path length found from this starting position.\n  (define (dfs x y visited)\n    (define max-length 1)\n    (for ([delta '((-1 0) (1 0) (0 -1) (0 1))])\n      (define nx (+ x (first delta)))\n      (define ny (+ y (second delta)))\n      (when (and (>= nx 0) (< nx M) (>= ny 0) (< ny N)\n                 (not (set-member? visited (list-ref (list-ref grid nx) ny))))\n        (set! max-length (max max-length\n                              (+ 1 (dfs nx ny (set-add visited (list-ref (list-ref grid nx) ny))))))))\n    max-length)\n  \n  (define max-path 0)\n  (for ([i (in-range M)])\n    (for ([j (in-range N)])\n      (set! max-path (max max-path (dfs i j (set (list-ref (list-ref grid i) j)))))))\n  max-path)\n\n\n(require racket/set)\n\n(define (test-max-unique-path-length)\n  (unless (= (max-unique-path-length '((1 2 3) (4 5 6) (7 8 9))) 9)\n    (error \"Test case 1 failed\"))\n  (unless (= (max-unique-path-length '((1 1 1) (1 1 1) (1 1 1))) 1)\n    (error \"Test case 2 failed\"))\n  (unless (= (max-unique-path-length '((1 2 3) (3 2 1))) 3)\n    (error \"Test case 3 failed\"))\n  (unless (= (max-unique-path-length '(())) 0)\n    (error \"Test case 4 failed\"))\n  (unless (= (max-unique-path-length '((1))) 1)\n    (error \"Test case 5 failed\")))\n\n(test-max-unique-path-length)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; replace-substring replaces all occurrences of a substring within a string with another substring.\n; Parameters:\n; original: The original string where replacements will be made.\n; to-replace: The substring to be replaced.\n; replacement: The substring to replace with.\n; Returns:\n; A string with all occurrences of 'to-replace' replaced by 'replacement'.\n; If 'to-replace' is an empty string, the original string is returned unchanged.\n(define (replace-substring original to-replace replacement)\n  (if (string=? to-replace \"\")\n      original\n      (string-replace original to-replace replacement)))", "test_cases": "", "test_case_results": "Original: hello world, To-replace: world, Replacement: racket\nResult: hello racket\nOriginal: hello world, To-replace: hello, Replacement: hi\nResult: hi world\nOriginal: hello world, To-replace: , Replacement: nothing\nResult: hello world\nOriginal: ababab, To-replace: ab, Replacement: ba\nResult: bababa\nOriginal: no change, To-replace: xyz, Replacement: abc\nResult: no change", "task_id": 26597, "assertions": "#lang racket\n\n(define (test-replace-substring)\n  (unless (string=? (replace-substring \"hello world\" \"world\" \"racket\") \"hello racket\")\n    (error \"Test 1 failed\"))\n  (unless (string=? (replace-substring \"hello world\" \"hello\" \"hi\") \"hi world\")\n    (error \"Test 2 failed\"))\n  (unless (string=? (replace-substring \"hello world\" \"\" \"nothing\") \"hello world\")\n    (error \"Test 3 failed\"))\n  (unless (string=? (replace-substring \"ababab\" \"ab\" \"ba\") \"bababa\")\n    (error \"Test 4 failed\"))\n  (unless (string=? (replace-substring \"no change\" \"xyz\" \"abc\") \"no change\")\n    (error \"Test 5 failed\")))\n\n(test-replace-substring)", "all_code": "#lang racket\n\n\n; replace-substring replaces all occurrences of a substring within a string with another substring.\n; Parameters:\n; original: The original string where replacements will be made.\n; to-replace: The substring to be replaced.\n; replacement: The substring to replace with.\n; Returns:\n; A string with all occurrences of 'to-replace' replaced by 'replacement'.\n; If 'to-replace' is an empty string, the original string is returned unchanged.\n(define (replace-substring original to-replace replacement)\n  (if (string=? to-replace \"\")\n      original\n      (string-replace original to-replace replacement)))\n\n\n(define (test-replace-substring)\n  (unless (string=? (replace-substring \"hello world\" \"world\" \"racket\") \"hello racket\")\n    (error \"Test 1 failed\"))\n  (unless (string=? (replace-substring \"hello world\" \"hello\" \"hi\") \"hi world\")\n    (error \"Test 2 failed\"))\n  (unless (string=? (replace-substring \"hello world\" \"\" \"nothing\") \"hello world\")\n    (error \"Test 3 failed\"))\n  (unless (string=? (replace-substring \"ababab\" \"ab\" \"ba\") \"bababa\")\n    (error \"Test 4 failed\"))\n  (unless (string=? (replace-substring \"no change\" \"xyz\" \"abc\") \"no change\")\n    (error \"Test 5 failed\")))\n\n(test-replace-substring)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for hash operations\n(require racket/dict)\n\n; are-permutations checks if one string is a permutation of another.\n; It does this by comparing the frequency of each character in both strings.\n; The function is case-sensitive and treats whitespace and special characters as significant.\n; If the lengths of the two strings are different, they cannot be permutations.\n(define (are-permutations s1 s2)\n  (if (not (= (string-length s1) (string-length s2)))\n      #f\n      (let ([count1 (make-hash)]\n            [count2 (make-hash)])\n        ; Count characters in s1\n        (for ([c (string->list s1)])\n          (dict-update! count1 c add1 (lambda () 0)))\n        ; Count characters in s2\n        (for ([c (string->list s2)])\n          (dict-update! count2 c add1 (lambda () 0)))\n        ; Compare the counts\n        (equal? count1 count2))))", "test_cases": "", "test_case_results": "Input: abc and cba\nResult: #t\nInput: hello and world\nResult: #f\nInput: aab and bba\nResult: #f\nInput: 123 and 321\nResult: #t\nInput:   and  \nResult: #t\nInput: Case and case\nResult: #f", "task_id": 7756, "assertions": "#lang racket\n\n(require racket/dict)\n\n(define (test-permutations)\n  (unless (are-permutations \"abc\" \"cba\")\n    (error \"Test 1 failed: abc and cba should be permutations\"))\n  (unless (not (are-permutations \"hello\" \"world\"))\n    (error \"Test 2 failed: hello and world should not be permutations\"))\n  (unless (not (are-permutations \"aab\" \"bba\"))\n    (error \"Test 3 failed: aab and bba should not be permutations\"))\n  (unless (are-permutations \"123\" \"321\")\n    (error \"Test 4 failed: 123 and 321 should be permutations\"))\n  (unless (are-permutations \" \" \" \")\n    (error \"Test 5 failed: two spaces should be permutations\"))\n  (unless (not (are-permutations \"Case\" \"case\"))\n    (error \"Test 6 failed: Case and case should not be permutations\")))\n\n(test-permutations)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for hash operations\n(require racket/dict)\n\n; are-permutations checks if one string is a permutation of another.\n; It does this by comparing the frequency of each character in both strings.\n; The function is case-sensitive and treats whitespace and special characters as significant.\n; If the lengths of the two strings are different, they cannot be permutations.\n(define (are-permutations s1 s2)\n  (if (not (= (string-length s1) (string-length s2)))\n      #f\n      (let ([count1 (make-hash)]\n            [count2 (make-hash)])\n        ; Count characters in s1\n        (for ([c (string->list s1)])\n          (dict-update! count1 c add1 (lambda () 0)))\n        ; Count characters in s2\n        (for ([c (string->list s2)])\n          (dict-update! count2 c add1 (lambda () 0)))\n        ; Compare the counts\n        (equal? count1 count2))))\n\n\n(require racket/dict)\n\n(define (test-permutations)\n  (unless (are-permutations \"abc\" \"cba\")\n    (error \"Test 1 failed: abc and cba should be permutations\"))\n  (unless (not (are-permutations \"hello\" \"world\"))\n    (error \"Test 2 failed: hello and world should not be permutations\"))\n  (unless (not (are-permutations \"aab\" \"bba\"))\n    (error \"Test 3 failed: aab and bba should not be permutations\"))\n  (unless (are-permutations \"123\" \"321\")\n    (error \"Test 4 failed: 123 and 321 should be permutations\"))\n  (unless (are-permutations \" \" \" \")\n    (error \"Test 5 failed: two spaces should be permutations\"))\n  (unless (not (are-permutations \"Case\" \"case\"))\n    (error \"Test 6 failed: Case and case should not be permutations\")))\n\n(test-permutations)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for regular expressions\n(require racket/match)\n\n; find-identifiers searches for all matches of a given pattern in an input string.\n; It uses Racket's regexp-match* function to find all non-overlapping matches.\n; The pattern is compiled into a regular expression object for efficient searching.\n; Parameters:\n; - input-string: The string to search within.\n; - pattern: The regular expression pattern to search for (as a string).\n; Returns:\n; A list of all matches found in the input string.\n(define (find-identifiers input-string pattern)\n  (regexp-match* (pregexp pattern) input-string))", "test_cases": "", "test_case_results": "Input string: int x = 5; double y = 3.14; string z = \"hello\";\nPattern: [a-zA-Z_][a-zA-Z0-9_]*\nMatches: (int x double y string z hello)\n\nInput string: 123 abc 456 def\nPattern: [a-z]+\nMatches: (abc def)\n\nInput string: Hello, world! How are you?\nPattern: [A-Z][a-z]*\nMatches: (Hello How)", "task_id": 28325, "assertions": "#lang racket\n\n(require racket/match)\n\n(define (test-find-identifiers)\n  (unless (equal? (find-identifiers \"int x = 5; double y = 3.14; string z = \\\"hello\\\";\" \"[a-zA-Z_][a-zA-Z0-9_]*\")\n                  '(\"int\" \"x\" \"double\" \"y\" \"string\" \"z\" \"hello\"))\n    (error \"Test 1 failed\"))\n  \n  (unless (equal? (find-identifiers \"123 abc 456 def\" \"[a-z]+\")\n                  '(\"abc\" \"def\"))\n    (error \"Test 2 failed\"))\n  \n  (unless (equal? (find-identifiers \"Hello, world! How are you?\" \"[A-Z][a-z]*\")\n                  '(\"Hello\" \"How\"))\n    (error \"Test 3 failed\")))\n\n(test-find-identifiers)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for regular expressions\n(require racket/match)\n\n; find-identifiers searches for all matches of a given pattern in an input string.\n; It uses Racket's regexp-match* function to find all non-overlapping matches.\n; The pattern is compiled into a regular expression object for efficient searching.\n; Parameters:\n; - input-string: The string to search within.\n; - pattern: The regular expression pattern to search for (as a string).\n; Returns:\n; A list of all matches found in the input string.\n(define (find-identifiers input-string pattern)\n  (regexp-match* (pregexp pattern) input-string))\n\n\n(require racket/match)\n\n(define (test-find-identifiers)\n  (unless (equal? (find-identifiers \"int x = 5; double y = 3.14; string z = \\\"hello\\\";\" \"[a-zA-Z_][a-zA-Z0-9_]*\")\n                  '(\"int\" \"x\" \"double\" \"y\" \"string\" \"z\" \"hello\"))\n    (error \"Test 1 failed\"))\n  \n  (unless (equal? (find-identifiers \"123 abc 456 def\" \"[a-z]+\")\n                  '(\"abc\" \"def\"))\n    (error \"Test 2 failed\"))\n  \n  (unless (equal? (find-identifiers \"Hello, world! How are you?\" \"[A-Z][a-z]*\")\n                  '(\"Hello\" \"How\"))\n    (error \"Test 3 failed\")))\n\n(test-find-identifiers)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; distinct-substrings-in-concatenated-string calculates the number of distinct non-empty substrings\n; of a string `p` that can be found at least once in an infinitely concatenated string of `p`.\n; The function works by generating all possible non-empty substrings of `p` and storing them in a set\n; to ensure uniqueness. The size of the set is then returned as the result.\n(define (distinct-substrings-in-concatenated-string p)\n  (let ([n (string-length p)]\n        [substrings (mutable-set)])\n    (for ([i (in-range n)])\n      (for ([j (in-range (add1 i) (add1 n))])\n        (set-add! substrings (substring p i j))))\n    (set-count substrings)))", "test_cases": "", "test_case_results": "Input: a\nDistinct substrings: 1\nInput: ab\nDistinct substrings: 3\nInput: abc\nDistinct substrings: 6\nInput: aaa\nDistinct substrings: 3", "task_id": 1564, "assertions": "#lang racket\n\n(define (test-distinct-substrings)\n  (unless (= (distinct-substrings-in-concatenated-string \"a\") 1)\n    (error \"Test case 'a' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"ab\") 3)\n    (error \"Test case 'ab' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"abc\") 6)\n    (error \"Test case 'abc' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"aaa\") 3)\n    (error \"Test case 'aaa' failed\")))\n\n(test-distinct-substrings)", "all_code": "#lang racket\n\n\n; distinct-substrings-in-concatenated-string calculates the number of distinct non-empty substrings\n; of a string `p` that can be found at least once in an infinitely concatenated string of `p`.\n; The function works by generating all possible non-empty substrings of `p` and storing them in a set\n; to ensure uniqueness. The size of the set is then returned as the result.\n(define (distinct-substrings-in-concatenated-string p)\n  (let ([n (string-length p)]\n        [substrings (mutable-set)])\n    (for ([i (in-range n)])\n      (for ([j (in-range (add1 i) (add1 n))])\n        (set-add! substrings (substring p i j))))\n    (set-count substrings)))\n\n\n(define (test-distinct-substrings)\n  (unless (= (distinct-substrings-in-concatenated-string \"a\") 1)\n    (error \"Test case 'a' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"ab\") 3)\n    (error \"Test case 'ab' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"abc\") 6)\n    (error \"Test case 'abc' failed\"))\n  (unless (= (distinct-substrings-in-concatenated-string \"aaa\") 3)\n    (error \"Test case 'aaa' failed\")))\n\n(test-distinct-substrings)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for hash tables and sorting\n(require racket/hash)\n\n; A warehouse is represented as a hash table where each key is a section ID\n; and each value is another hash table mapping item IDs to quantities.\n\n; make-warehouse creates a new empty warehouse.\n(define (make-warehouse)\n  (make-hash))\n\n; warehouse-store adds a quantity of an item to a section in the warehouse.\n; If the section or item does not exist, they are created.\n(define (warehouse-store warehouse item-id section-id quantity)\n  (let ([section (hash-ref warehouse section-id (hash))])\n    (hash-set! warehouse \n               section-id \n               (hash-set section \n                        item-id \n                        (+ (hash-ref section item-id 0) quantity)))))\n\n; warehouse-remove removes a quantity of an item from a section in the warehouse.\n; If the quantity reaches zero, the item is removed from the section.\n; If the section becomes empty, it is not removed for simplicity.\n(define (warehouse-remove warehouse item-id section-id quantity)\n  (when (hash-has-key? warehouse section-id)\n    (let ([section (hash-ref warehouse section-id)])\n      (when (hash-has-key? section item-id)\n        (let ([new-quantity (- (hash-ref section item-id) quantity)])\n          (if (<= new-quantity 0)\n              (hash-set! warehouse section-id (hash-remove section item-id))\n              (hash-set! warehouse section-id (hash-set section item-id new-quantity))))))))\n\n; warehouse-inventory returns the inventory of a section as a list of item-quantity pairs,\n; sorted by item ID.\n(define (warehouse-inventory warehouse section-id)\n  (if (hash-has-key? warehouse section-id)\n      (sort (hash->list (hash-ref warehouse section-id)) \n            (λ (a b) (< (car a) (car b))))\n      '()))\n\n; process-actions processes a list of warehouse actions and returns the inventory results.\n; Actions can be \"STORE\", \"REMOVE\", or \"INVENTORY\".\n(define (process-actions actions)\n  (let ([warehouse (make-warehouse)]\n        [results '()])\n    (for ([action actions])\n      (let* ([parts (string-split action)]\n             [command (first parts)])\n        (cond\n          [(equal? command \"STORE\")\n           (let ([item-id (string->number (second parts))]\n                 [section-id (string->number (third parts))]\n                 [quantity (string->number (fourth parts))])\n             (warehouse-store warehouse item-id section-id quantity))]\n          [(equal? command \"REMOVE\")\n           (let ([item-id (string->number (second parts))]\n                 [section-id (string->number (third parts))]\n                 [quantity (string->number (fourth parts))])\n             (warehouse-remove warehouse item-id section-id quantity))]\n          [(equal? command \"INVENTORY\")\n           (let ([section-id (string->number (second parts))])\n             (set! results \n                   (append \n                    results \n                    (map (λ (pair) \n                           (format \"~a ~a\" (car pair) (cdr pair))) \n                         (warehouse-inventory warehouse section-id)))))])))\n    results))", "test_cases": "", "test_case_results": "Test Actions:\n(STORE 1 100 5 STORE 2 100 10 STORE 3 200 7 REMOVE 2 100 5 INVENTORY 100 INVENTORY 200 REMOVE 1 100 5 INVENTORY 100)\nResults:\n(1 5 2 5 3 7 2 5)", "task_id": 22991, "assertions": "#lang racket\n\n(require rackunit)\n\n(define (test-warehouse-functions)\n  (let ([results (process-actions '(\"STORE 1 100 5\"\n                                   \"STORE 2 100 10\"\n                                   \"STORE 3 200 7\"\n                                   \"REMOVE 2 100 5\"\n                                   \"INVENTORY 100\"\n                                   \"INVENTORY 200\"\n                                   \"REMOVE 1 100 5\"\n                                   \"INVENTORY 100\"))])\n    (unless (equal? results '(\"1 5\" \"2 5\" \"3 7\" \"2 5\"))\n      (error \"Test failed: Incorrect results\"))\n    (let ([empty-results (process-actions '(\"INVENTORY 100\"))])\n      (unless (equal? empty-results '())\n        (error \"Test failed: Empty inventory should return empty list\")))))\n\n(test-warehouse-functions)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for hash tables and sorting\n(require racket/hash)\n\n; A warehouse is represented as a hash table where each key is a section ID\n; and each value is another hash table mapping item IDs to quantities.\n\n; make-warehouse creates a new empty warehouse.\n(define (make-warehouse)\n  (make-hash))\n\n; warehouse-store adds a quantity of an item to a section in the warehouse.\n; If the section or item does not exist, they are created.\n(define (warehouse-store warehouse item-id section-id quantity)\n  (let ([section (hash-ref warehouse section-id (hash))])\n    (hash-set! warehouse \n               section-id \n               (hash-set section \n                        item-id \n                        (+ (hash-ref section item-id 0) quantity)))))\n\n; warehouse-remove removes a quantity of an item from a section in the warehouse.\n; If the quantity reaches zero, the item is removed from the section.\n; If the section becomes empty, it is not removed for simplicity.\n(define (warehouse-remove warehouse item-id section-id quantity)\n  (when (hash-has-key? warehouse section-id)\n    (let ([section (hash-ref warehouse section-id)])\n      (when (hash-has-key? section item-id)\n        (let ([new-quantity (- (hash-ref section item-id) quantity)])\n          (if (<= new-quantity 0)\n              (hash-set! warehouse section-id (hash-remove section item-id))\n              (hash-set! warehouse section-id (hash-set section item-id new-quantity))))))))\n\n; warehouse-inventory returns the inventory of a section as a list of item-quantity pairs,\n; sorted by item ID.\n(define (warehouse-inventory warehouse section-id)\n  (if (hash-has-key? warehouse section-id)\n      (sort (hash->list (hash-ref warehouse section-id)) \n            (λ (a b) (< (car a) (car b))))\n      '()))\n\n; process-actions processes a list of warehouse actions and returns the inventory results.\n; Actions can be \"STORE\", \"REMOVE\", or \"INVENTORY\".\n(define (process-actions actions)\n  (let ([warehouse (make-warehouse)]\n        [results '()])\n    (for ([action actions])\n      (let* ([parts (string-split action)]\n             [command (first parts)])\n        (cond\n          [(equal? command \"STORE\")\n           (let ([item-id (string->number (second parts))]\n                 [section-id (string->number (third parts))]\n                 [quantity (string->number (fourth parts))])\n             (warehouse-store warehouse item-id section-id quantity))]\n          [(equal? command \"REMOVE\")\n           (let ([item-id (string->number (second parts))]\n                 [section-id (string->number (third parts))]\n                 [quantity (string->number (fourth parts))])\n             (warehouse-remove warehouse item-id section-id quantity))]\n          [(equal? command \"INVENTORY\")\n           (let ([section-id (string->number (second parts))])\n             (set! results \n                   (append \n                    results \n                    (map (λ (pair) \n                           (format \"~a ~a\" (car pair) (cdr pair))) \n                         (warehouse-inventory warehouse section-id)))))])))\n    results))\n\n\n(require rackunit)\n\n(define (test-warehouse-functions)\n  (let ([results (process-actions '(\"STORE 1 100 5\"\n                                   \"STORE 2 100 10\"\n                                   \"STORE 3 200 7\"\n                                   \"REMOVE 2 100 5\"\n                                   \"INVENTORY 100\"\n                                   \"INVENTORY 200\"\n                                   \"REMOVE 1 100 5\"\n                                   \"INVENTORY 100\"))])\n    (unless (equal? results '(\"1 5\" \"2 5\" \"3 7\" \"2 5\"))\n      (error \"Test failed: Incorrect results\"))\n    (let ([empty-results (process-actions '(\"INVENTORY 100\"))])\n      (unless (equal? empty-results '())\n        (error \"Test failed: Empty inventory should return empty list\")))))\n\n(test-warehouse-functions)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Define a player structure with name, ships, and points\n(struct player (name ships points) #:mutable)\n\n; Create a new player with a given name, initialized to 5 ships and 0 points\n(define (make-player name)\n  (player name 5 0))\n\n; Check if a player is alive (has ships remaining)\n(define (is-alive? p)\n  (> (player-ships p) 0))\n\n; Get the current points of a player\n(define (get-points p)\n  (player-points p))\n\n; Update the points of a player\n(define (update-points! p points)\n  (set-player-points! p points))\n\n; Sink one of the player's ships\n(define (sink-ship! p)\n  (set-player-ships! p (sub1 (player-ships p))))\n\n; Define a game structure with two players\n(struct game (player1 player2))\n\n; Determine the winner of the game based on remaining ships\n; Awards jackpot points (remaining ships * 3) to the winner if there is one\n(define (determine-winner g)\n  (let ([p1 (game-player1 g)]\n        [p2 (game-player2 g)])\n    (cond\n      [(and (is-alive? p1) (not (is-alive? p2)))\n       (update-points! p1 (* (player-ships p1) 3))\n       p1]\n      [(and (is-alive? p2) (not (is-alive? p1)))\n       (update-points! p2 (* (player-ships p2) 3))\n       p2]\n      [else #f])))", "test_cases": "", "test_case_results": "'(\"Player 1\" 12)", "task_id": 3845, "assertions": "#lang racket\n\n(define (test-game-utils)\n  (let* ([p1 (make-player \"Player 1\")]\n         [p2 (make-player \"Player 2\")]\n         [g (game p1 p2)])\n    \n    ; Simulate ship sinking\n    (sink-ship! p1)  ; p1 has 4 ships\n    (sink-ship! p2)  ; p2 has 4 ships\n    (sink-ship! p2)  ; p2 has 3 ships\n    (sink-ship! p2)  ; p2 has 2 ships\n    (sink-ship! p2)  ; p2 has 1 ship\n    (sink-ship! p2)  ; p2 has 0 ships\n    \n    (let ([winner (determine-winner g)])\n      (unless (equal? (player-name winner) \"Player 1\")\n        (error \"Test failed: Winner name should be 'Player 1'\"))\n      (unless (= (get-points winner) 12)\n        (error \"Test failed: Winner points should be 12\")))))\n\n(test-game-utils)", "all_code": "#lang racket\n\n\n; Define a player structure with name, ships, and points\n(struct player (name ships points) #:mutable)\n\n; Create a new player with a given name, initialized to 5 ships and 0 points\n(define (make-player name)\n  (player name 5 0))\n\n; Check if a player is alive (has ships remaining)\n(define (is-alive? p)\n  (> (player-ships p) 0))\n\n; Get the current points of a player\n(define (get-points p)\n  (player-points p))\n\n; Update the points of a player\n(define (update-points! p points)\n  (set-player-points! p points))\n\n; Sink one of the player's ships\n(define (sink-ship! p)\n  (set-player-ships! p (sub1 (player-ships p))))\n\n; Define a game structure with two players\n(struct game (player1 player2))\n\n; Determine the winner of the game based on remaining ships\n; Awards jackpot points (remaining ships * 3) to the winner if there is one\n(define (determine-winner g)\n  (let ([p1 (game-player1 g)]\n        [p2 (game-player2 g)])\n    (cond\n      [(and (is-alive? p1) (not (is-alive? p2)))\n       (update-points! p1 (* (player-ships p1) 3))\n       p1]\n      [(and (is-alive? p2) (not (is-alive? p1)))\n       (update-points! p2 (* (player-ships p2) 3))\n       p2]\n      [else #f])))\n\n\n(define (test-game-utils)\n  (let* ([p1 (make-player \"Player 1\")]\n         [p2 (make-player \"Player 2\")]\n         [g (game p1 p2)])\n    \n    ; Simulate ship sinking\n    (sink-ship! p1)  ; p1 has 4 ships\n    (sink-ship! p2)  ; p2 has 4 ships\n    (sink-ship! p2)  ; p2 has 3 ships\n    (sink-ship! p2)  ; p2 has 2 ships\n    (sink-ship! p2)  ; p2 has 1 ship\n    (sink-ship! p2)  ; p2 has 0 ships\n    \n    (let ([winner (determine-winner g)])\n      (unless (equal? (player-name winner) \"Player 1\")\n        (error \"Test failed: Winner name should be 'Player 1'\"))\n      (unless (= (get-points winner) 12)\n        (error \"Test failed: Winner points should be 12\")))))\n\n(test-game-utils)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for regular expressions\n(require racket/match)\n\n; evaluate-expression evaluates a given arithmetic expression string and returns the evaluated result.\n; The expression can contain numbers, parentheses, and the operators +, -, *, /.\n; The function follows standard operator precedence and associativity rules.\n(define (evaluate-expression expression)\n  ; parse-expression splits the input string into tokens (numbers, operators, parentheses)\n  (define (parse-expression expr)\n    (regexp-match* #px\"[-+*/()]|\\\\d+\" expr))\n  \n  ; apply-operation applies the given operation to the two operands\n  (define (apply-operation op a b)\n    (match op\n      [\"+\" (+ a b)]\n      [\"-\" (- a b)]\n      [\"*\" (* a b)]\n      [\"/\" (/ a b)]))\n  \n  ; greater-precedence? checks if op1 has higher precedence than op2\n  (define (greater-precedence? op1 op2)\n    (define precedences (hash \"+\" 1 \"-\" 1 \"*\" 2 \"/\" 2))\n    (> (hash-ref precedences op1) (hash-ref precedences op2)))\n  \n  ; evaluate processes the tokens using the shunting-yard algorithm to handle operator precedence\n  (define (evaluate tokens)\n    (let loop ([idx 0] [values '()] [ops '()])\n      (if (>= idx (length tokens))\n          ; Process remaining operations\n          (let process-remaining ([vals values] [operations ops])\n            (if (null? operations)\n                (car vals)\n                (let* ([op (car operations)]\n                       [b (car vals)]\n                       [a (cadr vals)]\n                       [new-val (apply-operation op a b)])\n                  (process-remaining (cons new-val (cddr vals)) (cdr operations)))))\n          ; Process current token\n          (let ([token (list-ref tokens idx)])\n            (cond\n              [(regexp-match? #px\"^\\\\d+$\" token)\n               (loop (add1 idx) (cons (string->number token) values) ops)]\n              [(string=? token \"(\")\n               (loop (add1 idx) values (cons token ops))]\n              [(string=? token \")\")\n               (let process-paren ([vals values] [operations ops])\n                 (if (string=? (car operations) \"(\")\n                     (loop (add1 idx) vals (cdr operations))\n                     (let* ([op (car operations)]\n                            [b (car vals)]\n                            [a (cadr vals)]\n                            [new-val (apply-operation op a b)])\n                       (process-paren (cons new-val (cddr vals)) (cdr operations)))))]\n              [else\n               (let process-ops ([vals values] [operations ops])\n                 (if (or (null? operations)\n                         (string=? (car operations) \"(\")\n                         (not (greater-precedence? (car operations) token)))\n                     (loop (add1 idx) vals (cons token operations))\n                     (let* ([op (car operations)]\n                            [b (car vals)]\n                            [a (cadr vals)]\n                            [new-val (apply-operation op a b)])\n                       (process-ops (cons new-val (cddr vals)) (cdr operations)))))])))))\n  \n  (let* ([tokens (parse-expression expression)]\n         [result (evaluate tokens)])\n    (if (integer? result)\n        (exact-round result)\n        result)))", "test_cases": "", "test_case_results": "Expression: 1+2*3\nExpected: 7\nResult: 7\nPASS\n\nExpression: (1+2)*3\nExpected: 9\nResult: 9\nPASS\n\nExpression: 10/3\nExpected: 10/3\nResult: 10/3\nPASS\n\nExpression: 2*(3+4)-5/2\nExpected: 11.5\nResult: 23/2\nFAIL\n\nExpression: 3+4*2/(1-5)\nExpected: 1\nResult: 1\nPASS\n\nExpression: 10\nExpected: 10\nResult: 10\nPASS\n\nExpression: (2+3)*(4-1)\nExpected: 15\nResult: 15\nPASS", "task_id": 20838, "assertions": "#lang racket\n\n(require racket/match)\n\n(define (test-evaluate-expression)\n  (unless (equal? (evaluate-expression \"1+2*3\") 7)\n    (error \"Test 1 failed: 1+2*3\"))\n  (unless (equal? (evaluate-expression \"(1+2)*3\") 9)\n    (error \"Test 2 failed: (1+2)*3\"))\n  (unless (equal? (evaluate-expression \"10/3\") 10/3)\n    (error \"Test 3 failed: 10/3\"))\n  (unless (equal? (evaluate-expression \"2*(3+4)-5/2\") 23/2)\n    (error \"Test 4 failed: 2*(3+4)-5/2\"))\n  (unless (equal? (evaluate-expression \"3+4*2/(1-5)\") 1)\n    (error \"Test 5 failed: 3+4*2/(1-5)\"))\n  (unless (equal? (evaluate-expression \"10\") 10)\n    (error \"Test 6 failed: 10\"))\n  (unless (equal? (evaluate-expression \"(2+3)*(4-1)\") 15)\n    (error \"Test 7 failed: (2+3)*(4-1)\")))\n\n(test-evaluate-expression)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for regular expressions\n(require racket/match)\n\n; evaluate-expression evaluates a given arithmetic expression string and returns the evaluated result.\n; The expression can contain numbers, parentheses, and the operators +, -, *, /.\n; The function follows standard operator precedence and associativity rules.\n(define (evaluate-expression expression)\n  ; parse-expression splits the input string into tokens (numbers, operators, parentheses)\n  (define (parse-expression expr)\n    (regexp-match* #px\"[-+*/()]|\\\\d+\" expr))\n  \n  ; apply-operation applies the given operation to the two operands\n  (define (apply-operation op a b)\n    (match op\n      [\"+\" (+ a b)]\n      [\"-\" (- a b)]\n      [\"*\" (* a b)]\n      [\"/\" (/ a b)]))\n  \n  ; greater-precedence? checks if op1 has higher precedence than op2\n  (define (greater-precedence? op1 op2)\n    (define precedences (hash \"+\" 1 \"-\" 1 \"*\" 2 \"/\" 2))\n    (> (hash-ref precedences op1) (hash-ref precedences op2)))\n  \n  ; evaluate processes the tokens using the shunting-yard algorithm to handle operator precedence\n  (define (evaluate tokens)\n    (let loop ([idx 0] [values '()] [ops '()])\n      (if (>= idx (length tokens))\n          ; Process remaining operations\n          (let process-remaining ([vals values] [operations ops])\n            (if (null? operations)\n                (car vals)\n                (let* ([op (car operations)]\n                       [b (car vals)]\n                       [a (cadr vals)]\n                       [new-val (apply-operation op a b)])\n                  (process-remaining (cons new-val (cddr vals)) (cdr operations)))))\n          ; Process current token\n          (let ([token (list-ref tokens idx)])\n            (cond\n              [(regexp-match? #px\"^\\\\d+$\" token)\n               (loop (add1 idx) (cons (string->number token) values) ops)]\n              [(string=? token \"(\")\n               (loop (add1 idx) values (cons token ops))]\n              [(string=? token \")\")\n               (let process-paren ([vals values] [operations ops])\n                 (if (string=? (car operations) \"(\")\n                     (loop (add1 idx) vals (cdr operations))\n                     (let* ([op (car operations)]\n                            [b (car vals)]\n                            [a (cadr vals)]\n                            [new-val (apply-operation op a b)])\n                       (process-paren (cons new-val (cddr vals)) (cdr operations)))))]\n              [else\n               (let process-ops ([vals values] [operations ops])\n                 (if (or (null? operations)\n                         (string=? (car operations) \"(\")\n                         (not (greater-precedence? (car operations) token)))\n                     (loop (add1 idx) vals (cons token operations))\n                     (let* ([op (car operations)]\n                            [b (car vals)]\n                            [a (cadr vals)]\n                            [new-val (apply-operation op a b)])\n                       (process-ops (cons new-val (cddr vals)) (cdr operations)))))])))))\n  \n  (let* ([tokens (parse-expression expression)]\n         [result (evaluate tokens)])\n    (if (integer? result)\n        (exact-round result)\n        result)))\n\n\n(require racket/match)\n\n(define (test-evaluate-expression)\n  (unless (equal? (evaluate-expression \"1+2*3\") 7)\n    (error \"Test 1 failed: 1+2*3\"))\n  (unless (equal? (evaluate-expression \"(1+2)*3\") 9)\n    (error \"Test 2 failed: (1+2)*3\"))\n  (unless (equal? (evaluate-expression \"10/3\") 10/3)\n    (error \"Test 3 failed: 10/3\"))\n  (unless (equal? (evaluate-expression \"2*(3+4)-5/2\") 23/2)\n    (error \"Test 4 failed: 2*(3+4)-5/2\"))\n  (unless (equal? (evaluate-expression \"3+4*2/(1-5)\") 1)\n    (error \"Test 5 failed: 3+4*2/(1-5)\"))\n  (unless (equal? (evaluate-expression \"10\") 10)\n    (error \"Test 6 failed: 10\"))\n  (unless (equal? (evaluate-expression \"(2+3)*(4-1)\") 15)\n    (error \"Test 7 failed: (2+3)*(4-1)\")))\n\n(test-evaluate-expression)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; count-consecutive-groups calculates the number of groups of consecutive integers in a sorted list.\n; The function first sorts the list of IDs, then iterates through the list to count how many times\n; consecutive numbers are not sequential, indicating the start of a new group.\n; \n; Parameters:\n;   n: the number of elements in the list\n;   ids: a list of integers representing book IDs\n; Returns:\n;   The number of groups of consecutive IDs\n(define (count-consecutive-groups n ids)\n  (let ([sorted-ids (sort ids <)])\n    (if (<= n 1)\n        1\n        (let loop ([i 1] [groups 1])\n          (if (>= i n)\n              groups\n              (if (not (= (list-ref sorted-ids i) (+ (list-ref sorted-ids (- i 1)) 1)))\n                  (loop (+ i 1) (+ groups 1))\n                  (loop (+ i 1) groups)))))))", "test_cases": "", "test_case_results": "Input: (1 3 2 5 4)\nNumber of groups: 1\nInput: (7 7 7)\nNumber of groups: 3\nInput: (10)\nNumber of groups: 1\nInput: (10 11 12 13)\nNumber of groups: 1\nInput: (1 2 3 5 6 7)\nNumber of groups: 2", "task_id": 2485, "assertions": "#lang racket\n\n(define (test-count-consecutive-groups)\n  (unless (= (count-consecutive-groups 5 '(1 3 2 5 4)) 1)\n    (error \"Test case 1 failed: (1 3 2 5 4)\"))\n  (unless (= (count-consecutive-groups 3 '(7 7 7)) 3)\n    (error \"Test case 2 failed: (7 7 7)\"))\n  (unless (= (count-consecutive-groups 1 '(10)) 1)\n    (error \"Test case 3 failed: (10)\"))\n  (unless (= (count-consecutive-groups 4 '(10 11 12 13)) 1)\n    (error \"Test case 4 failed: (10 11 12 13)\"))\n  (unless (= (count-consecutive-groups 6 '(1 2 3 5 6 7)) 2)\n    (error \"Test case 5 failed: (1 2 3 5 6 7)\")))\n\n(test-count-consecutive-groups)", "all_code": "#lang racket\n\n\n; count-consecutive-groups calculates the number of groups of consecutive integers in a sorted list.\n; The function first sorts the list of IDs, then iterates through the list to count how many times\n; consecutive numbers are not sequential, indicating the start of a new group.\n; \n; Parameters:\n;   n: the number of elements in the list\n;   ids: a list of integers representing book IDs\n; Returns:\n;   The number of groups of consecutive IDs\n(define (count-consecutive-groups n ids)\n  (let ([sorted-ids (sort ids <)])\n    (if (<= n 1)\n        1\n        (let loop ([i 1] [groups 1])\n          (if (>= i n)\n              groups\n              (if (not (= (list-ref sorted-ids i) (+ (list-ref sorted-ids (- i 1)) 1)))\n                  (loop (+ i 1) (+ groups 1))\n                  (loop (+ i 1) groups)))))))\n\n\n(define (test-count-consecutive-groups)\n  (unless (= (count-consecutive-groups 5 '(1 3 2 5 4)) 1)\n    (error \"Test case 1 failed: (1 3 2 5 4)\"))\n  (unless (= (count-consecutive-groups 3 '(7 7 7)) 3)\n    (error \"Test case 2 failed: (7 7 7)\"))\n  (unless (= (count-consecutive-groups 1 '(10)) 1)\n    (error \"Test case 3 failed: (10)\"))\n  (unless (= (count-consecutive-groups 4 '(10 11 12 13)) 1)\n    (error \"Test case 4 failed: (10 11 12 13)\"))\n  (unless (= (count-consecutive-groups 6 '(1 2 3 5 6 7)) 2)\n    (error \"Test case 5 failed: (1 2 3 5 6 7)\")))\n\n(test-count-consecutive-groups)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; Require the necessary standard libraries for date and time manipulation\n(require racket/date)\n\n; generate-times generates all valid times between start and end (inclusive) in HH:MM format.\n; The function takes two strings representing the start and end times in \"HH:MM\" format.\n; If the end time is earlier than the start time, it assumes the end time is on the next day.\n; The function returns a list of strings, each representing a time in \"HH:MM\" format.\n(define (generate-times start end)\n  (let* ([start-dt (parse-time start)]\n         [end-dt (parse-time end)]\n         [end-dt (if (time<? end-dt start-dt)\n                     (add-minutes end-dt (* 24 60)) ; Add one day if end is before start\n                     end-dt)]\n         [times (generate-times-helper start-dt end-dt '())])\n    (reverse times))) ; Reverse to maintain chronological order\n\n; Helper function to parse a time string \"HH:MM\" into a date struct\n(define (parse-time time-str)\n  (let* ([parts (string-split time-str \":\")]\n         [hours (string->number (first parts))]\n         [minutes (string->number (second parts))])\n    (seconds->date (* 60 (+ minutes (* 60 hours)))))) ; Convert to date struct\n\n; Helper function to compare two date structs representing times\n(define (time<? t1 t2)\n  (< (date->seconds t1) (date->seconds t2)))\n\n; Helper function to add minutes to a date struct\n(define (add-minutes dt minutes)\n  (seconds->date (+ (date->seconds dt) (* 60 minutes))))\n\n; Helper function to recursively generate times from start to end\n(define (generate-times-helper current-dt end-dt times)\n  (if (time<? end-dt current-dt)\n      times\n      (let* ([hours (date-hour current-dt)]\n             [minutes (date-minute current-dt)]\n             [time-str (format \"~a:~a\" \n                              (~a hours #:width 2 #:align 'right #:pad-string \"0\")\n                              (~a minutes #:width 2 #:align 'right #:pad-string \"0\"))]\n             [next-dt (add-minutes current-dt 1)])\n        (generate-times-helper next-dt end-dt (cons time-str times)))))", "test_cases": "", "test_case_results": "Start: 00:00, End: 00:05\nGenerated Times: (08:00 08:01 08:02 08:03 08:04 08:05)\nStart: 23:55, End: 00:05\nGenerated Times: (07:55 07:56 07:57 07:58 07:59 08:00 08:01 08:02 08:03 08:04 08:05)\nStart: 12:00, End: 12:00\nGenerated Times: (20:00)\nStart: 00:00, End: 23:59\nGenerated Times: (08:00 08:01 08:02 08:03 08:04 08:05 08:06 08:07 08:08 08:09 08:10 08:11 08:12 08:13 08:14 08:15 08:16 08:17 08:18 08:19 08:20 08:21 08:22 08:23 08:24 08:25 08:26 08:27 08:28 08:29 08:30 08:31 08:32 08:33 08:34 08:35 08:36 08:37 08:38 08:39 08:40 08:41 08:42 08:43 08:44 08:45 08:46 08:47 08:48 08:49 08:50 08:51 08:52 08:53 08:54 08:55 08:56 08:57 08:58 08:59 09:00 09:01 09:02 09:03 09:04 09:05 09:06 09:07 09:08 09:09 09:10 09:11 09:12 09:13 09:14 09:15 09:16 09:17 09:18 09:19 09:20 09:21 09:22 09:23 09:24 09:25 09:26 09:27 09:28 09:29 09:30 09:31 09:32 09:33 09:34 09:35 09:36 09:37 09:38 09:39 09:40 09:41 09:42 09:43 09:44 09:45 09:46 09:47 09:48 09:49 09:50 09:51 09:52 09:53 09:54 09:55 09:56 09:57 09:58 09:59 10:00 10:01 10:02 10:", "task_id": 25958, "assertions": "#lang racket\n\n(require racket/date)\n\n(define (test-generate-times)\n  (unless (equal? (generate-times \"00:00\" \"00:05\")\n                  '(\"00:00\" \"00:01\" \"00:02\" \"00:03\" \"00:04\" \"00:05\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (generate-times \"23:55\" \"00:05\")\n                  '(\"23:55\" \"23:56\" \"23:57\" \"23:58\" \"23:59\" \"00:00\" \"00:01\" \"00:02\" \"00:03\" \"00:04\" \"00:05\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (generate-times \"12:00\" \"12:00\")\n                  '(\"12:00\"))\n    (error \"Test 3 failed\"))\n  (unless (= (length (generate-times \"00:00\" \"23:59\")) 1440)\n    (error \"Test 4 failed\")))\n\n(test-generate-times)", "all_code": "#lang racket\n\n\n; Require the necessary standard libraries for date and time manipulation\n(require racket/date)\n\n; generate-times generates all valid times between start and end (inclusive) in HH:MM format.\n; The function takes two strings representing the start and end times in \"HH:MM\" format.\n; If the end time is earlier than the start time, it assumes the end time is on the next day.\n; The function returns a list of strings, each representing a time in \"HH:MM\" format.\n(define (generate-times start end)\n  (let* ([start-dt (parse-time start)]\n         [end-dt (parse-time end)]\n         [end-dt (if (time<? end-dt start-dt)\n                     (add-minutes end-dt (* 24 60)) ; Add one day if end is before start\n                     end-dt)]\n         [times (generate-times-helper start-dt end-dt '())])\n    (reverse times))) ; Reverse to maintain chronological order\n\n; Helper function to parse a time string \"HH:MM\" into a date struct\n(define (parse-time time-str)\n  (let* ([parts (string-split time-str \":\")]\n         [hours (string->number (first parts))]\n         [minutes (string->number (second parts))])\n    (seconds->date (* 60 (+ minutes (* 60 hours)))))) ; Convert to date struct\n\n; Helper function to compare two date structs representing times\n(define (time<? t1 t2)\n  (< (date->seconds t1) (date->seconds t2)))\n\n; Helper function to add minutes to a date struct\n(define (add-minutes dt minutes)\n  (seconds->date (+ (date->seconds dt) (* 60 minutes))))\n\n; Helper function to recursively generate times from start to end\n(define (generate-times-helper current-dt end-dt times)\n  (if (time<? end-dt current-dt)\n      times\n      (let* ([hours (date-hour current-dt)]\n             [minutes (date-minute current-dt)]\n             [time-str (format \"~a:~a\" \n                              (~a hours #:width 2 #:align 'right #:pad-string \"0\")\n                              (~a minutes #:width 2 #:align 'right #:pad-string \"0\"))]\n             [next-dt (add-minutes current-dt 1)])\n        (generate-times-helper next-dt end-dt (cons time-str times)))))\n\n\n(require racket/date)\n\n(define (test-generate-times)\n  (unless (equal? (generate-times \"00:00\" \"00:05\")\n                  '(\"00:00\" \"00:01\" \"00:02\" \"00:03\" \"00:04\" \"00:05\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (generate-times \"23:55\" \"00:05\")\n                  '(\"23:55\" \"23:56\" \"23:57\" \"23:58\" \"23:59\" \"00:00\" \"00:01\" \"00:02\" \"00:03\" \"00:04\" \"00:05\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (generate-times \"12:00\" \"12:00\")\n                  '(\"12:00\"))\n    (error \"Test 3 failed\"))\n  (unless (= (length (generate-times \"00:00\" \"23:59\")) 1440)\n    (error \"Test 4 failed\")))\n\n(test-generate-times)\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "#lang racket\n\n; traffic-light-simulation simulates a simple traffic light system at an intersection.\n; It determines the light color for North-South and East-West directions based on the current time step.\n; Parameters:\n; - current-time: The current time in seconds (integer).\n; - cycle-length: The total length of the traffic light cycle in seconds (integer).\n; - green-duration: The duration of the green light in seconds for each direction (integer).\n; Returns:\n; - A list of strings indicating the light color for \"North-South\" and \"East-West\" directions.\n(define (traffic-light-simulation current-time cycle-length green-duration)\n  (let ([time-in-cycle (modulo current-time cycle-length)])\n    (if (< time-in-cycle green-duration)\n        (list \"Green\" \"Red\")\n        (list \"Red\" \"Green\"))))", "test_cases": "", "test_case_results": "Input: current-time=0, cycle-length=60, green-duration=30\nLights: (Green Red)\nInput: current-time=29, cycle-length=60, green-duration=30\nLights: (Green Red)\nInput: current-time=30, cycle-length=60, green-duration=30\nLights: (Red Green)\nInput: current-time=59, cycle-length=60, green-duration=30\nLights: (Red Green)\nInput: current-time=60, cycle-length=60, green-duration=30\nLights: (Green Red)\nInput: current-time=15, cycle-length=20, green-duration=10\nLights: (Red Green)\nInput: current-time=15, cycle-length=20, green-duration=15\nLights: (Red Green)", "task_id": 10070, "assertions": "#lang racket\n\n(define (test-traffic-light-simulation)\n  (unless (equal? (traffic-light-simulation 0 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (traffic-light-simulation 29 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (traffic-light-simulation 30 60 30) '(\"Red\" \"Green\"))\n    (error \"Test 3 failed\"))\n  (unless (equal? (traffic-light-simulation 59 60 30) '(\"Red\" \"Green\"))\n    (error \"Test 4 failed\"))\n  (unless (equal? (traffic-light-simulation 60 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 5 failed\"))\n  (unless (equal? (traffic-light-simulation 15 20 10) '(\"Red\" \"Green\"))\n    (error \"Test 6 failed\"))\n  (unless (equal? (traffic-light-simulation 15 20 15) '(\"Red\" \"Green\"))\n    (error \"Test 7 failed\")))\n\n(test-traffic-light-simulation)", "all_code": "#lang racket\n\n\n; traffic-light-simulation simulates a simple traffic light system at an intersection.\n; It determines the light color for North-South and East-West directions based on the current time step.\n; Parameters:\n; - current-time: The current time in seconds (integer).\n; - cycle-length: The total length of the traffic light cycle in seconds (integer).\n; - green-duration: The duration of the green light in seconds for each direction (integer).\n; Returns:\n; - A list of strings indicating the light color for \"North-South\" and \"East-West\" directions.\n(define (traffic-light-simulation current-time cycle-length green-duration)\n  (let ([time-in-cycle (modulo current-time cycle-length)])\n    (if (< time-in-cycle green-duration)\n        (list \"Green\" \"Red\")\n        (list \"Red\" \"Green\"))))\n\n\n(define (test-traffic-light-simulation)\n  (unless (equal? (traffic-light-simulation 0 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 1 failed\"))\n  (unless (equal? (traffic-light-simulation 29 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 2 failed\"))\n  (unless (equal? (traffic-light-simulation 30 60 30) '(\"Red\" \"Green\"))\n    (error \"Test 3 failed\"))\n  (unless (equal? (traffic-light-simulation 59 60 30) '(\"Red\" \"Green\"))\n    (error \"Test 4 failed\"))\n  (unless (equal? (traffic-light-simulation 60 60 30) '(\"Green\" \"Red\"))\n    (error \"Test 5 failed\"))\n  (unless (equal? (traffic-light-simulation 15 20 10) '(\"Red\" \"Green\"))\n    (error \"Test 6 failed\"))\n  (unless (equal? (traffic-light-simulation 15 20 15) '(\"Red\" \"Green\"))\n    (error \"Test 7 failed\")))\n\n(test-traffic-light-simulation)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; flip-bit-longest-seq calculates the length of the longest sequence of 1s that can be obtained\n; by flipping exactly one bit from 0 to 1 in the binary representation of the given integer.\n; The function handles special cases for -1 (all bits 1) and 0 (all bits 0) explicitly.\n; For other numbers, it iterates through each bit, tracking the current and previous lengths of 1 sequences,\n; and computes the maximum possible sequence length achievable by flipping a single 0 to 1.\n(define (flip-bit-longest-seq num)\n  (cond\n    [(= num -1) 32]  ; All bits are 1, flipping any bit keeps 32 consecutive 1s\n    [(= num 0) 1]    ; Flipping any bit in 0 results in at least one 1\n    [else\n     (let loop ([num num]\n                [current-length 0]\n                [previous-length 0]\n                [max-length 1])  ; At least one bit can be flipped\n       (if (zero? num)\n           max-length\n           (let ([current-bit (bitwise-and num 1)])\n             (if (= current-bit 1)\n                 (loop (arithmetic-shift num -1)\n                       (add1 current-length)\n                       previous-length\n                       (max max-length (+ previous-length current-length 1)))\n                 (loop (arithmetic-shift num -1)\n                       0\n                       (if (= (bitwise-and num 2) 2) current-length 0)\n                       (max max-length (+ previous-length current-length 1)))))))]))", "test_cases": "", "test_case_results": "Input: -1\n32\nInput: 0\n1\nInput: 1\n1\nInput: 2\n1\nInput: 3\n2\nInput: 4\n1\nInput: 5\n2\nInput: 6\n2\nInput: 7\n3\nInput: 8\n1\nInput: 1775\n8\nInput: 2147483647\n31", "task_id": 24614, "assertions": "#lang racket\n\n(define (test-flip-bit-longest-seq)\n  (unless (= (flip-bit-longest-seq -1) 32)\n    (error \"Test -1 failed\"))\n  (unless (= (flip-bit-longest-seq 0) 1)\n    (error \"Test 0 failed\"))\n  (unless (= (flip-bit-longest-seq 1) 1)\n    (error \"Test 1 failed\"))\n  (unless (= (flip-bit-longest-seq 2) 1)\n    (error \"Test 2 failed\"))\n  (unless (= (flip-bit-longest-seq 3) 2)\n    (error \"Test 3 failed\"))\n  (unless (= (flip-bit-longest-seq 4) 1)\n    (error \"Test 4 failed\"))\n  (unless (= (flip-bit-longest-seq 5) 2)\n    (error \"Test 5 failed\"))\n  (unless (= (flip-bit-longest-seq 6) 2)\n    (error \"Test 6 failed\"))\n  (unless (= (flip-bit-longest-seq 7) 3)\n    (error \"Test 7 failed\"))\n  (unless (= (flip-bit-longest-seq 8) 1)\n    (error \"Test 8 failed\"))\n  (unless (= (flip-bit-longest-seq 1775) 8)\n    (error \"Test 1775 failed\"))\n  (unless (= (flip-bit-longest-seq 2147483647) 31)\n    (error \"Test 2147483647 failed\")))\n\n(test-flip-bit-longest-seq)", "all_code": "#lang racket\n\n\n; flip-bit-longest-seq calculates the length of the longest sequence of 1s that can be obtained\n; by flipping exactly one bit from 0 to 1 in the binary representation of the given integer.\n; The function handles special cases for -1 (all bits 1) and 0 (all bits 0) explicitly.\n; For other numbers, it iterates through each bit, tracking the current and previous lengths of 1 sequences,\n; and computes the maximum possible sequence length achievable by flipping a single 0 to 1.\n(define (flip-bit-longest-seq num)\n  (cond\n    [(= num -1) 32]  ; All bits are 1, flipping any bit keeps 32 consecutive 1s\n    [(= num 0) 1]    ; Flipping any bit in 0 results in at least one 1\n    [else\n     (let loop ([num num]\n                [current-length 0]\n                [previous-length 0]\n                [max-length 1])  ; At least one bit can be flipped\n       (if (zero? num)\n           max-length\n           (let ([current-bit (bitwise-and num 1)])\n             (if (= current-bit 1)\n                 (loop (arithmetic-shift num -1)\n                       (add1 current-length)\n                       previous-length\n                       (max max-length (+ previous-length current-length 1)))\n                 (loop (arithmetic-shift num -1)\n                       0\n                       (if (= (bitwise-and num 2) 2) current-length 0)\n                       (max max-length (+ previous-length current-length 1)))))))]))\n\n\n(define (test-flip-bit-longest-seq)\n  (unless (= (flip-bit-longest-seq -1) 32)\n    (error \"Test -1 failed\"))\n  (unless (= (flip-bit-longest-seq 0) 1)\n    (error \"Test 0 failed\"))\n  (unless (= (flip-bit-longest-seq 1) 1)\n    (error \"Test 1 failed\"))\n  (unless (= (flip-bit-longest-seq 2) 1)\n    (error \"Test 2 failed\"))\n  (unless (= (flip-bit-longest-seq 3) 2)\n    (error \"Test 3 failed\"))\n  (unless (= (flip-bit-longest-seq 4) 1)\n    (error \"Test 4 failed\"))\n  (unless (= (flip-bit-longest-seq 5) 2)\n    (error \"Test 5 failed\"))\n  (unless (= (flip-bit-longest-seq 6) 2)\n    (error \"Test 6 failed\"))\n  (unless (= (flip-bit-longest-seq 7) 3)\n    (error \"Test 7 failed\"))\n  (unless (= (flip-bit-longest-seq 8) 1)\n    (error \"Test 8 failed\"))\n  (unless (= (flip-bit-longest-seq 1775) 8)\n    (error \"Test 1775 failed\"))\n  (unless (= (flip-bit-longest-seq 2147483647) 31)\n    (error \"Test 2147483647 failed\")))\n\n(test-flip-bit-longest-seq)\n", "exec_outcome": "PASSED"}
{"code": "#lang racket\n\n; process-orders processes customer orders and checks against the available inventory.\n; It takes an inventory list of ISBN-quantity pairs and a list of orders (each order is a list of ISBNs).\n; It returns a list of \"YES\" or \"NO\" strings indicating whether each order can be fulfilled.\n(define (process-orders inventory orders)\n  ; Convert the inventory list to a hash table for quick lookup\n  (define inventory-hash (make-hash))\n  (for ([item inventory])\n    (hash-set! inventory-hash (first item) (second item)))\n  \n  ; Process each order\n  (for/list ([order orders])\n    (let ([temp-inventory (hash-copy inventory-hash)]\n          [can-fulfill #t])\n      ; Check each ISBN in the order\n      (for ([isbn order] #:break (not can-fulfill))\n        (if (> (hash-ref temp-inventory isbn 0) 0)\n            (hash-set! temp-inventory isbn (- (hash-ref temp-inventory isbn) 1))\n            (set! can-fulfill #f)))\n      (if can-fulfill \"YES\" \"NO\"))))", "test_cases": "", "test_case_results": "Inventory: ((123 3) (456 2) (789 1))\nOrders: ((123 456) (789 789) (123 123 123 123) (456 999))\nResults: (YES NO NO NO)", "task_id": 7160, "assertions": "#lang racket\n\n(define (test-process-orders)\n  (define test-inventory '((123 3) (456 2) (789 1)))\n  (define test-orders '((123 456) (789 789) (123 123 123 123) (456 999)))\n  (define expected-results '(YES NO NO NO))\n  \n  (define actual-results (process-orders test-inventory test-orders))\n  \n  (unless (equal? actual-results expected-results)\n    (error (format \"Test failed. Expected: ~a, Actual: ~a\" expected-results actual-results))))\n\n(test-process-orders)", "all_code": "#lang racket\n\n\n; process-orders processes customer orders and checks against the available inventory.\n; It takes an inventory list of ISBN-quantity pairs and a list of orders (each order is a list of ISBNs).\n; It returns a list of \"YES\" or \"NO\" strings indicating whether each order can be fulfilled.\n(define (process-orders inventory orders)\n  ; Convert the inventory list to a hash table for quick lookup\n  (define inventory-hash (make-hash))\n  (for ([item inventory])\n    (hash-set! inventory-hash (first item) (second item)))\n  \n  ; Process each order\n  (for/list ([order orders])\n    (let ([temp-inventory (hash-copy inventory-hash)]\n          [can-fulfill #t])\n      ; Check each ISBN in the order\n      (for ([isbn order] #:break (not can-fulfill))\n        (if (> (hash-ref temp-inventory isbn 0) 0)\n            (hash-set! temp-inventory isbn (- (hash-ref temp-inventory isbn) 1))\n            (set! can-fulfill #f)))\n      (if can-fulfill \"YES\" \"NO\"))))\n\n\n(define (test-process-orders)\n  (define test-inventory '((123 3) (456 2) (789 1)))\n  (define test-orders '((123 456) (789 789) (123 123 123 123) (456 999)))\n  (define expected-results '(YES NO NO NO))\n  \n  (define actual-results (process-orders test-inventory test-orders))\n  \n  (unless (equal? actual-results expected-results)\n    (error (format \"Test failed. Expected: ~a, Actual: ~a\" expected-results actual-results))))\n\n(test-process-orders)\n", "exec_outcome": "RUNTIME_ERROR"}
