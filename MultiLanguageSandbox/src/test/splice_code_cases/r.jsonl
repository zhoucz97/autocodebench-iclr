{"code": "max_tasks <- function(tasks, T1, T2) {\n  # Filter tasks to those within the time window [T1, T2]\n  filtered_tasks <- tasks[sapply(tasks, function(task) task[1] >= T1 && task[2] <= T2)]\n  \n  # If no tasks are within the window, return 0\n  if (length(filtered_tasks) == 0) {\n    return(0)\n  }\n  \n  # Convert the list of tasks into a matrix for easier sorting\n  task_matrix <- matrix(unlist(filtered_tasks), ncol = 2, byrow = TRUE)\n  \n  # Sort tasks by end time\n  task_matrix <- task_matrix[order(task_matrix[, 2]), ]\n  \n  count <- 0\n  last_end_time <- T1\n  \n  # Iterate through the sorted tasks and count non-overlapping ones\n  for (i in 1:nrow(task_matrix)) {\n    start <- task_matrix[i, 1]\n    end <- task_matrix[i, 2]\n    \n    if (start >= last_end_time) {\n      count <- count + 1\n      last_end_time = end\n    }\n  }\n  \n  return(count)\n}", "test_cases": "", "test_case_results": "Tasks:  [1, 3], [2, 5], [4, 6], [7, 9] \nT1:  1 , T2:  10 \nMaximum non-overlapping tasks:  3 \n\nTasks:  [1, 2], [3, 4], [5, 6] \nT1:  1 , T2:  6 \nMaximum non-overlapping tasks:  3 \n\nTasks:  [1, 4], [2, 3], [5, 7] \nT1:  1 , T2:  7 \nMaximum non-overlapping tasks:  2 \n\nTasks:  [10, 12], [11, 13], [14, 15] \nT1:  1 , T2:  5 \nMaximum non-overlapping tasks:  0", "task_id": 11765, "assertions": "test_max_tasks <- function() {\n  # Test case 1\n  stopifnot(max_tasks(list(c(1, 3), c(2, 5), c(4, 6), c(7, 9)), 1, 10) == 3)\n  \n  # Test case 2\n  stopifnot(max_tasks(list(c(1, 2), c(3, 4), c(5, 6)), 1, 6) == 3)\n  \n  # Test case 3\n  stopifnot(max_tasks(list(c(1, 4), c(2, 3), c(5, 7)), 1, 7) == 2)\n  \n  # Test case 4\n  stopifnot(max_tasks(list(c(10, 12), c(11, 13), c(14, 15)), 1, 5) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_tasks()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_tasks <- function() {\n  # Test case 1\n  stopifnot(max_tasks(list(c(1, 3), c(2, 5), c(4, 6), c(7, 9)), 1, 10) == 3)\n  \n  # Test case 2\n  stopifnot(max_tasks(list(c(1, 2), c(3, 4), c(5, 6)), 1, 6) == 3)\n  \n  # Test case 3\n  stopifnot(max_tasks(list(c(1, 4), c(2, 3), c(5, 7)), 1, 7) == 2)\n  \n  # Test case 4\n  stopifnot(max_tasks(list(c(10, 12), c(11, 13), c(14, 15)), 1, 5) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_tasks()", "output": "max_tasks"}, "all_code": "max_tasks <- function(tasks, T1, T2) {\n  # Filter tasks to those within the time window [T1, T2]\n  filtered_tasks <- tasks[sapply(tasks, function(task) task[1] >= T1 && task[2] <= T2)]\n  \n  # If no tasks are within the window, return 0\n  if (length(filtered_tasks) == 0) {\n    return(0)\n  }\n  \n  # Convert the list of tasks into a matrix for easier sorting\n  task_matrix <- matrix(unlist(filtered_tasks), ncol = 2, byrow = TRUE)\n  \n  # Sort tasks by end time\n  task_matrix <- task_matrix[order(task_matrix[, 2]), ]\n  \n  count <- 0\n  last_end_time <- T1\n  \n  # Iterate through the sorted tasks and count non-overlapping ones\n  for (i in 1:nrow(task_matrix)) {\n    start <- task_matrix[i, 1]\n    end <- task_matrix[i, 2]\n    \n    if (start >= last_end_time) {\n      count <- count + 1\n      last_end_time = end\n    }\n  }\n  \n  return(count)\n}\ntest_max_tasks <- function() {\n  # Test case 1\n  stopifnot(max_tasks(list(c(1, 3), c(2, 5), c(4, 6), c(7, 9)), 1, 10) == 3)\n  \n  # Test case 2\n  stopifnot(max_tasks(list(c(1, 2), c(3, 4), c(5, 6)), 1, 6) == 3)\n  \n  # Test case 3\n  stopifnot(max_tasks(list(c(1, 4), c(2, 3), c(5, 7)), 1, 7) == 2)\n  \n  # Test case 4\n  stopifnot(max_tasks(list(c(10, 12), c(11, 13), c(14, 15)), 1, 5) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_tasks()", "exec_outcome": "PASSED"}
{"code": "# max_satisfied_customers calculates the maximum number of customers that can be satisfied given the available quantities of vegetables.\n# It checks each customer's demands against the available quantities and deducts the demands if the customer can be satisfied.\n#\n# Args:\n#   n: integer, number of vegetable types\n#   m: integer, number of customers\n#   veg_quantities: numeric vector, quantities of each vegetable type available\n#   customers: list of numeric vectors, each customer's demands for each type of vegetable\n#\n# Returns:\n#   integer, maximum number of satisfied customers\nmax_satisfied_customers <- function(n, m, veg_quantities, customers) {\n    satisfied_customers <- 0\n\n    for (customer in customers) {\n        # Check if all customer demands can be met\n        can_satisfy <- all(mapply(function(v, c) v >= c, veg_quantities, customer))\n        \n        if (can_satisfy) {\n            # Deduct the customer's demand from available quantities\n            veg_quantities <- mapply(function(v, c) v - c, veg_quantities, customer)\n            satisfied_customers <- satisfied_customers + 1\n        }\n    }\n\n    return(satisfied_customers)\n}", "test_cases": "", "test_case_results": "Input:\n  n: 2 \n  m: 3 \n  veg_quantities: 5 7 \n  customers:\n     3 4 \n     2 2 \n     1 1 \nResult: 2 \n\nInput:\n  n: 3 \n  m: 2 \n  veg_quantities: 10 10 10 \n  customers:\n     5 5 5 \n     6 6 6 \nResult: 1 \n\nInput:\n  n: 1 \n  m: 2 \n  veg_quantities: 3 \n  customers:\n     2 \n     2 \nResult: 1", "task_id": 20102, "assertions": "test.max_satisfied_customers <- function() {\n    # Test case 1\n    stopifnot(max_satisfied_customers(2, 3, c(5, 7), list(c(3, 4), c(2, 2), c(1, 1))) == 2)\n    \n    # Test case 2\n    stopifnot(max_satisfied_customers(3, 2, c(10, 10, 10), list(c(5, 5, 5), c(6, 6, 6))) == 1)\n    \n    # Test case 3\n    stopifnot(max_satisfied_customers(1, 2, c(3), list(c(2), c(2))) == 1)\n}\n\ntest.max_satisfied_customers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.max_satisfied_customers <- function() {\n    # Test case 1\n    stopifnot(max_satisfied_customers(2, 3, c(5, 7), list(c(3, 4), c(2, 2), c(1, 1))) == 2)\n    \n    # Test case 2\n    stopifnot(max_satisfied_customers(3, 2, c(10, 10, 10), list(c(5, 5, 5), c(6, 6, 6))) == 1)\n    \n    # Test case 3\n    stopifnot(max_satisfied_customers(1, 2, c(3), list(c(2), c(2))) == 1)\n}\n\ntest.max_satisfied_customers()", "output": "max_satisfied_customers"}, "all_code": "# max_satisfied_customers calculates the maximum number of customers that can be satisfied given the available quantities of vegetables.\n# It checks each customer's demands against the available quantities and deducts the demands if the customer can be satisfied.\n#\n# Args:\n#   n: integer, number of vegetable types\n#   m: integer, number of customers\n#   veg_quantities: numeric vector, quantities of each vegetable type available\n#   customers: list of numeric vectors, each customer's demands for each type of vegetable\n#\n# Returns:\n#   integer, maximum number of satisfied customers\nmax_satisfied_customers <- function(n, m, veg_quantities, customers) {\n    satisfied_customers <- 0\n\n    for (customer in customers) {\n        # Check if all customer demands can be met\n        can_satisfy <- all(mapply(function(v, c) v >= c, veg_quantities, customer))\n        \n        if (can_satisfy) {\n            # Deduct the customer's demand from available quantities\n            veg_quantities <- mapply(function(v, c) v - c, veg_quantities, customer)\n            satisfied_customers <- satisfied_customers + 1\n        }\n    }\n\n    return(satisfied_customers)\n}\ntest.max_satisfied_customers <- function() {\n    # Test case 1\n    stopifnot(max_satisfied_customers(2, 3, c(5, 7), list(c(3, 4), c(2, 2), c(1, 1))) == 2)\n    \n    # Test case 2\n    stopifnot(max_satisfied_customers(3, 2, c(10, 10, 10), list(c(5, 5, 5), c(6, 6, 6))) == 1)\n    \n    # Test case 3\n    stopifnot(max_satisfied_customers(1, 2, c(3), list(c(2), c(2))) == 1)\n}\n\ntest.max_satisfied_customers()", "exec_outcome": "PASSED"}
{"code": "# max_unique_activities identifies the user with the maximum number of unique activities within a specified time range.\n# The function takes a list of logs, where each log is a vector containing userId, activityId, and timestamp.\n# It also takes start and end timestamps to define the time range of interest.\n# The function returns the userId of the user with the most unique activities in the specified time range.\n# If no activities fall within the time range, it returns NULL.\nmax_unique_activities <- function(logs, start, end) {\n  activity_count <- list()\n  \n  for (log in logs) {\n    userId <- log[1]\n    activityId <- log[2]\n    timestamp <- log[3]\n    if (timestamp >= start && timestamp <= end) {\n      if (is.null(activity_count[[userId]])) {\n        activity_count[[userId]] <- list()\n      }\n      if (!(activityId %in% activity_count[[userId]])) {\n        activity_count[[userId]] <- c(activity_count[[userId]], activityId)\n      }\n    }\n  }\n  \n  max_activities <- 0\n  user_with_max_activities <- NULL\n  \n  for (userId in names(activity_count)) {\n    current_activities <- length(activity_count[[userId]])\n    if (current_activities > max_activities) {\n      max_activities <- current_activities\n      user_with_max_activities <- userId\n    }\n  }\n  \n  return(user_with_max_activities)\n}", "test_cases": "", "test_case_results": "Logs: \n  User: user1 Activity: activity1 Timestamp: 100 \n  User: user1 Activity: activity2 Timestamp: 150 \n  User: user2 Activity: activity1 Timestamp: 200 \n  User: user2 Activity: activity3 Timestamp: 250 \n  User: user3 Activity: activity1 Timestamp: 300 \nStart: 100 End: 200 \nUser with most unique activities: user1 \n\nLogs: \n  User: user1 Activity: activity1 Timestamp: 50 \n  User: user1 Activity: activity2 Timestamp: 60 \n  User: user2 Activity: activity1 Timestamp: 70 \n  User: user2 Activity: activity3 Timestamp: 80 \n  User: user3 Activity: activity1 Timestamp: 90 \nStart: 100 End: 200 \nNo activities in the specified time range.\n\nLogs: \n  User: user1 Activity: activity1 Timestamp: 100 \n  User: user1 Activity: activity2 Timestamp: 100 \n  User: user2 Activity: activity1 Timestamp: 100 \n  User: user2 Activity: activity3 Timestamp: 100 \n  User: user3 Activity: activity1 Timestamp: 100 \nStart: 100 End: 100 \nUser with most unique activities: user1", "task_id": 16449, "assertions": "test_max_unique_activities <- function() {\n  # Test case 1: Multiple users with activities in range\n  logs1 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 150),\n    c(\"user2\", \"activity1\", 200),\n    c(\"user2\", \"activity3\", 250),\n    c(\"user3\", \"activity1\", 300)\n  )\n  stopifnot(max_unique_activities(logs1, 100, 200) == \"user1\")\n  \n  # Test case 2: No activities in range\n  logs2 <- list(\n    c(\"user1\", \"activity1\", 50),\n    c(\"user1\", \"activity2\", 60),\n    c(\"user2\", \"activity1\", 70),\n    c(\"user2\", \"activity3\", 80),\n    c(\"user3\", \"activity1\", 90)\n  )\n  stopifnot(is.null(max_unique_activities(logs2, 100, 200)))\n  \n  # Test case 3: All activities at same timestamp\n  logs3 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 100),\n    c(\"user2\", \"activity1\", 100),\n    c(\"user2\", \"activity3\", 100),\n    c(\"user3\", \"activity1\", 100)\n  )\n  stopifnot(max_unique_activities(logs3, 100, 100) == \"user1\")\n}\n\ntest_max_unique_activities()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_unique_activities <- function() {\n  # Test case 1: Multiple users with activities in range\n  logs1 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 150),\n    c(\"user2\", \"activity1\", 200),\n    c(\"user2\", \"activity3\", 250),\n    c(\"user3\", \"activity1\", 300)\n  )\n  stopifnot(max_unique_activities(logs1, 100, 200) == \"user1\")\n  \n  # Test case 2: No activities in range\n  logs2 <- list(\n    c(\"user1\", \"activity1\", 50),\n    c(\"user1\", \"activity2\", 60),\n    c(\"user2\", \"activity1\", 70),\n    c(\"user2\", \"activity3\", 80),\n    c(\"user3\", \"activity1\", 90)\n  )\n  stopifnot(is.null(max_unique_activities(logs2, 100, 200)))\n  \n  # Test case 3: All activities at same timestamp\n  logs3 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 100),\n    c(\"user2\", \"activity1\", 100),\n    c(\"user2\", \"activity3\", 100),\n    c(\"user3\", \"activity1\", 100)\n  )\n  stopifnot(max_unique_activities(logs3, 100, 100) == \"user1\")\n}\n\ntest_max_unique_activities()", "output": "max_unique_activities"}, "all_code": "# max_unique_activities identifies the user with the maximum number of unique activities within a specified time range.\n# The function takes a list of logs, where each log is a vector containing userId, activityId, and timestamp.\n# It also takes start and end timestamps to define the time range of interest.\n# The function returns the userId of the user with the most unique activities in the specified time range.\n# If no activities fall within the time range, it returns NULL.\nmax_unique_activities <- function(logs, start, end) {\n  activity_count <- list()\n  \n  for (log in logs) {\n    userId <- log[1]\n    activityId <- log[2]\n    timestamp <- log[3]\n    if (timestamp >= start && timestamp <= end) {\n      if (is.null(activity_count[[userId]])) {\n        activity_count[[userId]] <- list()\n      }\n      if (!(activityId %in% activity_count[[userId]])) {\n        activity_count[[userId]] <- c(activity_count[[userId]], activityId)\n      }\n    }\n  }\n  \n  max_activities <- 0\n  user_with_max_activities <- NULL\n  \n  for (userId in names(activity_count)) {\n    current_activities <- length(activity_count[[userId]])\n    if (current_activities > max_activities) {\n      max_activities <- current_activities\n      user_with_max_activities <- userId\n    }\n  }\n  \n  return(user_with_max_activities)\n}\ntest_max_unique_activities <- function() {\n  # Test case 1: Multiple users with activities in range\n  logs1 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 150),\n    c(\"user2\", \"activity1\", 200),\n    c(\"user2\", \"activity3\", 250),\n    c(\"user3\", \"activity1\", 300)\n  )\n  stopifnot(max_unique_activities(logs1, 100, 200) == \"user1\")\n  \n  # Test case 2: No activities in range\n  logs2 <- list(\n    c(\"user1\", \"activity1\", 50),\n    c(\"user1\", \"activity2\", 60),\n    c(\"user2\", \"activity1\", 70),\n    c(\"user2\", \"activity3\", 80),\n    c(\"user3\", \"activity1\", 90)\n  )\n  stopifnot(is.null(max_unique_activities(logs2, 100, 200)))\n  \n  # Test case 3: All activities at same timestamp\n  logs3 <- list(\n    c(\"user1\", \"activity1\", 100),\n    c(\"user1\", \"activity2\", 100),\n    c(\"user2\", \"activity1\", 100),\n    c(\"user2\", \"activity3\", 100),\n    c(\"user3\", \"activity1\", 100)\n  )\n  stopifnot(max_unique_activities(logs3, 100, 100) == \"user1\")\n}\n\ntest_max_unique_activities()", "exec_outcome": "PASSED"}
{"code": "# odd_chars function takes a string as input and returns a new string composed of characters \n# that appear an odd number of times in the input string.\n# It uses the table function in R to count character occurrences and filters characters with odd counts.\nodd_chars <- function(string) {\n  # Convert the string into a vector of individual characters\n  chars <- strsplit(string, \"\")[[1]]\n  \n  # Count the occurrences of each character\n  char_counts <- table(chars)\n  \n  # Filter characters with odd counts\n  odd_chars <- names(char_counts)[char_counts %% 2 != 0]\n  \n  # Combine the filtered characters into a single string\n  result <- paste(odd_chars, collapse = \"\")\n  \n  return(result)\n}", "test_cases": "", "test_case_results": "Input:  hello \nResult:  eho \nInput:  world \nResult:  dlorw \nInput:  aabbcc \nResult:   \nInput:  abcabc \nResult:   \nInput:  aaabbbccc \nResult:  abc", "task_id": 15500, "assertions": "test_odd_chars <- function() {\n    stopifnot(odd_chars(\"hello\") == \"eho\")\n    stopifnot(odd_chars(\"world\") == \"dlorw\")\n    stopifnot(odd_chars(\"aabbcc\") == \"\")\n    stopifnot(odd_chars(\"abcabc\") == \"\")\n    stopifnot(odd_chars(\"aaabbbccc\") == \"abc\")\n}\n\ntest_odd_chars()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_odd_chars <- function() {\n    stopifnot(odd_chars(\"hello\") == \"eho\")\n    stopifnot(odd_chars(\"world\") == \"dlorw\")\n    stopifnot(odd_chars(\"aabbcc\") == \"\")\n    stopifnot(odd_chars(\"abcabc\") == \"\")\n    stopifnot(odd_chars(\"aaabbbccc\") == \"abc\")\n}\n\ntest_odd_chars()", "output": "odd_chars"}, "all_code": "# odd_chars function takes a string as input and returns a new string composed of characters \n# that appear an odd number of times in the input string.\n# It uses the table function in R to count character occurrences and filters characters with odd counts.\nodd_chars <- function(string) {\n  # Convert the string into a vector of individual characters\n  chars <- strsplit(string, \"\")[[1]]\n  \n  # Count the occurrences of each character\n  char_counts <- table(chars)\n  \n  # Filter characters with odd counts\n  odd_chars <- names(char_counts)[char_counts %% 2 != 0]\n  \n  # Combine the filtered characters into a single string\n  result <- paste(odd_chars, collapse = \"\")\n  \n  return(result)\n}\ntest_odd_chars <- function() {\n    stopifnot(odd_chars(\"hello\") == \"eho\")\n    stopifnot(odd_chars(\"world\") == \"dlorw\")\n    stopifnot(odd_chars(\"aabbcc\") == \"\")\n    stopifnot(odd_chars(\"abcabc\") == \"\")\n    stopifnot(odd_chars(\"aaabbbccc\") == \"abc\")\n}\n\ntest_odd_chars()", "exec_outcome": "PASSED"}
{"code": "minimal_subarray_length <- function(a, n, x) {\n    left <- 1  # R uses 1-based indexing\n    curr_sum <- 0\n    min_len <- Inf\n\n    for (right in 1:n) {\n        curr_sum <- curr_sum + a[right]\n        \n        while (curr_sum >= x) {\n            min_len <- min(min_len, right - left + 1)\n            curr_sum <- curr_sum - a[left]\n            left <- left + 1\n        }\n    }\n    \n    if (min_len != Inf) {\n        return(min_len)\n    } else {\n        return(-1)\n    }\n}", "test_cases": "", "test_case_results": "Input array:  1 4 45 6 0 19 \nTarget sum (x):  51 \nMinimal subarray length:  2 \n\nInput array:  1 10 5 2 7 \nTarget sum (x):  9 \nMinimal subarray length:  1 \n\nInput array:  1 11 100 1 0 200 3 2 1 250 \nTarget sum (x):  280 \nMinimal subarray length:  4 \n\nInput array:  1 2 4 \nTarget sum (x):  8 \nMinimal subarray length:  -1", "task_id": 17075, "assertions": "test_minimal_subarray_length <- function() {\n    stopifnot(minimal_subarray_length(c(1, 4, 45, 6, 0, 19), 6, 51) == 2)\n    stopifnot(minimal_subarray_length(c(1, 10, 5, 2, 7), 5, 9) == 1)\n    stopifnot(minimal_subarray_length(c(1, 11, 100, 1, 0, 200, 3, 2, 1, 250), 10, 280) == 4)\n    stopifnot(minimal_subarray_length(c(1, 2, 4), 3, 8) == -1)\n}\n\ntest_minimal_subarray_length()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_minimal_subarray_length <- function() {\n    stopifnot(minimal_subarray_length(c(1, 4, 45, 6, 0, 19), 6, 51) == 2)\n    stopifnot(minimal_subarray_length(c(1, 10, 5, 2, 7), 5, 9) == 1)\n    stopifnot(minimal_subarray_length(c(1, 11, 100, 1, 0, 200, 3, 2, 1, 250), 10, 280) == 4)\n    stopifnot(minimal_subarray_length(c(1, 2, 4), 3, 8) == -1)\n}\n\ntest_minimal_subarray_length()", "output": "minimal_subarray_length"}, "all_code": "minimal_subarray_length <- function(a, n, x) {\n    left <- 1  # R uses 1-based indexing\n    curr_sum <- 0\n    min_len <- Inf\n\n    for (right in 1:n) {\n        curr_sum <- curr_sum + a[right]\n        \n        while (curr_sum >= x) {\n            min_len <- min(min_len, right - left + 1)\n            curr_sum <- curr_sum - a[left]\n            left <- left + 1\n        }\n    }\n    \n    if (min_len != Inf) {\n        return(min_len)\n    } else {\n        return(-1)\n    }\n}\ntest_minimal_subarray_length <- function() {\n    stopifnot(minimal_subarray_length(c(1, 4, 45, 6, 0, 19), 6, 51) == 2)\n    stopifnot(minimal_subarray_length(c(1, 10, 5, 2, 7), 5, 9) == 1)\n    stopifnot(minimal_subarray_length(c(1, 11, 100, 1, 0, 200, 3, 2, 1, 250), 10, 280) == 4)\n    stopifnot(minimal_subarray_length(c(1, 2, 4), 3, 8) == -1)\n}\n\ntest_minimal_subarray_length()", "exec_outcome": "PASSED"}
{"code": "# find_pattern_indices returns a vector of starting indices in the text where any of the patterns are found.\n# The function searches for each pattern in the text and records all starting positions of matches.\n# The indices are sorted in ascending order to reflect their order of occurrence in the text.\nfind_pattern_indices <- function(patterns, text) {\n  indices <- c()\n  for (pattern in patterns) {\n    start <- 1  # R strings are 1-indexed\n    while (start <= nchar(text)) {\n      # Find the pattern in the text starting from 'start'\n      pos <- regexpr(pattern, substring(text, start, nchar(text)))\n      if (pos == -1) {\n        break\n      }\n      # Adjust the position to be relative to the entire text\n      absolute_pos <- start + pos - 1\n      indices <- c(indices, absolute_pos)\n      start <- absolute_pos + 1  # Move past this match to find subsequent ones\n    }\n  }\n  return(sort(indices))  # Return sorted indices\n}", "test_cases": "", "test_case_results": "Patterns:  ab, bc \nText:  abcbcab \nIndices:  1, 2, 4, 6 \n\nPatterns:  aa, bb \nText:  aabbccaa \nIndices:  1, 3, 7 \n\nPatterns:  x, y \nText:  zzz \nIndices:   \n\nPatterns:  hello, world \nText:  hello world hello \nIndices:  1, 7, 13", "task_id": 21961, "assertions": "test.find_pattern_indices <- function() {\n    # Test case 1\n    stopifnot(identical(\n        find_pattern_indices(c(\"ab\", \"bc\"), \"abcbcab\"),\n        c(1, 2, 4, 6)\n    ))\n    \n    # Test case 2\n    stopifnot(identical(\n        find_pattern_indices(c(\"aa\", \"bb\"), \"aabbccaa\"),\n        c(1, 3, 7)\n    ))\n    \n    # Test case 3\n    stopifnot(identical(\n        find_pattern_indices(c(\"x\", \"y\"), \"zzz\"),\n        integer(0)\n    ))\n    \n    # Test case 4\n    stopifnot(identical(\n        find_pattern_indices(c(\"hello\", \"world\"), \"hello world hello\"),\n        c(1, 7, 13)\n    ))\n}\n\ntest.find_pattern_indices()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.find_pattern_indices <- function() {\n    # Test case 1\n    stopifnot(identical(\n        find_pattern_indices(c(\"ab\", \"bc\"), \"abcbcab\"),\n        c(1, 2, 4, 6)\n    ))\n    \n    # Test case 2\n    stopifnot(identical(\n        find_pattern_indices(c(\"aa\", \"bb\"), \"aabbccaa\"),\n        c(1, 3, 7)\n    ))\n    \n    # Test case 3\n    stopifnot(identical(\n        find_pattern_indices(c(\"x\", \"y\"), \"zzz\"),\n        integer(0)\n    ))\n    \n    # Test case 4\n    stopifnot(identical(\n        find_pattern_indices(c(\"hello\", \"world\"), \"hello world hello\"),\n        c(1, 7, 13)\n    ))\n}\n\ntest.find_pattern_indices()", "output": "find_pattern_indices"}, "all_code": "# find_pattern_indices returns a vector of starting indices in the text where any of the patterns are found.\n# The function searches for each pattern in the text and records all starting positions of matches.\n# The indices are sorted in ascending order to reflect their order of occurrence in the text.\nfind_pattern_indices <- function(patterns, text) {\n  indices <- c()\n  for (pattern in patterns) {\n    start <- 1  # R strings are 1-indexed\n    while (start <= nchar(text)) {\n      # Find the pattern in the text starting from 'start'\n      pos <- regexpr(pattern, substring(text, start, nchar(text)))\n      if (pos == -1) {\n        break\n      }\n      # Adjust the position to be relative to the entire text\n      absolute_pos <- start + pos - 1\n      indices <- c(indices, absolute_pos)\n      start <- absolute_pos + 1  # Move past this match to find subsequent ones\n    }\n  }\n  return(sort(indices))  # Return sorted indices\n}\ntest.find_pattern_indices <- function() {\n    # Test case 1\n    stopifnot(identical(\n        find_pattern_indices(c(\"ab\", \"bc\"), \"abcbcab\"),\n        c(1, 2, 4, 6)\n    ))\n    \n    # Test case 2\n    stopifnot(identical(\n        find_pattern_indices(c(\"aa\", \"bb\"), \"aabbccaa\"),\n        c(1, 3, 7)\n    ))\n    \n    # Test case 3\n    stopifnot(identical(\n        find_pattern_indices(c(\"x\", \"y\"), \"zzz\"),\n        integer(0)\n    ))\n    \n    # Test case 4\n    stopifnot(identical(\n        find_pattern_indices(c(\"hello\", \"world\"), \"hello world hello\"),\n        c(1, 7, 13)\n    ))\n}\n\ntest.find_pattern_indices()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# Function to find the farthest node and its distance from a given start node using BFS.\n# Parameters:\n#   start: The starting node for BFS.\n#   n: The total number of nodes in the tree.\n#   graph: An adjacency list representing the tree.\n# Returns:\n#   A list containing the farthest node and its distance from the start node.\nfind_farthest_node <- function(start, n, graph) {\n    visited <- rep(FALSE, n + 1)\n    queue <- list(list(current_node = start, distance = 0))\n    visited[start] <- TRUE\n    farthest_node <- start\n    max_distance <- 0\n    \n    while (length(queue) > 0) {\n        current <- queue[[1]]\n        queue <- queue[-1]\n        current_node <- current$current_node\n        distance <- current$distance\n        \n        for (neighbor in graph[[current_node]]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] <- TRUE\n                queue <- append(queue, list(list(current_node = neighbor, distance = distance + 1)))\n                if (distance + 1 > max_distance) {\n                    max_distance = distance + 1\n                    farthest_node = neighbor\n                }\n            }\n        }\n    }\n    \n    return(list(farthest_node = farthest_node, max_distance = max_distance))\n}\n\n# Function to compute the diameter of a tree.\n# The diameter is found by first finding the farthest node from an arbitrary node (node 1),\n# and then finding the farthest node from that node.\n# Parameters:\n#   n: The total number of nodes in the tree.\n#   edges: A list of edges, where each edge is represented as a vector of two nodes.\n# Returns:\n#   The diameter of the tree.\ntree_diameter <- function(n, edges) {\n    graph <- vector(\"list\", n + 1)\n    for (i in 1:length(edges)) {\n        u <- edges[[i]][1]\n        v <- edges[[i]][2]\n        graph[[u]] <- c(graph[[u]], v)\n        graph[[v]] <- c(graph[[v]], u)\n    }\n    \n    # Find the farthest node from node 1\n    first_result <- find_farthest_node(1, n, graph)\n    first_node <- first_result$farthest_node\n    \n    # Find the farthest node from first_node\n    second_result <- find_farthest_node(first_node, n, graph)\n    diameter <- second_result$max_distance\n    \n    return(diameter)\n}", "test_cases": "", "test_case_results": "Input:\nNumber of nodes (n): 4 \nEdges: 1-2, 1-3, 2-4 \nDiameter: 3 \n\nInput:\nNumber of nodes (n): 5 \nEdges: 1-2, 2-3, 3-4, 4-5 \nDiameter: 4 \n\nInput:\nNumber of nodes (n): 6 \nEdges: 1-2, 2-3, 2-4, 4-5, 5-6 \nDiameter: 4", "task_id": 1129, "assertions": "test_tree_diameter <- function() {\n    # Test case 1\n    edges1 <- list(c(1, 2), c(1, 3), c(2, 4))\n    stopifnot(tree_diameter(4, edges1) == 3)\n    \n    # Test case 2\n    edges2 <- list(c(1, 2), c(2, 3), c(3, 4), c(4, 5))\n    stopifnot(tree_diameter(5, edges2) == 4)\n    \n    # Test case 3\n    edges3 <- list(c(1, 2), c(2, 3), c(2, 4), c(4, 5), c(5, 6))\n    stopifnot(tree_diameter(6, edges3) == 4)\n}\n\ntest_tree_diameter()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_tree_diameter <- function() {\n    # Test case 1\n    edges1 <- list(c(1, 2), c(1, 3), c(2, 4))\n    stopifnot(tree_diameter(4, edges1) == 3)\n    \n    # Test case 2\n    edges2 <- list(c(1, 2), c(2, 3), c(3, 4), c(4, 5))\n    stopifnot(tree_diameter(5, edges2) == 4)\n    \n    # Test case 3\n    edges3 <- list(c(1, 2), c(2, 3), c(2, 4), c(4, 5), c(5, 6))\n    stopifnot(tree_diameter(6, edges3) == 4)\n}\n\ntest_tree_diameter()", "output": "tree_diameter"}, "all_code": "# Function to find the farthest node and its distance from a given start node using BFS.\n# Parameters:\n#   start: The starting node for BFS.\n#   n: The total number of nodes in the tree.\n#   graph: An adjacency list representing the tree.\n# Returns:\n#   A list containing the farthest node and its distance from the start node.\nfind_farthest_node <- function(start, n, graph) {\n    visited <- rep(FALSE, n + 1)\n    queue <- list(list(current_node = start, distance = 0))\n    visited[start] <- TRUE\n    farthest_node <- start\n    max_distance <- 0\n    \n    while (length(queue) > 0) {\n        current <- queue[[1]]\n        queue <- queue[-1]\n        current_node <- current$current_node\n        distance <- current$distance\n        \n        for (neighbor in graph[[current_node]]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] <- TRUE\n                queue <- append(queue, list(list(current_node = neighbor, distance = distance + 1)))\n                if (distance + 1 > max_distance) {\n                    max_distance = distance + 1\n                    farthest_node = neighbor\n                }\n            }\n        }\n    }\n    \n    return(list(farthest_node = farthest_node, max_distance = max_distance))\n}\n\n# Function to compute the diameter of a tree.\n# The diameter is found by first finding the farthest node from an arbitrary node (node 1),\n# and then finding the farthest node from that node.\n# Parameters:\n#   n: The total number of nodes in the tree.\n#   edges: A list of edges, where each edge is represented as a vector of two nodes.\n# Returns:\n#   The diameter of the tree.\ntree_diameter <- function(n, edges) {\n    graph <- vector(\"list\", n + 1)\n    for (i in 1:length(edges)) {\n        u <- edges[[i]][1]\n        v <- edges[[i]][2]\n        graph[[u]] <- c(graph[[u]], v)\n        graph[[v]] <- c(graph[[v]], u)\n    }\n    \n    # Find the farthest node from node 1\n    first_result <- find_farthest_node(1, n, graph)\n    first_node <- first_result$farthest_node\n    \n    # Find the farthest node from first_node\n    second_result <- find_farthest_node(first_node, n, graph)\n    diameter <- second_result$max_distance\n    \n    return(diameter)\n}\ntest_tree_diameter <- function() {\n    # Test case 1\n    edges1 <- list(c(1, 2), c(1, 3), c(2, 4))\n    stopifnot(tree_diameter(4, edges1) == 3)\n    \n    # Test case 2\n    edges2 <- list(c(1, 2), c(2, 3), c(3, 4), c(4, 5))\n    stopifnot(tree_diameter(5, edges2) == 4)\n    \n    # Test case 3\n    edges3 <- list(c(1, 2), c(2, 3), c(2, 4), c(4, 5), c(5, 6))\n    stopifnot(tree_diameter(6, edges3) == 4)\n}\n\ntest_tree_diameter()", "exec_outcome": "PASSED"}
{"code": "# count_comfortable_days calculates the number of days when the temperature was within a specified range [tmin, tmax]\n# and the humidity was less than or equal to a specified maximum humidity (hmax).\n# The function takes the following parameters:\n#   - n: The number of days (not used in the function but included for completeness)\n#   - tmin: The minimum comfortable temperature\n#   - tmax: The maximum comfortable temperature\n#   - hmax: The maximum comfortable humidity\n#   - weather_data: A list of pairs (temperature, humidity) for each day\n# The function returns the count of days that meet the comfort conditions.\ncount_comfortable_days <- function(n, tmin, tmax, hmax, weather_data) {\n    comfortable_days <- 0\n    \n    for (day in weather_data) {\n        temp <- day[1]\n        humidity <- day[2]\n        if (temp >= tmin && temp <= tmax && humidity <= hmax) {\n            comfortable_days <- comfortable_days + 1\n        }\n    }\n    \n    return(comfortable_days)\n}", "test_cases": "", "test_case_results": "Input:\n  n: 5 \n  tmin: 20 \n  tmax: 30 \n  hmax: 80 \n  weather_data: (25, 70), (15, 60), (30, 90), (22, 75), (28, 65) \nComfortable days: 3 \n\nInput:\n  n: 3 \n  tmin: 10 \n  tmax: 20 \n  hmax: 50 \n  weather_data: (12, 45), (18, 55), (9, 30) \nComfortable days: 1 \n\nInput:\n  n: 4 \n  tmin: 0 \n  tmax: 10 \n  hmax: 60 \n  weather_data: (5, 50), (-2, 40), (10, 70), (8, 55) \nComfortable days: 2", "task_id": 20900, "assertions": "test_comfortable_days <- function() {\n    # Test case 1\n    stopifnot(count_comfortable_days(\n        n = 5,\n        tmin = 20,\n        tmax = 30,\n        hmax = 80,\n        weather_data = list(c(25, 70), c(15, 60), c(30, 90), c(22, 75), c(28, 65))\n    ) == 3)\n    \n    # Test case 2\n    stopifnot(count_comfortable_days(\n        n = 3,\n        tmin = 10,\n        tmax = 20,\n        hmax = 50,\n        weather_data = list(c(12, 45), c(18, 55), c(9, 30))\n    ) == 1)\n    \n    # Test case 3\n    stopifnot(count_comfortable_days(\n        n = 4,\n        tmin = 0,\n        tmax = 10,\n        hmax = 60,\n        weather_data = list(c(5, 50), c(-2, 40), c(10, 70), c(8, 55))\n    ) == 2)\n}\n\ntest_comfortable_days()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_comfortable_days <- function() {\n    # Test case 1\n    stopifnot(count_comfortable_days(\n        n = 5,\n        tmin = 20,\n        tmax = 30,\n        hmax = 80,\n        weather_data = list(c(25, 70), c(15, 60), c(30, 90), c(22, 75), c(28, 65))\n    ) == 3)\n    \n    # Test case 2\n    stopifnot(count_comfortable_days(\n        n = 3,\n        tmin = 10,\n        tmax = 20,\n        hmax = 50,\n        weather_data = list(c(12, 45), c(18, 55), c(9, 30))\n    ) == 1)\n    \n    # Test case 3\n    stopifnot(count_comfortable_days(\n        n = 4,\n        tmin = 0,\n        tmax = 10,\n        hmax = 60,\n        weather_data = list(c(5, 50), c(-2, 40), c(10, 70), c(8, 55))\n    ) == 2)\n}\n\ntest_comfortable_days()", "output": "count_comfortable_days"}, "all_code": "# count_comfortable_days calculates the number of days when the temperature was within a specified range [tmin, tmax]\n# and the humidity was less than or equal to a specified maximum humidity (hmax).\n# The function takes the following parameters:\n#   - n: The number of days (not used in the function but included for completeness)\n#   - tmin: The minimum comfortable temperature\n#   - tmax: The maximum comfortable temperature\n#   - hmax: The maximum comfortable humidity\n#   - weather_data: A list of pairs (temperature, humidity) for each day\n# The function returns the count of days that meet the comfort conditions.\ncount_comfortable_days <- function(n, tmin, tmax, hmax, weather_data) {\n    comfortable_days <- 0\n    \n    for (day in weather_data) {\n        temp <- day[1]\n        humidity <- day[2]\n        if (temp >= tmin && temp <= tmax && humidity <= hmax) {\n            comfortable_days <- comfortable_days + 1\n        }\n    }\n    \n    return(comfortable_days)\n}\ntest_comfortable_days <- function() {\n    # Test case 1\n    stopifnot(count_comfortable_days(\n        n = 5,\n        tmin = 20,\n        tmax = 30,\n        hmax = 80,\n        weather_data = list(c(25, 70), c(15, 60), c(30, 90), c(22, 75), c(28, 65))\n    ) == 3)\n    \n    # Test case 2\n    stopifnot(count_comfortable_days(\n        n = 3,\n        tmin = 10,\n        tmax = 20,\n        hmax = 50,\n        weather_data = list(c(12, 45), c(18, 55), c(9, 30))\n    ) == 1)\n    \n    # Test case 3\n    stopifnot(count_comfortable_days(\n        n = 4,\n        tmin = 0,\n        tmax = 10,\n        hmax = 60,\n        weather_data = list(c(5, 50), c(-2, 40), c(10, 70), c(8, 55))\n    ) == 2)\n}\n\ntest_comfortable_days()", "exec_outcome": "PASSED"}
{"code": "max_substring_length_with_k_operations <- function(s, k) {\n    n <- nchar(s)\n    max_len <- 0\n\n    for (start in 1:n) {\n        frequency <- list()\n        unique_count <- 0\n        max_possible_len <- 0\n\n        for (end in start:n) {\n            current_char <- substr(s, end, end)\n            if (is.null(frequency[[current_char]])) {\n                frequency[[current_char]] <- 0\n            }\n            frequency[[current_char]] <- frequency[[current_char]] + 1\n\n            if (frequency[[current_char]] == 1) {\n                unique_count <- unique_count + 1\n            }\n\n            while (unique_count + k < (end - start + 1)) {\n                start_char <- substr(s, start, start)\n                frequency[[start_char]] <- frequency[[start_char]] - 1\n                if (frequency[[start_char]] == 0) {\n                    unique_count <- unique_count - 1\n                }\n                start <- start + 1\n            }\n\n            max_possible_len <- end - start + 1\n            max_len <- max(max_len, min(max_possible_len, unique_count + k))\n        }\n    }\n\n    return(max_len)\n}", "test_cases": "", "test_case_results": "Input string:  aababba , k:  1 \nMaximum substring length:  3 \nInput string:  abcdef , k:  2 \nMaximum substring length:  6 \nInput string:  aaabbb , k:  3 \nMaximum substring length:  5 \nInput string:  aabbcc , k:  0 \nMaximum substring length:  2", "task_id": 23970, "assertions": "test_max_substring <- function() {\n    stopifnot(max_substring_length_with_k_operations(\"aababba\", 1) == 3)\n    stopifnot(max_substring_length_with_k_operations(\"abcdef\", 2) == 6)\n    stopifnot(max_substring_length_with_k_operations(\"aaabbb\", 3) == 5)\n    stopifnot(max_substring_length_with_k_operations(\"aabbcc\", 0) == 2)\n}\n\ntest_max_substring()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_substring <- function() {\n    stopifnot(max_substring_length_with_k_operations(\"aababba\", 1) == 3)\n    stopifnot(max_substring_length_with_k_operations(\"abcdef\", 2) == 6)\n    stopifnot(max_substring_length_with_k_operations(\"aaabbb\", 3) == 5)\n    stopifnot(max_substring_length_with_k_operations(\"aabbcc\", 0) == 2)\n}\n\ntest_max_substring()", "output": "max_substring_length_with_k_operations"}, "all_code": "max_substring_length_with_k_operations <- function(s, k) {\n    n <- nchar(s)\n    max_len <- 0\n\n    for (start in 1:n) {\n        frequency <- list()\n        unique_count <- 0\n        max_possible_len <- 0\n\n        for (end in start:n) {\n            current_char <- substr(s, end, end)\n            if (is.null(frequency[[current_char]])) {\n                frequency[[current_char]] <- 0\n            }\n            frequency[[current_char]] <- frequency[[current_char]] + 1\n\n            if (frequency[[current_char]] == 1) {\n                unique_count <- unique_count + 1\n            }\n\n            while (unique_count + k < (end - start + 1)) {\n                start_char <- substr(s, start, start)\n                frequency[[start_char]] <- frequency[[start_char]] - 1\n                if (frequency[[start_char]] == 0) {\n                    unique_count <- unique_count - 1\n                }\n                start <- start + 1\n            }\n\n            max_possible_len <- end - start + 1\n            max_len <- max(max_len, min(max_possible_len, unique_count + k))\n        }\n    }\n\n    return(max_len)\n}\ntest_max_substring <- function() {\n    stopifnot(max_substring_length_with_k_operations(\"aababba\", 1) == 3)\n    stopifnot(max_substring_length_with_k_operations(\"abcdef\", 2) == 6)\n    stopifnot(max_substring_length_with_k_operations(\"aaabbb\", 3) == 5)\n    stopifnot(max_substring_length_with_k_operations(\"aabbcc\", 0) == 2)\n}\n\ntest_max_substring()", "exec_outcome": "PASSED"}
{"code": "# top_k_frequent_phrases finds the top k most frequent search phrases in a list of queries.\n# It counts the frequency of each query, sorts them by frequency (descending) and then alphabetically (ascending),\n# and returns the top k phrases.\n#\n# Parameters:\n# queries (character vector): A vector of search queries where each query is a string.\n# k (integer): An integer representing the number of top frequent phrases to return.\n#\n# Returns:\n# character vector: A vector of the k most frequent search phrases.\ntop_k_frequent_phrases <- function(queries, k) {\n  # Count the frequency of each query\n  freq <- table(queries)\n  \n  # Convert to a data frame for easier sorting\n  freq_df <- data.frame(phrase = names(freq), count = as.numeric(freq), stringsAsFactors = FALSE)\n  \n  # Sort by count (descending) and then by phrase (ascending)\n  freq_df <- freq_df[order(-freq_df$count, freq_df$phrase), ]\n  \n  # Extract the top k phrases\n  result <- freq_df$phrase[1:min(k, nrow(freq_df))]\n  return(result)\n}", "test_cases": "", "test_case_results": "Input queries:  apple, banana, apple, orange, banana, apple \nk:  2 \nTop k frequent phrases:  apple, banana \n\nInput queries:  cat, dog, cat, bird, dog, cat, dog \nk:  3 \nTop k frequent phrases:  cat, dog, bird \n\nInput queries:  red, red, blue, green \nk:  1 \nTop k frequent phrases:  red \n\nInput queries:  one, two, three \nk:  5 \nTop k frequent phrases:  one, three, two", "task_id": 22596, "assertions": "test_top_k_frequent_phrases <- function() {\n    # Test case 1\n    queries1 <- c(\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\")\n    stopifnot(all(top_k_frequent_phrases(queries1, 2) == c(\"apple\", \"banana\")))\n    \n    # Test case 2\n    queries2 <- c(\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"cat\", \"dog\")\n    stopifnot(all(top_k_frequent_phrases(queries2, 3) == c(\"cat\", \"dog\", \"bird\")))\n    \n    # Test case 3\n    queries3 <- c(\"red\", \"red\", \"blue\", \"green\")\n    stopifnot(all(top_k_frequent_phrases(queries3, 1) == \"red\"))\n    \n    # Test case 4\n    queries4 <- c(\"one\", \"two\", \"three\")\n    stopifnot(all(top_k_frequent_phrases(queries4, 5) == c(\"one\", \"three\", \"two\")))\n}\n\ntest_top_k_frequent_phrases()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_top_k_frequent_phrases <- function() {\n    # Test case 1\n    queries1 <- c(\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\")\n    stopifnot(all(top_k_frequent_phrases(queries1, 2) == c(\"apple\", \"banana\")))\n    \n    # Test case 2\n    queries2 <- c(\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"cat\", \"dog\")\n    stopifnot(all(top_k_frequent_phrases(queries2, 3) == c(\"cat\", \"dog\", \"bird\")))\n    \n    # Test case 3\n    queries3 <- c(\"red\", \"red\", \"blue\", \"green\")\n    stopifnot(all(top_k_frequent_phrases(queries3, 1) == \"red\"))\n    \n    # Test case 4\n    queries4 <- c(\"one\", \"two\", \"three\")\n    stopifnot(all(top_k_frequent_phrases(queries4, 5) == c(\"one\", \"three\", \"two\")))\n}\n\ntest_top_k_frequent_phrases()", "output": "top_k_frequent_phrases"}, "all_code": "# top_k_frequent_phrases finds the top k most frequent search phrases in a list of queries.\n# It counts the frequency of each query, sorts them by frequency (descending) and then alphabetically (ascending),\n# and returns the top k phrases.\n#\n# Parameters:\n# queries (character vector): A vector of search queries where each query is a string.\n# k (integer): An integer representing the number of top frequent phrases to return.\n#\n# Returns:\n# character vector: A vector of the k most frequent search phrases.\ntop_k_frequent_phrases <- function(queries, k) {\n  # Count the frequency of each query\n  freq <- table(queries)\n  \n  # Convert to a data frame for easier sorting\n  freq_df <- data.frame(phrase = names(freq), count = as.numeric(freq), stringsAsFactors = FALSE)\n  \n  # Sort by count (descending) and then by phrase (ascending)\n  freq_df <- freq_df[order(-freq_df$count, freq_df$phrase), ]\n  \n  # Extract the top k phrases\n  result <- freq_df$phrase[1:min(k, nrow(freq_df))]\n  return(result)\n}\ntest_top_k_frequent_phrases <- function() {\n    # Test case 1\n    queries1 <- c(\"apple\", \"banana\", \"apple\", \"orange\", \"banana\", \"apple\")\n    stopifnot(all(top_k_frequent_phrases(queries1, 2) == c(\"apple\", \"banana\")))\n    \n    # Test case 2\n    queries2 <- c(\"cat\", \"dog\", \"cat\", \"bird\", \"dog\", \"cat\", \"dog\")\n    stopifnot(all(top_k_frequent_phrases(queries2, 3) == c(\"cat\", \"dog\", \"bird\")))\n    \n    # Test case 3\n    queries3 <- c(\"red\", \"red\", \"blue\", \"green\")\n    stopifnot(all(top_k_frequent_phrases(queries3, 1) == \"red\"))\n    \n    # Test case 4\n    queries4 <- c(\"one\", \"two\", \"three\")\n    stopifnot(all(top_k_frequent_phrases(queries4, 5) == c(\"one\", \"three\", \"two\")))\n}\n\ntest_top_k_frequent_phrases()", "exec_outcome": "PASSED"}
{"code": "# replace_vowels_with_ascii replaces vowels in the input string with their corresponding ASCII decimal values.\n# The function checks each character in the input string and replaces it with its ASCII value if it is a vowel (case-insensitive).\n# Non-vowel characters remain unchanged.\nreplace_vowels_with_ascii <- function(s) {\n    vowels_to_ascii <- list(\n        'A' = '65', 'a' = '65',\n        'E' = '69', 'e' = '69',\n        'I' = '73', 'i' = '73',\n        'O' = '79', 'o' = '79',\n        'U' = '85', 'u' = '85'\n    )\n    \n    result <- c()\n    for (char in strsplit(s, \"\")[[1]]) {\n        if (char %in% names(vowels_to_ascii)) {\n            result <- c(result, vowels_to_ascii[[char]])\n        } else {\n            result <- c(result, char)\n        }\n    }\n    \n    return(paste(result, collapse = \"\"))\n}", "test_cases": "", "test_case_results": "Input: \"Hello World\"\nResult: \"H69ll79 W79rld\"\nInput: \"R is Awesome\"\nResult: \"R 73s 65w69s79m69\"\nInput: \"AEIOUaeiou\"\nResult: \"65697379856569737985\"\nInput: \"No vowels here\"\nResult: \"N79 v79w69ls h69r69\"\nInput: \"\"\nResult: \"\"", "task_id": 10660, "assertions": "test.replace_vowels_with_ascii <- function() {\n    stopifnot(replace_vowels_with_ascii(\"Hello World\") == \"H69ll79 W79rld\")\n    stopifnot(replace_vowels_with_ascii(\"R is Awesome\") == \"R 73s 65w69s79m69\")\n    stopifnot(replace_vowels_with_ascii(\"AEIOUaeiou\") == \"65697379856569737985\")\n    stopifnot(replace_vowels_with_ascii(\"No vowels here\") == \"N79 v79w69ls h69r69\")\n    stopifnot(replace_vowels_with_ascii(\"\") == \"\")\n}\n\ntest.replace_vowels_with_ascii()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.replace_vowels_with_ascii <- function() {\n    stopifnot(replace_vowels_with_ascii(\"Hello World\") == \"H69ll79 W79rld\")\n    stopifnot(replace_vowels_with_ascii(\"R is Awesome\") == \"R 73s 65w69s79m69\")\n    stopifnot(replace_vowels_with_ascii(\"AEIOUaeiou\") == \"65697379856569737985\")\n    stopifnot(replace_vowels_with_ascii(\"No vowels here\") == \"N79 v79w69ls h69r69\")\n    stopifnot(replace_vowels_with_ascii(\"\") == \"\")\n}\n\ntest.replace_vowels_with_ascii()", "output": "replace_vowels_with_ascii"}, "all_code": "# replace_vowels_with_ascii replaces vowels in the input string with their corresponding ASCII decimal values.\n# The function checks each character in the input string and replaces it with its ASCII value if it is a vowel (case-insensitive).\n# Non-vowel characters remain unchanged.\nreplace_vowels_with_ascii <- function(s) {\n    vowels_to_ascii <- list(\n        'A' = '65', 'a' = '65',\n        'E' = '69', 'e' = '69',\n        'I' = '73', 'i' = '73',\n        'O' = '79', 'o' = '79',\n        'U' = '85', 'u' = '85'\n    )\n    \n    result <- c()\n    for (char in strsplit(s, \"\")[[1]]) {\n        if (char %in% names(vowels_to_ascii)) {\n            result <- c(result, vowels_to_ascii[[char]])\n        } else {\n            result <- c(result, char)\n        }\n    }\n    \n    return(paste(result, collapse = \"\"))\n}\ntest.replace_vowels_with_ascii <- function() {\n    stopifnot(replace_vowels_with_ascii(\"Hello World\") == \"H69ll79 W79rld\")\n    stopifnot(replace_vowels_with_ascii(\"R is Awesome\") == \"R 73s 65w69s79m69\")\n    stopifnot(replace_vowels_with_ascii(\"AEIOUaeiou\") == \"65697379856569737985\")\n    stopifnot(replace_vowels_with_ascii(\"No vowels here\") == \"N79 v79w69ls h69r69\")\n    stopifnot(replace_vowels_with_ascii(\"\") == \"\")\n}\n\ntest.replace_vowels_with_ascii()", "exec_outcome": "PASSED"}
{"code": "# adjust_positions rearranges the ages in a list such that people older than or equal to the threshold \n# remain in their original positions, while the rest are rearranged in non-descending order.\n#\n# Args:\n#   ages: A numeric vector representing the ages of people.\n#   threshold: A numeric value representing the age threshold.\n#\n# Returns:\n#   A numeric vector with the ages adjusted according to the specified conditions.\nadjust_positions <- function(ages, threshold) {\n    # Collect the ages that can be rearranged (those below the threshold)\n    rearrange_ages <- ages[ages < threshold]\n    # Sort these ages in non-descending order\n    rearrange_ages <- sort(rearrange_ages)\n    \n    # Initialize the result vector\n    result <- numeric(length(ages))\n    i <- 1  # Index for rearrange_ages\n    \n    # Iterate over the original ages and build the result vector\n    for (j in 1:length(ages)) {\n        if (ages[j] < threshold) {\n            result[j] <- rearrange_ages[i]\n            i <- i + 1\n        } else {\n            result[j] <- ages[j]\n        }\n    }\n    \n    return(result)\n}", "test_cases": "", "test_case_results": "Ages:  25 30 18 22 40 \nThreshold:  30 \nAdjusted Ages:  18 30 22 25 40 \n\nAges:  45 20 15 35 10 \nThreshold:  20 \nAdjusted Ages:  45 20 10 35 15 \n\nAges:  10 10 10 20 20 \nThreshold:  15 \nAdjusted Ages:  10 10 10 20 20 \n\nAges:  50 30 40 20 10 \nThreshold:  25 \nAdjusted Ages:  50 30 40 10 20", "task_id": 21034, "assertions": "test_adjust_positions <- function() {\n    stopifnot(all(adjust_positions(c(25, 30, 18, 22, 40), 30) == c(18, 30, 22, 25, 40)))\n    stopifnot(all(adjust_positions(c(45, 20, 15, 35, 10), 20) == c(45, 20, 10, 35, 15)))\n    stopifnot(all(adjust_positions(c(10, 10, 10, 20, 20), 15) == c(10, 10, 10, 20, 20)))\n    stopifnot(all(adjust_positions(c(50, 30, 40, 20, 10), 25) == c(50, 30, 40, 10, 20)))\n}\n\ntest_adjust_positions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_adjust_positions <- function() {\n    stopifnot(all(adjust_positions(c(25, 30, 18, 22, 40), 30) == c(18, 30, 22, 25, 40)))\n    stopifnot(all(adjust_positions(c(45, 20, 15, 35, 10), 20) == c(45, 20, 10, 35, 15)))\n    stopifnot(all(adjust_positions(c(10, 10, 10, 20, 20), 15) == c(10, 10, 10, 20, 20)))\n    stopifnot(all(adjust_positions(c(50, 30, 40, 20, 10), 25) == c(50, 30, 40, 10, 20)))\n}\n\ntest_adjust_positions()", "output": "adjust_positions"}, "all_code": "# adjust_positions rearranges the ages in a list such that people older than or equal to the threshold \n# remain in their original positions, while the rest are rearranged in non-descending order.\n#\n# Args:\n#   ages: A numeric vector representing the ages of people.\n#   threshold: A numeric value representing the age threshold.\n#\n# Returns:\n#   A numeric vector with the ages adjusted according to the specified conditions.\nadjust_positions <- function(ages, threshold) {\n    # Collect the ages that can be rearranged (those below the threshold)\n    rearrange_ages <- ages[ages < threshold]\n    # Sort these ages in non-descending order\n    rearrange_ages <- sort(rearrange_ages)\n    \n    # Initialize the result vector\n    result <- numeric(length(ages))\n    i <- 1  # Index for rearrange_ages\n    \n    # Iterate over the original ages and build the result vector\n    for (j in 1:length(ages)) {\n        if (ages[j] < threshold) {\n            result[j] <- rearrange_ages[i]\n            i <- i + 1\n        } else {\n            result[j] <- ages[j]\n        }\n    }\n    \n    return(result)\n}\ntest_adjust_positions <- function() {\n    stopifnot(all(adjust_positions(c(25, 30, 18, 22, 40), 30) == c(18, 30, 22, 25, 40)))\n    stopifnot(all(adjust_positions(c(45, 20, 15, 35, 10), 20) == c(45, 20, 10, 35, 15)))\n    stopifnot(all(adjust_positions(c(10, 10, 10, 20, 20), 15) == c(10, 10, 10, 20, 20)))\n    stopifnot(all(adjust_positions(c(50, 30, 40, 20, 10), 25) == c(50, 30, 40, 10, 20)))\n}\n\ntest_adjust_positions()", "exec_outcome": "PASSED"}
{"code": "is_path_exists <- function(matrix, N, M) {\n  if (matrix[1, 1] == '#' || matrix[N, M] == '#') {\n    return(\"NO\")\n  }\n  \n  # Nested DFS function to explore paths\n  dfs <- function(x, y) {\n    if (x == N && y == M) {\n      return(TRUE)\n    }\n    if (x < 1 || y < 1 || x > N || y > M || matrix[x, y] == '#') {\n      return(FALSE)\n    }\n    \n    # Mark as visited by converting to obstacle\n    matrix[x, y] <<- '#'\n    \n    # Check right and down for possible paths\n    if (dfs(x + 1, y) || dfs(x, y + 1)) {\n      return(TRUE)\n    }\n    \n    return(FALSE)\n  }\n  \n  if (dfs(1, 1)) {\n    return(\"YES\")\n  } else {\n    return(\"NO\")\n  }\n}\n\nprocess_test_cases <- function(test_cases) {\n  results <- c()\n  for (case in test_cases) {\n    N <- case$N\n    M <- case$M\n    matrix <- case$matrix\n    results <- c(results, is_path_exists(matrix, N, M))\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Test Case 1:\nMatrix:\n     [,1] [,2]\n[1,] \".\"  \".\" \n[2,] \".\"  \".\" \nDimensions: 2 x 2\nResult: YES\n\nTest Case 2:\nMatrix:\n     [,1] [,2]\n[1,] \".\"  \"#\" \n[2,] \".\"  \".\" \nDimensions: 2 x 2\nResult: YES\n\nTest Case 3:\nMatrix:\n     [,1] [,2] [,3]\n[1,] \".\"  \".\"  \"#\" \n[2,] \"#\"  \".\"  \".\" \n[3,] \".\"  \"#\"  \".\" \nDimensions: 3 x 3\nResult: YES\n\nTest Case 4:\nMatrix:\n     [,1]\n[1,] \".\" \nDimensions: 1 x 1\nResult: YES\n\nTest Case 5:\nMatrix:\n     [,1]\n[1,] \"#\" \nDimensions: 1 x 1\nResult: NO", "task_id": 7353, "assertions": "test_path_exists <- function() {\n  # Test case 1: Simple 2x2 matrix with a clear path\n  test_case_1 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '.', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 2: 2x2 matrix with an obstacle blocking the path\n  test_case_2 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '#', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 3: 3x3 matrix with a clear path\n  test_case_3 <- list(\n    N = 3,\n    M = 3,\n    matrix = matrix(c('.', '.', '#', '#', '.', '.', '.', '#', '.'), nrow = 3, byrow = TRUE)\n  )\n  \n  # Test case 4: 1x1 matrix with no obstacle\n  test_case_4 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('.'), nrow = 1)\n  )\n  \n  # Test case 5: 1x1 matrix with obstacle\n  test_case_5 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('#'), nrow = 1)\n  )\n  \n  test_cases <- list(test_case_1, test_case_2, test_case_3, test_case_4, test_case_5)\n  \n  results <- process_test_cases(test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"YES\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"YES\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_path_exists()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_path_exists <- function() {\n  # Test case 1: Simple 2x2 matrix with a clear path\n  test_case_1 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '.', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 2: 2x2 matrix with an obstacle blocking the path\n  test_case_2 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '#', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 3: 3x3 matrix with a clear path\n  test_case_3 <- list(\n    N = 3,\n    M = 3,\n    matrix = matrix(c('.', '.', '#', '#', '.', '.', '.', '#', '.'), nrow = 3, byrow = TRUE)\n  )\n  \n  # Test case 4: 1x1 matrix with no obstacle\n  test_case_4 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('.'), nrow = 1)\n  )\n  \n  # Test case 5: 1x1 matrix with obstacle\n  test_case_5 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('#'), nrow = 1)\n  )\n  \n  test_cases <- list(test_case_1, test_case_2, test_case_3, test_case_4, test_case_5)\n  \n  results <- process_test_cases(test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"YES\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"YES\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_path_exists()", "output": "path_exists"}, "all_code": "is_path_exists <- function(matrix, N, M) {\n  if (matrix[1, 1] == '#' || matrix[N, M] == '#') {\n    return(\"NO\")\n  }\n  \n  # Nested DFS function to explore paths\n  dfs <- function(x, y) {\n    if (x == N && y == M) {\n      return(TRUE)\n    }\n    if (x < 1 || y < 1 || x > N || y > M || matrix[x, y] == '#') {\n      return(FALSE)\n    }\n    \n    # Mark as visited by converting to obstacle\n    matrix[x, y] <<- '#'\n    \n    # Check right and down for possible paths\n    if (dfs(x + 1, y) || dfs(x, y + 1)) {\n      return(TRUE)\n    }\n    \n    return(FALSE)\n  }\n  \n  if (dfs(1, 1)) {\n    return(\"YES\")\n  } else {\n    return(\"NO\")\n  }\n}\n\nprocess_test_cases <- function(test_cases) {\n  results <- c()\n  for (case in test_cases) {\n    N <- case$N\n    M <- case$M\n    matrix <- case$matrix\n    results <- c(results, is_path_exists(matrix, N, M))\n  }\n  return(results)\n}\ntest_path_exists <- function() {\n  # Test case 1: Simple 2x2 matrix with a clear path\n  test_case_1 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '.', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 2: 2x2 matrix with an obstacle blocking the path\n  test_case_2 <- list(\n    N = 2,\n    M = 2,\n    matrix = matrix(c('.', '#', '.', '.'), nrow = 2, byrow = TRUE)\n  )\n  \n  # Test case 3: 3x3 matrix with a clear path\n  test_case_3 <- list(\n    N = 3,\n    M = 3,\n    matrix = matrix(c('.', '.', '#', '#', '.', '.', '.', '#', '.'), nrow = 3, byrow = TRUE)\n  )\n  \n  # Test case 4: 1x1 matrix with no obstacle\n  test_case_4 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('.'), nrow = 1)\n  )\n  \n  # Test case 5: 1x1 matrix with obstacle\n  test_case_5 <- list(\n    N = 1,\n    M = 1,\n    matrix = matrix(c('#'), nrow = 1)\n  )\n  \n  test_cases <- list(test_case_1, test_case_2, test_case_3, test_case_4, test_case_5)\n  \n  results <- process_test_cases(test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"YES\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"YES\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_path_exists()", "exec_outcome": "PASSED"}
{"code": "remove_and_minimize <- function(S, ch) {\n    # Convert the string to a vector of characters for easier manipulation\n    chars <- unlist(strsplit(S, \"\"))\n    \n    # Find all indices where the character `ch` occurs\n    indices <- which(chars == ch)\n    \n    # If `ch` is not found, return the original string\n    if (length(indices) == 0) {\n        return(S)\n    }\n    \n    # Initialize the smallest string as NULL\n    smallest_str <- NULL\n    \n    # Iterate over each occurrence of `ch` and construct new strings by removing it\n    for (i in indices) {\n        new_chars <- chars[-i]\n        new_str <- paste(new_chars, collapse = \"\")\n        \n        # Update the smallest string if the new string is smaller or if it's the first candidate\n        if (is.null(smallest_str) || new_str < smallest_str) {\n            smallest_str <- new_str\n        }\n    }\n    \n    return(smallest_str)\n}", "test_cases": "", "test_case_results": "Input String:  abacaba , Character to remove:  a \nResult:  abacab \nInput String:  hello , Character to remove:  l \nResult:  helo \nInput String:  abc , Character to remove:  d \nResult:  abc \nInput String:  aab , Character to remove:  a \nResult:  ab \nInput String:  zzz , Character to remove:  z \nResult:  zz", "task_id": 5586, "assertions": "test_remove_and_minimize <- function() {\n    stopifnot(remove_and_minimize(\"abacaba\", \"a\") == \"abacab\")\n    stopifnot(remove_and_minimize(\"hello\", \"l\") == \"helo\")\n    stopifnot(remove_and_minimize(\"abc\", \"d\") == \"abc\")\n    stopifnot(remove_and_minimize(\"aab\", \"a\") == \"ab\")\n    stopifnot(remove_and_minimize(\"zzz\", \"z\") == \"zz\")\n}\n\ntest_remove_and_minimize()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_remove_and_minimize <- function() {\n    stopifnot(remove_and_minimize(\"abacaba\", \"a\") == \"abacab\")\n    stopifnot(remove_and_minimize(\"hello\", \"l\") == \"helo\")\n    stopifnot(remove_and_minimize(\"abc\", \"d\") == \"abc\")\n    stopifnot(remove_and_minimize(\"aab\", \"a\") == \"ab\")\n    stopifnot(remove_and_minimize(\"zzz\", \"z\") == \"zz\")\n}\n\ntest_remove_and_minimize()", "output": "remove_and_minimize"}, "all_code": "remove_and_minimize <- function(S, ch) {\n    # Convert the string to a vector of characters for easier manipulation\n    chars <- unlist(strsplit(S, \"\"))\n    \n    # Find all indices where the character `ch` occurs\n    indices <- which(chars == ch)\n    \n    # If `ch` is not found, return the original string\n    if (length(indices) == 0) {\n        return(S)\n    }\n    \n    # Initialize the smallest string as NULL\n    smallest_str <- NULL\n    \n    # Iterate over each occurrence of `ch` and construct new strings by removing it\n    for (i in indices) {\n        new_chars <- chars[-i]\n        new_str <- paste(new_chars, collapse = \"\")\n        \n        # Update the smallest string if the new string is smaller or if it's the first candidate\n        if (is.null(smallest_str) || new_str < smallest_str) {\n            smallest_str <- new_str\n        }\n    }\n    \n    return(smallest_str)\n}\ntest_remove_and_minimize <- function() {\n    stopifnot(remove_and_minimize(\"abacaba\", \"a\") == \"abacab\")\n    stopifnot(remove_and_minimize(\"hello\", \"l\") == \"helo\")\n    stopifnot(remove_and_minimize(\"abc\", \"d\") == \"abc\")\n    stopifnot(remove_and_minimize(\"aab\", \"a\") == \"ab\")\n    stopifnot(remove_and_minimize(\"zzz\", \"z\") == \"zz\")\n}\n\ntest_remove_and_minimize()", "exec_outcome": "PASSED"}
{"code": "# mask_credit_card masks a credit card number by showing only the last four digits \n# and replacing the preceding digits with asterisks.\n# \n# Args:\n#   card_number (character): The credit card number as a string.\n#\n# Returns:\n#   character: The masked credit card number.\n#\n# Raises:\n#   error if the length of card_number is less than 4.\nmask_credit_card <- function(card_number) {\n  if (nchar(card_number) < 4) {\n    stop(\"Credit card number must be at least 4 digits long.\")\n  }\n  \n  masked_part <- paste(rep(\"*\", nchar(card_number) - 4), collapse = \"\")\n  last_four <- substr(card_number, nchar(card_number) - 3, nchar(card_number))\n  return(paste0(masked_part, last_four))\n}", "test_cases": "", "test_case_results": "Input:  1234567890123456 \nMasked:  ************3456 \n\nInput:  1234 \nMasked:  1234 \n\nInput:  98765432109876543210 \nMasked:  ****************3210 \n\nInput:  1111222233334444 \nMasked:  ************4444", "task_id": 26516, "assertions": "test.mask_credit_card <- function() {\n    # Test normal cases\n    stopifnot(mask_credit_card(\"1234567890123456\") == \"************3456\")\n    stopifnot(mask_credit_card(\"1234\") == \"1234\")\n    stopifnot(mask_credit_card(\"98765432109876543210\") == \"****************3210\")\n    stopifnot(mask_credit_card(\"1111222233334444\") == \"************4444\")\n    \n    # Test error case\n    has_error <- FALSE\n    tryCatch({\n        mask_credit_card(\"123\")\n    }, error = function(e) {\n        has_error <<- TRUE\n    })\n    stopifnot(has_error)\n}\n\ntest.mask_credit_card()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.mask_credit_card <- function() {\n    # Test normal cases\n    stopifnot(mask_credit_card(\"1234567890123456\") == \"************3456\")\n    stopifnot(mask_credit_card(\"1234\") == \"1234\")\n    stopifnot(mask_credit_card(\"98765432109876543210\") == \"****************3210\")\n    stopifnot(mask_credit_card(\"1111222233334444\") == \"************4444\")\n    \n    # Test error case\n    has_error <- FALSE\n    tryCatch({\n        mask_credit_card(\"123\")\n    }, error = function(e) {\n        has_error <<- TRUE\n    })\n    stopifnot(has_error)\n}\n\ntest.mask_credit_card()", "output": "mask_credit_card"}, "all_code": "# mask_credit_card masks a credit card number by showing only the last four digits \n# and replacing the preceding digits with asterisks.\n# \n# Args:\n#   card_number (character): The credit card number as a string.\n#\n# Returns:\n#   character: The masked credit card number.\n#\n# Raises:\n#   error if the length of card_number is less than 4.\nmask_credit_card <- function(card_number) {\n  if (nchar(card_number) < 4) {\n    stop(\"Credit card number must be at least 4 digits long.\")\n  }\n  \n  masked_part <- paste(rep(\"*\", nchar(card_number) - 4), collapse = \"\")\n  last_four <- substr(card_number, nchar(card_number) - 3, nchar(card_number))\n  return(paste0(masked_part, last_four))\n}\ntest.mask_credit_card <- function() {\n    # Test normal cases\n    stopifnot(mask_credit_card(\"1234567890123456\") == \"************3456\")\n    stopifnot(mask_credit_card(\"1234\") == \"1234\")\n    stopifnot(mask_credit_card(\"98765432109876543210\") == \"****************3210\")\n    stopifnot(mask_credit_card(\"1111222233334444\") == \"************4444\")\n    \n    # Test error case\n    has_error <- FALSE\n    tryCatch({\n        mask_credit_card(\"123\")\n    }, error = function(e) {\n        has_error <<- TRUE\n    })\n    stopifnot(has_error)\n}\n\ntest.mask_credit_card()", "exec_outcome": "PASSED"}
{"code": "multiply_matrices <- function(mat1, mat2) {\n  m <- nrow(mat1)\n  n <- ncol(mat1)\n  k <- nrow(mat2)\n  p <- ncol(mat2)\n  \n  if (n != k) {\n    return(list())\n  }\n  \n  # Initialize the result matrix with zeros\n  result <- matrix(0, nrow = m, ncol = p)\n  \n  # Perform matrix multiplication\n  for (i in 1:m) {\n    for (j in 1:n) {\n      if (mat1[i, j] != 0) {\n        for (l in 1:p) {\n          result[i, l] <- result[i, l] + mat1[i, j] * mat2[j, l]\n        }\n      }\n    }\n  }\n  \n  return(result)\n}", "test_cases": "", "test_case_results": "Input Matrix 1:\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\nInput Matrix 2:\n     [,1] [,2]\n[1,]    5    6\n[2,]    7    8\nResult:\n     [,1] [,2]\n[1,]   19   22\n[2,]   43   50\n\nInput Matrix 1:\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\nInput Matrix 2:\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\nResult:\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\nInput Matrix 1:\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\nInput Matrix 2:\n     [,1] [,2]\n[1,]    7    8\n[2,]    9   10\n[3,]   11   12\nResult:\n     [,1] [,2]\n[1,]   58   64\n[2,]  139  154\n\nInput Matrix 1:\n     [,1] [,2] [,3]\n[1,]    1    2    3\nInput Matrix 2:\n     [,1]\n[1,]    4\n[2,]    5\n[3,]    6\nResult:\n     [,1]\n[1,]   32\n\nInput Matrix 1:\n     [,1] [,2]\n[1,]    1    2\nInput Matrix 2:\n     [,1] [,2]\n[1,]    3    4\n[2,]    5    6\nResult:\n     [,1] [,2]\n[1,]   13   16", "task_id": 26621, "assertions": "test_matrix_multiplication <- function() {\n  # Test case 1\n  mat1 <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(5, 6, 7, 8), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(19, 22, 43, 50), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 2 (identity matrices)\n  mat1 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), mat1))\n  \n  # Test case 3 (2x3 * 3x2)\n  mat1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(7, 8, 9, 10, 11, 12), nrow = 3, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(58, 64, 139, 154), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 4 (1x3 * 3x1)\n  mat1 <- matrix(c(1, 2, 3), nrow = 1, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(4, 5, 6), nrow = 3, ncol = 1, byrow = TRUE)\n  expected <- matrix(32, nrow = 1, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 5 (1x2 * 2x2)\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(3, 4, 5, 6), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(13, 16), nrow = 1, ncol = 2)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case for dimension mismatch\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2)\n  mat2 <- matrix(c(1, 2, 3), nrow = 3, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), list()))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_matrix_multiplication()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_matrix_multiplication <- function() {\n  # Test case 1\n  mat1 <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(5, 6, 7, 8), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(19, 22, 43, 50), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 2 (identity matrices)\n  mat1 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), mat1))\n  \n  # Test case 3 (2x3 * 3x2)\n  mat1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(7, 8, 9, 10, 11, 12), nrow = 3, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(58, 64, 139, 154), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 4 (1x3 * 3x1)\n  mat1 <- matrix(c(1, 2, 3), nrow = 1, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(4, 5, 6), nrow = 3, ncol = 1, byrow = TRUE)\n  expected <- matrix(32, nrow = 1, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 5 (1x2 * 2x2)\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(3, 4, 5, 6), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(13, 16), nrow = 1, ncol = 2)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case for dimension mismatch\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2)\n  mat2 <- matrix(c(1, 2, 3), nrow = 3, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), list()))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_matrix_multiplication()", "output": "multiply_matrices"}, "all_code": "multiply_matrices <- function(mat1, mat2) {\n  m <- nrow(mat1)\n  n <- ncol(mat1)\n  k <- nrow(mat2)\n  p <- ncol(mat2)\n  \n  if (n != k) {\n    return(list())\n  }\n  \n  # Initialize the result matrix with zeros\n  result <- matrix(0, nrow = m, ncol = p)\n  \n  # Perform matrix multiplication\n  for (i in 1:m) {\n    for (j in 1:n) {\n      if (mat1[i, j] != 0) {\n        for (l in 1:p) {\n          result[i, l] <- result[i, l] + mat1[i, j] * mat2[j, l]\n        }\n      }\n    }\n  }\n  \n  return(result)\n}\ntest_matrix_multiplication <- function() {\n  # Test case 1\n  mat1 <- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(5, 6, 7, 8), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(19, 22, 43, 50), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 2 (identity matrices)\n  mat1 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), mat1))\n  \n  # Test case 3 (2x3 * 3x2)\n  mat1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(7, 8, 9, 10, 11, 12), nrow = 3, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(58, 64, 139, 154), nrow = 2, ncol = 2, byrow = TRUE)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 4 (1x3 * 3x1)\n  mat1 <- matrix(c(1, 2, 3), nrow = 1, ncol = 3, byrow = TRUE)\n  mat2 <- matrix(c(4, 5, 6), nrow = 3, ncol = 1, byrow = TRUE)\n  expected <- matrix(32, nrow = 1, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case 5 (1x2 * 2x2)\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2, byrow = TRUE)\n  mat2 <- matrix(c(3, 4, 5, 6), nrow = 2, ncol = 2, byrow = TRUE)\n  expected <- matrix(c(13, 16), nrow = 1, ncol = 2)\n  stopifnot(identical(multiply_matrices(mat1, mat2), expected))\n  \n  # Test case for dimension mismatch\n  mat1 <- matrix(c(1, 2), nrow = 1, ncol = 2)\n  mat2 <- matrix(c(1, 2, 3), nrow = 3, ncol = 1)\n  stopifnot(identical(multiply_matrices(mat1, mat2), list()))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_matrix_multiplication()", "exec_outcome": "PASSED"}
{"code": "prim_mst <- function(n, dist_matrix) {\n  min_cost <- rep(.Machine$integer.max, n)\n  min_cost[1] <- 0  # R uses 1-based indexing\n  visited <- rep(FALSE, n)\n  pq <- list()\n  pq[[1]] <- c(0, 1)  # (cost, vertex)\n  \n  total_cost <- 0\n  \n  while (length(pq) > 0) {\n    # Extract the vertex with the minimum cost\n    min_idx <- which.min(sapply(pq, function(x) x[1]))\n    cost <- pq[[min_idx]][1]\n    u <- pq[[min_idx]][2]\n    pq <- pq[-min_idx]\n    \n    if (visited[u]) {\n      next\n    }\n    visited[u] <- TRUE\n    total_cost <- total_cost + cost\n    \n    for (v in 1:n) {\n      if (!visited[v] && dist_matrix[u, v] < min_cost[v]) {\n        min_cost[v] <- dist_matrix[u, v]\n        pq[[length(pq) + 1]] <- c(dist_matrix[u, v], v)\n      }\n    }\n  }\n  \n  return(total_cost)\n}\n\nminimal_rope_length <- function(test_cases) {\n  results <- c()\n  for (case in test_cases) {\n    n <- case[[1]]\n    dist_matrix <- case[[2]]\n    results <- c(results, prim_mst(n, dist_matrix))\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Test case 1:\nNumber of vertices (n): 3\nDistance matrix:\n     [,1] [,2] [,3]\n[1,]    0    2    3\n[2,]    2    0    1\n[3,]    3    1    0\nMinimum rope length (MST cost): 3\n\nTest case 2:\nNumber of vertices (n): 4\nDistance matrix:\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    4    3\n[2,]    1    0    2    5\n[3,]    4    2    0    6\n[4,]    3    5    6    0\nMinimum rope length (MST cost): 6\n\nTest case 3:\nNumber of vertices (n): 2\nDistance matrix:\n     [,1] [,2]\n[1,]    0   10\n[2,]   10    0\nMinimum rope length (MST cost): 10", "task_id": 22194, "assertions": "test_mst <- function() {\n  # Test case 1: 3 vertices\n  n1 <- 3\n  dist_matrix1 <- matrix(c(\n    0, 2, 3,\n    2, 0, 1,\n    3, 1, 0\n  ), nrow = n1, byrow = TRUE)\n  test_case1 <- list(n1, dist_matrix1)\n  \n  # Test case 2: 4 vertices\n  n2 <- 4\n  dist_matrix2 <- matrix(c(\n    0, 1, 4, 3,\n    1, 0, 2, 5,\n    4, 2, 0, 6,\n    3, 5, 6, 0\n  ), nrow = n2, byrow = TRUE)\n  test_case2 <- list(n2, dist_matrix2)\n  \n  # Test case 3: 2 vertices\n  n3 <- 2\n  dist_matrix3 <- matrix(c(\n    0, 10,\n    10, 0\n  ), nrow = n3, byrow = TRUE)\n  test_case3 <- list(n3, dist_matrix3)\n  \n  test_cases <- list(test_case1, test_case2, test_case3)\n  \n  results <- minimal_rope_length(test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 6)\n  stopifnot(results[3] == 10)\n}\n\ntest_mst()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_mst <- function() {\n  # Test case 1: 3 vertices\n  n1 <- 3\n  dist_matrix1 <- matrix(c(\n    0, 2, 3,\n    2, 0, 1,\n    3, 1, 0\n  ), nrow = n1, byrow = TRUE)\n  test_case1 <- list(n1, dist_matrix1)\n  \n  # Test case 2: 4 vertices\n  n2 <- 4\n  dist_matrix2 <- matrix(c(\n    0, 1, 4, 3,\n    1, 0, 2, 5,\n    4, 2, 0, 6,\n    3, 5, 6, 0\n  ), nrow = n2, byrow = TRUE)\n  test_case2 <- list(n2, dist_matrix2)\n  \n  # Test case 3: 2 vertices\n  n3 <- 2\n  dist_matrix3 <- matrix(c(\n    0, 10,\n    10, 0\n  ), nrow = n3, byrow = TRUE)\n  test_case3 <- list(n3, dist_matrix3)\n  \n  test_cases <- list(test_case1, test_case2, test_case3)\n  \n  results <- minimal_rope_length(test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 6)\n  stopifnot(results[3] == 10)\n}\n\ntest_mst()", "output": "minimal_rope_length"}, "all_code": "prim_mst <- function(n, dist_matrix) {\n  min_cost <- rep(.Machine$integer.max, n)\n  min_cost[1] <- 0  # R uses 1-based indexing\n  visited <- rep(FALSE, n)\n  pq <- list()\n  pq[[1]] <- c(0, 1)  # (cost, vertex)\n  \n  total_cost <- 0\n  \n  while (length(pq) > 0) {\n    # Extract the vertex with the minimum cost\n    min_idx <- which.min(sapply(pq, function(x) x[1]))\n    cost <- pq[[min_idx]][1]\n    u <- pq[[min_idx]][2]\n    pq <- pq[-min_idx]\n    \n    if (visited[u]) {\n      next\n    }\n    visited[u] <- TRUE\n    total_cost <- total_cost + cost\n    \n    for (v in 1:n) {\n      if (!visited[v] && dist_matrix[u, v] < min_cost[v]) {\n        min_cost[v] <- dist_matrix[u, v]\n        pq[[length(pq) + 1]] <- c(dist_matrix[u, v], v)\n      }\n    }\n  }\n  \n  return(total_cost)\n}\n\nminimal_rope_length <- function(test_cases) {\n  results <- c()\n  for (case in test_cases) {\n    n <- case[[1]]\n    dist_matrix <- case[[2]]\n    results <- c(results, prim_mst(n, dist_matrix))\n  }\n  return(results)\n}\ntest_mst <- function() {\n  # Test case 1: 3 vertices\n  n1 <- 3\n  dist_matrix1 <- matrix(c(\n    0, 2, 3,\n    2, 0, 1,\n    3, 1, 0\n  ), nrow = n1, byrow = TRUE)\n  test_case1 <- list(n1, dist_matrix1)\n  \n  # Test case 2: 4 vertices\n  n2 <- 4\n  dist_matrix2 <- matrix(c(\n    0, 1, 4, 3,\n    1, 0, 2, 5,\n    4, 2, 0, 6,\n    3, 5, 6, 0\n  ), nrow = n2, byrow = TRUE)\n  test_case2 <- list(n2, dist_matrix2)\n  \n  # Test case 3: 2 vertices\n  n3 <- 2\n  dist_matrix3 <- matrix(c(\n    0, 10,\n    10, 0\n  ), nrow = n3, byrow = TRUE)\n  test_case3 <- list(n3, dist_matrix3)\n  \n  test_cases <- list(test_case1, test_case2, test_case3)\n  \n  results <- minimal_rope_length(test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 6)\n  stopifnot(results[3] == 10)\n}\n\ntest_mst()", "exec_outcome": "PASSED"}
{"code": "max_comfort_level <- function(n, m, r, comfort_levels, gina_prefs, paul_prefs) {\n  # Convert preferences to sets for quick lookup\n  gina_prefs_set <- gina_prefs\n  paul_prefs_set <- paul_prefs\n  \n  # Create a data frame of comfort levels and seat indices (1-based)\n  comfort_seats <- data.frame(\n    comfort = comfort_levels,\n    seat = 1:n\n  )\n  \n  # Sort by comfort level in descending order\n  comfort_seats <- comfort_seats[order(-comfort_seats$comfort), ]\n  \n  # Function to check if a combination of seats meets the preference constraints\n  is_valid_combination <- function(combo) {\n    gina_count <- sum(combo$seat %in% gina_prefs_set)\n    paul_count <- sum(combo$seat %in% paul_prefs_set)\n    return(gina_count >= r && paul_count >= r)\n  }\n  \n  # Generate all possible combinations of m seats\n  # Note: This can be computationally expensive for large n and m\n  max_comfort <- -1\n  indices <- combn(n, m, simplify = FALSE)\n  \n  for (idx in indices) {\n    current_combo <- comfort_seats[idx, ]\n    if (is_valid_combination(current_combo)) {\n      total_comfort <- sum(current_combo$comfort)\n      if (total_comfort > max_comfort) {\n        max_comfort <- total_comfort\n      }\n    }\n  }\n  \n  return(max_comfort)\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 5 m: 3 r: 1 \nComfort Levels: 10 20 30 40 50 \nGina's Preferences: 1 3 5 \nPaul's Preferences: 2 4 5 \nResult: 120 \n\nTest Case 2:\nn: 4 m: 2 r: 2 \nComfort Levels: 5 10 15 20 \nGina's Preferences: 1 2 \nPaul's Preferences: 3 4 \nResult: -1 \n\nTest Case 3:\nn: 3 m: 2 r: 1 \nComfort Levels: 100 200 300 \nGina's Preferences: 1 2 3 \nPaul's Preferences: 1 2 3 \nResult: 500", "task_id": 5589, "assertions": "test_max_comfort_level <- function() {\n  # Test Case 1: Basic case where constraints can be satisfied\n  stopifnot(max_comfort_level(5, 3, 1, c(10, 20, 30, 40, 50), c(1, 3, 5), c(2, 4, 5)) == 120)\n  \n  # Test Case 2: Constraints cannot be satisfied\n  stopifnot(max_comfort_level(4, 2, 2, c(5, 10, 15, 20), c(1, 2), c(3, 4)) == -1)\n  \n  # Test Case 3: All seats are preferred by both\n  stopifnot(max_comfort_level(3, 2, 1, c(100, 200, 300), c(1, 2, 3), c(1, 2, 3)) == 500)\n}\n\ntest_max_comfort_level()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_comfort_level <- function() {\n  # Test Case 1: Basic case where constraints can be satisfied\n  stopifnot(max_comfort_level(5, 3, 1, c(10, 20, 30, 40, 50), c(1, 3, 5), c(2, 4, 5)) == 120)\n  \n  # Test Case 2: Constraints cannot be satisfied\n  stopifnot(max_comfort_level(4, 2, 2, c(5, 10, 15, 20), c(1, 2), c(3, 4)) == -1)\n  \n  # Test Case 3: All seats are preferred by both\n  stopifnot(max_comfort_level(3, 2, 1, c(100, 200, 300), c(1, 2, 3), c(1, 2, 3)) == 500)\n}\n\ntest_max_comfort_level()", "output": "max_comfort_level"}, "all_code": "max_comfort_level <- function(n, m, r, comfort_levels, gina_prefs, paul_prefs) {\n  # Convert preferences to sets for quick lookup\n  gina_prefs_set <- gina_prefs\n  paul_prefs_set <- paul_prefs\n  \n  # Create a data frame of comfort levels and seat indices (1-based)\n  comfort_seats <- data.frame(\n    comfort = comfort_levels,\n    seat = 1:n\n  )\n  \n  # Sort by comfort level in descending order\n  comfort_seats <- comfort_seats[order(-comfort_seats$comfort), ]\n  \n  # Function to check if a combination of seats meets the preference constraints\n  is_valid_combination <- function(combo) {\n    gina_count <- sum(combo$seat %in% gina_prefs_set)\n    paul_count <- sum(combo$seat %in% paul_prefs_set)\n    return(gina_count >= r && paul_count >= r)\n  }\n  \n  # Generate all possible combinations of m seats\n  # Note: This can be computationally expensive for large n and m\n  max_comfort <- -1\n  indices <- combn(n, m, simplify = FALSE)\n  \n  for (idx in indices) {\n    current_combo <- comfort_seats[idx, ]\n    if (is_valid_combination(current_combo)) {\n      total_comfort <- sum(current_combo$comfort)\n      if (total_comfort > max_comfort) {\n        max_comfort <- total_comfort\n      }\n    }\n  }\n  \n  return(max_comfort)\n}\ntest_max_comfort_level <- function() {\n  # Test Case 1: Basic case where constraints can be satisfied\n  stopifnot(max_comfort_level(5, 3, 1, c(10, 20, 30, 40, 50), c(1, 3, 5), c(2, 4, 5)) == 120)\n  \n  # Test Case 2: Constraints cannot be satisfied\n  stopifnot(max_comfort_level(4, 2, 2, c(5, 10, 15, 20), c(1, 2), c(3, 4)) == -1)\n  \n  # Test Case 3: All seats are preferred by both\n  stopifnot(max_comfort_level(3, 2, 1, c(100, 200, 300), c(1, 2, 3), c(1, 2, 3)) == 500)\n}\n\ntest_max_comfort_level()", "exec_outcome": "PASSED"}
{"code": "find_contiguous_subarrays <- function(arr, k) {\n    if (length(arr) < k) {\n        return(list())\n    }\n    \n    result <- list()\n    for (i in 1:(length(arr) - k + 1)) {\n        result[[i]] <- arr[i:(i + k - 1)]\n    }\n    \n    return(result)\n}", "test_cases": "", "test_case_results": "Input vector:  1 2 3 4 5 , k:  3 \nContiguous subarrays:  1, 2, 3 | 2, 3, 4 | 3, 4, 5 \nInput vector:  10 20 30 , k:  2 \nContiguous subarrays:  10, 20 | 20, 30 \nInput vector:  5 15 25 35 45 , k:  4 \nContiguous subarrays:  5, 15, 25, 35 | 15, 25, 35, 45 \nInput vector:  1 2 , k:  3 \nContiguous subarrays:", "task_id": 26032, "assertions": "test_contiguous_subarrays <- function() {\n    # Test case 1\n    result1 <- find_contiguous_subarrays(c(1, 2, 3, 4, 5), 3)\n    expected1 <- list(c(1, 2, 3), c(2, 3, 4), c(3, 4, 5))\n    stopifnot(identical(result1, expected1))\n    \n    # Test case 2\n    result2 <- find_contiguous_subarrays(c(10, 20, 30), 2)\n    expected2 <- list(c(10, 20), c(20, 30))\n    stopifnot(identical(result2, expected2))\n    \n    # Test case 3\n    result3 <- find_contiguous_subarrays(c(5, 15, 25, 35, 45), 4)\n    expected3 <- list(c(5, 15, 25, 35), c(15, 25, 35, 45))\n    stopifnot(identical(result3, expected3))\n    \n    # Test case 4 (empty result case)\n    result4 <- find_contiguous_subarrays(c(1, 2), 3)\n    expected4 <- list()\n    stopifnot(identical(result4, expected4))\n    \n    cat(\"All tests passed successfully!\\n\")\n}\n\ntest_contiguous_subarrays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_contiguous_subarrays <- function() {\n    # Test case 1\n    result1 <- find_contiguous_subarrays(c(1, 2, 3, 4, 5), 3)\n    expected1 <- list(c(1, 2, 3), c(2, 3, 4), c(3, 4, 5))\n    stopifnot(identical(result1, expected1))\n    \n    # Test case 2\n    result2 <- find_contiguous_subarrays(c(10, 20, 30), 2)\n    expected2 <- list(c(10, 20), c(20, 30))\n    stopifnot(identical(result2, expected2))\n    \n    # Test case 3\n    result3 <- find_contiguous_subarrays(c(5, 15, 25, 35, 45), 4)\n    expected3 <- list(c(5, 15, 25, 35), c(15, 25, 35, 45))\n    stopifnot(identical(result3, expected3))\n    \n    # Test case 4 (empty result case)\n    result4 <- find_contiguous_subarrays(c(1, 2), 3)\n    expected4 <- list()\n    stopifnot(identical(result4, expected4))\n    \n    cat(\"All tests passed successfully!\\n\")\n}\n\ntest_contiguous_subarrays()", "output": "find_contiguous_subarrays"}, "all_code": "find_contiguous_subarrays <- function(arr, k) {\n    if (length(arr) < k) {\n        return(list())\n    }\n    \n    result <- list()\n    for (i in 1:(length(arr) - k + 1)) {\n        result[[i]] <- arr[i:(i + k - 1)]\n    }\n    \n    return(result)\n}\ntest_contiguous_subarrays <- function() {\n    # Test case 1\n    result1 <- find_contiguous_subarrays(c(1, 2, 3, 4, 5), 3)\n    expected1 <- list(c(1, 2, 3), c(2, 3, 4), c(3, 4, 5))\n    stopifnot(identical(result1, expected1))\n    \n    # Test case 2\n    result2 <- find_contiguous_subarrays(c(10, 20, 30), 2)\n    expected2 <- list(c(10, 20), c(20, 30))\n    stopifnot(identical(result2, expected2))\n    \n    # Test case 3\n    result3 <- find_contiguous_subarrays(c(5, 15, 25, 35, 45), 4)\n    expected3 <- list(c(5, 15, 25, 35), c(15, 25, 35, 45))\n    stopifnot(identical(result3, expected3))\n    \n    # Test case 4 (empty result case)\n    result4 <- find_contiguous_subarrays(c(1, 2), 3)\n    expected4 <- list()\n    stopifnot(identical(result4, expected4))\n    \n    cat(\"All tests passed successfully!\\n\")\n}\n\ntest_contiguous_subarrays()", "exec_outcome": "PASSED"}
{"code": "# merge_sorted_arrays merges two sorted arrays into one sorted array with unique elements.\n# It uses R's built-in functions to handle sets and sorting.\n# Parameters:\n#   arr1 (vector of int): The first sorted array.\n#   arr2 (vector of int): The second sorted array.\n# Returns:\n#   vector of int: A merged and sorted array with unique elements.\nmerge_sorted_arrays <- function(arr1, arr2) {\n  merged_set <- union(arr1, arr2)\n  merged_list <- sort(merged_set)\n  return(merged_list)\n}", "test_cases": "", "test_case_results": "Input arr1:  1 2 3 4 \nInput arr2:  3 4 5 6 \nMerged and sorted array:  1 2 3 4 5 6 \n\nInput arr1:  1 3 5 \nInput arr2:  2 4 6 \nMerged and sorted array:  1 2 3 4 5 6 \n\nInput arr1:  1 1 1 \nInput arr2:  1 1 1 \nMerged and sorted array:  1 \n\nInput arr1:  \nInput arr2:  1 2 3 \nMerged and sorted array:  1 2 3 \n\nInput arr1:  1 2 3 \nInput arr2:  \nMerged and sorted array:  1 2 3", "task_id": 6154, "assertions": "test_merge_sorted_arrays <- function() {\n    # Test case 1: Normal case with some overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3, 4), c(3, 4, 5, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 2: No overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 3, 5), c(2, 4, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 3: All elements identical\n    stopifnot(identical(merge_sorted_arrays(c(1, 1, 1), c(1, 1, 1)), 1))\n    \n    # Test case 4: First array empty\n    stopifnot(identical(merge_sorted_arrays(c(), c(1, 2, 3)), c(1, 2, 3)))\n    \n    # Test case 5: Second array empty\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3), c()), c(1, 2, 3)))\n}\n\ntest_merge_sorted_arrays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_merge_sorted_arrays <- function() {\n    # Test case 1: Normal case with some overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3, 4), c(3, 4, 5, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 2: No overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 3, 5), c(2, 4, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 3: All elements identical\n    stopifnot(identical(merge_sorted_arrays(c(1, 1, 1), c(1, 1, 1)), 1))\n    \n    # Test case 4: First array empty\n    stopifnot(identical(merge_sorted_arrays(c(), c(1, 2, 3)), c(1, 2, 3)))\n    \n    # Test case 5: Second array empty\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3), c()), c(1, 2, 3)))\n}\n\ntest_merge_sorted_arrays()", "output": "merge_sorted_arrays"}, "all_code": "# merge_sorted_arrays merges two sorted arrays into one sorted array with unique elements.\n# It uses R's built-in functions to handle sets and sorting.\n# Parameters:\n#   arr1 (vector of int): The first sorted array.\n#   arr2 (vector of int): The second sorted array.\n# Returns:\n#   vector of int: A merged and sorted array with unique elements.\nmerge_sorted_arrays <- function(arr1, arr2) {\n  merged_set <- union(arr1, arr2)\n  merged_list <- sort(merged_set)\n  return(merged_list)\n}\ntest_merge_sorted_arrays <- function() {\n    # Test case 1: Normal case with some overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3, 4), c(3, 4, 5, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 2: No overlapping elements\n    stopifnot(identical(merge_sorted_arrays(c(1, 3, 5), c(2, 4, 6)), c(1, 2, 3, 4, 5, 6)))\n    \n    # Test case 3: All elements identical\n    stopifnot(identical(merge_sorted_arrays(c(1, 1, 1), c(1, 1, 1)), 1))\n    \n    # Test case 4: First array empty\n    stopifnot(identical(merge_sorted_arrays(c(), c(1, 2, 3)), c(1, 2, 3)))\n    \n    # Test case 5: Second array empty\n    stopifnot(identical(merge_sorted_arrays(c(1, 2, 3), c()), c(1, 2, 3)))\n}\n\ntest_merge_sorted_arrays()", "exec_outcome": "PASSED"}
{"code": "# replace_kth_element_with_sum replaces every k-th element in a vector with the sum of the previous k elements.\n# If the vector length is less than k, the original vector is returned as no replacements can be made.\n# The function modifies the input vector in place and returns the modified vector.\nreplace_kth_element_with_sum <- function(arr, k) {\n  n <- length(arr)\n  if (k > n) {\n    return(arr)\n  }\n  for (i in seq(k, n, by = k)) {\n    start_index <- max(1, i - k + 1)\n    arr[i] <- sum(arr[start_index:i])\n  }\n  return(arr)\n}\n\n# process_test_cases processes multiple test cases by applying the replace_kth_element_with_sum function.\n# It takes the number of test cases (t) and a list of test cases, where each test case is a list containing n, k, and the vector.\n# It returns a list of results, each being the modified vector after applying the function.\nprocess_test_cases <- function(t, test_cases) {\n  results <- list()\n  for (i in 1:t) {\n    n <- test_cases[[i]][[1]]\n    k <- test_cases[[i]][[2]]\n    arr <- test_cases[[i]][[3]]\n    results[[i]] <- replace_kth_element_with_sum(arr, k)\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 5, k: 2, Input Vector: 12345\nResulting Vector: 13375\n\nTest Case 2:\nn: 6, k: 3, Input Vector: 102030405060\nResulting Vector: 1020604050150\n\nTest Case 3:\nn: 4, k: 5, Input Vector: 1234\nResulting Vector: 1234\n\nTest Case 4:\nn: 7, k: 1, Input Vector: 7654321\nResulting Vector: 7654321", "task_id": 27258, "assertions": "test_replace_kth_element <- function() {\n  # Test Case 1: Replace every 2nd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4, 5), 2),\n    c(1, 3, 3, 7, 5)\n  ))\n  \n  # Test Case 2: Replace every 3rd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(10, 20, 30, 40, 50, 60), 3),\n    c(10, 20, 60, 40, 50, 150)\n  ))\n  \n  # Test Case 3: k > n, no replacements\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4), 5),\n    c(1, 2, 3, 4)\n  ))\n  \n  # Test Case 4: Replace every element (k=1)\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(7, 6, 5, 4, 3, 2, 1), 1),\n    c(7, 6, 5, 4, 3, 2, 1)\n  ))\n  \n  # Test process_test_cases function\n  test_cases <- list(\n    list(5, 2, c(1, 2, 3, 4, 5)),\n    list(6, 3, c(10, 20, 30, 40, 50, 60)),\n    list(4, 5, c(1, 2, 3, 4)),\n    list(7, 1, c(7, 6, 5, 4, 3, 2, 1))\n  )\n  expected_results <- list(\n    c(1, 3, 3, 7, 5),\n    c(10, 20, 60, 40, 50, 150),\n    c(1, 2, 3, 4),\n    c(7, 6, 5, 4, 3, 2, 1)\n  )\n  stopifnot(identical(\n    process_test_cases(4, test_cases),\n    expected_results\n  ))\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_replace_kth_element()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_replace_kth_element <- function() {\n  # Test Case 1: Replace every 2nd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4, 5), 2),\n    c(1, 3, 3, 7, 5)\n  ))\n  \n  # Test Case 2: Replace every 3rd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(10, 20, 30, 40, 50, 60), 3),\n    c(10, 20, 60, 40, 50, 150)\n  ))\n  \n  # Test Case 3: k > n, no replacements\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4), 5),\n    c(1, 2, 3, 4)\n  ))\n  \n  # Test Case 4: Replace every element (k=1)\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(7, 6, 5, 4, 3, 2, 1), 1),\n    c(7, 6, 5, 4, 3, 2, 1)\n  ))\n  \n  # Test process_test_cases function\n  test_cases <- list(\n    list(5, 2, c(1, 2, 3, 4, 5)),\n    list(6, 3, c(10, 20, 30, 40, 50, 60)),\n    list(4, 5, c(1, 2, 3, 4)),\n    list(7, 1, c(7, 6, 5, 4, 3, 2, 1))\n  )\n  expected_results <- list(\n    c(1, 3, 3, 7, 5),\n    c(10, 20, 60, 40, 50, 150),\n    c(1, 2, 3, 4),\n    c(7, 6, 5, 4, 3, 2, 1)\n  )\n  stopifnot(identical(\n    process_test_cases(4, test_cases),\n    expected_results\n  ))\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_replace_kth_element()", "output": "replace_kth_element_with_sum"}, "all_code": "# replace_kth_element_with_sum replaces every k-th element in a vector with the sum of the previous k elements.\n# If the vector length is less than k, the original vector is returned as no replacements can be made.\n# The function modifies the input vector in place and returns the modified vector.\nreplace_kth_element_with_sum <- function(arr, k) {\n  n <- length(arr)\n  if (k > n) {\n    return(arr)\n  }\n  for (i in seq(k, n, by = k)) {\n    start_index <- max(1, i - k + 1)\n    arr[i] <- sum(arr[start_index:i])\n  }\n  return(arr)\n}\n\n# process_test_cases processes multiple test cases by applying the replace_kth_element_with_sum function.\n# It takes the number of test cases (t) and a list of test cases, where each test case is a list containing n, k, and the vector.\n# It returns a list of results, each being the modified vector after applying the function.\nprocess_test_cases <- function(t, test_cases) {\n  results <- list()\n  for (i in 1:t) {\n    n <- test_cases[[i]][[1]]\n    k <- test_cases[[i]][[2]]\n    arr <- test_cases[[i]][[3]]\n    results[[i]] <- replace_kth_element_with_sum(arr, k)\n  }\n  return(results)\n}\ntest_replace_kth_element <- function() {\n  # Test Case 1: Replace every 2nd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4, 5), 2),\n    c(1, 3, 3, 7, 5)\n  ))\n  \n  # Test Case 2: Replace every 3rd element\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(10, 20, 30, 40, 50, 60), 3),\n    c(10, 20, 60, 40, 50, 150)\n  ))\n  \n  # Test Case 3: k > n, no replacements\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(1, 2, 3, 4), 5),\n    c(1, 2, 3, 4)\n  ))\n  \n  # Test Case 4: Replace every element (k=1)\n  stopifnot(identical(\n    replace_kth_element_with_sum(c(7, 6, 5, 4, 3, 2, 1), 1),\n    c(7, 6, 5, 4, 3, 2, 1)\n  ))\n  \n  # Test process_test_cases function\n  test_cases <- list(\n    list(5, 2, c(1, 2, 3, 4, 5)),\n    list(6, 3, c(10, 20, 30, 40, 50, 60)),\n    list(4, 5, c(1, 2, 3, 4)),\n    list(7, 1, c(7, 6, 5, 4, 3, 2, 1))\n  )\n  expected_results <- list(\n    c(1, 3, 3, 7, 5),\n    c(10, 20, 60, 40, 50, 150),\n    c(1, 2, 3, 4),\n    c(7, 6, 5, 4, 3, 2, 1)\n  )\n  stopifnot(identical(\n    process_test_cases(4, test_cases),\n    expected_results\n  ))\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_replace_kth_element()", "exec_outcome": "PASSED"}
{"code": "can_form_guards_pattern <- function(num_cases, cases) {\n  results <- c()\n  \n  for (case in cases) {\n    n <- case[[1]]\n    heights <- case[[2]]\n    \n    if (n < 3) {\n      results <- c(results, \"NO\")\n      next\n    }\n    \n    peak_found <- FALSE\n    valid <- TRUE\n    \n    for (i in 2:n) {\n      if (heights[i] == heights[i-1]) {\n        valid <- FALSE\n        break\n      } else if (!peak_found) {\n        if (heights[i] < heights[i-1]) {  # Start of decreasing part\n          peak_found <- TRUE\n        }\n      } else {\n        if (heights[i] > heights[i-1]) {  # Found an increasing part after peak\n          valid <- FALSE\n          break\n        }\n      }\n    }\n    \n    if (valid && peak_found) {\n      results <- c(results, \"YES\")\n    } else {\n      results <- c(results, \"NO\")\n    }\n  }\n  \n  return(results)\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of heights: 5\nHeights: 12321\nResult: YES\n\nTest Case 2:\nNumber of heights: 4\nHeights: 1234\nResult: NO\n\nTest Case 3:\nNumber of heights: 4\nHeights: 4321\nResult: YES\n\nTest Case 4:\nNumber of heights: 3\nHeights: 121\nResult: YES\n\nTest Case 5:\nNumber of heights: 3\nHeights: 122\nResult: NO\n\nTest Case 6:\nNumber of heights: 3\nHeights: 212\nResult: NO\n\nTest Case 7:\nNumber of heights: 2\nHeights: 12\nResult: NO", "task_id": 18865, "assertions": "test_guards_pattern <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 3, 2, 1)),  # YES\n    list(4, c(1, 2, 3, 4)),     # NO (no peak)\n    list(4, c(4, 3, 2, 1)),     # YES (modified from original test case 3)\n    list(3, c(1, 2, 1)),        # YES\n    list(3, c(1, 2, 2)),        # NO (equal heights)\n    list(3, c(2, 1, 2)),        # NO (increasing after peak)\n    list(2, c(1, 2))            # NO (less than 3 heights)\n  )\n  \n  expected_results <- c(\"YES\", \"NO\", \"YES\", \"YES\", \"NO\", \"NO\", \"NO\")\n  \n  actual_results <- can_form_guards_pattern(length(test_cases), test_cases)\n  \n  for (i in seq_along(test_cases)) {\n    stopifnot(actual_results[i] == expected_results[i])\n  }\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_guards_pattern()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_guards_pattern <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 3, 2, 1)),  # YES\n    list(4, c(1, 2, 3, 4)),     # NO (no peak)\n    list(4, c(4, 3, 2, 1)),     # YES (modified from original test case 3)\n    list(3, c(1, 2, 1)),        # YES\n    list(3, c(1, 2, 2)),        # NO (equal heights)\n    list(3, c(2, 1, 2)),        # NO (increasing after peak)\n    list(2, c(1, 2))            # NO (less than 3 heights)\n  )\n  \n  expected_results <- c(\"YES\", \"NO\", \"YES\", \"YES\", \"NO\", \"NO\", \"NO\")\n  \n  actual_results <- can_form_guards_pattern(length(test_cases), test_cases)\n  \n  for (i in seq_along(test_cases)) {\n    stopifnot(actual_results[i] == expected_results[i])\n  }\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_guards_pattern()", "output": "can_form_guards_pattern"}, "all_code": "can_form_guards_pattern <- function(num_cases, cases) {\n  results <- c()\n  \n  for (case in cases) {\n    n <- case[[1]]\n    heights <- case[[2]]\n    \n    if (n < 3) {\n      results <- c(results, \"NO\")\n      next\n    }\n    \n    peak_found <- FALSE\n    valid <- TRUE\n    \n    for (i in 2:n) {\n      if (heights[i] == heights[i-1]) {\n        valid <- FALSE\n        break\n      } else if (!peak_found) {\n        if (heights[i] < heights[i-1]) {  # Start of decreasing part\n          peak_found <- TRUE\n        }\n      } else {\n        if (heights[i] > heights[i-1]) {  # Found an increasing part after peak\n          valid <- FALSE\n          break\n        }\n      }\n    }\n    \n    if (valid && peak_found) {\n      results <- c(results, \"YES\")\n    } else {\n      results <- c(results, \"NO\")\n    }\n  }\n  \n  return(results)\n}\ntest_guards_pattern <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 3, 2, 1)),  # YES\n    list(4, c(1, 2, 3, 4)),     # NO (no peak)\n    list(4, c(4, 3, 2, 1)),     # YES (modified from original test case 3)\n    list(3, c(1, 2, 1)),        # YES\n    list(3, c(1, 2, 2)),        # NO (equal heights)\n    list(3, c(2, 1, 2)),        # NO (increasing after peak)\n    list(2, c(1, 2))            # NO (less than 3 heights)\n  )\n  \n  expected_results <- c(\"YES\", \"NO\", \"YES\", \"YES\", \"NO\", \"NO\", \"NO\")\n  \n  actual_results <- can_form_guards_pattern(length(test_cases), test_cases)\n  \n  for (i in seq_along(test_cases)) {\n    stopifnot(actual_results[i] == expected_results[i])\n  }\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_guards_pattern()", "exec_outcome": "PASSED"}
{"code": "final_length_after_removals <- function(test_cases) {\n  reduce_array <- function(arr) {\n    stack <- c()\n    for (num in arr) {\n      if (length(stack) > 0 && stack[length(stack)] == num) {\n        stack <- stack[-length(stack)]\n      } else {\n        stack <- c(stack, num)\n      }\n    }\n    return(length(stack))\n  }\n  \n  results <- c()\n  for (case in test_cases) {\n    n <- case[[1]]\n    arr <- case[[2]]\n    results <- c(results, reduce_array(arr))\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Input array:  1 2 2 3 3 \nLength after removals:  1 \nInput array:  1 2 3 4 \nLength after removals:  4 \nInput array:  1 1 2 2 3 3 \nLength after removals:  0 \nInput array:  1 2 1 \nLength after removals:  3", "task_id": 15611, "assertions": "test_final_length_after_removals <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 2, 3, 3)),\n    list(4, c(1, 2, 3, 4)),\n    list(6, c(1, 1, 2, 2, 3, 3)),\n    list(3, c(1, 2, 1))\n  )\n  \n  expected_results <- c(1, 4, 0, 3)\n  actual_results <- final_length_after_removals(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n}\n\ntest_final_length_after_removals()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_final_length_after_removals <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 2, 3, 3)),\n    list(4, c(1, 2, 3, 4)),\n    list(6, c(1, 1, 2, 2, 3, 3)),\n    list(3, c(1, 2, 1))\n  )\n  \n  expected_results <- c(1, 4, 0, 3)\n  actual_results <- final_length_after_removals(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n}\n\ntest_final_length_after_removals()", "output": "final_length_after_removals"}, "all_code": "final_length_after_removals <- function(test_cases) {\n  reduce_array <- function(arr) {\n    stack <- c()\n    for (num in arr) {\n      if (length(stack) > 0 && stack[length(stack)] == num) {\n        stack <- stack[-length(stack)]\n      } else {\n        stack <- c(stack, num)\n      }\n    }\n    return(length(stack))\n  }\n  \n  results <- c()\n  for (case in test_cases) {\n    n <- case[[1]]\n    arr <- case[[2]]\n    results <- c(results, reduce_array(arr))\n  }\n  return(results)\n}\ntest_final_length_after_removals <- function() {\n  test_cases <- list(\n    list(5, c(1, 2, 2, 3, 3)),\n    list(4, c(1, 2, 3, 4)),\n    list(6, c(1, 1, 2, 2, 3, 3)),\n    list(3, c(1, 2, 1))\n  )\n  \n  expected_results <- c(1, 4, 0, 3)\n  actual_results <- final_length_after_removals(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n}\n\ntest_final_length_after_removals()", "exec_outcome": "PASSED"}
{"code": "longest_increasing_path <- function(grid) {\n  if (length(grid) == 0 || length(grid[[1]]) == 0) {\n    return(0)\n  }\n  \n  rows <- length(grid)\n  cols <- length(grid[[1]])\n  memo <- matrix(-1, nrow = rows, ncol = cols)\n  \n  # dfs performs a depth-first search to find the longest increasing path starting from (x, y).\n  dfs <- function(x, y) {\n    if (memo[x, y] != -1) {\n      return(memo[x, y])\n    }\n    \n    directions <- list(c(1, 0), c(-1, 0), c(0, 1), c(0, -1))\n    max_path <- 1\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      if (nx >= 1 && nx <= rows && ny >= 1 && ny <= cols && grid[[nx]][ny] > grid[[x]][y]) {\n        max_path <- max(max_path, 1 + dfs(nx, ny))\n      }\n    }\n    \n    memo[x, y] <<- max_path\n    return(max_path)\n  }\n  \n  longest_path <- 0\n  for (i in 1:rows) {\n    for (j in 1:cols) {\n      longest_path <- max(longest_path, dfs(i, j))\n    }\n  }\n  \n  return(longest_path)\n}", "test_cases": "", "test_case_results": "Test case:  3x3 grid with spiral increasing path \nGrid:\n1 2 3 \n6 5 4 \n7 8 9 \nLongest increasing path length:  9 \n\nTest case:  2x2 grid with simple increasing path \nGrid:\n1 2 \n3 4 \nLongest increasing path length:  3 \n\nTest case:  2x2 grid with all equal values \nGrid:\n1 1 \n1 1 \nLongest increasing path length:  1", "task_id": 6439, "assertions": "test_longest_increasing_path <- function() {\n  test_grid1 <- list(\n    c(1, 2, 3),\n    c(6, 5, 4),\n    c(7, 8, 9)\n  )\n  stopifnot(longest_increasing_path(test_grid1) == 9)\n  \n  test_grid2 <- list(\n    c(1, 2),\n    c(3, 4)\n  )\n  stopifnot(longest_increasing_path(test_grid2) == 3)\n  \n  test_grid3 <- list(\n    c(1, 1),\n    c(1, 1)\n  )\n  stopifnot(longest_increasing_path(test_grid3) == 1)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_longest_increasing_path()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_longest_increasing_path <- function() {\n  test_grid1 <- list(\n    c(1, 2, 3),\n    c(6, 5, 4),\n    c(7, 8, 9)\n  )\n  stopifnot(longest_increasing_path(test_grid1) == 9)\n  \n  test_grid2 <- list(\n    c(1, 2),\n    c(3, 4)\n  )\n  stopifnot(longest_increasing_path(test_grid2) == 3)\n  \n  test_grid3 <- list(\n    c(1, 1),\n    c(1, 1)\n  )\n  stopifnot(longest_increasing_path(test_grid3) == 1)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_longest_increasing_path()", "output": "longest_increasing_path"}, "all_code": "longest_increasing_path <- function(grid) {\n  if (length(grid) == 0 || length(grid[[1]]) == 0) {\n    return(0)\n  }\n  \n  rows <- length(grid)\n  cols <- length(grid[[1]])\n  memo <- matrix(-1, nrow = rows, ncol = cols)\n  \n  # dfs performs a depth-first search to find the longest increasing path starting from (x, y).\n  dfs <- function(x, y) {\n    if (memo[x, y] != -1) {\n      return(memo[x, y])\n    }\n    \n    directions <- list(c(1, 0), c(-1, 0), c(0, 1), c(0, -1))\n    max_path <- 1\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      if (nx >= 1 && nx <= rows && ny >= 1 && ny <= cols && grid[[nx]][ny] > grid[[x]][y]) {\n        max_path <- max(max_path, 1 + dfs(nx, ny))\n      }\n    }\n    \n    memo[x, y] <<- max_path\n    return(max_path)\n  }\n  \n  longest_path <- 0\n  for (i in 1:rows) {\n    for (j in 1:cols) {\n      longest_path <- max(longest_path, dfs(i, j))\n    }\n  }\n  \n  return(longest_path)\n}\ntest_longest_increasing_path <- function() {\n  test_grid1 <- list(\n    c(1, 2, 3),\n    c(6, 5, 4),\n    c(7, 8, 9)\n  )\n  stopifnot(longest_increasing_path(test_grid1) == 9)\n  \n  test_grid2 <- list(\n    c(1, 2),\n    c(3, 4)\n  )\n  stopifnot(longest_increasing_path(test_grid2) == 3)\n  \n  test_grid3 <- list(\n    c(1, 1),\n    c(1, 1)\n  )\n  stopifnot(longest_increasing_path(test_grid3) == 1)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_longest_increasing_path()", "exec_outcome": "PASSED"}
{"code": "# max_sum_after_replacement calculates the maximum possible sum of an array after replacing all its elements with a given maximum value.\n# The function takes three parameters:\n#   - n: the length of the array\n#   - m: the maximum value an element can take\n#   - a: the given array of integers\n# The function returns the sum of the array where all elements are replaced by `m`.\nmax_sum_after_replacement <- function(n, m, a) {\n    # Calculate the sum of the original array\n    original_sum <- sum(a)\n    \n    # Calculate the sum of all elements replaced by `m`\n    replaced_sum <- sum(rep(m, n))\n    \n    # The replacement operation will replace all the elements in the array\n    max_sum <- replaced_sum\n    \n    return(max_sum)\n}", "test_cases": "", "test_case_results": "Input: n = 3 , m = 5 , a = 1 2 3 \nMax Sum: 15 \nInput: n = 4 , m = 10 , a = 4 5 6 7 \nMax Sum: 40 \nInput: n = 2 , m = 1 , a = 0 0 \nMax Sum: 2", "task_id": 11265, "assertions": "test.max_sum_after_replacement <- function() {\n    stopifnot(max_sum_after_replacement(3, 5, c(1, 2, 3)) == 15)\n    stopifnot(max_sum_after_replacement(4, 10, c(4, 5, 6, 7)) == 40)\n    stopifnot(max_sum_after_replacement(2, 1, c(0, 0)) == 2)\n}\n\ntest.max_sum_after_replacement()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.max_sum_after_replacement <- function() {\n    stopifnot(max_sum_after_replacement(3, 5, c(1, 2, 3)) == 15)\n    stopifnot(max_sum_after_replacement(4, 10, c(4, 5, 6, 7)) == 40)\n    stopifnot(max_sum_after_replacement(2, 1, c(0, 0)) == 2)\n}\n\ntest.max_sum_after_replacement()", "output": "max_sum_after_replacement"}, "all_code": "# max_sum_after_replacement calculates the maximum possible sum of an array after replacing all its elements with a given maximum value.\n# The function takes three parameters:\n#   - n: the length of the array\n#   - m: the maximum value an element can take\n#   - a: the given array of integers\n# The function returns the sum of the array where all elements are replaced by `m`.\nmax_sum_after_replacement <- function(n, m, a) {\n    # Calculate the sum of the original array\n    original_sum <- sum(a)\n    \n    # Calculate the sum of all elements replaced by `m`\n    replaced_sum <- sum(rep(m, n))\n    \n    # The replacement operation will replace all the elements in the array\n    max_sum <- replaced_sum\n    \n    return(max_sum)\n}\ntest.max_sum_after_replacement <- function() {\n    stopifnot(max_sum_after_replacement(3, 5, c(1, 2, 3)) == 15)\n    stopifnot(max_sum_after_replacement(4, 10, c(4, 5, 6, 7)) == 40)\n    stopifnot(max_sum_after_replacement(2, 1, c(0, 0)) == 2)\n}\n\ntest.max_sum_after_replacement()", "exec_outcome": "PASSED"}
{"code": "# longest_increasing_temperatures calculates the length of the longest contiguous subsequence \n# of increasing temperatures in a given numeric vector.\n# \n# Parameters:\n#   temperatures (numeric vector): A vector of daily temperatures.\n#\n# Returns:\n#   integer: The length of the longest contiguous increasing subsequence.\nlongest_increasing_temperatures <- function(temperatures) {\n  if (length(temperatures) == 0) {\n    return(0)  # Edge case: no temperatures provided\n  }\n  \n  # Initial parameters for tracking the longest increasing sequence\n  max_length <- 1\n  current_length <- 1\n  \n  for (i in 2:length(temperatures)) {\n    if (temperatures[i] > temperatures[i - 1]) {\n      current_length <- current_length + 1\n      max_length <- max(max_length, current_length)\n    } else {\n      current_length <- 1\n    }\n  }\n  \n  return(max_length)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nLongest increasing subsequence length:  4 \nInput:  4 3 2 1 \nLongest increasing subsequence length:  1 \nInput:  1 2 1 3 2 4 \nLongest increasing subsequence length:  2 \nInput:  1 1 1 1 \nLongest increasing subsequence length:  1 \nInput:   \nLongest increasing subsequence length:  0", "task_id": 26192, "assertions": "test_longest_increasing_temperatures <- function() {\n    stopifnot(longest_increasing_temperatures(c(1, 2, 3, 4)) == 4)\n    stopifnot(longest_increasing_temperatures(c(4, 3, 2, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(c(1, 2, 1, 3, 2, 4)) == 2)\n    stopifnot(longest_increasing_temperatures(c(1, 1, 1, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(numeric(0)) == 0)\n}\n\ntest_longest_increasing_temperatures()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_longest_increasing_temperatures <- function() {\n    stopifnot(longest_increasing_temperatures(c(1, 2, 3, 4)) == 4)\n    stopifnot(longest_increasing_temperatures(c(4, 3, 2, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(c(1, 2, 1, 3, 2, 4)) == 2)\n    stopifnot(longest_increasing_temperatures(c(1, 1, 1, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(numeric(0)) == 0)\n}\n\ntest_longest_increasing_temperatures()", "output": "longest_increasing_temperatures"}, "all_code": "# longest_increasing_temperatures calculates the length of the longest contiguous subsequence \n# of increasing temperatures in a given numeric vector.\n# \n# Parameters:\n#   temperatures (numeric vector): A vector of daily temperatures.\n#\n# Returns:\n#   integer: The length of the longest contiguous increasing subsequence.\nlongest_increasing_temperatures <- function(temperatures) {\n  if (length(temperatures) == 0) {\n    return(0)  # Edge case: no temperatures provided\n  }\n  \n  # Initial parameters for tracking the longest increasing sequence\n  max_length <- 1\n  current_length <- 1\n  \n  for (i in 2:length(temperatures)) {\n    if (temperatures[i] > temperatures[i - 1]) {\n      current_length <- current_length + 1\n      max_length <- max(max_length, current_length)\n    } else {\n      current_length <- 1\n    }\n  }\n  \n  return(max_length)\n}\ntest_longest_increasing_temperatures <- function() {\n    stopifnot(longest_increasing_temperatures(c(1, 2, 3, 4)) == 4)\n    stopifnot(longest_increasing_temperatures(c(4, 3, 2, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(c(1, 2, 1, 3, 2, 4)) == 2)\n    stopifnot(longest_increasing_temperatures(c(1, 1, 1, 1)) == 1)\n    stopifnot(longest_increasing_temperatures(numeric(0)) == 0)\n}\n\ntest_longest_increasing_temperatures()", "exec_outcome": "PASSED"}
{"code": "# remaining_string removes the first and last character of a string repeatedly \n# until the string is empty or contains a single character. \n# It returns the final resulting string.\nremaining_string <- function(s) {\n  while (nchar(s) > 1) {\n    s <- substr(s, 2, nchar(s) - 1)\n  }\n  return(s)\n}", "test_cases": "", "test_case_results": "Input: \"hello\"\nResult: \"l\"\nInput: \"world\"\nResult: \"r\"\nInput: \"a\"\nResult: \"a\"\nInput: \"ab\"\nResult: \"\"\nInput: \"abc\"\nResult: \"b\"\nInput: \"\"\nResult: \"\"", "task_id": 14854, "assertions": "test.remaining_string <- function() {\n    stopifnot(remaining_string(\"hello\") == \"l\")\n    stopifnot(remaining_string(\"world\") == \"r\")\n    stopifnot(remaining_string(\"a\") == \"a\")\n    stopifnot(remaining_string(\"ab\") == \"\")\n    stopifnot(remaining_string(\"abc\") == \"b\")\n    stopifnot(remaining_string(\"\") == \"\")\n}\n\ntest.remaining_string()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.remaining_string <- function() {\n    stopifnot(remaining_string(\"hello\") == \"l\")\n    stopifnot(remaining_string(\"world\") == \"r\")\n    stopifnot(remaining_string(\"a\") == \"a\")\n    stopifnot(remaining_string(\"ab\") == \"\")\n    stopifnot(remaining_string(\"abc\") == \"b\")\n    stopifnot(remaining_string(\"\") == \"\")\n}\n\ntest.remaining_string()", "output": "remaining_string"}, "all_code": "# remaining_string removes the first and last character of a string repeatedly \n# until the string is empty or contains a single character. \n# It returns the final resulting string.\nremaining_string <- function(s) {\n  while (nchar(s) > 1) {\n    s <- substr(s, 2, nchar(s) - 1)\n  }\n  return(s)\n}\ntest.remaining_string <- function() {\n    stopifnot(remaining_string(\"hello\") == \"l\")\n    stopifnot(remaining_string(\"world\") == \"r\")\n    stopifnot(remaining_string(\"a\") == \"a\")\n    stopifnot(remaining_string(\"ab\") == \"\")\n    stopifnot(remaining_string(\"abc\") == \"b\")\n    stopifnot(remaining_string(\"\") == \"\")\n}\n\ntest.remaining_string()", "exec_outcome": "PASSED"}
{"code": "max_crossing_sum <- function(arr, left, mid, right) {\n    sum_left <- -Inf\n    sum_temp <- 0\n\n    for (i in mid:left) {\n        sum_temp <- sum_temp + arr[i]\n        if (sum_temp > sum_left) {\n            sum_left <- sum_temp\n        }\n    }\n\n    sum_right <- -Inf\n    sum_temp <- 0\n\n    for (i in (mid + 1):right) {\n        sum_temp <- sum_temp + arr[i]\n        if (sum_temp > sum_right) {\n            sum_right <- sum_temp\n        }\n    }\n\n    return(sum_left + sum_right)\n}\n\nmax_sub_array_sum_util <- function(arr, left, right) {\n    if (left == right) {\n        return(arr[left])\n    }\n\n    mid <- floor((left + right) / 2)\n\n    return(max(\n        max_sub_array_sum_util(arr, left, mid),\n        max_sub_array_sum_util(arr, mid + 1, right),\n        max_crossing_sum(arr, left, mid, right)\n    ))\n}\n\nmax_sub_array_sum <- function(arr) {\n    if (length(arr) == 0) {\n        return(0)\n    }\n    return(max_sub_array_sum_util(arr, 1, length(arr)))\n}", "test_cases": "", "test_case_results": "Input:  -2 -3 4 -1 -2 1 5 -3 \nMaximum Subarray Sum:  7 \nInput:  -2 1 -3 4 -1 2 1 -5 4 \nMaximum Subarray Sum:  6 \nInput:  1 2 3 4 5 \nMaximum Subarray Sum:  15 \nInput:  -1 -2 -3 -4 \nMaximum Subarray Sum:  -1 \nInput:  0 0 0 0 \nMaximum Subarray Sum:  0", "task_id": 26549, "assertions": "test_max_sub_array_sum <- function() {\n    stopifnot(max_sub_array_sum(c(-2, -3, 4, -1, -2, 1, 5, -3)) == 7)\n    stopifnot(max_sub_array_sum(c(-2, 1, -3, 4, -1, 2, 1, -5, 4)) == 6)\n    stopifnot(max_sub_array_sum(c(1, 2, 3, 4, 5)) == 15)\n    stopifnot(max_sub_array_sum(c(-1, -2, -3, -4)) == -1)\n    stopifnot(max_sub_array_sum(c(0, 0, 0, 0)) == 0)\n}\n\ntest_max_sub_array_sum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_sub_array_sum <- function() {\n    stopifnot(max_sub_array_sum(c(-2, -3, 4, -1, -2, 1, 5, -3)) == 7)\n    stopifnot(max_sub_array_sum(c(-2, 1, -3, 4, -1, 2, 1, -5, 4)) == 6)\n    stopifnot(max_sub_array_sum(c(1, 2, 3, 4, 5)) == 15)\n    stopifnot(max_sub_array_sum(c(-1, -2, -3, -4)) == -1)\n    stopifnot(max_sub_array_sum(c(0, 0, 0, 0)) == 0)\n}\n\ntest_max_sub_array_sum()", "output": "max_sub_array_sum"}, "all_code": "max_crossing_sum <- function(arr, left, mid, right) {\n    sum_left <- -Inf\n    sum_temp <- 0\n\n    for (i in mid:left) {\n        sum_temp <- sum_temp + arr[i]\n        if (sum_temp > sum_left) {\n            sum_left <- sum_temp\n        }\n    }\n\n    sum_right <- -Inf\n    sum_temp <- 0\n\n    for (i in (mid + 1):right) {\n        sum_temp <- sum_temp + arr[i]\n        if (sum_temp > sum_right) {\n            sum_right <- sum_temp\n        }\n    }\n\n    return(sum_left + sum_right)\n}\n\nmax_sub_array_sum_util <- function(arr, left, right) {\n    if (left == right) {\n        return(arr[left])\n    }\n\n    mid <- floor((left + right) / 2)\n\n    return(max(\n        max_sub_array_sum_util(arr, left, mid),\n        max_sub_array_sum_util(arr, mid + 1, right),\n        max_crossing_sum(arr, left, mid, right)\n    ))\n}\n\nmax_sub_array_sum <- function(arr) {\n    if (length(arr) == 0) {\n        return(0)\n    }\n    return(max_sub_array_sum_util(arr, 1, length(arr)))\n}\ntest_max_sub_array_sum <- function() {\n    stopifnot(max_sub_array_sum(c(-2, -3, 4, -1, -2, 1, 5, -3)) == 7)\n    stopifnot(max_sub_array_sum(c(-2, 1, -3, 4, -1, 2, 1, -5, 4)) == 6)\n    stopifnot(max_sub_array_sum(c(1, 2, 3, 4, 5)) == 15)\n    stopifnot(max_sub_array_sum(c(-1, -2, -3, -4)) == -1)\n    stopifnot(max_sub_array_sum(c(0, 0, 0, 0)) == 0)\n}\n\ntest_max_sub_array_sum()", "exec_outcome": "PASSED"}
{"code": "smallest_substring_with_distinct_chars <- function(s, p) {\n    if (p == 0) {\n        return(0)\n    }\n\n    n <- nchar(s)\n    if (p > n) {\n        return(-1)\n    }\n\n    left <- 1  # R uses 1-based indexing\n    right <- 1\n    char_count <- list()\n    distinct_count <- 0\n    min_length <- Inf\n\n    while (right <= n) {\n        current_char <- substr(s, right, right)\n        if (is.null(char_count[[current_char]])) {\n            char_count[[current_char]] <- 0\n        }\n        char_count[[current_char]] <- char_count[[current_char]] + 1\n        if (char_count[[current_char]] == 1) {\n            distinct_count <- distinct_count + 1\n        }\n\n        while (distinct_count >= p) {\n            current_window_length <- right - left + 1\n            if (current_window_length < min_length) {\n                min_length <- current_window_length\n            }\n            left_char <- substr(s, left, left)\n            char_count[[left_char]] <- char_count[[left_char]] - 1\n            if (char_count[[left_char]] == 0) {\n                distinct_count <- distinct_count - 1\n            }\n            left <- left + 1\n        }\n\n        right <- right + 1\n    }\n\n    if (min_length != Inf) {\n        return(min_length)\n    } else {\n        return(-1)\n    }\n}", "test_cases": "", "test_case_results": "Input string: 'abcda', p: 3\nResult: 3\n\nInput string: 'aaaa', p: 2\nResult: -1\n\nInput string: 'aabacbebebe', p: 3\nResult: 3\n\nInput string: 'a', p: 1\nResult: 1\n\nInput string: 'a', p: 2\nResult: -1\n\nInput string: '', p: 0\nResult: 0", "task_id": 17332, "assertions": "test_smallest_substring <- function() {\n    stopifnot(smallest_substring_with_distinct_chars(\"abcda\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"aaaa\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"aabacbebebe\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 1) == 1)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"\", 0) == 0)\n}\n\ntest_smallest_substring()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_smallest_substring <- function() {\n    stopifnot(smallest_substring_with_distinct_chars(\"abcda\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"aaaa\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"aabacbebebe\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 1) == 1)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"\", 0) == 0)\n}\n\ntest_smallest_substring()", "output": "smallest_substring_with_distinct_chars"}, "all_code": "smallest_substring_with_distinct_chars <- function(s, p) {\n    if (p == 0) {\n        return(0)\n    }\n\n    n <- nchar(s)\n    if (p > n) {\n        return(-1)\n    }\n\n    left <- 1  # R uses 1-based indexing\n    right <- 1\n    char_count <- list()\n    distinct_count <- 0\n    min_length <- Inf\n\n    while (right <= n) {\n        current_char <- substr(s, right, right)\n        if (is.null(char_count[[current_char]])) {\n            char_count[[current_char]] <- 0\n        }\n        char_count[[current_char]] <- char_count[[current_char]] + 1\n        if (char_count[[current_char]] == 1) {\n            distinct_count <- distinct_count + 1\n        }\n\n        while (distinct_count >= p) {\n            current_window_length <- right - left + 1\n            if (current_window_length < min_length) {\n                min_length <- current_window_length\n            }\n            left_char <- substr(s, left, left)\n            char_count[[left_char]] <- char_count[[left_char]] - 1\n            if (char_count[[left_char]] == 0) {\n                distinct_count <- distinct_count - 1\n            }\n            left <- left + 1\n        }\n\n        right <- right + 1\n    }\n\n    if (min_length != Inf) {\n        return(min_length)\n    } else {\n        return(-1)\n    }\n}\ntest_smallest_substring <- function() {\n    stopifnot(smallest_substring_with_distinct_chars(\"abcda\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"aaaa\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"aabacbebebe\", 3) == 3)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 1) == 1)\n    stopifnot(smallest_substring_with_distinct_chars(\"a\", 2) == -1)\n    stopifnot(smallest_substring_with_distinct_chars(\"\", 0) == 0)\n}\n\ntest_smallest_substring()", "exec_outcome": "PASSED"}
{"code": "is_critical_condition <- function(n, T, heart_rates) {\n    current_sum <- 0\n    start <- 1  # R uses 1-based indexing\n    \n    for (end in 1:n) {\n        current_sum <- current_sum + heart_rates[end]\n        \n        if (current_sum > T) {\n            return(\"YES\")\n        }\n        \n        # The original Python code had a redundant while loop, which is not needed\n        # since we return immediately if current_sum > T\n    }\n    \n    return(\"NO\")\n}", "test_cases": "", "test_case_results": "Input: n = 5 , T = 100 , heart_rates = 30 40 50 20 10 \nResult: YES \n\nInput: n = 4 , T = 150 , heart_rates = 50 60 40 30 \nResult: YES \n\nInput: n = 3 , T = 50 , heart_rates = 20 20 20 \nResult: YES \n\nInput: n = 6 , T = 200 , heart_rates = 100 50 60 70 80 90 \nResult: YES", "task_id": 17330, "assertions": "test_critical_condition <- function() {\n    stopifnot(is_critical_condition(5, 100, c(30, 40, 50, 20, 10)) == \"YES\")\n    stopifnot(is_critical_condition(4, 150, c(50, 60, 40, 30)) == \"YES\")\n    stopifnot(is_critical_condition(3, 50, c(20, 20, 20)) == \"YES\")\n    stopifnot(is_critical_condition(6, 200, c(100, 50, 60, 70, 80, 90)) == \"YES\")\n}\n\ntest_critical_condition()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_critical_condition <- function() {\n    stopifnot(is_critical_condition(5, 100, c(30, 40, 50, 20, 10)) == \"YES\")\n    stopifnot(is_critical_condition(4, 150, c(50, 60, 40, 30)) == \"YES\")\n    stopifnot(is_critical_condition(3, 50, c(20, 20, 20)) == \"YES\")\n    stopifnot(is_critical_condition(6, 200, c(100, 50, 60, 70, 80, 90)) == \"YES\")\n}\n\ntest_critical_condition()", "output": "is_critical_condition"}, "all_code": "is_critical_condition <- function(n, T, heart_rates) {\n    current_sum <- 0\n    start <- 1  # R uses 1-based indexing\n    \n    for (end in 1:n) {\n        current_sum <- current_sum + heart_rates[end]\n        \n        if (current_sum > T) {\n            return(\"YES\")\n        }\n        \n        # The original Python code had a redundant while loop, which is not needed\n        # since we return immediately if current_sum > T\n    }\n    \n    return(\"NO\")\n}\ntest_critical_condition <- function() {\n    stopifnot(is_critical_condition(5, 100, c(30, 40, 50, 20, 10)) == \"YES\")\n    stopifnot(is_critical_condition(4, 150, c(50, 60, 40, 30)) == \"YES\")\n    stopifnot(is_critical_condition(3, 50, c(20, 20, 20)) == \"YES\")\n    stopifnot(is_critical_condition(6, 200, c(100, 50, 60, 70, 80, 90)) == \"YES\")\n}\n\ntest_critical_condition()", "exec_outcome": "PASSED"}
{"code": "regex_match <- function(pattern, text) {\n  match_helper <- function(p_idx, t_idx) {\n    if (p_idx > nchar(pattern)) {  # End of pattern\n      return(t_idx > nchar(text))  # TRUE if end of text, else FALSE\n    }\n    \n    first_match <- t_idx <= nchar(text) && \n      (substr(pattern, p_idx, p_idx) == substr(text, t_idx, t_idx) || \n       substr(pattern, p_idx, p_idx) == \".\")\n    \n    if (p_idx + 1 <= nchar(pattern) && substr(pattern, p_idx + 1, p_idx + 1) == \"*\") {\n      return(match_helper(p_idx + 2, t_idx) || \n             (first_match && match_helper(p_idx, t_idx + 1)))\n    } else {\n      return(first_match && match_helper(p_idx + 1, t_idx + 1))\n    }\n  }\n  \n  return(match_helper(1, 1))\n}", "test_cases": "", "test_case_results": "Pattern:  a , Text:  a , Match:  TRUE \nPattern:  a , Text:  aa , Match:  FALSE \nPattern:  a* , Text:  aa , Match:  TRUE \nPattern:  .* , Text:  ab , Match:  TRUE \nPattern:  c*a*b , Text:  aab , Match:  TRUE \nPattern:  mis*is*p*. , Text:  mississippi , Match:  FALSE", "task_id": 5900, "assertions": "test_regex_match <- function() {\n    stopifnot(regex_match(\"a\", \"a\") == TRUE)\n    stopifnot(regex_match(\"a\", \"aa\") == FALSE)\n    stopifnot(regex_match(\"a*\", \"aa\") == TRUE)\n    stopifnot(regex_match(\".*\", \"ab\") == TRUE)\n    stopifnot(regex_match(\"c*a*b\", \"aab\") == TRUE)\n    stopifnot(regex_match(\"mis*is*p*.\", \"mississippi\") == FALSE)\n}\n\ntest_regex_match()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_regex_match <- function() {\n    stopifnot(regex_match(\"a\", \"a\") == TRUE)\n    stopifnot(regex_match(\"a\", \"aa\") == FALSE)\n    stopifnot(regex_match(\"a*\", \"aa\") == TRUE)\n    stopifnot(regex_match(\".*\", \"ab\") == TRUE)\n    stopifnot(regex_match(\"c*a*b\", \"aab\") == TRUE)\n    stopifnot(regex_match(\"mis*is*p*.\", \"mississippi\") == FALSE)\n}\n\ntest_regex_match()", "output": "regex_match"}, "all_code": "regex_match <- function(pattern, text) {\n  match_helper <- function(p_idx, t_idx) {\n    if (p_idx > nchar(pattern)) {  # End of pattern\n      return(t_idx > nchar(text))  # TRUE if end of text, else FALSE\n    }\n    \n    first_match <- t_idx <= nchar(text) && \n      (substr(pattern, p_idx, p_idx) == substr(text, t_idx, t_idx) || \n       substr(pattern, p_idx, p_idx) == \".\")\n    \n    if (p_idx + 1 <= nchar(pattern) && substr(pattern, p_idx + 1, p_idx + 1) == \"*\") {\n      return(match_helper(p_idx + 2, t_idx) || \n             (first_match && match_helper(p_idx, t_idx + 1)))\n    } else {\n      return(first_match && match_helper(p_idx + 1, t_idx + 1))\n    }\n  }\n  \n  return(match_helper(1, 1))\n}\ntest_regex_match <- function() {\n    stopifnot(regex_match(\"a\", \"a\") == TRUE)\n    stopifnot(regex_match(\"a\", \"aa\") == FALSE)\n    stopifnot(regex_match(\"a*\", \"aa\") == TRUE)\n    stopifnot(regex_match(\".*\", \"ab\") == TRUE)\n    stopifnot(regex_match(\"c*a*b\", \"aab\") == TRUE)\n    stopifnot(regex_match(\"mis*is*p*.\", \"mississippi\") == FALSE)\n}\n\ntest_regex_match()", "exec_outcome": "PASSED"}
{"code": "# max_area calculates the maximum amount of water a container can store, formed by two lines from the input vector.\n# The function uses a two-pointer approach to efficiently find the maximum area.\n# \n# Args:\n#   nums: A numeric vector representing the height of lines.\n#\n# Returns:\n#   The maximum amount of water a container can store.\nmax_area <- function(nums) {\n    left <- 1\n    right <- length(nums)\n    max_water <- 0\n\n    while (left < right) {\n        height <- min(nums[left], nums[right])\n        width <- right - left\n        current_area <- height * width\n        max_water <- max(max_water, current_area)\n\n        if (nums[left] < nums[right]) {\n            left <- left + 1\n        } else {\n            right <- right - 1\n        }\n    }\n\n    return(max_water)\n}", "test_cases": "", "test_case_results": "Input:  1 8 6 2 5 4 8 3 7 \nMax Water Area:  49 \n\nInput:  1 1 \nMax Water Area:  1 \n\nInput:  4 3 2 1 4 \nMax Water Area:  16 \n\nInput:  1 2 1 \nMax Water Area:  2", "task_id": 9799, "assertions": "test_max_area <- function() {\n    stopifnot(max_area(c(1, 8, 6, 2, 5, 4, 8, 3, 7)) == 49)\n    stopifnot(max_area(c(1, 1)) == 1)\n    stopifnot(max_area(c(4, 3, 2, 1, 4)) == 16)\n    stopifnot(max_area(c(1, 2, 1)) == 2)\n}\n\ntest_max_area()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_area <- function() {\n    stopifnot(max_area(c(1, 8, 6, 2, 5, 4, 8, 3, 7)) == 49)\n    stopifnot(max_area(c(1, 1)) == 1)\n    stopifnot(max_area(c(4, 3, 2, 1, 4)) == 16)\n    stopifnot(max_area(c(1, 2, 1)) == 2)\n}\n\ntest_max_area()", "output": "max_area"}, "all_code": "# max_area calculates the maximum amount of water a container can store, formed by two lines from the input vector.\n# The function uses a two-pointer approach to efficiently find the maximum area.\n# \n# Args:\n#   nums: A numeric vector representing the height of lines.\n#\n# Returns:\n#   The maximum amount of water a container can store.\nmax_area <- function(nums) {\n    left <- 1\n    right <- length(nums)\n    max_water <- 0\n\n    while (left < right) {\n        height <- min(nums[left], nums[right])\n        width <- right - left\n        current_area <- height * width\n        max_water <- max(max_water, current_area)\n\n        if (nums[left] < nums[right]) {\n            left <- left + 1\n        } else {\n            right <- right - 1\n        }\n    }\n\n    return(max_water)\n}\ntest_max_area <- function() {\n    stopifnot(max_area(c(1, 8, 6, 2, 5, 4, 8, 3, 7)) == 49)\n    stopifnot(max_area(c(1, 1)) == 1)\n    stopifnot(max_area(c(4, 3, 2, 1, 4)) == 16)\n    stopifnot(max_area(c(1, 2, 1)) == 2)\n}\n\ntest_max_area()", "exec_outcome": "PASSED"}
{"code": "min_operations_to_make_distinct <- function(S) {\n    # Count frequency of each character\n    char_count <- list()\n    for (char in strsplit(S, \"\")[[1]]) {\n        if (char %in% names(char_count)) {\n            char_count[[char]] <- char_count[[char]] + 1\n        } else {\n            char_count[[char]] <- 1\n        }\n    }\n    \n    # Calculate the number of operations needed\n    operations <- 0\n    for (count in char_count) {\n        if (count > 1) {\n            operations <- operations + (count - 1)\n        }\n    }\n    \n    return(operations)\n}\n\nprocess_test_cases <- function(test_cases) {\n    results <- list()\n    for (S in test_cases) {\n        results <- append(results, min_operations_to_make_distinct(S))\n    }\n    return(results)\n}", "test_cases": "", "test_case_results": "Input: \"aab\"\nMinimum operations: 1\nInput: \"abc\"\nMinimum operations: 0\nInput: \"aabbcc\"\nMinimum operations: 3\nInput: \"aaaaa\"\nMinimum operations: 4\nInput: \"\"\nMinimum operations: 0\n\nProcessing all test cases at once:\nInput: \"aab\" -> Minimum operations: 1\nInput: \"abc\" -> Minimum operations: 0\nInput: \"aabbcc\" -> Minimum operations: 3\nInput: \"aaaaa\" -> Minimum operations: 4\nInput: \"\" -> Minimum operations: 0", "task_id": 29602, "assertions": "test_min_operations <- function() {\n    test_cases <- list(\n        \"aab\",\n        \"abc\",\n        \"aabbcc\",\n        \"aaaaa\",\n        \"\"\n    )\n    expected_results <- list(1, 0, 3, 4, 0)\n    \n    # Test individual function\n    stopifnot(min_operations_to_make_distinct(\"aab\") == 1)\n    stopifnot(min_operations_to_make_distinct(\"abc\") == 0)\n    stopifnot(min_operations_to_make_distinct(\"aabbcc\") == 3)\n    stopifnot(min_operations_to_make_distinct(\"aaaaa\") == 4)\n    stopifnot(min_operations_to_make_distinct(\"\") == 0)\n    \n    # Test batch processing function\n    results <- process_test_cases(test_cases)\n    for (i in 1:length(test_cases)) {\n        stopifnot(results[[i]] == expected_results[[i]])\n    }\n}\n\ntest_min_operations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_operations <- function() {\n    test_cases <- list(\n        \"aab\",\n        \"abc\",\n        \"aabbcc\",\n        \"aaaaa\",\n        \"\"\n    )\n    expected_results <- list(1, 0, 3, 4, 0)\n    \n    # Test individual function\n    stopifnot(min_operations_to_make_distinct(\"aab\") == 1)\n    stopifnot(min_operations_to_make_distinct(\"abc\") == 0)\n    stopifnot(min_operations_to_make_distinct(\"aabbcc\") == 3)\n    stopifnot(min_operations_to_make_distinct(\"aaaaa\") == 4)\n    stopifnot(min_operations_to_make_distinct(\"\") == 0)\n    \n    # Test batch processing function\n    results <- process_test_cases(test_cases)\n    for (i in 1:length(test_cases)) {\n        stopifnot(results[[i]] == expected_results[[i]])\n    }\n}\n\ntest_min_operations()", "output": "min_operations_to_make_distinct"}, "all_code": "min_operations_to_make_distinct <- function(S) {\n    # Count frequency of each character\n    char_count <- list()\n    for (char in strsplit(S, \"\")[[1]]) {\n        if (char %in% names(char_count)) {\n            char_count[[char]] <- char_count[[char]] + 1\n        } else {\n            char_count[[char]] <- 1\n        }\n    }\n    \n    # Calculate the number of operations needed\n    operations <- 0\n    for (count in char_count) {\n        if (count > 1) {\n            operations <- operations + (count - 1)\n        }\n    }\n    \n    return(operations)\n}\n\nprocess_test_cases <- function(test_cases) {\n    results <- list()\n    for (S in test_cases) {\n        results <- append(results, min_operations_to_make_distinct(S))\n    }\n    return(results)\n}\ntest_min_operations <- function() {\n    test_cases <- list(\n        \"aab\",\n        \"abc\",\n        \"aabbcc\",\n        \"aaaaa\",\n        \"\"\n    )\n    expected_results <- list(1, 0, 3, 4, 0)\n    \n    # Test individual function\n    stopifnot(min_operations_to_make_distinct(\"aab\") == 1)\n    stopifnot(min_operations_to_make_distinct(\"abc\") == 0)\n    stopifnot(min_operations_to_make_distinct(\"aabbcc\") == 3)\n    stopifnot(min_operations_to_make_distinct(\"aaaaa\") == 4)\n    stopifnot(min_operations_to_make_distinct(\"\") == 0)\n    \n    # Test batch processing function\n    results <- process_test_cases(test_cases)\n    for (i in 1:length(test_cases)) {\n        stopifnot(results[[i]] == expected_results[[i]])\n    }\n}\n\ntest_min_operations()", "exec_outcome": "PASSED"}
{"code": "# visible_buildings calculates the number of visible buildings from a given vantage point to the end of the array.\n# A building is considered visible if it is taller than all the buildings before it (from the vantage point onwards).\n# The function takes a numeric vector of building heights and an integer representing the vantage point index.\n# It returns the count of visible buildings.\nvisible_buildings <- function(heights, vantage_point) {\n  n <- length(heights)\n  visible_count <- 0\n  current_max_height <- 0\n  \n  for (i in (vantage_point + 1):n) {  # R uses 1-based indexing\n    if (heights[i] > current_max_height) {\n      visible_count <- visible_count + 1\n      current_max_height <- heights[i]\n    }\n  }\n  \n  return(visible_count)\n}", "test_cases": "", "test_case_results": "Heights:  1 2 3 4 , Vantage Point:  0 \nVisible Buildings:  4 \nHeights:  5 1 2 3 , Vantage Point:  1 \nVisible Buildings:  3 \nHeights:  3 2 1 5 , Vantage Point:  2 \nVisible Buildings:  2 \nHeights:  1 1 1 1 , Vantage Point:  0 \nVisible Buildings:  1 \nHeights:  10 9 8 7 , Vantage Point:  0 \nVisible Buildings:  1", "task_id": 25289, "assertions": "test.visible_buildings <- function() {\n  stopifnot(visible_buildings(c(1, 2, 3, 4), 0) == 4)\n  stopifnot(visible_buildings(c(5, 1, 2, 3), 1) == 3)\n  stopifnot(visible_buildings(c(3, 2, 1, 5), 2) == 2)\n  stopifnot(visible_buildings(c(1, 1, 1, 1), 0) == 1)\n  stopifnot(visible_buildings(c(10, 9, 8, 7), 0) == 1)\n}\n\ntest.visible_buildings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.visible_buildings <- function() {\n  stopifnot(visible_buildings(c(1, 2, 3, 4), 0) == 4)\n  stopifnot(visible_buildings(c(5, 1, 2, 3), 1) == 3)\n  stopifnot(visible_buildings(c(3, 2, 1, 5), 2) == 2)\n  stopifnot(visible_buildings(c(1, 1, 1, 1), 0) == 1)\n  stopifnot(visible_buildings(c(10, 9, 8, 7), 0) == 1)\n}\n\ntest.visible_buildings()", "output": "visible_buildings"}, "all_code": "# visible_buildings calculates the number of visible buildings from a given vantage point to the end of the array.\n# A building is considered visible if it is taller than all the buildings before it (from the vantage point onwards).\n# The function takes a numeric vector of building heights and an integer representing the vantage point index.\n# It returns the count of visible buildings.\nvisible_buildings <- function(heights, vantage_point) {\n  n <- length(heights)\n  visible_count <- 0\n  current_max_height <- 0\n  \n  for (i in (vantage_point + 1):n) {  # R uses 1-based indexing\n    if (heights[i] > current_max_height) {\n      visible_count <- visible_count + 1\n      current_max_height <- heights[i]\n    }\n  }\n  \n  return(visible_count)\n}\ntest.visible_buildings <- function() {\n  stopifnot(visible_buildings(c(1, 2, 3, 4), 0) == 4)\n  stopifnot(visible_buildings(c(5, 1, 2, 3), 1) == 3)\n  stopifnot(visible_buildings(c(3, 2, 1, 5), 2) == 2)\n  stopifnot(visible_buildings(c(1, 1, 1, 1), 0) == 1)\n  stopifnot(visible_buildings(c(10, 9, 8, 7), 0) == 1)\n}\n\ntest.visible_buildings()", "exec_outcome": "PASSED"}
{"code": "insert_reversed_string <- function(str1, str2, pos) {\n  if (pos < 0 || pos > nchar(str2)) {\n    stop(\"Position is out of bounds of the second string.\")\n  }\n  \n  reversed_str1 <- paste(rev(strsplit(str1, NULL)[[1]]), collapse = \"\")\n  new_str <- paste0(substring(str2, 1, pos), reversed_str1, substring(str2, pos + 1))\n  return(new_str)\n}", "test_cases": "", "test_case_results": "Input: str1 = 'hello', str2 = 'world', pos = 2\nResult: 'woollehrld'\nInput: str1 = 'abc', str2 = 'defgh', pos = 0\nResult: 'cbadefgh'\nInput: str1 = '123', str2 = '456', pos = 3\nResult: '456321'\nInput: str1 = 'x', str2 = 'y', pos = 1\nResult: 'yx'", "task_id": 26414, "assertions": "test_insert_reversed_string <- function() {\n    # Test normal cases\n    stopifnot(insert_reversed_string(\"hello\", \"world\", 2) == \"woollehrld\")\n    stopifnot(insert_reversed_string(\"abc\", \"defgh\", 0) == \"cbadefgh\")\n    stopifnot(insert_reversed_string(\"123\", \"456\", 3) == \"456321\")\n    stopifnot(insert_reversed_string(\"x\", \"y\", 1) == \"yx\")\n    \n    # Test error case\n    error_occurred <- FALSE\n    tryCatch({\n        insert_reversed_string(\"test\", \"string\", 10)\n    }, error = function(e) {\n        error_occurred <<- TRUE\n    })\n    stopifnot(error_occurred)\n}\n\ntest_insert_reversed_string()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_insert_reversed_string <- function() {\n    # Test normal cases\n    stopifnot(insert_reversed_string(\"hello\", \"world\", 2) == \"woollehrld\")\n    stopifnot(insert_reversed_string(\"abc\", \"defgh\", 0) == \"cbadefgh\")\n    stopifnot(insert_reversed_string(\"123\", \"456\", 3) == \"456321\")\n    stopifnot(insert_reversed_string(\"x\", \"y\", 1) == \"yx\")\n    \n    # Test error case\n    error_occurred <- FALSE\n    tryCatch({\n        insert_reversed_string(\"test\", \"string\", 10)\n    }, error = function(e) {\n        error_occurred <<- TRUE\n    })\n    stopifnot(error_occurred)\n}\n\ntest_insert_reversed_string()", "output": "insert_reversed_string"}, "all_code": "insert_reversed_string <- function(str1, str2, pos) {\n  if (pos < 0 || pos > nchar(str2)) {\n    stop(\"Position is out of bounds of the second string.\")\n  }\n  \n  reversed_str1 <- paste(rev(strsplit(str1, NULL)[[1]]), collapse = \"\")\n  new_str <- paste0(substring(str2, 1, pos), reversed_str1, substring(str2, pos + 1))\n  return(new_str)\n}\ntest_insert_reversed_string <- function() {\n    # Test normal cases\n    stopifnot(insert_reversed_string(\"hello\", \"world\", 2) == \"woollehrld\")\n    stopifnot(insert_reversed_string(\"abc\", \"defgh\", 0) == \"cbadefgh\")\n    stopifnot(insert_reversed_string(\"123\", \"456\", 3) == \"456321\")\n    stopifnot(insert_reversed_string(\"x\", \"y\", 1) == \"yx\")\n    \n    # Test error case\n    error_occurred <- FALSE\n    tryCatch({\n        insert_reversed_string(\"test\", \"string\", 10)\n    }, error = function(e) {\n        error_occurred <<- TRUE\n    })\n    stopifnot(error_occurred)\n}\n\ntest_insert_reversed_string()", "exec_outcome": "PASSED"}
{"code": "min_days_to_complete_projects <- function(arr, k) {\n    n <- length(arr)\n\n    # Base cases\n    if (n == 0) {\n        return(0)\n    }\n    if (n == 1) {\n        return(arr[1])\n    }\n\n    # Initialize the count of days\n    days <- 0\n    i <- 1  # R uses 1-based indexing\n\n    while (i <= n) {\n        days <- days + arr[i]\n        if (i < n) {\n            days <- days + k\n        }\n        i <- i + 1\n    }\n\n    return(days)\n}", "test_cases": "", "test_case_results": "Input array:  1 2 3 , Cooldown period (k):  1 \nMinimum days to complete projects:  8 \nInput array:  5 , Cooldown period (k):  2 \nMinimum days to complete projects:  5 \nInput array:  , Cooldown period (k):  3 \nMinimum days to complete projects:  0 \nInput array:  4 6 2 7 , Cooldown period (k):  2 \nMinimum days to complete projects:  25", "task_id": 12667, "assertions": "test_min_days_to_complete_projects <- function() {\n    stopifnot(min_days_to_complete_projects(c(1, 2, 3), 1) == 8)\n    stopifnot(min_days_to_complete_projects(c(5), 2) == 5)\n    stopifnot(min_days_to_complete_projects(c(), 3) == 0)\n    stopifnot(min_days_to_complete_projects(c(4, 6, 2, 7), 2) == 25)\n}\n\ntest_min_days_to_complete_projects()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_days_to_complete_projects <- function() {\n    stopifnot(min_days_to_complete_projects(c(1, 2, 3), 1) == 8)\n    stopifnot(min_days_to_complete_projects(c(5), 2) == 5)\n    stopifnot(min_days_to_complete_projects(c(), 3) == 0)\n    stopifnot(min_days_to_complete_projects(c(4, 6, 2, 7), 2) == 25)\n}\n\ntest_min_days_to_complete_projects()", "output": "min_days_to_complete_projects"}, "all_code": "min_days_to_complete_projects <- function(arr, k) {\n    n <- length(arr)\n\n    # Base cases\n    if (n == 0) {\n        return(0)\n    }\n    if (n == 1) {\n        return(arr[1])\n    }\n\n    # Initialize the count of days\n    days <- 0\n    i <- 1  # R uses 1-based indexing\n\n    while (i <= n) {\n        days <- days + arr[i]\n        if (i < n) {\n            days <- days + k\n        }\n        i <- i + 1\n    }\n\n    return(days)\n}\ntest_min_days_to_complete_projects <- function() {\n    stopifnot(min_days_to_complete_projects(c(1, 2, 3), 1) == 8)\n    stopifnot(min_days_to_complete_projects(c(5), 2) == 5)\n    stopifnot(min_days_to_complete_projects(c(), 3) == 0)\n    stopifnot(min_days_to_complete_projects(c(4, 6, 2, 7), 2) == 25)\n}\n\ntest_min_days_to_complete_projects()", "exec_outcome": "PASSED"}
{"code": "# can_rearrange_books checks if it's possible to rearrange a set of books such that no two adjacent books have the same height.\n# The function takes the number of books (n) and a vector of their heights.\n# It returns \"Yes\" if such a rearrangement is possible, otherwise \"No\".\n# The logic is based on the frequency of the most common height; if it's more than half the total books (rounded up), rearrangement is impossible.\ncan_rearrange_books <- function(n, heights) {\n  # Calculate the frequency of each height\n  height_freq <- table(heights)\n  \n  # Find the maximum frequency of any single height\n  max_freq <- max(height_freq)\n  \n  # Check if the maximum frequency is greater than half the number of books (rounded up)\n  if (max_freq <= (n + 1) %/% 2) {\n    return(\"Yes\")\n  } else {\n    return(\"No\")\n  }\n}", "test_cases": "", "test_case_results": "Input - n:  4 , heights:  1 2 1 2 \nResult:  Yes \nInput - n:  5 , heights:  1 1 1 2 2 \nResult:  Yes \nInput - n:  3 , heights:  1 1 2 \nResult:  Yes \nInput - n:  6 , heights:  1 2 3 1 2 3 \nResult:  Yes", "task_id": 12687, "assertions": "test_book_rearrangement <- function() {\n  stopifnot(can_rearrange_books(4, c(1, 2, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(5, c(1, 1, 1, 2, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(3, c(1, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(6, c(1, 2, 3, 1, 2, 3)) == \"Yes\")\n}\n\ntest_book_rearrangement()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_book_rearrangement <- function() {\n  stopifnot(can_rearrange_books(4, c(1, 2, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(5, c(1, 1, 1, 2, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(3, c(1, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(6, c(1, 2, 3, 1, 2, 3)) == \"Yes\")\n}\n\ntest_book_rearrangement()", "output": "can_rearrange_books"}, "all_code": "# can_rearrange_books checks if it's possible to rearrange a set of books such that no two adjacent books have the same height.\n# The function takes the number of books (n) and a vector of their heights.\n# It returns \"Yes\" if such a rearrangement is possible, otherwise \"No\".\n# The logic is based on the frequency of the most common height; if it's more than half the total books (rounded up), rearrangement is impossible.\ncan_rearrange_books <- function(n, heights) {\n  # Calculate the frequency of each height\n  height_freq <- table(heights)\n  \n  # Find the maximum frequency of any single height\n  max_freq <- max(height_freq)\n  \n  # Check if the maximum frequency is greater than half the number of books (rounded up)\n  if (max_freq <= (n + 1) %/% 2) {\n    return(\"Yes\")\n  } else {\n    return(\"No\")\n  }\n}\ntest_book_rearrangement <- function() {\n  stopifnot(can_rearrange_books(4, c(1, 2, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(5, c(1, 1, 1, 2, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(3, c(1, 1, 2)) == \"Yes\")\n  stopifnot(can_rearrange_books(6, c(1, 2, 3, 1, 2, 3)) == \"Yes\")\n}\n\ntest_book_rearrangement()", "exec_outcome": "PASSED"}
{"code": "can_form_by_deleting_one <- function(s, t) {\n    if (nchar(s) != nchar(t) + 1) {\n        return(FALSE)\n    }\n\n    s_counter <- table(strsplit(s, \"\")[[1]])\n    t_counter <- table(strsplit(t, \"\")[[1]])\n\n    diff_count <- 0\n    for (char in names(s_counter)) {\n        s_count <- s_counter[[char]]\n        t_count <- ifelse(char %in% names(t_counter), t_counter[[char]], 0)\n        if (s_count != t_count) {\n            diff_count <- diff_count + 1\n            if (diff_count > 1 || t_count != s_count - 1) {\n                return(FALSE)\n            }\n        }\n    }\n\n    return(TRUE)\n}", "test_cases": "", "test_case_results": "Input s:  abcde , Input t:  abce \nResult:  TRUE \nInput s:  abcde , Input t:  abcd \nResult:  TRUE \nInput s:  aabbcc , Input t:  aabbc \nResult:  TRUE \nInput s:  aabbcc , Input t:  aabbb \nResult:  FALSE \nInput s:  hello , Input t:  hell \nResult:  TRUE \nInput s:  hello , Input t:  helo \nResult:  TRUE", "task_id": 10960, "assertions": "test_can_form_by_deleting_one <- function() {\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abce\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abcd\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbc\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbb\") == FALSE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"hell\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"helo\") == TRUE)\n}\n\ntest_can_form_by_deleting_one()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_can_form_by_deleting_one <- function() {\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abce\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abcd\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbc\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbb\") == FALSE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"hell\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"helo\") == TRUE)\n}\n\ntest_can_form_by_deleting_one()", "output": "can_form_by_deleting_one"}, "all_code": "can_form_by_deleting_one <- function(s, t) {\n    if (nchar(s) != nchar(t) + 1) {\n        return(FALSE)\n    }\n\n    s_counter <- table(strsplit(s, \"\")[[1]])\n    t_counter <- table(strsplit(t, \"\")[[1]])\n\n    diff_count <- 0\n    for (char in names(s_counter)) {\n        s_count <- s_counter[[char]]\n        t_count <- ifelse(char %in% names(t_counter), t_counter[[char]], 0)\n        if (s_count != t_count) {\n            diff_count <- diff_count + 1\n            if (diff_count > 1 || t_count != s_count - 1) {\n                return(FALSE)\n            }\n        }\n    }\n\n    return(TRUE)\n}\ntest_can_form_by_deleting_one <- function() {\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abce\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"abcde\", \"abcd\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbc\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"aabbcc\", \"aabbb\") == FALSE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"hell\") == TRUE)\n    stopifnot(can_form_by_deleting_one(\"hello\", \"helo\") == TRUE)\n}\n\ntest_can_form_by_deleting_one()", "exec_outcome": "PASSED"}
{"code": "find_common_free_time <- function(schedule) {\n  # Flatten the schedule to get all the busy intervals\n  all_busy_intervals <- unlist(schedule, recursive = FALSE)\n  \n  # Sort the busy intervals by start time\n  all_busy_intervals <- all_busy_intervals[order(sapply(all_busy_intervals, function(x) x[1]))]\n  \n  # Merge overlapping intervals\n  merged_intervals <- list()\n  for (interval in all_busy_intervals) {\n    if (length(merged_intervals) == 0 || merged_intervals[[length(merged_intervals)]][2] < interval[1]) {\n      merged_intervals <- c(merged_intervals, list(interval))\n    } else {\n      merged_intervals[[length(merged_intervals)]][2] <- max(merged_intervals[[length(merged_intervals)]][2], interval[2])\n    }\n  }\n  \n  # Find the common free time\n  common_free_time <- list()\n  work_start <- 0\n  work_end <- 1440\n  \n  for (interval in merged_intervals) {\n    if (work_start < interval[1]) {\n      common_free_time <- c(common_free_time, list(c(work_start, interval[1])))\n    }\n    work_start <- interval[2]\n  }\n  \n  if (work_start < work_end) {\n    common_free_time <- c(common_free_time, list(c(work_start, work_end)))\n  }\n  \n  return(common_free_time)\n}", "test_cases": "", "test_case_results": "Test case 1 \nInput schedule:\n[[1]]\n[[1]][[1]]\n[1] 300 400\n\n[[1]][[2]]\n[1] 500 600\n\n\n[[2]]\n[[2]][[1]]\n[1] 700 800\n\n\nCommon free time intervals:\n[[1]]\n[1]   0 300\n\n[[2]]\n[1] 400 500\n\n[[3]]\n[1] 600 700\n\n[[4]]\n[1]  800 1440\n\n\nTest case 2 \nInput schedule:\n[[1]]\n[[1]][[1]]\n[1] 300 400\n\n[[1]][[2]]\n[1] 350 450\n\n\n[[2]]\n[[2]][[1]]\n[1] 400 500\n\n\nCommon free time intervals:\n[[1]]\n[1]   0 300\n\n[[2]]\n[1]  500 1440\n\n\nTest case 3 \nInput schedule:\n[[1]]\n[[1]][[1]]\n[1] 300 400\n\n[[1]][[2]]\n[1] 400 500\n\n\n[[2]]\n[[2]][[1]]\n[1] 500 600\n\n\nCommon free time intervals:\n[[1]]\n[1]   0 300\n\n[[2]]\n[1]  600 1440\n\n\nTest case 4 \nInput schedule:\n[[1]]\n[[1]][[1]]\n[1]    0 1440\n\n\n[[2]]\n[[2]][[1]]\n[1]    0 1440\n\n\nCommon free time intervals:\nlist()\n\nTest case 5 \nInput schedule:\nlist()\nCommon free time intervals:\n[[1]]\n[1]    0 1440", "task_id": 9873, "assertions": "test_common_free_time <- function() {\n    # Test case 1: No overlapping intervals\n    test_case1 <- list(\n        list(c(300, 400), c(500, 600)),\n        list(c(700, 800))\n    )\n    result1 <- find_common_free_time(test_case1)\n    stopifnot(identical(result1, list(c(0, 300), c(400, 500), c(600, 700), c(800, 1440))))\n    \n    # Test case 2: Overlapping intervals\n    test_case2 <- list(\n        list(c(300, 400), c(350, 450)),\n        list(c(400, 500))\n    )\n    result2 <- find_common_free_time(test_case2)\n    stopifnot(identical(result2, list(c(0, 300), c(500, 1440))))\n    \n    # Test case 3: Adjacent intervals\n    test_case3 <- list(\n        list(c(300, 400), c(400, 500)),\n        list(c(500, 600))\n    )\n    result3 <- find_common_free_time(test_case3)\n    stopifnot(identical(result3, list(c(0, 300), c(600, 1440))))\n    \n    # Test case 4: Full day busy\n    test_case4 <- list(\n        list(c(0, 1440)),\n        list(c(0, 1440))\n    )\n    result4 <- find_common_free_time(test_case4)\n    stopifnot(identical(result4, list()))\n    \n    # Test case 5: Empty schedule\n    test_case5 <- list()\n    result5 <- find_common_free_time(test_case5)\n    stopifnot(identical(result5, list(c(0, 1440))))\n}\n\ntest_common_free_time()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_common_free_time <- function() {\n    # Test case 1: No overlapping intervals\n    test_case1 <- list(\n        list(c(300, 400), c(500, 600)),\n        list(c(700, 800))\n    )\n    result1 <- find_common_free_time(test_case1)\n    stopifnot(identical(result1, list(c(0, 300), c(400, 500), c(600, 700), c(800, 1440))))\n    \n    # Test case 2: Overlapping intervals\n    test_case2 <- list(\n        list(c(300, 400), c(350, 450)),\n        list(c(400, 500))\n    )\n    result2 <- find_common_free_time(test_case2)\n    stopifnot(identical(result2, list(c(0, 300), c(500, 1440))))\n    \n    # Test case 3: Adjacent intervals\n    test_case3 <- list(\n        list(c(300, 400), c(400, 500)),\n        list(c(500, 600))\n    )\n    result3 <- find_common_free_time(test_case3)\n    stopifnot(identical(result3, list(c(0, 300), c(600, 1440))))\n    \n    # Test case 4: Full day busy\n    test_case4 <- list(\n        list(c(0, 1440)),\n        list(c(0, 1440))\n    )\n    result4 <- find_common_free_time(test_case4)\n    stopifnot(identical(result4, list()))\n    \n    # Test case 5: Empty schedule\n    test_case5 <- list()\n    result5 <- find_common_free_time(test_case5)\n    stopifnot(identical(result5, list(c(0, 1440))))\n}\n\ntest_common_free_time()", "output": "find_common_free_time"}, "all_code": "find_common_free_time <- function(schedule) {\n  # Flatten the schedule to get all the busy intervals\n  all_busy_intervals <- unlist(schedule, recursive = FALSE)\n  \n  # Sort the busy intervals by start time\n  all_busy_intervals <- all_busy_intervals[order(sapply(all_busy_intervals, function(x) x[1]))]\n  \n  # Merge overlapping intervals\n  merged_intervals <- list()\n  for (interval in all_busy_intervals) {\n    if (length(merged_intervals) == 0 || merged_intervals[[length(merged_intervals)]][2] < interval[1]) {\n      merged_intervals <- c(merged_intervals, list(interval))\n    } else {\n      merged_intervals[[length(merged_intervals)]][2] <- max(merged_intervals[[length(merged_intervals)]][2], interval[2])\n    }\n  }\n  \n  # Find the common free time\n  common_free_time <- list()\n  work_start <- 0\n  work_end <- 1440\n  \n  for (interval in merged_intervals) {\n    if (work_start < interval[1]) {\n      common_free_time <- c(common_free_time, list(c(work_start, interval[1])))\n    }\n    work_start <- interval[2]\n  }\n  \n  if (work_start < work_end) {\n    common_free_time <- c(common_free_time, list(c(work_start, work_end)))\n  }\n  \n  return(common_free_time)\n}\ntest_common_free_time <- function() {\n    # Test case 1: No overlapping intervals\n    test_case1 <- list(\n        list(c(300, 400), c(500, 600)),\n        list(c(700, 800))\n    )\n    result1 <- find_common_free_time(test_case1)\n    stopifnot(identical(result1, list(c(0, 300), c(400, 500), c(600, 700), c(800, 1440))))\n    \n    # Test case 2: Overlapping intervals\n    test_case2 <- list(\n        list(c(300, 400), c(350, 450)),\n        list(c(400, 500))\n    )\n    result2 <- find_common_free_time(test_case2)\n    stopifnot(identical(result2, list(c(0, 300), c(500, 1440))))\n    \n    # Test case 3: Adjacent intervals\n    test_case3 <- list(\n        list(c(300, 400), c(400, 500)),\n        list(c(500, 600))\n    )\n    result3 <- find_common_free_time(test_case3)\n    stopifnot(identical(result3, list(c(0, 300), c(600, 1440))))\n    \n    # Test case 4: Full day busy\n    test_case4 <- list(\n        list(c(0, 1440)),\n        list(c(0, 1440))\n    )\n    result4 <- find_common_free_time(test_case4)\n    stopifnot(identical(result4, list()))\n    \n    # Test case 5: Empty schedule\n    test_case5 <- list()\n    result5 <- find_common_free_time(test_case5)\n    stopifnot(identical(result5, list(c(0, 1440))))\n}\n\ntest_common_free_time()", "exec_outcome": "PASSED"}
{"code": "toggle_bulbs <- function(n, operations) {\n  bulbs <- rep(0, n)\n  \n  for (op in operations) {\n    left <- op[1]\n    right <- op[2]\n    bulbs[left:right] <- 1 - bulbs[left:right]\n  }\n  \n  return(bulbs)\n}", "test_cases": "", "test_case_results": "Number of bulbs:  5 \nOperations: [[1]]\n[1] 1 3\n\n[[2]]\n[1] 2 4\n\nFinal bulb states:  1 0 0 1 0 \n\nNumber of bulbs:  3 \nOperations: [[1]]\n[1] 1 2\n\n[[2]]\n[1] 2 3\n\nFinal bulb states:  1 0 1 \n\nNumber of bulbs:  10 \nOperations: [[1]]\n[1]  1 10\n\n[[2]]\n[1] 1 5\n\n[[3]]\n[1]  6 10\n\nFinal bulb states:  0 0 0 0 0 0 0 0 0 0", "task_id": 5004, "assertions": "test_toggle_bulbs <- function() {\n  # Test case 1\n  result1 <- toggle_bulbs(5, list(c(1, 3), c(2, 4)))\n  stopifnot(identical(result1, c(1, 0, 0, 1, 0)))\n  \n  # Test case 2\n  result2 <- toggle_bulbs(3, list(c(1, 2), c(2, 3)))\n  stopifnot(identical(result2, c(1, 0, 1)))\n  \n  # Test case 3\n  result3 <- toggle_bulbs(10, list(c(1, 10), c(1, 5), c(6, 10)))\n  stopifnot(identical(result3, c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)))\n}\n\ntest_toggle_bulbs()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_toggle_bulbs <- function() {\n  # Test case 1\n  result1 <- toggle_bulbs(5, list(c(1, 3), c(2, 4)))\n  stopifnot(identical(result1, c(1, 0, 0, 1, 0)))\n  \n  # Test case 2\n  result2 <- toggle_bulbs(3, list(c(1, 2), c(2, 3)))\n  stopifnot(identical(result2, c(1, 0, 1)))\n  \n  # Test case 3\n  result3 <- toggle_bulbs(10, list(c(1, 10), c(1, 5), c(6, 10)))\n  stopifnot(identical(result3, c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)))\n}\n\ntest_toggle_bulbs()", "output": "toggle_bulbs"}, "all_code": "toggle_bulbs <- function(n, operations) {\n  bulbs <- rep(0, n)\n  \n  for (op in operations) {\n    left <- op[1]\n    right <- op[2]\n    bulbs[left:right] <- 1 - bulbs[left:right]\n  }\n  \n  return(bulbs)\n}\ntest_toggle_bulbs <- function() {\n  # Test case 1\n  result1 <- toggle_bulbs(5, list(c(1, 3), c(2, 4)))\n  stopifnot(identical(result1, c(1, 0, 0, 1, 0)))\n  \n  # Test case 2\n  result2 <- toggle_bulbs(3, list(c(1, 2), c(2, 3)))\n  stopifnot(identical(result2, c(1, 0, 1)))\n  \n  # Test case 3\n  result3 <- toggle_bulbs(10, list(c(1, 10), c(1, 5), c(6, 10)))\n  stopifnot(identical(result3, c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)))\n}\n\ntest_toggle_bulbs()", "exec_outcome": "PASSED"}
{"code": "# is_quasi_fibonacci determines if a given numeric vector follows a quasi-fibonacci sequence.\n# A quasi-fibonacci sequence is defined such that each element (from the third onward) \n# is either equal to one of the two preceding elements (if they are non-zero) \n# or their sum. The function checks this condition for all elements in the sequence.\n# \n# Args:\n#   sequence: A numeric vector representing the sequence to be checked.\n#\n# Returns:\n#   A logical value (TRUE or FALSE) indicating whether the sequence is quasi-fibonacci.\nis_quasi_fibonacci <- function(sequence) {\n    if (length(sequence) < 3) {\n        return(TRUE)\n    }\n    \n    for (i in 3:length(sequence)) {\n        a <- sequence[i-2]\n        b <- sequence[i-1]\n        possible_next_values <- c()\n        \n        if (a == 0 && b == 0) {\n            possible_next_values <- c(possible_next_values, 0)\n        } else {\n            if (a != 0) {\n                possible_next_values <- c(possible_next_values, a)\n            }\n            if (b != 0) {\n                possible_next_values <- c(possible_next_values, b)\n            }\n            possible_next_values <- c(possible_next_values, a + b)\n        }\n        \n        if (!(sequence[i] %in% possible_next_values)) {\n            return(FALSE)\n        }\n    }\n    \n    return(TRUE)\n}", "test_cases": "", "test_case_results": "Input:  1 1 2 3 5 \nIs Quasi-Fibonacci:  TRUE \n\nInput:  0 0 0 0 \nIs Quasi-Fibonacci:  TRUE \n\nInput:  1 2 1 2 1 \nIs Quasi-Fibonacci:  TRUE \n\nInput:  1 2 3 4 5 \nIs Quasi-Fibonacci:  FALSE \n\nInput:  1 0 1 1 2 \nIs Quasi-Fibonacci:  TRUE \n\nInput:  5 5 10 5 10 \nIs Quasi-Fibonacci:  TRUE", "task_id": 22411, "assertions": "test_quasi_fibonacci <- function() {\n    # Test cases from original code with expected results\n    stopifnot(is_quasi_fibonacci(c(1, 1, 2, 3, 5)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(0, 0, 0, 0)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 1, 2, 1)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 3, 4, 5)) == FALSE)\n    stopifnot(is_quasi_fibonacci(c(1, 0, 1, 1, 2)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(5, 5, 10, 5, 10)) == TRUE)\n    \n    # Additional edge cases\n    stopifnot(is_quasi_fibonacci(c(1)) == TRUE)  # Single element\n    stopifnot(is_quasi_fibonacci(c(1, 2)) == TRUE)  # Two elements\n    stopifnot(is_quasi_fibonacci(c(1, 1, 1)) == TRUE)  # All same elements\n}\n\ntest_quasi_fibonacci()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_quasi_fibonacci <- function() {\n    # Test cases from original code with expected results\n    stopifnot(is_quasi_fibonacci(c(1, 1, 2, 3, 5)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(0, 0, 0, 0)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 1, 2, 1)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 3, 4, 5)) == FALSE)\n    stopifnot(is_quasi_fibonacci(c(1, 0, 1, 1, 2)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(5, 5, 10, 5, 10)) == TRUE)\n    \n    # Additional edge cases\n    stopifnot(is_quasi_fibonacci(c(1)) == TRUE)  # Single element\n    stopifnot(is_quasi_fibonacci(c(1, 2)) == TRUE)  # Two elements\n    stopifnot(is_quasi_fibonacci(c(1, 1, 1)) == TRUE)  # All same elements\n}\n\ntest_quasi_fibonacci()", "output": "is_quasi_fibonacci"}, "all_code": "# is_quasi_fibonacci determines if a given numeric vector follows a quasi-fibonacci sequence.\n# A quasi-fibonacci sequence is defined such that each element (from the third onward) \n# is either equal to one of the two preceding elements (if they are non-zero) \n# or their sum. The function checks this condition for all elements in the sequence.\n# \n# Args:\n#   sequence: A numeric vector representing the sequence to be checked.\n#\n# Returns:\n#   A logical value (TRUE or FALSE) indicating whether the sequence is quasi-fibonacci.\nis_quasi_fibonacci <- function(sequence) {\n    if (length(sequence) < 3) {\n        return(TRUE)\n    }\n    \n    for (i in 3:length(sequence)) {\n        a <- sequence[i-2]\n        b <- sequence[i-1]\n        possible_next_values <- c()\n        \n        if (a == 0 && b == 0) {\n            possible_next_values <- c(possible_next_values, 0)\n        } else {\n            if (a != 0) {\n                possible_next_values <- c(possible_next_values, a)\n            }\n            if (b != 0) {\n                possible_next_values <- c(possible_next_values, b)\n            }\n            possible_next_values <- c(possible_next_values, a + b)\n        }\n        \n        if (!(sequence[i] %in% possible_next_values)) {\n            return(FALSE)\n        }\n    }\n    \n    return(TRUE)\n}\ntest_quasi_fibonacci <- function() {\n    # Test cases from original code with expected results\n    stopifnot(is_quasi_fibonacci(c(1, 1, 2, 3, 5)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(0, 0, 0, 0)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 1, 2, 1)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(1, 2, 3, 4, 5)) == FALSE)\n    stopifnot(is_quasi_fibonacci(c(1, 0, 1, 1, 2)) == TRUE)\n    stopifnot(is_quasi_fibonacci(c(5, 5, 10, 5, 10)) == TRUE)\n    \n    # Additional edge cases\n    stopifnot(is_quasi_fibonacci(c(1)) == TRUE)  # Single element\n    stopifnot(is_quasi_fibonacci(c(1, 2)) == TRUE)  # Two elements\n    stopifnot(is_quasi_fibonacci(c(1, 1, 1)) == TRUE)  # All same elements\n}\n\ntest_quasi_fibonacci()", "exec_outcome": "PASSED"}
{"code": "# has_unique_characters determines if a given string contains all unique characters.\n# It assumes the string contains only lowercase alphabetical characters.\n# The function uses a logical vector to track seen characters for efficiency.\n#\n# Parameters:\n#   s - Input string (character vector of length 1 in R)\n#\n# Returns:\n#   TRUE if all characters are unique, FALSE otherwise\nhas_unique_characters <- function(s) {\n  # Convert the string to a vector of individual characters\n  chars <- strsplit(s, \"\")[[1]]\n  \n  # Initialize a logical vector to track seen characters (for 'a' to 'z')\n  char_seen <- logical(26)\n  \n  for (char in chars) {\n    # Calculate the index for the character (a=1, b=2, ..., z=26)\n    index <- utf8ToInt(char) - utf8ToInt('a') + 1\n    \n    if (char_seen[index]) {\n      return(FALSE)\n    }\n    char_seen[index] <- TRUE\n  }\n  \n  return(TRUE)\n}", "test_cases": "", "test_case_results": "Input: \"abcde\"\nResult: TRUE\n\nInput: \"hello\"\nResult: FALSE\n\nInput: \"world\"\nResult: TRUE\n\nInput: \"aabbcc\"\nResult: FALSE\n\nInput: \"\"\nResult: TRUE\n\nInput: \"a\"\nResult: TRUE", "task_id": 15794, "assertions": "test_unique_characters <- function() {\n    stopifnot(has_unique_characters(\"abcde\") == TRUE)\n    stopifnot(has_unique_characters(\"hello\") == FALSE)\n    stopifnot(has_unique_characters(\"world\") == TRUE)\n    stopifnot(has_unique_characters(\"aabbcc\") == FALSE)\n    stopifnot(has_unique_characters(\"\") == TRUE)\n    stopifnot(has_unique_characters(\"a\") == TRUE)\n}\n\ntest_unique_characters()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_unique_characters <- function() {\n    stopifnot(has_unique_characters(\"abcde\") == TRUE)\n    stopifnot(has_unique_characters(\"hello\") == FALSE)\n    stopifnot(has_unique_characters(\"world\") == TRUE)\n    stopifnot(has_unique_characters(\"aabbcc\") == FALSE)\n    stopifnot(has_unique_characters(\"\") == TRUE)\n    stopifnot(has_unique_characters(\"a\") == TRUE)\n}\n\ntest_unique_characters()", "output": "has_unique_characters"}, "all_code": "# has_unique_characters determines if a given string contains all unique characters.\n# It assumes the string contains only lowercase alphabetical characters.\n# The function uses a logical vector to track seen characters for efficiency.\n#\n# Parameters:\n#   s - Input string (character vector of length 1 in R)\n#\n# Returns:\n#   TRUE if all characters are unique, FALSE otherwise\nhas_unique_characters <- function(s) {\n  # Convert the string to a vector of individual characters\n  chars <- strsplit(s, \"\")[[1]]\n  \n  # Initialize a logical vector to track seen characters (for 'a' to 'z')\n  char_seen <- logical(26)\n  \n  for (char in chars) {\n    # Calculate the index for the character (a=1, b=2, ..., z=26)\n    index <- utf8ToInt(char) - utf8ToInt('a') + 1\n    \n    if (char_seen[index]) {\n      return(FALSE)\n    }\n    char_seen[index] <- TRUE\n  }\n  \n  return(TRUE)\n}\ntest_unique_characters <- function() {\n    stopifnot(has_unique_characters(\"abcde\") == TRUE)\n    stopifnot(has_unique_characters(\"hello\") == FALSE)\n    stopifnot(has_unique_characters(\"world\") == TRUE)\n    stopifnot(has_unique_characters(\"aabbcc\") == FALSE)\n    stopifnot(has_unique_characters(\"\") == TRUE)\n    stopifnot(has_unique_characters(\"a\") == TRUE)\n}\n\ntest_unique_characters()", "exec_outcome": "PASSED"}
{"code": "# count_distinct_elements calculates the number of distinct elements in specified subarrays of a given array.\n# \n# Parameters:\n#   N (int): The number of elements in the array (unused in the function but kept for consistency with the original).\n#   Q (int): The number of queries (unused in the function but kept for consistency with the original).\n#   array (vector): A numeric vector representing the array.\n#   queries (list of vectors): A list where each element is a vector of two integers (L, R) representing the query range.\n#\n# Returns:\n#   A numeric vector containing the count of distinct elements for each query.\ncount_distinct_elements <- function(N, Q, array, queries) {\n  result <- c()\n  for (query in queries) {\n    L <- query[1]\n    R <- query[2]\n    subarray <- array[L:R]\n    distinct_count <- length(unique(subarray))\n    result <- c(result, distinct_count)\n  }\n  return(result)\n}", "test_cases": "", "test_case_results": "Test Case 1:\nArray:  1 2 3 2 1 \nQueries: (1,3), (2,5)\nResult:  3 3 \n\nTest Case 2:\nArray:  1 1 1 1 \nQueries: (1,4), (2,3), (1,1)\nResult:  1 1 1 \n\nTest Case 3:\nArray:  1 2 3 4 5 6 \nQueries: (1,6)\nResult:  6", "task_id": 14844, "assertions": "test_count_distinct_elements <- function() {\n    # Test case 1\n    N1 <- 5\n    Q1 <- 2\n    array1 <- c(1, 2, 3, 2, 1)\n    queries1 <- list(c(1, 3), c(2, 5))\n    result1 <- count_distinct_elements(N1, Q1, array1, queries1)\n    stopifnot(identical(result1, c(3, 3)))\n    \n    # Test case 2\n    N2 <- 4\n    Q2 <- 3\n    array2 <- c(1, 1, 1, 1)\n    queries2 <- list(c(1, 4), c(2, 3), c(1, 1))\n    result2 <- count_distinct_elements(N2, Q2, array2, queries2)\n    stopifnot(identical(result2, c(1, 1, 1)))\n    \n    # Test case 3\n    N3 <- 6\n    Q3 <- 1\n    array3 <- c(1, 2, 3, 4, 5, 6)\n    queries3 <- list(c(1, 6))\n    result3 <- count_distinct_elements(N3, Q3, array3, queries3)\n    stopifnot(identical(result3, 6))\n}\n\ntest_count_distinct_elements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_count_distinct_elements <- function() {\n    # Test case 1\n    N1 <- 5\n    Q1 <- 2\n    array1 <- c(1, 2, 3, 2, 1)\n    queries1 <- list(c(1, 3), c(2, 5))\n    result1 <- count_distinct_elements(N1, Q1, array1, queries1)\n    stopifnot(identical(result1, c(3, 3)))\n    \n    # Test case 2\n    N2 <- 4\n    Q2 <- 3\n    array2 <- c(1, 1, 1, 1)\n    queries2 <- list(c(1, 4), c(2, 3), c(1, 1))\n    result2 <- count_distinct_elements(N2, Q2, array2, queries2)\n    stopifnot(identical(result2, c(1, 1, 1)))\n    \n    # Test case 3\n    N3 <- 6\n    Q3 <- 1\n    array3 <- c(1, 2, 3, 4, 5, 6)\n    queries3 <- list(c(1, 6))\n    result3 <- count_distinct_elements(N3, Q3, array3, queries3)\n    stopifnot(identical(result3, 6))\n}\n\ntest_count_distinct_elements()", "output": "count_distinct_elements"}, "all_code": "# count_distinct_elements calculates the number of distinct elements in specified subarrays of a given array.\n# \n# Parameters:\n#   N (int): The number of elements in the array (unused in the function but kept for consistency with the original).\n#   Q (int): The number of queries (unused in the function but kept for consistency with the original).\n#   array (vector): A numeric vector representing the array.\n#   queries (list of vectors): A list where each element is a vector of two integers (L, R) representing the query range.\n#\n# Returns:\n#   A numeric vector containing the count of distinct elements for each query.\ncount_distinct_elements <- function(N, Q, array, queries) {\n  result <- c()\n  for (query in queries) {\n    L <- query[1]\n    R <- query[2]\n    subarray <- array[L:R]\n    distinct_count <- length(unique(subarray))\n    result <- c(result, distinct_count)\n  }\n  return(result)\n}\ntest_count_distinct_elements <- function() {\n    # Test case 1\n    N1 <- 5\n    Q1 <- 2\n    array1 <- c(1, 2, 3, 2, 1)\n    queries1 <- list(c(1, 3), c(2, 5))\n    result1 <- count_distinct_elements(N1, Q1, array1, queries1)\n    stopifnot(identical(result1, c(3, 3)))\n    \n    # Test case 2\n    N2 <- 4\n    Q2 <- 3\n    array2 <- c(1, 1, 1, 1)\n    queries2 <- list(c(1, 4), c(2, 3), c(1, 1))\n    result2 <- count_distinct_elements(N2, Q2, array2, queries2)\n    stopifnot(identical(result2, c(1, 1, 1)))\n    \n    # Test case 3\n    N3 <- 6\n    Q3 <- 1\n    array3 <- c(1, 2, 3, 4, 5, 6)\n    queries3 <- list(c(1, 6))\n    result3 <- count_distinct_elements(N3, Q3, array3, queries3)\n    stopifnot(identical(result3, 6))\n}\n\ntest_count_distinct_elements()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# balance_bus_capacity calculates the minimum total capacity increase required for bus segments\n# to meet passenger loads and returns the new capacities for each segment.\n#\n# Parameters:\n#   n: Number of stops (integer)\n#   segments: List of tuples (ci, pi), where ci is the current capacity and pi is the passenger load for each segment\n#\n# Returns:\n#   A list containing the total capacity increase (numeric) and a vector of new capacities (numeric vector)\nbalance_bus_capacity <- function(n, segments) {\n    total_increase <- 0\n    new_capacities <- c()\n    \n    for (segment in segments) {\n        ci <- segment[1]\n        pi <- segment[2]\n        \n        if (ci < pi) {\n            increase <- pi - ci\n            total_increase <- total_increase + increase\n            new_capacities <- c(new_capacities, pi)\n        } else {\n            new_capacities <- c(new_capacities, ci)\n        }\n    }\n    \n    return(list(total_increase = total_increase, new_capacities = new_capacities))\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput - n: 3 segments: 50 30 60 40 70 35 \nTotal Increase: 0 \nNew Capacities: 50 60 70 \n\nTest Case 2:\nInput - n: 4 segments: 40 50 30 30 20 25 10 15 \nTotal Increase: 20 \nNew Capacities: 50 30 25 15 \n\nTest Case 3:\nInput - n: 2 segments: 10 20 15 30 \nTotal Increase: 25 \nNew Capacities: 20 30", "task_id": 20332, "assertions": "test.balance_bus_capacity <- function() {\n    # Test Case 1: All segments have sufficient capacity\n    result_1 <- balance_bus_capacity(3, list(c(50, 30), c(60, 40), c(70, 35)))\n    stopifnot(result_1$total_increase == 0)\n    stopifnot(all(result_1$new_capacities == c(50, 60, 70)))\n    \n    # Test Case 2: Some segments require capacity increase\n    result_2 <- balance_bus_capacity(4, list(c(40, 50), c(30, 30), c(20, 25), c(10, 15)))\n    stopifnot(result_2$total_increase == 20)\n    stopifnot(all(result_2$new_capacities == c(50, 30, 25, 15)))\n    \n    # Test Case 3: All segments require capacity increase\n    result_3 <- balance_bus_capacity(2, list(c(10, 20), c(15, 30)))\n    stopifnot(result_3$total_increase == 25)\n    stopifnot(all(result_3$new_capacities == c(20, 30)))\n}\n\ntest.balance_bus_capacity()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.balance_bus_capacity <- function() {\n    # Test Case 1: All segments have sufficient capacity\n    result_1 <- balance_bus_capacity(3, list(c(50, 30), c(60, 40), c(70, 35)))\n    stopifnot(result_1$total_increase == 0)\n    stopifnot(all(result_1$new_capacities == c(50, 60, 70)))\n    \n    # Test Case 2: Some segments require capacity increase\n    result_2 <- balance_bus_capacity(4, list(c(40, 50), c(30, 30), c(20, 25), c(10, 15)))\n    stopifnot(result_2$total_increase == 20)\n    stopifnot(all(result_2$new_capacities == c(50, 30, 25, 15)))\n    \n    # Test Case 3: All segments require capacity increase\n    result_3 <- balance_bus_capacity(2, list(c(10, 20), c(15, 30)))\n    stopifnot(result_3$total_increase == 25)\n    stopifnot(all(result_3$new_capacities == c(20, 30)))\n}\n\ntest.balance_bus_capacity()", "output": "balance_bus_capacity"}, "all_code": "# balance_bus_capacity calculates the minimum total capacity increase required for bus segments\n# to meet passenger loads and returns the new capacities for each segment.\n#\n# Parameters:\n#   n: Number of stops (integer)\n#   segments: List of tuples (ci, pi), where ci is the current capacity and pi is the passenger load for each segment\n#\n# Returns:\n#   A list containing the total capacity increase (numeric) and a vector of new capacities (numeric vector)\nbalance_bus_capacity <- function(n, segments) {\n    total_increase <- 0\n    new_capacities <- c()\n    \n    for (segment in segments) {\n        ci <- segment[1]\n        pi <- segment[2]\n        \n        if (ci < pi) {\n            increase <- pi - ci\n            total_increase <- total_increase + increase\n            new_capacities <- c(new_capacities, pi)\n        } else {\n            new_capacities <- c(new_capacities, ci)\n        }\n    }\n    \n    return(list(total_increase = total_increase, new_capacities = new_capacities))\n}\ntest.balance_bus_capacity <- function() {\n    # Test Case 1: All segments have sufficient capacity\n    result_1 <- balance_bus_capacity(3, list(c(50, 30), c(60, 40), c(70, 35)))\n    stopifnot(result_1$total_increase == 0)\n    stopifnot(all(result_1$new_capacities == c(50, 60, 70)))\n    \n    # Test Case 2: Some segments require capacity increase\n    result_2 <- balance_bus_capacity(4, list(c(40, 50), c(30, 30), c(20, 25), c(10, 15)))\n    stopifnot(result_2$total_increase == 20)\n    stopifnot(all(result_2$new_capacities == c(50, 30, 25, 15)))\n    \n    # Test Case 3: All segments require capacity increase\n    result_3 <- balance_bus_capacity(2, list(c(10, 20), c(15, 30)))\n    stopifnot(result_3$total_increase == 25)\n    stopifnot(all(result_3$new_capacities == c(20, 30)))\n}\n\ntest.balance_bus_capacity()", "exec_outcome": "PASSED"}
{"code": "# longest_subarray_with_sum finds the length of the longest subarray with a given sum.\n# It uses a hash map to store the first occurrence of each cumulative sum encountered.\n# This allows efficient checking for the presence of (cumulative_sum - target_sum) to determine subarrays that sum to the target.\n# \n# Parameters:\n# - arr: A numeric vector representing the input array of integers.\n# - target_sum: An integer representing the target sum for which the longest subarray's length is to be found.\n#\n# Returns:\n# - An integer representing the length of the longest subarray which adds up to `target_sum`.\nlongest_subarray_with_sum <- function(arr, target_sum) {\n    cumulative_sum <- 0\n    max_length <- 0\n    sum_to_index <- list()\n    sum_to_index[[\"0\"]] <- -1  # Initialize with cumulative sum 0 at index -1\n    \n    for (index in seq_along(arr)) {\n        value <- arr[index]\n        cumulative_sum <- cumulative_sum + value\n        \n        # If cumulative sum equals the target sum, update the max length\n        if (cumulative_sum == target_sum) {\n            max_length <- index\n        }\n        \n        # If (cumulative_sum - target_sum) exists in sum_to_index, update max length\n        key <- as.character(cumulative_sum - target_sum)\n        if (key %in% names(sum_to_index)) {\n            max_length <- max(max_length, index - sum_to_index[[key]])\n        }\n        \n        # Store the first occurrence of each cumulative sum\n        current_key <- as.character(cumulative_sum)\n        if (!(current_key %in% names(sum_to_index))) {\n            sum_to_index[[current_key]] <- index\n        }\n    }\n    \n    return(max_length)\n}", "test_cases": "", "test_case_results": "Input array:  1 2 3 4 \nTarget sum:  6 \nLength of longest subarray:  4 \n\nInput array:  5 6 7 0 \nTarget sum:  18 \nLength of longest subarray:  5 \n\nInput array:  0 0 0 0 \nTarget sum:  0 \nLength of longest subarray:  5 \n\nInput array:  1 -1 1 1 1 \nTarget sum:  2 \nLength of longest subarray:  5 \n\nInput array:  10 5 2 7 1 9 \nTarget sum:  15 \nLength of longest subarray:  4", "task_id": 24779, "assertions": "test_longest_subarray_with_sum <- function() {\n    stopifnot(longest_subarray_with_sum(c(1, 2, 3, 4), 6) == 4)\n    stopifnot(longest_subarray_with_sum(c(5, 6, 7, 0), 18) == 5)\n    stopifnot(longest_subarray_with_sum(c(0, 0, 0, 0), 0) == 5)\n    stopifnot(longest_subarray_with_sum(c(1, -1, 1, 1, 1), 2) == 5)\n    stopifnot(longest_subarray_with_sum(c(10, 5, 2, 7, 1, 9), 15) == 4)\n}\n\ntest_longest_subarray_with_sum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_longest_subarray_with_sum <- function() {\n    stopifnot(longest_subarray_with_sum(c(1, 2, 3, 4), 6) == 4)\n    stopifnot(longest_subarray_with_sum(c(5, 6, 7, 0), 18) == 5)\n    stopifnot(longest_subarray_with_sum(c(0, 0, 0, 0), 0) == 5)\n    stopifnot(longest_subarray_with_sum(c(1, -1, 1, 1, 1), 2) == 5)\n    stopifnot(longest_subarray_with_sum(c(10, 5, 2, 7, 1, 9), 15) == 4)\n}\n\ntest_longest_subarray_with_sum()", "output": "longest_subarray_with_sum"}, "all_code": "# longest_subarray_with_sum finds the length of the longest subarray with a given sum.\n# It uses a hash map to store the first occurrence of each cumulative sum encountered.\n# This allows efficient checking for the presence of (cumulative_sum - target_sum) to determine subarrays that sum to the target.\n# \n# Parameters:\n# - arr: A numeric vector representing the input array of integers.\n# - target_sum: An integer representing the target sum for which the longest subarray's length is to be found.\n#\n# Returns:\n# - An integer representing the length of the longest subarray which adds up to `target_sum`.\nlongest_subarray_with_sum <- function(arr, target_sum) {\n    cumulative_sum <- 0\n    max_length <- 0\n    sum_to_index <- list()\n    sum_to_index[[\"0\"]] <- -1  # Initialize with cumulative sum 0 at index -1\n    \n    for (index in seq_along(arr)) {\n        value <- arr[index]\n        cumulative_sum <- cumulative_sum + value\n        \n        # If cumulative sum equals the target sum, update the max length\n        if (cumulative_sum == target_sum) {\n            max_length <- index\n        }\n        \n        # If (cumulative_sum - target_sum) exists in sum_to_index, update max length\n        key <- as.character(cumulative_sum - target_sum)\n        if (key %in% names(sum_to_index)) {\n            max_length <- max(max_length, index - sum_to_index[[key]])\n        }\n        \n        # Store the first occurrence of each cumulative sum\n        current_key <- as.character(cumulative_sum)\n        if (!(current_key %in% names(sum_to_index))) {\n            sum_to_index[[current_key]] <- index\n        }\n    }\n    \n    return(max_length)\n}\ntest_longest_subarray_with_sum <- function() {\n    stopifnot(longest_subarray_with_sum(c(1, 2, 3, 4), 6) == 4)\n    stopifnot(longest_subarray_with_sum(c(5, 6, 7, 0), 18) == 5)\n    stopifnot(longest_subarray_with_sum(c(0, 0, 0, 0), 0) == 5)\n    stopifnot(longest_subarray_with_sum(c(1, -1, 1, 1, 1), 2) == 5)\n    stopifnot(longest_subarray_with_sum(c(10, 5, 2, 7, 1, 9), 15) == 4)\n}\n\ntest_longest_subarray_with_sum()", "exec_outcome": "PASSED"}
{"code": "# clean_string removes all non-alphabetic characters from a string and converts it to lowercase.\n# It uses regular expressions to perform the cleaning operation.\n# Parameters:\n#   input_string (character): The string to be cleaned.\n# Returns:\n#   character: The cleaned string in lowercase.\nclean_string <- function(input_string) {\n  # Remove all non-alphabetic characters using regular expression\n  cleaned_string <- gsub(\"[^a-zA-Z]\", \"\", input_string)\n  # Convert to lowercase\n  cleaned_string <- tolower(cleaned_string)\n  return(cleaned_string)\n}", "test_cases": "", "test_case_results": "Input: \"Hello, World! 123\"\nCleaned: \"helloworld\"\nInput: \"R-Programming_2023\"\nCleaned: \"rprogramming\"\nInput: \"NoNumbersOrSymbols\"\nCleaned: \"nonumbersorsymbols\"\nInput: \"!@#$%^&*()\"\nCleaned: \"\"\nInput: \"\"\nCleaned: \"\"", "task_id": 6183, "assertions": "test.clean_string <- function() {\n    stopifnot(clean_string(\"Hello, World! 123\") == \"helloworld\")\n    stopifnot(clean_string(\"R-Programming_2023\") == \"rprogramming\")\n    stopifnot(clean_string(\"NoNumbersOrSymbols\") == \"nonumbersorsymbols\")\n    stopifnot(clean_string(\"!@#$%^&*()\") == \"\")\n    stopifnot(clean_string(\"\") == \"\")\n}\n\ntest.clean_string()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.clean_string <- function() {\n    stopifnot(clean_string(\"Hello, World! 123\") == \"helloworld\")\n    stopifnot(clean_string(\"R-Programming_2023\") == \"rprogramming\")\n    stopifnot(clean_string(\"NoNumbersOrSymbols\") == \"nonumbersorsymbols\")\n    stopifnot(clean_string(\"!@#$%^&*()\") == \"\")\n    stopifnot(clean_string(\"\") == \"\")\n}\n\ntest.clean_string()", "output": "clean_string"}, "all_code": "# clean_string removes all non-alphabetic characters from a string and converts it to lowercase.\n# It uses regular expressions to perform the cleaning operation.\n# Parameters:\n#   input_string (character): The string to be cleaned.\n# Returns:\n#   character: The cleaned string in lowercase.\nclean_string <- function(input_string) {\n  # Remove all non-alphabetic characters using regular expression\n  cleaned_string <- gsub(\"[^a-zA-Z]\", \"\", input_string)\n  # Convert to lowercase\n  cleaned_string <- tolower(cleaned_string)\n  return(cleaned_string)\n}\ntest.clean_string <- function() {\n    stopifnot(clean_string(\"Hello, World! 123\") == \"helloworld\")\n    stopifnot(clean_string(\"R-Programming_2023\") == \"rprogramming\")\n    stopifnot(clean_string(\"NoNumbersOrSymbols\") == \"nonumbersorsymbols\")\n    stopifnot(clean_string(\"!@#$%^&*()\") == \"\")\n    stopifnot(clean_string(\"\") == \"\")\n}\n\ntest.clean_string()", "exec_outcome": "PASSED"}
{"code": "# find_special_triplets counts the number of special triplets in a numeric vector where:\n# a + b > c, b + c > a, and c + a > b (triangle inequality conditions).\n# The function first sorts the array and then uses a two-pointer approach to efficiently count valid triplets.\n# Input: arr - a numeric vector\n# Output: the count of valid triplets\nfind_special_triplets <- function(arr) {\n  n <- length(arr)\n  count <- 0\n  arr <- sort(arr)\n  \n  for (i in 1:(n - 2)) {\n    k <- i + 2\n    for (j in (i + 1):(n - 1)) {\n      while (k <= n && arr[i] + arr[j] > arr[k]) {\n        k <- k + 1\n      }\n      count <- count + k - j - 1\n    }\n  }\n  \n  return(count)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nCount of special triplets:  1 \nInput:  5 6 7 8 \nCount of special triplets:  4 \nInput:  1 1 1 1 \nCount of special triplets:  4 \nInput:  2 3 4 5 6 \nCount of special triplets:  7 \nInput:  10 20 30 40 50 \nCount of special triplets:  3", "task_id": 12078, "assertions": "test.special.triplets <- function() {\n  stopifnot(find_special_triplets(c(1, 2, 3, 4)) == 1)\n  stopifnot(find_special_triplets(c(5, 6, 7, 8)) == 4)\n  stopifnot(find_special_triplets(c(1, 1, 1, 1)) == 4)\n  stopifnot(find_special_triplets(c(2, 3, 4, 5, 6)) == 7)\n  stopifnot(find_special_triplets(c(10, 20, 30, 40, 50)) == 3)\n}\n\ntest.special.triplets()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.special.triplets <- function() {\n  stopifnot(find_special_triplets(c(1, 2, 3, 4)) == 1)\n  stopifnot(find_special_triplets(c(5, 6, 7, 8)) == 4)\n  stopifnot(find_special_triplets(c(1, 1, 1, 1)) == 4)\n  stopifnot(find_special_triplets(c(2, 3, 4, 5, 6)) == 7)\n  stopifnot(find_special_triplets(c(10, 20, 30, 40, 50)) == 3)\n}\n\ntest.special.triplets()", "output": "find_special_triplets"}, "all_code": "# find_special_triplets counts the number of special triplets in a numeric vector where:\n# a + b > c, b + c > a, and c + a > b (triangle inequality conditions).\n# The function first sorts the array and then uses a two-pointer approach to efficiently count valid triplets.\n# Input: arr - a numeric vector\n# Output: the count of valid triplets\nfind_special_triplets <- function(arr) {\n  n <- length(arr)\n  count <- 0\n  arr <- sort(arr)\n  \n  for (i in 1:(n - 2)) {\n    k <- i + 2\n    for (j in (i + 1):(n - 1)) {\n      while (k <= n && arr[i] + arr[j] > arr[k]) {\n        k <- k + 1\n      }\n      count <- count + k - j - 1\n    }\n  }\n  \n  return(count)\n}\ntest.special.triplets <- function() {\n  stopifnot(find_special_triplets(c(1, 2, 3, 4)) == 1)\n  stopifnot(find_special_triplets(c(5, 6, 7, 8)) == 4)\n  stopifnot(find_special_triplets(c(1, 1, 1, 1)) == 4)\n  stopifnot(find_special_triplets(c(2, 3, 4, 5, 6)) == 7)\n  stopifnot(find_special_triplets(c(10, 20, 30, 40, 50)) == 3)\n}\n\ntest.special.triplets()", "exec_outcome": "PASSED"}
{"code": "reverse_string <- function(s, method) {\n    if (method == 'recursive') {\n        return(reverse_recursive(s))\n    } else if (method == 'iterative') {\n        return(reverse_iterative(s))\n    } else if (method == 'pythonic') {\n        return(reverse_pythonic(s))\n    } else if (method == 'ultra_pythonic') {\n        return(reverse_ultra_pythonic(s))\n    } else {\n        stop(\"Invalid method.\")\n    }\n}\n\nreverse_recursive <- function(s) {\n    if (nchar(s) == 0) {\n        return(s)\n    } else {\n        return(paste0(substr(s, nchar(s), nchar(s)), reverse_recursive(substr(s, 1, nchar(s) - 1))))\n    }\n}\n\nreverse_iterative <- function(s) {\n    result <- \"\"\n    for (i in 1:nchar(s)) {\n        result <- paste0(substr(s, i, i), result)\n    }\n    return(result)\n}\n\nreverse_pythonic <- function(s) {\n    chars <- strsplit(s, NULL)[[1]]\n    reversed_chars <- rev(chars)\n    return(paste0(reversed_chars, collapse = \"\"))\n}\n\nreverse_ultra_pythonic <- function(s) {\n    chars <- strsplit(s, NULL)[[1]]\n    reversed_chars <- chars[length(chars):1]\n    return(paste0(reversed_chars, collapse = \"\"))\n}", "test_cases": "", "test_case_results": "Input: 'hello', Method: 'recursive'\nReversed: 'olleh'\nInput: 'hello', Method: 'iterative'\nReversed: 'olleh'\nInput: 'hello', Method: 'pythonic'\nReversed: 'olleh'\nInput: 'hello', Method: 'ultra_pythonic'\nReversed: 'olleh'\nInput: 'R is great', Method: 'recursive'\nReversed: 'taerg si R'\nInput: 'R is great', Method: 'iterative'\nReversed: 'taerg si R'\nInput: 'R is great', Method: 'pythonic'\nReversed: 'taerg si R'\nInput: 'R is great', Method: 'ultra_pythonic'\nReversed: 'taerg si R'\nInput: '', Method: 'recursive'\nReversed: ''\nInput: '', Method: 'iterative'\nReversed: ''\nInput: '', Method: 'pythonic'\nReversed: ''\nInput: '', Method: 'ultra_pythonic'\nReversed: 'NA'", "task_id": 21922, "assertions": "test_reverse_string <- function() {\n    # Test cases for 'hello'\n    stopifnot(reverse_string(\"hello\", \"recursive\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"iterative\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"pythonic\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"ultra_pythonic\") == \"olleh\")\n    \n    # Test cases for 'R is great'\n    stopifnot(reverse_string(\"R is great\", \"recursive\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"iterative\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"pythonic\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"ultra_pythonic\") == \"taerg si R\")\n    \n    # Test cases for empty string\n    stopifnot(reverse_string(\"\", \"recursive\") == \"\")\n    stopifnot(reverse_string(\"\", \"iterative\") == \"\")\n    stopifnot(reverse_string(\"\", \"pythonic\") == \"\")\n    stopifnot(reverse_string(\"\", \"ultra_pythonic\") == \"\")\n}\n\ntest_reverse_string()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_reverse_string <- function() {\n    # Test cases for 'hello'\n    stopifnot(reverse_string(\"hello\", \"recursive\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"iterative\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"pythonic\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"ultra_pythonic\") == \"olleh\")\n    \n    # Test cases for 'R is great'\n    stopifnot(reverse_string(\"R is great\", \"recursive\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"iterative\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"pythonic\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"ultra_pythonic\") == \"taerg si R\")\n    \n    # Test cases for empty string\n    stopifnot(reverse_string(\"\", \"recursive\") == \"\")\n    stopifnot(reverse_string(\"\", \"iterative\") == \"\")\n    stopifnot(reverse_string(\"\", \"pythonic\") == \"\")\n    stopifnot(reverse_string(\"\", \"ultra_pythonic\") == \"\")\n}\n\ntest_reverse_string()", "output": "reverse_string"}, "all_code": "reverse_string <- function(s, method) {\n    if (method == 'recursive') {\n        return(reverse_recursive(s))\n    } else if (method == 'iterative') {\n        return(reverse_iterative(s))\n    } else if (method == 'pythonic') {\n        return(reverse_pythonic(s))\n    } else if (method == 'ultra_pythonic') {\n        return(reverse_ultra_pythonic(s))\n    } else {\n        stop(\"Invalid method.\")\n    }\n}\n\nreverse_recursive <- function(s) {\n    if (nchar(s) == 0) {\n        return(s)\n    } else {\n        return(paste0(substr(s, nchar(s), nchar(s)), reverse_recursive(substr(s, 1, nchar(s) - 1))))\n    }\n}\n\nreverse_iterative <- function(s) {\n    result <- \"\"\n    for (i in 1:nchar(s)) {\n        result <- paste0(substr(s, i, i), result)\n    }\n    return(result)\n}\n\nreverse_pythonic <- function(s) {\n    chars <- strsplit(s, NULL)[[1]]\n    reversed_chars <- rev(chars)\n    return(paste0(reversed_chars, collapse = \"\"))\n}\n\nreverse_ultra_pythonic <- function(s) {\n    chars <- strsplit(s, NULL)[[1]]\n    reversed_chars <- chars[length(chars):1]\n    return(paste0(reversed_chars, collapse = \"\"))\n}\ntest_reverse_string <- function() {\n    # Test cases for 'hello'\n    stopifnot(reverse_string(\"hello\", \"recursive\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"iterative\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"pythonic\") == \"olleh\")\n    stopifnot(reverse_string(\"hello\", \"ultra_pythonic\") == \"olleh\")\n    \n    # Test cases for 'R is great'\n    stopifnot(reverse_string(\"R is great\", \"recursive\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"iterative\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"pythonic\") == \"taerg si R\")\n    stopifnot(reverse_string(\"R is great\", \"ultra_pythonic\") == \"taerg si R\")\n    \n    # Test cases for empty string\n    stopifnot(reverse_string(\"\", \"recursive\") == \"\")\n    stopifnot(reverse_string(\"\", \"iterative\") == \"\")\n    stopifnot(reverse_string(\"\", \"pythonic\") == \"\")\n    stopifnot(reverse_string(\"\", \"ultra_pythonic\") == \"\")\n}\n\ntest_reverse_string()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "buddy_strings <- function(s, goal) {\n  if (nchar(s) != nchar(goal)) {\n    return(FALSE)\n  }\n  \n  if (s == goal) {\n    chars <- strsplit(s, \"\")[[1]]\n    return(length(unique(chars)) < length(chars))\n  }\n  \n  pairs <- list()\n  s_chars <- strsplit(s, \"\")[[1]]\n  goal_chars <- strsplit(goal, \"\")[[1]]\n  \n  for (i in 1:length(s_chars)) {\n    if (s_chars[i] != goal_chars[i]) {\n      pairs <- c(pairs, list(c(s_chars[i], goal_chars[i])))\n      if (length(pairs) > 2) {\n        return(FALSE)\n      }\n    }\n  }\n  \n  return(length(pairs) == 2 && identical(pairs[[1]], rev(pairs[[2]])))\n}", "test_cases": "", "test_case_results": "Input: s = 'ab', goal = 'ba'\nResult: TRUE\nInput: s = 'ab', goal = 'ab'\nResult: FALSE\nInput: s = 'aa', goal = 'aa'\nResult: TRUE\nInput: s = 'aaaaaaabc', goal = 'aaaaaaacb'\nResult: TRUE\nInput: s = 'abcd', goal = 'badc'\nResult: FALSE\nInput: s = 'abcd', goal = 'abcd'\nResult: FALSE\nInput: s = 'ab', goal = 'ca'\nResult: FALSE", "task_id": 27724, "assertions": "test.buddy_strings <- function() {\n    stopifnot(buddy_strings(\"ab\", \"ba\") == TRUE)\n    stopifnot(buddy_strings(\"ab\", \"ab\") == FALSE)\n    stopifnot(buddy_strings(\"aa\", \"aa\") == TRUE)\n    stopifnot(buddy_strings(\"aaaaaaabc\", \"aaaaaaacb\") == TRUE)\n    stopifnot(buddy_strings(\"abcd\", \"badc\") == FALSE)\n    stopifnot(buddy_strings(\"abcd\", \"abcd\") == FALSE)\n    stopifnot(buddy_strings(\"ab\", \"ca\") == FALSE)\n}\n\ntest.buddy_strings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.buddy_strings <- function() {\n    stopifnot(buddy_strings(\"ab\", \"ba\") == TRUE)\n    stopifnot(buddy_strings(\"ab\", \"ab\") == FALSE)\n    stopifnot(buddy_strings(\"aa\", \"aa\") == TRUE)\n    stopifnot(buddy_strings(\"aaaaaaabc\", \"aaaaaaacb\") == TRUE)\n    stopifnot(buddy_strings(\"abcd\", \"badc\") == FALSE)\n    stopifnot(buddy_strings(\"abcd\", \"abcd\") == FALSE)\n    stopifnot(buddy_strings(\"ab\", \"ca\") == FALSE)\n}\n\ntest.buddy_strings()", "output": "buddy_strings"}, "all_code": "buddy_strings <- function(s, goal) {\n  if (nchar(s) != nchar(goal)) {\n    return(FALSE)\n  }\n  \n  if (s == goal) {\n    chars <- strsplit(s, \"\")[[1]]\n    return(length(unique(chars)) < length(chars))\n  }\n  \n  pairs <- list()\n  s_chars <- strsplit(s, \"\")[[1]]\n  goal_chars <- strsplit(goal, \"\")[[1]]\n  \n  for (i in 1:length(s_chars)) {\n    if (s_chars[i] != goal_chars[i]) {\n      pairs <- c(pairs, list(c(s_chars[i], goal_chars[i])))\n      if (length(pairs) > 2) {\n        return(FALSE)\n      }\n    }\n  }\n  \n  return(length(pairs) == 2 && identical(pairs[[1]], rev(pairs[[2]])))\n}\ntest.buddy_strings <- function() {\n    stopifnot(buddy_strings(\"ab\", \"ba\") == TRUE)\n    stopifnot(buddy_strings(\"ab\", \"ab\") == FALSE)\n    stopifnot(buddy_strings(\"aa\", \"aa\") == TRUE)\n    stopifnot(buddy_strings(\"aaaaaaabc\", \"aaaaaaacb\") == TRUE)\n    stopifnot(buddy_strings(\"abcd\", \"badc\") == FALSE)\n    stopifnot(buddy_strings(\"abcd\", \"abcd\") == FALSE)\n    stopifnot(buddy_strings(\"ab\", \"ca\") == FALSE)\n}\n\ntest.buddy_strings()", "exec_outcome": "PASSED"}
{"code": "# count_similar_pairs calculates the number of similar pairs of binary strings in a list.\n# Two binary strings are considered similar if they differ by exactly one position.\n# The function uses nested loops to compare each pair of strings and counts the similar pairs.\ncount_similar_pairs <- function(binary_strings) {\n  # is_similar checks if two binary strings differ by exactly one position.\n  # It takes two binary strings as input and returns TRUE if they are similar, FALSE otherwise.\n  is_similar <- function(s, t) {\n    # Convert strings to vectors of characters for comparison\n    s_chars <- strsplit(s, \"\")[[1]]\n    t_chars <- strsplit(t, \"\")[[1]]\n    # Count the number of differing positions\n    difference_count <- sum(s_chars != t_chars)\n    return(difference_count == 1)\n  }\n  \n  count <- 0\n  n <- length(binary_strings)\n  \n  # Compare each pair of strings\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      if (is_similar(binary_strings[i], binary_strings[j])) {\n        count <- count + 1\n      }\n    }\n  }\n  \n  return(count)\n}", "test_cases": "", "test_case_results": "Input:  000, 001, 010, 100 \nNumber of similar pairs:  3 \nInput:  00, 01, 10, 11 \nNumber of similar pairs:  4 \nInput:  000, 111, 010, 101 \nNumber of similar pairs:  2 \nInput:  0, 1 \nNumber of similar pairs:  1 \nInput:  00, 00 \nNumber of similar pairs:  0", "task_id": 2272, "assertions": "test_similar_pairs <- function() {\n  test_cases <- list(\n    list(input = c(\"000\", \"001\", \"010\", \"100\"), expected = 3),\n    list(input = c(\"00\", \"01\", \"10\", \"11\"), expected = 4),\n    list(input = c(\"000\", \"111\", \"010\", \"101\"), expected = 2),\n    list(input = c(\"0\", \"1\"), expected = 1),\n    list(input = c(\"00\", \"00\"), expected = 0)\n  )\n  \n  for (test_case in test_cases) {\n    result <- count_similar_pairs(test_case$input)\n    stopifnot(result == test_case$expected)\n  }\n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_similar_pairs()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_similar_pairs <- function() {\n  test_cases <- list(\n    list(input = c(\"000\", \"001\", \"010\", \"100\"), expected = 3),\n    list(input = c(\"00\", \"01\", \"10\", \"11\"), expected = 4),\n    list(input = c(\"000\", \"111\", \"010\", \"101\"), expected = 2),\n    list(input = c(\"0\", \"1\"), expected = 1),\n    list(input = c(\"00\", \"00\"), expected = 0)\n  )\n  \n  for (test_case in test_cases) {\n    result <- count_similar_pairs(test_case$input)\n    stopifnot(result == test_case$expected)\n  }\n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_similar_pairs()", "output": "count_similar_pairs"}, "all_code": "# count_similar_pairs calculates the number of similar pairs of binary strings in a list.\n# Two binary strings are considered similar if they differ by exactly one position.\n# The function uses nested loops to compare each pair of strings and counts the similar pairs.\ncount_similar_pairs <- function(binary_strings) {\n  # is_similar checks if two binary strings differ by exactly one position.\n  # It takes two binary strings as input and returns TRUE if they are similar, FALSE otherwise.\n  is_similar <- function(s, t) {\n    # Convert strings to vectors of characters for comparison\n    s_chars <- strsplit(s, \"\")[[1]]\n    t_chars <- strsplit(t, \"\")[[1]]\n    # Count the number of differing positions\n    difference_count <- sum(s_chars != t_chars)\n    return(difference_count == 1)\n  }\n  \n  count <- 0\n  n <- length(binary_strings)\n  \n  # Compare each pair of strings\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      if (is_similar(binary_strings[i], binary_strings[j])) {\n        count <- count + 1\n      }\n    }\n  }\n  \n  return(count)\n}\ntest_similar_pairs <- function() {\n  test_cases <- list(\n    list(input = c(\"000\", \"001\", \"010\", \"100\"), expected = 3),\n    list(input = c(\"00\", \"01\", \"10\", \"11\"), expected = 4),\n    list(input = c(\"000\", \"111\", \"010\", \"101\"), expected = 2),\n    list(input = c(\"0\", \"1\"), expected = 1),\n    list(input = c(\"00\", \"00\"), expected = 0)\n  )\n  \n  for (test_case in test_cases) {\n    result <- count_similar_pairs(test_case$input)\n    stopifnot(result == test_case$expected)\n  }\n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_similar_pairs()", "exec_outcome": "PASSED"}
{"code": "shortest_nice_subarray <- function(nums, k) {\n    n <- length(nums)\n    left <- 1  # R uses 1-based indexing\n    count <- list()\n    distinct_count <- 0\n    min_len <- n + 1  # Initialize with a value larger than any possible subarray length\n\n    for (right in 1:n) {\n        num <- nums[right]\n        if (is.null(count[[as.character(num)]])) {\n            count[[as.character(num)]] <- 0\n        }\n        if (count[[as.character(num)]] == 0) {\n            distinct_count <- distinct_count + 1\n        }\n        count[[as.character(num)]] <- count[[as.character(num)]] + 1\n\n        while (distinct_count == k) {\n            current_len <- right - left + 1\n            if (current_len < min_len) {\n                min_len <- current_len\n            }\n            left_num <- nums[left]\n            count[[as.character(left_num)]] <- count[[as.character(left_num)]] - 1\n            if (count[[as.character(left_num)]] == 0) {\n                distinct_count <- distinct_count - 1\n            }\n            left <- left + 1\n        }\n    }\n\n    if (min_len <= n) {\n        return(min_len)\n    } else {\n        return(-1)\n    }\n}", "test_cases": "", "test_case_results": "Input nums:  1 2 2 1 3 , k:  2 \nShortest nice subarray length:  2 \nInput nums:  1 2 2 1 3 , k:  3 \nShortest nice subarray length:  3 \nInput nums:  1 1 1 1 1 , k:  1 \nShortest nice subarray length:  1 \nInput nums:  1 2 3 4 5 , k:  5 \nShortest nice subarray length:  5 \nInput nums:  1 2 3 4 5 , k:  6 \nShortest nice subarray length:  -1", "task_id": 7999, "assertions": "test_shortest_nice_subarray <- function() {\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 2) == 2)\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 3) == 3)\n    stopifnot(shortest_nice_subarray(c(1, 1, 1, 1, 1), 1) == 1)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 5) == 5)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 6) == -1)\n}\n\ntest_shortest_nice_subarray()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_shortest_nice_subarray <- function() {\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 2) == 2)\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 3) == 3)\n    stopifnot(shortest_nice_subarray(c(1, 1, 1, 1, 1), 1) == 1)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 5) == 5)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 6) == -1)\n}\n\ntest_shortest_nice_subarray()", "output": "shortest_nice_subarray"}, "all_code": "shortest_nice_subarray <- function(nums, k) {\n    n <- length(nums)\n    left <- 1  # R uses 1-based indexing\n    count <- list()\n    distinct_count <- 0\n    min_len <- n + 1  # Initialize with a value larger than any possible subarray length\n\n    for (right in 1:n) {\n        num <- nums[right]\n        if (is.null(count[[as.character(num)]])) {\n            count[[as.character(num)]] <- 0\n        }\n        if (count[[as.character(num)]] == 0) {\n            distinct_count <- distinct_count + 1\n        }\n        count[[as.character(num)]] <- count[[as.character(num)]] + 1\n\n        while (distinct_count == k) {\n            current_len <- right - left + 1\n            if (current_len < min_len) {\n                min_len <- current_len\n            }\n            left_num <- nums[left]\n            count[[as.character(left_num)]] <- count[[as.character(left_num)]] - 1\n            if (count[[as.character(left_num)]] == 0) {\n                distinct_count <- distinct_count - 1\n            }\n            left <- left + 1\n        }\n    }\n\n    if (min_len <= n) {\n        return(min_len)\n    } else {\n        return(-1)\n    }\n}\ntest_shortest_nice_subarray <- function() {\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 2) == 2)\n    stopifnot(shortest_nice_subarray(c(1, 2, 2, 1, 3), 3) == 3)\n    stopifnot(shortest_nice_subarray(c(1, 1, 1, 1, 1), 1) == 1)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 5) == 5)\n    stopifnot(shortest_nice_subarray(c(1, 2, 3, 4, 5), 6) == -1)\n}\n\ntest_shortest_nice_subarray()", "exec_outcome": "PASSED"}
{"code": "min_partition_sum <- function(arr, n) {\n  is_valid_partition <- function(max_sum) {\n    current_sum <- 0\n    partitions <- 1\n    for (num in arr) {\n      if (current_sum + num > max_sum) {\n        partitions <- partitions + 1\n        current_sum <- num\n        if (partitions > n) {\n          return(FALSE)\n        }\n      } else {\n        current_sum <- current_sum + num\n      }\n    }\n    return(TRUE)\n  }\n\n  left <- max(arr)\n  right <- sum(arr)\n  result <- right\n\n  while (left <= right) {\n    mid <- floor((left + right) / 2)\n    if (is_valid_partition(mid)) {\n      result <- mid\n      right <- mid - 1\n    } else {\n      left <- mid + 1\n    }\n  }\n\n  return(result)\n}", "test_cases": "", "test_case_results": "Input array:  1 2 3 4 , n:  2 \nMinimal maximum sum:  6 \nInput array:  5 6 7 0 , n:  3 \nMinimal maximum sum:  7 \nInput array:  0 0 0 0 , n:  1 \nMinimal maximum sum:  0 \nInput array:  10 20 30 40 , n:  5 \nMinimal maximum sum:  40", "task_id": 14040, "assertions": "test_min_partition_sum <- function() {\n  stopifnot(min_partition_sum(c(1, 2, 3, 4), 2) == 6)\n  stopifnot(min_partition_sum(c(5, 6, 7, 0), 3) == 7)\n  stopifnot(min_partition_sum(c(0, 0, 0, 0), 1) == 0)\n  stopifnot(min_partition_sum(c(10, 20, 30, 40), 5) == 40)\n}\n\ntest_min_partition_sum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_partition_sum <- function() {\n  stopifnot(min_partition_sum(c(1, 2, 3, 4), 2) == 6)\n  stopifnot(min_partition_sum(c(5, 6, 7, 0), 3) == 7)\n  stopifnot(min_partition_sum(c(0, 0, 0, 0), 1) == 0)\n  stopifnot(min_partition_sum(c(10, 20, 30, 40), 5) == 40)\n}\n\ntest_min_partition_sum()", "output": "min_partition_sum"}, "all_code": "min_partition_sum <- function(arr, n) {\n  is_valid_partition <- function(max_sum) {\n    current_sum <- 0\n    partitions <- 1\n    for (num in arr) {\n      if (current_sum + num > max_sum) {\n        partitions <- partitions + 1\n        current_sum <- num\n        if (partitions > n) {\n          return(FALSE)\n        }\n      } else {\n        current_sum <- current_sum + num\n      }\n    }\n    return(TRUE)\n  }\n\n  left <- max(arr)\n  right <- sum(arr)\n  result <- right\n\n  while (left <= right) {\n    mid <- floor((left + right) / 2)\n    if (is_valid_partition(mid)) {\n      result <- mid\n      right <- mid - 1\n    } else {\n      left <- mid + 1\n    }\n  }\n\n  return(result)\n}\ntest_min_partition_sum <- function() {\n  stopifnot(min_partition_sum(c(1, 2, 3, 4), 2) == 6)\n  stopifnot(min_partition_sum(c(5, 6, 7, 0), 3) == 7)\n  stopifnot(min_partition_sum(c(0, 0, 0, 0), 1) == 0)\n  stopifnot(min_partition_sum(c(10, 20, 30, 40), 5) == 40)\n}\n\ntest_min_partition_sum()", "exec_outcome": "PASSED"}
{"code": "# max_money_two_dishes calculates the maximum amount of money that can be spent on two dishes\n# without exceeding the budget 'm'. The function takes the number of dishes 'n', the budget 'm',\n# and a vector of dish prices. It sorts the prices and uses a two-pointer technique to find\n# the maximum sum of two prices that is less than or equal to 'm'.\n# If no such pair is found, it returns -1.\nmax_money_two_dishes <- function(n, m, prices) {\n  prices <- sort(prices)\n  left <- 1\n  right <- n\n  max_spent <- -1\n  \n  while (left < right) {\n    total <- prices[left] + prices[right]\n    if (total > m) {\n      right <- right - 1\n    } else {\n      max_spent <- max(max_spent, total)\n      left <- left + 1\n    }\n  }\n  \n  return(max_spent)\n}", "test_cases": "", "test_case_results": "Input: n = 4 , m = 10 , prices = 3 5 2 8 \nMax spent: 10 \nInput: n = 5 , m = 15 , prices = 1 12 5 7 3 \nMax spent: 15 \nInput: n = 3 , m = 5 , prices = 4 6 8 \nMax spent: -1 \nInput: n = 2 , m = 3 , prices = 1 2 \nMax spent: 3", "task_id": 1461, "assertions": "test_max_money_two_dishes <- function() {\n  stopifnot(max_money_two_dishes(4, 10, c(3, 5, 2, 8)) == 10)\n  stopifnot(max_money_two_dishes(5, 15, c(1, 12, 5, 7, 3)) == 15)\n  stopifnot(max_money_two_dishes(3, 5, c(4, 6, 8)) == -1)\n  stopifnot(max_money_two_dishes(2, 3, c(1, 2)) == 3)\n}\n\ntest_max_money_two_dishes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_money_two_dishes <- function() {\n  stopifnot(max_money_two_dishes(4, 10, c(3, 5, 2, 8)) == 10)\n  stopifnot(max_money_two_dishes(5, 15, c(1, 12, 5, 7, 3)) == 15)\n  stopifnot(max_money_two_dishes(3, 5, c(4, 6, 8)) == -1)\n  stopifnot(max_money_two_dishes(2, 3, c(1, 2)) == 3)\n}\n\ntest_max_money_two_dishes()", "output": "max_money_two_dishes"}, "all_code": "# max_money_two_dishes calculates the maximum amount of money that can be spent on two dishes\n# without exceeding the budget 'm'. The function takes the number of dishes 'n', the budget 'm',\n# and a vector of dish prices. It sorts the prices and uses a two-pointer technique to find\n# the maximum sum of two prices that is less than or equal to 'm'.\n# If no such pair is found, it returns -1.\nmax_money_two_dishes <- function(n, m, prices) {\n  prices <- sort(prices)\n  left <- 1\n  right <- n\n  max_spent <- -1\n  \n  while (left < right) {\n    total <- prices[left] + prices[right]\n    if (total > m) {\n      right <- right - 1\n    } else {\n      max_spent <- max(max_spent, total)\n      left <- left + 1\n    }\n  }\n  \n  return(max_spent)\n}\ntest_max_money_two_dishes <- function() {\n  stopifnot(max_money_two_dishes(4, 10, c(3, 5, 2, 8)) == 10)\n  stopifnot(max_money_two_dishes(5, 15, c(1, 12, 5, 7, 3)) == 15)\n  stopifnot(max_money_two_dishes(3, 5, c(4, 6, 8)) == -1)\n  stopifnot(max_money_two_dishes(2, 3, c(1, 2)) == 3)\n}\n\ntest_max_money_two_dishes()", "exec_outcome": "PASSED"}
{"code": "# has_subarray_with_sum determines if there is a contiguous subarray within `arr` that sums up to `target`.\n# It uses a set to keep track of prefix sums encountered so far to efficiently check for the target sum.\n# \n# Parameters:\n#   arr (numeric vector): The vector of integers.\n#   target (numeric): The target sum.\n#\n# Returns:\n#   logical: TRUE if such a subarray exists, FALSE otherwise.\nhas_subarray_with_sum <- function(arr, target) {\n  curr_sum <- 0\n  prefix_sums <- new.env(hash = TRUE, size = length(arr))  # Using an environment as a set\n  \n  for (num in arr) {\n    curr_sum <- curr_sum + num\n    if (curr_sum == target || exists(as.character(curr_sum - target), prefix_sums)) {\n      return(TRUE)\n    }\n    prefix_sums[[as.character(curr_sum)]] <- TRUE\n  }\n  \n  return(FALSE)\n}", "test_cases": "", "test_case_results": "Input array:  1 2 3 4 , Target:  6 \nResult:  TRUE \n\nInput array:  1 2 3 4 , Target:  10 \nResult:  TRUE \n\nInput array:  1 -1 1 -1 , Target:  0 \nResult:  TRUE \n\nInput array:  1 2 3 4 , Target:  7 \nResult:  TRUE \n\nInput array:  1 2 3 4 , Target:  11 \nResult:  FALSE", "task_id": 15906, "assertions": "test_subarray_sum <- function() {\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 6) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 10) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, -1, 1, -1), 0) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 7) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 11) == FALSE)\n}\n\ntest_subarray_sum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_subarray_sum <- function() {\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 6) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 10) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, -1, 1, -1), 0) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 7) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 11) == FALSE)\n}\n\ntest_subarray_sum()", "output": "has_subarray_with_sum"}, "all_code": "# has_subarray_with_sum determines if there is a contiguous subarray within `arr` that sums up to `target`.\n# It uses a set to keep track of prefix sums encountered so far to efficiently check for the target sum.\n# \n# Parameters:\n#   arr (numeric vector): The vector of integers.\n#   target (numeric): The target sum.\n#\n# Returns:\n#   logical: TRUE if such a subarray exists, FALSE otherwise.\nhas_subarray_with_sum <- function(arr, target) {\n  curr_sum <- 0\n  prefix_sums <- new.env(hash = TRUE, size = length(arr))  # Using an environment as a set\n  \n  for (num in arr) {\n    curr_sum <- curr_sum + num\n    if (curr_sum == target || exists(as.character(curr_sum - target), prefix_sums)) {\n      return(TRUE)\n    }\n    prefix_sums[[as.character(curr_sum)]] <- TRUE\n  }\n  \n  return(FALSE)\n}\ntest_subarray_sum <- function() {\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 6) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 10) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, -1, 1, -1), 0) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 7) == TRUE)\n    stopifnot(has_subarray_with_sum(c(1, 2, 3, 4), 11) == FALSE)\n}\n\ntest_subarray_sum()", "exec_outcome": "PASSED"}
{"code": "# calculate_histogram computes the histogram of pixel intensities for a given grayscale image.\n# The function takes a 2D matrix (list of lists) where each element is an integer between 0 and 255.\n# It returns a vector of 256 integers representing the count of each pixel intensity.\ncalculate_histogram <- function(image) {\n    histogram <- rep(0, 256)\n    \n    for (row in image) {\n        for (pixel in row) {\n            # Increment the count for the current pixel intensity\n            histogram[pixel + 1] <- histogram[pixel + 1] + 1  # R uses 1-based indexing\n        }\n    }\n    \n    return(histogram)\n}", "test_cases": "", "test_case_results": "Input:\n0 255 \n128 64 \nHistogram (indices 0-255):\n1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \nInput:\n10 10 \n10 10 \nHistogram (indices 0-255):\n0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \nInput:\n \n \nHistogram (indices 0-255):\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \nInput:\n0 1 2 3 \n255 254 253 252 \n100 101 102 103 \nHistogram (indices 0-255):\n1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0", "task_id": 627, "assertions": "test_histogram <- function() {\n    # Test case 1: Simple 2x2 image\n    test_case1 <- list(\n        c(0, 255),\n        c(128, 64)\n    )\n    expected1 <- rep(0, 256)\n    expected1[c(1, 65, 129, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case1), expected1))\n    \n    # Test case 2: Uniform image\n    test_case2 <- list(\n        c(10, 10),\n        c(10, 10)\n    )\n    expected2 <- rep(0, 256)\n    expected2[11] <- 4\n    stopifnot(identical(calculate_histogram(test_case2), expected2))\n    \n    # Test case 3: Empty image (edge case)\n    test_case3 <- list(\n        c(),\n        c()\n    )\n    expected3 <- rep(0, 256)\n    stopifnot(identical(calculate_histogram(test_case3), expected3))\n    \n    # Test case 4: Larger image with varied intensities\n    test_case4 <- list(\n        c(0, 1, 2, 3),\n        c(255, 254, 253, 252),\n        c(100, 101, 102, 103)\n    )\n    expected4 <- rep(0, 256)\n    expected4[c(1, 2, 3, 4, 101, 102, 103, 104, 253, 254, 255, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case4), expected4))\n    \n    cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_histogram()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_histogram <- function() {\n    # Test case 1: Simple 2x2 image\n    test_case1 <- list(\n        c(0, 255),\n        c(128, 64)\n    )\n    expected1 <- rep(0, 256)\n    expected1[c(1, 65, 129, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case1), expected1))\n    \n    # Test case 2: Uniform image\n    test_case2 <- list(\n        c(10, 10),\n        c(10, 10)\n    )\n    expected2 <- rep(0, 256)\n    expected2[11] <- 4\n    stopifnot(identical(calculate_histogram(test_case2), expected2))\n    \n    # Test case 3: Empty image (edge case)\n    test_case3 <- list(\n        c(),\n        c()\n    )\n    expected3 <- rep(0, 256)\n    stopifnot(identical(calculate_histogram(test_case3), expected3))\n    \n    # Test case 4: Larger image with varied intensities\n    test_case4 <- list(\n        c(0, 1, 2, 3),\n        c(255, 254, 253, 252),\n        c(100, 101, 102, 103)\n    )\n    expected4 <- rep(0, 256)\n    expected4[c(1, 2, 3, 4, 101, 102, 103, 104, 253, 254, 255, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case4), expected4))\n    \n    cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_histogram()", "output": "calculate_histogram"}, "all_code": "# calculate_histogram computes the histogram of pixel intensities for a given grayscale image.\n# The function takes a 2D matrix (list of lists) where each element is an integer between 0 and 255.\n# It returns a vector of 256 integers representing the count of each pixel intensity.\ncalculate_histogram <- function(image) {\n    histogram <- rep(0, 256)\n    \n    for (row in image) {\n        for (pixel in row) {\n            # Increment the count for the current pixel intensity\n            histogram[pixel + 1] <- histogram[pixel + 1] + 1  # R uses 1-based indexing\n        }\n    }\n    \n    return(histogram)\n}\ntest_histogram <- function() {\n    # Test case 1: Simple 2x2 image\n    test_case1 <- list(\n        c(0, 255),\n        c(128, 64)\n    )\n    expected1 <- rep(0, 256)\n    expected1[c(1, 65, 129, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case1), expected1))\n    \n    # Test case 2: Uniform image\n    test_case2 <- list(\n        c(10, 10),\n        c(10, 10)\n    )\n    expected2 <- rep(0, 256)\n    expected2[11] <- 4\n    stopifnot(identical(calculate_histogram(test_case2), expected2))\n    \n    # Test case 3: Empty image (edge case)\n    test_case3 <- list(\n        c(),\n        c()\n    )\n    expected3 <- rep(0, 256)\n    stopifnot(identical(calculate_histogram(test_case3), expected3))\n    \n    # Test case 4: Larger image with varied intensities\n    test_case4 <- list(\n        c(0, 1, 2, 3),\n        c(255, 254, 253, 252),\n        c(100, 101, 102, 103)\n    )\n    expected4 <- rep(0, 256)\n    expected4[c(1, 2, 3, 4, 101, 102, 103, 104, 253, 254, 255, 256)] <- 1\n    stopifnot(identical(calculate_histogram(test_case4), expected4))\n    \n    cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_histogram()", "exec_outcome": "PASSED"}
{"code": "# find_hotspot_submatrix identifies if there exists any k x k submatrix in an n x m matrix \n# where the sum of elements is greater than a threshold t. If found, it returns the top-left \n# position of the first such submatrix; otherwise, it returns \"NO\".\n# \n# Parameters:\n#   n: Number of rows in the matrix.\n#   m: Number of columns in the matrix.\n#   t: Threshold value for the sum of elements in the submatrix.\n#   readings: A 2D matrix (list of lists) of numeric values.\n#\n# Returns:\n#   A string indicating if a hotspot was found (\"YES\" followed by the position) or \"NO\".\n\nfind_hotspot_submatrix <- function(n, m, t, readings) {\n  # Helper function to calculate the sum of elements in a k x k submatrix starting at (x, y)\n  get_submatrix_sum <- function(x, y, k) {\n    total <- 0\n    for (i in x:(x + k - 1)) {\n      for (j in y:(y + k - 1)) {\n        total <- total + readings[[i]][[j]]\n      }\n    }\n    return(total)\n  }\n  \n  max_k <- min(n, m)\n  for (k in 1:max_k) {\n    for (i in 1:(n - k + 1)) {\n      for (j in 1:(m - k + 1)) {\n        current_sum <- get_submatrix_sum(i, j, k)\n        if (current_sum > t) {\n          return(paste(\"YES\", i, j))\n        }\n      }\n    }\n  }\n  return(\"NO\")\n}", "test_cases": "", "test_case_results": "Input:\nn: 3 , m: 3 , t: 10 \nMatrix:\n1 2 3 \n4 5 6 \n7 8 9 \nResult: YES 1 1 \n\nInput:\nn: 2 , m: 2 , t: 5 \nMatrix:\n1 2 \n3 4 \nResult: YES 1 1 \n\nInput:\nn: 4 , m: 4 , t: 50 \nMatrix:\n1 1 1 1 \n1 1 1 1 \n1 1 1 1 \n1 1 1 1 \nResult: NO", "task_id": 27026, "assertions": "test_hotspot_submatrix <- function() {\n  # Test case 1\n  test_case1 <- list(\n    n = 3,\n    m = 3,\n    t = 10,\n    readings = list(\n      list(1, 2, 3),\n      list(4, 5, 6),\n      list(7, 8, 9)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case1$n, test_case1$m, test_case1$t, test_case1$readings) == \"YES 1 1\")\n  \n  # Test case 2\n  test_case2 <- list(\n    n = 2,\n    m = 2,\n    t = 5,\n    readings = list(\n      list(1, 2),\n      list(3, 4)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case2$n, test_case2$m, test_case2$t, test_case2$readings) == \"YES 1 1\")\n  \n  # Test case 3\n  test_case3 <- list(\n    n = 4,\n    m = 4,\n    t = 50,\n    readings = list(\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case3$n, test_case3$m, test_case3$t, test_case3$readings) == \"NO\")\n}\n\ntest_hotspot_submatrix()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_hotspot_submatrix <- function() {\n  # Test case 1\n  test_case1 <- list(\n    n = 3,\n    m = 3,\n    t = 10,\n    readings = list(\n      list(1, 2, 3),\n      list(4, 5, 6),\n      list(7, 8, 9)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case1$n, test_case1$m, test_case1$t, test_case1$readings) == \"YES 1 1\")\n  \n  # Test case 2\n  test_case2 <- list(\n    n = 2,\n    m = 2,\n    t = 5,\n    readings = list(\n      list(1, 2),\n      list(3, 4)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case2$n, test_case2$m, test_case2$t, test_case2$readings) == \"YES 1 1\")\n  \n  # Test case 3\n  test_case3 <- list(\n    n = 4,\n    m = 4,\n    t = 50,\n    readings = list(\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case3$n, test_case3$m, test_case3$t, test_case3$readings) == \"NO\")\n}\n\ntest_hotspot_submatrix()", "output": "find_hotspot_submatrix"}, "all_code": "# find_hotspot_submatrix identifies if there exists any k x k submatrix in an n x m matrix \n# where the sum of elements is greater than a threshold t. If found, it returns the top-left \n# position of the first such submatrix; otherwise, it returns \"NO\".\n# \n# Parameters:\n#   n: Number of rows in the matrix.\n#   m: Number of columns in the matrix.\n#   t: Threshold value for the sum of elements in the submatrix.\n#   readings: A 2D matrix (list of lists) of numeric values.\n#\n# Returns:\n#   A string indicating if a hotspot was found (\"YES\" followed by the position) or \"NO\".\n\nfind_hotspot_submatrix <- function(n, m, t, readings) {\n  # Helper function to calculate the sum of elements in a k x k submatrix starting at (x, y)\n  get_submatrix_sum <- function(x, y, k) {\n    total <- 0\n    for (i in x:(x + k - 1)) {\n      for (j in y:(y + k - 1)) {\n        total <- total + readings[[i]][[j]]\n      }\n    }\n    return(total)\n  }\n  \n  max_k <- min(n, m)\n  for (k in 1:max_k) {\n    for (i in 1:(n - k + 1)) {\n      for (j in 1:(m - k + 1)) {\n        current_sum <- get_submatrix_sum(i, j, k)\n        if (current_sum > t) {\n          return(paste(\"YES\", i, j))\n        }\n      }\n    }\n  }\n  return(\"NO\")\n}\ntest_hotspot_submatrix <- function() {\n  # Test case 1\n  test_case1 <- list(\n    n = 3,\n    m = 3,\n    t = 10,\n    readings = list(\n      list(1, 2, 3),\n      list(4, 5, 6),\n      list(7, 8, 9)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case1$n, test_case1$m, test_case1$t, test_case1$readings) == \"YES 1 1\")\n  \n  # Test case 2\n  test_case2 <- list(\n    n = 2,\n    m = 2,\n    t = 5,\n    readings = list(\n      list(1, 2),\n      list(3, 4)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case2$n, test_case2$m, test_case2$t, test_case2$readings) == \"YES 1 1\")\n  \n  # Test case 3\n  test_case3 <- list(\n    n = 4,\n    m = 4,\n    t = 50,\n    readings = list(\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1),\n      list(1, 1, 1, 1)\n    )\n  )\n  stopifnot(find_hotspot_submatrix(test_case3$n, test_case3$m, test_case3$t, test_case3$readings) == \"NO\")\n}\n\ntest_hotspot_submatrix()", "exec_outcome": "PASSED"}
{"code": "can_divide_equal_coins <- function(nums) {\n  total_sum <- sum(nums)\n  # If total sum is odd, we can't divide it into two equal parts\n  if (total_sum %% 2 != 0) {\n    return(FALSE)\n  }\n\n  target_sum <- total_sum %/% 2\n  n <- length(nums)\n  \n  # dp[i] will be TRUE if a subset of nums[1..i] has a sum equal to `target_sum`\n  dp <- rep(FALSE, target_sum + 1)\n  dp[1] <- TRUE  # Base case: sum of 0 is always possible with an empty subset\n  \n  for (coin in nums) {\n    for (j in target_sum:coin) {\n      if (dp[j - coin + 1]) {\n        dp[j + 1] <- TRUE\n      }\n    }\n  }\n  \n  return(dp[target_sum + 1])\n}", "test_cases": "", "test_case_results": "Input:  1 5 11 5 \nCan divide equally:  TRUE \nInput:  1 2 3 5 \nCan divide equally:  FALSE \nInput:  1 1 \nCan divide equally:  TRUE \nInput:  1 2 3 4 5 6 7 \nCan divide equally:  TRUE \nInput:  2 2 2 2 \nCan divide equally:  TRUE", "task_id": 9020, "assertions": "test_can_divide_equal_coins <- function() {\n    stopifnot(can_divide_equal_coins(c(1, 5, 11, 5)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 5)) == FALSE)\n    stopifnot(can_divide_equal_coins(c(1, 1)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 4, 5, 6, 7)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(2, 2, 2, 2)) == TRUE)\n}\n\ntest_can_divide_equal_coins()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_can_divide_equal_coins <- function() {\n    stopifnot(can_divide_equal_coins(c(1, 5, 11, 5)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 5)) == FALSE)\n    stopifnot(can_divide_equal_coins(c(1, 1)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 4, 5, 6, 7)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(2, 2, 2, 2)) == TRUE)\n}\n\ntest_can_divide_equal_coins()", "output": "can_divide_equal_coins"}, "all_code": "can_divide_equal_coins <- function(nums) {\n  total_sum <- sum(nums)\n  # If total sum is odd, we can't divide it into two equal parts\n  if (total_sum %% 2 != 0) {\n    return(FALSE)\n  }\n\n  target_sum <- total_sum %/% 2\n  n <- length(nums)\n  \n  # dp[i] will be TRUE if a subset of nums[1..i] has a sum equal to `target_sum`\n  dp <- rep(FALSE, target_sum + 1)\n  dp[1] <- TRUE  # Base case: sum of 0 is always possible with an empty subset\n  \n  for (coin in nums) {\n    for (j in target_sum:coin) {\n      if (dp[j - coin + 1]) {\n        dp[j + 1] <- TRUE\n      }\n    }\n  }\n  \n  return(dp[target_sum + 1])\n}\ntest_can_divide_equal_coins <- function() {\n    stopifnot(can_divide_equal_coins(c(1, 5, 11, 5)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 5)) == FALSE)\n    stopifnot(can_divide_equal_coins(c(1, 1)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(1, 2, 3, 4, 5, 6, 7)) == TRUE)\n    stopifnot(can_divide_equal_coins(c(2, 2, 2, 2)) == TRUE)\n}\n\ntest_can_divide_equal_coins()", "exec_outcome": "PASSED"}
{"code": "# min_meeting_height calculates the minimum height encountered as two people move towards each other\n# from the start and end of a vector of heights. The function uses a two-pointer approach to efficiently\n# traverse the vector and find the minimum height encountered during the traversal.\n# \n# Args:\n#   heights: A numeric vector representing the heights at each position.\n#\n# Returns:\n#   The minimum height encountered as the two pointers move towards each other.\n\nmin_meeting_height <- function(heights) {\n    n <- length(heights)\n    \n    # Initialize pointers for the two people\n    left <- 1  # R uses 1-based indexing\n    right <- n\n    \n    # Initialize the minimum height encountered\n    min_height <- min(heights[left], heights[right])\n    \n    # Move both pointers towards each other\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            left <- left + 1\n            min_height <- min(min_height, heights[left])\n        } else {\n            right <- right - 1\n            min_height <- min(min_height, heights[right])\n        }\n    }\n    \n    return(min_height)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nMinimum Meeting Height:  1 \n\nInput:  5 6 7 0 \nMinimum Meeting Height:  0 \n\nInput:  0 0 0 0 \nMinimum Meeting Height:  0 \n\nInput:  10 20 30 40 50 \nMinimum Meeting Height:  10 \n\nInput:  50 40 30 20 10 \nMinimum Meeting Height:  10", "task_id": 15893, "assertions": "test_min_meeting_height <- function() {\n    stopifnot(min_meeting_height(c(1, 2, 3, 4)) == 1)\n    stopifnot(min_meeting_height(c(5, 6, 7, 0)) == 0)\n    stopifnot(min_meeting_height(c(0, 0, 0, 0)) == 0)\n    stopifnot(min_meeting_height(c(10, 20, 30, 40, 50)) == 10)\n    stopifnot(min_meeting_height(c(50, 40, 30, 20, 10)) == 10)\n}\n\ntest_min_meeting_height()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_meeting_height <- function() {\n    stopifnot(min_meeting_height(c(1, 2, 3, 4)) == 1)\n    stopifnot(min_meeting_height(c(5, 6, 7, 0)) == 0)\n    stopifnot(min_meeting_height(c(0, 0, 0, 0)) == 0)\n    stopifnot(min_meeting_height(c(10, 20, 30, 40, 50)) == 10)\n    stopifnot(min_meeting_height(c(50, 40, 30, 20, 10)) == 10)\n}\n\ntest_min_meeting_height()", "output": "min_meeting_height"}, "all_code": "# min_meeting_height calculates the minimum height encountered as two people move towards each other\n# from the start and end of a vector of heights. The function uses a two-pointer approach to efficiently\n# traverse the vector and find the minimum height encountered during the traversal.\n# \n# Args:\n#   heights: A numeric vector representing the heights at each position.\n#\n# Returns:\n#   The minimum height encountered as the two pointers move towards each other.\n\nmin_meeting_height <- function(heights) {\n    n <- length(heights)\n    \n    # Initialize pointers for the two people\n    left <- 1  # R uses 1-based indexing\n    right <- n\n    \n    # Initialize the minimum height encountered\n    min_height <- min(heights[left], heights[right])\n    \n    # Move both pointers towards each other\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            left <- left + 1\n            min_height <- min(min_height, heights[left])\n        } else {\n            right <- right - 1\n            min_height <- min(min_height, heights[right])\n        }\n    }\n    \n    return(min_height)\n}\ntest_min_meeting_height <- function() {\n    stopifnot(min_meeting_height(c(1, 2, 3, 4)) == 1)\n    stopifnot(min_meeting_height(c(5, 6, 7, 0)) == 0)\n    stopifnot(min_meeting_height(c(0, 0, 0, 0)) == 0)\n    stopifnot(min_meeting_height(c(10, 20, 30, 40, 50)) == 10)\n    stopifnot(min_meeting_height(c(50, 40, 30, 20, 10)) == 10)\n}\n\ntest_min_meeting_height()", "exec_outcome": "PASSED"}
{"code": "# most_frequent_letter finds the most frequent letter in a string.\n# In case of a tie, the alphabetically first letter is returned.\n# The function ignores non-letter characters and is case-sensitive.\nmost_frequent_letter <- function(s) {\n  # Split the string into individual characters\n  chars <- strsplit(s, \"\")[[1]]\n  \n  # Filter out non-letter characters (optional, but aligns with the Python version)\n  chars <- chars[grepl(\"[a-zA-Z]\", chars)]\n  \n  # If there are no letters, return NA (or handle as needed)\n  if (length(chars) == 0) {\n    return(NA)\n  }\n  \n  # Calculate the frequency of each letter\n  frequency <- table(chars)\n  \n  # Find the maximum frequency\n  max_frequency <- max(frequency)\n  \n  # Get the letters with the maximum frequency\n  most_frequent_letters <- names(frequency[frequency == max_frequency])\n  \n  # Return the alphabetically first letter among the most frequent ones\n  return(min(most_frequent_letters))\n}\n\n# process_input processes a list of strings and returns the most frequent letter for each string.\n# T is the number of strings, but in R, we don't necessarily need it as we can directly process the list.\nprocess_input <- function(strings) {\n  results <- sapply(strings, most_frequent_letter)\n  return(results)\n}", "test_cases": "", "test_case_results": "Testing most_frequent_letter:\nInput: 'hello'\nMost frequent letter: 'l'\nInput: 'banana'\nMost frequent letter: 'a'\nInput: 'aabbcc'\nMost frequent letter: 'a'\nInput: 'R is great'\nMost frequent letter: 'R'\nInput: 'AaaBBb'\nMost frequent letter: 'B'\n\nTesting process_input:\nInput: 'hello', Most frequent letter: 'l'\nInput: 'banana', Most frequent letter: 'a'\nInput: 'aabbcc', Most frequent letter: 'a'\nInput: 'R is great', Most frequent letter: 'R'\nInput: 'AaaBBb', Most frequent letter: 'B'", "task_id": 2458, "assertions": "test_most_frequent_letter <- function() {\n  # Test individual cases\n  stopifnot(most_frequent_letter(\"hello\") == \"l\")\n  stopifnot(most_frequent_letter(\"banana\") == \"a\")\n  stopifnot(most_frequent_letter(\"aabbcc\") == \"a\")\n  stopifnot(most_frequent_letter(\"R is great\") == \"R\")\n  stopifnot(most_frequent_letter(\"AaaBBb\") == \"B\")\n  \n  # Test process_input with a list of strings\n  test_cases <- list(\"hello\", \"banana\", \"aabbcc\", \"R is great\", \"AaaBBb\")\n  expected_results <- c(\"l\", \"a\", \"a\", \"R\", \"B\")\n  stopifnot(all(process_input(test_cases) == expected_results))\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_most_frequent_letter()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_most_frequent_letter <- function() {\n  # Test individual cases\n  stopifnot(most_frequent_letter(\"hello\") == \"l\")\n  stopifnot(most_frequent_letter(\"banana\") == \"a\")\n  stopifnot(most_frequent_letter(\"aabbcc\") == \"a\")\n  stopifnot(most_frequent_letter(\"R is great\") == \"R\")\n  stopifnot(most_frequent_letter(\"AaaBBb\") == \"B\")\n  \n  # Test process_input with a list of strings\n  test_cases <- list(\"hello\", \"banana\", \"aabbcc\", \"R is great\", \"AaaBBb\")\n  expected_results <- c(\"l\", \"a\", \"a\", \"R\", \"B\")\n  stopifnot(all(process_input(test_cases) == expected_results))\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_most_frequent_letter()", "output": "most_frequent_letter"}, "all_code": "# most_frequent_letter finds the most frequent letter in a string.\n# In case of a tie, the alphabetically first letter is returned.\n# The function ignores non-letter characters and is case-sensitive.\nmost_frequent_letter <- function(s) {\n  # Split the string into individual characters\n  chars <- strsplit(s, \"\")[[1]]\n  \n  # Filter out non-letter characters (optional, but aligns with the Python version)\n  chars <- chars[grepl(\"[a-zA-Z]\", chars)]\n  \n  # If there are no letters, return NA (or handle as needed)\n  if (length(chars) == 0) {\n    return(NA)\n  }\n  \n  # Calculate the frequency of each letter\n  frequency <- table(chars)\n  \n  # Find the maximum frequency\n  max_frequency <- max(frequency)\n  \n  # Get the letters with the maximum frequency\n  most_frequent_letters <- names(frequency[frequency == max_frequency])\n  \n  # Return the alphabetically first letter among the most frequent ones\n  return(min(most_frequent_letters))\n}\n\n# process_input processes a list of strings and returns the most frequent letter for each string.\n# T is the number of strings, but in R, we don't necessarily need it as we can directly process the list.\nprocess_input <- function(strings) {\n  results <- sapply(strings, most_frequent_letter)\n  return(results)\n}\ntest_most_frequent_letter <- function() {\n  # Test individual cases\n  stopifnot(most_frequent_letter(\"hello\") == \"l\")\n  stopifnot(most_frequent_letter(\"banana\") == \"a\")\n  stopifnot(most_frequent_letter(\"aabbcc\") == \"a\")\n  stopifnot(most_frequent_letter(\"R is great\") == \"R\")\n  stopifnot(most_frequent_letter(\"AaaBBb\") == \"B\")\n  \n  # Test process_input with a list of strings\n  test_cases <- list(\"hello\", \"banana\", \"aabbcc\", \"R is great\", \"AaaBBb\")\n  expected_results <- c(\"l\", \"a\", \"a\", \"R\", \"B\")\n  stopifnot(all(process_input(test_cases) == expected_results))\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_most_frequent_letter()", "exec_outcome": "PASSED"}
{"code": "min_books_to_sell <- function(N, test_cases) {\n  results <- vector(\"integer\", N)\n  for (i in 1:N) {\n    B <- test_cases[[i]]$books\n    customer_reqs <- test_cases[[i]]$customer_reqs\n    \n    # Initialize a vector to count occurrences of each book\n    book_count <- integer(B)\n    for (req in customer_reqs) {\n      book_count[req + 1] <- book_count[req + 1] + 1  # +1 because R uses 1-based indexing\n    }\n    \n    # Count how many unique books are requested\n    books_needed <- sum(book_count > 0)\n    results[i] <- books_needed\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Test Case 1:\n  Books: 5\n  Customers: 3\n  Customer Requests: 012\n  Minimum Books Needed: 3\n\nTest Case 2:\n  Books: 4\n  Customers: 5\n  Customer Requests: 11233\n  Minimum Books Needed: 3\n\nTest Case 3:\n  Books: 3\n  Customers: 4\n  Customer Requests: 0012\n  Minimum Books Needed: 3", "task_id": 23648, "assertions": "test_min_books_to_sell <- function() {\n  test_cases <- list(\n    list(\n      books = 5,\n      stock = c(10, 10, 10, 10, 10),\n      customers = 3,\n      customer_reqs = c(0, 1, 2)\n    ),\n    list(\n      books = 4,\n      stock = c(5, 5, 5, 5),\n      customers = 5,\n      customer_reqs = c(1, 1, 2, 3, 3)\n    ),\n    list(\n      books = 3,\n      stock = c(2, 2, 2),\n      customers = 4,\n      customer_reqs = c(0, 0, 1, 2)\n    )\n  )\n  \n  N <- length(test_cases)\n  results <- min_books_to_sell(N, test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 3)\n  stopifnot(results[3] == 3)\n}\n\ntest_min_books_to_sell()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_books_to_sell <- function() {\n  test_cases <- list(\n    list(\n      books = 5,\n      stock = c(10, 10, 10, 10, 10),\n      customers = 3,\n      customer_reqs = c(0, 1, 2)\n    ),\n    list(\n      books = 4,\n      stock = c(5, 5, 5, 5),\n      customers = 5,\n      customer_reqs = c(1, 1, 2, 3, 3)\n    ),\n    list(\n      books = 3,\n      stock = c(2, 2, 2),\n      customers = 4,\n      customer_reqs = c(0, 0, 1, 2)\n    )\n  )\n  \n  N <- length(test_cases)\n  results <- min_books_to_sell(N, test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 3)\n  stopifnot(results[3] == 3)\n}\n\ntest_min_books_to_sell()", "output": "min_books_to_sell"}, "all_code": "min_books_to_sell <- function(N, test_cases) {\n  results <- vector(\"integer\", N)\n  for (i in 1:N) {\n    B <- test_cases[[i]]$books\n    customer_reqs <- test_cases[[i]]$customer_reqs\n    \n    # Initialize a vector to count occurrences of each book\n    book_count <- integer(B)\n    for (req in customer_reqs) {\n      book_count[req + 1] <- book_count[req + 1] + 1  # +1 because R uses 1-based indexing\n    }\n    \n    # Count how many unique books are requested\n    books_needed <- sum(book_count > 0)\n    results[i] <- books_needed\n  }\n  return(results)\n}\ntest_min_books_to_sell <- function() {\n  test_cases <- list(\n    list(\n      books = 5,\n      stock = c(10, 10, 10, 10, 10),\n      customers = 3,\n      customer_reqs = c(0, 1, 2)\n    ),\n    list(\n      books = 4,\n      stock = c(5, 5, 5, 5),\n      customers = 5,\n      customer_reqs = c(1, 1, 2, 3, 3)\n    ),\n    list(\n      books = 3,\n      stock = c(2, 2, 2),\n      customers = 4,\n      customer_reqs = c(0, 0, 1, 2)\n    )\n  )\n  \n  N <- length(test_cases)\n  results <- min_books_to_sell(N, test_cases)\n  \n  stopifnot(results[1] == 3)\n  stopifnot(results[2] == 3)\n  stopifnot(results[3] == 3)\n}\n\ntest_min_books_to_sell()", "exec_outcome": "PASSED"}
{"code": "# Function to check if the knight can reach the target position in exactly K moves\n# Parameters:\n#   M, N: dimensions of the chessboard (rows, columns)\n#   x_start, y_start: starting position of the knight (0-based)\n#   x_target, y_target: target position to reach (0-based)\n#   K: exact number of moves allowed\n# Returns: \"YES\" if the target can be reached in exactly K moves, \"NO\" otherwise\ncan_reach_in_exactly_k_moves <- function(M, N, x_start, y_start, x_target, y_target, K) {\n  moves <- list(\n    c(2, 1), c(2, -1), c(-2, 1), c(-2, -1),\n    c(1, 2), c(1, -2), c(-1, 2), c(-1, -2)\n  )\n  \n  queue <- list(list(x = x_start, y = y_start, d = 0))\n  visited <- list()\n  visited[[paste(x_start, y_start, 0, sep = \",\")]] <- TRUE\n  \n  while (length(queue) > 0) {\n    current <- queue[[1]]\n    queue <- queue[-1]\n    x <- current$x\n    y <- current$y\n    d <- current$d\n    \n    if (d == K) {\n      if (x == x_target && y == y_target) {\n        return(\"YES\")\n      }\n      next\n    }\n    \n    for (move in moves) {\n      nx <- x + move[1]\n      ny <- y + move[2]\n      key <- paste(nx, ny, d + 1, sep = \",\")\n      \n      if (nx >= 0 && nx < M && ny >= 0 && ny < N && is.null(visited[[key]])) {\n        queue <- append(queue, list(list(x = nx, y = ny, d = d + 1)))\n        visited[[key]] <- TRUE\n      }\n    }\n  }\n  \n  return(\"NO\")\n}\n\n# Function to process multiple test cases for the knight moves problem\n# Parameters:\n#   T: number of test cases\n#   test_cases: list of test cases, each containing M, N, x_start, y_start, x_target, y_target, K\n# Returns: vector of results (\"YES\" or \"NO\") for each test case\nprocess_knight_moves <- function(T, test_cases) {\n  results <- c()\n  for (test_case in test_cases) {\n    M <- test_case[1]\n    N <- test_case[2]\n    x_start <- test_case[3]\n    y_start <- test_case[4]\n    x_target <- test_case[5]\n    y_target <- test_case[6]\n    K <- test_case[7]\n    result <- can_reach_in_exactly_k_moves(M, N, x_start, y_start, x_target, y_target, K)\n    results <- c(results, result)\n  }\n  return(results)\n}", "test_cases": "", "test_case_results": "Test Case 1: M=8, N=8, Start=(0,0), Target=(1,2), K=1 -> Result: YES\nTest Case 2: M=8, N=8, Start=(0,0), Target=(1,2), K=2 -> Result: NO\nTest Case 3: M=8, N=8, Start=(0,0), Target=(3,3), K=2 -> Result: YES\nTest Case 4: M=8, N=8, Start=(0,0), Target=(3,3), K=3 -> Result: NO\nTest Case 5: M=3, N=3, Start=(0,0), Target=(2,2), K=4 -> Result: YES", "task_id": 10254, "assertions": "test_knight_moves <- function() {\n  test_cases <- list(\n    c(8, 8, 0, 0, 1, 2, 1),  # YES (can reach in 1 move)\n    c(8, 8, 0, 0, 1, 2, 2),  # NO (can reach in 1 move, but not exactly 2)\n    c(8, 8, 0, 0, 3, 3, 2),  # YES (can reach in 2 moves)\n    c(8, 8, 0, 0, 3, 3, 3),  # NO (can reach in 2 moves, but not exactly 3)\n    c(3, 3, 0, 0, 2, 2, 4)   # NO (target is unreachable within the board)\n  )\n  \n  results <- process_knight_moves(length(test_cases), test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"NO\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"NO\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_knight_moves()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_knight_moves <- function() {\n  test_cases <- list(\n    c(8, 8, 0, 0, 1, 2, 1),  # YES (can reach in 1 move)\n    c(8, 8, 0, 0, 1, 2, 2),  # NO (can reach in 1 move, but not exactly 2)\n    c(8, 8, 0, 0, 3, 3, 2),  # YES (can reach in 2 moves)\n    c(8, 8, 0, 0, 3, 3, 3),  # NO (can reach in 2 moves, but not exactly 3)\n    c(3, 3, 0, 0, 2, 2, 4)   # NO (target is unreachable within the board)\n  )\n  \n  results <- process_knight_moves(length(test_cases), test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"NO\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"NO\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_knight_moves()", "output": "process_knight_moves"}, "all_code": "# Function to check if the knight can reach the target position in exactly K moves\n# Parameters:\n#   M, N: dimensions of the chessboard (rows, columns)\n#   x_start, y_start: starting position of the knight (0-based)\n#   x_target, y_target: target position to reach (0-based)\n#   K: exact number of moves allowed\n# Returns: \"YES\" if the target can be reached in exactly K moves, \"NO\" otherwise\ncan_reach_in_exactly_k_moves <- function(M, N, x_start, y_start, x_target, y_target, K) {\n  moves <- list(\n    c(2, 1), c(2, -1), c(-2, 1), c(-2, -1),\n    c(1, 2), c(1, -2), c(-1, 2), c(-1, -2)\n  )\n  \n  queue <- list(list(x = x_start, y = y_start, d = 0))\n  visited <- list()\n  visited[[paste(x_start, y_start, 0, sep = \",\")]] <- TRUE\n  \n  while (length(queue) > 0) {\n    current <- queue[[1]]\n    queue <- queue[-1]\n    x <- current$x\n    y <- current$y\n    d <- current$d\n    \n    if (d == K) {\n      if (x == x_target && y == y_target) {\n        return(\"YES\")\n      }\n      next\n    }\n    \n    for (move in moves) {\n      nx <- x + move[1]\n      ny <- y + move[2]\n      key <- paste(nx, ny, d + 1, sep = \",\")\n      \n      if (nx >= 0 && nx < M && ny >= 0 && ny < N && is.null(visited[[key]])) {\n        queue <- append(queue, list(list(x = nx, y = ny, d = d + 1)))\n        visited[[key]] <- TRUE\n      }\n    }\n  }\n  \n  return(\"NO\")\n}\n\n# Function to process multiple test cases for the knight moves problem\n# Parameters:\n#   T: number of test cases\n#   test_cases: list of test cases, each containing M, N, x_start, y_start, x_target, y_target, K\n# Returns: vector of results (\"YES\" or \"NO\") for each test case\nprocess_knight_moves <- function(T, test_cases) {\n  results <- c()\n  for (test_case in test_cases) {\n    M <- test_case[1]\n    N <- test_case[2]\n    x_start <- test_case[3]\n    y_start <- test_case[4]\n    x_target <- test_case[5]\n    y_target <- test_case[6]\n    K <- test_case[7]\n    result <- can_reach_in_exactly_k_moves(M, N, x_start, y_start, x_target, y_target, K)\n    results <- c(results, result)\n  }\n  return(results)\n}\ntest_knight_moves <- function() {\n  test_cases <- list(\n    c(8, 8, 0, 0, 1, 2, 1),  # YES (can reach in 1 move)\n    c(8, 8, 0, 0, 1, 2, 2),  # NO (can reach in 1 move, but not exactly 2)\n    c(8, 8, 0, 0, 3, 3, 2),  # YES (can reach in 2 moves)\n    c(8, 8, 0, 0, 3, 3, 3),  # NO (can reach in 2 moves, but not exactly 3)\n    c(3, 3, 0, 0, 2, 2, 4)   # NO (target is unreachable within the board)\n  )\n  \n  results <- process_knight_moves(length(test_cases), test_cases)\n  \n  stopifnot(results[1] == \"YES\")\n  stopifnot(results[2] == \"NO\")\n  stopifnot(results[3] == \"YES\")\n  stopifnot(results[4] == \"NO\")\n  stopifnot(results[5] == \"NO\")\n}\n\ntest_knight_moves()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# min_repaints calculates the minimum number of balloons that must be repainted \n# to ensure no two adjacent balloons share the same color.\n# The function takes an integer n (number of balloons) and a vector of balloon colors.\n# It iterates through the balloons and counts repaints needed when adjacent balloons have the same color.\n# If three consecutive balloons have the same color, the middle one is repainted to a unique color (-1).\nmin_repaints <- function(n, balloons) {\n    if (n <= 1) {\n        return(0)\n    }\n    \n    repaints <- 0\n    \n    for (i in 2:n) {\n        if (balloons[i] == balloons[i-1]) {\n            repaints <- repaints + 1\n            # Change the balloon's color to a different one to avoid same color in next step comparison\n            if (i+1 <= n && balloons[i+1] == balloons[i]) {\n                balloons[i] <- -1  # -1 represents the repaint\n            }\n        }\n    }\n    \n    return(repaints)\n}", "test_cases": "", "test_case_results": "Input: n = 1 , balloons = 1 \nMinimum repaints:  0 \nInput: n = 2 , balloons = 1 1 \nMinimum repaints:  1 \nInput: n = 3 , balloons = 1 1 1 \nMinimum repaints:  1 \nInput: n = 4 , balloons = 1 2 2 3 \nMinimum repaints:  1 \nInput: n = 5 , balloons = 1 1 2 2 1 \nMinimum repaints:  2", "task_id": 13307, "assertions": "test_min_repaints <- function() {\n    stopifnot(min_repaints(1, c(1)) == 0)\n    stopifnot(min_repaints(2, c(1, 1)) == 1)\n    stopifnot(min_repaints(3, c(1, 1, 1)) == 1)\n    stopifnot(min_repaints(4, c(1, 2, 2, 3)) == 1)\n    stopifnot(min_repaints(5, c(1, 1, 2, 2, 1)) == 2)\n}\n\ntest_min_repaints()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_min_repaints <- function() {\n    stopifnot(min_repaints(1, c(1)) == 0)\n    stopifnot(min_repaints(2, c(1, 1)) == 1)\n    stopifnot(min_repaints(3, c(1, 1, 1)) == 1)\n    stopifnot(min_repaints(4, c(1, 2, 2, 3)) == 1)\n    stopifnot(min_repaints(5, c(1, 1, 2, 2, 1)) == 2)\n}\n\ntest_min_repaints()", "output": "min_repaints"}, "all_code": "# min_repaints calculates the minimum number of balloons that must be repainted \n# to ensure no two adjacent balloons share the same color.\n# The function takes an integer n (number of balloons) and a vector of balloon colors.\n# It iterates through the balloons and counts repaints needed when adjacent balloons have the same color.\n# If three consecutive balloons have the same color, the middle one is repainted to a unique color (-1).\nmin_repaints <- function(n, balloons) {\n    if (n <= 1) {\n        return(0)\n    }\n    \n    repaints <- 0\n    \n    for (i in 2:n) {\n        if (balloons[i] == balloons[i-1]) {\n            repaints <- repaints + 1\n            # Change the balloon's color to a different one to avoid same color in next step comparison\n            if (i+1 <= n && balloons[i+1] == balloons[i]) {\n                balloons[i] <- -1  # -1 represents the repaint\n            }\n        }\n    }\n    \n    return(repaints)\n}\ntest_min_repaints <- function() {\n    stopifnot(min_repaints(1, c(1)) == 0)\n    stopifnot(min_repaints(2, c(1, 1)) == 1)\n    stopifnot(min_repaints(3, c(1, 1, 1)) == 1)\n    stopifnot(min_repaints(4, c(1, 2, 2, 3)) == 1)\n    stopifnot(min_repaints(5, c(1, 1, 2, 2, 1)) == 2)\n}\n\ntest_min_repaints()", "exec_outcome": "PASSED"}
{"code": "# sum_of_integers calculates the sum of integers in a numeric vector.\n# If the input is not a numeric vector or contains non-numeric elements, it returns NULL.\n# This function handles potential errors gracefully by catching exceptions.\nsum_of_integers <- function(int_list) {\n  tryCatch({\n    total <- sum(int_list)\n    return(total)\n  }, error = function(e) {\n    return(NULL)\n  })\n}", "test_cases": "", "test_case_results": "Input:  1, 2, 3, 4 \nSum:  10 \nInput:  5, 6, 7, 0 \nSum:  18 \nInput:  0, 0, 0, 0 \nSum:  0 \nInput:  -1, -2, -3, -4 \nSum:  -10 \nInput:  1.5, 2.5, 3.5 \nSum:  7.5 \nInput:  a, b, c \nSum:  NULL \nInput:   \nSum:  0", "task_id": 23880, "assertions": "test.sum_of_integers <- function() {\n    # Test normal case\n    stopifnot(sum_of_integers(c(1, 2, 3, 4)) == 10)\n    # Test includes zero\n    stopifnot(sum_of_integers(c(5, 6, 7, 0)) == 18)\n    # Test all zeros\n    stopifnot(sum_of_integers(c(0, 0, 0, 0)) == 0)\n    # Test negative numbers\n    stopifnot(sum_of_integers(c(-1, -2, -3, -4)) == -10)\n    # Test non-integer numbers\n    stopifnot(sum_of_integers(c(1.5, 2.5, 3.5)) == 7.5)\n    # Test non-numeric input\n    stopifnot(is.null(sum_of_integers(c(\"a\", \"b\", \"c\"))))\n    # Test NULL input\n    stopifnot(sum_of_integers(NULL) == 0)\n}\n\ntest.sum_of_integers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.sum_of_integers <- function() {\n    # Test normal case\n    stopifnot(sum_of_integers(c(1, 2, 3, 4)) == 10)\n    # Test includes zero\n    stopifnot(sum_of_integers(c(5, 6, 7, 0)) == 18)\n    # Test all zeros\n    stopifnot(sum_of_integers(c(0, 0, 0, 0)) == 0)\n    # Test negative numbers\n    stopifnot(sum_of_integers(c(-1, -2, -3, -4)) == -10)\n    # Test non-integer numbers\n    stopifnot(sum_of_integers(c(1.5, 2.5, 3.5)) == 7.5)\n    # Test non-numeric input\n    stopifnot(is.null(sum_of_integers(c(\"a\", \"b\", \"c\"))))\n    # Test NULL input\n    stopifnot(sum_of_integers(NULL) == 0)\n}\n\ntest.sum_of_integers()", "output": "sum_of_integers"}, "all_code": "# sum_of_integers calculates the sum of integers in a numeric vector.\n# If the input is not a numeric vector or contains non-numeric elements, it returns NULL.\n# This function handles potential errors gracefully by catching exceptions.\nsum_of_integers <- function(int_list) {\n  tryCatch({\n    total <- sum(int_list)\n    return(total)\n  }, error = function(e) {\n    return(NULL)\n  })\n}\ntest.sum_of_integers <- function() {\n    # Test normal case\n    stopifnot(sum_of_integers(c(1, 2, 3, 4)) == 10)\n    # Test includes zero\n    stopifnot(sum_of_integers(c(5, 6, 7, 0)) == 18)\n    # Test all zeros\n    stopifnot(sum_of_integers(c(0, 0, 0, 0)) == 0)\n    # Test negative numbers\n    stopifnot(sum_of_integers(c(-1, -2, -3, -4)) == -10)\n    # Test non-integer numbers\n    stopifnot(sum_of_integers(c(1.5, 2.5, 3.5)) == 7.5)\n    # Test non-numeric input\n    stopifnot(is.null(sum_of_integers(c(\"a\", \"b\", \"c\"))))\n    # Test NULL input\n    stopifnot(sum_of_integers(NULL) == 0)\n}\n\ntest.sum_of_integers()", "exec_outcome": "PASSED"}
{"code": "# has_perfect_attendance checks if an employee has perfect attendance based on the given criteria.\n# The function returns TRUE if the attendance record contains no 'A' characters or has a single 'A' \n# that appears after some 'P' and no further 'A' after the first one. Otherwise, it returns FALSE.\nhas_perfect_attendance <- function(attendance) {\n  a_found <- FALSE\n  \n  for (i in 1:nchar(attendance)) {\n    current_char <- substr(attendance, i, i)\n    if (current_char == 'A') {\n      if (a_found) {\n        return(FALSE)  # A second 'A' found\n      } else {\n        a_found <- TRUE\n        if (i == 1) {\n          return(FALSE)  # 'A' cannot be at the beginning\n        }\n      }\n    }\n  }\n  \n  return(TRUE)\n}", "test_cases": "", "test_case_results": "Input: \"PPAP\", Result: TRUE\nInput: \"PPPPP\", Result: TRUE\nInput: \"APPP\", Result: FALSE\nInput: \"PPAA\", Result: FALSE\nInput: \"PAPAP\", Result: FALSE\nInput: \"P\", Result: TRUE\nInput: \"A\", Result: FALSE\nInput: \"\", Result: TRUE", "task_id": 12539, "assertions": "test_attendance <- function() {\n    stopifnot(has_perfect_attendance(\"PPAP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"PPPPP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"APPP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PPAA\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PAPAP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"P\") == TRUE)\n    stopifnot(has_perfect_attendance(\"A\") == FALSE)\n    stopifnot(has_perfect_attendance(\"\") == TRUE)\n}\n\ntest_attendance()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_attendance <- function() {\n    stopifnot(has_perfect_attendance(\"PPAP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"PPPPP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"APPP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PPAA\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PAPAP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"P\") == TRUE)\n    stopifnot(has_perfect_attendance(\"A\") == FALSE)\n    stopifnot(has_perfect_attendance(\"\") == TRUE)\n}\n\ntest_attendance()", "output": "has_perfect_attendance"}, "all_code": "# has_perfect_attendance checks if an employee has perfect attendance based on the given criteria.\n# The function returns TRUE if the attendance record contains no 'A' characters or has a single 'A' \n# that appears after some 'P' and no further 'A' after the first one. Otherwise, it returns FALSE.\nhas_perfect_attendance <- function(attendance) {\n  a_found <- FALSE\n  \n  for (i in 1:nchar(attendance)) {\n    current_char <- substr(attendance, i, i)\n    if (current_char == 'A') {\n      if (a_found) {\n        return(FALSE)  # A second 'A' found\n      } else {\n        a_found <- TRUE\n        if (i == 1) {\n          return(FALSE)  # 'A' cannot be at the beginning\n        }\n      }\n    }\n  }\n  \n  return(TRUE)\n}\ntest_attendance <- function() {\n    stopifnot(has_perfect_attendance(\"PPAP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"PPPPP\") == TRUE)\n    stopifnot(has_perfect_attendance(\"APPP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PPAA\") == FALSE)\n    stopifnot(has_perfect_attendance(\"PAPAP\") == FALSE)\n    stopifnot(has_perfect_attendance(\"P\") == TRUE)\n    stopifnot(has_perfect_attendance(\"A\") == FALSE)\n    stopifnot(has_perfect_attendance(\"\") == TRUE)\n}\n\ntest_attendance()", "exec_outcome": "PASSED"}
{"code": "# find_min_integer_to_remove returns the smallest integer to be removed to maximize the sum of the remaining integers.\n# If there are multiple choices, it returns the smallest integer.\n# The function works by iterating through the sorted list of numbers, calculating the sum when each number is removed,\n# and keeping track of the number that, when removed, results in the maximum sum.\nfind_min_integer_to_remove <- function(numbers) {\n  total_sum <- sum(numbers)\n  max_sum <- -Inf\n  candidate <- NULL\n  \n  for (num in sort(numbers)) {\n    current_sum <- total_sum - num\n    \n    if (current_sum > max_sum) {\n      max_sum <- current_sum\n      candidate <- num\n    } else if (current_sum == max_sum) {\n      candidate <- min(candidate, num)\n    }\n  }\n  \n  return(candidate)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nSmallest integer to remove:  1 \nInput:  5 5 5 5 \nSmallest integer to remove:  5 \nInput:  10 2 3 4 \nSmallest integer to remove:  2 \nInput:  1 1 2 2 \nSmallest integer to remove:  1", "task_id": 29373, "assertions": "test_find_min_integer_to_remove <- function() {\n    stopifnot(find_min_integer_to_remove(c(1, 2, 3, 4)) == 1)\n    stopifnot(find_min_integer_to_remove(c(5, 5, 5, 5)) == 5)\n    stopifnot(find_min_integer_to_remove(c(10, 2, 3, 4)) == 2)\n    stopifnot(find_min_integer_to_remove(c(1, 1, 2, 2)) == 1)\n}\n\ntest_find_min_integer_to_remove()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_find_min_integer_to_remove <- function() {\n    stopifnot(find_min_integer_to_remove(c(1, 2, 3, 4)) == 1)\n    stopifnot(find_min_integer_to_remove(c(5, 5, 5, 5)) == 5)\n    stopifnot(find_min_integer_to_remove(c(10, 2, 3, 4)) == 2)\n    stopifnot(find_min_integer_to_remove(c(1, 1, 2, 2)) == 1)\n}\n\ntest_find_min_integer_to_remove()", "output": "find_min_integer_to_remove"}, "all_code": "# find_min_integer_to_remove returns the smallest integer to be removed to maximize the sum of the remaining integers.\n# If there are multiple choices, it returns the smallest integer.\n# The function works by iterating through the sorted list of numbers, calculating the sum when each number is removed,\n# and keeping track of the number that, when removed, results in the maximum sum.\nfind_min_integer_to_remove <- function(numbers) {\n  total_sum <- sum(numbers)\n  max_sum <- -Inf\n  candidate <- NULL\n  \n  for (num in sort(numbers)) {\n    current_sum <- total_sum - num\n    \n    if (current_sum > max_sum) {\n      max_sum <- current_sum\n      candidate <- num\n    } else if (current_sum == max_sum) {\n      candidate <- min(candidate, num)\n    }\n  }\n  \n  return(candidate)\n}\ntest_find_min_integer_to_remove <- function() {\n    stopifnot(find_min_integer_to_remove(c(1, 2, 3, 4)) == 1)\n    stopifnot(find_min_integer_to_remove(c(5, 5, 5, 5)) == 5)\n    stopifnot(find_min_integer_to_remove(c(10, 2, 3, 4)) == 2)\n    stopifnot(find_min_integer_to_remove(c(1, 1, 2, 2)) == 1)\n}\n\ntest_find_min_integer_to_remove()", "exec_outcome": "PASSED"}
{"code": "walls_and_gates <- function(rooms) {\n  m <- nrow(rooms)\n  n <- ncol(rooms)\n  queue <- list()\n  \n  # Initialize the queue with all gate positions\n  for (i in 1:m) {\n    for (j in 1:n) {\n      if (rooms[i, j] == 0) {\n        queue <- append(queue, list(c(i, j)))\n      }\n    }\n  }\n  \n  # Directions for moving up, down, left, right\n  directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n  \n  # Process each position in the queue\n  while (length(queue) > 0) {\n    current <- queue[[1]]\n    queue <- queue[-1]\n    x <- current[1]\n    y <- current[2]\n    \n    # Explore all four possible directions\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      \n      # Check if the new position is within bounds and is an empty room\n      if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && rooms[nx, ny] == 2147483647) {\n        rooms[nx, ny] <- rooms[x, y] + 1\n        queue <- append(queue, list(c(nx, ny)))\n      }\n    }\n  }\n  \n  return(rooms)\n}", "test_cases": "", "test_case_results": "Test case 1 input:\n           [,1]       [,2]       [,3]       [,4]\n[1,] 2147483647         -1          0 2147483647\n[2,] 2147483647 2147483647 2147483647         -1\n[3,] 2147483647         -1 2147483647         -1\n[4,]          0         -1 2147483647 2147483647\nTest case 1 result:\n     [,1] [,2] [,3] [,4]\n[1,]    3   -1    0    1\n[2,]    2    2    1   -1\n[3,]    1   -1    2   -1\n[4,]    0   -1    3    4\n\nTest case 2 input:\n           [,1]       [,2]       [,3]       [,4]\n[1,] 2147483647         -1          0 2147483647\n[2,]         -1 2147483647 2147483647         -1\n[3,] 2147483647         -1 2147483647         -1\n[4,]          0         -1 2147483647 2147483647\nTest case 2 result:\n           [,1] [,2] [,3] [,4]\n[1,] 2147483647   -1    0    1\n[2,]         -1    2    1   -1\n[3,]          1   -1    2   -1\n[4,]          0   -1    3    4\n\nTest case 3 input:\n           [,1]       [,2]\n[1,]          0 2147483647\n[2,] 2147483647          0\nTest case 3 result:\n     [,1] [,2]\n[1,]    0    1\n[2,]    1    0", "task_id": 28, "assertions": "test_walls_and_gates <- function() {\n  test_case1 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    2147483647, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected1 <- matrix(c(\n    3, -1, 0, 1,\n    2, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case2 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    -1, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected2 <- matrix(c(\n    2147483647, -1, 0, 1,\n    -1, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case3 <- matrix(c(\n    0, 2147483647,\n    2147483647, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  expected3 <- matrix(c(\n    0, 1,\n    1, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  stopifnot(identical(walls_and_gates(test_case1), expected1))\n  stopifnot(identical(walls_and_gates(test_case2), expected2))\n  stopifnot(identical(walls_and_gates(test_case3), expected3))\n}\n\ntest_walls_and_gates()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_walls_and_gates <- function() {\n  test_case1 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    2147483647, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected1 <- matrix(c(\n    3, -1, 0, 1,\n    2, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case2 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    -1, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected2 <- matrix(c(\n    2147483647, -1, 0, 1,\n    -1, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case3 <- matrix(c(\n    0, 2147483647,\n    2147483647, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  expected3 <- matrix(c(\n    0, 1,\n    1, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  stopifnot(identical(walls_and_gates(test_case1), expected1))\n  stopifnot(identical(walls_and_gates(test_case2), expected2))\n  stopifnot(identical(walls_and_gates(test_case3), expected3))\n}\n\ntest_walls_and_gates()", "output": "walls_and_gates"}, "all_code": "walls_and_gates <- function(rooms) {\n  m <- nrow(rooms)\n  n <- ncol(rooms)\n  queue <- list()\n  \n  # Initialize the queue with all gate positions\n  for (i in 1:m) {\n    for (j in 1:n) {\n      if (rooms[i, j] == 0) {\n        queue <- append(queue, list(c(i, j)))\n      }\n    }\n  }\n  \n  # Directions for moving up, down, left, right\n  directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n  \n  # Process each position in the queue\n  while (length(queue) > 0) {\n    current <- queue[[1]]\n    queue <- queue[-1]\n    x <- current[1]\n    y <- current[2]\n    \n    # Explore all four possible directions\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      \n      # Check if the new position is within bounds and is an empty room\n      if (nx >= 1 && nx <= m && ny >= 1 && ny <= n && rooms[nx, ny] == 2147483647) {\n        rooms[nx, ny] <- rooms[x, y] + 1\n        queue <- append(queue, list(c(nx, ny)))\n      }\n    }\n  }\n  \n  return(rooms)\n}\ntest_walls_and_gates <- function() {\n  test_case1 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    2147483647, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected1 <- matrix(c(\n    3, -1, 0, 1,\n    2, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case2 <- matrix(c(\n    2147483647, -1, 0, 2147483647,\n    -1, 2147483647, 2147483647, -1,\n    2147483647, -1, 2147483647, -1,\n    0, -1, 2147483647, 2147483647\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  expected2 <- matrix(c(\n    2147483647, -1, 0, 1,\n    -1, 2, 1, -1,\n    1, -1, 2, -1,\n    0, -1, 3, 4\n  ), nrow = 4, ncol = 4, byrow = TRUE)\n  \n  test_case3 <- matrix(c(\n    0, 2147483647,\n    2147483647, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  expected3 <- matrix(c(\n    0, 1,\n    1, 0\n  ), nrow = 2, ncol = 2, byrow = TRUE)\n  \n  stopifnot(identical(walls_and_gates(test_case1), expected1))\n  stopifnot(identical(walls_and_gates(test_case2), expected2))\n  stopifnot(identical(walls_and_gates(test_case3), expected3))\n}\n\ntest_walls_and_gates()", "exec_outcome": "PASSED"}
{"code": "# separate_numbers categorizes the elements of a numeric vector into three groups:\n# positive numbers, negative numbers, and zeros.\n# It returns a list containing three vectors: positive, negative, and zeros.\nseparate_numbers <- function(arr) {\n  pos <- arr[arr > 0]\n  neg <- arr[arr < 0]\n  neither <- arr[arr == 0]\n  return(list(pos = pos, neg = neg, neither = neither))\n}", "test_cases": "", "test_case_results": "Input:  1 -2 3 -4 0 5 0 \nPositive:  1 3 5 \nNegative:  -2 -4 \nZero:  0 0 \n\nInput:  -1 -2 -3 0 0 0 \nPositive:   \nNegative:  -1 -2 -3 \nZero:  0 0 0 \n\nInput:  1 2 3 4 5 \nPositive:  1 2 3 4 5 \nNegative:   \nZero:   \n\nInput:  0 0 0 \nPositive:   \nNegative:   \nZero:  0 0 0 \n\nInput:  -1 -2 -3 \nPositive:   \nNegative:  -1 -2 -3 \nZero:", "task_id": 13422, "assertions": "test_separate_numbers <- function() {\n  # Test case 1\n  result1 <- separate_numbers(c(1, -2, 3, -4, 0, 5, 0))\n  stopifnot(identical(result1$pos, c(1, 3, 5)),\n            identical(result1$neg, c(-2, -4)),\n            identical(result1$neither, c(0, 0)))\n  \n  # Test case 2\n  result2 <- separate_numbers(c(-1, -2, -3, 0, 0, 0))\n  stopifnot(identical(result2$pos, numeric(0)),\n            identical(result2$neg, c(-1, -2, -3)),\n            identical(result2$neither, c(0, 0, 0)))\n  \n  # Test case 3\n  result3 <- separate_numbers(c(1, 2, 3, 4, 5))\n  stopifnot(identical(result3$pos, c(1, 2, 3, 4, 5)),\n            identical(result3$neg, numeric(0)),\n            identical(result3$neither, numeric(0)))\n  \n  # Test case 4\n  result4 <- separate_numbers(c(0, 0, 0))\n  stopifnot(identical(result4$pos, numeric(0)),\n            identical(result4$neg, numeric(0)),\n            identical(result4$neither, c(0, 0, 0)))\n  \n  # Test case 5\n  result5 <- separate_numbers(c(-1, -2, -3))\n  stopifnot(identical(result5$pos, numeric(0)),\n            identical(result5$neg, c(-1, -2, -3)),\n            identical(result5$neither, numeric(0)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_separate_numbers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_separate_numbers <- function() {\n  # Test case 1\n  result1 <- separate_numbers(c(1, -2, 3, -4, 0, 5, 0))\n  stopifnot(identical(result1$pos, c(1, 3, 5)),\n            identical(result1$neg, c(-2, -4)),\n            identical(result1$neither, c(0, 0)))\n  \n  # Test case 2\n  result2 <- separate_numbers(c(-1, -2, -3, 0, 0, 0))\n  stopifnot(identical(result2$pos, numeric(0)),\n            identical(result2$neg, c(-1, -2, -3)),\n            identical(result2$neither, c(0, 0, 0)))\n  \n  # Test case 3\n  result3 <- separate_numbers(c(1, 2, 3, 4, 5))\n  stopifnot(identical(result3$pos, c(1, 2, 3, 4, 5)),\n            identical(result3$neg, numeric(0)),\n            identical(result3$neither, numeric(0)))\n  \n  # Test case 4\n  result4 <- separate_numbers(c(0, 0, 0))\n  stopifnot(identical(result4$pos, numeric(0)),\n            identical(result4$neg, numeric(0)),\n            identical(result4$neither, c(0, 0, 0)))\n  \n  # Test case 5\n  result5 <- separate_numbers(c(-1, -2, -3))\n  stopifnot(identical(result5$pos, numeric(0)),\n            identical(result5$neg, c(-1, -2, -3)),\n            identical(result5$neither, numeric(0)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_separate_numbers()", "output": "separate_numbers"}, "all_code": "# separate_numbers categorizes the elements of a numeric vector into three groups:\n# positive numbers, negative numbers, and zeros.\n# It returns a list containing three vectors: positive, negative, and zeros.\nseparate_numbers <- function(arr) {\n  pos <- arr[arr > 0]\n  neg <- arr[arr < 0]\n  neither <- arr[arr == 0]\n  return(list(pos = pos, neg = neg, neither = neither))\n}\ntest_separate_numbers <- function() {\n  # Test case 1\n  result1 <- separate_numbers(c(1, -2, 3, -4, 0, 5, 0))\n  stopifnot(identical(result1$pos, c(1, 3, 5)),\n            identical(result1$neg, c(-2, -4)),\n            identical(result1$neither, c(0, 0)))\n  \n  # Test case 2\n  result2 <- separate_numbers(c(-1, -2, -3, 0, 0, 0))\n  stopifnot(identical(result2$pos, numeric(0)),\n            identical(result2$neg, c(-1, -2, -3)),\n            identical(result2$neither, c(0, 0, 0)))\n  \n  # Test case 3\n  result3 <- separate_numbers(c(1, 2, 3, 4, 5))\n  stopifnot(identical(result3$pos, c(1, 2, 3, 4, 5)),\n            identical(result3$neg, numeric(0)),\n            identical(result3$neither, numeric(0)))\n  \n  # Test case 4\n  result4 <- separate_numbers(c(0, 0, 0))\n  stopifnot(identical(result4$pos, numeric(0)),\n            identical(result4$neg, numeric(0)),\n            identical(result4$neither, c(0, 0, 0)))\n  \n  # Test case 5\n  result5 <- separate_numbers(c(-1, -2, -3))\n  stopifnot(identical(result5$pos, numeric(0)),\n            identical(result5$neg, c(-1, -2, -3)),\n            identical(result5$neither, numeric(0)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_separate_numbers()", "exec_outcome": "PASSED"}
{"code": "longest_valid_sequence <- function(n, k, arr) {\n  # Initialize deques to store indices of elements in the current window\n  min_deque <- integer(0)\n  max_deque <- integer(0)\n  left <- 1  # R uses 1-based indexing\n  max_len <- 0\n\n  for (right in 1:n) {\n    # Maintain the min_deque: remove elements from the end that are >= current element\n    while (length(min_deque) > 0 && arr[min_deque[length(min_deque)]] >= arr[right]) {\n      min_deque <- min_deque[-length(min_deque)]\n    }\n    min_deque <- c(min_deque, right)\n\n    # Maintain the max_deque: remove elements from the end that are <= current element\n    while (length(max_deque) > 0 && arr[max_deque[length(max_deque)]] <= arr[right]) {\n      max_deque <- max_deque[-length(max_deque)]\n    }\n    max_deque <- c(max_deque, right)\n\n    # Validate the current window: if max - min > k, move left pointer\n    while (arr[max_deque[1]] - arr[min_deque[1]] > k) {\n      left <- left + 1\n      if (min_deque[1] < left) {\n        min_deque <- min_deque[-1]\n      }\n      if (max_deque[1] < left) {\n        max_deque <- max_deque[-1]\n      }\n    }\n\n    # Update the maximum length of valid sequence\n    max_len <- max(max_len, right - left + 1)\n  }\n\n  return(max_len)\n}", "test_cases": "", "test_case_results": "Input: n = 5 , k = 2 , arr = [ 1, 2, 3, 4, 5 ]\nLongest valid sequence length: 3 \nInput: n = 6 , k = 3 , arr = [ 1, 5, 2, 3, 7, 4 ]\nLongest valid sequence length: 3 \nInput: n = 4 , k = 0 , arr = [ 1, 1, 1, 1 ]\nLongest valid sequence length: 4 \nInput: n = 7 , k = 5 , arr = [ 10, 1, 2, 4, 7, 3, 15 ]\nLongest valid sequence length: 4", "task_id": 12110, "assertions": "test_longest_valid_sequence <- function() {\n  stopifnot(longest_valid_sequence(5, 2, c(1, 2, 3, 4, 5)) == 3)\n  stopifnot(longest_valid_sequence(6, 3, c(1, 5, 2, 3, 7, 4)) == 3)\n  stopifnot(longest_valid_sequence(4, 0, c(1, 1, 1, 1)) == 4)\n  stopifnot(longest_valid_sequence(7, 5, c(10, 1, 2, 4, 7, 3, 15)) == 4)\n}\n\ntest_longest_valid_sequence()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_longest_valid_sequence <- function() {\n  stopifnot(longest_valid_sequence(5, 2, c(1, 2, 3, 4, 5)) == 3)\n  stopifnot(longest_valid_sequence(6, 3, c(1, 5, 2, 3, 7, 4)) == 3)\n  stopifnot(longest_valid_sequence(4, 0, c(1, 1, 1, 1)) == 4)\n  stopifnot(longest_valid_sequence(7, 5, c(10, 1, 2, 4, 7, 3, 15)) == 4)\n}\n\ntest_longest_valid_sequence()", "output": "longest_valid_sequence"}, "all_code": "longest_valid_sequence <- function(n, k, arr) {\n  # Initialize deques to store indices of elements in the current window\n  min_deque <- integer(0)\n  max_deque <- integer(0)\n  left <- 1  # R uses 1-based indexing\n  max_len <- 0\n\n  for (right in 1:n) {\n    # Maintain the min_deque: remove elements from the end that are >= current element\n    while (length(min_deque) > 0 && arr[min_deque[length(min_deque)]] >= arr[right]) {\n      min_deque <- min_deque[-length(min_deque)]\n    }\n    min_deque <- c(min_deque, right)\n\n    # Maintain the max_deque: remove elements from the end that are <= current element\n    while (length(max_deque) > 0 && arr[max_deque[length(max_deque)]] <= arr[right]) {\n      max_deque <- max_deque[-length(max_deque)]\n    }\n    max_deque <- c(max_deque, right)\n\n    # Validate the current window: if max - min > k, move left pointer\n    while (arr[max_deque[1]] - arr[min_deque[1]] > k) {\n      left <- left + 1\n      if (min_deque[1] < left) {\n        min_deque <- min_deque[-1]\n      }\n      if (max_deque[1] < left) {\n        max_deque <- max_deque[-1]\n      }\n    }\n\n    # Update the maximum length of valid sequence\n    max_len <- max(max_len, right - left + 1)\n  }\n\n  return(max_len)\n}\ntest_longest_valid_sequence <- function() {\n  stopifnot(longest_valid_sequence(5, 2, c(1, 2, 3, 4, 5)) == 3)\n  stopifnot(longest_valid_sequence(6, 3, c(1, 5, 2, 3, 7, 4)) == 3)\n  stopifnot(longest_valid_sequence(4, 0, c(1, 1, 1, 1)) == 4)\n  stopifnot(longest_valid_sequence(7, 5, c(10, 1, 2, 4, 7, 3, 15)) == 4)\n}\n\ntest_longest_valid_sequence()", "exec_outcome": "PASSED"}
{"code": "# decode_string decodes an encoded string where each digit indicates the number of times \n# the following lowercase letter appears. For example, \"3a2b1c\" is decoded to \"aaabbc\".\n#\n# Parameters:\n# - encoded (str): Encoded string, e.g., \"3a2b1c\".\n#\n# Returns:\n# - str: Decoded string, e.g., \"aaabbc\".\ndecode_string <- function(encoded) {\n    decoded <- character(0)\n    i <- 1\n    length <- nchar(encoded)\n\n    while (i <= length) {\n        # Get the count\n        count <- 0\n        while (i <= length && grepl(\"[0-9]\", substr(encoded, i, i))) {\n            count <- count * 10 + as.integer(substr(encoded, i, i))\n            i <- i + 1\n        }\n        \n        if (i <= length && grepl(\"[a-z]\", substr(encoded, i, i))) {\n            char <- substr(encoded, i, i)\n            decoded <- c(decoded, rep(char, count))\n            i <- i + 1\n        }\n    }\n\n    return(paste(decoded, collapse = \"\"))\n}", "test_cases": "", "test_case_results": "Input:  3a2b1c \nDecoded:  aaabbc \nInput:  10a5b2c \nDecoded:  aaaaaaaaaabbbbbcc \nInput:  1a1b1c \nDecoded:  abc \nInput:  2x3y4z \nDecoded:  xxyyyzzzz \nInput:  0a1b0c \nDecoded:  b", "task_id": 8277, "assertions": "test.decode_string <- function() {\n    stopifnot(decode_string(\"3a2b1c\") == \"aaabbc\")\n    stopifnot(decode_string(\"10a5b2c\") == \"aaaaaaaaaabbbbbcc\")\n    stopifnot(decode_string(\"1a1b1c\") == \"abc\")\n    stopifnot(decode_string(\"2x3y4z\") == \"xxyyyzzzz\")\n    stopifnot(decode_string(\"0a1b0c\") == \"b\")\n}\n\ntest.decode_string()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.decode_string <- function() {\n    stopifnot(decode_string(\"3a2b1c\") == \"aaabbc\")\n    stopifnot(decode_string(\"10a5b2c\") == \"aaaaaaaaaabbbbbcc\")\n    stopifnot(decode_string(\"1a1b1c\") == \"abc\")\n    stopifnot(decode_string(\"2x3y4z\") == \"xxyyyzzzz\")\n    stopifnot(decode_string(\"0a1b0c\") == \"b\")\n}\n\ntest.decode_string()", "output": "decode_string"}, "all_code": "# decode_string decodes an encoded string where each digit indicates the number of times \n# the following lowercase letter appears. For example, \"3a2b1c\" is decoded to \"aaabbc\".\n#\n# Parameters:\n# - encoded (str): Encoded string, e.g., \"3a2b1c\".\n#\n# Returns:\n# - str: Decoded string, e.g., \"aaabbc\".\ndecode_string <- function(encoded) {\n    decoded <- character(0)\n    i <- 1\n    length <- nchar(encoded)\n\n    while (i <= length) {\n        # Get the count\n        count <- 0\n        while (i <= length && grepl(\"[0-9]\", substr(encoded, i, i))) {\n            count <- count * 10 + as.integer(substr(encoded, i, i))\n            i <- i + 1\n        }\n        \n        if (i <= length && grepl(\"[a-z]\", substr(encoded, i, i))) {\n            char <- substr(encoded, i, i)\n            decoded <- c(decoded, rep(char, count))\n            i <- i + 1\n        }\n    }\n\n    return(paste(decoded, collapse = \"\"))\n}\ntest.decode_string <- function() {\n    stopifnot(decode_string(\"3a2b1c\") == \"aaabbc\")\n    stopifnot(decode_string(\"10a5b2c\") == \"aaaaaaaaaabbbbbcc\")\n    stopifnot(decode_string(\"1a1b1c\") == \"abc\")\n    stopifnot(decode_string(\"2x3y4z\") == \"xxyyyzzzz\")\n    stopifnot(decode_string(\"0a1b0c\") == \"b\")\n}\n\ntest.decode_string()", "exec_outcome": "PASSED"}
{"code": "# directed_graph.R\n# This script implements a directed graph data structure in R with functions to add nodes, add edges,\n# and check for the existence of a path between two nodes using depth-first search (DFS).\n\n# The DirectedGraph class is implemented as a list with nodes, edges, and an adjacency list.\n# The functions include:\n# - add_node: Adds a node to the graph if it doesn't already exist.\n# - add_edge: Adds a directed edge between two nodes.\n# - has_path: Checks if there is a path from one node to another using DFS.\n\n# Initialize a new DirectedGraph\nnew_directed_graph <- function(load_dict = list()) {\n  graph <- list(\n    nodes = c(),\n    edges = list(),\n    adjacency_list = list()\n  )\n  \n  # Load the graph from a dictionary if provided\n  if (length(load_dict) > 0 && is.list(load_dict)) {\n    for (vertex in names(load_dict)) {\n      node_from <- add_node(graph, vertex)\n      graph$adjacency_list[[node_from]] <- c()\n      for (neighbor in load_dict[[vertex]]) {\n        node_to <- add_node(graph, neighbor)\n        graph$adjacency_list[[node_from]] <- c(graph$adjacency_list[[node_from]], node_to)\n        graph <- add_edge(graph, vertex, neighbor)\n      }\n    }\n  }\n  \n  return(graph)\n}\n\n# Add a node to the graph if it doesn't already exist\nadd_node <- function(graph, node_name) {\n  if (!(node_name %in% graph$nodes)) {\n    graph$nodes <- c(graph$nodes, node_name)\n  }\n  return(node_name)\n}\n\n# Add a directed edge from node_name_from to node_name_to\nadd_edge <- function(graph, node_name_from, node_name_to) {\n  if (is.null(graph$adjacency_list[[node_name_from]])) {\n    graph$adjacency_list[[node_name_from]] <- c()\n  }\n  if (!(node_name_to %in% graph$adjacency_list[[node_name_from]])) {\n    graph$adjacency_list[[node_name_from]] <- c(graph$adjacency_list[[node_name_from]], node_name_to)\n    graph$edges[[length(graph$edges) + 1]] <- c(node_name_from, node_name_to)\n  }\n  return(graph)\n}\n\n# Check if there is a path from start_node to end_node using DFS\nhas_path <- function(graph, start_node, end_node) {\n  visited <- c()\n  \n  dfs <- function(node) {\n    if (node %in% visited) {\n      return(FALSE)\n    }\n    if (node == end_node) {\n      return(TRUE)\n    }\n    visited <<- c(visited, node)\n    for (neighbor in graph$adjacency_list[[node]]) {\n      if (dfs(neighbor)) {\n        return(TRUE)\n      }\n    }\n    return(FALSE)\n  }\n  \n  return(dfs(start_node))\n}", "test_cases": "", "test_case_results": "Test case 1: Simple graph with a direct path (A -> B -> C)\nInput: start_node = 'A', end_node = 'C'\nResult:  TRUE \n\nTest case 2: Graph with no path between nodes (A -> B and C -> D)\nInput: start_node = 'A', end_node = 'D'\nResult:  FALSE \n\nTest case 3: Graph loaded from a dictionary\nInput: start_node = 'A', end_node = 'D'\nResult:  TRUE \n\nTest case 4: Graph with a cycle (A -> B -> C -> A)\nInput: start_node = 'A', end_node = 'C'\nResult:  TRUE", "task_id": 23331, "assertions": "test_directed_graph <- function() {\n  # Test case 1: Simple graph with a direct path\n  graph1 <- new_directed_graph()\n  graph1 <- add_edge(graph1, \"A\", \"B\")\n  graph1 <- add_edge(graph1, \"B\", \"C\")\n  stopifnot(has_path(graph1, \"A\", \"C\") == TRUE)\n  \n  # Test case 2: Graph with no path between nodes\n  graph2 <- new_directed_graph()\n  graph2 <- add_edge(graph2, \"A\", \"B\")\n  graph2 <- add_edge(graph2, \"C\", \"D\")\n  stopifnot(has_path(graph2, \"A\", \"D\") == FALSE)\n  \n  # Test case 3: Graph loaded from a dictionary\n  load_dict <- list(\n    \"A\" = c(\"B\", \"C\"),\n    \"B\" = c(\"D\"),\n    \"C\" = c(\"E\"),\n    \"E\" = c(\"D\")\n  )\n  graph3 <- new_directed_graph(load_dict)\n  stopifnot(has_path(graph3, \"A\", \"D\") == TRUE)\n  \n  # Test case 4: Graph with a cycle\n  graph4 <- new_directed_graph()\n  graph4 <- add_edge(graph4, \"A\", \"B\")\n  graph4 <- add_edge(graph4, \"B\", \"C\")\n  graph4 <- add_edge(graph4, \"C\", \"A\")\n  stopifnot(has_path(graph4, \"A\", \"C\") == TRUE)\n}\n\ntest_directed_graph()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_directed_graph <- function() {\n  # Test case 1: Simple graph with a direct path\n  graph1 <- new_directed_graph()\n  graph1 <- add_edge(graph1, \"A\", \"B\")\n  graph1 <- add_edge(graph1, \"B\", \"C\")\n  stopifnot(has_path(graph1, \"A\", \"C\") == TRUE)\n  \n  # Test case 2: Graph with no path between nodes\n  graph2 <- new_directed_graph()\n  graph2 <- add_edge(graph2, \"A\", \"B\")\n  graph2 <- add_edge(graph2, \"C\", \"D\")\n  stopifnot(has_path(graph2, \"A\", \"D\") == FALSE)\n  \n  # Test case 3: Graph loaded from a dictionary\n  load_dict <- list(\n    \"A\" = c(\"B\", \"C\"),\n    \"B\" = c(\"D\"),\n    \"C\" = c(\"E\"),\n    \"E\" = c(\"D\")\n  )\n  graph3 <- new_directed_graph(load_dict)\n  stopifnot(has_path(graph3, \"A\", \"D\") == TRUE)\n  \n  # Test case 4: Graph with a cycle\n  graph4 <- new_directed_graph()\n  graph4 <- add_edge(graph4, \"A\", \"B\")\n  graph4 <- add_edge(graph4, \"B\", \"C\")\n  graph4 <- add_edge(graph4, \"C\", \"A\")\n  stopifnot(has_path(graph4, \"A\", \"C\") == TRUE)\n}\n\ntest_directed_graph()", "output": "has_path"}, "all_code": "# directed_graph.R\n# This script implements a directed graph data structure in R with functions to add nodes, add edges,\n# and check for the existence of a path between two nodes using depth-first search (DFS).\n\n# The DirectedGraph class is implemented as a list with nodes, edges, and an adjacency list.\n# The functions include:\n# - add_node: Adds a node to the graph if it doesn't already exist.\n# - add_edge: Adds a directed edge between two nodes.\n# - has_path: Checks if there is a path from one node to another using DFS.\n\n# Initialize a new DirectedGraph\nnew_directed_graph <- function(load_dict = list()) {\n  graph <- list(\n    nodes = c(),\n    edges = list(),\n    adjacency_list = list()\n  )\n  \n  # Load the graph from a dictionary if provided\n  if (length(load_dict) > 0 && is.list(load_dict)) {\n    for (vertex in names(load_dict)) {\n      node_from <- add_node(graph, vertex)\n      graph$adjacency_list[[node_from]] <- c()\n      for (neighbor in load_dict[[vertex]]) {\n        node_to <- add_node(graph, neighbor)\n        graph$adjacency_list[[node_from]] <- c(graph$adjacency_list[[node_from]], node_to)\n        graph <- add_edge(graph, vertex, neighbor)\n      }\n    }\n  }\n  \n  return(graph)\n}\n\n# Add a node to the graph if it doesn't already exist\nadd_node <- function(graph, node_name) {\n  if (!(node_name %in% graph$nodes)) {\n    graph$nodes <- c(graph$nodes, node_name)\n  }\n  return(node_name)\n}\n\n# Add a directed edge from node_name_from to node_name_to\nadd_edge <- function(graph, node_name_from, node_name_to) {\n  if (is.null(graph$adjacency_list[[node_name_from]])) {\n    graph$adjacency_list[[node_name_from]] <- c()\n  }\n  if (!(node_name_to %in% graph$adjacency_list[[node_name_from]])) {\n    graph$adjacency_list[[node_name_from]] <- c(graph$adjacency_list[[node_name_from]], node_name_to)\n    graph$edges[[length(graph$edges) + 1]] <- c(node_name_from, node_name_to)\n  }\n  return(graph)\n}\n\n# Check if there is a path from start_node to end_node using DFS\nhas_path <- function(graph, start_node, end_node) {\n  visited <- c()\n  \n  dfs <- function(node) {\n    if (node %in% visited) {\n      return(FALSE)\n    }\n    if (node == end_node) {\n      return(TRUE)\n    }\n    visited <<- c(visited, node)\n    for (neighbor in graph$adjacency_list[[node]]) {\n      if (dfs(neighbor)) {\n        return(TRUE)\n      }\n    }\n    return(FALSE)\n  }\n  \n  return(dfs(start_node))\n}\ntest_directed_graph <- function() {\n  # Test case 1: Simple graph with a direct path\n  graph1 <- new_directed_graph()\n  graph1 <- add_edge(graph1, \"A\", \"B\")\n  graph1 <- add_edge(graph1, \"B\", \"C\")\n  stopifnot(has_path(graph1, \"A\", \"C\") == TRUE)\n  \n  # Test case 2: Graph with no path between nodes\n  graph2 <- new_directed_graph()\n  graph2 <- add_edge(graph2, \"A\", \"B\")\n  graph2 <- add_edge(graph2, \"C\", \"D\")\n  stopifnot(has_path(graph2, \"A\", \"D\") == FALSE)\n  \n  # Test case 3: Graph loaded from a dictionary\n  load_dict <- list(\n    \"A\" = c(\"B\", \"C\"),\n    \"B\" = c(\"D\"),\n    \"C\" = c(\"E\"),\n    \"E\" = c(\"D\")\n  )\n  graph3 <- new_directed_graph(load_dict)\n  stopifnot(has_path(graph3, \"A\", \"D\") == TRUE)\n  \n  # Test case 4: Graph with a cycle\n  graph4 <- new_directed_graph()\n  graph4 <- add_edge(graph4, \"A\", \"B\")\n  graph4 <- add_edge(graph4, \"B\", \"C\")\n  graph4 <- add_edge(graph4, \"C\", \"A\")\n  stopifnot(has_path(graph4, \"A\", \"C\") == TRUE)\n}\n\ntest_directed_graph()", "exec_outcome": "PASSED"}
{"code": "# manage_book_loans processes a list of book loan operations and returns the final set of books each member has borrowed.\n# The function takes a list of operations, where each operation is a list with 'member', 'action', and 'book_id' elements.\n# It returns a named list where each name is a member and the value is a vector of book identifiers they have borrowed.\n# Members can borrow up to 3 books at a time. Borrowing beyond this limit is ignored.\n# Returning a book removes it from the member's borrowed list.\nmanage_book_loans <- function(operations) {\n  member_books <- list()\n\n  for (operation in operations) {\n    member <- operation$member\n    action <- operation$action\n    book_id <- operation$book_id\n\n    if (!(member %in% names(member_books))) {\n      member_books[[member]] <- character(0)\n    }\n\n    if (action == 'borrow') {\n      if (length(member_books[[member]]) < 3) {\n        member_books[[member]] <- c(member_books[[member]], book_id)\n      }\n    } else if (action == 'return') {\n      member_books[[member]] <- setdiff(member_books[[member]], book_id)\n    }\n  }\n\n  return(member_books)\n}", "test_cases": "", "test_case_results": "Test Case  1 :\nInput Operations:\n  Member:  Alice , Action:  borrow , Book ID:  B001 \n  Member:  Bob , Action:  borrow , Book ID:  B002 \n  Member:  Alice , Action:  borrow , Book ID:  B003 \n  Member:  Alice , Action:  return , Book ID:  B001 \n  Member:  Bob , Action:  borrow , Book ID:  B004 \n  Member:  Alice , Action:  borrow , Book ID:  B005 \n  Member:  Alice , Action:  borrow , Book ID:  B006 \nResult:\n   Alice :  B003, B005, B006 \n   Bob :  B002, B004 \n\nTest Case  2 :\nInput Operations:\n  Member:  Charlie , Action:  borrow , Book ID:  B007 \n  Member:  Charlie , Action:  borrow , Book ID:  B008 \n  Member:  Charlie , Action:  return , Book ID:  B007 \n  Member:  Charlie , Action:  borrow , Book ID:  B009 \n  Member:  Charlie , Action:  borrow , Book ID:  B010 \nResult:\n   Charlie :  B008, B009, B010 \n\nTest Case  3 :\nInput Operations:\nResult:", "task_id": 22059, "assertions": "test_book_loans <- function() {\n    # Test Case 1\n    operations1 <- list(\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B002\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B003\"),\n        list(member = \"Alice\", action = \"return\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B004\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B005\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B006\")  # Should be ignored (limit reached)\n    )\n    result1 <- manage_book_loans(operations1)\n    stopifnot(identical(result1$Alice, c(\"B003\", \"B005\", \"B006\")))\n    stopifnot(identical(result1$Bob, c(\"B002\", \"B004\")))\n    \n    # Test Case 2\n    operations2 <- list(\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B008\"),\n        list(member = \"Charlie\", action = \"return\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B009\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B010\")\n    )\n    result2 <- manage_book_loans(operations2)\n    stopifnot(identical(result2$Charlie, c(\"B008\", \"B009\", \"B010\")))\n    \n    # Test Case 3 (Edge case: no operations)\n    operations3 <- list()\n    result3 <- manage_book_loans(operations3)\n    stopifnot(identical(result3, list()))\n}\n\ntest_book_loans()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_book_loans <- function() {\n    # Test Case 1\n    operations1 <- list(\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B002\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B003\"),\n        list(member = \"Alice\", action = \"return\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B004\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B005\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B006\")  # Should be ignored (limit reached)\n    )\n    result1 <- manage_book_loans(operations1)\n    stopifnot(identical(result1$Alice, c(\"B003\", \"B005\", \"B006\")))\n    stopifnot(identical(result1$Bob, c(\"B002\", \"B004\")))\n    \n    # Test Case 2\n    operations2 <- list(\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B008\"),\n        list(member = \"Charlie\", action = \"return\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B009\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B010\")\n    )\n    result2 <- manage_book_loans(operations2)\n    stopifnot(identical(result2$Charlie, c(\"B008\", \"B009\", \"B010\")))\n    \n    # Test Case 3 (Edge case: no operations)\n    operations3 <- list()\n    result3 <- manage_book_loans(operations3)\n    stopifnot(identical(result3, list()))\n}\n\ntest_book_loans()", "output": "manage_book_loans"}, "all_code": "# manage_book_loans processes a list of book loan operations and returns the final set of books each member has borrowed.\n# The function takes a list of operations, where each operation is a list with 'member', 'action', and 'book_id' elements.\n# It returns a named list where each name is a member and the value is a vector of book identifiers they have borrowed.\n# Members can borrow up to 3 books at a time. Borrowing beyond this limit is ignored.\n# Returning a book removes it from the member's borrowed list.\nmanage_book_loans <- function(operations) {\n  member_books <- list()\n\n  for (operation in operations) {\n    member <- operation$member\n    action <- operation$action\n    book_id <- operation$book_id\n\n    if (!(member %in% names(member_books))) {\n      member_books[[member]] <- character(0)\n    }\n\n    if (action == 'borrow') {\n      if (length(member_books[[member]]) < 3) {\n        member_books[[member]] <- c(member_books[[member]], book_id)\n      }\n    } else if (action == 'return') {\n      member_books[[member]] <- setdiff(member_books[[member]], book_id)\n    }\n  }\n\n  return(member_books)\n}\ntest_book_loans <- function() {\n    # Test Case 1\n    operations1 <- list(\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B002\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B003\"),\n        list(member = \"Alice\", action = \"return\", book_id = \"B001\"),\n        list(member = \"Bob\", action = \"borrow\", book_id = \"B004\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B005\"),\n        list(member = \"Alice\", action = \"borrow\", book_id = \"B006\")  # Should be ignored (limit reached)\n    )\n    result1 <- manage_book_loans(operations1)\n    stopifnot(identical(result1$Alice, c(\"B003\", \"B005\", \"B006\")))\n    stopifnot(identical(result1$Bob, c(\"B002\", \"B004\")))\n    \n    # Test Case 2\n    operations2 <- list(\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B008\"),\n        list(member = \"Charlie\", action = \"return\", book_id = \"B007\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B009\"),\n        list(member = \"Charlie\", action = \"borrow\", book_id = \"B010\")\n    )\n    result2 <- manage_book_loans(operations2)\n    stopifnot(identical(result2$Charlie, c(\"B008\", \"B009\", \"B010\")))\n    \n    # Test Case 3 (Edge case: no operations)\n    operations3 <- list()\n    result3 <- manage_book_loans(operations3)\n    stopifnot(identical(result3, list()))\n}\n\ntest_book_loans()", "exec_outcome": "PASSED"}
{"code": "weather_report <- function(data) {\n  if (length(data) == 0) {\n    return(list(\n      hottest_city = NULL,\n      coldest_city = NULL,\n      average_temperature = NULL,\n      most_humid_city = NULL,\n      least_humid_city = NULL\n    ))\n  }\n  \n  # Filter valid entries (must have city, temperature, and humidity)\n  valid_entries <- data[sapply(data, function(x) {\n    all(c(\"city\", \"temperature\", \"humidity\") %in% names(x))\n  })]\n  \n  if (length(valid_entries) == 0) {\n    return(list(\n      hottest_city = NULL,\n      coldest_city = NULL,\n      average_temperature = NULL,\n      most_humid_city = NULL,\n      least_humid_city = NULL\n    ))\n  }\n  \n  # Extract temperatures and humidities for calculations\n  temperatures <- sapply(valid_entries, function(x) x$temperature)\n  humidities <- sapply(valid_entries, function(x) x$humidity)\n  cities <- sapply(valid_entries, function(x) x$city)\n  \n  hottest_city <- cities[which.max(temperatures)]\n  coldest_city <- cities[which.min(temperatures)]\n  average_temperature <- round(mean(temperatures), 1)\n  most_humid_city <- cities[which.max(humidities)]\n  least_humid_city <- cities[which.min(humidities)]\n  \n  return(list(\n    hottest_city = hottest_city,\n    coldest_city = coldest_city,\n    average_temperature = average_temperature,\n    most_humid_city = most_humid_city,\n    least_humid_city = least_humid_city\n  ))\n}", "test_cases": "", "test_case_results": "Test case 1:\nInput data:\n[[1]]\n[[1]]$city\n[1] \"New York\"\n\n[[1]]$temperature\n[1] 65\n\n[[1]]$humidity\n[1] 60\n\n\n[[2]]\n[[2]]$city\n[1] \"Los Angeles\"\n\n[[2]]$temperature\n[1] 80\n\n[[2]]$humidity\n[1] 50\n\n\n[[3]]\n[[3]]$city\n[1] \"Chicago\"\n\n[[3]]$temperature\n[1] 50\n\n[[3]]$humidity\n[1] 70\n\n\n[[4]]\n[[4]]$city\n[1] \"Houston\"\n\n[[4]]$temperature\n[1] 90\n\n[[4]]$humidity\n[1] 75\n\n\n\nResults:\nHottest city: Houston\nColdest city: Chicago\nAverage temperature: 71.2\nMost humid city: Houston\nLeast humid city: Los Angeles\n\nTest case 2:\nInput data:\nlist()\n\nResults:\nHottest city: NULL\nColdest city: NULL\nAverage temperature: NULL\nMost humid city: NULL\nLeast humid city: NULL\n\nTest case 3:\nInput data:\n[[1]]\n[[1]]$city\n[1] \"Seattle\"\n\n[[1]]$humidity\n[1] 65\n\n\n[[2]]\n[[2]]$temperature\n[1] 60\n\n[[2]]$humidity\n[1] 55\n\n\n[[3]]\n[[3]]$city\n[1] \"Boston\"\n\n[[3]]$temperature\n[1] 45\n\n\n\nResults:\nHottest city: NULL\nColdest city: NULL\nAverage temperature: NULL\nMost humid city: NULL\nLeast humid city: NULL\n\nTest case 4:\nInput data:\n[[1]]\n[[1]]$city\n[1] \"Miami\"\n\n[[1]]$temperature\n[1] 85\n\n[[1]]$humidity\n[1] 80\n\n\n\nResults:\nHottest city: Miami\nColdest city: Miami\nAverage temperature: 85\nMost humid city: Miami\nLeast humid city: Miami", "task_id": 16547, "assertions": "test_weather_report <- function() {\n  # Test case 1: Normal case with multiple cities\n  test_case1 <- list(\n    list(city = \"New York\", temperature = 65, humidity = 60),\n    list(city = \"Los Angeles\", temperature = 80, humidity = 50),\n    list(city = \"Chicago\", temperature = 50, humidity = 70),\n    list(city = \"Houston\", temperature = 90, humidity = 75)\n  )\n  result1 <- weather_report(test_case1)\n  stopifnot(result1$hottest_city == \"Houston\")\n  stopifnot(result1$coldest_city == \"Chicago\")\n  stopifnot(result1$average_temperature == 71.2)\n  stopifnot(result1$most_humid_city == \"Houston\")\n  stopifnot(result1$least_humid_city == \"Los Angeles\")\n  \n  # Test case 2: Empty list\n  test_case2 <- list()\n  result2 <- weather_report(test_case2)\n  stopifnot(is.null(result2$hottest_city))\n  stopifnot(is.null(result2$coldest_city))\n  stopifnot(is.null(result2$average_temperature))\n  stopifnot(is.null(result2$most_humid_city))\n  stopifnot(is.null(result2$least_humid_city))\n  \n  # Test case 3: Invalid entries (missing fields)\n  test_case3 <- list(\n    list(city = \"Seattle\", humidity = 65),\n    list(temperature = 60, humidity = 55),\n    list(city = \"Boston\", temperature = 45)\n  )\n  result3 <- weather_report(test_case3)\n  stopifnot(is.null(result3$hottest_city))\n  stopifnot(is.null(result3$coldest_city))\n  stopifnot(is.null(result3$average_temperature))\n  stopifnot(is.null(result3$most_humid_city))\n  stopifnot(is.null(result3$least_humid_city))\n  \n  # Test case 4: Single city\n  test_case4 <- list(\n    list(city = \"Miami\", temperature = 85, humidity = 80)\n  )\n  result4 <- weather_report(test_case4)\n  stopifnot(result4$hottest_city == \"Miami\")\n  stopifnot(result4$coldest_city == \"Miami\")\n  stopifnot(result4$average_temperature == 85)\n  stopifnot(result4$most_humid_city == \"Miami\")\n  stopifnot(result4$least_humid_city == \"Miami\")\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_weather_report()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_weather_report <- function() {\n  # Test case 1: Normal case with multiple cities\n  test_case1 <- list(\n    list(city = \"New York\", temperature = 65, humidity = 60),\n    list(city = \"Los Angeles\", temperature = 80, humidity = 50),\n    list(city = \"Chicago\", temperature = 50, humidity = 70),\n    list(city = \"Houston\", temperature = 90, humidity = 75)\n  )\n  result1 <- weather_report(test_case1)\n  stopifnot(result1$hottest_city == \"Houston\")\n  stopifnot(result1$coldest_city == \"Chicago\")\n  stopifnot(result1$average_temperature == 71.2)\n  stopifnot(result1$most_humid_city == \"Houston\")\n  stopifnot(result1$least_humid_city == \"Los Angeles\")\n  \n  # Test case 2: Empty list\n  test_case2 <- list()\n  result2 <- weather_report(test_case2)\n  stopifnot(is.null(result2$hottest_city))\n  stopifnot(is.null(result2$coldest_city))\n  stopifnot(is.null(result2$average_temperature))\n  stopifnot(is.null(result2$most_humid_city))\n  stopifnot(is.null(result2$least_humid_city))\n  \n  # Test case 3: Invalid entries (missing fields)\n  test_case3 <- list(\n    list(city = \"Seattle\", humidity = 65),\n    list(temperature = 60, humidity = 55),\n    list(city = \"Boston\", temperature = 45)\n  )\n  result3 <- weather_report(test_case3)\n  stopifnot(is.null(result3$hottest_city))\n  stopifnot(is.null(result3$coldest_city))\n  stopifnot(is.null(result3$average_temperature))\n  stopifnot(is.null(result3$most_humid_city))\n  stopifnot(is.null(result3$least_humid_city))\n  \n  # Test case 4: Single city\n  test_case4 <- list(\n    list(city = \"Miami\", temperature = 85, humidity = 80)\n  )\n  result4 <- weather_report(test_case4)\n  stopifnot(result4$hottest_city == \"Miami\")\n  stopifnot(result4$coldest_city == \"Miami\")\n  stopifnot(result4$average_temperature == 85)\n  stopifnot(result4$most_humid_city == \"Miami\")\n  stopifnot(result4$least_humid_city == \"Miami\")\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_weather_report()", "output": "weather_report"}, "all_code": "weather_report <- function(data) {\n  if (length(data) == 0) {\n    return(list(\n      hottest_city = NULL,\n      coldest_city = NULL,\n      average_temperature = NULL,\n      most_humid_city = NULL,\n      least_humid_city = NULL\n    ))\n  }\n  \n  # Filter valid entries (must have city, temperature, and humidity)\n  valid_entries <- data[sapply(data, function(x) {\n    all(c(\"city\", \"temperature\", \"humidity\") %in% names(x))\n  })]\n  \n  if (length(valid_entries) == 0) {\n    return(list(\n      hottest_city = NULL,\n      coldest_city = NULL,\n      average_temperature = NULL,\n      most_humid_city = NULL,\n      least_humid_city = NULL\n    ))\n  }\n  \n  # Extract temperatures and humidities for calculations\n  temperatures <- sapply(valid_entries, function(x) x$temperature)\n  humidities <- sapply(valid_entries, function(x) x$humidity)\n  cities <- sapply(valid_entries, function(x) x$city)\n  \n  hottest_city <- cities[which.max(temperatures)]\n  coldest_city <- cities[which.min(temperatures)]\n  average_temperature <- round(mean(temperatures), 1)\n  most_humid_city <- cities[which.max(humidities)]\n  least_humid_city <- cities[which.min(humidities)]\n  \n  return(list(\n    hottest_city = hottest_city,\n    coldest_city = coldest_city,\n    average_temperature = average_temperature,\n    most_humid_city = most_humid_city,\n    least_humid_city = least_humid_city\n  ))\n}\ntest_weather_report <- function() {\n  # Test case 1: Normal case with multiple cities\n  test_case1 <- list(\n    list(city = \"New York\", temperature = 65, humidity = 60),\n    list(city = \"Los Angeles\", temperature = 80, humidity = 50),\n    list(city = \"Chicago\", temperature = 50, humidity = 70),\n    list(city = \"Houston\", temperature = 90, humidity = 75)\n  )\n  result1 <- weather_report(test_case1)\n  stopifnot(result1$hottest_city == \"Houston\")\n  stopifnot(result1$coldest_city == \"Chicago\")\n  stopifnot(result1$average_temperature == 71.2)\n  stopifnot(result1$most_humid_city == \"Houston\")\n  stopifnot(result1$least_humid_city == \"Los Angeles\")\n  \n  # Test case 2: Empty list\n  test_case2 <- list()\n  result2 <- weather_report(test_case2)\n  stopifnot(is.null(result2$hottest_city))\n  stopifnot(is.null(result2$coldest_city))\n  stopifnot(is.null(result2$average_temperature))\n  stopifnot(is.null(result2$most_humid_city))\n  stopifnot(is.null(result2$least_humid_city))\n  \n  # Test case 3: Invalid entries (missing fields)\n  test_case3 <- list(\n    list(city = \"Seattle\", humidity = 65),\n    list(temperature = 60, humidity = 55),\n    list(city = \"Boston\", temperature = 45)\n  )\n  result3 <- weather_report(test_case3)\n  stopifnot(is.null(result3$hottest_city))\n  stopifnot(is.null(result3$coldest_city))\n  stopifnot(is.null(result3$average_temperature))\n  stopifnot(is.null(result3$most_humid_city))\n  stopifnot(is.null(result3$least_humid_city))\n  \n  # Test case 4: Single city\n  test_case4 <- list(\n    list(city = \"Miami\", temperature = 85, humidity = 80)\n  )\n  result4 <- weather_report(test_case4)\n  stopifnot(result4$hottest_city == \"Miami\")\n  stopifnot(result4$coldest_city == \"Miami\")\n  stopifnot(result4$average_temperature == 85)\n  stopifnot(result4$most_humid_city == \"Miami\")\n  stopifnot(result4$least_humid_city == \"Miami\")\n  \n  cat(\"All tests passed successfully!\\n\")\n}\n\ntest_weather_report()", "exec_outcome": "PASSED"}
{"code": "# max_road_distance calculates the maximum consecutive 'R's in each row of a grid.\n# It iterates through each row of the grid, counting consecutive 'R's and updating the maximum count found.\n# The function returns the maximum count of consecutive 'R's across all rows.\n# Parameters:\n#   n: Number of rows in the grid (not used in the function, but kept for consistency with the original)\n#   m: Number of columns in the grid (not used in the function, but kept for consistency with the original)\n#   grid: A list of strings, where each string represents a row in the grid\n# Returns:\n#   The maximum number of consecutive 'R's in the grid\nmax_road_distance <- function(n, m, grid) {\n  max_distance <- 0\n  for (row in grid) {\n    current_distance <- 0\n    for (cell in strsplit(row, \"\")[[1]]) {\n      if (cell == 'R') {\n        current_distance <- current_distance + 1\n        max_distance <- max(max_distance, current_distance)\n      } else {\n        current_distance <- 0\n      }\n    }\n  }\n  return(max_distance)\n}", "test_cases": "", "test_case_results": "Input Grid:\nRRR \nR.R \nRR. \nMaximum consecutive 'R's:  3 \n\nInput Grid:\nR.R.R \n.RRRR \nMaximum consecutive 'R's:  4 \n\nInput Grid:\nR... \n.R.. \n..R. \n...R \nMaximum consecutive 'R's:  1 \n\nInput Grid:\nR \nMaximum consecutive 'R's:  1 \n\nInput Grid:\n. \nMaximum consecutive 'R's:  0", "task_id": 9694, "assertions": "test_max_road_distance <- function() {\n  # Test case 1\n  stopifnot(max_road_distance(3, 3, c(\"RRR\", \"R.R\", \"RR.\")) == 3)\n  \n  # Test case 2\n  stopifnot(max_road_distance(2, 5, c(\"R.R.R\", \".RRRR\")) == 4)\n  \n  # Test case 3\n  stopifnot(max_road_distance(4, 4, c(\"R...\", \".R..\", \"..R.\", \"...R\")) == 1)\n  \n  # Test case 4\n  stopifnot(max_road_distance(1, 1, c(\"R\")) == 1)\n  \n  # Test case 5\n  stopifnot(max_road_distance(1, 1, c(\".\")) == 0)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_max_road_distance()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_road_distance <- function() {\n  # Test case 1\n  stopifnot(max_road_distance(3, 3, c(\"RRR\", \"R.R\", \"RR.\")) == 3)\n  \n  # Test case 2\n  stopifnot(max_road_distance(2, 5, c(\"R.R.R\", \".RRRR\")) == 4)\n  \n  # Test case 3\n  stopifnot(max_road_distance(4, 4, c(\"R...\", \".R..\", \"..R.\", \"...R\")) == 1)\n  \n  # Test case 4\n  stopifnot(max_road_distance(1, 1, c(\"R\")) == 1)\n  \n  # Test case 5\n  stopifnot(max_road_distance(1, 1, c(\".\")) == 0)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_max_road_distance()", "output": "max_road_distance"}, "all_code": "# max_road_distance calculates the maximum consecutive 'R's in each row of a grid.\n# It iterates through each row of the grid, counting consecutive 'R's and updating the maximum count found.\n# The function returns the maximum count of consecutive 'R's across all rows.\n# Parameters:\n#   n: Number of rows in the grid (not used in the function, but kept for consistency with the original)\n#   m: Number of columns in the grid (not used in the function, but kept for consistency with the original)\n#   grid: A list of strings, where each string represents a row in the grid\n# Returns:\n#   The maximum number of consecutive 'R's in the grid\nmax_road_distance <- function(n, m, grid) {\n  max_distance <- 0\n  for (row in grid) {\n    current_distance <- 0\n    for (cell in strsplit(row, \"\")[[1]]) {\n      if (cell == 'R') {\n        current_distance <- current_distance + 1\n        max_distance <- max(max_distance, current_distance)\n      } else {\n        current_distance <- 0\n      }\n    }\n  }\n  return(max_distance)\n}\ntest_max_road_distance <- function() {\n  # Test case 1\n  stopifnot(max_road_distance(3, 3, c(\"RRR\", \"R.R\", \"RR.\")) == 3)\n  \n  # Test case 2\n  stopifnot(max_road_distance(2, 5, c(\"R.R.R\", \".RRRR\")) == 4)\n  \n  # Test case 3\n  stopifnot(max_road_distance(4, 4, c(\"R...\", \".R..\", \"..R.\", \"...R\")) == 1)\n  \n  # Test case 4\n  stopifnot(max_road_distance(1, 1, c(\"R\")) == 1)\n  \n  # Test case 5\n  stopifnot(max_road_distance(1, 1, c(\".\")) == 0)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_max_road_distance()", "exec_outcome": "PASSED"}
{"code": "# stock_price_tracker is a collection of functions that simulate a stock price tracker.\n# It allows updating stock prices with timestamps, and retrieving the current, maximum, and minimum prices.\n# The implementation uses a list to store timestamp-price pairs and keeps track of the current, max, and min prices.\n\n# Initialize a new stock price tracker\nnew_stock_price_tracker <- function() {\n  list(\n    timestamp_to_price = list(),\n    current_time = -1,\n    current_price = 0.0,\n    min_price = Inf,\n    max_price = -Inf\n  )\n}\n\n# Update the stock price tracker with a new timestamp and price\nupdate_stock_price <- function(tracker, timestamp, price) {\n  tracker$timestamp_to_price[[as.character(timestamp)]] <- price\n  \n  if (timestamp >= tracker$current_time) {\n    tracker$current_time <- timestamp\n    tracker$current_price <- price\n  }\n  \n  if (price < tracker$min_price) {\n    tracker$min_price = price\n  }\n  \n  if (price > tracker$max_price) {\n    tracker$max_price = price\n  }\n  \n  tracker\n}\n\n# Get the current stock price\nget_current_price <- function(tracker) {\n  tracker$current_price\n}\n\n# Get the maximum stock price\nget_maximum_price <- function(tracker) {\n  max(unlist(tracker$timestamp_to_price))\n}\n\n# Get the minimum stock price\nget_minimum_price <- function(tracker) {\n  min(unlist(tracker$timestamp_to_price))\n}", "test_cases": "", "test_case_results": "After update (1, 10):\nCurrent:  10 \nMaximum:  10 \nMinimum:  10 \n\nAfter update (2, 5):\nCurrent:  5 \nMaximum:  10 \nMinimum:  5 \n\nAfter update (1, 3):\nCurrent:  5 \nMaximum:  5 \nMinimum:  3 \n\nAfter update (4, 15):\nCurrent:  15 \nMaximum:  15 \nMinimum:  3", "task_id": 20362, "assertions": "test_stock_price_tracker <- function() {\n  # Initialize tracker\n  tracker <- new_stock_price_tracker()\n  \n  # Test case 1: Update with timestamp 1 and price 10\n  tracker <- update_stock_price(tracker, 1, 10)\n  stopifnot(get_current_price(tracker) == 10)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 10)\n  \n  # Test case 2: Update with timestamp 2 and price 5\n  tracker <- update_stock_price(tracker, 2, 5)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 5)\n  \n  # Test case 3: Update with timestamp 1 and price 3 (older timestamp)\n  tracker <- update_stock_price(tracker, 1, 3)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 5)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  # Test case 4: Update with timestamp 4 and price 15\n  tracker <- update_stock_price(tracker, 4, 15)\n  stopifnot(get_current_price(tracker) == 15)\n  stopifnot(get_maximum_price(tracker) == 15)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_stock_price_tracker()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_stock_price_tracker <- function() {\n  # Initialize tracker\n  tracker <- new_stock_price_tracker()\n  \n  # Test case 1: Update with timestamp 1 and price 10\n  tracker <- update_stock_price(tracker, 1, 10)\n  stopifnot(get_current_price(tracker) == 10)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 10)\n  \n  # Test case 2: Update with timestamp 2 and price 5\n  tracker <- update_stock_price(tracker, 2, 5)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 5)\n  \n  # Test case 3: Update with timestamp 1 and price 3 (older timestamp)\n  tracker <- update_stock_price(tracker, 1, 3)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 5)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  # Test case 4: Update with timestamp 4 and price 15\n  tracker <- update_stock_price(tracker, 4, 15)\n  stopifnot(get_current_price(tracker) == 15)\n  stopifnot(get_maximum_price(tracker) == 15)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_stock_price_tracker()", "output": "update_stock_price"}, "all_code": "# stock_price_tracker is a collection of functions that simulate a stock price tracker.\n# It allows updating stock prices with timestamps, and retrieving the current, maximum, and minimum prices.\n# The implementation uses a list to store timestamp-price pairs and keeps track of the current, max, and min prices.\n\n# Initialize a new stock price tracker\nnew_stock_price_tracker <- function() {\n  list(\n    timestamp_to_price = list(),\n    current_time = -1,\n    current_price = 0.0,\n    min_price = Inf,\n    max_price = -Inf\n  )\n}\n\n# Update the stock price tracker with a new timestamp and price\nupdate_stock_price <- function(tracker, timestamp, price) {\n  tracker$timestamp_to_price[[as.character(timestamp)]] <- price\n  \n  if (timestamp >= tracker$current_time) {\n    tracker$current_time <- timestamp\n    tracker$current_price <- price\n  }\n  \n  if (price < tracker$min_price) {\n    tracker$min_price = price\n  }\n  \n  if (price > tracker$max_price) {\n    tracker$max_price = price\n  }\n  \n  tracker\n}\n\n# Get the current stock price\nget_current_price <- function(tracker) {\n  tracker$current_price\n}\n\n# Get the maximum stock price\nget_maximum_price <- function(tracker) {\n  max(unlist(tracker$timestamp_to_price))\n}\n\n# Get the minimum stock price\nget_minimum_price <- function(tracker) {\n  min(unlist(tracker$timestamp_to_price))\n}\ntest_stock_price_tracker <- function() {\n  # Initialize tracker\n  tracker <- new_stock_price_tracker()\n  \n  # Test case 1: Update with timestamp 1 and price 10\n  tracker <- update_stock_price(tracker, 1, 10)\n  stopifnot(get_current_price(tracker) == 10)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 10)\n  \n  # Test case 2: Update with timestamp 2 and price 5\n  tracker <- update_stock_price(tracker, 2, 5)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 10)\n  stopifnot(get_minimum_price(tracker) == 5)\n  \n  # Test case 3: Update with timestamp 1 and price 3 (older timestamp)\n  tracker <- update_stock_price(tracker, 1, 3)\n  stopifnot(get_current_price(tracker) == 5)\n  stopifnot(get_maximum_price(tracker) == 5)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  # Test case 4: Update with timestamp 4 and price 15\n  tracker <- update_stock_price(tracker, 4, 15)\n  stopifnot(get_current_price(tracker) == 15)\n  stopifnot(get_maximum_price(tracker) == 15)\n  stopifnot(get_minimum_price(tracker) == 3)\n  \n  cat(\"All tests passed successfully.\\n\")\n}\n\ntest_stock_price_tracker()", "exec_outcome": "PASSED"}
{"code": "# categorize_orders categorizes a list of order quantities into small, medium, and large.\n# The categorization is based on the following criteria:\n# - Small: 1-10 items\n# - Medium: 11-50 items\n# - Large: 51-100 items\n# The function returns a vector of three integers representing the counts of small, medium, and large orders respectively.\ncategorize_orders <- function(orders) {\n  small <- 0\n  medium <- 0\n  large <- 0\n  \n  for (order in orders) {\n    if (order >= 1 && order <= 10) {\n      small <- small + 1\n    } else if (order >= 11 && order <= 50) {\n      medium <- medium + 1\n    } else if (order >= 51 && order <= 100) {\n      large <- large + 1\n    }\n  }\n  \n  return(c(small, medium, large))\n}", "test_cases": "", "test_case_results": "Input:  5 15 55 3 20 60 8 25 70 \nSmall:  3 , Medium:  3 , Large:  3 \nInput:  1 2 3 4 5 6 7 8 9 10 \nSmall:  10 , Medium:  0 , Large:  0 \nInput:  11 12 13 14 15 51 52 53 54 55 \nSmall:  0 , Medium:  5 , Large:  5 \nInput:  0 101 102 103 \nSmall:  0 , Medium:  0 , Large:  0", "task_id": 807, "assertions": "test_order_categorization <- function() {\n    test_case1 <- c(5, 15, 55, 3, 20, 60, 8, 25, 70)\n    test_case2 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    test_case3 <- c(11, 12, 13, 14, 15, 51, 52, 53, 54, 55)\n    test_case4 <- c(0, 101, 102, 103)\n    \n    stopifnot(identical(categorize_orders(test_case1), c(3, 3, 3)))\n    stopifnot(identical(categorize_orders(test_case2), c(10, 0, 0)))\n    stopifnot(identical(categorize_orders(test_case3), c(0, 5, 5)))\n    stopifnot(identical(categorize_orders(test_case4), c(0, 0, 0)))\n}\n\ntest_order_categorization()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_order_categorization <- function() {\n    test_case1 <- c(5, 15, 55, 3, 20, 60, 8, 25, 70)\n    test_case2 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    test_case3 <- c(11, 12, 13, 14, 15, 51, 52, 53, 54, 55)\n    test_case4 <- c(0, 101, 102, 103)\n    \n    stopifnot(identical(categorize_orders(test_case1), c(3, 3, 3)))\n    stopifnot(identical(categorize_orders(test_case2), c(10, 0, 0)))\n    stopifnot(identical(categorize_orders(test_case3), c(0, 5, 5)))\n    stopifnot(identical(categorize_orders(test_case4), c(0, 0, 0)))\n}\n\ntest_order_categorization()", "output": "categorize_orders"}, "all_code": "# categorize_orders categorizes a list of order quantities into small, medium, and large.\n# The categorization is based on the following criteria:\n# - Small: 1-10 items\n# - Medium: 11-50 items\n# - Large: 51-100 items\n# The function returns a vector of three integers representing the counts of small, medium, and large orders respectively.\ncategorize_orders <- function(orders) {\n  small <- 0\n  medium <- 0\n  large <- 0\n  \n  for (order in orders) {\n    if (order >= 1 && order <= 10) {\n      small <- small + 1\n    } else if (order >= 11 && order <= 50) {\n      medium <- medium + 1\n    } else if (order >= 51 && order <= 100) {\n      large <- large + 1\n    }\n  }\n  \n  return(c(small, medium, large))\n}\ntest_order_categorization <- function() {\n    test_case1 <- c(5, 15, 55, 3, 20, 60, 8, 25, 70)\n    test_case2 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    test_case3 <- c(11, 12, 13, 14, 15, 51, 52, 53, 54, 55)\n    test_case4 <- c(0, 101, 102, 103)\n    \n    stopifnot(identical(categorize_orders(test_case1), c(3, 3, 3)))\n    stopifnot(identical(categorize_orders(test_case2), c(10, 0, 0)))\n    stopifnot(identical(categorize_orders(test_case3), c(0, 5, 5)))\n    stopifnot(identical(categorize_orders(test_case4), c(0, 0, 0)))\n}\n\ntest_order_categorization()", "exec_outcome": "PASSED"}
{"code": "sum_of_smallest_m_integers <- function(n, m, x, arr) {\n  filtered_array <- arr[arr != x]\n  if (length(filtered_array) < m) {\n    return(-1)\n  }\n  sorted_array <- sort(filtered_array)\n  return(sum(sorted_array[1:m]))\n}", "test_cases": "", "test_case_results": "Input: n = 5 , m = 3 , x = 2 , arr = 1 2 3 4 5 \nResult: 8 \nInput: n = 4 , m = 2 , x = 3 , arr = 3 1 3 5 \nResult: 6 \nInput: n = 3 , m = 4 , x = 1 , arr = 1 1 2 \nResult: -1 \nInput: n = 6 , m = 3 , x = 4 , arr = 4 5 6 7 8 9 \nResult: 18", "task_id": 24554, "assertions": "test_sum_of_smallest_m_integers <- function() {\n  stopifnot(sum_of_smallest_m_integers(5, 3, 2, c(1, 2, 3, 4, 5)) == 8)\n  stopifnot(sum_of_smallest_m_integers(4, 2, 3, c(3, 1, 3, 5)) == 6)\n  stopifnot(sum_of_smallest_m_integers(3, 4, 1, c(1, 1, 2)) == -1)\n  stopifnot(sum_of_smallest_m_integers(6, 3, 4, c(4, 5, 6, 7, 8, 9)) == 18)\n}\n\ntest_sum_of_smallest_m_integers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_sum_of_smallest_m_integers <- function() {\n  stopifnot(sum_of_smallest_m_integers(5, 3, 2, c(1, 2, 3, 4, 5)) == 8)\n  stopifnot(sum_of_smallest_m_integers(4, 2, 3, c(3, 1, 3, 5)) == 6)\n  stopifnot(sum_of_smallest_m_integers(3, 4, 1, c(1, 1, 2)) == -1)\n  stopifnot(sum_of_smallest_m_integers(6, 3, 4, c(4, 5, 6, 7, 8, 9)) == 18)\n}\n\ntest_sum_of_smallest_m_integers()", "output": "sum_of_smallest_m_integers"}, "all_code": "sum_of_smallest_m_integers <- function(n, m, x, arr) {\n  filtered_array <- arr[arr != x]\n  if (length(filtered_array) < m) {\n    return(-1)\n  }\n  sorted_array <- sort(filtered_array)\n  return(sum(sorted_array[1:m]))\n}\ntest_sum_of_smallest_m_integers <- function() {\n  stopifnot(sum_of_smallest_m_integers(5, 3, 2, c(1, 2, 3, 4, 5)) == 8)\n  stopifnot(sum_of_smallest_m_integers(4, 2, 3, c(3, 1, 3, 5)) == 6)\n  stopifnot(sum_of_smallest_m_integers(3, 4, 1, c(1, 1, 2)) == -1)\n  stopifnot(sum_of_smallest_m_integers(6, 3, 4, c(4, 5, 6, 7, 8, 9)) == 18)\n}\n\ntest_sum_of_smallest_m_integers()", "exec_outcome": "PASSED"}
{"code": "flatten_and_count_nested_list <- function(nested_list) {\n  # Initialize an empty list to store flattened elements\n  flattened <- list()\n  \n  # Define a helper function to recursively flatten the list\n  flatten <- function(lst) {\n    for (item in lst) {\n      if (is.list(item)) {\n        flatten(item)\n      } else {\n        flattened <<- c(flattened, item)\n      }\n    }\n  }\n  \n  # Flatten the input list\n  flatten(nested_list)\n  \n  # Convert the list to a vector and filter out non-integer elements\n  flattened_vector <- unlist(flattened)\n  flattened_vector <- flattened_vector[sapply(flattened_vector, function(x) is.integer(x) || is.numeric(x))]\n  \n  # Count occurrences of each integer\n  if (length(flattened_vector) == 0) {\n    return(NULL)\n  }\n  \n  count_table <- table(flattened_vector)\n  result <- as.vector(count_table)\n  names(result) <- names(count_table)\n  \n  return(result)\n}", "test_cases": "", "test_case_results": "Input:  [[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[[3]][[1]]\n[1] 3\n\n[[3]][[2]]\n[1] 4\n\n[[3]][[3]]\n[[3]][[3]][[1]]\n[1] 5\n\n[[3]][[3]][[2]]\n[1] 5\n\n[[3]][[3]][[3]]\n[1] 1\n\n\n \nResult: \n1 :  2 \n2 :  1 \n3 :  1 \n4 :  1 \n5 :  2 \n\nInput:  [[1]]\n[1] 1\n\n[[2]]\n[[2]][[1]]\n[1] 2\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] 3\n\n[[2]][[2]][[2]]\n[[2]][[2]][[2]][[1]]\n[1] 4\n\n[[2]][[2]][[2]][[2]]\n[[2]][[2]][[2]][[2]][[1]]\n[1] 5\n\n\n\n\n \nResult: \n1 :  1 \n2 :  1 \n3 :  1 \n4 :  1 \n5 :  1 \n\nInput:  [[1]]\n[[1]][[1]]\n[[1]][[1]][[1]]\n[1] 1\n\n[[1]][[1]][[2]]\n[1] 1\n\n\n[[1]][[2]]\n[1] 2\n\n\n[[2]]\n[[2]][[1]]\n[1] 3\n\n[[2]][[2]]\n[[2]][[2]][[1]]\n[1] 4\n\n[[2]][[2]][[2]]\n[1] 4\n\n\n \nResult: \n1 :  2 \n2 :  1 \n3 :  1 \n4 :  2 \n\nInput:  [[1]]\n[1] 1\n\n[[2]]\n[1] \"a\"\n\n[[3]]\n[[3]][[1]]\n[1] 2\n\n[[3]][[2]]\n[1] \"b\"\n\n\n[[4]]\n[[4]][[1]]\n[1] 3\n\n[[4]][[2]]\n[[4]][[2]][[1]]\n[1] 4\n\n[[4]][[2]][[2]]\n[1] \"c\"\n\n\n \nResult: NULL (empty or no integers found)\n\nInput:  list() \nResult: NULL (empty or no integers found)", "task_id": 17563, "assertions": "test_flatten_and_count <- function() {\n  # Test case 1\n  test1 <- list(1, 2, list(3, 4, list(5, 5, 1)))\n  result1 <- flatten_and_count_nested_list(test1)\n  stopifnot(identical(result1, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 2)))\n  \n  # Test case 2\n  test2 <- list(1, list(2, list(3, list(4, list(5)))))\n  result2 <- flatten_and_count_nested_list(test2)\n  stopifnot(identical(result2, c(\"1\" = 1, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 1)))\n  \n  # Test case 3\n  test3 <- list(list(list(1, 1), 2), list(3, list(4, 4)))\n  result3 <- flatten_and_count_nested_list(test3)\n  stopifnot(identical(result3, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 2)))\n  \n  # Test case 4 (non-integer elements)\n  test4 <- list(1, \"a\", list(2, \"b\"), list(3, list(4, \"c\")))\n  result4 <- flatten_and_count_nested_list(test4)\n  stopifnot(is.null(result4))\n  \n  # Test case 5 (empty list)\n  test5 <- list()\n  result5 <- flatten_and_count_nested_list(test5)\n  stopifnot(is.null(result5))\n}\n\ntest_flatten_and_count()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_flatten_and_count <- function() {\n  # Test case 1\n  test1 <- list(1, 2, list(3, 4, list(5, 5, 1)))\n  result1 <- flatten_and_count_nested_list(test1)\n  stopifnot(identical(result1, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 2)))\n  \n  # Test case 2\n  test2 <- list(1, list(2, list(3, list(4, list(5)))))\n  result2 <- flatten_and_count_nested_list(test2)\n  stopifnot(identical(result2, c(\"1\" = 1, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 1)))\n  \n  # Test case 3\n  test3 <- list(list(list(1, 1), 2), list(3, list(4, 4)))\n  result3 <- flatten_and_count_nested_list(test3)\n  stopifnot(identical(result3, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 2)))\n  \n  # Test case 4 (non-integer elements)\n  test4 <- list(1, \"a\", list(2, \"b\"), list(3, list(4, \"c\")))\n  result4 <- flatten_and_count_nested_list(test4)\n  stopifnot(is.null(result4))\n  \n  # Test case 5 (empty list)\n  test5 <- list()\n  result5 <- flatten_and_count_nested_list(test5)\n  stopifnot(is.null(result5))\n}\n\ntest_flatten_and_count()", "output": "flatten_and_count_nested_list"}, "all_code": "flatten_and_count_nested_list <- function(nested_list) {\n  # Initialize an empty list to store flattened elements\n  flattened <- list()\n  \n  # Define a helper function to recursively flatten the list\n  flatten <- function(lst) {\n    for (item in lst) {\n      if (is.list(item)) {\n        flatten(item)\n      } else {\n        flattened <<- c(flattened, item)\n      }\n    }\n  }\n  \n  # Flatten the input list\n  flatten(nested_list)\n  \n  # Convert the list to a vector and filter out non-integer elements\n  flattened_vector <- unlist(flattened)\n  flattened_vector <- flattened_vector[sapply(flattened_vector, function(x) is.integer(x) || is.numeric(x))]\n  \n  # Count occurrences of each integer\n  if (length(flattened_vector) == 0) {\n    return(NULL)\n  }\n  \n  count_table <- table(flattened_vector)\n  result <- as.vector(count_table)\n  names(result) <- names(count_table)\n  \n  return(result)\n}\ntest_flatten_and_count <- function() {\n  # Test case 1\n  test1 <- list(1, 2, list(3, 4, list(5, 5, 1)))\n  result1 <- flatten_and_count_nested_list(test1)\n  stopifnot(identical(result1, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 2)))\n  \n  # Test case 2\n  test2 <- list(1, list(2, list(3, list(4, list(5)))))\n  result2 <- flatten_and_count_nested_list(test2)\n  stopifnot(identical(result2, c(\"1\" = 1, \"2\" = 1, \"3\" = 1, \"4\" = 1, \"5\" = 1)))\n  \n  # Test case 3\n  test3 <- list(list(list(1, 1), 2), list(3, list(4, 4)))\n  result3 <- flatten_and_count_nested_list(test3)\n  stopifnot(identical(result3, c(\"1\" = 2, \"2\" = 1, \"3\" = 1, \"4\" = 2)))\n  \n  # Test case 4 (non-integer elements)\n  test4 <- list(1, \"a\", list(2, \"b\"), list(3, list(4, \"c\")))\n  result4 <- flatten_and_count_nested_list(test4)\n  stopifnot(is.null(result4))\n  \n  # Test case 5 (empty list)\n  test5 <- list()\n  result5 <- flatten_and_count_nested_list(test5)\n  stopifnot(is.null(result5))\n}\n\ntest_flatten_and_count()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "shortest_path_with_obstacles <- function(matrix) {\n  # is_valid checks if the given coordinates (x, y) are within the bounds of the matrix.\n  is_valid <- function(x, y, n, m) {\n    return(x >= 0 && x < n && y >= 0 && y < m)\n  }\n\n  n <- nrow(matrix)\n  m <- ncol(matrix)\n  \n  # Initialize the queue with the starting position (0, 0), distance 0, and no obstacles broken.\n  queue <- list(list(row = 0, col = 0, dist = 0, broken = FALSE))\n  \n  # visited keeps track of visited positions and whether an obstacle has been broken.\n  visited <- list()\n  visited[[paste(0, 0, FALSE)]] <- TRUE\n  \n  # Directions for moving up, down, left, and right.\n  directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n  \n  while (length(queue) > 0) {\n    # Dequeue the first element.\n    current <- queue[[1]]\n    queue <- queue[-1]\n    \n    x <- current$row\n    y <- current$col\n    dist <- current$dist\n    broken <- current$broken\n    \n    # Check if we've reached the destination.\n    if (x == n - 1 && y == m - 1) {\n      return(dist)\n    }\n    \n    # Explore all four directions.\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      \n      if (is_valid(nx, ny, n, m)) {\n        # If the next cell is a free space and we haven't visited it with the current broken state.\n        if (matrix[nx + 1, ny + 1] == 0 && is.null(visited[[paste(nx, ny, broken)]])) {\n          visited[[paste(nx, ny, broken)]] <- TRUE\n          queue[[length(queue) + 1]] <- list(row = nx, col = ny, dist = dist + 1, broken = broken)\n        }\n        # If the next cell is an obstacle, and we haven't broken any obstacle yet.\n        if (matrix[nx + 1, ny + 1] == 1 && !broken && is.null(visited[[paste(nx, ny, TRUE)]])) {\n          visited[[paste(nx, ny, TRUE)]] <- TRUE\n          queue[[length(queue) + 1]] <- list(row = nx, col = ny, dist = dist + 1, broken = TRUE)\n        }\n      }\n    }\n  }\n  \n  # If no path was found.\n  return(-1)\n}", "test_cases": "", "test_case_results": "Input matrix:\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    1    1    0\n[3,]    0    0    0\nShortest path length:  4 \n\nInput matrix:\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    0    1    0\n[3,]    0    0    0\nShortest path length:  4 \n\nInput matrix:\n     [,1] [,2] [,3]\n[1,]    0    1    1\n[2,]    1    1    1\n[3,]    1    1    0\nShortest path length:  -1 \n\nInput matrix:\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    0    0    0\n[3,]    0    0    0\nShortest path length:  4", "task_id": 12893, "assertions": "test_shortest_path_with_obstacles <- function() {\n  test_cases <- list(\n    matrix(c(0, 0, 0,\n             1, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 0,\n             0, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 1,\n             1, 1, 1,\n             1, 1, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 0, 0,\n             0, 0, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE)\n  )\n  \n  expected_results <- c(4, 4, -1, 4)\n  \n  for (i in seq_along(test_cases)) {\n    result <- shortest_path_with_obstacles(test_cases[[i]])\n    stopifnot(result == expected_results[i])\n  }\n}\n\ntest_shortest_path_with_obstacles()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_shortest_path_with_obstacles <- function() {\n  test_cases <- list(\n    matrix(c(0, 0, 0,\n             1, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 0,\n             0, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 1,\n             1, 1, 1,\n             1, 1, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 0, 0,\n             0, 0, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE)\n  )\n  \n  expected_results <- c(4, 4, -1, 4)\n  \n  for (i in seq_along(test_cases)) {\n    result <- shortest_path_with_obstacles(test_cases[[i]])\n    stopifnot(result == expected_results[i])\n  }\n}\n\ntest_shortest_path_with_obstacles()", "output": "shortest_path_with_obstacles"}, "all_code": "shortest_path_with_obstacles <- function(matrix) {\n  # is_valid checks if the given coordinates (x, y) are within the bounds of the matrix.\n  is_valid <- function(x, y, n, m) {\n    return(x >= 0 && x < n && y >= 0 && y < m)\n  }\n\n  n <- nrow(matrix)\n  m <- ncol(matrix)\n  \n  # Initialize the queue with the starting position (0, 0), distance 0, and no obstacles broken.\n  queue <- list(list(row = 0, col = 0, dist = 0, broken = FALSE))\n  \n  # visited keeps track of visited positions and whether an obstacle has been broken.\n  visited <- list()\n  visited[[paste(0, 0, FALSE)]] <- TRUE\n  \n  # Directions for moving up, down, left, and right.\n  directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n  \n  while (length(queue) > 0) {\n    # Dequeue the first element.\n    current <- queue[[1]]\n    queue <- queue[-1]\n    \n    x <- current$row\n    y <- current$col\n    dist <- current$dist\n    broken <- current$broken\n    \n    # Check if we've reached the destination.\n    if (x == n - 1 && y == m - 1) {\n      return(dist)\n    }\n    \n    # Explore all four directions.\n    for (dir in directions) {\n      nx <- x + dir[1]\n      ny <- y + dir[2]\n      \n      if (is_valid(nx, ny, n, m)) {\n        # If the next cell is a free space and we haven't visited it with the current broken state.\n        if (matrix[nx + 1, ny + 1] == 0 && is.null(visited[[paste(nx, ny, broken)]])) {\n          visited[[paste(nx, ny, broken)]] <- TRUE\n          queue[[length(queue) + 1]] <- list(row = nx, col = ny, dist = dist + 1, broken = broken)\n        }\n        # If the next cell is an obstacle, and we haven't broken any obstacle yet.\n        if (matrix[nx + 1, ny + 1] == 1 && !broken && is.null(visited[[paste(nx, ny, TRUE)]])) {\n          visited[[paste(nx, ny, TRUE)]] <- TRUE\n          queue[[length(queue) + 1]] <- list(row = nx, col = ny, dist = dist + 1, broken = TRUE)\n        }\n      }\n    }\n  }\n  \n  # If no path was found.\n  return(-1)\n}\ntest_shortest_path_with_obstacles <- function() {\n  test_cases <- list(\n    matrix(c(0, 0, 0,\n             1, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 0,\n             0, 1, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 1, 1,\n             1, 1, 1,\n             1, 1, 0), nrow = 3, byrow = TRUE),\n    \n    matrix(c(0, 0, 0,\n             0, 0, 0,\n             0, 0, 0), nrow = 3, byrow = TRUE)\n  )\n  \n  expected_results <- c(4, 4, -1, 4)\n  \n  for (i in seq_along(test_cases)) {\n    result <- shortest_path_with_obstacles(test_cases[[i]])\n    stopifnot(result == expected_results[i])\n  }\n}\n\ntest_shortest_path_with_obstacles()", "exec_outcome": "PASSED"}
{"code": "# find_common_elements counts the number of elements that are common to all rows of a matrix.\n# It uses a list of vectors to represent the matrix and a table to count element frequencies.\n# If the matrix is empty, it returns 0.\nfind_common_elements <- function(mat) {\n  if (length(mat) == 0) {\n    return(0)\n  }\n\n  # Initialize a frequency table with the elements of the first row\n  common_counts <- table(mat[[1]])\n  \n  # Intersect the counts with subsequent rows\n  for (row in mat[-1]) {\n    row_counts <- table(row)\n    common_elements <- intersect(names(common_counts), names(row_counts))\n    common_counts <- common_counts[common_elements]\n    common_counts <- pmin(common_counts, row_counts[common_elements])\n  }\n\n  # Count the common elements (those with count > 0)\n  common_elements_count <- sum(common_counts > 0)\n  return(common_elements_count)\n}", "test_cases": "", "test_case_results": "Test case 1 Input matrix:\n[ 1 2 3 4 ]\n[ 2 3 4 5 ]\n[ 3 4 5 6 ]\nNumber of common elements: 2 \n\nTest case 2 Input matrix:\n[ 1 2 3 ]\n[ 4 5 6 ]\n[ 7 8 9 ]\nNumber of common elements: 0 \n\nTest case 3 Input matrix:\nNumber of common elements: 0 \n\nTest case 4 Input matrix:\n[ 1 1 2 2 ]\nNumber of common elements: 2 \n\nTest case 5 Input matrix:\n[ 1 2 3 ]\n[ 1 2 3 ]\n[ 1 2 3 ]\nNumber of common elements: 3", "task_id": 26446, "assertions": "test_find_common_elements <- function() {\n  # Test case 1: Matrix with common elements\n  test_case1 <- list(\n    c(1, 2, 3, 4),\n    c(2, 3, 4, 5),\n    c(3, 4, 5, 6)\n  )\n  stopifnot(find_common_elements(test_case1) == 2)\n  \n  # Test case 2: Matrix with no common elements\n  test_case2 <- list(\n    c(1, 2, 3),\n    c(4, 5, 6),\n    c(7, 8, 9)\n  )\n  stopifnot(find_common_elements(test_case2) == 0)\n  \n  # Test case 3: Empty matrix\n  test_case3 <- list()\n  stopifnot(find_common_elements(test_case3) == 0)\n  \n  # Test case 4: Single-row matrix\n  test_case4 <- list(\n    c(1, 1, 2, 2)\n  )\n  stopifnot(find_common_elements(test_case4) == 2)\n  \n  # Test case 5: Matrix with all identical rows\n  test_case5 <- list(\n    c(1, 2, 3),\n    c(1, 2, 3),\n    c(1, 2, 3)\n  )\n  stopifnot(find_common_elements(test_case5) == 3)\n}\n\ntest_find_common_elements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_find_common_elements <- function() {\n  # Test case 1: Matrix with common elements\n  test_case1 <- list(\n    c(1, 2, 3, 4),\n    c(2, 3, 4, 5),\n    c(3, 4, 5, 6)\n  )\n  stopifnot(find_common_elements(test_case1) == 2)\n  \n  # Test case 2: Matrix with no common elements\n  test_case2 <- list(\n    c(1, 2, 3),\n    c(4, 5, 6),\n    c(7, 8, 9)\n  )\n  stopifnot(find_common_elements(test_case2) == 0)\n  \n  # Test case 3: Empty matrix\n  test_case3 <- list()\n  stopifnot(find_common_elements(test_case3) == 0)\n  \n  # Test case 4: Single-row matrix\n  test_case4 <- list(\n    c(1, 1, 2, 2)\n  )\n  stopifnot(find_common_elements(test_case4) == 2)\n  \n  # Test case 5: Matrix with all identical rows\n  test_case5 <- list(\n    c(1, 2, 3),\n    c(1, 2, 3),\n    c(1, 2, 3)\n  )\n  stopifnot(find_common_elements(test_case5) == 3)\n}\n\ntest_find_common_elements()", "output": "find_common_elements"}, "all_code": "# find_common_elements counts the number of elements that are common to all rows of a matrix.\n# It uses a list of vectors to represent the matrix and a table to count element frequencies.\n# If the matrix is empty, it returns 0.\nfind_common_elements <- function(mat) {\n  if (length(mat) == 0) {\n    return(0)\n  }\n\n  # Initialize a frequency table with the elements of the first row\n  common_counts <- table(mat[[1]])\n  \n  # Intersect the counts with subsequent rows\n  for (row in mat[-1]) {\n    row_counts <- table(row)\n    common_elements <- intersect(names(common_counts), names(row_counts))\n    common_counts <- common_counts[common_elements]\n    common_counts <- pmin(common_counts, row_counts[common_elements])\n  }\n\n  # Count the common elements (those with count > 0)\n  common_elements_count <- sum(common_counts > 0)\n  return(common_elements_count)\n}\ntest_find_common_elements <- function() {\n  # Test case 1: Matrix with common elements\n  test_case1 <- list(\n    c(1, 2, 3, 4),\n    c(2, 3, 4, 5),\n    c(3, 4, 5, 6)\n  )\n  stopifnot(find_common_elements(test_case1) == 2)\n  \n  # Test case 2: Matrix with no common elements\n  test_case2 <- list(\n    c(1, 2, 3),\n    c(4, 5, 6),\n    c(7, 8, 9)\n  )\n  stopifnot(find_common_elements(test_case2) == 0)\n  \n  # Test case 3: Empty matrix\n  test_case3 <- list()\n  stopifnot(find_common_elements(test_case3) == 0)\n  \n  # Test case 4: Single-row matrix\n  test_case4 <- list(\n    c(1, 1, 2, 2)\n  )\n  stopifnot(find_common_elements(test_case4) == 2)\n  \n  # Test case 5: Matrix with all identical rows\n  test_case5 <- list(\n    c(1, 2, 3),\n    c(1, 2, 3),\n    c(1, 2, 3)\n  )\n  stopifnot(find_common_elements(test_case5) == 3)\n}\n\ntest_find_common_elements()", "exec_outcome": "PASSED"}
{"code": "# reduce_noise reduces noise from a Hermitian positive-definite matrix using Cholesky decomposition.\n# The function takes a 2D numeric matrix (representing a Hermitian positive-definite matrix) as input,\n# performs Cholesky decomposition to obtain the lower triangular matrix, and returns it as the \"cleaned\" version.\n# Note: The input matrix must be Hermitian positive-definite for Cholesky decomposition to work.\nreduce_noise <- function(A) {\n  # Convert the input to a matrix if it's not already\n  A_matrix <- as.matrix(A)\n  \n  # Perform Cholesky decomposition to get the lower triangular matrix\n  L <- chol(A_matrix, pivot = FALSE)\n  \n  # Return the lower triangular matrix\n  return(L)\n}", "test_cases": "", "test_case_results": "Test Case 1 Input Matrix:\n     [,1] [,2]\n[1,]    4   12\n[2,]   12   37\nLower Triangular Matrix (Result):\n     [,1] [,2]\n[1,]    2    6\n[2,]    0    1\n\nTest Case 2 Input Matrix:\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    2\nLower Triangular Matrix (Result):\n     [,1] [,2]\n[1,]    1    1\n[2,]    0    1\n\nTest Case 3 Input Matrix:\n     [,1] [,2] [,3]\n[1,]    4   12  -16\n[2,]   12   37  -43\n[3,]  -16  -43   98\nLower Triangular Matrix (Result):\n     [,1] [,2] [,3]\n[1,]    2    6   -8\n[2,]    0    1    5\n[3,]    0    0    3", "task_id": 2342, "assertions": "test.reduce_noise <- function() {\n  # Test case 1\n  test_case_1 <- matrix(c(4, 12, 12, 37), nrow = 2, ncol = 2)\n  expected_result_1 <- matrix(c(2, 0, 6, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_1), expected_result_1))\n  \n  # Test case 2\n  test_case_2 <- matrix(c(1, 1, 1, 2), nrow = 2, ncol = 2)\n  expected_result_2 <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_2), expected_result_2))\n  \n  # Test case 3\n  test_case_3 <- matrix(c(4, 12, -16, 12, 37, -43, -16, -43, 98), nrow = 3, ncol = 3)\n  expected_result_3 <- matrix(c(2, 0, 0, 6, 1, 0, -8, 5, 3), nrow = 3, ncol = 3)\n  stopifnot(all.equal(reduce_noise(test_case_3), expected_result_3))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest.reduce_noise()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest.reduce_noise <- function() {\n  # Test case 1\n  test_case_1 <- matrix(c(4, 12, 12, 37), nrow = 2, ncol = 2)\n  expected_result_1 <- matrix(c(2, 0, 6, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_1), expected_result_1))\n  \n  # Test case 2\n  test_case_2 <- matrix(c(1, 1, 1, 2), nrow = 2, ncol = 2)\n  expected_result_2 <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_2), expected_result_2))\n  \n  # Test case 3\n  test_case_3 <- matrix(c(4, 12, -16, 12, 37, -43, -16, -43, 98), nrow = 3, ncol = 3)\n  expected_result_3 <- matrix(c(2, 0, 0, 6, 1, 0, -8, 5, 3), nrow = 3, ncol = 3)\n  stopifnot(all.equal(reduce_noise(test_case_3), expected_result_3))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest.reduce_noise()", "output": "reduce_noise"}, "all_code": "# reduce_noise reduces noise from a Hermitian positive-definite matrix using Cholesky decomposition.\n# The function takes a 2D numeric matrix (representing a Hermitian positive-definite matrix) as input,\n# performs Cholesky decomposition to obtain the lower triangular matrix, and returns it as the \"cleaned\" version.\n# Note: The input matrix must be Hermitian positive-definite for Cholesky decomposition to work.\nreduce_noise <- function(A) {\n  # Convert the input to a matrix if it's not already\n  A_matrix <- as.matrix(A)\n  \n  # Perform Cholesky decomposition to get the lower triangular matrix\n  L <- chol(A_matrix, pivot = FALSE)\n  \n  # Return the lower triangular matrix\n  return(L)\n}\ntest.reduce_noise <- function() {\n  # Test case 1\n  test_case_1 <- matrix(c(4, 12, 12, 37), nrow = 2, ncol = 2)\n  expected_result_1 <- matrix(c(2, 0, 6, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_1), expected_result_1))\n  \n  # Test case 2\n  test_case_2 <- matrix(c(1, 1, 1, 2), nrow = 2, ncol = 2)\n  expected_result_2 <- matrix(c(1, 0, 1, 1), nrow = 2, ncol = 2)\n  stopifnot(all.equal(reduce_noise(test_case_2), expected_result_2))\n  \n  # Test case 3\n  test_case_3 <- matrix(c(4, 12, -16, 12, 37, -43, -16, -43, 98), nrow = 3, ncol = 3)\n  expected_result_3 <- matrix(c(2, 0, 0, 6, 1, 0, -8, 5, 3), nrow = 3, ncol = 3)\n  stopifnot(all.equal(reduce_noise(test_case_3), expected_result_3))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest.reduce_noise()", "exec_outcome": "PASSED"}
{"code": "UnionFind <- function(n) {\n  parent <- 0:(n - 1)\n  rank <- rep(1, n)\n  \n  find <- function(x) {\n    if (parent[x + 1] != x) {\n      parent[x + 1] <<- find(parent[x + 1])\n    }\n    return(parent[x + 1])\n  }\n  \n  union <- function(x, y) {\n    rootX <- find(x)\n    rootY <- find(y)\n    \n    if (rootX != rootY) {\n      if (rank[rootX + 1] > rank[rootY + 1]) {\n        parent[rootY + 1] <<- rootX\n      } else if (rank[rootX + 1] < rank[rootY + 1]) {\n        parent[rootX + 1] <<- rootY\n      } else {\n        parent[rootY + 1] <<- rootX\n        rank[rootX + 1] <<- rank[rootX + 1] + 1\n      }\n    }\n  }\n  \n  return(list(find = find, union = union))\n}\n\ncan_communicate <- function(n, q, links, queries) {\n  uf <- UnionFind(n)\n  \n  for (link in links) {\n    u <- link[1]\n    v <- link[2]\n    uf$union(u, v)\n  }\n  \n  results <- c()\n  for (query in queries) {\n    ai <- query[1]\n    bi <- query[2]\n    if (uf$find(ai) == uf$find(bi)) {\n      results <- c(results, \"YES\")\n    } else {\n      results <- c(results, \"NO\")\n    }\n  }\n  \n  return(results)\n}", "test_cases": "", "test_case_results": "Test case 1:\nNodes:  4 \nLinks:  0-1, 2-3 \nQueries:  0-1, 1-2 \nResults:  YES, NO \n\nTest case 2:\nNodes:  5 \nLinks:  0-1, 1-2, 3-4 \nQueries:  0-2, 1-3, 4-4 \nResults:  YES, NO, YES \n\nTest case 3:\nNodes:  3 \nLinks:  0-1 \nQueries:  0-1, 1-2, 0-2 \nResults:  YES, NO, NO", "task_id": 21716, "assertions": "test_union_find <- function() {\n  # Test case 1\n  n1 <- 4\n  q1 <- 2\n  links1 <- list(c(0, 1), c(2, 3))\n  queries1 <- list(c(0, 1), c(1, 2))\n  result1 <- can_communicate(n1, q1, links1, queries1)\n  stopifnot(identical(result1, c(\"YES\", \"NO\")))\n  \n  # Test case 2\n  n2 <- 5\n  q2 <- 3\n  links2 <- list(c(0, 1), c(1, 2), c(3, 4))\n  queries2 <- list(c(0, 2), c(1, 3), c(4, 4))\n  result2 <- can_communicate(n2, q2, links2, queries2)\n  stopifnot(identical(result2, c(\"YES\", \"NO\", \"YES\")))\n  \n  # Test case 3\n  n3 <- 3\n  q3 <- 3\n  links3 <- list(c(0, 1))\n  queries3 <- list(c(0, 1), c(1, 2), c(0, 2))\n  result3 <- can_communicate(n3, q3, links3, queries3)\n  stopifnot(identical(result3, c(\"YES\", \"NO\", \"NO\")))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_union_find()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_union_find <- function() {\n  # Test case 1\n  n1 <- 4\n  q1 <- 2\n  links1 <- list(c(0, 1), c(2, 3))\n  queries1 <- list(c(0, 1), c(1, 2))\n  result1 <- can_communicate(n1, q1, links1, queries1)\n  stopifnot(identical(result1, c(\"YES\", \"NO\")))\n  \n  # Test case 2\n  n2 <- 5\n  q2 <- 3\n  links2 <- list(c(0, 1), c(1, 2), c(3, 4))\n  queries2 <- list(c(0, 2), c(1, 3), c(4, 4))\n  result2 <- can_communicate(n2, q2, links2, queries2)\n  stopifnot(identical(result2, c(\"YES\", \"NO\", \"YES\")))\n  \n  # Test case 3\n  n3 <- 3\n  q3 <- 3\n  links3 <- list(c(0, 1))\n  queries3 <- list(c(0, 1), c(1, 2), c(0, 2))\n  result3 <- can_communicate(n3, q3, links3, queries3)\n  stopifnot(identical(result3, c(\"YES\", \"NO\", \"NO\")))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_union_find()", "output": "can_communicate"}, "all_code": "UnionFind <- function(n) {\n  parent <- 0:(n - 1)\n  rank <- rep(1, n)\n  \n  find <- function(x) {\n    if (parent[x + 1] != x) {\n      parent[x + 1] <<- find(parent[x + 1])\n    }\n    return(parent[x + 1])\n  }\n  \n  union <- function(x, y) {\n    rootX <- find(x)\n    rootY <- find(y)\n    \n    if (rootX != rootY) {\n      if (rank[rootX + 1] > rank[rootY + 1]) {\n        parent[rootY + 1] <<- rootX\n      } else if (rank[rootX + 1] < rank[rootY + 1]) {\n        parent[rootX + 1] <<- rootY\n      } else {\n        parent[rootY + 1] <<- rootX\n        rank[rootX + 1] <<- rank[rootX + 1] + 1\n      }\n    }\n  }\n  \n  return(list(find = find, union = union))\n}\n\ncan_communicate <- function(n, q, links, queries) {\n  uf <- UnionFind(n)\n  \n  for (link in links) {\n    u <- link[1]\n    v <- link[2]\n    uf$union(u, v)\n  }\n  \n  results <- c()\n  for (query in queries) {\n    ai <- query[1]\n    bi <- query[2]\n    if (uf$find(ai) == uf$find(bi)) {\n      results <- c(results, \"YES\")\n    } else {\n      results <- c(results, \"NO\")\n    }\n  }\n  \n  return(results)\n}\ntest_union_find <- function() {\n  # Test case 1\n  n1 <- 4\n  q1 <- 2\n  links1 <- list(c(0, 1), c(2, 3))\n  queries1 <- list(c(0, 1), c(1, 2))\n  result1 <- can_communicate(n1, q1, links1, queries1)\n  stopifnot(identical(result1, c(\"YES\", \"NO\")))\n  \n  # Test case 2\n  n2 <- 5\n  q2 <- 3\n  links2 <- list(c(0, 1), c(1, 2), c(3, 4))\n  queries2 <- list(c(0, 2), c(1, 3), c(4, 4))\n  result2 <- can_communicate(n2, q2, links2, queries2)\n  stopifnot(identical(result2, c(\"YES\", \"NO\", \"YES\")))\n  \n  # Test case 3\n  n3 <- 3\n  q3 <- 3\n  links3 <- list(c(0, 1))\n  queries3 <- list(c(0, 1), c(1, 2), c(0, 2))\n  result3 <- can_communicate(n3, q3, links3, queries3)\n  stopifnot(identical(result3, c(\"YES\", \"NO\", \"NO\")))\n  \n  cat(\"All test cases passed successfully!\\n\")\n}\n\ntest_union_find()", "exec_outcome": "PASSED"}
{"code": "count_unique_cities <- function(test_cases) {\n  unique_city_counts <- c()\n  for (test_case in test_cases) {\n    n <- test_case[[1]]\n    cities <- test_case[[2]]\n    unique_cities <- unique(cities)\n    unique_city_counts <- c(unique_city_counts, length(unique_cities))\n  }\n  return(unique_city_counts)\n}", "test_cases": "", "test_case_results": "Test Case 1:\n  Number of city tags (n): 5\n  City tags: New York, Los Angeles, New York, Chicago, Los Angeles\n  Number of unique cities: 3\n\nTest Case 2:\n  Number of city tags (n): 3\n  City tags: London, Paris, London\n  Number of unique cities: 2\n\nTest Case 3:\n  Number of city tags (n): 4\n  City tags: Tokyo, Osaka, Nagoya, Tokyo\n  Number of unique cities: 3\n\nTest Case 4:\n  Number of city tags (n): 1\n  City tags: Berlin\n  Number of unique cities: 1\n\nTest Case 5:\n  Number of city tags (n): 0\n  City tags: \n  Number of unique cities: 0", "task_id": 16094, "assertions": "test_unique_cities <- function() {\n  test_cases <- list(\n    list(5, c(\"New York\", \"Los Angeles\", \"New York\", \"Chicago\", \"Los Angeles\")),\n    list(3, c(\"London\", \"Paris\", \"London\")),\n    list(4, c(\"Tokyo\", \"Osaka\", \"Nagoya\", \"Tokyo\")),\n    list(1, c(\"Berlin\")),\n    list(0, c())\n  )\n  \n  expected_results <- c(3, 2, 3, 1, 0)\n  actual_results <- count_unique_cities(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n  stopifnot(length(actual_results) == length(expected_results))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_unique_cities()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_unique_cities <- function() {\n  test_cases <- list(\n    list(5, c(\"New York\", \"Los Angeles\", \"New York\", \"Chicago\", \"Los Angeles\")),\n    list(3, c(\"London\", \"Paris\", \"London\")),\n    list(4, c(\"Tokyo\", \"Osaka\", \"Nagoya\", \"Tokyo\")),\n    list(1, c(\"Berlin\")),\n    list(0, c())\n  )\n  \n  expected_results <- c(3, 2, 3, 1, 0)\n  actual_results <- count_unique_cities(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n  stopifnot(length(actual_results) == length(expected_results))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_unique_cities()", "output": "count_unique_cities"}, "all_code": "count_unique_cities <- function(test_cases) {\n  unique_city_counts <- c()\n  for (test_case in test_cases) {\n    n <- test_case[[1]]\n    cities <- test_case[[2]]\n    unique_cities <- unique(cities)\n    unique_city_counts <- c(unique_city_counts, length(unique_cities))\n  }\n  return(unique_city_counts)\n}\ntest_unique_cities <- function() {\n  test_cases <- list(\n    list(5, c(\"New York\", \"Los Angeles\", \"New York\", \"Chicago\", \"Los Angeles\")),\n    list(3, c(\"London\", \"Paris\", \"London\")),\n    list(4, c(\"Tokyo\", \"Osaka\", \"Nagoya\", \"Tokyo\")),\n    list(1, c(\"Berlin\")),\n    list(0, c())\n  )\n  \n  expected_results <- c(3, 2, 3, 1, 0)\n  actual_results <- count_unique_cities(test_cases)\n  \n  stopifnot(all(actual_results == expected_results))\n  stopifnot(length(actual_results) == length(expected_results))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_unique_cities()", "exec_outcome": "PASSED"}
{"code": "# two_sum_binary_search finds two numbers in a sorted vector that add up to a target value using binary search.\n# It iterates through each number and uses binary search to find its complement.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_binary_search <- function(numbers, target) {\n  binary_search <- function(low, high, value) {\n    while (low <= high) {\n      mid <- floor((low + high) / 2)\n      if (numbers[mid] == value) {\n        return(mid)\n      } else if (numbers[mid] < value) {\n        low <- mid + 1\n      } else {\n        high <- mid - 1\n      }\n    }\n    return(-1)\n  }\n\n  for (i in 1:length(numbers)) {\n    complement <- target - numbers[i]\n    j <- binary_search(i + 1, length(numbers), complement)\n    if (j != -1) {\n      return(c(i, j))\n    }\n  }\n  return(c())\n}\n\n# two_sum_hash_table finds two numbers in a sorted vector that add up to a target value using a hash table.\n# It stores each number's index in a hash table and checks for the complement of each number.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_hash_table <- function(numbers, target) {\n  num_to_index <- list()\n  for (i in 1:length(numbers)) {\n    num <- numbers[i]\n    complement <- target - num\n    if (!is.null(num_to_index[[as.character(complement)]])) {\n      return(c(num_to_index[[as.character(complement)]], i))\n    }\n    num_to_index[[as.character(num)]] <- i\n  }\n  return(c())\n}\n\n# two_sum_two_pointers finds two numbers in a sorted vector that add up to a target value using two pointers.\n# It uses one pointer at the start and another at the end, moving them based on the sum comparison with the target.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_two_pointers <- function(numbers, target) {\n  left <- 1\n  right <- length(numbers)\n  while (left < right) {\n    current_sum <- numbers[left] + numbers[right]\n    if (current_sum == target) {\n      return(c(left, right))\n    } else if (current_sum < target) {\n      left <- left + 1\n    } else {\n      right <- right - 1\n    }\n  }\n  return(c())\n}", "test_cases": "", "test_case_results": "Input numbers:  2 7 11 15 , Target:  9 \nBinary Search Result:  1 2 \nHash Table Result:  1 2 \nTwo Pointers Result:  1 2 \n\nInput numbers:  2 3 4 , Target:  6 \nBinary Search Result:  1 3 \nHash Table Result:  1 3 \nTwo Pointers Result:  1 3 \n\nInput numbers:  -1 0 , Target:  -1 \nBinary Search Result:  1 2 \nHash Table Result:  1 2 \nTwo Pointers Result:  1 2", "task_id": 9315, "assertions": "test_two_sum_functions <- function() {\n  # Test case 1\n  numbers1 <- c(2, 7, 11, 15)\n  target1 <- 9\n  stopifnot(identical(two_sum_binary_search(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers1, target1), c(1, 2)))\n  \n  # Test case 2\n  numbers2 <- c(2, 3, 4)\n  target2 <- 6\n  stopifnot(identical(two_sum_binary_search(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_hash_table(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_two_pointers(numbers2, target2), c(1, 3)))\n  \n  # Test case 3\n  numbers3 <- c(-1, 0)\n  target3 <- -1\n  stopifnot(identical(two_sum_binary_search(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers3, target3), c(1, 2)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_two_sum_functions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_two_sum_functions <- function() {\n  # Test case 1\n  numbers1 <- c(2, 7, 11, 15)\n  target1 <- 9\n  stopifnot(identical(two_sum_binary_search(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers1, target1), c(1, 2)))\n  \n  # Test case 2\n  numbers2 <- c(2, 3, 4)\n  target2 <- 6\n  stopifnot(identical(two_sum_binary_search(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_hash_table(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_two_pointers(numbers2, target2), c(1, 3)))\n  \n  # Test case 3\n  numbers3 <- c(-1, 0)\n  target3 <- -1\n  stopifnot(identical(two_sum_binary_search(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers3, target3), c(1, 2)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_two_sum_functions()", "output": "two_sum_binary_search, two_sum_hash_table, two_sum_two_pointers"}, "all_code": "# two_sum_binary_search finds two numbers in a sorted vector that add up to a target value using binary search.\n# It iterates through each number and uses binary search to find its complement.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_binary_search <- function(numbers, target) {\n  binary_search <- function(low, high, value) {\n    while (low <= high) {\n      mid <- floor((low + high) / 2)\n      if (numbers[mid] == value) {\n        return(mid)\n      } else if (numbers[mid] < value) {\n        low <- mid + 1\n      } else {\n        high <- mid - 1\n      }\n    }\n    return(-1)\n  }\n\n  for (i in 1:length(numbers)) {\n    complement <- target - numbers[i]\n    j <- binary_search(i + 1, length(numbers), complement)\n    if (j != -1) {\n      return(c(i, j))\n    }\n  }\n  return(c())\n}\n\n# two_sum_hash_table finds two numbers in a sorted vector that add up to a target value using a hash table.\n# It stores each number's index in a hash table and checks for the complement of each number.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_hash_table <- function(numbers, target) {\n  num_to_index <- list()\n  for (i in 1:length(numbers)) {\n    num <- numbers[i]\n    complement <- target - num\n    if (!is.null(num_to_index[[as.character(complement)]])) {\n      return(c(num_to_index[[as.character(complement)]], i))\n    }\n    num_to_index[[as.character(num)]] <- i\n  }\n  return(c())\n}\n\n# two_sum_two_pointers finds two numbers in a sorted vector that add up to a target value using two pointers.\n# It uses one pointer at the start and another at the end, moving them based on the sum comparison with the target.\n# Returns the 1-based indices of the two numbers if found, otherwise an empty vector.\ntwo_sum_two_pointers <- function(numbers, target) {\n  left <- 1\n  right <- length(numbers)\n  while (left < right) {\n    current_sum <- numbers[left] + numbers[right]\n    if (current_sum == target) {\n      return(c(left, right))\n    } else if (current_sum < target) {\n      left <- left + 1\n    } else {\n      right <- right - 1\n    }\n  }\n  return(c())\n}\ntest_two_sum_functions <- function() {\n  # Test case 1\n  numbers1 <- c(2, 7, 11, 15)\n  target1 <- 9\n  stopifnot(identical(two_sum_binary_search(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers1, target1), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers1, target1), c(1, 2)))\n  \n  # Test case 2\n  numbers2 <- c(2, 3, 4)\n  target2 <- 6\n  stopifnot(identical(two_sum_binary_search(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_hash_table(numbers2, target2), c(1, 3)))\n  stopifnot(identical(two_sum_two_pointers(numbers2, target2), c(1, 3)))\n  \n  # Test case 3\n  numbers3 <- c(-1, 0)\n  target3 <- -1\n  stopifnot(identical(two_sum_binary_search(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_hash_table(numbers3, target3), c(1, 2)))\n  stopifnot(identical(two_sum_two_pointers(numbers3, target3), c(1, 2)))\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_two_sum_functions()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "longest_valid_word <- function(s) {\n    # Use regular expression to find all sequences of Latin letters\n    words <- regmatches(s, gregexpr(\"[A-Za-z]+\", s, perl = TRUE))[[1]]\n    if (length(words) == 0) {\n        return(\"\")\n    }\n    # Find the longest word\n    longest_word <- words[which.max(nchar(words))]\n    return(longest_word)\n}", "test_cases": "", "test_case_results": "Input: \"Hello, world!\"\nLongest valid word: \"Hello\"\nInput: \"123abc def456\"\nLongest valid word: \"abc\"\nInput: \"!!!\"\nLongest valid word: \"\"\nInput: \"Mixed123 and Matched456Words\"\nLongest valid word: \"Matched\"\nInput: \"SingleWord\"\nLongest valid word: \"SingleWord\"", "task_id": 22126, "assertions": "test_longest_valid_word <- function() {\n    stopifnot(longest_valid_word(\"Hello, world!\") == \"Hello\")\n    stopifnot(longest_valid_word(\"123abc def456\") == \"abc\")\n    stopifnot(longest_valid_word(\"!!!\") == \"\")\n    stopifnot(longest_valid_word(\"Mixed123 and Matched456Words\") == \"Matched\")\n    stopifnot(longest_valid_word(\"SingleWord\") == \"SingleWord\")\n}\n\ntest_longest_valid_word()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_longest_valid_word <- function() {\n    stopifnot(longest_valid_word(\"Hello, world!\") == \"Hello\")\n    stopifnot(longest_valid_word(\"123abc def456\") == \"abc\")\n    stopifnot(longest_valid_word(\"!!!\") == \"\")\n    stopifnot(longest_valid_word(\"Mixed123 and Matched456Words\") == \"Matched\")\n    stopifnot(longest_valid_word(\"SingleWord\") == \"SingleWord\")\n}\n\ntest_longest_valid_word()", "output": "longest_valid_word"}, "all_code": "longest_valid_word <- function(s) {\n    # Use regular expression to find all sequences of Latin letters\n    words <- regmatches(s, gregexpr(\"[A-Za-z]+\", s, perl = TRUE))[[1]]\n    if (length(words) == 0) {\n        return(\"\")\n    }\n    # Find the longest word\n    longest_word <- words[which.max(nchar(words))]\n    return(longest_word)\n}\ntest_longest_valid_word <- function() {\n    stopifnot(longest_valid_word(\"Hello, world!\") == \"Hello\")\n    stopifnot(longest_valid_word(\"123abc def456\") == \"abc\")\n    stopifnot(longest_valid_word(\"!!!\") == \"\")\n    stopifnot(longest_valid_word(\"Mixed123 and Matched456Words\") == \"Matched\")\n    stopifnot(longest_valid_word(\"SingleWord\") == \"SingleWord\")\n}\n\ntest_longest_valid_word()", "exec_outcome": "PASSED"}
{"code": "# minimum_card_pair_subarray_length determines the minimum length of a subarray that contains at least one card pair.\n# It returns -1 if no such subarray exists.\n# \n# Parameters:\n#   cards: A numeric vector representing card numbers.\n#\n# Returns:\n#   The minimum length of a subarray containing at least one card pair, or -1 if not possible.\nminimum_card_pair_subarray_length <- function(cards) {\n    card_indices <- list()\n    min_length <- Inf\n\n    for (i in seq_along(cards)) {\n        card <- cards[i]\n        if (as.character(card) %in% names(card_indices)) {\n            current_length <- i - card_indices[[as.character(card)]] + 1\n            min_length <- min(min_length, current_length)\n        }\n        card_indices[[as.character(card)]] <- i\n    }\n\n    if (is.infinite(min_length)) {\n        return(-1)\n    } else {\n        return(min_length)\n    }\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 5 \nMinimum subarray length with at least one pair:  -1 \nInput:  1 2 3 2 5 \nMinimum subarray length with at least one pair:  3 \nInput:  1 1 1 1 1 \nMinimum subarray length with at least one pair:  2 \nInput:  1 2 3 4 1 \nMinimum subarray length with at least one pair:  5 \nInput:  1 2 3 4 5 6 7 8 9 10 \nMinimum subarray length with at least one pair:  -1 \nInput:  1 2 3 4 5 6 7 8 9 1 \nMinimum subarray length with at least one pair:  10", "task_id": 26565, "assertions": "test_minimum_card_pair_subarray_length <- function() {\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 2, 5)) == 3)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 1, 1, 1, 1)) == 2)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 1)) == 5)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 1)) == 10)\n}\n\ntest_minimum_card_pair_subarray_length()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_minimum_card_pair_subarray_length <- function() {\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 2, 5)) == 3)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 1, 1, 1, 1)) == 2)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 1)) == 5)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 1)) == 10)\n}\n\ntest_minimum_card_pair_subarray_length()", "output": "minimum_card_pair_subarray_length"}, "all_code": "# minimum_card_pair_subarray_length determines the minimum length of a subarray that contains at least one card pair.\n# It returns -1 if no such subarray exists.\n# \n# Parameters:\n#   cards: A numeric vector representing card numbers.\n#\n# Returns:\n#   The minimum length of a subarray containing at least one card pair, or -1 if not possible.\nminimum_card_pair_subarray_length <- function(cards) {\n    card_indices <- list()\n    min_length <- Inf\n\n    for (i in seq_along(cards)) {\n        card <- cards[i]\n        if (as.character(card) %in% names(card_indices)) {\n            current_length <- i - card_indices[[as.character(card)]] + 1\n            min_length <- min(min_length, current_length)\n        }\n        card_indices[[as.character(card)]] <- i\n    }\n\n    if (is.infinite(min_length)) {\n        return(-1)\n    } else {\n        return(min_length)\n    }\n}\ntest_minimum_card_pair_subarray_length <- function() {\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 2, 5)) == 3)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 1, 1, 1, 1)) == 2)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 1)) == 5)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) == -1)\n    stopifnot(minimum_card_pair_subarray_length(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 1)) == 10)\n}\n\ntest_minimum_card_pair_subarray_length()", "exec_outcome": "PASSED"}
{"code": "# count_substring_occurrences counts the number of times a given word appears as a substring in a text.\n# The function joins multiple lines of text into a single string, converts everything to lowercase to ignore case,\n# and then counts the occurrences of the word in the combined text.\n# The function also removes any occurrences of 'END_OF_TEXT' from the text before processing.\ncount_substring_occurrences <- function(word, ...) {\n  # Combine all lines into a single string and convert to lowercase\n  text <- paste(..., collapse = \"\")\n  # Remove 'END_OF_TEXT' from the text\n  text <- gsub(\"END_OF_TEXT\", \"\", text, ignore.case = TRUE)\n  # Convert text and word to lowercase for case-insensitive comparison\n  text <- tolower(text)\n  word <- tolower(word)\n  \n  # Count the number of occurrences of the word in the text\n  count <- sum(gregexpr(word, text, fixed = TRUE)[[1]] > 0)\n  \n  return(count)\n}", "test_cases": "", "test_case_results": "Word:  hello \nText:  Hello world hello there END_OF_TEXT \nCount:  2 \n\nWord:  foo \nText:  foo bar FOO BAR end_of_text \nCount:  2 \n\nWord:  test \nText:  Testing TESTING END_OF_TEXT \nCount:  2 \n\nWord:  r \nText:  R is great r is fun END_OF_TEXT \nCount:  3", "task_id": 17970, "assertions": "test_substring_occurrences <- function() {\n    # Test case 1\n    stopifnot(count_substring_occurrences(\"hello\", \"Hello world\", \"hello there\", \"END_OF_TEXT\") == 2)\n    # Test case 2\n    stopifnot(count_substring_occurrences(\"foo\", \"foo bar\", \"FOO BAR\", \"end_of_text\") == 2)\n    # Test case 3\n    stopifnot(count_substring_occurrences(\"test\", \"Testing\", \"TESTING\", \"END_OF_TEXT\") == 2)\n    # Test case 4\n    stopifnot(count_substring_occurrences(\"r\", \"R is great\", \"r is fun\", \"END_OF_TEXT\") == 3)\n}\n\ntest_substring_occurrences()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_substring_occurrences <- function() {\n    # Test case 1\n    stopifnot(count_substring_occurrences(\"hello\", \"Hello world\", \"hello there\", \"END_OF_TEXT\") == 2)\n    # Test case 2\n    stopifnot(count_substring_occurrences(\"foo\", \"foo bar\", \"FOO BAR\", \"end_of_text\") == 2)\n    # Test case 3\n    stopifnot(count_substring_occurrences(\"test\", \"Testing\", \"TESTING\", \"END_OF_TEXT\") == 2)\n    # Test case 4\n    stopifnot(count_substring_occurrences(\"r\", \"R is great\", \"r is fun\", \"END_OF_TEXT\") == 3)\n}\n\ntest_substring_occurrences()", "output": "count_substring_occurrences"}, "all_code": "# count_substring_occurrences counts the number of times a given word appears as a substring in a text.\n# The function joins multiple lines of text into a single string, converts everything to lowercase to ignore case,\n# and then counts the occurrences of the word in the combined text.\n# The function also removes any occurrences of 'END_OF_TEXT' from the text before processing.\ncount_substring_occurrences <- function(word, ...) {\n  # Combine all lines into a single string and convert to lowercase\n  text <- paste(..., collapse = \"\")\n  # Remove 'END_OF_TEXT' from the text\n  text <- gsub(\"END_OF_TEXT\", \"\", text, ignore.case = TRUE)\n  # Convert text and word to lowercase for case-insensitive comparison\n  text <- tolower(text)\n  word <- tolower(word)\n  \n  # Count the number of occurrences of the word in the text\n  count <- sum(gregexpr(word, text, fixed = TRUE)[[1]] > 0)\n  \n  return(count)\n}\ntest_substring_occurrences <- function() {\n    # Test case 1\n    stopifnot(count_substring_occurrences(\"hello\", \"Hello world\", \"hello there\", \"END_OF_TEXT\") == 2)\n    # Test case 2\n    stopifnot(count_substring_occurrences(\"foo\", \"foo bar\", \"FOO BAR\", \"end_of_text\") == 2)\n    # Test case 3\n    stopifnot(count_substring_occurrences(\"test\", \"Testing\", \"TESTING\", \"END_OF_TEXT\") == 2)\n    # Test case 4\n    stopifnot(count_substring_occurrences(\"r\", \"R is great\", \"r is fun\", \"END_OF_TEXT\") == 3)\n}\n\ntest_substring_occurrences()", "exec_outcome": "PASSED"}
{"code": "has_path_in_maze <- function(maze, start, destination) {\n  rows <- length(maze)\n  if (rows == 0) return(FALSE)\n  cols <- length(maze[[1]])\n  \n  is_valid <- function(x, y) {\n    x >= 1 && x <= rows && y >= 1 && y <= cols && maze[[x]][y] == \".\"\n  }\n  \n  bfs <- function(start) {\n    queue <- list()\n    queue[[1]] <- start\n    visited <- matrix(FALSE, nrow = rows, ncol = cols)\n    visited[start[1], start[2]] <- TRUE\n    \n    while (length(queue) > 0) {\n      current <- queue[[1]]\n      queue <- queue[-1]\n      x <- current[1]\n      y <- current[2]\n      \n      if (x == destination[1] && y == destination[2]) {\n        return(TRUE)\n      }\n      \n      directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n      \n      for (dir in directions) {\n        dx <- dir[1]\n        dy <- dir[2]\n        new_x <- x\n        new_y <- y\n        \n        while (is_valid(new_x + dx, new_y + dy)) {\n          new_x <- new_x + dx\n          new_y <- new_y + dy\n        }\n        \n        if (!visited[new_x, new_y]) {\n          visited[new_x, new_y] <- TRUE\n          queue[[length(queue) + 1]] <- c(new_x, new_y)\n        }\n      }\n    }\n    \n    return(FALSE)\n  }\n  \n  return(bfs(start))\n}", "test_cases": "", "test_case_results": "Test case 1 \nMaze:\n. . . . . \n. X X X . \n. . . . . \n. X X X . \n. . . . . \nStart: 1 1 \nDestination: 5 5 \nHas path: TRUE \n\nTest case 2 \nMaze:\n. . . . . \n. X X X . \n. X . . . \n. X X X . \n. . . . . \nStart: 1 1 \nDestination: 5 5 \nHas path: TRUE \n\nTest case 3 \nMaze:\n. . . . . \n. X X X . \n. . . . . \n. X X X . \n. . . . . \nStart: 3 3 \nDestination: 3 3 \nHas path: TRUE \n\nTest case 4 \nMaze:\n. X . . . \n. X X X . \n. X . . . \n. X X X . \n. X . . . \nStart: 1 1 \nDestination: 5 5 \nHas path: FALSE", "task_id": 22555, "assertions": "test_maze_path <- function() {\n  maze1 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start1 <- c(1, 1)\n  destination1 <- c(5, 5)\n  \n  maze2 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start2 <- c(1, 1)\n  destination2 <- c(5, 5)\n  \n  maze3 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start3 <- c(3, 3)\n  destination3 <- c(3, 3)\n  \n  maze4 <- list(\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\")\n  )\n  start4 <- c(1, 1)\n  destination4 <- c(5, 5)\n  \n  stopifnot(has_path_in_maze(maze1, start1, destination1) == TRUE)\n  stopifnot(has_path_in_maze(maze2, start2, destination2) == TRUE)\n  stopifnot(has_path_in_maze(maze3, start3, destination3) == TRUE)\n  stopifnot(has_path_in_maze(maze4, start4, destination4) == FALSE)\n}\n\ntest_maze_path()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_maze_path <- function() {\n  maze1 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start1 <- c(1, 1)\n  destination1 <- c(5, 5)\n  \n  maze2 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start2 <- c(1, 1)\n  destination2 <- c(5, 5)\n  \n  maze3 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start3 <- c(3, 3)\n  destination3 <- c(3, 3)\n  \n  maze4 <- list(\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\")\n  )\n  start4 <- c(1, 1)\n  destination4 <- c(5, 5)\n  \n  stopifnot(has_path_in_maze(maze1, start1, destination1) == TRUE)\n  stopifnot(has_path_in_maze(maze2, start2, destination2) == TRUE)\n  stopifnot(has_path_in_maze(maze3, start3, destination3) == TRUE)\n  stopifnot(has_path_in_maze(maze4, start4, destination4) == FALSE)\n}\n\ntest_maze_path()", "output": "has_path_in_maze"}, "all_code": "has_path_in_maze <- function(maze, start, destination) {\n  rows <- length(maze)\n  if (rows == 0) return(FALSE)\n  cols <- length(maze[[1]])\n  \n  is_valid <- function(x, y) {\n    x >= 1 && x <= rows && y >= 1 && y <= cols && maze[[x]][y] == \".\"\n  }\n  \n  bfs <- function(start) {\n    queue <- list()\n    queue[[1]] <- start\n    visited <- matrix(FALSE, nrow = rows, ncol = cols)\n    visited[start[1], start[2]] <- TRUE\n    \n    while (length(queue) > 0) {\n      current <- queue[[1]]\n      queue <- queue[-1]\n      x <- current[1]\n      y <- current[2]\n      \n      if (x == destination[1] && y == destination[2]) {\n        return(TRUE)\n      }\n      \n      directions <- list(c(-1, 0), c(1, 0), c(0, -1), c(0, 1))\n      \n      for (dir in directions) {\n        dx <- dir[1]\n        dy <- dir[2]\n        new_x <- x\n        new_y <- y\n        \n        while (is_valid(new_x + dx, new_y + dy)) {\n          new_x <- new_x + dx\n          new_y <- new_y + dy\n        }\n        \n        if (!visited[new_x, new_y]) {\n          visited[new_x, new_y] <- TRUE\n          queue[[length(queue) + 1]] <- c(new_x, new_y)\n        }\n      }\n    }\n    \n    return(FALSE)\n  }\n  \n  return(bfs(start))\n}\ntest_maze_path <- function() {\n  maze1 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start1 <- c(1, 1)\n  destination1 <- c(5, 5)\n  \n  maze2 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start2 <- c(1, 1)\n  destination2 <- c(5, 5)\n  \n  maze3 <- list(\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \".\", \".\", \".\", \".\")\n  )\n  start3 <- c(3, 3)\n  destination3 <- c(3, 3)\n  \n  maze4 <- list(\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\"),\n    c(\".\", \"X\", \"X\", \"X\", \".\"),\n    c(\".\", \"X\", \".\", \".\", \".\")\n  )\n  start4 <- c(1, 1)\n  destination4 <- c(5, 5)\n  \n  stopifnot(has_path_in_maze(maze1, start1, destination1) == TRUE)\n  stopifnot(has_path_in_maze(maze2, start2, destination2) == TRUE)\n  stopifnot(has_path_in_maze(maze3, start3, destination3) == TRUE)\n  stopifnot(has_path_in_maze(maze4, start4, destination4) == FALSE)\n}\n\ntest_maze_path()", "exec_outcome": "PASSED"}
{"code": "# count_ways_to_tile calculates the number of ways to tile a 2 x n board using 2 x 1 tiles.\n# It uses dynamic programming to solve the problem, where dp[i] represents the number of ways to tile a 2 x i board.\n# The recurrence relation is dp[i] = dp[i-1] + dp[i-2], similar to the Fibonacci sequence.\n# The result is returned modulo 10^9 + 7 to handle large numbers.\ncount_ways_to_tile <- function(n) {\n  MOD <- 10^9 + 7\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(1)\n  }\n  dp <- integer(n + 1)\n  dp[1] <- 1  # dp[0] is 1, but R uses 1-based indexing, so dp[1] corresponds to n=0\n  dp[2] <- 1  # dp[2] corresponds to n=1\n  for (i in 3:(n + 1)) {\n    dp[i] <- (dp[i - 1] + dp[i - 2]) %% MOD\n  }\n  return(dp[n + 1])\n}", "test_cases": "", "test_case_results": "Input n:  0 \nNumber of ways to tile:  1 \nInput n:  1 \nNumber of ways to tile:  1 \nInput n:  2 \nNumber of ways to tile:  2 \nInput n:  3 \nNumber of ways to tile:  3 \nInput n:  4 \nNumber of ways to tile:  5 \nInput n:  5 \nNumber of ways to tile:  8", "task_id": 11654, "assertions": "test_tiling <- function() {\n    stopifnot(count_ways_to_tile(0) == 1)\n    stopifnot(count_ways_to_tile(1) == 1)\n    stopifnot(count_ways_to_tile(2) == 2)\n    stopifnot(count_ways_to_tile(3) == 3)\n    stopifnot(count_ways_to_tile(4) == 5)\n    stopifnot(count_ways_to_tile(5) == 8)\n}\n\ntest_tiling()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_tiling <- function() {\n    stopifnot(count_ways_to_tile(0) == 1)\n    stopifnot(count_ways_to_tile(1) == 1)\n    stopifnot(count_ways_to_tile(2) == 2)\n    stopifnot(count_ways_to_tile(3) == 3)\n    stopifnot(count_ways_to_tile(4) == 5)\n    stopifnot(count_ways_to_tile(5) == 8)\n}\n\ntest_tiling()", "output": "count_ways_to_tile"}, "all_code": "# count_ways_to_tile calculates the number of ways to tile a 2 x n board using 2 x 1 tiles.\n# It uses dynamic programming to solve the problem, where dp[i] represents the number of ways to tile a 2 x i board.\n# The recurrence relation is dp[i] = dp[i-1] + dp[i-2], similar to the Fibonacci sequence.\n# The result is returned modulo 10^9 + 7 to handle large numbers.\ncount_ways_to_tile <- function(n) {\n  MOD <- 10^9 + 7\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(1)\n  }\n  dp <- integer(n + 1)\n  dp[1] <- 1  # dp[0] is 1, but R uses 1-based indexing, so dp[1] corresponds to n=0\n  dp[2] <- 1  # dp[2] corresponds to n=1\n  for (i in 3:(n + 1)) {\n    dp[i] <- (dp[i - 1] + dp[i - 2]) %% MOD\n  }\n  return(dp[n + 1])\n}\ntest_tiling <- function() {\n    stopifnot(count_ways_to_tile(0) == 1)\n    stopifnot(count_ways_to_tile(1) == 1)\n    stopifnot(count_ways_to_tile(2) == 2)\n    stopifnot(count_ways_to_tile(3) == 3)\n    stopifnot(count_ways_to_tile(4) == 5)\n    stopifnot(count_ways_to_tile(5) == 8)\n}\n\ntest_tiling()", "exec_outcome": "PASSED"}
{"code": "# is_all_nested_lists checks whether all elements in the provided list are lists, including nested ones.\n# \n# Parameters:\n#   lst (list): The list to check.\n#\n# Returns:\n#   logical: TRUE if all elements are lists, including nested ones, FALSE otherwise.\nis_all_nested_lists <- function(lst) {\n  if (!is.list(lst)) {\n    return(FALSE)\n  }\n  for (element in lst) {\n    if (!is.list(element)) {\n      return(FALSE)\n    }\n    if (!is_all_nested_lists(element)) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}", "test_cases": "", "test_case_results": "Input: [[1]]\nlist()\n\n[[2]]\n[[2]][[1]]\nlist()\n\n\nResult:  TRUE \n\nInput: [[1]]\nlist()\n\n[[2]]\n[1] \"not a list\"\n\nResult:  FALSE \n\nInput: [[1]]\nlist()\n\n[[2]]\n[[2]][[1]]\n[1] 1\n\n[[2]][[2]]\n[1] 2\n\n[[2]][[3]]\n[1] 3\n\n\nResult:  FALSE \n\nInput: [1] \"not a list\"\nResult:  FALSE \n\nInput: [[1]]\n[[1]][[1]]\nlist()\n\n\n[[2]]\n[[2]][[1]]\n[[2]][[1]][[1]]\nlist()\n\n\n\nResult:  TRUE", "task_id": 4006, "assertions": "test_nested_lists <- function() {\n    # Test case 1: All nested lists\n    stopifnot(is_all_nested_lists(list(list(), list(list()))) == TRUE)\n    \n    # Test case 2: Contains a non-list element\n    stopifnot(is_all_nested_lists(list(list(), \"not a list\")) == FALSE)\n    \n    # Test case 3: Contains a list with non-list elements\n    stopifnot(is_all_nested_lists(list(list(), list(1, 2, 3))) == FALSE)\n    \n    # Test case 4: Not a list at all\n    stopifnot(is_all_nested_lists(\"not a list\") == FALSE)\n    \n    # Test case 5: Deeply nested lists\n    stopifnot(is_all_nested_lists(list(list(list()), list(list(list()))))) == TRUE)\n}\n\ntest_nested_lists()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_nested_lists <- function() {\n    # Test case 1: All nested lists\n    stopifnot(is_all_nested_lists(list(list(), list(list()))) == TRUE)\n    \n    # Test case 2: Contains a non-list element\n    stopifnot(is_all_nested_lists(list(list(), \"not a list\")) == FALSE)\n    \n    # Test case 3: Contains a list with non-list elements\n    stopifnot(is_all_nested_lists(list(list(), list(1, 2, 3))) == FALSE)\n    \n    # Test case 4: Not a list at all\n    stopifnot(is_all_nested_lists(\"not a list\") == FALSE)\n    \n    # Test case 5: Deeply nested lists\n    stopifnot(is_all_nested_lists(list(list(list()), list(list(list()))))) == TRUE)\n}\n\ntest_nested_lists()", "output": "is_all_nested_lists"}, "all_code": "# is_all_nested_lists checks whether all elements in the provided list are lists, including nested ones.\n# \n# Parameters:\n#   lst (list): The list to check.\n#\n# Returns:\n#   logical: TRUE if all elements are lists, including nested ones, FALSE otherwise.\nis_all_nested_lists <- function(lst) {\n  if (!is.list(lst)) {\n    return(FALSE)\n  }\n  for (element in lst) {\n    if (!is.list(element)) {\n      return(FALSE)\n    }\n    if (!is_all_nested_lists(element)) {\n      return(FALSE)\n    }\n  }\n  return(TRUE)\n}\ntest_nested_lists <- function() {\n    # Test case 1: All nested lists\n    stopifnot(is_all_nested_lists(list(list(), list(list()))) == TRUE)\n    \n    # Test case 2: Contains a non-list element\n    stopifnot(is_all_nested_lists(list(list(), \"not a list\")) == FALSE)\n    \n    # Test case 3: Contains a list with non-list elements\n    stopifnot(is_all_nested_lists(list(list(), list(1, 2, 3))) == FALSE)\n    \n    # Test case 4: Not a list at all\n    stopifnot(is_all_nested_lists(\"not a list\") == FALSE)\n    \n    # Test case 5: Deeply nested lists\n    stopifnot(is_all_nested_lists(list(list(list()), list(list(list()))))) == TRUE)\n}\n\ntest_nested_lists()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# numbers_to_ascii converts a list of numbers into a list of their ASCII character representations.\n# Only the first 256 possible ASCII characters are considered. Numbers outside this range are converted to '?'.\n#\n# Parameters:\n#   lst (numeric vector): Vector of integers.\n#\n# Returns:\n#   character vector: Vector of ASCII character representations for given integers in the input vector.\nnumbers_to_ascii <- function(lst) {\n  sapply(lst, function(num) {\n    if (0 <= num && num < 256) {\n      intToUtf8(num)\n    } else {\n      '?'\n    }\n  })\n}", "test_cases": "", "test_case_results": "Input:  65 66 67 \nASCII:  A B C \n\nInput:  97 98 99 \nASCII:  a b c \n\nInput:  0 127 255 \nASCII:     \n\nInput:  -1 256 1000 \nASCII:  ? ? ? \n\nInput:  72 101 108 108 111 \nASCII:  H e l l o", "task_id": 23974, "assertions": "test_numbers_to_ascii <- function() {\n  stopifnot(identical(numbers_to_ascii(c(65, 66, 67)), c(\"A\", \"B\", \"C\")))\n  stopifnot(identical(numbers_to_ascii(c(97, 98, 99)), c(\"a\", \"b\", \"c\")))\n  stopifnot(identical(numbers_to_ascii(c(0, 127, 255)), c(\"\\x00\", \"\\x7f\", \"\")))\n  stopifnot(identical(numbers_to_ascii(c(-1, 256, 1000)), c(\"?\", \"?\", \"?\")))\n  stopifnot(identical(numbers_to_ascii(c(72, 101, 108, 108, 111)), c(\"H\", \"e\", \"l\", \"l\", \"o\")))\n}\n\ntest_numbers_to_ascii()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_numbers_to_ascii <- function() {\n  stopifnot(identical(numbers_to_ascii(c(65, 66, 67)), c(\"A\", \"B\", \"C\")))\n  stopifnot(identical(numbers_to_ascii(c(97, 98, 99)), c(\"a\", \"b\", \"c\")))\n  stopifnot(identical(numbers_to_ascii(c(0, 127, 255)), c(\"\\x00\", \"\\x7f\", \"\")))\n  stopifnot(identical(numbers_to_ascii(c(-1, 256, 1000)), c(\"?\", \"?\", \"?\")))\n  stopifnot(identical(numbers_to_ascii(c(72, 101, 108, 108, 111)), c(\"H\", \"e\", \"l\", \"l\", \"o\")))\n}\n\ntest_numbers_to_ascii()", "output": "numbers_to_ascii"}, "all_code": "# numbers_to_ascii converts a list of numbers into a list of their ASCII character representations.\n# Only the first 256 possible ASCII characters are considered. Numbers outside this range are converted to '?'.\n#\n# Parameters:\n#   lst (numeric vector): Vector of integers.\n#\n# Returns:\n#   character vector: Vector of ASCII character representations for given integers in the input vector.\nnumbers_to_ascii <- function(lst) {\n  sapply(lst, function(num) {\n    if (0 <= num && num < 256) {\n      intToUtf8(num)\n    } else {\n      '?'\n    }\n  })\n}\ntest_numbers_to_ascii <- function() {\n  stopifnot(identical(numbers_to_ascii(c(65, 66, 67)), c(\"A\", \"B\", \"C\")))\n  stopifnot(identical(numbers_to_ascii(c(97, 98, 99)), c(\"a\", \"b\", \"c\")))\n  stopifnot(identical(numbers_to_ascii(c(0, 127, 255)), c(\"\\x00\", \"\\x7f\", \"\")))\n  stopifnot(identical(numbers_to_ascii(c(-1, 256, 1000)), c(\"?\", \"?\", \"?\")))\n  stopifnot(identical(numbers_to_ascii(c(72, 101, 108, 108, 111)), c(\"H\", \"e\", \"l\", \"l\", \"o\")))\n}\n\ntest_numbers_to_ascii()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# count_islands calculates the number of \"islands\" in a numeric vector.\n# An \"island\" is defined as a contiguous sequence of increasing numbers.\n# The function iterates through the vector and counts each increasing sequence as a single island.\n# If the vector has fewer than 2 elements, it returns 0 since no islands can exist.\ncount_islands <- function(arr) {\n  if (length(arr) < 2) {\n    return(0)\n  }\n  \n  count <- 0\n  i <- 1  # R uses 1-based indexing\n  \n  while (i < length(arr)) {\n    if (arr[i] < arr[i + 1]) {\n      count <- count + 1\n      while (i < length(arr) && arr[i] <= arr[i + 1]) {\n        i <- i + 1\n      }\n    }\n    i <- i + 1\n  }\n  \n  return(count)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nNumber of islands:  1 \nInput:  4 3 2 1 \nNumber of islands:  0 \nInput:  1 3 2 4 \nNumber of islands:  2 \nInput:  1 2 1 2 1 2 \nNumber of islands:  3 \nInput:  1 \nNumber of islands:  0 \nInput:  \nNumber of islands:  0", "task_id": 8578, "assertions": "test_count_islands <- function() {\n    stopifnot(count_islands(c(1, 2, 3, 4)) == 1)\n    stopifnot(count_islands(c(4, 3, 2, 1)) == 0)\n    stopifnot(count_islands(c(1, 3, 2, 4)) == 2)\n    stopifnot(count_islands(c(1, 2, 1, 2, 1, 2)) == 3)\n    stopifnot(count_islands(c(1)) == 0)\n    stopifnot(count_islands(c()) == 0)\n}\n\ntest_count_islands()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_count_islands <- function() {\n    stopifnot(count_islands(c(1, 2, 3, 4)) == 1)\n    stopifnot(count_islands(c(4, 3, 2, 1)) == 0)\n    stopifnot(count_islands(c(1, 3, 2, 4)) == 2)\n    stopifnot(count_islands(c(1, 2, 1, 2, 1, 2)) == 3)\n    stopifnot(count_islands(c(1)) == 0)\n    stopifnot(count_islands(c()) == 0)\n}\n\ntest_count_islands()", "output": "count_islands"}, "all_code": "# count_islands calculates the number of \"islands\" in a numeric vector.\n# An \"island\" is defined as a contiguous sequence of increasing numbers.\n# The function iterates through the vector and counts each increasing sequence as a single island.\n# If the vector has fewer than 2 elements, it returns 0 since no islands can exist.\ncount_islands <- function(arr) {\n  if (length(arr) < 2) {\n    return(0)\n  }\n  \n  count <- 0\n  i <- 1  # R uses 1-based indexing\n  \n  while (i < length(arr)) {\n    if (arr[i] < arr[i + 1]) {\n      count <- count + 1\n      while (i < length(arr) && arr[i] <= arr[i + 1]) {\n        i <- i + 1\n      }\n    }\n    i <- i + 1\n  }\n  \n  return(count)\n}\ntest_count_islands <- function() {\n    stopifnot(count_islands(c(1, 2, 3, 4)) == 1)\n    stopifnot(count_islands(c(4, 3, 2, 1)) == 0)\n    stopifnot(count_islands(c(1, 3, 2, 4)) == 2)\n    stopifnot(count_islands(c(1, 2, 1, 2, 1, 2)) == 3)\n    stopifnot(count_islands(c(1)) == 0)\n    stopifnot(count_islands(c()) == 0)\n}\n\ntest_count_islands()", "exec_outcome": "PASSED"}
{"code": "# efficient_remove_duplicates returns a new vector with duplicates removed, \n# keeping only the first occurrence of each element and maintaining the initial order.\n# It uses a hash set to track seen elements for efficient lookup.\nefficient_remove_duplicates <- function(array) {\n  seen <- new.env(hash = TRUE, size = length(array))\n  result <- vector()\n  for (item in array) {\n    if (!exists(as.character(item), envir = seen)) {\n      seen[[as.character(item)]] <- TRUE\n      result <- c(result, item)\n    }\n  }\n  return(result)\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nResult:  1 2 3 4 \nInput:  5 6 7 5 6 8 \nResult:  5 6 7 8 \nInput:  0 0 0 0 \nResult:  0 \nInput:  a b a c b \nResult:  a b \nInput:  TRUE FALSE TRUE FALSE \nResult:  TRUE FALSE", "task_id": 5364, "assertions": "test_remove_duplicates <- function() {\n    stopifnot(identical(efficient_remove_duplicates(c(1, 2, 3, 4)), c(1, 2, 3, 4)))\n    stopifnot(identical(efficient_remove_duplicates(c(5, 6, 7, 5, 6, 8)), c(5, 6, 7, 8)))\n    stopifnot(identical(efficient_remove_duplicates(c(0, 0, 0, 0)), 0))\n    stopifnot(identical(efficient_remove_duplicates(c(\"a\", \"b\", \"a\", \"c\", \"b\")), c(\"a\", \"b\", \"c\")))\n    stopifnot(identical(efficient_remove_duplicates(c(TRUE, FALSE, TRUE, FALSE)), c(TRUE, FALSE)))\n}\n\ntest_remove_duplicates()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_remove_duplicates <- function() {\n    stopifnot(identical(efficient_remove_duplicates(c(1, 2, 3, 4)), c(1, 2, 3, 4)))\n    stopifnot(identical(efficient_remove_duplicates(c(5, 6, 7, 5, 6, 8)), c(5, 6, 7, 8)))\n    stopifnot(identical(efficient_remove_duplicates(c(0, 0, 0, 0)), 0))\n    stopifnot(identical(efficient_remove_duplicates(c(\"a\", \"b\", \"a\", \"c\", \"b\")), c(\"a\", \"b\", \"c\")))\n    stopifnot(identical(efficient_remove_duplicates(c(TRUE, FALSE, TRUE, FALSE)), c(TRUE, FALSE)))\n}\n\ntest_remove_duplicates()", "output": "efficient_remove_duplicates"}, "all_code": "# efficient_remove_duplicates returns a new vector with duplicates removed, \n# keeping only the first occurrence of each element and maintaining the initial order.\n# It uses a hash set to track seen elements for efficient lookup.\nefficient_remove_duplicates <- function(array) {\n  seen <- new.env(hash = TRUE, size = length(array))\n  result <- vector()\n  for (item in array) {\n    if (!exists(as.character(item), envir = seen)) {\n      seen[[as.character(item)]] <- TRUE\n      result <- c(result, item)\n    }\n  }\n  return(result)\n}\ntest_remove_duplicates <- function() {\n    stopifnot(identical(efficient_remove_duplicates(c(1, 2, 3, 4)), c(1, 2, 3, 4)))\n    stopifnot(identical(efficient_remove_duplicates(c(5, 6, 7, 5, 6, 8)), c(5, 6, 7, 8)))\n    stopifnot(identical(efficient_remove_duplicates(c(0, 0, 0, 0)), 0))\n    stopifnot(identical(efficient_remove_duplicates(c(\"a\", \"b\", \"a\", \"c\", \"b\")), c(\"a\", \"b\", \"c\")))\n    stopifnot(identical(efficient_remove_duplicates(c(TRUE, FALSE, TRUE, FALSE)), c(TRUE, FALSE)))\n}\n\ntest_remove_duplicates()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "# max_widgets calculates the maximum number of different types of widgets that can be produced\n# without exceeding the total material limit. The function sorts the material requirements\n# and iteratively adds the smallest remaining material requirements until the total material\n# limit is reached.\n#\n# Parameters:\n# n (int): Number of different types of widgets.\n# m (int): Total amount of material available.\n# materials (numeric vector): Amount of material required for each type of widget.\n#\n# Returns:\n# int: The maximum number of different types of widgets that can be produced.\nmax_widgets <- function(n, m, materials) {\n  materials <- sort(materials)\n  total_material_used <- 0\n  widget_count <- 0\n\n  for (material in materials) {\n    if (total_material_used + material <= m) {\n      total_material_used <- total_material_used + material\n      widget_count <- widget_count + 1\n    } else {\n      break\n    }\n  }\n\n  return(widget_count)\n}", "test_cases": "", "test_case_results": "Input - n:  3 , m:  10 , materials:  3 5 2 \nMaximum number of widgets:  3 \nInput - n:  5 , m:  15 , materials:  1 2 3 4 5 \nMaximum number of widgets:  5 \nInput - n:  4 , m:  20 , materials:  10 20 30 40 \nMaximum number of widgets:  1 \nInput - n:  2 , m:  5 , materials:  6 7 \nMaximum number of widgets:  0", "task_id": 23729, "assertions": "test_max_widgets <- function() {\n  # Test case 1\n  stopifnot(max_widgets(3, 10, c(3, 5, 2)) == 3)\n  \n  # Test case 2\n  stopifnot(max_widgets(5, 15, c(1, 2, 3, 4, 5)) == 5)\n  \n  # Test case 3\n  stopifnot(max_widgets(4, 20, c(10, 20, 30, 40)) == 1)\n  \n  # Test case 4\n  stopifnot(max_widgets(2, 5, c(6, 7)) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_widgets()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_widgets <- function() {\n  # Test case 1\n  stopifnot(max_widgets(3, 10, c(3, 5, 2)) == 3)\n  \n  # Test case 2\n  stopifnot(max_widgets(5, 15, c(1, 2, 3, 4, 5)) == 5)\n  \n  # Test case 3\n  stopifnot(max_widgets(4, 20, c(10, 20, 30, 40)) == 1)\n  \n  # Test case 4\n  stopifnot(max_widgets(2, 5, c(6, 7)) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_widgets()", "output": "max_widgets"}, "all_code": "# max_widgets calculates the maximum number of different types of widgets that can be produced\n# without exceeding the total material limit. The function sorts the material requirements\n# and iteratively adds the smallest remaining material requirements until the total material\n# limit is reached.\n#\n# Parameters:\n# n (int): Number of different types of widgets.\n# m (int): Total amount of material available.\n# materials (numeric vector): Amount of material required for each type of widget.\n#\n# Returns:\n# int: The maximum number of different types of widgets that can be produced.\nmax_widgets <- function(n, m, materials) {\n  materials <- sort(materials)\n  total_material_used <- 0\n  widget_count <- 0\n\n  for (material in materials) {\n    if (total_material_used + material <= m) {\n      total_material_used <- total_material_used + material\n      widget_count <- widget_count + 1\n    } else {\n      break\n    }\n  }\n\n  return(widget_count)\n}\ntest_max_widgets <- function() {\n  # Test case 1\n  stopifnot(max_widgets(3, 10, c(3, 5, 2)) == 3)\n  \n  # Test case 2\n  stopifnot(max_widgets(5, 15, c(1, 2, 3, 4, 5)) == 5)\n  \n  # Test case 3\n  stopifnot(max_widgets(4, 20, c(10, 20, 30, 40)) == 1)\n  \n  # Test case 4\n  stopifnot(max_widgets(2, 5, c(6, 7)) == 0)\n  \n  cat(\"All test cases passed successfully.\\n\")\n}\n\ntest_max_widgets()", "exec_outcome": "PASSED"}
{"code": "# is_valid_url checks if a given string is a properly formatted URL.\n# It uses a regular expression to validate the URL structure, including:\n# - Protocol (http:// or https://)\n# - Domain name (with optional subdomains and TLD)\n# - Optional port number\n# - Optional path, query parameters, and fragment\n# The function returns TRUE if the URL is valid, FALSE otherwise.\nis_valid_url <- function(url) {\n  regex <- \"^((https?)://)?([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,}(:\\\\d+)?(/[-a-z0-9%@_.+~#=]*)*(\\\\?[;&a-z0-9%@_.,~+=-]*)?(#[a-z0-9_]*)?$\"\n  return(grepl(regex, url, ignore.case = TRUE))\n}", "test_cases": "", "test_case_results": "Input: \"http://example.com\"\nIs valid URL: TRUE\n\nInput: \"https://sub.example.com/path?query=param\"\nIs valid URL: TRUE\n\nInput: \"ftp://invalid.com\"\nIs valid URL: FALSE\n\nInput: \"http://localhost:8080\"\nIs valid URL: FALSE\n\nInput: \"not-a-url\"\nIs valid URL: FALSE\n\nInput: \"http://example..com\"\nIs valid URL: FALSE\n\nInput: \"https://example.com/path#fragment\"\nIs valid URL: TRUE", "task_id": 6191, "assertions": "test_url_validation <- function() {\n    stopifnot(is_valid_url(\"http://example.com\") == TRUE)\n    stopifnot(is_valid_url(\"https://sub.example.com/path?query=param\") == TRUE)\n    stopifnot(is_valid_url(\"ftp://invalid.com\") == FALSE)\n    stopifnot(is_valid_url(\"http://localhost:8080\") == FALSE)\n    stopifnot(is_valid_url(\"not-a-url\") == FALSE)\n    stopifnot(is_valid_url(\"http://example..com\") == FALSE)\n    stopifnot(is_valid_url(\"https://example.com/path#fragment\") == TRUE)\n}\n\ntest_url_validation()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_url_validation <- function() {\n    stopifnot(is_valid_url(\"http://example.com\") == TRUE)\n    stopifnot(is_valid_url(\"https://sub.example.com/path?query=param\") == TRUE)\n    stopifnot(is_valid_url(\"ftp://invalid.com\") == FALSE)\n    stopifnot(is_valid_url(\"http://localhost:8080\") == FALSE)\n    stopifnot(is_valid_url(\"not-a-url\") == FALSE)\n    stopifnot(is_valid_url(\"http://example..com\") == FALSE)\n    stopifnot(is_valid_url(\"https://example.com/path#fragment\") == TRUE)\n}\n\ntest_url_validation()", "output": "is_valid_url"}, "all_code": "# is_valid_url checks if a given string is a properly formatted URL.\n# It uses a regular expression to validate the URL structure, including:\n# - Protocol (http:// or https://)\n# - Domain name (with optional subdomains and TLD)\n# - Optional port number\n# - Optional path, query parameters, and fragment\n# The function returns TRUE if the URL is valid, FALSE otherwise.\nis_valid_url <- function(url) {\n  regex <- \"^((https?)://)?([a-z0-9]+(-[a-z0-9]+)*\\\\.)+[a-z]{2,}(:\\\\d+)?(/[-a-z0-9%@_.+~#=]*)*(\\\\?[;&a-z0-9%@_.,~+=-]*)?(#[a-z0-9_]*)?$\"\n  return(grepl(regex, url, ignore.case = TRUE))\n}\ntest_url_validation <- function() {\n    stopifnot(is_valid_url(\"http://example.com\") == TRUE)\n    stopifnot(is_valid_url(\"https://sub.example.com/path?query=param\") == TRUE)\n    stopifnot(is_valid_url(\"ftp://invalid.com\") == FALSE)\n    stopifnot(is_valid_url(\"http://localhost:8080\") == FALSE)\n    stopifnot(is_valid_url(\"not-a-url\") == FALSE)\n    stopifnot(is_valid_url(\"http://example..com\") == FALSE)\n    stopifnot(is_valid_url(\"https://example.com/path#fragment\") == TRUE)\n}\n\ntest_url_validation()", "exec_outcome": "PASSED"}
{"code": "# can_split_into_sections checks if a book can be split into sections each containing exactly 2 consecutive pages.\n# The function takes a vector of page numbers and returns 'YES' if the splitting is possible, 'NO' otherwise.\n# The logic involves checking if the total number of pages is even and if each pair of consecutive pages meets the criteria.\ncan_split_into_sections <- function(pages) {\n    # Check if the number of pages is even\n    n <- length(pages)\n    if (n %% 2 != 0) {\n        return('NO')\n    }\n    \n    # Iterate through the list of pages and check if each pair of pages\n    # can form a section of 2 consecutive pages\n    for (i in seq(1, n, by = 2)) {\n        if (pages[i] == pages[i + 1] - 1 || pages[i] == pages[i + 1] + 1) {\n            next\n        } else {\n            return('NO')\n        }\n    }\n    \n    return('YES')\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nResult:  YES \nInput:  4 3 2 1 \nResult:  YES \nInput:  1 3 2 4 \nResult:  NO \nInput:  1 2 3 4 5 \nResult:  NO \nInput:  5 6 \nResult:  YES", "task_id": 11730, "assertions": "test_can_split_into_sections <- function() {\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4)) == 'YES')\n    stopifnot(can_split_into_sections(c(4, 3, 2, 1)) == 'YES')\n    stopifnot(can_split_into_sections(c(1, 3, 2, 4)) == 'NO')\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4, 5)) == 'NO')\n    stopifnot(can_split_into_sections(c(5, 6)) == 'YES')\n}\n\ntest_can_split_into_sections()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_can_split_into_sections <- function() {\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4)) == 'YES')\n    stopifnot(can_split_into_sections(c(4, 3, 2, 1)) == 'YES')\n    stopifnot(can_split_into_sections(c(1, 3, 2, 4)) == 'NO')\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4, 5)) == 'NO')\n    stopifnot(can_split_into_sections(c(5, 6)) == 'YES')\n}\n\ntest_can_split_into_sections()", "output": "can_split_into_sections"}, "all_code": "# can_split_into_sections checks if a book can be split into sections each containing exactly 2 consecutive pages.\n# The function takes a vector of page numbers and returns 'YES' if the splitting is possible, 'NO' otherwise.\n# The logic involves checking if the total number of pages is even and if each pair of consecutive pages meets the criteria.\ncan_split_into_sections <- function(pages) {\n    # Check if the number of pages is even\n    n <- length(pages)\n    if (n %% 2 != 0) {\n        return('NO')\n    }\n    \n    # Iterate through the list of pages and check if each pair of pages\n    # can form a section of 2 consecutive pages\n    for (i in seq(1, n, by = 2)) {\n        if (pages[i] == pages[i + 1] - 1 || pages[i] == pages[i + 1] + 1) {\n            next\n        } else {\n            return('NO')\n        }\n    }\n    \n    return('YES')\n}\ntest_can_split_into_sections <- function() {\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4)) == 'YES')\n    stopifnot(can_split_into_sections(c(4, 3, 2, 1)) == 'YES')\n    stopifnot(can_split_into_sections(c(1, 3, 2, 4)) == 'NO')\n    stopifnot(can_split_into_sections(c(1, 2, 3, 4, 5)) == 'NO')\n    stopifnot(can_split_into_sections(c(5, 6)) == 'YES')\n}\n\ntest_can_split_into_sections()", "exec_outcome": "PASSED"}
{"code": "# is_rotation checks if string s2 is a rotation of string s1.\n# A rotation means that s2 can be formed by rotating the characters of s1.\n# For example, \"erbottlewat\" is a rotation of \"waterbottle\".\n# The function uses the logic that if s2 is a rotation of s1, then s2 must be a substring of s1 concatenated with itself.\n# If the lengths of s1 and s2 are different, it immediately returns FALSE.\nis_rotation <- function(s1, s2) {\n    if (nchar(s1) != nchar(s2)) {\n        return(FALSE)\n    }\n\n    # Concatenate s1 with itself\n    concatenated <- paste0(s1, s1)\n    \n    # Check if s2 is a substring of the concatenated string\n    return(grepl(s2, concatenated, fixed = TRUE))\n}", "test_cases": "", "test_case_results": "Input: s1 = 'waterbottle', s2 = 'erbottlewat'\nIs rotation: TRUE\nInput: s1 = 'hello', s2 = 'llohe'\nIs rotation: TRUE\nInput: s1 = 'abc', s2 = 'def'\nIs rotation: FALSE\nInput: s1 = 'abc', s2 = 'abcd'\nIs rotation: FALSE\nInput: s1 = '', s2 = ''\nIs rotation: TRUE", "task_id": 20363, "assertions": "test_rotation <- function() {\n    stopifnot(is_rotation(\"waterbottle\", \"erbottlewat\") == TRUE)\n    stopifnot(is_rotation(\"hello\", \"llohe\") == TRUE)\n    stopifnot(is_rotation(\"abc\", \"def\") == FALSE)\n    stopifnot(is_rotation(\"abc\", \"abcd\") == FALSE)\n    stopifnot(is_rotation(\"\", \"\") == TRUE)\n}\n\ntest_rotation()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_rotation <- function() {\n    stopifnot(is_rotation(\"waterbottle\", \"erbottlewat\") == TRUE)\n    stopifnot(is_rotation(\"hello\", \"llohe\") == TRUE)\n    stopifnot(is_rotation(\"abc\", \"def\") == FALSE)\n    stopifnot(is_rotation(\"abc\", \"abcd\") == FALSE)\n    stopifnot(is_rotation(\"\", \"\") == TRUE)\n}\n\ntest_rotation()", "output": "is_rotation"}, "all_code": "# is_rotation checks if string s2 is a rotation of string s1.\n# A rotation means that s2 can be formed by rotating the characters of s1.\n# For example, \"erbottlewat\" is a rotation of \"waterbottle\".\n# The function uses the logic that if s2 is a rotation of s1, then s2 must be a substring of s1 concatenated with itself.\n# If the lengths of s1 and s2 are different, it immediately returns FALSE.\nis_rotation <- function(s1, s2) {\n    if (nchar(s1) != nchar(s2)) {\n        return(FALSE)\n    }\n\n    # Concatenate s1 with itself\n    concatenated <- paste0(s1, s1)\n    \n    # Check if s2 is a substring of the concatenated string\n    return(grepl(s2, concatenated, fixed = TRUE))\n}\ntest_rotation <- function() {\n    stopifnot(is_rotation(\"waterbottle\", \"erbottlewat\") == TRUE)\n    stopifnot(is_rotation(\"hello\", \"llohe\") == TRUE)\n    stopifnot(is_rotation(\"abc\", \"def\") == FALSE)\n    stopifnot(is_rotation(\"abc\", \"abcd\") == FALSE)\n    stopifnot(is_rotation(\"\", \"\") == TRUE)\n}\n\ntest_rotation()", "exec_outcome": "PASSED"}
{"code": "# find_max_and_min returns a list with the maximum and minimum values from a given vector of integers.\n# If the vector is empty, it returns a list with NULL for both max and min values.\n#\n# Args:\n#   int_vector: A vector of integers\n#\n# Returns:\n#   A list containing the maximum and minimum values (max_value, min_value)\nfind_max_and_min <- function(int_vector) {\n  if (length(int_vector) == 0) {\n    return(list(max_value = NULL, min_value = NULL))\n  }\n  \n  max_value <- max(int_vector)\n  min_value <- min(int_vector)\n  \n  return(list(max_value = max_value, min_value = min_value))\n}", "test_cases": "", "test_case_results": "Input:  1 2 3 4 \nMax:  4 , Min:  1 \nInput:  -5 0 10 -3 \nMax:  10 , Min:  -5 \nInput:  100 \nMax:  100 , Min:  100 \nInput:   \nMax:  , Min:", "task_id": 7195, "assertions": "test_max_and_min <- function() {\n    # Test case 1: Normal vector\n    result1 <- find_max_and_min(c(1, 2, 3, 4))\n    stopifnot(result1$max_value == 4, result1$min_value == 1)\n    \n    # Test case 2: Vector with negative numbers\n    result2 <- find_max_and_min(c(-5, 0, 10, -3))\n    stopifnot(result2$max_value == 10, result2$min_value == -5)\n    \n    # Test case 3: Single element vector\n    result3 <- find_max_and_min(c(100))\n    stopifnot(result3$max_value == 100, result3$min_value == 100)\n    \n    # Test case 4: Empty vector\n    result4 <- find_max_and_min(integer(0))\n    stopifnot(is.null(result4$max_value), is.null(result4$min_value))\n}\n\ntest_max_and_min()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_and_min <- function() {\n    # Test case 1: Normal vector\n    result1 <- find_max_and_min(c(1, 2, 3, 4))\n    stopifnot(result1$max_value == 4, result1$min_value == 1)\n    \n    # Test case 2: Vector with negative numbers\n    result2 <- find_max_and_min(c(-5, 0, 10, -3))\n    stopifnot(result2$max_value == 10, result2$min_value == -5)\n    \n    # Test case 3: Single element vector\n    result3 <- find_max_and_min(c(100))\n    stopifnot(result3$max_value == 100, result3$min_value == 100)\n    \n    # Test case 4: Empty vector\n    result4 <- find_max_and_min(integer(0))\n    stopifnot(is.null(result4$max_value), is.null(result4$min_value))\n}\n\ntest_max_and_min()", "output": "find_max_and_min"}, "all_code": "# find_max_and_min returns a list with the maximum and minimum values from a given vector of integers.\n# If the vector is empty, it returns a list with NULL for both max and min values.\n#\n# Args:\n#   int_vector: A vector of integers\n#\n# Returns:\n#   A list containing the maximum and minimum values (max_value, min_value)\nfind_max_and_min <- function(int_vector) {\n  if (length(int_vector) == 0) {\n    return(list(max_value = NULL, min_value = NULL))\n  }\n  \n  max_value <- max(int_vector)\n  min_value <- min(int_vector)\n  \n  return(list(max_value = max_value, min_value = min_value))\n}\ntest_max_and_min <- function() {\n    # Test case 1: Normal vector\n    result1 <- find_max_and_min(c(1, 2, 3, 4))\n    stopifnot(result1$max_value == 4, result1$min_value == 1)\n    \n    # Test case 2: Vector with negative numbers\n    result2 <- find_max_and_min(c(-5, 0, 10, -3))\n    stopifnot(result2$max_value == 10, result2$min_value == -5)\n    \n    # Test case 3: Single element vector\n    result3 <- find_max_and_min(c(100))\n    stopifnot(result3$max_value == 100, result3$min_value == 100)\n    \n    # Test case 4: Empty vector\n    result4 <- find_max_and_min(integer(0))\n    stopifnot(is.null(result4$max_value), is.null(result4$min_value))\n}\n\ntest_max_and_min()", "exec_outcome": "PASSED"}
{"code": "# max_profit calculates the maximum profit by buying and selling stock exactly once.\n# It iterates through the list of prices, keeping track of the minimum price seen so far\n# and calculating the potential profit if sold at the current price.\n# If no profit can be made, it returns 0.\nmax_profit <- function(prices) {\n  if (length(prices) == 0) {\n    return(0)\n  }\n\n  min_price <- prices[1]\n  max_profit <- 0\n\n  for (price in prices) {\n    # Calculate the profit if we sold at current price\n    profit <- price - min_price\n    # Update the max profit\n    max_profit <- max(max_profit, profit)\n    # Update the min price to be the lowest price seen so far\n    min_price <- min(min_price, price)\n  }\n\n  return(max_profit)\n}", "test_cases": "", "test_case_results": "Input:  7 1 5 3 6 4 \nMax Profit:  5 \nInput:  7 6 4 3 1 \nMax Profit:  0 \nInput:  1 2 3 4 5 \nMax Profit:  4 \nInput:  3 3 3 3 3 \nMax Profit:  0 \nInput:   \nMax Profit:  0", "task_id": 16863, "assertions": "test_max_profit <- function() {\n    stopifnot(max_profit(c(7, 1, 5, 3, 6, 4)) == 5)\n    stopifnot(max_profit(c(7, 6, 4, 3, 1)) == 0)\n    stopifnot(max_profit(c(1, 2, 3, 4, 5)) == 4)\n    stopifnot(max_profit(c(3, 3, 3, 3, 3)) == 0)\n    stopifnot(max_profit(numeric(0)) == 0)\n}\n\ntest_max_profit()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_max_profit <- function() {\n    stopifnot(max_profit(c(7, 1, 5, 3, 6, 4)) == 5)\n    stopifnot(max_profit(c(7, 6, 4, 3, 1)) == 0)\n    stopifnot(max_profit(c(1, 2, 3, 4, 5)) == 4)\n    stopifnot(max_profit(c(3, 3, 3, 3, 3)) == 0)\n    stopifnot(max_profit(numeric(0)) == 0)\n}\n\ntest_max_profit()", "output": "max_profit"}, "all_code": "# max_profit calculates the maximum profit by buying and selling stock exactly once.\n# It iterates through the list of prices, keeping track of the minimum price seen so far\n# and calculating the potential profit if sold at the current price.\n# If no profit can be made, it returns 0.\nmax_profit <- function(prices) {\n  if (length(prices) == 0) {\n    return(0)\n  }\n\n  min_price <- prices[1]\n  max_profit <- 0\n\n  for (price in prices) {\n    # Calculate the profit if we sold at current price\n    profit <- price - min_price\n    # Update the max profit\n    max_profit <- max(max_profit, profit)\n    # Update the min price to be the lowest price seen so far\n    min_price <- min(min_price, price)\n  }\n\n  return(max_profit)\n}\ntest_max_profit <- function() {\n    stopifnot(max_profit(c(7, 1, 5, 3, 6, 4)) == 5)\n    stopifnot(max_profit(c(7, 6, 4, 3, 1)) == 0)\n    stopifnot(max_profit(c(1, 2, 3, 4, 5)) == 4)\n    stopifnot(max_profit(c(3, 3, 3, 3, 3)) == 0)\n    stopifnot(max_profit(numeric(0)) == 0)\n}\n\ntest_max_profit()", "exec_outcome": "PASSED"}
{"code": "most_frequent_theme <- function(n, m, instructions) {\n  # Initialize the table with no theme (represented by 0)\n  table <- rep(0, n)\n  \n  # Apply each instruction to the table\n  for (instruction in instructions) {\n    a <- instruction[1]\n    b <- instruction[2]\n    t <- instruction[3]\n    table[a:b] <- t\n  }\n  \n  # Count the frequencies of each theme\n  frequencies <- table(table)\n  \n  # Find the most frequent theme, and in case of ties, the smallest ID\n  max_frequency <- max(frequencies)\n  most_frequent_themes <- as.numeric(names(frequencies[frequencies == max_frequency]))\n  most_frequent_theme_id <- min(most_frequent_themes)\n  \n  return(most_frequent_theme_id)\n}", "test_cases": "", "test_case_results": "Input: n = 5 , m = 2 , instructions = (1, 3, 1), (2, 4, 2) \nMost frequent theme ID: 2 \nInput: n = 10 , m = 3 , instructions = (1, 5, 3), (3, 7, 3), (5, 10, 5) \nMost frequent theme ID: 5 \nInput: n = 7 , m = 1 , instructions = (1, 7, 4) \nMost frequent theme ID: 4 \nInput: n = 6 , m = 4 , instructions = (1, 2, 1), (3, 4, 1), (5, 6, 2), (1, 6, 3) \nMost frequent theme ID: 3", "task_id": 20147, "assertions": "test_most_frequent_theme <- function() {\n  # Test case 1\n  stopifnot(most_frequent_theme(5, 2, list(c(1, 3, 1), c(2, 4, 2))) == 2)\n  \n  # Test case 2\n  stopifnot(most_frequent_theme(10, 3, list(c(1, 5, 3), c(3, 7, 3), c(5, 10, 5))) == 5)\n  \n  # Test case 3\n  stopifnot(most_frequent_theme(7, 1, list(c(1, 7, 4))) == 4)\n  \n  # Test case 4\n  stopifnot(most_frequent_theme(6, 4, list(c(1, 2, 1), c(3, 4, 1), c(5, 6, 2), c(1, 6, 3))) == 3)\n}\n\ntest_most_frequent_theme()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_most_frequent_theme <- function() {\n  # Test case 1\n  stopifnot(most_frequent_theme(5, 2, list(c(1, 3, 1), c(2, 4, 2))) == 2)\n  \n  # Test case 2\n  stopifnot(most_frequent_theme(10, 3, list(c(1, 5, 3), c(3, 7, 3), c(5, 10, 5))) == 5)\n  \n  # Test case 3\n  stopifnot(most_frequent_theme(7, 1, list(c(1, 7, 4))) == 4)\n  \n  # Test case 4\n  stopifnot(most_frequent_theme(6, 4, list(c(1, 2, 1), c(3, 4, 1), c(5, 6, 2), c(1, 6, 3))) == 3)\n}\n\ntest_most_frequent_theme()", "output": "most_frequent_theme"}, "all_code": "most_frequent_theme <- function(n, m, instructions) {\n  # Initialize the table with no theme (represented by 0)\n  table <- rep(0, n)\n  \n  # Apply each instruction to the table\n  for (instruction in instructions) {\n    a <- instruction[1]\n    b <- instruction[2]\n    t <- instruction[3]\n    table[a:b] <- t\n  }\n  \n  # Count the frequencies of each theme\n  frequencies <- table(table)\n  \n  # Find the most frequent theme, and in case of ties, the smallest ID\n  max_frequency <- max(frequencies)\n  most_frequent_themes <- as.numeric(names(frequencies[frequencies == max_frequency]))\n  most_frequent_theme_id <- min(most_frequent_themes)\n  \n  return(most_frequent_theme_id)\n}\ntest_most_frequent_theme <- function() {\n  # Test case 1\n  stopifnot(most_frequent_theme(5, 2, list(c(1, 3, 1), c(2, 4, 2))) == 2)\n  \n  # Test case 2\n  stopifnot(most_frequent_theme(10, 3, list(c(1, 5, 3), c(3, 7, 3), c(5, 10, 5))) == 5)\n  \n  # Test case 3\n  stopifnot(most_frequent_theme(7, 1, list(c(1, 7, 4))) == 4)\n  \n  # Test case 4\n  stopifnot(most_frequent_theme(6, 4, list(c(1, 2, 1), c(3, 4, 1), c(5, 6, 2), c(1, 6, 3))) == 3)\n}\n\ntest_most_frequent_theme()", "exec_outcome": "PASSED"}
{"code": "find_number_of_roads_to_cut <- function(n, m, roads) {\n    if (m == 0) {\n        return(0)\n    }\n\n    parent <- 1:(n + 1)  # 1-based indexing for easier handling in R\n    \n    find <- function(x) {\n        if (parent[x] != x) {\n            parent[x] <<- find(parent[x])  # Use <<- for assignment in parent scope\n        }\n        return(parent[x])\n    }\n    \n    union <- function(x, y) {\n        rootX <- find(x)\n        rootY <- find(y)\n        if (rootX != rootY) {\n            parent[rootX] <<- rootY  # Use <<- for assignment in parent scope\n            return(TRUE)\n        }\n        return(FALSE)\n    }\n    \n    redundant_connections <- 0\n\n    for (road in roads) {\n        u <- road[1]\n        v <- road[2]\n        if (!union(u, v)) {\n            redundant_connections <- redundant_connections + 1\n        }\n    }\n    \n    return(redundant_connections)\n}", "test_cases": "", "test_case_results": "Input - Towns (n):  4 , Roads (m):  3 , Roads list: [[1]]\n[1] 1 2\n\n[[2]]\n[1] 2 3\n\n[[3]]\n[1] 3 4\n\nNumber of roads to cut:  0 \n\nInput - Towns (n):  4 , Roads (m):  4 , Roads list: [[1]]\n[1] 1 2\n\n[[2]]\n[1] 2 3\n\n[[3]]\n[1] 3 4\n\n[[4]]\n[1] 1 4\n\nNumber of roads to cut:  1 \n\nInput - Towns (n):  5 , Roads (m):  6 , Roads list: [[1]]\n[1] 1 2\n\n[[2]]\n[1] 2 3\n\n[[3]]\n[1] 3 4\n\n[[4]]\n[1] 4 5\n\n[[5]]\n[1] 1 3\n\n[[6]]\n[1] 2 4\n\nNumber of roads to cut:  2 \n\nInput - Towns (n):  3 , Roads (m):  0 , Roads list: list()\nNumber of roads to cut:  0", "task_id": 1747, "assertions": "test_roads_to_cut <- function() {\n    # Test case 1: No redundant roads\n    stopifnot(find_number_of_roads_to_cut(4, 3, list(c(1, 2), c(2, 3), c(3, 4))) == 0)\n    \n    # Test case 2: 1 redundant road\n    stopifnot(find_number_of_roads_to_cut(4, 4, list(c(1, 2), c(2, 3), c(3, 4), c(1, 4))) == 1)\n    \n    # Test case 3: 2 redundant roads\n    stopifnot(find_number_of_roads_to_cut(5, 6, list(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(1, 3), c(2, 4))) == 2)\n    \n    # Test case 4: No roads\n    stopifnot(find_number_of_roads_to_cut(3, 0, list()) == 0)\n}\n\ntest_roads_to_cut()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\ntest_roads_to_cut <- function() {\n    # Test case 1: No redundant roads\n    stopifnot(find_number_of_roads_to_cut(4, 3, list(c(1, 2), c(2, 3), c(3, 4))) == 0)\n    \n    # Test case 2: 1 redundant road\n    stopifnot(find_number_of_roads_to_cut(4, 4, list(c(1, 2), c(2, 3), c(3, 4), c(1, 4))) == 1)\n    \n    # Test case 3: 2 redundant roads\n    stopifnot(find_number_of_roads_to_cut(5, 6, list(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(1, 3), c(2, 4))) == 2)\n    \n    # Test case 4: No roads\n    stopifnot(find_number_of_roads_to_cut(3, 0, list()) == 0)\n}\n\ntest_roads_to_cut()", "output": "find_number_of_roads_to_cut"}, "all_code": "find_number_of_roads_to_cut <- function(n, m, roads) {\n    if (m == 0) {\n        return(0)\n    }\n\n    parent <- 1:(n + 1)  # 1-based indexing for easier handling in R\n    \n    find <- function(x) {\n        if (parent[x] != x) {\n            parent[x] <<- find(parent[x])  # Use <<- for assignment in parent scope\n        }\n        return(parent[x])\n    }\n    \n    union <- function(x, y) {\n        rootX <- find(x)\n        rootY <- find(y)\n        if (rootX != rootY) {\n            parent[rootX] <<- rootY  # Use <<- for assignment in parent scope\n            return(TRUE)\n        }\n        return(FALSE)\n    }\n    \n    redundant_connections <- 0\n\n    for (road in roads) {\n        u <- road[1]\n        v <- road[2]\n        if (!union(u, v)) {\n            redundant_connections <- redundant_connections + 1\n        }\n    }\n    \n    return(redundant_connections)\n}\ntest_roads_to_cut <- function() {\n    # Test case 1: No redundant roads\n    stopifnot(find_number_of_roads_to_cut(4, 3, list(c(1, 2), c(2, 3), c(3, 4))) == 0)\n    \n    # Test case 2: 1 redundant road\n    stopifnot(find_number_of_roads_to_cut(4, 4, list(c(1, 2), c(2, 3), c(3, 4), c(1, 4))) == 1)\n    \n    # Test case 3: 2 redundant roads\n    stopifnot(find_number_of_roads_to_cut(5, 6, list(c(1, 2), c(2, 3), c(3, 4), c(4, 5), c(1, 3), c(2, 4))) == 2)\n    \n    # Test case 4: No roads\n    stopifnot(find_number_of_roads_to_cut(3, 0, list()) == 0)\n}\n\ntest_roads_to_cut()", "exec_outcome": "PASSED"}
