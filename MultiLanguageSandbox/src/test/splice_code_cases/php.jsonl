{"code": "<?php\n// select_students selects students based on their Math, English, and total scores in stages.\n// The function takes four parameters:\n// - $n: total number of students\n// - $x: number of students to select based on Math scores\n// - $y: number of students to select based on English scores\n// - $z: number of students to select based on total scores\n// - $a: array of Math scores for each student\n// - $b: array of English scores for each student\n// Returns an array of selected student IDs in ascending order.\nfunction select_students($n, $x, $y, $z, $a, $b) {\n    $students = [];\n    for ($i = 0; $i < $n; $i++) {\n        $students[] = [\n            'math' => $a[$i],\n            'eng' => $b[$i],\n            'id' => $i + 1\n        ];\n    }\n    $selected = [];\n\n    // Stage 1: Select based on Math scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        if ($s1['math'] == $s2['math']) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $s2['math'] - $s1['math'];\n    });\n    for ($i = 0; $i < $x && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Stage 2: Select based on English scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        if ($s1['eng'] == $s2['eng']) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $s2['eng'] - $s1['eng'];\n    });\n    for ($i = 0; $i < $y && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Stage 3: Select based on total scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        $total1 = $s1['math'] + $s1['eng'];\n        $total2 = $s2['math'] + $s2['eng'];\n        if ($total1 == $total2) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $total2 - $total1;\n    });\n    for ($i = 0; $i < $z && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Sort the selected IDs in ascending order\n    sort($selected);\n    return $selected;\n}\n?>", "test_cases": "", "test_case_results": "Input:\nn: 6\nx: 1\ny: 1\nz: 1\nMath scores: 80, 60, 80, 60, 70, 70\nEnglish scores: 40, 20, 50, 50, 30, 40\nSelected student IDs: 1, 3, 4\n\nInput:\nn: 5\nx: 2\ny: 1\nz: 1\nMath scores: 100, 100, 80, 60, 60\nEnglish scores: 50, 50, 80, 90, 90\nSelected student IDs: 1, 2, 3, 4", "task_id": 3905, "assertions": "<?php\nfunction testSelectStudents() {\n    // Test case 1\n    $result1 = select_students(6, 1, 1, 1, [80, 60, 80, 60, 70, 70], [40, 20, 50, 50, 30, 40]);\n    assert($result1 == [1, 3, 4], \"Test case 1 failed\");\n    \n    // Test case 2\n    $result2 = select_students(5, 2, 1, 1, [100, 100, 80, 60, 60], [50, 50, 80, 90, 90]);\n    assert($result2 == [1, 2, 3, 4], \"Test case 2 failed\");\n}\n\ntestSelectStudents();\n?>", "all_code": "<?php\n// select_students selects students based on their Math, English, and total scores in stages.\n// The function takes four parameters:\n// - $n: total number of students\n// - $x: number of students to select based on Math scores\n// - $y: number of students to select based on English scores\n// - $z: number of students to select based on total scores\n// - $a: array of Math scores for each student\n// - $b: array of English scores for each student\n// Returns an array of selected student IDs in ascending order.\nfunction select_students($n, $x, $y, $z, $a, $b) {\n    $students = [];\n    for ($i = 0; $i < $n; $i++) {\n        $students[] = [\n            'math' => $a[$i],\n            'eng' => $b[$i],\n            'id' => $i + 1\n        ];\n    }\n    $selected = [];\n\n    // Stage 1: Select based on Math scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        if ($s1['math'] == $s2['math']) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $s2['math'] - $s1['math'];\n    });\n    for ($i = 0; $i < $x && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Stage 2: Select based on English scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        if ($s1['eng'] == $s2['eng']) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $s2['eng'] - $s1['eng'];\n    });\n    for ($i = 0; $i < $y && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Stage 3: Select based on total scores\n    $remaining = array_filter($students, function($stu) use ($selected) {\n        return !in_array($stu['id'], $selected);\n    });\n    usort($remaining, function($s1, $s2) {\n        $total1 = $s1['math'] + $s1['eng'];\n        $total2 = $s2['math'] + $s2['eng'];\n        if ($total1 == $total2) {\n            return $s1['id'] - $s2['id'];\n        }\n        return $total2 - $total1;\n    });\n    for ($i = 0; $i < $z && $i < count($remaining); $i++) {\n        $selected[] = $remaining[$i]['id'];\n    }\n\n    // Sort the selected IDs in ascending order\n    sort($selected);\n    return $selected;\n}\nfunction testSelectStudents() {\n    // Test case 1\n    $result1 = select_students(6, 1, 1, 1, [80, 60, 80, 60, 70, 70], [40, 20, 50, 50, 30, 40]);\n    assert($result1 == [1, 3, 4], \"Test case 1 failed\");\n    \n    // Test case 2\n    $result2 = select_students(5, 2, 1, 1, [100, 100, 80, 60, 60], [50, 50, 80, 90, 90]);\n    assert($result2 == [1, 2, 3, 4], \"Test case 2 failed\");\n}\n\ntestSelectStudents();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_characters counts the number of letters, digits, and other characters in a string until a '?' is encountered.\n// The function returns an associative array with the counts of letters, digits, and others.\nfunction count_characters($s) {\n    $letters = 0;\n    $digits = 0;\n    $others = 0;\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if ($char == '?') {\n            break;\n        }\n        if (ctype_alpha($char)) {\n            $letters++;\n        } elseif (ctype_digit($char)) {\n            $digits++;\n        } else {\n            $others++;\n        }\n    }\n\n    return [\n        'letters' => $letters,\n        'digits' => $digits,\n        'others' => $others\n    ];\n}\n?>", "test_cases": "", "test_case_results": "Input: Hello123!?\nLetters: 5, Digits: 3, Others: 1\nInput: 12345?abc\nLetters: 0, Digits: 5, Others: 0\nInput: ?abc123\nLetters: 0, Digits: 0, Others: 0\nInput: NoQuestionMark123!\nLetters: 14, Digits: 3, Others: 1", "task_id": 25522, "assertions": "<?php\nfunction testCountCharacters() {\n    $result1 = count_characters(\"Hello123!?\");\n    assert($result1['letters'] === 5);\n    assert($result1['digits'] === 3);\n    assert($result1['others'] === 1);\n\n    $result2 = count_characters(\"12345?abc\");\n    assert($result2['letters'] === 0);\n    assert($result2['digits'] === 5);\n    assert($result2['others'] === 0);\n\n    $result3 = count_characters(\"?abc123\");\n    assert($result3['letters'] === 0);\n    assert($result3['digits'] === 0);\n    assert($result3['others'] === 0);\n\n    $result4 = count_characters(\"NoQuestionMark123!\");\n    assert($result4['letters'] === 14);\n    assert($result4['digits'] === 3);\n    assert($result4['others'] === 1);\n}\n\ntestCountCharacters();\n?>", "all_code": "<?php\n// count_characters counts the number of letters, digits, and other characters in a string until a '?' is encountered.\n// The function returns an associative array with the counts of letters, digits, and others.\nfunction count_characters($s) {\n    $letters = 0;\n    $digits = 0;\n    $others = 0;\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if ($char == '?') {\n            break;\n        }\n        if (ctype_alpha($char)) {\n            $letters++;\n        } elseif (ctype_digit($char)) {\n            $digits++;\n        } else {\n            $others++;\n        }\n    }\n\n    return [\n        'letters' => $letters,\n        'digits' => $digits,\n        'others' => $others\n    ];\n}\nfunction testCountCharacters() {\n    $result1 = count_characters(\"Hello123!?\");\n    assert($result1['letters'] === 5);\n    assert($result1['digits'] === 3);\n    assert($result1['others'] === 1);\n\n    $result2 = count_characters(\"12345?abc\");\n    assert($result2['letters'] === 0);\n    assert($result2['digits'] === 5);\n    assert($result2['others'] === 0);\n\n    $result3 = count_characters(\"?abc123\");\n    assert($result3['letters'] === 0);\n    assert($result3['digits'] === 0);\n    assert($result3['others'] === 0);\n\n    $result4 = count_characters(\"NoQuestionMark123!\");\n    assert($result4['letters'] === 14);\n    assert($result4['digits'] === 3);\n    assert($result4['others'] === 1);\n}\n\ntestCountCharacters();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines if there exists a subset of the list `nums` such that the sum of the subset is equal to `m`.\n *\n * @param int $n The number of elements in the list.\n * @param int $m The target sum value.\n * @param array $nums The list of integers.\n * @return string \"YES\" if such a subset exists, \"NO\" otherwise.\n */\nfunction subset_sum_exists($n, $m, $nums) {\n    // Helper function to check subset sum\n    $subset_sum = function ($nums, $target, $index) use (&$subset_sum) {\n        if ($target == 0) {\n            return true;\n        }\n        if ($index >= count($nums) || $target < 0) {\n            return false;\n        }\n        \n        // Include the number at index\n        $include = $subset_sum($nums, $target - $nums[$index], $index + 1);\n        // Exclude the number and move to the next\n        $exclude = $subset_sum($nums, $target, $index + 1);\n        \n        return $include || $exclude;\n    };\n    \n    return $subset_sum($nums, $m, 0) ? \"YES\" : \"NO\";\n}\n\n/**\n * Handles multiple test cases.\n *\n * @param array $tc Each element is an array containing (n, m, nums) representing a test case.\n * @return array List of strings \"YES\" or \"NO\" for each test case.\n */\nfunction handle_multiple_cases($tc) {\n    $results = [];\n    foreach ($tc as $t) {\n        list($n, $m, $nums) = $t;\n        $results[] = subset_sum_exists($n, $m, $nums);\n    }\n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n = 4, m = 5, nums = [1, 2, 3, 4]\nResult: YES\n\nTest Case 2:\nInput: n = 3, m = 10, nums = [1, 2, 3]\nResult: NO\n\nTest Case 3: Multiple Test Cases\nResults:\n  Case 1: YES\n  Case 2: NO\n  Case 3: YES", "task_id": 11659, "assertions": "<?php\n\nfunction testSubsetSumExists() {\n    // Test case 1: Subset sum exists\n    assert(subset_sum_exists(4, 5, [1, 2, 3, 4]) === \"YES\");\n    \n    // Test case 2: Subset sum does not exist\n    assert(subset_sum_exists(3, 10, [1, 2, 3]) === \"NO\");\n    \n    // Test case 3: Multiple test cases\n    $test_cases = [\n        [4, 5, [1, 2, 3, 4]],\n        [3, 10, [1, 2, 3]],\n        [5, 0, [1, 2, 3, 4, 5]]\n    ];\n    $expected_results = [\"YES\", \"NO\", \"YES\"];\n    $results = handle_multiple_cases($test_cases);\n    assert($results === $expected_results);\n}\n\ntestSubsetSumExists();\n?>", "all_code": "<?php\n/**\n * Determines if there exists a subset of the list `nums` such that the sum of the subset is equal to `m`.\n *\n * @param int $n The number of elements in the list.\n * @param int $m The target sum value.\n * @param array $nums The list of integers.\n * @return string \"YES\" if such a subset exists, \"NO\" otherwise.\n */\nfunction subset_sum_exists($n, $m, $nums) {\n    // Helper function to check subset sum\n    $subset_sum = function ($nums, $target, $index) use (&$subset_sum) {\n        if ($target == 0) {\n            return true;\n        }\n        if ($index >= count($nums) || $target < 0) {\n            return false;\n        }\n        \n        // Include the number at index\n        $include = $subset_sum($nums, $target - $nums[$index], $index + 1);\n        // Exclude the number and move to the next\n        $exclude = $subset_sum($nums, $target, $index + 1);\n        \n        return $include || $exclude;\n    };\n    \n    return $subset_sum($nums, $m, 0) ? \"YES\" : \"NO\";\n}\n\n/**\n * Handles multiple test cases.\n *\n * @param array $tc Each element is an array containing (n, m, nums) representing a test case.\n * @return array List of strings \"YES\" or \"NO\" for each test case.\n */\nfunction handle_multiple_cases($tc) {\n    $results = [];\n    foreach ($tc as $t) {\n        list($n, $m, $nums) = $t;\n        $results[] = subset_sum_exists($n, $m, $nums);\n    }\n    return $results;\n}\nfunction testSubsetSumExists() {\n    // Test case 1: Subset sum exists\n    assert(subset_sum_exists(4, 5, [1, 2, 3, 4]) === \"YES\");\n    \n    // Test case 2: Subset sum does not exist\n    assert(subset_sum_exists(3, 10, [1, 2, 3]) === \"NO\");\n    \n    // Test case 3: Multiple test cases\n    $test_cases = [\n        [4, 5, [1, 2, 3, 4]],\n        [3, 10, [1, 2, 3]],\n        [5, 0, [1, 2, 3, 4, 5]]\n    ];\n    $expected_results = [\"YES\", \"NO\", \"YES\"];\n    $results = handle_multiple_cases($test_cases);\n    assert($results === $expected_results);\n}\n\ntestSubsetSumExists();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Solves the 0/1 knapsack problem to find the maximum total value that can be stored in the warehouse.\n *\n * @param int $n Number of items.\n * @param int $W Capacity of the warehouse.\n * @param array $items List of items, where each item is an array containing weight and value.\n * @return int Maximum total value of goods that can be stored in the warehouse.\n */\nfunction knapsack($n, $W, $items) {\n    // Initialize a 2D array dp with dimensions (n+1) x (W+1) filled with zeros\n    $dp = array_fill(0, $n + 1, array_fill(0, $W + 1, 0));\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $weight = $items[$i - 1][0];\n        $value = $items[$i - 1][1];\n        \n        for ($w = 0; $w <= $W; $w++) {\n            if ($weight <= $w) {\n                // If the current item's weight is less than or equal to the current capacity,\n                // choose the maximum between including or excluding the item\n                $dp[$i][$w] = max($dp[$i - 1][$w], $dp[$i - 1][$w - $weight] + $value);\n            } else {\n                // If the current item's weight exceeds the current capacity, exclude the item\n                $dp[$i][$w] = $dp[$i - 1][$w];\n            }\n        }\n    }\n    \n    return $dp[$n][$W];\n}\n?>", "test_cases": "", "test_case_results": "Test Case:\nNumber of items (n): 3\nCapacity (W): 50\nItems (weight, value): (10, 60) (20, 100) (30, 120) \nMaximum total value: 220\n\nTest Case:\nNumber of items (n): 4\nCapacity (W): 8\nItems (weight, value): (2, 3) (3, 4) (4, 5) (5, 6) \nMaximum total value: 10\n\nTest Case:\nNumber of items (n): 5\nCapacity (W): 10\nItems (weight, value): (2, 6) (2, 10) (3, 12) (4, 8) (5, 9) \nMaximum total value: 31", "task_id": 10202, "assertions": "<?php\n\nfunction testKnapsack() {\n    // Test case 1\n    $n1 = 3;\n    $W1 = 50;\n    $items1 = [\n        [10, 60],\n        [20, 100],\n        [30, 120]\n    ];\n    assert(knapsack($n1, $W1, $items1) === 220);\n\n    // Test case 2\n    $n2 = 4;\n    $W2 = 8;\n    $items2 = [\n        [2, 3],\n        [3, 4],\n        [4, 5],\n        [5, 6]\n    ];\n    assert(knapsack($n2, $W2, $items2) === 10);\n\n    // Test case 3\n    $n3 = 5;\n    $W3 = 10;\n    $items3 = [\n        [2, 6],\n        [2, 10],\n        [3, 12],\n        [4, 8],\n        [5, 9]\n    ];\n    assert(knapsack($n3, $W3, $items3) === 31);\n}\n\ntestKnapsack();\n?>", "all_code": "<?php\n/**\n * Solves the 0/1 knapsack problem to find the maximum total value that can be stored in the warehouse.\n *\n * @param int $n Number of items.\n * @param int $W Capacity of the warehouse.\n * @param array $items List of items, where each item is an array containing weight and value.\n * @return int Maximum total value of goods that can be stored in the warehouse.\n */\nfunction knapsack($n, $W, $items) {\n    // Initialize a 2D array dp with dimensions (n+1) x (W+1) filled with zeros\n    $dp = array_fill(0, $n + 1, array_fill(0, $W + 1, 0));\n    \n    for ($i = 1; $i <= $n; $i++) {\n        $weight = $items[$i - 1][0];\n        $value = $items[$i - 1][1];\n        \n        for ($w = 0; $w <= $W; $w++) {\n            if ($weight <= $w) {\n                // If the current item's weight is less than or equal to the current capacity,\n                // choose the maximum between including or excluding the item\n                $dp[$i][$w] = max($dp[$i - 1][$w], $dp[$i - 1][$w - $weight] + $value);\n            } else {\n                // If the current item's weight exceeds the current capacity, exclude the item\n                $dp[$i][$w] = $dp[$i - 1][$w];\n            }\n        }\n    }\n    \n    return $dp[$n][$W];\n}\nfunction testKnapsack() {\n    // Test case 1\n    $n1 = 3;\n    $W1 = 50;\n    $items1 = [\n        [10, 60],\n        [20, 100],\n        [30, 120]\n    ];\n    assert(knapsack($n1, $W1, $items1) === 220);\n\n    // Test case 2\n    $n2 = 4;\n    $W2 = 8;\n    $items2 = [\n        [2, 3],\n        [3, 4],\n        [4, 5],\n        [5, 6]\n    ];\n    assert(knapsack($n2, $W2, $items2) === 10);\n\n    // Test case 3\n    $n3 = 5;\n    $W3 = 10;\n    $items3 = [\n        [2, 6],\n        [2, 10],\n        [3, 12],\n        [4, 8],\n        [5, 9]\n    ];\n    assert(knapsack($n3, $W3, $items3) === 31);\n}\n\ntestKnapsack();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// solve_knapsack calculates the maximum volume that can be filled from given volumes\n// into a target volume using a dynamic programming approach (0/1 knapsack problem).\n// It returns the remaining unused volume after filling as much as possible.\nfunction solve_knapsack($target_volume, $volumes) {\n    // Initialize dynamic programming array with zeros\n    $dp = array_fill(0, $target_volume + 1, 0);\n\n    foreach ($volumes as $vol) {\n        // Iterate from target volume down to current volume\n        for ($j = $target_volume; $j >= $vol; $j--) {\n            // Update dp[j] if using current volume gives better result\n            $dp[$j] = max($dp[$j], $dp[$j - $vol] + $vol);\n        }\n    }\n\n    // Return the remaining unused volume\n    return $target_volume - $dp[$target_volume];\n}\n?>", "test_cases": "", "test_case_results": "Target Volume: 10\nAvailable Volumes: [3, 5, 7]\nRemaining Unused Volume: 0\n\nTarget Volume: 15\nAvailable Volumes: [2, 3, 5, 7]\nRemaining Unused Volume: 0\n\nTarget Volume: 20\nAvailable Volumes: [3, 5, 7, 11]\nRemaining Unused Volume: 1\n\nTarget Volume: 5\nAvailable Volumes: [6, 7, 8]\nRemaining Unused Volume: 5", "task_id": 28322, "assertions": "<?php\n\nfunction testSolveKnapsack() {\n    assert(solve_knapsack(10, [3, 5, 7]) === 0);\n    assert(solve_knapsack(15, [2, 3, 5, 7]) === 0);\n    assert(solve_knapsack(20, [3, 5, 7, 11]) === 1);\n    assert(solve_knapsack(5, [6, 7, 8]) === 5);\n}\n\ntestSolveKnapsack();\n?>", "all_code": "<?php\n// solve_knapsack calculates the maximum volume that can be filled from given volumes\n// into a target volume using a dynamic programming approach (0/1 knapsack problem).\n// It returns the remaining unused volume after filling as much as possible.\nfunction solve_knapsack($target_volume, $volumes) {\n    // Initialize dynamic programming array with zeros\n    $dp = array_fill(0, $target_volume + 1, 0);\n\n    foreach ($volumes as $vol) {\n        // Iterate from target volume down to current volume\n        for ($j = $target_volume; $j >= $vol; $j--) {\n            // Update dp[j] if using current volume gives better result\n            $dp[$j] = max($dp[$j], $dp[$j - $vol] + $vol);\n        }\n    }\n\n    // Return the remaining unused volume\n    return $target_volume - $dp[$target_volume];\n}\nfunction testSolveKnapsack() {\n    assert(solve_knapsack(10, [3, 5, 7]) === 0);\n    assert(solve_knapsack(15, [2, 3, 5, 7]) === 0);\n    assert(solve_knapsack(20, [3, 5, 7, 11]) === 1);\n    assert(solve_knapsack(5, [6, 7, 8]) === 5);\n}\n\ntestSolveKnapsack();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_max_value computes the maximum value of a polynomial expression modulo P.\n// The polynomial is defined as: A*x^3 + B*y^3 + C*x^2*y + D*x*y^2 + E*x*y + F*x + G*y.\n// The function evaluates this polynomial for all integer values of x in [X1, X2] and y in [Y1, Y2],\n// and returns the maximum value obtained modulo P.\nfunction calculate_max_value($A, $B, $C, $D, $E, $F, $G, $P, $X1, $X2, $Y1, $Y2) {\n    $max_val = -1;\n\n    for ($x = $X1; $x <= $X2; $x++) {\n        $x_sq = $x * $x;\n        $x_cu = $x_sq * $x;\n        for ($y = $Y1; $y <= $Y2; $y++) {\n            $y_sq = $y * $y;\n            $y_cu = $y_sq * $y;\n            $t1 = ($A * $x_cu) % $P;\n            $t2 = ($B * $y_cu) % $P;\n            $t3 = ($C * $x_sq * $y) % $P;\n            $t4 = ($D * $x * $y_sq) % $P;\n            $t5 = ($E * $x * $y) % $P;\n            $t6 = ($F * $x) % $P;\n            $t7 = ($G * $y) % $P;\n            $total = ($t1 + $t2 + $t3 + $t4 + $t5 + $t6 + $t7) % $P;\n            if ($total > $max_val) {\n                $max_val = $total;\n            }\n        }\n    }\n\n    return $max_val;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nInput Parameters:\nA: 1, B: 1, C: 1, D: 1\nE: 1, F: 1, G: 1, P: 100\nX Range: [1, 2], Y Range: [1, 2]\nMaximum Value: 40\n\nTest Case 2:\nInput Parameters:\nA: 2, B: 3, C: 4, D: 5\nE: 6, F: 7, G: 8, P: 1000\nX Range: [0, 10], Y Range: [0, 10]\nMaximum Value: 994\n\nTest Case 3:\nInput Parameters:\nA: 0, B: 0, C: 0, D: 0\nE: 0, F: 0, G: 0, P: 10\nX Range: [1, 5], Y Range: [1, 5]\nMaximum Value: 0", "task_id": 17172, "assertions": "<?php\n\nfunction testCalculateMaxValue() {\n    // Test Case 1: Simple case with small ranges\n    assert(calculate_max_value(1, 1, 1, 1, 1, 1, 1, 100, 1, 2, 1, 2) === 40);\n    \n    // Test Case 2: Larger ranges and different coefficients\n    assert(calculate_max_value(2, 3, 4, 5, 6, 7, 8, 1000, 0, 10, 0, 10) === 994);\n    \n    // Test Case 3: Edge case with zero coefficients\n    assert(calculate_max_value(0, 0, 0, 0, 0, 0, 0, 10, 1, 5, 1, 5) === 0);\n}\n\ntestCalculateMaxValue();\n?>", "all_code": "<?php\n// calculate_max_value computes the maximum value of a polynomial expression modulo P.\n// The polynomial is defined as: A*x^3 + B*y^3 + C*x^2*y + D*x*y^2 + E*x*y + F*x + G*y.\n// The function evaluates this polynomial for all integer values of x in [X1, X2] and y in [Y1, Y2],\n// and returns the maximum value obtained modulo P.\nfunction calculate_max_value($A, $B, $C, $D, $E, $F, $G, $P, $X1, $X2, $Y1, $Y2) {\n    $max_val = -1;\n\n    for ($x = $X1; $x <= $X2; $x++) {\n        $x_sq = $x * $x;\n        $x_cu = $x_sq * $x;\n        for ($y = $Y1; $y <= $Y2; $y++) {\n            $y_sq = $y * $y;\n            $y_cu = $y_sq * $y;\n            $t1 = ($A * $x_cu) % $P;\n            $t2 = ($B * $y_cu) % $P;\n            $t3 = ($C * $x_sq * $y) % $P;\n            $t4 = ($D * $x * $y_sq) % $P;\n            $t5 = ($E * $x * $y) % $P;\n            $t6 = ($F * $x) % $P;\n            $t7 = ($G * $y) % $P;\n            $total = ($t1 + $t2 + $t3 + $t4 + $t5 + $t6 + $t7) % $P;\n            if ($total > $max_val) {\n                $max_val = $total;\n            }\n        }\n    }\n\n    return $max_val;\n}\nfunction testCalculateMaxValue() {\n    // Test Case 1: Simple case with small ranges\n    assert(calculate_max_value(1, 1, 1, 1, 1, 1, 1, 100, 1, 2, 1, 2) === 40);\n    \n    // Test Case 2: Larger ranges and different coefficients\n    assert(calculate_max_value(2, 3, 4, 5, 6, 7, 8, 1000, 0, 10, 0, 10) === 994);\n    \n    // Test Case 3: Edge case with zero coefficients\n    assert(calculate_max_value(0, 0, 0, 0, 0, 0, 0, 10, 1, 5, 1, 5) === 0);\n}\n\ntestCalculateMaxValue();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Computes the shortest path from a source node to a target node under a weight constraint.\n *\n * @param array $graph A 2D array representing the adjacency matrix of the graph, where $graph[$i][$j] is the weight of the edge from node $i to node $j.\n * @param int $source The starting node.\n * @param int $target The destination node.\n * @param float $max_weight The maximum allowed weight for the path.\n * @return array A list of nodes representing the vertices in the shortest path from $source to $target, or an empty array if no such path exists.\n */\nfunction constrained_shortest_path($graph, $source, $target, $max_weight) {\n    $num_nodes = count($graph);\n    // Priority queue to store tuples of (current_path_weight, current_path, current_node)\n    $pq = new SplPriorityQueue();\n    // We use a max-heap by default, so we negate the weights to simulate a min-heap\n    $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\n    \n    $pq->insert([0, [$source], $source], -0);\n    \n    // Dictionary to store minimum weight to reach each node\n    $min_weight_to_node = array_fill(0, $num_nodes, INF);\n    $min_weight_to_node[$source] = 0;\n    \n    while (!$pq->isEmpty()) {\n        list($current_weight, $path, $node) = $pq->extract();\n        \n        // If we reached the target node, return the path\n        if ($node == $target) {\n            return $path;\n        }\n        \n        // Explore neighbors\n        for ($neighbor = 0; $neighbor < $num_nodes; $neighbor++) {\n            $edge_weight = $graph[$node][$neighbor];\n            \n            if ($edge_weight == INF) {\n                continue;\n            }\n            \n            $new_weight = $current_weight + $edge_weight;\n            \n            // Check if the new path is within the $max_weight and is an improvement\n            if ($new_weight < $min_weight_to_node[$neighbor] && $new_weight <= $max_weight) {\n                $min_weight_to_node[$neighbor] = $new_weight;\n                $new_path = array_merge($path, [$neighbor]);\n                $pq->insert([$new_weight, $new_path, $neighbor], -$new_weight);\n            }\n        }\n    }\n    \n    // If target node is not reachable within the weight constraint, return an empty array\n    return [];\n}\n\ndefine('INF', INF);\n?>", "test_cases": "", "test_case_results": "Input: source = 0, target = 4, max_weight = 10\nPath: 0 -> 1 -> 4\nInput: source = 1, target = 3, max_weight = 5\nPath: No path found\nInput: source = 2, target = 4, max_weight = 15\nPath: 2 -> 4\nInput: source = 0, target = 2, max_weight = 5\nPath: 0 -> 1 -> 2", "task_id": 25670, "assertions": "<?php\n\nfunction testConstrainedShortestPath() {\n    $test_graph = [\n        [0, 2, INF, 6, INF],\n        [2, 0, 3, 8, 5],\n        [INF, 3, 0, INF, 7],\n        [6, 8, INF, 0, 9],\n        [INF, 5, 7, 9, 0]\n    ];\n\n    assert(constrained_shortest_path($test_graph, 0, 4, 10) === [0, 1, 4]);\n    assert(constrained_shortest_path($test_graph, 1, 3, 5) === []);\n    assert(constrained_shortest_path($test_graph, 2, 4, 15) === [2, 4]);\n    assert(constrained_shortest_path($test_graph, 0, 2, 5) === [0, 1, 2]);\n}\n\ntestConstrainedShortestPath();\n?>", "all_code": "<?php\n/**\n * Computes the shortest path from a source node to a target node under a weight constraint.\n *\n * @param array $graph A 2D array representing the adjacency matrix of the graph, where $graph[$i][$j] is the weight of the edge from node $i to node $j.\n * @param int $source The starting node.\n * @param int $target The destination node.\n * @param float $max_weight The maximum allowed weight for the path.\n * @return array A list of nodes representing the vertices in the shortest path from $source to $target, or an empty array if no such path exists.\n */\nfunction constrained_shortest_path($graph, $source, $target, $max_weight) {\n    $num_nodes = count($graph);\n    // Priority queue to store tuples of (current_path_weight, current_path, current_node)\n    $pq = new SplPriorityQueue();\n    // We use a max-heap by default, so we negate the weights to simulate a min-heap\n    $pq->setExtractFlags(SplPriorityQueue::EXTR_DATA);\n    \n    $pq->insert([0, [$source], $source], -0);\n    \n    // Dictionary to store minimum weight to reach each node\n    $min_weight_to_node = array_fill(0, $num_nodes, INF);\n    $min_weight_to_node[$source] = 0;\n    \n    while (!$pq->isEmpty()) {\n        list($current_weight, $path, $node) = $pq->extract();\n        \n        // If we reached the target node, return the path\n        if ($node == $target) {\n            return $path;\n        }\n        \n        // Explore neighbors\n        for ($neighbor = 0; $neighbor < $num_nodes; $neighbor++) {\n            $edge_weight = $graph[$node][$neighbor];\n            \n            if ($edge_weight == INF) {\n                continue;\n            }\n            \n            $new_weight = $current_weight + $edge_weight;\n            \n            // Check if the new path is within the $max_weight and is an improvement\n            if ($new_weight < $min_weight_to_node[$neighbor] && $new_weight <= $max_weight) {\n                $min_weight_to_node[$neighbor] = $new_weight;\n                $new_path = array_merge($path, [$neighbor]);\n                $pq->insert([$new_weight, $new_path, $neighbor], -$new_weight);\n            }\n        }\n    }\n    \n    // If target node is not reachable within the weight constraint, return an empty array\n    return [];\n}\n\ndefine('INF', INF);\nfunction testConstrainedShortestPath() {\n    $test_graph = [\n        [0, 2, INF, 6, INF],\n        [2, 0, 3, 8, 5],\n        [INF, 3, 0, INF, 7],\n        [6, 8, INF, 0, 9],\n        [INF, 5, 7, 9, 0]\n    ];\n\n    assert(constrained_shortest_path($test_graph, 0, 4, 10) === [0, 1, 4]);\n    assert(constrained_shortest_path($test_graph, 1, 3, 5) === []);\n    assert(constrained_shortest_path($test_graph, 2, 4, 15) === [2, 4]);\n    assert(constrained_shortest_path($test_graph, 0, 2, 5) === [0, 1, 2]);\n}\n\ntestConstrainedShortestPath();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// This function calculates the counts of each total score (T) based on the input parameters K and N.\n// K is the number of (msi, pi) pairs, and N is the upper limit for k.\n// The function returns the maximum count of any total score T.\nfunction calculate_max_count($K, $N, $msi_pi_pairs) {\n    $counts = array();\n\n    foreach ($msi_pi_pairs as $pair) {\n        list($msi, $pi) = $pair;\n        for ($k = 1; $k <= $N; $k++) {\n            $q = intdiv($k - 1, $pi);\n            $r = ($k - 1) % $pi;\n            $S = $q * $pi * ($pi - 1) / 2;\n            $T = $k * $msi + $S + $r;\n            if (!isset($counts[$T])) {\n                $counts[$T] = 0;\n            }\n            $counts[$T]++;\n        }\n    }\n\n    return empty($counts) ? 0 : max($counts);\n}\n?>", "test_cases": "", "test_case_results": "Input: K=2, N=5, msi_pi_pairs=[(3, 2), (4, 3)]\nMax Count: 2\nInput: K=1, N=10, msi_pi_pairs=[(5, 2)]\nMax Count: 1\nInput: K=3, N=4, msi_pi_pairs=[(1, 1), (2, 2), (3, 3)]\nMax Count: 2", "task_id": 15643, "assertions": "<?php\n\nfunction testCalculateMaxCount() {\n    // Test case 1\n    assert(calculate_max_count(2, 5, [[3, 2], [4, 3]]) === 2);\n    \n    // Test case 2\n    assert(calculate_max_count(1, 10, [[5, 2]]) === 1);\n    \n    // Test case 3\n    assert(calculate_max_count(3, 4, [[1, 1], [2, 2], [3, 3]]) === 2);\n}\n\ntestCalculateMaxCount();\n?>", "all_code": "<?php\n// This function calculates the counts of each total score (T) based on the input parameters K and N.\n// K is the number of (msi, pi) pairs, and N is the upper limit for k.\n// The function returns the maximum count of any total score T.\nfunction calculate_max_count($K, $N, $msi_pi_pairs) {\n    $counts = array();\n\n    foreach ($msi_pi_pairs as $pair) {\n        list($msi, $pi) = $pair;\n        for ($k = 1; $k <= $N; $k++) {\n            $q = intdiv($k - 1, $pi);\n            $r = ($k - 1) % $pi;\n            $S = $q * $pi * ($pi - 1) / 2;\n            $T = $k * $msi + $S + $r;\n            if (!isset($counts[$T])) {\n                $counts[$T] = 0;\n            }\n            $counts[$T]++;\n        }\n    }\n\n    return empty($counts) ? 0 : max($counts);\n}\nfunction testCalculateMaxCount() {\n    // Test case 1\n    assert(calculate_max_count(2, 5, [[3, 2], [4, 3]]) === 2);\n    \n    // Test case 2\n    assert(calculate_max_count(1, 10, [[5, 2]]) === 1);\n    \n    // Test case 3\n    assert(calculate_max_count(3, 4, [[1, 1], [2, 2], [3, 3]]) === 2);\n}\n\ntestCalculateMaxCount();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Reverses the keys and values in an associative array (dictionary). \n * If the value is not scalar (i.e., not a simple type like int, float, string, or bool),\n * it converts the value to a string before reversing.\n *\n * @param array $input_dict The associative array to be reversed\n * @return array The reversed associative array\n */\nfunction reverse_dictionary($input_dict) {\n    $reversed_dict = array();\n    \n    foreach ($input_dict as $key => $value) {\n        // Check if the value is scalar (int, float, string, bool)\n        if (!is_scalar($value) && !is_null($value)) {\n            $value = strval($value);\n        }\n        \n        $reversed_dict[$value] = $key;\n    }\n    \n    return $reversed_dict;\n}\n?>", "test_cases": "", "test_case_results": "Input: Array\n(\n    [a] => 1\n    [b] => 2\n    [c] => 3\n)\nReversed: Array\n(\n    [1] => a\n    [2] => b\n    [3] => c\n)\n\nInput: Array\n(\n    [x] => hello\n    [y] => world\n    [z] => php\n)\nReversed: Array\n(\n    [hello] => x\n    [world] => y\n    [php] => z\n)\n\nInput: Array\n(\n    [key1] => Array\n        (\n            [0] => 1\n            [1] => 2\n            [2] => 3\n        )\n\n    [key2] => Array\n        (\n            [0] => a\n            [1] => b\n            [2] => c\n        )\n\n)\nReversed: Array\n(\n    [Array] => key2\n)\n\nInput: Array\n(\n    [one] => 1\n    [two] => \n    [three] => \n)\nReversed: Array\n(\n    [1] => one\n    [0] => two\n    [] => three\n)", "task_id": 22550, "assertions": "<?php\n\nfunction testReverseDictionary() {\n    // Test case 1: Numeric values\n    assert(reverse_dictionary([\"a\" => 1, \"b\" => 2, \"c\" => 3]) === [1 => \"a\", 2 => \"b\", 3 => \"c\"]);\n    \n    // Test case 2: String values\n    assert(reverse_dictionary([\"x\" => \"hello\", \"y\" => \"world\", \"z\" => \"php\"]) === [\"hello\" => \"x\", \"world\" => \"y\", \"php\" => \"z\"]);\n    \n    // Test case 3: Array values (should be converted to string \"Array\")\n    $result = reverse_dictionary([\"key1\" => [1, 2, 3], \"key2\" => [\"a\", \"b\", \"c\"]]);\n    assert(array_key_exists(\"Array\", $result) && ($result[\"Array\"] === \"key2\"));\n    \n    // Test case 4: Boolean and null values\n    assert(reverse_dictionary([\"one\" => true, \"two\" => false, \"three\" => null]) === [1 => \"one\", 0 => \"two\", \"\" => \"three\"]);\n}\n\ntestReverseDictionary();\n?>", "all_code": "<?php\n/**\n * Reverses the keys and values in an associative array (dictionary). \n * If the value is not scalar (i.e., not a simple type like int, float, string, or bool),\n * it converts the value to a string before reversing.\n *\n * @param array $input_dict The associative array to be reversed\n * @return array The reversed associative array\n */\nfunction reverse_dictionary($input_dict) {\n    $reversed_dict = array();\n    \n    foreach ($input_dict as $key => $value) {\n        // Check if the value is scalar (int, float, string, bool)\n        if (!is_scalar($value) && !is_null($value)) {\n            $value = strval($value);\n        }\n        \n        $reversed_dict[$value] = $key;\n    }\n    \n    return $reversed_dict;\n}\nfunction testReverseDictionary() {\n    // Test case 1: Numeric values\n    assert(reverse_dictionary([\"a\" => 1, \"b\" => 2, \"c\" => 3]) === [1 => \"a\", 2 => \"b\", 3 => \"c\"]);\n    \n    // Test case 2: String values\n    assert(reverse_dictionary([\"x\" => \"hello\", \"y\" => \"world\", \"z\" => \"php\"]) === [\"hello\" => \"x\", \"world\" => \"y\", \"php\" => \"z\"]);\n    \n    // Test case 3: Array values (should be converted to string \"Array\")\n    $result = reverse_dictionary([\"key1\" => [1, 2, 3], \"key2\" => [\"a\", \"b\", \"c\"]]);\n    assert(array_key_exists(\"Array\", $result) && ($result[\"Array\"] === \"key2\"));\n    \n    // Test case 4: Boolean and null values\n    assert(reverse_dictionary([\"one\" => true, \"two\" => false, \"three\" => null]) === [1 => \"one\", 0 => \"two\", \"\" => \"three\"]);\n}\n\ntestReverseDictionary();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_min_cost calculates the minimum cost to purchase 'N' items considering bulk purchase options.\n// The cost is calculated based on two options:\n// 1. Buying in sets of 10 items for 100 units each.\n// 2. Buying individual items for 15 units each.\n// The function iterates through all possible combinations of sets and individual items to find the minimum cost.\nfunction calculate_min_cost($N) {\n    $min_cost = PHP_INT_MAX; // Initialize with the maximum possible integer value\n    $max_sets = (int)ceil($N / 10); // Calculate the maximum number of sets needed\n\n    for ($k = 0; $k <= $max_sets; $k++) {\n        $sets = $k;\n        $remaining = max(0, $N - 10 * $k);\n        $cost = 100 * $sets + 15 * $remaining;\n        if ($cost < $min_cost) {\n            $min_cost = $cost;\n        }\n    }\n\n    return $min_cost;\n}\n?>", "test_cases": "", "test_case_results": "Input N: 5\nMinimum Cost: 75\nInput N: 10\nMinimum Cost: 100\nInput N: 15\nMinimum Cost: 175\nInput N: 23\nMinimum Cost: 245\nInput N: 0\nMinimum Cost: 0", "task_id": 17200, "assertions": "<?php\n\nfunction testCalculateMinCost() {\n    assert(calculate_min_cost(5) === 75);\n    assert(calculate_min_cost(10) === 100);\n    assert(calculate_min_cost(15) === 175);\n    assert(calculate_min_cost(23) === 245);\n    assert(calculate_min_cost(0) === 0);\n    echo \"All tests passed successfully!\";\n}\n\ntestCalculateMinCost();\n?>", "all_code": "<?php\n// calculate_min_cost calculates the minimum cost to purchase 'N' items considering bulk purchase options.\n// The cost is calculated based on two options:\n// 1. Buying in sets of 10 items for 100 units each.\n// 2. Buying individual items for 15 units each.\n// The function iterates through all possible combinations of sets and individual items to find the minimum cost.\nfunction calculate_min_cost($N) {\n    $min_cost = PHP_INT_MAX; // Initialize with the maximum possible integer value\n    $max_sets = (int)ceil($N / 10); // Calculate the maximum number of sets needed\n\n    for ($k = 0; $k <= $max_sets; $k++) {\n        $sets = $k;\n        $remaining = max(0, $N - 10 * $k);\n        $cost = 100 * $sets + 15 * $remaining;\n        if ($cost < $min_cost) {\n            $min_cost = $cost;\n        }\n    }\n\n    return $min_cost;\n}\nfunction testCalculateMinCost() {\n    assert(calculate_min_cost(5) === 75);\n    assert(calculate_min_cost(10) === 100);\n    assert(calculate_min_cost(15) === 175);\n    assert(calculate_min_cost(23) === 245);\n    assert(calculate_min_cost(0) === 0);\n    echo \"All tests passed successfully!\";\n}\n\ntestCalculateMinCost();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// lexicographically_smallest_sequence returns the lexicographically smallest sequence achievable by at most one swap.\n// If the sequence is already the smallest, it returns the sequence as-is.\nfunction lexicographically_smallest_sequence($N, $sequence) {\n    // Create a sorted version of the sequence\n    $sorted_sequence = $sequence;\n    sort($sorted_sequence);\n    \n    // If the sequence is already the smallest, return it\n    if ($sequence === $sorted_sequence) {\n        return $sequence;\n    }\n\n    // Identify the first element that differs from the sorted sequence\n    $i = 0;\n    for (; $i < $N; $i++) {\n        if ($sequence[$i] != $sorted_sequence[$i]) {\n            break;\n        }\n    }\n\n    // Find the correct position of this element in the unsorted sequence\n    $j = $N - 1;\n    for (; $j >= 0; $j--) {\n        if ($sequence[$j] == $sorted_sequence[$i]) {\n            break;\n        }\n    }\n\n    // Swap the elements\n    $temp = $sequence[$i];\n    $sequence[$i] = $sequence[$j];\n    $sequence[$j] = $temp;\n\n    return $sequence;\n}\n?>", "test_cases": "", "test_case_results": "Input N: 4, Sequence: [3, 2, 1, 4]\nResult: [1, 2, 3, 4]\nInput N: 5, Sequence: [5, 3, 4, 2, 1]\nResult: [1, 3, 4, 2, 5]\nInput N: 3, Sequence: [1, 2, 3]\nResult: [1, 2, 3]\nInput N: 4, Sequence: [1, 3, 2, 4]\nResult: [1, 2, 3, 4]", "task_id": 13765, "assertions": "<?php\n\nfunction testLexicographicallySmallestSequence() {\n    assert(lexicographically_smallest_sequence(4, [3, 2, 1, 4]) === [1, 2, 3, 4]);\n    assert(lexicographically_smallest_sequence(5, [5, 3, 4, 2, 1]) === [1, 3, 4, 2, 5]);\n    assert(lexicographically_smallest_sequence(3, [1, 2, 3]) === [1, 2, 3]);\n    assert(lexicographically_smallest_sequence(4, [1, 3, 2, 4]) === [1, 2, 3, 4]);\n}\n\ntestLexicographicallySmallestSequence();\n?>", "all_code": "<?php\n// lexicographically_smallest_sequence returns the lexicographically smallest sequence achievable by at most one swap.\n// If the sequence is already the smallest, it returns the sequence as-is.\nfunction lexicographically_smallest_sequence($N, $sequence) {\n    // Create a sorted version of the sequence\n    $sorted_sequence = $sequence;\n    sort($sorted_sequence);\n    \n    // If the sequence is already the smallest, return it\n    if ($sequence === $sorted_sequence) {\n        return $sequence;\n    }\n\n    // Identify the first element that differs from the sorted sequence\n    $i = 0;\n    for (; $i < $N; $i++) {\n        if ($sequence[$i] != $sorted_sequence[$i]) {\n            break;\n        }\n    }\n\n    // Find the correct position of this element in the unsorted sequence\n    $j = $N - 1;\n    for (; $j >= 0; $j--) {\n        if ($sequence[$j] == $sorted_sequence[$i]) {\n            break;\n        }\n    }\n\n    // Swap the elements\n    $temp = $sequence[$i];\n    $sequence[$i] = $sequence[$j];\n    $sequence[$j] = $temp;\n\n    return $sequence;\n}\nfunction testLexicographicallySmallestSequence() {\n    assert(lexicographically_smallest_sequence(4, [3, 2, 1, 4]) === [1, 2, 3, 4]);\n    assert(lexicographically_smallest_sequence(5, [5, 3, 4, 2, 1]) === [1, 3, 4, 2, 5]);\n    assert(lexicographically_smallest_sequence(3, [1, 2, 3]) === [1, 2, 3]);\n    assert(lexicographically_smallest_sequence(4, [1, 3, 2, 4]) === [1, 2, 3, 4]);\n}\n\ntestLexicographicallySmallestSequence();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Calculates the minimum number of distinct characters required to form a palindrome from the given string.\n * \n * The function determines that the minimal number of distinct characters needed is 1, as all characters \n * can be converted to a single character to form a palindrome.\n * \n * @param string $s The input string to be checked.\n * @return int The minimum number of distinct characters required, which is always 1.\n */\nfunction min_distinct_chars_to_palindrome($s) {\n    // For any string, the minimal distinct characters required to form a palindrome is 1.\n    // This is because we can change all characters to a single character, which will trivially form a palindrome.\n    return 1;\n}\n?>", "test_cases": "", "test_case_results": "Input: a\nMinimum distinct characters required: 1\nInput: ab\nMinimum distinct characters required: 1\nInput: abc\nMinimum distinct characters required: 1\nInput: aab\nMinimum distinct characters required: 1\nInput: aaabbb\nMinimum distinct characters required: 1\nInput: racecar\nMinimum distinct characters required: 1", "task_id": 10185, "assertions": "<?php\n\nfunction testMinDistinctCharsToPalindrome() {\n    assert(min_distinct_chars_to_palindrome(\"a\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"ab\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"abc\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"aab\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"aaabbb\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"racecar\") === 1);\n}\n\ntestMinDistinctCharsToPalindrome();\n?>", "all_code": "<?php\n/**\n * Calculates the minimum number of distinct characters required to form a palindrome from the given string.\n * \n * The function determines that the minimal number of distinct characters needed is 1, as all characters \n * can be converted to a single character to form a palindrome.\n * \n * @param string $s The input string to be checked.\n * @return int The minimum number of distinct characters required, which is always 1.\n */\nfunction min_distinct_chars_to_palindrome($s) {\n    // For any string, the minimal distinct characters required to form a palindrome is 1.\n    // This is because we can change all characters to a single character, which will trivially form a palindrome.\n    return 1;\n}\nfunction testMinDistinctCharsToPalindrome() {\n    assert(min_distinct_chars_to_palindrome(\"a\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"ab\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"abc\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"aab\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"aaabbb\") === 1);\n    assert(min_distinct_chars_to_palindrome(\"racecar\") === 1);\n}\n\ntestMinDistinctCharsToPalindrome();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// process_deque_operations processes a series of deque operations and outputs the results.\n// The function handles pushLeft, pushRight, popLeft, and popRight operations.\n// It checks for queue full and empty conditions before performing operations.\nfunction process_deque_operations($n, $m, $operations) {\n    $deque = [];\n    $output = [];\n    foreach ($operations as $operation) {\n        $parts = explode(' ', $operation);\n        $cmd = $parts[0];\n        if ($cmd === 'pushLeft' || $cmd === 'pushRight') {\n            $x = (int)$parts[1];\n            if (count($deque) >= $n) {\n                $output[] = \"The queue is full\";\n            } else {\n                if ($cmd === 'pushLeft') {\n                    array_unshift($deque, $x);\n                    $output[] = \"Pushed in left: $x\";\n                } else {\n                    array_push($deque, $x);\n                    $output[] = \"Pushed in right: $x\";\n                }\n            }\n        } else { // popLeft or popRight\n            if (empty($deque)) {\n                $output[] = \"The queue is empty\";\n            } else {\n                if ($cmd === 'popLeft') {\n                    $val = array_shift($deque);\n                    $output[] = \"Popped from left: $val\";\n                } else {\n                    $val = array_pop($deque);\n                    $output[] = \"Popped from right: $val\";\n                }\n            }\n        }\n    }\n    return $output;\n}\n?>", "test_cases": "", "test_case_results": "Case 1:\nPushed in left: 1\nPushed in right: 2\nPushed in left: 3\nThe queue is full\nPopped from left: 3\nPopped from right: 2\nPopped from left: 1\nThe queue is empty\n\nCase 2:\nPushed in left: 1\nPushed in right: 2\nThe queue is full\nPopped from right: 2\nPopped from left: 1\n\nCase 3:\nPushed in left: 1\nThe queue is full\nPopped from left: 1", "task_id": 24667, "assertions": "<?php\n\nfunction testProcessDequeOperations() {\n    $testCases = [\n        [\n            'n' => 3,\n            'm' => 8,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'pushLeft 3',\n                'pushRight 4',\n                'popLeft',\n                'popRight',\n                'popLeft',\n                'popRight'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'Pushed in right: 2',\n                'Pushed in left: 3',\n                'The queue is full',\n                'Popped from left: 3',\n                'Popped from right: 2',\n                'Popped from left: 1',\n                'The queue is empty'\n            ]\n        ],\n        [\n            'n' => 2,\n            'm' => 5,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'pushLeft 3',\n                'popRight',\n                'popLeft'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'Pushed in right: 2',\n                'The queue is full',\n                'Popped from right: 2',\n                'Popped from left: 1'\n            ]\n        ],\n        [\n            'n' => 1,\n            'm' => 3,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'popLeft'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'The queue is full',\n                'Popped from left: 1'\n            ]\n        ]\n    ];\n\n    foreach ($testCases as $testCase) {\n        $result = process_deque_operations($testCase['n'], $testCase['m'], $testCase['operations']);\n        assert($result === $testCase['expected']);\n    }\n}\n\ntestProcessDequeOperations();\n?>", "all_code": "<?php\n// process_deque_operations processes a series of deque operations and outputs the results.\n// The function handles pushLeft, pushRight, popLeft, and popRight operations.\n// It checks for queue full and empty conditions before performing operations.\nfunction process_deque_operations($n, $m, $operations) {\n    $deque = [];\n    $output = [];\n    foreach ($operations as $operation) {\n        $parts = explode(' ', $operation);\n        $cmd = $parts[0];\n        if ($cmd === 'pushLeft' || $cmd === 'pushRight') {\n            $x = (int)$parts[1];\n            if (count($deque) >= $n) {\n                $output[] = \"The queue is full\";\n            } else {\n                if ($cmd === 'pushLeft') {\n                    array_unshift($deque, $x);\n                    $output[] = \"Pushed in left: $x\";\n                } else {\n                    array_push($deque, $x);\n                    $output[] = \"Pushed in right: $x\";\n                }\n            }\n        } else { // popLeft or popRight\n            if (empty($deque)) {\n                $output[] = \"The queue is empty\";\n            } else {\n                if ($cmd === 'popLeft') {\n                    $val = array_shift($deque);\n                    $output[] = \"Popped from left: $val\";\n                } else {\n                    $val = array_pop($deque);\n                    $output[] = \"Popped from right: $val\";\n                }\n            }\n        }\n    }\n    return $output;\n}\nfunction testProcessDequeOperations() {\n    $testCases = [\n        [\n            'n' => 3,\n            'm' => 8,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'pushLeft 3',\n                'pushRight 4',\n                'popLeft',\n                'popRight',\n                'popLeft',\n                'popRight'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'Pushed in right: 2',\n                'Pushed in left: 3',\n                'The queue is full',\n                'Popped from left: 3',\n                'Popped from right: 2',\n                'Popped from left: 1',\n                'The queue is empty'\n            ]\n        ],\n        [\n            'n' => 2,\n            'm' => 5,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'pushLeft 3',\n                'popRight',\n                'popLeft'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'Pushed in right: 2',\n                'The queue is full',\n                'Popped from right: 2',\n                'Popped from left: 1'\n            ]\n        ],\n        [\n            'n' => 1,\n            'm' => 3,\n            'operations' => [\n                'pushLeft 1',\n                'pushRight 2',\n                'popLeft'\n            ],\n            'expected' => [\n                'Pushed in left: 1',\n                'The queue is full',\n                'Popped from left: 1'\n            ]\n        ]\n    ];\n\n    foreach ($testCases as $testCase) {\n        $result = process_deque_operations($testCase['n'], $testCase['m'], $testCase['operations']);\n        assert($result === $testCase['expected']);\n    }\n}\n\ntestProcessDequeOperations();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// min_insertions_to_good_string calculates the minimum number of insertions required\n// to convert the given string into a \"good\" string. A \"good\" string is defined as one\n// where no two adjacent characters are the same.\nfunction min_insertions_to_good_string($s) {\n    $insertions = 0;\n    $length = strlen($s);\n    \n    for ($i = 1; $i < $length; $i++) {\n        if ($s[$i] == $s[$i - 1]) {\n            $insertions++;\n        }\n    }\n    \n    return $insertions;\n}\n?>", "test_cases": "", "test_case_results": "Input: aab\nInsertions required: 1\nInput: aaab\nInsertions required: 2\nInput: aaa\nInsertions required: 2\nInput: abc\nInsertions required: 0\nInput: a\nInsertions required: 0", "task_id": 26251, "assertions": "<?php\nfunction testMinInsertionsToGoodString() {\n    assert(min_insertions_to_good_string(\"aab\") === 1);\n    assert(min_insertions_to_good_string(\"aaab\") === 2);\n    assert(min_insertions_to_good_string(\"aaa\") === 2);\n    assert(min_insertions_to_good_string(\"abc\") === 0);\n    assert(min_insertions_to_good_string(\"a\") === 0);\n    echo \"All tests passed successfully!\";\n}\n\ntestMinInsertionsToGoodString();\n?>", "all_code": "<?php\n// min_insertions_to_good_string calculates the minimum number of insertions required\n// to convert the given string into a \"good\" string. A \"good\" string is defined as one\n// where no two adjacent characters are the same.\nfunction min_insertions_to_good_string($s) {\n    $insertions = 0;\n    $length = strlen($s);\n    \n    for ($i = 1; $i < $length; $i++) {\n        if ($s[$i] == $s[$i - 1]) {\n            $insertions++;\n        }\n    }\n    \n    return $insertions;\n}\nfunction testMinInsertionsToGoodString() {\n    assert(min_insertions_to_good_string(\"aab\") === 1);\n    assert(min_insertions_to_good_string(\"aaab\") === 2);\n    assert(min_insertions_to_good_string(\"aaa\") === 2);\n    assert(min_insertions_to_good_string(\"abc\") === 0);\n    assert(min_insertions_to_good_string(\"a\") === 0);\n    echo \"All tests passed successfully!\";\n}\n\ntestMinInsertionsToGoodString();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * reverse_vowels_consonants_preserved reverses the vowels in a string while keeping consonants in their original positions.\n *\n * @param string $s The input string to process.\n * @return string The string with vowels reversed and consonants preserved.\n */\nfunction reverse_vowels_consonants_preserved($s) {\n    $vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    $vowel_positions = [];\n    $vowel_chars = [];\n\n    // Collect positions and characters of vowels in the string\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (in_array($s[$i], $vowels)) {\n            array_push($vowel_positions, $i);\n            array_push($vowel_chars, $s[$i]);\n        }\n    }\n\n    // Reverse the vowel characters\n    $reversed_vowel_chars = array_reverse($vowel_chars);\n\n    // Build the result string with vowels reversed\n    $result = $s;\n    for ($i = 0; $i < count($vowel_positions); $i++) {\n        $result[$vowel_positions[$i]] = $reversed_vowel_chars[$i];\n    }\n\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input: hello\nResult: holle\nInput: leetcode\nResult: leotcede\nInput: aA\nResult: Aa\nInput: xyz\nResult: xyz\nInput: aeiou\nResult: uoiea", "task_id": 13596, "assertions": "<?php\n\nfunction testReverseVowelsConsonantsPreserved() {\n    assert(reverse_vowels_consonants_preserved(\"hello\") === \"holle\");\n    assert(reverse_vowels_consonants_preserved(\"leetcode\") === \"leotcede\");\n    assert(reverse_vowels_consonants_preserved(\"aA\") === \"Aa\");\n    assert(reverse_vowels_consonants_preserved(\"xyz\") === \"xyz\");\n    assert(reverse_vowels_consonants_preserved(\"aeiou\") === \"uoiea\");\n}\n\ntestReverseVowelsConsonantsPreserved();\n?>", "all_code": "<?php\n/**\n * reverse_vowels_consonants_preserved reverses the vowels in a string while keeping consonants in their original positions.\n *\n * @param string $s The input string to process.\n * @return string The string with vowels reversed and consonants preserved.\n */\nfunction reverse_vowels_consonants_preserved($s) {\n    $vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];\n    $vowel_positions = [];\n    $vowel_chars = [];\n\n    // Collect positions and characters of vowels in the string\n    for ($i = 0; $i < strlen($s); $i++) {\n        if (in_array($s[$i], $vowels)) {\n            array_push($vowel_positions, $i);\n            array_push($vowel_chars, $s[$i]);\n        }\n    }\n\n    // Reverse the vowel characters\n    $reversed_vowel_chars = array_reverse($vowel_chars);\n\n    // Build the result string with vowels reversed\n    $result = $s;\n    for ($i = 0; $i < count($vowel_positions); $i++) {\n        $result[$vowel_positions[$i]] = $reversed_vowel_chars[$i];\n    }\n\n    return $result;\n}\nfunction testReverseVowelsConsonantsPreserved() {\n    assert(reverse_vowels_consonants_preserved(\"hello\") === \"holle\");\n    assert(reverse_vowels_consonants_preserved(\"leetcode\") === \"leotcede\");\n    assert(reverse_vowels_consonants_preserved(\"aA\") === \"Aa\");\n    assert(reverse_vowels_consonants_preserved(\"xyz\") === \"xyz\");\n    assert(reverse_vowels_consonants_preserved(\"aeiou\") === \"uoiea\");\n}\n\ntestReverseVowelsConsonantsPreserved();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Finds the minimal sum of all road lengths forming a fully connected network.\n * \n * @param int $N Number of intersections.\n * @param array $roads List of roads where each element is an array [u, v, L].\n * \n * @return int Minimal sum of road lengths in the spanning tree.\n */\nfunction minimal_spanning_tree($N, $roads) {\n    // Sort the roads by weight (length)\n    usort($roads, function($a, $b) {\n        return $a[2] - $b[2];\n    });\n    \n    // Initialize parent and rank arrays for Union-Find/Disjoint Set Union (DSU)\n    $parent = range(0, $N - 1);\n    $rank = array_fill(0, $N, 0);\n    \n    /**\n     * Finds the root of the set that element $u belongs to.\n     * \n     * @param int $u The element to find.\n     * @return int The root of the set.\n     */\n    $find = function($u) use (&$parent, &$find) {\n        if ($parent[$u] != $u) {\n            $parent[$u] = $find($parent[$u]);\n        }\n        return $parent[$u];\n    };\n    \n    /**\n     * Unions the sets containing elements $u and $v.\n     * \n     * @param int $u First element.\n     * @param int $v Second element.\n     */\n    $union = function($u, $v) use (&$find, &$parent, &$rank) {\n        $root_u = $find($u);\n        $root_v = $find($v);\n        \n        if ($root_u != $root_v) {\n            if ($rank[$root_u] > $rank[$root_v]) {\n                $parent[$root_v] = $root_u;\n            } elseif ($rank[$root_u] < $rank[$root_v]) {\n                $parent[$root_u] = $root_v;\n            } else {\n                $parent[$root_v] = $root_u;\n                $rank[$root_u]++;\n            }\n        }\n    };\n    \n    $mst_length = 0;\n    foreach ($roads as $road) {\n        $u = $road[0] - 1;  // Convert to zero-indexed\n        $v = $road[1] - 1;  // Convert to zero-indexed\n        $length = $road[2];\n        \n        if ($find($u) != $find($v)) {\n            $union($u, $v);\n            $mst_length += $length;\n        }\n    }\n    \n    return $mst_length;\n}\n?>", "test_cases": "", "test_case_results": "Test Case: Simple linear connection\nNumber of intersections (N): 4\nRoads: \n  1 - 2 : 1\n  2 - 3 : 2\n  3 - 4 : 3\n  1 - 4 : 4\nMinimal Spanning Tree Length: 6\n\nTest Case: Triangle with one short edge\nNumber of intersections (N): 3\nRoads: \n  1 - 2 : 5\n  2 - 3 : 5\n  1 - 3 : 1\nMinimal Spanning Tree Length: 6\n\nTest Case: More complex network\nNumber of intersections (N): 5\nRoads: \n  1 - 2 : 10\n  2 - 3 : 20\n  3 - 4 : 30\n  4 - 5 : 40\n  1 - 5 : 50\n  2 - 5 : 60\nMinimal Spanning Tree Length: 100", "task_id": 28947, "assertions": "<?php\n\nfunction testMinimalSpanningTree() {\n    // Test Case 1: Simple linear connection\n    $result1 = minimal_spanning_tree(4, [\n        [1, 2, 1],\n        [2, 3, 2],\n        [3, 4, 3],\n        [1, 4, 4]\n    ]);\n    assert($result1 === 6, \"Test Case 1 Failed\");\n\n    // Test Case 2: Triangle with one short edge\n    $result2 = minimal_spanning_tree(3, [\n        [1, 2, 5],\n        [2, 3, 5],\n        [1, 3, 1]\n    ]);\n    assert($result2 === 6, \"Test Case 2 Failed\");\n\n    // Test Case 3: More complex network\n    $result3 = minimal_spanning_tree(5, [\n        [1, 2, 10],\n        [2, 3, 20],\n        [3, 4, 30],\n        [4, 5, 40],\n        [1, 5, 50],\n        [2, 5, 60]\n    ]);\n    assert($result3 === 100, \"Test Case 3 Failed\");\n\n    echo \"All test cases passed!\\n\";\n}\n\ntestMinimalSpanningTree();\n?>", "all_code": "<?php\n/**\n * Finds the minimal sum of all road lengths forming a fully connected network.\n * \n * @param int $N Number of intersections.\n * @param array $roads List of roads where each element is an array [u, v, L].\n * \n * @return int Minimal sum of road lengths in the spanning tree.\n */\nfunction minimal_spanning_tree($N, $roads) {\n    // Sort the roads by weight (length)\n    usort($roads, function($a, $b) {\n        return $a[2] - $b[2];\n    });\n    \n    // Initialize parent and rank arrays for Union-Find/Disjoint Set Union (DSU)\n    $parent = range(0, $N - 1);\n    $rank = array_fill(0, $N, 0);\n    \n    /**\n     * Finds the root of the set that element $u belongs to.\n     * \n     * @param int $u The element to find.\n     * @return int The root of the set.\n     */\n    $find = function($u) use (&$parent, &$find) {\n        if ($parent[$u] != $u) {\n            $parent[$u] = $find($parent[$u]);\n        }\n        return $parent[$u];\n    };\n    \n    /**\n     * Unions the sets containing elements $u and $v.\n     * \n     * @param int $u First element.\n     * @param int $v Second element.\n     */\n    $union = function($u, $v) use (&$find, &$parent, &$rank) {\n        $root_u = $find($u);\n        $root_v = $find($v);\n        \n        if ($root_u != $root_v) {\n            if ($rank[$root_u] > $rank[$root_v]) {\n                $parent[$root_v] = $root_u;\n            } elseif ($rank[$root_u] < $rank[$root_v]) {\n                $parent[$root_u] = $root_v;\n            } else {\n                $parent[$root_v] = $root_u;\n                $rank[$root_u]++;\n            }\n        }\n    };\n    \n    $mst_length = 0;\n    foreach ($roads as $road) {\n        $u = $road[0] - 1;  // Convert to zero-indexed\n        $v = $road[1] - 1;  // Convert to zero-indexed\n        $length = $road[2];\n        \n        if ($find($u) != $find($v)) {\n            $union($u, $v);\n            $mst_length += $length;\n        }\n    }\n    \n    return $mst_length;\n}\nfunction testMinimalSpanningTree() {\n    // Test Case 1: Simple linear connection\n    $result1 = minimal_spanning_tree(4, [\n        [1, 2, 1],\n        [2, 3, 2],\n        [3, 4, 3],\n        [1, 4, 4]\n    ]);\n    assert($result1 === 6, \"Test Case 1 Failed\");\n\n    // Test Case 2: Triangle with one short edge\n    $result2 = minimal_spanning_tree(3, [\n        [1, 2, 5],\n        [2, 3, 5],\n        [1, 3, 1]\n    ]);\n    assert($result2 === 6, \"Test Case 2 Failed\");\n\n    // Test Case 3: More complex network\n    $result3 = minimal_spanning_tree(5, [\n        [1, 2, 10],\n        [2, 3, 20],\n        [3, 4, 30],\n        [4, 5, 40],\n        [1, 5, 50],\n        [2, 5, 60]\n    ]);\n    assert($result3 === 100, \"Test Case 3 Failed\");\n\n    echo \"All test cases passed!\\n\";\n}\n\ntestMinimalSpanningTree();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_lattice_points calculates the number of lattice points (i, j) that satisfy certain conditions.\n// The conditions are derived from the given mathematical logic where:\n// - For each j in 1..m, we check if a corresponding i exists within 1..n.\n// - The i is calculated as ((n-1)*j + (m-n)) / (m-1), and must be an integer within the range 1..n.\nfunction count_lattice_points($n, $m) {\n    $count = 0;\n\n    if ($m == 1) {\n        $count = $n;\n    } elseif ($n == 1) {\n        $count = $m;\n    } else {\n        for ($j = 1; $j <= $m; $j++) {\n            $numerator = ($n - 1) * $j + ($m - $n);\n            $denominator = $m - 1;\n            if ($numerator % $denominator == 0) {\n                $i = $numerator / $denominator;\n                if (1 <= $i && $i <= $n) {\n                    $count++;\n                }\n            }\n        }\n    }\n\n    return $count;\n}\n?>", "test_cases": "", "test_case_results": "Input: n = 5, m = 5\nCount: 5\nInput: n = 1, m = 10\nCount: 10\nInput: n = 10, m = 1\nCount: 10\nInput: n = 3, m = 7\nCount: 3\nInput: n = 7, m = 3\nCount: 3", "task_id": 2588, "assertions": "<?php\n\nfunction testCountLatticePoints() {\n    assert(count_lattice_points(5, 5) === 5);\n    assert(count_lattice_points(1, 10) === 10);\n    assert(count_lattice_points(10, 1) === 10);\n    assert(count_lattice_points(3, 7) === 3);\n    assert(count_lattice_points(7, 3) === 3);\n}\n\ntestCountLatticePoints();\n?>", "all_code": "<?php\n// count_lattice_points calculates the number of lattice points (i, j) that satisfy certain conditions.\n// The conditions are derived from the given mathematical logic where:\n// - For each j in 1..m, we check if a corresponding i exists within 1..n.\n// - The i is calculated as ((n-1)*j + (m-n)) / (m-1), and must be an integer within the range 1..n.\nfunction count_lattice_points($n, $m) {\n    $count = 0;\n\n    if ($m == 1) {\n        $count = $n;\n    } elseif ($n == 1) {\n        $count = $m;\n    } else {\n        for ($j = 1; $j <= $m; $j++) {\n            $numerator = ($n - 1) * $j + ($m - $n);\n            $denominator = $m - 1;\n            if ($numerator % $denominator == 0) {\n                $i = $numerator / $denominator;\n                if (1 <= $i && $i <= $n) {\n                    $count++;\n                }\n            }\n        }\n    }\n\n    return $count;\n}\nfunction testCountLatticePoints() {\n    assert(count_lattice_points(5, 5) === 5);\n    assert(count_lattice_points(1, 10) === 10);\n    assert(count_lattice_points(10, 1) === 10);\n    assert(count_lattice_points(3, 7) === 3);\n    assert(count_lattice_points(7, 3) === 3);\n}\n\ntestCountLatticePoints();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_mutual_friendships calculates the total number of mutual friendships in a network.\n// The function takes an adjacency matrix (2D array of booleans) where friendships[a][b] indicates if 'a' is friends with 'b'.\n// It returns the number of mutual friendships (where both friendships[a][b] and friendships[b][a] are true).\n// Since each mutual friendship is counted twice in the adjacency matrix, the result is divided by 2 before returning.\nfunction count_mutual_friendships($friendships) {\n    $n = count($friendships);\n    $mutual_friendships = 0;\n    \n    for ($a = 0; $a < $n; $a++) {\n        for ($b = 0; $b < $n; $b++) {\n            if ($friendships[$a][$b] && $friendships[$b][$a]) {\n                $mutual_friendships += 1;\n            }\n        }\n    }\n    \n    return $mutual_friendships / 2;\n}\n?>", "test_cases": "", "test_case_results": "Input adjacency matrix:\n[false, true, false, ]\n[true, false, true, ]\n[false, true, false, ]\nNumber of mutual friendships: 2\n\nInput adjacency matrix:\n[false, true, true, ]\n[true, false, true, ]\n[true, true, false, ]\nNumber of mutual friendships: 3\n\nInput adjacency matrix:\n[false, false, false, ]\n[false, false, false, ]\n[false, false, false, ]\nNumber of mutual friendships: 0", "task_id": 9963, "assertions": "<?php\n\nfunction testCountMutualFriendships() {\n    $testCase1 = [\n        [false, true, false],\n        [true, false, true],\n        [false, true, false]\n    ];\n    assert(count_mutual_friendships($testCase1) == 2);\n\n    $testCase2 = [\n        [false, true, true],\n        [true, false, true],\n        [true, true, false]\n    ];\n    assert(count_mutual_friendships($testCase2) == 3);\n\n    $testCase3 = [\n        [false, false, false],\n        [false, false, false],\n        [false, false, false]\n    ];\n    assert(count_mutual_friendships($testCase3) == 0);\n}\n\ntestCountMutualFriendships();\n?>", "all_code": "<?php\n// count_mutual_friendships calculates the total number of mutual friendships in a network.\n// The function takes an adjacency matrix (2D array of booleans) where friendships[a][b] indicates if 'a' is friends with 'b'.\n// It returns the number of mutual friendships (where both friendships[a][b] and friendships[b][a] are true).\n// Since each mutual friendship is counted twice in the adjacency matrix, the result is divided by 2 before returning.\nfunction count_mutual_friendships($friendships) {\n    $n = count($friendships);\n    $mutual_friendships = 0;\n    \n    for ($a = 0; $a < $n; $a++) {\n        for ($b = 0; $b < $n; $b++) {\n            if ($friendships[$a][$b] && $friendships[$b][$a]) {\n                $mutual_friendships += 1;\n            }\n        }\n    }\n    \n    return $mutual_friendships / 2;\n}\nfunction testCountMutualFriendships() {\n    $testCase1 = [\n        [false, true, false],\n        [true, false, true],\n        [false, true, false]\n    ];\n    assert(count_mutual_friendships($testCase1) == 2);\n\n    $testCase2 = [\n        [false, true, true],\n        [true, false, true],\n        [true, true, false]\n    ];\n    assert(count_mutual_friendships($testCase2) == 3);\n\n    $testCase3 = [\n        [false, false, false],\n        [false, false, false],\n        [false, false, false]\n    ];\n    assert(count_mutual_friendships($testCase3) == 0);\n}\n\ntestCountMutualFriendships();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// are_anagrams checks if two strings are anagrams by comparing the sorted versions of the strings.\n// If the lengths of the strings are not equal, they cannot be anagrams.\nfunction are_anagrams($str1, $str2) {\n    // If lengths are not equal, they cannot be anagrams\n    if (strlen($str1) != strlen($str2)) {\n        return false;\n    }\n\n    // Sorting both strings\n    $sorted_str1 = sorted_characters($str1);\n    $sorted_str2 = sorted_characters($str2);\n\n    // Compare sorted strings\n    return $sorted_str1 == $sorted_str2;\n}\n\n// sorted_characters is a helper function to sort characters in a string without using built-in sort function.\n// It implements bubble sort to sort the characters.\nfunction sorted_characters($s) {\n    $characters = str_split($s);\n    $n = count($characters);\n    \n    // Implementing bubble sort\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n - $i - 1; $j++) {\n            if ($characters[$j] > $characters[$j + 1]) {\n                // Swap characters\n                $temp = $characters[$j];\n                $characters[$j] = $characters[$j + 1];\n                $characters[$j + 1] = $temp;\n            }\n        }\n    }\n    \n    return implode('', $characters);\n}\n?>", "test_cases": "", "test_case_results": "Input: 'listen', 'silent'\nAre anagrams: true\nInput: 'hello', 'world'\nAre anagrams: false\nInput: 'abc', 'cba'\nAre anagrams: true\nInput: 'test', 'tset'\nAre anagrams: true\nInput: 'anagram', 'nagaram'\nAre anagrams: true\nInput: 'foo', 'bar'\nAre anagrams: false", "task_id": 10556, "assertions": "<?php\nfunction testAreAnagrams() {\n    assert(are_anagrams(\"listen\", \"silent\") === true);\n    assert(are_anagrams(\"hello\", \"world\") === false);\n    assert(are_anagrams(\"abc\", \"cba\") === true);\n    assert(are_anagrams(\"test\", \"tset\") === true);\n    assert(are_anagrams(\"anagram\", \"nagaram\") === true);\n    assert(are_anagrams(\"foo\", \"bar\") === false);\n}\n\ntestAreAnagrams();\n?>", "all_code": "<?php\n// are_anagrams checks if two strings are anagrams by comparing the sorted versions of the strings.\n// If the lengths of the strings are not equal, they cannot be anagrams.\nfunction are_anagrams($str1, $str2) {\n    // If lengths are not equal, they cannot be anagrams\n    if (strlen($str1) != strlen($str2)) {\n        return false;\n    }\n\n    // Sorting both strings\n    $sorted_str1 = sorted_characters($str1);\n    $sorted_str2 = sorted_characters($str2);\n\n    // Compare sorted strings\n    return $sorted_str1 == $sorted_str2;\n}\n\n// sorted_characters is a helper function to sort characters in a string without using built-in sort function.\n// It implements bubble sort to sort the characters.\nfunction sorted_characters($s) {\n    $characters = str_split($s);\n    $n = count($characters);\n    \n    // Implementing bubble sort\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n - $i - 1; $j++) {\n            if ($characters[$j] > $characters[$j + 1]) {\n                // Swap characters\n                $temp = $characters[$j];\n                $characters[$j] = $characters[$j + 1];\n                $characters[$j + 1] = $temp;\n            }\n        }\n    }\n    \n    return implode('', $characters);\n}\nfunction testAreAnagrams() {\n    assert(are_anagrams(\"listen\", \"silent\") === true);\n    assert(are_anagrams(\"hello\", \"world\") === false);\n    assert(are_anagrams(\"abc\", \"cba\") === true);\n    assert(are_anagrams(\"test\", \"tset\") === true);\n    assert(are_anagrams(\"anagram\", \"nagaram\") === true);\n    assert(are_anagrams(\"foo\", \"bar\") === false);\n}\n\ntestAreAnagrams();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// number_of_distinct_sets_of_heights calculates the number of distinct sets of heights for each test case.\n// The number of sets is the product of all heights in each test case, modulo 10^9 + 7.\n// Parameters:\n//   $T - the number of test cases\n//   $test_cases - an array of test cases, where each test case is an array with two elements:\n//                 the first element is M (unused in the calculation), and the second is an array of heights\n// Returns an array of results, one for each test case.\nfunction number_of_distinct_sets_of_heights($T, $test_cases) {\n    $MOD = 1000000007;\n    $results = array();\n    \n    for ($i = 0; $i < $T; $i++) {\n        $heights = $test_cases[$i][1];\n        $num_sets = 1;\n        \n        foreach ($heights as $h) {\n            $num_sets = ($num_sets * $h) % $MOD;\n        }\n        \n        array_push($results, $num_sets);\n    }\n    \n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1: M = 2, heights = [3, 4]\nNumber of distinct sets: 12\nTest Case 2: M = 3, heights = [2, 3, 5]\nNumber of distinct sets: 30", "task_id": 24808, "assertions": "<?php\nfunction testNumberOfDistinctSetsOfHeights() {\n    $MOD = 1000000007;\n    \n    // Test Case 1\n    $T1 = 2;\n    $testCases1 = array(\n        array(2, array(3, 4)),\n        array(3, array(2, 3, 5))\n    );\n    $expected1 = array(12, 30);\n    $result1 = number_of_distinct_sets_of_heights($T1, $testCases1);\n    assert($result1 == $expected1);\n    \n    // Additional test cases could be added here\n    // For example, test with empty array\n    $T2 = 1;\n    $testCases2 = array(\n        array(0, array())\n    );\n    $expected2 = array(1); // Product of empty set is 1\n    $result2 = number_of_distinct_sets_of_heights($T2, $testCases2);\n    assert($result2 == $expected2);\n    \n    // Test with single element\n    $T3 = 1;\n    $testCases3 = array(\n        array(1, array(10))\n    );\n    $expected3 = array(10);\n    $result3 = number_of_distinct_sets_of_heights($T3, $testCases3);\n    assert($result3 == $expected3);\n}\n\ntestNumberOfDistinctSetsOfHeights();\n?>", "all_code": "<?php\n// number_of_distinct_sets_of_heights calculates the number of distinct sets of heights for each test case.\n// The number of sets is the product of all heights in each test case, modulo 10^9 + 7.\n// Parameters:\n//   $T - the number of test cases\n//   $test_cases - an array of test cases, where each test case is an array with two elements:\n//                 the first element is M (unused in the calculation), and the second is an array of heights\n// Returns an array of results, one for each test case.\nfunction number_of_distinct_sets_of_heights($T, $test_cases) {\n    $MOD = 1000000007;\n    $results = array();\n    \n    for ($i = 0; $i < $T; $i++) {\n        $heights = $test_cases[$i][1];\n        $num_sets = 1;\n        \n        foreach ($heights as $h) {\n            $num_sets = ($num_sets * $h) % $MOD;\n        }\n        \n        array_push($results, $num_sets);\n    }\n    \n    return $results;\n}\nfunction testNumberOfDistinctSetsOfHeights() {\n    $MOD = 1000000007;\n    \n    // Test Case 1\n    $T1 = 2;\n    $testCases1 = array(\n        array(2, array(3, 4)),\n        array(3, array(2, 3, 5))\n    );\n    $expected1 = array(12, 30);\n    $result1 = number_of_distinct_sets_of_heights($T1, $testCases1);\n    assert($result1 == $expected1);\n    \n    // Additional test cases could be added here\n    // For example, test with empty array\n    $T2 = 1;\n    $testCases2 = array(\n        array(0, array())\n    );\n    $expected2 = array(1); // Product of empty set is 1\n    $result2 = number_of_distinct_sets_of_heights($T2, $testCases2);\n    assert($result2 == $expected2);\n    \n    // Test with single element\n    $T3 = 1;\n    $testCases3 = array(\n        array(1, array(10))\n    );\n    $expected3 = array(10);\n    $result3 = number_of_distinct_sets_of_heights($T3, $testCases3);\n    assert($result3 == $expected3);\n}\n\ntestNumberOfDistinctSetsOfHeights();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// This script simulates a simple banking system where you can perform two types of queries:\n// 1. Deposit or withdraw money from a specific account.\n// 2. Calculate the total balance between two accounts (inclusive).\n\n// Initialize the accounts array with 1-based indexing.\nfunction initialize_accounts($n) {\n    return array_fill(1, $n, 0);\n}\n\n// Process a deposit or withdrawal query.\nfunction process_transaction(&$accounts, $p, $x) {\n    $accounts[$p] += $x;\n}\n\n// Calculate the total balance between two accounts (inclusive).\nfunction calculate_total_balance($accounts, $p, $q) {\n    $total = 0;\n    for ($i = $p; $i <= $q; $i++) {\n        $total += $accounts[$i];\n    }\n    return $total;\n}\n?>", "test_cases": "", "test_case_results": "Transaction: Deposit/Withdraw 10000 to account 3\nTransaction: Deposit/Withdraw -5000 to account 4\nTransaction: Deposit/Withdraw -3000 to account 7\nQuery: Total balance from account 1 to 10 is 2000\nTransaction: Deposit/Withdraw 35000 to account 6\nQuery: Total balance from account 4 to 10 is 27000\nFinal account balances:\nAccount 1: 0\nAccount 2: 0\nAccount 3: 10000\nAccount 4: -5000\nAccount 5: 0\nAccount 6: 35000\nAccount 7: -3000\nAccount 8: 0\nAccount 9: 0\nAccount 10: 0", "task_id": 17692, "assertions": "<?php\n\nfunction testBankingSystem() {\n    // Initialize accounts with 10 accounts (1-based indexing)\n    $accounts = initialize_accounts(10);\n    \n    // Test process_transaction\n    process_transaction($accounts, 3, 10000);\n    assert($accounts[3] === 10000);\n    \n    process_transaction($accounts, 4, -5000);\n    assert($accounts[4] === -5000);\n    \n    process_transaction($accounts, 7, -3000);\n    assert($accounts[7] === -3000);\n    \n    // Test calculate_total_balance\n    assert(calculate_total_balance($accounts, 1, 10) === 2000);\n    \n    process_transaction($accounts, 6, 35000);\n    assert($accounts[6] === 35000);\n    \n    assert(calculate_total_balance($accounts, 4, 10) === 27000);\n    \n    // Verify final account balances\n    $expected_balances = [\n        1 => 0,\n        2 => 0,\n        3 => 10000,\n        4 => -5000,\n        5 => 0,\n        6 => 35000,\n        7 => -3000,\n        8 => 0,\n        9 => 0,\n        10 => 0\n    ];\n    \n    foreach ($expected_balances as $account_num => $balance) {\n        assert($accounts[$account_num] === $balance);\n    }\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestBankingSystem();\n?>", "all_code": "<?php\n// This script simulates a simple banking system where you can perform two types of queries:\n// 1. Deposit or withdraw money from a specific account.\n// 2. Calculate the total balance between two accounts (inclusive).\n\n// Initialize the accounts array with 1-based indexing.\nfunction initialize_accounts($n) {\n    return array_fill(1, $n, 0);\n}\n\n// Process a deposit or withdrawal query.\nfunction process_transaction(&$accounts, $p, $x) {\n    $accounts[$p] += $x;\n}\n\n// Calculate the total balance between two accounts (inclusive).\nfunction calculate_total_balance($accounts, $p, $q) {\n    $total = 0;\n    for ($i = $p; $i <= $q; $i++) {\n        $total += $accounts[$i];\n    }\n    return $total;\n}\nfunction testBankingSystem() {\n    // Initialize accounts with 10 accounts (1-based indexing)\n    $accounts = initialize_accounts(10);\n    \n    // Test process_transaction\n    process_transaction($accounts, 3, 10000);\n    assert($accounts[3] === 10000);\n    \n    process_transaction($accounts, 4, -5000);\n    assert($accounts[4] === -5000);\n    \n    process_transaction($accounts, 7, -3000);\n    assert($accounts[7] === -3000);\n    \n    // Test calculate_total_balance\n    assert(calculate_total_balance($accounts, 1, 10) === 2000);\n    \n    process_transaction($accounts, 6, 35000);\n    assert($accounts[6] === 35000);\n    \n    assert(calculate_total_balance($accounts, 4, 10) === 27000);\n    \n    // Verify final account balances\n    $expected_balances = [\n        1 => 0,\n        2 => 0,\n        3 => 10000,\n        4 => -5000,\n        5 => 0,\n        6 => 35000,\n        7 => -3000,\n        8 => 0,\n        9 => 0,\n        10 => 0\n    ];\n    \n    foreach ($expected_balances as $account_num => $balance) {\n        assert($accounts[$account_num] === $balance);\n    }\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestBankingSystem();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// encrypt_caesar performs a Caesar cipher encryption on a string.\n// It shifts each uppercase letter by n positions in the alphabet (wrapping around if needed),\n// while leaving spaces unchanged.\n// Parameters:\n//   $n - The shift value (integer)\n//   $s - The string to encrypt (only uppercase letters and spaces allowed)\n// Returns:\n//   The encrypted string\nfunction encrypt_caesar($n, $s) {\n    $encrypted = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        if ($c == ' ') {\n            $encrypted[] = ' ';\n        } else {\n            $shifted = (ord($c) - ord('A') + $n) % 26;\n            $encrypted[] = chr($shifted + ord('A'));\n        }\n    }\n    return implode('', $encrypted);\n}\n?>", "test_cases": "", "test_case_results": "#1 Input: n=5, s='HELLO WORLD'\nEncrypted: 'MJQQT BTWQI'\n\n#2 Input: n=13, s='SECRET MESSAGE'\nEncrypted: 'FRPERG ZRFFNTR'\n\n#3 Input: n=0, s='NO CHANGE'\nEncrypted: 'NO CHANGE'\n\n#4 Input: n=26, s='WRAP AROUND'\nEncrypted: 'WRAP AROUND'\n\n#5 Input: n=1, s='A B C'\nEncrypted: 'B C D'\n\n#6 Input: n=25, s='Z Y X'\nEncrypted: 'Y X W'", "task_id": 26818, "assertions": "<?php\n\nfunction testEncryptCaesar() {\n    assert(encrypt_caesar(5, \"HELLO WORLD\") === \"MJQQT BTWQI\");\n    assert(encrypt_caesar(13, \"SECRET MESSAGE\") === \"FRPERG ZRFFNTR\");\n    assert(encrypt_caesar(0, \"NO CHANGE\") === \"NO CHANGE\");\n    assert(encrypt_caesar(26, \"WRAP AROUND\") === \"WRAP AROUND\");\n    assert(encrypt_caesar(1, \"A B C\") === \"B C D\");\n    assert(encrypt_caesar(25, \"Z Y X\") === \"Y X W\");\n    echo \"All tests passed successfully!\";\n}\n\ntestEncryptCaesar();\n?>", "all_code": "<?php\n// encrypt_caesar performs a Caesar cipher encryption on a string.\n// It shifts each uppercase letter by n positions in the alphabet (wrapping around if needed),\n// while leaving spaces unchanged.\n// Parameters:\n//   $n - The shift value (integer)\n//   $s - The string to encrypt (only uppercase letters and spaces allowed)\n// Returns:\n//   The encrypted string\nfunction encrypt_caesar($n, $s) {\n    $encrypted = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        if ($c == ' ') {\n            $encrypted[] = ' ';\n        } else {\n            $shifted = (ord($c) - ord('A') + $n) % 26;\n            $encrypted[] = chr($shifted + ord('A'));\n        }\n    }\n    return implode('', $encrypted);\n}\nfunction testEncryptCaesar() {\n    assert(encrypt_caesar(5, \"HELLO WORLD\") === \"MJQQT BTWQI\");\n    assert(encrypt_caesar(13, \"SECRET MESSAGE\") === \"FRPERG ZRFFNTR\");\n    assert(encrypt_caesar(0, \"NO CHANGE\") === \"NO CHANGE\");\n    assert(encrypt_caesar(26, \"WRAP AROUND\") === \"WRAP AROUND\");\n    assert(encrypt_caesar(1, \"A B C\") === \"B C D\");\n    assert(encrypt_caesar(25, \"Z Y X\") === \"Y X W\");\n    echo \"All tests passed successfully!\";\n}\n\ntestEncryptCaesar();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Reconstructs the hidden list based on the allowed queries.\n *\n * @param int $n Length of the list.\n * @param int $m Range of each integer.\n * @param int $q Number of allowed queries.\n * @param callable $query_function Function to make queries in the form of query_function(i, j).\n *\n * @return array The reconstructed list.\n */\nfunction reconstruct_list($n, $m, $q, $query_function) {\n    // Create an array to store the reconstructed numbers\n    $result = array_fill(0, $n, 0);\n    \n    // We will query the sum of elements from the start to each index\n    // to get the prefix sums which will help us to deduce the individual elements\n    $prefix_sums = array_fill(0, $n + 1, 0);\n    \n    for ($i = 1; $i <= $n; $i++) {\n        if ($i == 1) {\n            // For the first element just query from 1 to 1\n            $prefix_sums[$i] = $query_function(1, 1);\n            $result[$i - 1] = $prefix_sums[$i];\n        } else {\n            // For other elements, query from 1 to i\n            $prefix_sums[$i] = $query_function(1, $i);\n            // Deduce the current element using the prefix sum\n            $result[$i - 1] = $prefix_sums[$i] - $prefix_sums[$i - 1];\n        }\n    }\n    \n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n = 4, m = 4, q = 4\nReconstructed List: 1, 2, 3, 4\nTest Case 2:\nInput: n = 4, m = 4, q = 4\nReconstructed List: 5, 6, 7, 8", "task_id": 4331, "assertions": "<?php\n\nfunction testReconstructList() {\n    // Test case 1\n    $mock_query_function1 = function($i, $j) {\n        $hidden_list = [1, 2, 3, 4];\n        $sum = 0;\n        for ($k = $i - 1; $k < $j; $k++) {\n            $sum += $hidden_list[$k];\n        }\n        return $sum;\n    };\n    \n    $result1 = reconstruct_list(4, 4, 4, $mock_query_function1);\n    assert($result1 === [1, 2, 3, 4], \"Test Case 1 Failed\");\n    \n    // Test case 2\n    $mock_query_function2 = function($i, $j) {\n        $hidden_list = [5, 6, 7, 8];\n        $sum = 0;\n        for ($k = $i - 1; $k < $j; $k++) {\n            $sum += $hidden_list[$k];\n        }\n        return $sum;\n    };\n    \n    $result2 = reconstruct_list(4, 4, 4, $mock_query_function2);\n    assert($result2 === [5, 6, 7, 8], \"Test Case 2 Failed\");\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestReconstructList();\n?>", "all_code": "<?php\n/**\n * Reconstructs the hidden list based on the allowed queries.\n *\n * @param int $n Length of the list.\n * @param int $m Range of each integer.\n * @param int $q Number of allowed queries.\n * @param callable $query_function Function to make queries in the form of query_function(i, j).\n *\n * @return array The reconstructed list.\n */\nfunction reconstruct_list($n, $m, $q, $query_function) {\n    // Create an array to store the reconstructed numbers\n    $result = array_fill(0, $n, 0);\n    \n    // We will query the sum of elements from the start to each index\n    // to get the prefix sums which will help us to deduce the individual elements\n    $prefix_sums = array_fill(0, $n + 1, 0);\n    \n    for ($i = 1; $i <= $n; $i++) {\n        if ($i == 1) {\n            // For the first element just query from 1 to 1\n            $prefix_sums[$i] = $query_function(1, 1);\n            $result[$i - 1] = $prefix_sums[$i];\n        } else {\n            // For other elements, query from 1 to i\n            $prefix_sums[$i] = $query_function(1, $i);\n            // Deduce the current element using the prefix sum\n            $result[$i - 1] = $prefix_sums[$i] - $prefix_sums[$i - 1];\n        }\n    }\n    \n    return $result;\n}\nfunction testReconstructList() {\n    // Test case 1\n    $mock_query_function1 = function($i, $j) {\n        $hidden_list = [1, 2, 3, 4];\n        $sum = 0;\n        for ($k = $i - 1; $k < $j; $k++) {\n            $sum += $hidden_list[$k];\n        }\n        return $sum;\n    };\n    \n    $result1 = reconstruct_list(4, 4, 4, $mock_query_function1);\n    assert($result1 === [1, 2, 3, 4], \"Test Case 1 Failed\");\n    \n    // Test case 2\n    $mock_query_function2 = function($i, $j) {\n        $hidden_list = [5, 6, 7, 8];\n        $sum = 0;\n        for ($k = $i - 1; $k < $j; $k++) {\n            $sum += $hidden_list[$k];\n        }\n        return $sum;\n    };\n    \n    $result2 = reconstruct_list(4, 4, 4, $mock_query_function2);\n    assert($result2 === [5, 6, 7, 8], \"Test Case 2 Failed\");\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestReconstructList();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines the minimum number of temperature zones required for different plant types.\n * \n * @param int $n Number of different types of plants.\n * @param array $ranges Array of arrays where each sub-array contains two integers (L, H)\n *                      that represent the lowest and highest temperature the i-th \n *                      type of plant can grow in.\n * @return int Minimum number of temperature zones required.\n */\nfunction min_temperature_zones($n, $ranges) {\n    // Sort the ranges based on their ending temperature\n    usort($ranges, function($a, $b) {\n        return $a[1] - $b[1];\n    });\n    \n    // Initialize the count of required zones\n    $zones = 0;\n    // The end of the last added zone\n    $last_zone_end = -1;\n    \n    foreach ($ranges as $range) {\n        if ($range[0] > $last_zone_end) {\n            // Create a new zone\n            $zones += 1;\n            $last_zone_end = $range[1];\n        }\n    }\n    \n    return $zones;\n}\n?>", "test_cases": "", "test_case_results": "Input:\nNumber of plants (n): 3\nTemperature ranges: [[1, 5], [3, 7], [6, 9], ]\nMinimum number of zones required: 2\n\nInput:\nNumber of plants (n): 4\nTemperature ranges: [[1, 2], [2, 3], [3, 4], [4, 5], ]\nMinimum number of zones required: 2\n\nInput:\nNumber of plants (n): 2\nTemperature ranges: [[1, 10], [2, 3], ]\nMinimum number of zones required: 1\n\nInput:\nNumber of plants (n): 1\nTemperature ranges: [[5, 5], ]\nMinimum number of zones required: 1", "task_id": 1605, "assertions": "<?php\n\nfunction testMinTemperatureZones() {\n    assert(min_temperature_zones(3, [[1, 5], [3, 7], [6, 9]]) === 2);\n    assert(min_temperature_zones(4, [[1, 2], [2, 3], [3, 4], [4, 5]]) === 2);\n    assert(min_temperature_zones(2, [[1, 10], [2, 3]]) === 1);\n    assert(min_temperature_zones(1, [[5, 5]]) === 1);\n    echo \"All tests passed successfully!\";\n}\n\ntestMinTemperatureZones();\n?>", "all_code": "<?php\n/**\n * Determines the minimum number of temperature zones required for different plant types.\n * \n * @param int $n Number of different types of plants.\n * @param array $ranges Array of arrays where each sub-array contains two integers (L, H)\n *                      that represent the lowest and highest temperature the i-th \n *                      type of plant can grow in.\n * @return int Minimum number of temperature zones required.\n */\nfunction min_temperature_zones($n, $ranges) {\n    // Sort the ranges based on their ending temperature\n    usort($ranges, function($a, $b) {\n        return $a[1] - $b[1];\n    });\n    \n    // Initialize the count of required zones\n    $zones = 0;\n    // The end of the last added zone\n    $last_zone_end = -1;\n    \n    foreach ($ranges as $range) {\n        if ($range[0] > $last_zone_end) {\n            // Create a new zone\n            $zones += 1;\n            $last_zone_end = $range[1];\n        }\n    }\n    \n    return $zones;\n}\nfunction testMinTemperatureZones() {\n    assert(min_temperature_zones(3, [[1, 5], [3, 7], [6, 9]]) === 2);\n    assert(min_temperature_zones(4, [[1, 2], [2, 3], [3, 4], [4, 5]]) === 2);\n    assert(min_temperature_zones(2, [[1, 10], [2, 3]]) === 1);\n    assert(min_temperature_zones(1, [[5, 5]]) === 1);\n    echo \"All tests passed successfully!\";\n}\n\ntestMinTemperatureZones();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// max_fertile_square calculates the area of the largest square containing only '1's in a given 2D field.\n// The function uses dynamic programming to efficiently compute the solution.\n// Parameters:\n// - $n: number of rows in the field\n// - $m: number of columns in the field\n// - $field: a 2D array representing the field, where each element is either '0' or '1'\n// Returns: the area of the largest square of '1's found in the field\nfunction max_fertile_square($n, $m, $field) {\n    if ($n == 0 || $m == 0) {\n        return 0;\n    }\n    \n    $dp = array_fill(0, $n, array_fill(0, $m, 0));\n    $max_side = 0;\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            if ($field[$i][$j] == '1') {\n                if ($i == 0 || $j == 0) {\n                    $dp[$i][$j] = 1;\n                } else {\n                    $dp[$i][$j] = min($dp[$i-1][$j], $dp[$i][$j-1], $dp[$i-1][$j-1]) + 1;\n                }\n                $max_side = max($max_side, $dp[$i][$j]);\n            }\n        }\n    }\n    \n    return $max_side * $max_side;\n}\n?>", "test_cases": "", "test_case_results": "Input:\nn: 4, m: 5\nField:\n1 0 1 0 0\n1 0 1 1 1\n1 1 1 1 1\n1 0 0 1 0\nArea of largest square of '1's: 4\n\nInput:\nn: 3, m: 3\nField:\n0 0 0\n0 0 0\n0 0 0\nArea of largest square of '1's: 0\n\nInput:\nn: 2, m: 2\nField:\n1 1\n1 1\nArea of largest square of '1's: 4", "task_id": 14528, "assertions": "<?php\nfunction testMaxFertileSquare() {\n    // Test case 1\n    $field1 = [\n        ['1', '0', '1', '0', '0'],\n        ['1', '0', '1', '1', '1'],\n        ['1', '1', '1', '1', '1'],\n        ['1', '0', '0', '1', '0']\n    ];\n    assert(max_fertile_square(4, 5, $field1) === 4);\n    \n    // Test case 2\n    $field2 = [\n        ['0', '0', '0'],\n        ['0', '0', '0'],\n        ['0', '0', '0']\n    ];\n    assert(max_fertile_square(3, 3, $field2) === 0);\n    \n    // Test case 3\n    $field3 = [\n        ['1', '1'],\n        ['1', '1']\n    ];\n    assert(max_fertile_square(2, 2, $field3) === 4);\n}\n\ntestMaxFertileSquare();\n?>", "all_code": "<?php\n// max_fertile_square calculates the area of the largest square containing only '1's in a given 2D field.\n// The function uses dynamic programming to efficiently compute the solution.\n// Parameters:\n// - $n: number of rows in the field\n// - $m: number of columns in the field\n// - $field: a 2D array representing the field, where each element is either '0' or '1'\n// Returns: the area of the largest square of '1's found in the field\nfunction max_fertile_square($n, $m, $field) {\n    if ($n == 0 || $m == 0) {\n        return 0;\n    }\n    \n    $dp = array_fill(0, $n, array_fill(0, $m, 0));\n    $max_side = 0;\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $m; $j++) {\n            if ($field[$i][$j] == '1') {\n                if ($i == 0 || $j == 0) {\n                    $dp[$i][$j] = 1;\n                } else {\n                    $dp[$i][$j] = min($dp[$i-1][$j], $dp[$i][$j-1], $dp[$i-1][$j-1]) + 1;\n                }\n                $max_side = max($max_side, $dp[$i][$j]);\n            }\n        }\n    }\n    \n    return $max_side * $max_side;\n}\nfunction testMaxFertileSquare() {\n    // Test case 1\n    $field1 = [\n        ['1', '0', '1', '0', '0'],\n        ['1', '0', '1', '1', '1'],\n        ['1', '1', '1', '1', '1'],\n        ['1', '0', '0', '1', '0']\n    ];\n    assert(max_fertile_square(4, 5, $field1) === 4);\n    \n    // Test case 2\n    $field2 = [\n        ['0', '0', '0'],\n        ['0', '0', '0'],\n        ['0', '0', '0']\n    ];\n    assert(max_fertile_square(3, 3, $field2) === 0);\n    \n    // Test case 3\n    $field3 = [\n        ['1', '1'],\n        ['1', '1']\n    ];\n    assert(max_fertile_square(2, 2, $field3) === 4);\n}\n\ntestMaxFertileSquare();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// Checks if a given word can be formed by sequentially adjacent letters on a 2D board.\n// The function uses a backtracking approach to explore all possible paths.\n// Returns \"YES\" if the word exists on the board, otherwise \"NO\".\nfunction exist($board, $word) {\n    $rows = count($board);\n    $cols = count($board[0]);\n\n    $backtrack = function($row, $col, $suffix) use (&$backtrack, &$board, $rows, $cols) {\n        if (strlen($suffix) == 0) {\n            return true;\n        }\n\n        if ($row < 0 || $row >= $rows || $col < 0 || $col >= $cols || $board[$row][$col] != $suffix[0]) {\n            return false;\n        }\n\n        $ret = false;\n        $temp = $board[$row][$col];\n        $board[$row][$col] = \"#\";  // Mark as visited\n\n        $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        foreach ($directions as $dir) {\n            $ret = $backtrack($row + $dir[0], $col + $dir[1], substr($suffix, 1));\n            if ($ret) {\n                break;\n            }\n        }\n\n        $board[$row][$col] = $temp;  // Unmark as visited\n        return $ret;\n    };\n\n    for ($row = 0; $row < $rows; $row++) {\n        for ($col = 0; $col < $cols; $col++) {\n            if ($backtrack($row, $col, $word)) {\n                return \"YES\";\n            }\n        }\n    }\n\n    return \"NO\";\n}\n?>", "test_cases": "", "test_case_results": "Board:\n[A, B, C, E]\n[S, F, C, S]\n[A, D, E, E]\nWord: ABCCED\nResult: YES\n\nBoard:\n[A, B, C, E]\n[S, F, C, S]\n[A, D, E, E]\nWord: SEE\nResult: YES\n\nBoard:\n[A, B, C, E]\n[S, F, C, S]\n[A, D, E, E]\nWord: ABCB\nResult: NO", "task_id": 27218, "assertions": "<?php\nfunction testExist() {\n    $board1 = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ];\n    assert(exist($board1, \"ABCCED\") === \"YES\");\n    assert(exist($board1, \"SEE\") === \"YES\");\n    assert(exist($board1, \"ABCB\") === \"NO\");\n}\n\ntestExist();\n?>", "all_code": "<?php\n// Checks if a given word can be formed by sequentially adjacent letters on a 2D board.\n// The function uses a backtracking approach to explore all possible paths.\n// Returns \"YES\" if the word exists on the board, otherwise \"NO\".\nfunction exist($board, $word) {\n    $rows = count($board);\n    $cols = count($board[0]);\n\n    $backtrack = function($row, $col, $suffix) use (&$backtrack, &$board, $rows, $cols) {\n        if (strlen($suffix) == 0) {\n            return true;\n        }\n\n        if ($row < 0 || $row >= $rows || $col < 0 || $col >= $cols || $board[$row][$col] != $suffix[0]) {\n            return false;\n        }\n\n        $ret = false;\n        $temp = $board[$row][$col];\n        $board[$row][$col] = \"#\";  // Mark as visited\n\n        $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        foreach ($directions as $dir) {\n            $ret = $backtrack($row + $dir[0], $col + $dir[1], substr($suffix, 1));\n            if ($ret) {\n                break;\n            }\n        }\n\n        $board[$row][$col] = $temp;  // Unmark as visited\n        return $ret;\n    };\n\n    for ($row = 0; $row < $rows; $row++) {\n        for ($col = 0; $col < $cols; $col++) {\n            if ($backtrack($row, $col, $word)) {\n                return \"YES\";\n            }\n        }\n    }\n\n    return \"NO\";\n}\nfunction testExist() {\n    $board1 = [\n        ['A', 'B', 'C', 'E'],\n        ['S', 'F', 'C', 'S'],\n        ['A', 'D', 'E', 'E']\n    ];\n    assert(exist($board1, \"ABCCED\") === \"YES\");\n    assert(exist($board1, \"SEE\") === \"YES\");\n    assert(exist($board1, \"ABCB\") === \"NO\");\n}\n\ntestExist();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Checks if the subarray from l to r (inclusive) forms a valid arithmetic progression.\n * \n * @param array $arr The input array.\n * @param int $l The left index (1-based) of the subarray.\n * @param int $r The right index (1-based) of the subarray.\n * @return bool True if the subarray is an arithmetic progression, False otherwise.\n */\nfunction is_arithmetic_subsequence($arr, $l, $r) {\n    $subarray = array_slice($arr, $l - 1, $r - $l + 1);\n    if (count($subarray) < 2) {\n        return true;\n    }\n    \n    $common_diff = $subarray[1] - $subarray[0];\n    for ($i = 2; $i < count($subarray); $i++) {\n        if ($subarray[$i] - $subarray[$i - 1] != $common_diff) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n/**\n * Processes a list of queries on the array to determine if each subarray is an arithmetic progression.\n * \n * @param int $n The length of the array (unused in this function but kept for consistency).\n * @param int $q The number of queries (unused in this function but kept for consistency).\n * @param array $arr The input array.\n * @param array $queries An array of queries, where each query is an array [l, r].\n * @return array An array of results, where each result is \"Yes\" or \"No\".\n */\nfunction process_queries($n, $q, $arr, $queries) {\n    $results = [];\n    foreach ($queries as $query) {\n        list($l, $r) = $query;\n        if (is_arithmetic_subsequence($arr, $l, $r)) {\n            $results[] = \"Yes\";\n        } else {\n            $results[] = \"No\";\n        }\n    }\n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Test Case:\nArray: [1, 3, 5, 7, 9]\nQueries:\n  [1, 3]\n  [2, 4]\n  [1, 5]\nResults: [Yes, Yes, Yes]\n\nTest Case:\nArray: [1, 2, 4, 8]\nQueries:\n  [1, 2]\n  [2, 4]\nResults: [Yes, No]\n\nTest Case:\nArray: [1, 1, 1]\nQueries:\n  [1, 3]\nResults: [Yes]", "task_id": 17658, "assertions": "<?php\n\nfunction testArithmeticSubsequence() {\n    // Test Case 1\n    $arr1 = [1, 3, 5, 7, 9];\n    $queries1 = [[1, 3], [2, 4], [1, 5]];\n    $results1 = process_queries(5, 3, $arr1, $queries1);\n    assert($results1 === [\"Yes\", \"Yes\", \"Yes\"]);\n\n    // Test Case 2\n    $arr2 = [1, 2, 4, 8];\n    $queries2 = [[1, 2], [2, 4]];\n    $results2 = process_queries(4, 2, $arr2, $queries2);\n    assert($results2 === [\"Yes\", \"No\"]);\n\n    // Test Case 3\n    $arr3 = [1, 1, 1];\n    $queries3 = [[1, 3]];\n    $results3 = process_queries(3, 1, $arr3, $queries3);\n    assert($results3 === [\"Yes\"]);\n}\n\ntestArithmeticSubsequence();\n?>", "all_code": "<?php\n/**\n * Checks if the subarray from l to r (inclusive) forms a valid arithmetic progression.\n * \n * @param array $arr The input array.\n * @param int $l The left index (1-based) of the subarray.\n * @param int $r The right index (1-based) of the subarray.\n * @return bool True if the subarray is an arithmetic progression, False otherwise.\n */\nfunction is_arithmetic_subsequence($arr, $l, $r) {\n    $subarray = array_slice($arr, $l - 1, $r - $l + 1);\n    if (count($subarray) < 2) {\n        return true;\n    }\n    \n    $common_diff = $subarray[1] - $subarray[0];\n    for ($i = 2; $i < count($subarray); $i++) {\n        if ($subarray[$i] - $subarray[$i - 1] != $common_diff) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\n/**\n * Processes a list of queries on the array to determine if each subarray is an arithmetic progression.\n * \n * @param int $n The length of the array (unused in this function but kept for consistency).\n * @param int $q The number of queries (unused in this function but kept for consistency).\n * @param array $arr The input array.\n * @param array $queries An array of queries, where each query is an array [l, r].\n * @return array An array of results, where each result is \"Yes\" or \"No\".\n */\nfunction process_queries($n, $q, $arr, $queries) {\n    $results = [];\n    foreach ($queries as $query) {\n        list($l, $r) = $query;\n        if (is_arithmetic_subsequence($arr, $l, $r)) {\n            $results[] = \"Yes\";\n        } else {\n            $results[] = \"No\";\n        }\n    }\n    return $results;\n}\nfunction testArithmeticSubsequence() {\n    // Test Case 1\n    $arr1 = [1, 3, 5, 7, 9];\n    $queries1 = [[1, 3], [2, 4], [1, 5]];\n    $results1 = process_queries(5, 3, $arr1, $queries1);\n    assert($results1 === [\"Yes\", \"Yes\", \"Yes\"]);\n\n    // Test Case 2\n    $arr2 = [1, 2, 4, 8];\n    $queries2 = [[1, 2], [2, 4]];\n    $results2 = process_queries(4, 2, $arr2, $queries2);\n    assert($results2 === [\"Yes\", \"No\"]);\n\n    // Test Case 3\n    $arr3 = [1, 1, 1];\n    $queries3 = [[1, 3]];\n    $results3 = process_queries(3, 1, $arr3, $queries3);\n    assert($results3 === [\"Yes\"]);\n}\n\ntestArithmeticSubsequence();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// transpose_matrix returns the transpose of a given 3x3 matrix.\n// The transpose of a matrix is obtained by swapping rows with columns.\nfunction transpose_matrix($matrix) {\n    $transposed = [];\n    for ($i = 0; $i < 3; $i++) {\n        for ($j = 0; $j < 3; $j++) {\n            $transposed[$i][$j] = $matrix[$j][$i];\n        }\n    }\n    return $transposed;\n}\n?>", "test_cases": "", "test_case_results": "Input Matrix:\n1, 2, 3\n4, 5, 6\n7, 8, 9\nTransposed Matrix:\n1, 4, 7\n2, 5, 8\n3, 6, 9\n\nInput Matrix:\n10, 20, 30\n40, 50, 60\n70, 80, 90\nTransposed Matrix:\n10, 40, 70\n20, 50, 80\n30, 60, 90\n\nInput Matrix:\n0, 0, 0\n1, 1, 1\n2, 2, 2\nTransposed Matrix:\n0, 1, 2\n0, 1, 2\n0, 1, 2", "task_id": 21410, "assertions": "<?php\nfunction testTransposeMatrix() {\n    assert(transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) === [[1, 4, 7], [2, 5, 8], [3, 6, 9]]);\n    assert(transpose_matrix([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) === [[10, 40, 70], [20, 50, 80], [30, 60, 90]]);\n    assert(transpose_matrix([[0, 0, 0], [1, 1, 1], [2, 2, 2]]) === [[0, 1, 2], [0, 1, 2], [0, 1, 2]]);\n}\n\ntestTransposeMatrix();\n?>", "all_code": "<?php\n// transpose_matrix returns the transpose of a given 3x3 matrix.\n// The transpose of a matrix is obtained by swapping rows with columns.\nfunction transpose_matrix($matrix) {\n    $transposed = [];\n    for ($i = 0; $i < 3; $i++) {\n        for ($j = 0; $j < 3; $j++) {\n            $transposed[$i][$j] = $matrix[$j][$i];\n        }\n    }\n    return $transposed;\n}\nfunction testTransposeMatrix() {\n    assert(transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) === [[1, 4, 7], [2, 5, 8], [3, 6, 9]]);\n    assert(transpose_matrix([[10, 20, 30], [40, 50, 60], [70, 80, 90]]) === [[10, 40, 70], [20, 50, 80], [30, 60, 90]]);\n    assert(transpose_matrix([[0, 0, 0], [1, 1, 1], [2, 2, 2]]) === [[0, 1, 2], [0, 1, 2], [0, 1, 2]]);\n}\n\ntestTransposeMatrix();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// get_position calculates the elevator and floor number based on the given position x,\n// considering there are m floors per elevator and k positions per floor.\n// The function returns an array with elevator and floor numbers.\nfunction get_position($x, $m, $k) {\n    $elevator = intval(($x - 1) / ($m * $k)) + 1;\n    $remainder = $x - ($elevator - 1) * ($m * $k);\n    $floor = intval(($remainder - 1) / $k) + 1;\n    return [$elevator, $floor];\n}\n\n// calculate_time computes the total time taken to move from position a to position b,\n// considering the given parameters n (total elevators), m (floors per elevator), and k (positions per floor).\n// The time calculation includes:\n// - 10 seconds per elevator difference\n// - 1 second per floor difference\n// - Additional 5 seconds if the floors are the same, otherwise 1 second.\nfunction calculate_time($n, $m, $k, $a, $b) {\n    list($e1, $f1) = get_position($a, $m, $k);\n    list($e2, $f2) = get_position($b, $m, $k);\n\n    $time = 10 * abs($e1 - $e2) + abs($f1 - $f2) * 1;\n    if ($f1 == $f2) {\n        $time += 5;\n    } else {\n        $time += 1;\n    }\n\n    return $time;\n}\n?>", "test_cases": "", "test_case_results": "Input: n=2, m=3, k=4, a=5, b=10\nTime: 2\nInput: n=3, m=2, k=5, a=7, b=12\nTime: 12\nInput: n=1, m=5, k=2, a=3, b=6\nTime: 2", "task_id": 29227, "assertions": "<?php\nfunction testCalculateTime() {\n    assert(calculate_time(2, 3, 4, 5, 10) === 2);\n    assert(calculate_time(3, 2, 5, 7, 12) === 12);\n    assert(calculate_time(1, 5, 2, 3, 6) === 2);\n}\n\ntestCalculateTime();\n?>", "all_code": "<?php\n// get_position calculates the elevator and floor number based on the given position x,\n// considering there are m floors per elevator and k positions per floor.\n// The function returns an array with elevator and floor numbers.\nfunction get_position($x, $m, $k) {\n    $elevator = intval(($x - 1) / ($m * $k)) + 1;\n    $remainder = $x - ($elevator - 1) * ($m * $k);\n    $floor = intval(($remainder - 1) / $k) + 1;\n    return [$elevator, $floor];\n}\n\n// calculate_time computes the total time taken to move from position a to position b,\n// considering the given parameters n (total elevators), m (floors per elevator), and k (positions per floor).\n// The time calculation includes:\n// - 10 seconds per elevator difference\n// - 1 second per floor difference\n// - Additional 5 seconds if the floors are the same, otherwise 1 second.\nfunction calculate_time($n, $m, $k, $a, $b) {\n    list($e1, $f1) = get_position($a, $m, $k);\n    list($e2, $f2) = get_position($b, $m, $k);\n\n    $time = 10 * abs($e1 - $e2) + abs($f1 - $f2) * 1;\n    if ($f1 == $f2) {\n        $time += 5;\n    } else {\n        $time += 1;\n    }\n\n    return $time;\n}\nfunction testCalculateTime() {\n    assert(calculate_time(2, 3, 4, 5, 10) === 2);\n    assert(calculate_time(3, 2, 5, 7, 12) === 12);\n    assert(calculate_time(1, 5, 2, 3, 6) === 2);\n}\n\ntestCalculateTime();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * bfs_minimum_corridors applies BFS to find the minimum path from room 1 to room n.\n * \n * @param int $n The number of rooms.\n * @param array $adj_list The adjacency list representing the corridors between rooms.\n * @return array An array containing the distance and the path from room 1 to room n. If no path exists, returns [-1, []].\n */\nfunction bfs_minimum_corridors($n, $adj_list) {\n    // This will store the minimum number of corridors from room 1 to room i.\n    $distances = array_fill(0, $n + 1, -1);\n    $distances[1] = 0;\n\n    // This will store the path to room n\n    $parent = array_fill(0, $n + 1, -1);\n\n    // Perform BFS\n    $queue = new SplQueue();\n    $queue->enqueue(1);\n\n    while (!$queue->isEmpty()) {\n        $current = $queue->dequeue();\n\n        foreach ($adj_list[$current] as $neighbor) {\n            if ($distances[$neighbor] == -1) {  // if the neighbor has not been visited\n                $distances[$neighbor] = $distances[$current] + 1;\n                $parent[$neighbor] = $current;\n                $queue->enqueue($neighbor);\n\n                // If we have reached room n, construct the path\n                if ($neighbor == $n) {\n                    $path = [];\n                    $node = $n;\n                    while ($node != -1) {\n                        array_unshift($path, $node);\n                        $node = $parent[$node];\n                    }\n                    return [$distances[$n], $path];\n                }\n            }\n        }\n    }\n\n    return [-1, []];\n}\n\n/**\n * find_treasure_path finds the shortest path from room 1 to room n in the haunted mansion.\n * \n * @param int $n The number of rooms.\n * @param array $corridors An array of corridors, where each corridor is represented as [u, v].\n * @return array An array containing the distance and the path from room 1 to room n. If no path exists, returns -1.\n */\nfunction find_treasure_path($n, $corridors) {\n    // Create adjacency list\n    $adj_list = array_fill(0, $n + 1, []);\n\n    foreach ($corridors as $corridor) {\n        $u = $corridor[0];\n        $v = $corridor[1];\n        $adj_list[$u][] = $v;\n        $adj_list[$v][] = $u;\n    }\n\n    list($distance, $path) = bfs_minimum_corridors($n, $adj_list);\n\n    if ($distance == -1) {\n        return -1;\n    } else {\n        return ['distance' => $distance, 'path' => $path];\n    }\n}\n?>", "test_cases": "", "test_case_results": "Input:\nNumber of rooms: 4\nCorridors: [[1, 2], [2, 3], [3, 4], ]\nDistance: 3\nPath: [1, 2, 3, 4]\n\nInput:\nNumber of rooms: 5\nCorridors: [[1, 2], [2, 3], [3, 4], [4, 5], ]\nDistance: 4\nPath: [1, 2, 3, 4, 5]\n\nInput:\nNumber of rooms: 3\nCorridors: [[1, 3], ]\nDistance: 1\nPath: [1, 3]\n\nInput:\nNumber of rooms: 4\nCorridors: [[1, 2], [1, 3], [3, 4], ]\nDistance: 2\nPath: [1, 3, 4]\n\nInput:\nNumber of rooms: 4\nCorridors: [[1, 2], [2, 4], [1, 3], ]\nDistance: 2\nPath: [1, 2, 4]", "task_id": 19811, "assertions": "<?php\n\nfunction testFindTreasurePath() {\n    // Test case 1: Simple linear path\n    $result1 = find_treasure_path(4, [[1, 2], [2, 3], [3, 4]]);\n    assert($result1['distance'] === 3);\n    assert($result1['path'] === [1, 2, 3, 4]);\n\n    // Test case 2: Longer linear path\n    $result2 = find_treasure_path(5, [[1, 2], [2, 3], [3, 4], [4, 5]]);\n    assert($result2['distance'] === 4);\n    assert($result2['path'] === [1, 2, 3, 4, 5]);\n\n    // Test case 3: Direct connection\n    $result3 = find_treasure_path(3, [[1, 3]]);\n    assert($result3['distance'] === 1);\n    assert($result3['path'] === [1, 3]);\n\n    // Test case 4: Alternative path\n    $result4 = find_treasure_path(4, [[1, 2], [1, 3], [3, 4]]);\n    assert($result4['distance'] === 2);\n    assert($result4['path'] === [1, 3, 4]);\n\n    // Test case 5: Multiple paths\n    $result5 = find_treasure_path(4, [[1, 2], [2, 4], [1, 3]]);\n    assert($result5['distance'] === 2);\n    assert($result5['path'] === [1, 2, 4]);\n\n    echo \"All tests passed successfully!\\n\";\n}\n\ntestFindTreasurePath();\n?>", "all_code": "<?php\n/**\n * bfs_minimum_corridors applies BFS to find the minimum path from room 1 to room n.\n * \n * @param int $n The number of rooms.\n * @param array $adj_list The adjacency list representing the corridors between rooms.\n * @return array An array containing the distance and the path from room 1 to room n. If no path exists, returns [-1, []].\n */\nfunction bfs_minimum_corridors($n, $adj_list) {\n    // This will store the minimum number of corridors from room 1 to room i.\n    $distances = array_fill(0, $n + 1, -1);\n    $distances[1] = 0;\n\n    // This will store the path to room n\n    $parent = array_fill(0, $n + 1, -1);\n\n    // Perform BFS\n    $queue = new SplQueue();\n    $queue->enqueue(1);\n\n    while (!$queue->isEmpty()) {\n        $current = $queue->dequeue();\n\n        foreach ($adj_list[$current] as $neighbor) {\n            if ($distances[$neighbor] == -1) {  // if the neighbor has not been visited\n                $distances[$neighbor] = $distances[$current] + 1;\n                $parent[$neighbor] = $current;\n                $queue->enqueue($neighbor);\n\n                // If we have reached room n, construct the path\n                if ($neighbor == $n) {\n                    $path = [];\n                    $node = $n;\n                    while ($node != -1) {\n                        array_unshift($path, $node);\n                        $node = $parent[$node];\n                    }\n                    return [$distances[$n], $path];\n                }\n            }\n        }\n    }\n\n    return [-1, []];\n}\n\n/**\n * find_treasure_path finds the shortest path from room 1 to room n in the haunted mansion.\n * \n * @param int $n The number of rooms.\n * @param array $corridors An array of corridors, where each corridor is represented as [u, v].\n * @return array An array containing the distance and the path from room 1 to room n. If no path exists, returns -1.\n */\nfunction find_treasure_path($n, $corridors) {\n    // Create adjacency list\n    $adj_list = array_fill(0, $n + 1, []);\n\n    foreach ($corridors as $corridor) {\n        $u = $corridor[0];\n        $v = $corridor[1];\n        $adj_list[$u][] = $v;\n        $adj_list[$v][] = $u;\n    }\n\n    list($distance, $path) = bfs_minimum_corridors($n, $adj_list);\n\n    if ($distance == -1) {\n        return -1;\n    } else {\n        return ['distance' => $distance, 'path' => $path];\n    }\n}\nfunction testFindTreasurePath() {\n    // Test case 1: Simple linear path\n    $result1 = find_treasure_path(4, [[1, 2], [2, 3], [3, 4]]);\n    assert($result1['distance'] === 3);\n    assert($result1['path'] === [1, 2, 3, 4]);\n\n    // Test case 2: Longer linear path\n    $result2 = find_treasure_path(5, [[1, 2], [2, 3], [3, 4], [4, 5]]);\n    assert($result2['distance'] === 4);\n    assert($result2['path'] === [1, 2, 3, 4, 5]);\n\n    // Test case 3: Direct connection\n    $result3 = find_treasure_path(3, [[1, 3]]);\n    assert($result3['distance'] === 1);\n    assert($result3['path'] === [1, 3]);\n\n    // Test case 4: Alternative path\n    $result4 = find_treasure_path(4, [[1, 2], [1, 3], [3, 4]]);\n    assert($result4['distance'] === 2);\n    assert($result4['path'] === [1, 3, 4]);\n\n    // Test case 5: Multiple paths\n    $result5 = find_treasure_path(4, [[1, 2], [2, 4], [1, 3]]);\n    assert($result5['distance'] === 2);\n    assert($result5['path'] === [1, 2, 4]);\n\n    echo \"All tests passed successfully!\\n\";\n}\n\ntestFindTreasurePath();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Returns the value of the first unique (non-repeated) element in the array.\n * If there is no unique element, returns -1.\n *\n * @param array $arr The input array of integers.\n * @return int The first unique element or -1 if none exists.\n */\nfunction first_unique(array $arr): int {\n    // Count the frequency of each element in the array\n    $count = array_count_values($arr);\n    \n    // Iterate through the array to find the first element with a count of 1\n    foreach ($arr as $num) {\n        if ($count[$num] === 1) {\n            return $num;\n        }\n    }\n    \n    return -1;\n}", "test_cases": "", "test_case_results": "Input: [4, 10, 5, 4, 2, 10]\nFirst unique element: 5\nInput: [1, 1, 1, 2, 2, 3, 3]\nFirst unique element: -1\nInput: [7]\nFirst unique element: 7\nInput: []\nFirst unique element: -1\nInput: [5, 5, 5, 5, 5]\nFirst unique element: -1", "task_id": 29392, "assertions": "<?php\n\nfunction testFirstUnique() {\n    assert(first_unique([4, 10, 5, 4, 2, 10]) === 5);\n    assert(first_unique([1, 1, 1, 2, 2, 3, 3]) === -1);\n    assert(first_unique([7]) === 7);\n    assert(first_unique([]) === -1);\n    assert(first_unique([5, 5, 5, 5, 5]) === -1);\n    echo \"All tests passed successfully!\";\n}\n\ntestFirstUnique();", "all_code": "<?php\n/**\n * Returns the value of the first unique (non-repeated) element in the array.\n * If there is no unique element, returns -1.\n *\n * @param array $arr The input array of integers.\n * @return int The first unique element or -1 if none exists.\n */\nfunction first_unique(array $arr): int {\n    // Count the frequency of each element in the array\n    $count = array_count_values($arr);\n    \n    // Iterate through the array to find the first element with a count of 1\n    foreach ($arr as $num) {\n        if ($count[$num] === 1) {\n            return $num;\n        }\n    }\n    \n    return -1;\n}\nfunction testFirstUnique() {\n    assert(first_unique([4, 10, 5, 4, 2, 10]) === 5);\n    assert(first_unique([1, 1, 1, 2, 2, 3, 3]) === -1);\n    assert(first_unique([7]) === 7);\n    assert(first_unique([]) === -1);\n    assert(first_unique([5, 5, 5, 5, 5]) === -1);\n    echo \"All tests passed successfully!\";\n}\n\ntestFirstUnique();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n/**\n * calculate_distance computes the total distance traveled given an array of acceleration and time pairs.\n * The distance is calculated using the formula: distance += velocity * time + 0.5 * acceleration * time^2\n * The velocity is updated in each iteration by adding acceleration * time.\n *\n * @param array $sources An array of arrays, where each sub-array contains acceleration and time values.\n * @return float The total distance traveled.\n */\nfunction calculate_distance($sources) {\n    $velocity = 0.0;\n    $distance = 0.0;\n    foreach ($sources as $source) {\n        $a = $source[0];\n        $t = $source[1];\n        $distance += $velocity * $t + 0.5 * $a * $t * $t;\n        $velocity += $a * $t;\n    }\n    return $distance;\n}\n\n/**\n * compare_distances calculates the difference between the optimal distance and the default distance.\n * The optimal order is determined by sorting the sources in descending order of acceleration and ascending order of time.\n *\n * @param array $sources An array of arrays, where each sub-array contains acceleration and time values.\n * @return float The difference between the optimal distance and the default distance.\n */\nfunction compare_distances($sources) {\n    $default_order = $sources;\n    $default_distance = calculate_distance($default_order);\n\n    // Sort sources by descending acceleration and ascending time\n    usort($sources, function ($a, $b) {\n        if ($a[0] == $b[0]) {\n            return $a[1] - $b[1];\n        }\n        return $b[0] - $a[0];\n    });\n    $optimal_distance = calculate_distance($sources);\n\n    return $optimal_distance - $default_distance;\n}\n?>", "test_cases": "", "test_case_results": "Input: [[1, 2], [3, 4], ]\nDifference: 16.0\nInput: [[5, 1], [2, 3], ]\nDifference: 0.0\nInput: [[0, 5], [0, 10], ]\nDifference: 0.0", "task_id": 10729, "assertions": "<?php\n\nfunction testDistanceCalculations() {\n    // Test case 1\n    $test1 = [[1, 2], [3, 4]];\n    assert(compare_distances($test1) == 16.0);\n    \n    // Test case 2\n    $test2 = [[5, 1], [2, 3]];\n    assert(compare_distances($test2) == 0.0);\n    \n    // Test case 3\n    $test3 = [[0, 5], [0, 10]];\n    assert(compare_distances($test3) == 0.0);\n}\n\ntestDistanceCalculations();\n?>", "all_code": "<?php\n/**\n * calculate_distance computes the total distance traveled given an array of acceleration and time pairs.\n * The distance is calculated using the formula: distance += velocity * time + 0.5 * acceleration * time^2\n * The velocity is updated in each iteration by adding acceleration * time.\n *\n * @param array $sources An array of arrays, where each sub-array contains acceleration and time values.\n * @return float The total distance traveled.\n */\nfunction calculate_distance($sources) {\n    $velocity = 0.0;\n    $distance = 0.0;\n    foreach ($sources as $source) {\n        $a = $source[0];\n        $t = $source[1];\n        $distance += $velocity * $t + 0.5 * $a * $t * $t;\n        $velocity += $a * $t;\n    }\n    return $distance;\n}\n\n/**\n * compare_distances calculates the difference between the optimal distance and the default distance.\n * The optimal order is determined by sorting the sources in descending order of acceleration and ascending order of time.\n *\n * @param array $sources An array of arrays, where each sub-array contains acceleration and time values.\n * @return float The difference between the optimal distance and the default distance.\n */\nfunction compare_distances($sources) {\n    $default_order = $sources;\n    $default_distance = calculate_distance($default_order);\n\n    // Sort sources by descending acceleration and ascending time\n    usort($sources, function ($a, $b) {\n        if ($a[0] == $b[0]) {\n            return $a[1] - $b[1];\n        }\n        return $b[0] - $a[0];\n    });\n    $optimal_distance = calculate_distance($sources);\n\n    return $optimal_distance - $default_distance;\n}\nfunction testDistanceCalculations() {\n    // Test case 1\n    $test1 = [[1, 2], [3, 4]];\n    assert(compare_distances($test1) == 16.0);\n    \n    // Test case 2\n    $test2 = [[5, 1], [2, 3]];\n    assert(compare_distances($test2) == 0.0);\n    \n    // Test case 3\n    $test3 = [[0, 5], [0, 10]];\n    assert(compare_distances($test3) == 0.0);\n}\n\ntestDistanceCalculations();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// Determines if a schedule can be created for water distribution among plants with conflicts.\n// The function checks if the conflict graph is bipartite (can be divided into two groups with no conflicts within each group).\n// If bipartite, it calculates the total water usage for the two groups.\n// Parameters:\n// - $n: Number of plants\n// - $m: Number of conflict pairs (unused in the logic but kept for interface consistency)\n// - $water_requirements: Array of water requirements for each plant\n// - $conflicts: Array of conflict pairs between plants\n// Returns: \"NO\" if conflicts cannot be resolved (graph is not bipartite), otherwise \"YES\" followed by total water usage\nfunction can_create_schedule($n, $m, $water_requirements, $conflicts) {\n    // Create the adjacency list for the conflict graph\n    $adjacency_list = array();\n    foreach ($conflicts as $pair) {\n        list($i, $j) = $pair;\n        if (!isset($adjacency_list[$i])) {\n            $adjacency_list[$i] = array();\n        }\n        if (!isset($adjacency_list[$j])) {\n            $adjacency_list[$j] = array();\n        }\n        array_push($adjacency_list[$i], $j);\n        array_push($adjacency_list[$j], $i);\n    }\n\n    // To store color of each vertex (-1: uncolored, 0 and 1: colors)\n    $colors = array_fill(1, $n, -1);\n\n    // Function to check if the graph is bipartite using BFS\n    $bfs_check_bipartite = function($start) use (&$adjacency_list, &$colors) {\n        $queue = array($start);\n        $colors[$start] = 0;\n        while (!empty($queue)) {\n            $u = array_shift($queue);\n            if (!isset($adjacency_list[$u])) {\n                continue;\n            }\n            foreach ($adjacency_list[$u] as $v) {\n                if ($colors[$v] == -1) {\n                    $colors[$v] = 1 - $colors[$u];\n                    array_push($queue, $v);\n                } elseif ($colors[$v] == $colors[$u]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    for ($plant = 1; $plant <= $n; $plant++) {\n        if ($colors[$plant] == -1) {\n            if (!$bfs_check_bipartite($plant)) {\n                return \"NO\";\n            }\n        }\n    }\n\n    $total_water_usage = 0;\n    foreach (array(0, 1) as $color_set) {\n        foreach (range(1, $n) as $i) {\n            if ($colors[$i] == $color_set) {\n                $total_water_usage += $water_requirements[$i - 1];\n            }\n        }\n    }\n\n    return \"YES \" . $total_water_usage;\n}\n?>", "test_cases": "", "test_case_results": "Test case:\nNumber of plants (n): 3\nNumber of conflicts (m): 2\nWater requirements: 10, 20, 30\nConflicts: (1, 2) (2, 3) \nResult: YES 60\n\nTest case:\nNumber of plants (n): 4\nNumber of conflicts (m): 3\nWater requirements: 10, 20, 30, 40\nConflicts: (1, 2) (2, 3) (3, 4) \nResult: YES 100\n\nTest case:\nNumber of plants (n): 3\nNumber of conflicts (m): 3\nWater requirements: 10, 20, 30\nConflicts: (1, 2) (2, 3) (1, 3) \nResult: NO", "task_id": 9097, "assertions": "<?php\nfunction testCanCreateSchedule() {\n    assert(can_create_schedule(3, 2, array(10, 20, 30), array(array(1, 2), array(2, 3))) === \"YES 60\");\n    assert(can_create_schedule(4, 3, array(10, 20, 30, 40), array(array(1, 2), array(2, 3), array(3, 4))) === \"YES 100\");\n    assert(can_create_schedule(3, 3, array(10, 20, 30), array(array(1, 2), array(2, 3), array(1, 3))) === \"NO\");\n}\n\ntestCanCreateSchedule();\n?>", "all_code": "<?php\n// Determines if a schedule can be created for water distribution among plants with conflicts.\n// The function checks if the conflict graph is bipartite (can be divided into two groups with no conflicts within each group).\n// If bipartite, it calculates the total water usage for the two groups.\n// Parameters:\n// - $n: Number of plants\n// - $m: Number of conflict pairs (unused in the logic but kept for interface consistency)\n// - $water_requirements: Array of water requirements for each plant\n// - $conflicts: Array of conflict pairs between plants\n// Returns: \"NO\" if conflicts cannot be resolved (graph is not bipartite), otherwise \"YES\" followed by total water usage\nfunction can_create_schedule($n, $m, $water_requirements, $conflicts) {\n    // Create the adjacency list for the conflict graph\n    $adjacency_list = array();\n    foreach ($conflicts as $pair) {\n        list($i, $j) = $pair;\n        if (!isset($adjacency_list[$i])) {\n            $adjacency_list[$i] = array();\n        }\n        if (!isset($adjacency_list[$j])) {\n            $adjacency_list[$j] = array();\n        }\n        array_push($adjacency_list[$i], $j);\n        array_push($adjacency_list[$j], $i);\n    }\n\n    // To store color of each vertex (-1: uncolored, 0 and 1: colors)\n    $colors = array_fill(1, $n, -1);\n\n    // Function to check if the graph is bipartite using BFS\n    $bfs_check_bipartite = function($start) use (&$adjacency_list, &$colors) {\n        $queue = array($start);\n        $colors[$start] = 0;\n        while (!empty($queue)) {\n            $u = array_shift($queue);\n            if (!isset($adjacency_list[$u])) {\n                continue;\n            }\n            foreach ($adjacency_list[$u] as $v) {\n                if ($colors[$v] == -1) {\n                    $colors[$v] = 1 - $colors[$u];\n                    array_push($queue, $v);\n                } elseif ($colors[$v] == $colors[$u]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    for ($plant = 1; $plant <= $n; $plant++) {\n        if ($colors[$plant] == -1) {\n            if (!$bfs_check_bipartite($plant)) {\n                return \"NO\";\n            }\n        }\n    }\n\n    $total_water_usage = 0;\n    foreach (array(0, 1) as $color_set) {\n        foreach (range(1, $n) as $i) {\n            if ($colors[$i] == $color_set) {\n                $total_water_usage += $water_requirements[$i - 1];\n            }\n        }\n    }\n\n    return \"YES \" . $total_water_usage;\n}\nfunction testCanCreateSchedule() {\n    assert(can_create_schedule(3, 2, array(10, 20, 30), array(array(1, 2), array(2, 3))) === \"YES 60\");\n    assert(can_create_schedule(4, 3, array(10, 20, 30, 40), array(array(1, 2), array(2, 3), array(3, 4))) === \"YES 100\");\n    assert(can_create_schedule(3, 3, array(10, 20, 30), array(array(1, 2), array(2, 3), array(1, 3))) === \"NO\");\n}\n\ntestCanCreateSchedule();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_torus_volume calculates the volume of a torus given the inner and outer radii.\n// The formula used is: volume = 2 * (pi^2) * R * (r^2), where R is the average of inner and outer radii,\n// and r is half the difference between outer and inner radii.\nfunction calculate_torus_volume($rin, $rout) {\n    $R = ($rin + $rout) / 2.0;\n    $r = ($rout - $rin) / 2.0;\n    $volume = 2 * pow(M_PI, 2) * $R * pow($r, 2);\n    return $volume;\n}\n\n// calculate_calories computes the total calories based on the volume of the torus and a calorie factor.\nfunction calculate_calories($volume, $calorie_factor) {\n    return $volume * $calorie_factor;\n}", "test_cases": "", "test_case_results": "Calorie Factor: 5, Inner Radius: 3, Outer Radius: 7\nCalories: 1,973.9208802179\nCalorie Factor: 10, Inner Radius: 1, Outer Radius: 5\nCalories: 2,368.7050562615\nCalorie Factor: 2, Inner Radius: 4, Outer Radius: 8\nCalories: 947.4820225046", "task_id": 24506, "assertions": "<?php\n\nfunction testTorusCalculations() {\n    // Test case 1\n    $volume1 = calculate_torus_volume(3, 7);\n    $calories1 = calculate_calories($volume1, 5);\n    assert(abs($calories1 - 1973.9208802179) < 0.0000000001);\n    \n    // Test case 2\n    $volume2 = calculate_torus_volume(1, 5);\n    $calories2 = calculate_calories($volume2, 10);\n    assert(abs($calories2 - 2368.7050562615) < 0.0000000001);\n    \n    // Test case 3\n    $volume3 = calculate_torus_volume(4, 8);\n    $calories3 = calculate_calories($volume3, 2);\n    assert(abs($calories3 - 947.4820225046) < 0.0000000001);\n}\n\ntestTorusCalculations();", "all_code": "<?php\n// calculate_torus_volume calculates the volume of a torus given the inner and outer radii.\n// The formula used is: volume = 2 * (pi^2) * R * (r^2), where R is the average of inner and outer radii,\n// and r is half the difference between outer and inner radii.\nfunction calculate_torus_volume($rin, $rout) {\n    $R = ($rin + $rout) / 2.0;\n    $r = ($rout - $rin) / 2.0;\n    $volume = 2 * pow(M_PI, 2) * $R * pow($r, 2);\n    return $volume;\n}\n\n// calculate_calories computes the total calories based on the volume of the torus and a calorie factor.\nfunction calculate_calories($volume, $calorie_factor) {\n    return $volume * $calorie_factor;\n}\nfunction testTorusCalculations() {\n    // Test case 1\n    $volume1 = calculate_torus_volume(3, 7);\n    $calories1 = calculate_calories($volume1, 5);\n    assert(abs($calories1 - 1973.9208802179) < 0.0000000001);\n    \n    // Test case 2\n    $volume2 = calculate_torus_volume(1, 5);\n    $calories2 = calculate_calories($volume2, 10);\n    assert(abs($calories2 - 2368.7050562615) < 0.0000000001);\n    \n    // Test case 3\n    $volume3 = calculate_torus_volume(4, 8);\n    $calories3 = calculate_calories($volume3, 2);\n    assert(abs($calories3 - 947.4820225046) < 0.0000000001);\n}\n\ntestTorusCalculations();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n/**\n * Finds the safest path from the starting room (Room 0) to the last room.\n * The safest path is the one with the lowest possible sum of danger levels.\n * \n * @param array $rooms An array of associative arrays where each key is a room index and the value is a list of tuples (next_room, danger).\n * @return int The total danger level of the safest path, or -1 if no path exists.\n */\nfunction safest_path($rooms) {\n    if (empty($rooms)) {\n        return -1;\n    }\n\n    $n = count($rooms);\n    $pq = new SplPriorityQueue();\n    $pq->setExtractFlags(SplPriorityQueue::EXTR_BOTH);\n    $pq->insert(0, -0); // Using negative priority to simulate min-heap\n\n    $dist = array_fill(0, $n, INF);\n    $dist[0] = 0;\n\n    while (!$pq->isEmpty()) {\n        $current = $pq->extract();\n        $curr_danger = -$current['priority'];\n        $curr_room = $current['data'];\n\n        if ($curr_room == $n - 1) {\n            return $curr_danger;\n        }\n\n        if (!isset($rooms[$curr_room])) {\n            continue;\n        }\n\n        foreach ($rooms[$curr_room] as $next_room => $danger) {\n            $new_danger = $curr_danger + $danger;\n            if ($new_danger < $dist[$next_room]) {\n                $dist[$next_room] = $new_danger;\n                $pq->insert($next_room, -$new_danger);\n            }\n        }\n    }\n\n    return -1;\n}\n?>", "test_cases": "", "test_case_results": "Test Case: Simple graph with two possible paths\nInput: [{\"1\":2,\"2\":4},{\"3\":3},{\"3\":1},[]]\nSafest Path Danger Level: 5\n\nTest Case: Straight line with minimal danger\nInput: [{\"1\":1},{\"2\":1},{\"3\":1},[]]\nSafest Path Danger Level: 3\n\nTest Case: Only one path\nInput: [{\"1\":5},[]]\nSafest Path Danger Level: 5\n\nTest Case: Empty rooms list\nInput: []\nSafest Path Danger Level: -1", "task_id": 27420, "assertions": "<?php\n\nfunction testSafestPath() {\n    // Test case 1: Simple graph with two possible paths\n    $rooms1 = [\n        0 => [1 => 2, 2 => 4],\n        1 => [3 => 3],\n        2 => [3 => 1],\n        3 => [],\n    ];\n    assert(safest_path($rooms1) === 5);\n\n    // Test case 2: Straight line with minimal danger\n    $rooms2 = [\n        0 => [1 => 1],\n        1 => [2 => 1],\n        2 => [3 => 1],\n        3 => [],\n    ];\n    assert(safest_path($rooms2) === 3);\n\n    // Test case 3: Only one path\n    $rooms3 = [\n        0 => [1 => 5],\n        1 => [],\n    ];\n    assert(safest_path($rooms3) === 5);\n\n    // Test case 4: Empty rooms list\n    $rooms4 = [];\n    assert(safest_path($rooms4) === -1);\n}\n\ntestSafestPath();\n?>", "all_code": "<?php\n/**\n * Finds the safest path from the starting room (Room 0) to the last room.\n * The safest path is the one with the lowest possible sum of danger levels.\n * \n * @param array $rooms An array of associative arrays where each key is a room index and the value is a list of tuples (next_room, danger).\n * @return int The total danger level of the safest path, or -1 if no path exists.\n */\nfunction safest_path($rooms) {\n    if (empty($rooms)) {\n        return -1;\n    }\n\n    $n = count($rooms);\n    $pq = new SplPriorityQueue();\n    $pq->setExtractFlags(SplPriorityQueue::EXTR_BOTH);\n    $pq->insert(0, -0); // Using negative priority to simulate min-heap\n\n    $dist = array_fill(0, $n, INF);\n    $dist[0] = 0;\n\n    while (!$pq->isEmpty()) {\n        $current = $pq->extract();\n        $curr_danger = -$current['priority'];\n        $curr_room = $current['data'];\n\n        if ($curr_room == $n - 1) {\n            return $curr_danger;\n        }\n\n        if (!isset($rooms[$curr_room])) {\n            continue;\n        }\n\n        foreach ($rooms[$curr_room] as $next_room => $danger) {\n            $new_danger = $curr_danger + $danger;\n            if ($new_danger < $dist[$next_room]) {\n                $dist[$next_room] = $new_danger;\n                $pq->insert($next_room, -$new_danger);\n            }\n        }\n    }\n\n    return -1;\n}\nfunction testSafestPath() {\n    // Test case 1: Simple graph with two possible paths\n    $rooms1 = [\n        0 => [1 => 2, 2 => 4],\n        1 => [3 => 3],\n        2 => [3 => 1],\n        3 => [],\n    ];\n    assert(safest_path($rooms1) === 5);\n\n    // Test case 2: Straight line with minimal danger\n    $rooms2 = [\n        0 => [1 => 1],\n        1 => [2 => 1],\n        2 => [3 => 1],\n        3 => [],\n    ];\n    assert(safest_path($rooms2) === 3);\n\n    // Test case 3: Only one path\n    $rooms3 = [\n        0 => [1 => 5],\n        1 => [],\n    ];\n    assert(safest_path($rooms3) === 5);\n\n    // Test case 4: Empty rooms list\n    $rooms4 = [];\n    assert(safest_path($rooms4) === -1);\n}\n\ntestSafestPath();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines if all the flyers can be delivered without any overlap.\n *\n * @param int $n The number of flyers.\n * @param array $slots Each sub-array contains two integers, start and end time of the slot for the flyer.\n * @return string \"YES\" if all flyers can be delivered without overlap, otherwise \"NO\".\n */\nfunction can_deliver_all_flyers($n, $slots) {\n    // Sort the flyers by their end time primarily and start time secondarily\n    usort($slots, function($a, $b) {\n        if ($a[1] == $b[1]) {\n            return $a[0] - $b[0];\n        }\n        return $a[1] - $b[1];\n    });\n    \n    // Initialize the end time of the last delivered flyer to -1 (before any possible time slot)\n    $last_end_time = -1;\n    \n    foreach ($slots as $slot) {\n        $start = $slot[0];\n        $end = $slot[1];\n        if ($start < $last_end_time) {\n            // Found overlap\n            return \"NO\";\n        }\n        // Update the last end time to the end of the current slot\n        $last_end_time = $end;\n    }\n    \n    return \"YES\";\n}\n?>", "test_cases": "", "test_case_results": "Input:\nNumber of flyers: 3\nTime slots: [[1, 2], [3, 4], [5, 6]]\nResult: YES\n\nInput:\nNumber of flyers: 3\nTime slots: [[1, 5], [2, 3], [4, 6]]\nResult: NO\n\nInput:\nNumber of flyers: 2\nTime slots: [[1, 3], [3, 5]]\nResult: YES", "task_id": 22865, "assertions": "<?php\n\nfunction testCanDeliverAllFlyers() {\n    assert(can_deliver_all_flyers(3, [[1, 2], [3, 4], [5, 6]]) === \"YES\");\n    assert(can_deliver_all_flyers(3, [[1, 5], [2, 3], [4, 6]]) === \"NO\");\n    assert(can_deliver_all_flyers(2, [[1, 3], [3, 5]]) === \"YES\");\n}\n\ntestCanDeliverAllFlyers();\n?>", "all_code": "<?php\n/**\n * Determines if all the flyers can be delivered without any overlap.\n *\n * @param int $n The number of flyers.\n * @param array $slots Each sub-array contains two integers, start and end time of the slot for the flyer.\n * @return string \"YES\" if all flyers can be delivered without overlap, otherwise \"NO\".\n */\nfunction can_deliver_all_flyers($n, $slots) {\n    // Sort the flyers by their end time primarily and start time secondarily\n    usort($slots, function($a, $b) {\n        if ($a[1] == $b[1]) {\n            return $a[0] - $b[0];\n        }\n        return $a[1] - $b[1];\n    });\n    \n    // Initialize the end time of the last delivered flyer to -1 (before any possible time slot)\n    $last_end_time = -1;\n    \n    foreach ($slots as $slot) {\n        $start = $slot[0];\n        $end = $slot[1];\n        if ($start < $last_end_time) {\n            // Found overlap\n            return \"NO\";\n        }\n        // Update the last end time to the end of the current slot\n        $last_end_time = $end;\n    }\n    \n    return \"YES\";\n}\nfunction testCanDeliverAllFlyers() {\n    assert(can_deliver_all_flyers(3, [[1, 2], [3, 4], [5, 6]]) === \"YES\");\n    assert(can_deliver_all_flyers(3, [[1, 5], [2, 3], [4, 6]]) === \"NO\");\n    assert(can_deliver_all_flyers(2, [[1, 3], [3, 5]]) === \"YES\");\n}\n\ntestCanDeliverAllFlyers();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// number_of_focal_subarrays calculates the number of subarrays that contain exactly k odd numbers.\n// It uses a prefix count approach to efficiently compute the result.\nfunction number_of_focal_subarrays($nums, $k) {\n    $count = 0;\n    $odd_count = 0;\n    $prefix_counts = [0 => 1];\n    \n    foreach ($nums as $num) {\n        if ($num % 2 == 1) {\n            $odd_count += 1;\n        }\n        \n        if (array_key_exists($odd_count - $k, $prefix_counts)) {\n            $count += $prefix_counts[$odd_count - $k];\n        }\n        \n        if (array_key_exists($odd_count, $prefix_counts)) {\n            $prefix_counts[$odd_count] += 1;\n        } else {\n            $prefix_counts[$odd_count] = 1;\n        }\n    }\n    \n    return $count;\n}\n?>", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4], k: 1\nNumber of focal subarrays: 6\nInput array: [1, 1, 1, 1], k: 2\nNumber of focal subarrays: 3\nInput array: [2, 4, 6, 8], k: 1\nNumber of focal subarrays: 0\nInput array: [1, 3, 5, 7], k: 4\nNumber of focal subarrays: 1", "task_id": 7353, "assertions": "<?php\n\nfunction testNumberOfFocalSubarrays() {\n    assert(number_of_focal_subarrays([1, 2, 3, 4], 1) === 6);\n    assert(number_of_focal_subarrays([1, 1, 1, 1], 2) === 3);\n    assert(number_of_focal_subarrays([2, 4, 6, 8], 1) === 0);\n    assert(number_of_focal_subarrays([1, 3, 5, 7], 4) === 1);\n}\n\ntestNumberOfFocalSubarrays();\n?>", "all_code": "<?php\n// number_of_focal_subarrays calculates the number of subarrays that contain exactly k odd numbers.\n// It uses a prefix count approach to efficiently compute the result.\nfunction number_of_focal_subarrays($nums, $k) {\n    $count = 0;\n    $odd_count = 0;\n    $prefix_counts = [0 => 1];\n    \n    foreach ($nums as $num) {\n        if ($num % 2 == 1) {\n            $odd_count += 1;\n        }\n        \n        if (array_key_exists($odd_count - $k, $prefix_counts)) {\n            $count += $prefix_counts[$odd_count - $k];\n        }\n        \n        if (array_key_exists($odd_count, $prefix_counts)) {\n            $prefix_counts[$odd_count] += 1;\n        } else {\n            $prefix_counts[$odd_count] = 1;\n        }\n    }\n    \n    return $count;\n}\nfunction testNumberOfFocalSubarrays() {\n    assert(number_of_focal_subarrays([1, 2, 3, 4], 1) === 6);\n    assert(number_of_focal_subarrays([1, 1, 1, 1], 2) === 3);\n    assert(number_of_focal_subarrays([2, 4, 6, 8], 1) === 0);\n    assert(number_of_focal_subarrays([1, 3, 5, 7], 4) === 1);\n}\n\ntestNumberOfFocalSubarrays();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// compute_mobius calculates the Mbius function values up to a given maximum number.\n// The Mbius function (n) is defined as:\n// - (n) = 1 if n is a square-free positive integer with an even number of prime factors.\n// - (n) = -1 if n is a square-free positive integer with an odd number of prime factors.\n// - (n) = 0 if n has a squared prime factor.\n// The function uses a sieve algorithm to compute the values efficiently.\nfunction compute_mobius($max_d) {\n    $mu = array_fill(0, $max_d + 1, 1);\n    $is_prime = array_fill(0, $max_d + 1, true);\n    $is_prime[0] = $is_prime[1] = false;\n\n    for ($p = 2; $p <= $max_d; $p++) {\n        if ($is_prime[$p]) {\n            for ($multiple = $p; $multiple <= $max_d; $multiple += $p) {\n                $is_prime[$multiple] = ($multiple == $p) ? $is_prime[$multiple] : false;\n                $mu[$multiple] *= -1;\n            }\n            $p_square = $p * $p;\n            for ($multiple = $p_square; $multiple <= $max_d; $multiple += $p_square) {\n                $mu[$multiple] = 0;\n            }\n        }\n    }\n    return $mu;\n}\n\n// calculate_total computes the total value based on the Mbius function and a given number N.\n// The total is calculated by summing (d) * count for each divisor d of N, where count is derived from (m + 1)^3 - 1 and m = N // d.\nfunction calculate_total($N, $mu) {\n    $total = 0;\n    for ($d = 1; $d <= $N; $d++) {\n        $m = intdiv($N, $d);\n        $count = pow($m + 1, 3) - 1;\n        $total += $mu[$d] * $count;\n    }\n    return $total;\n}\n?>", "test_cases": "", "test_case_results": "Input N: 1\nTotal: 7\nInput N: 2\nTotal: 19\nInput N: 3\nTotal: 49\nInput N: 4\nTotal: 91\nInput N: 5\nTotal: 175\nInput N: 10\nTotal: 1033\nInput N: 20\nTotal: 7513", "task_id": 26565, "assertions": "<?php\nfunction testMobiusCalculations() {\n    $max_d = 100;\n    $mu = compute_mobius($max_d);\n    \n    assert(calculate_total(1, $mu) === 7);\n    assert(calculate_total(2, $mu) === 19);\n    assert(calculate_total(3, $mu) === 49);\n    assert(calculate_total(4, $mu) === 91);\n    assert(calculate_total(5, $mu) === 175);\n    assert(calculate_total(10, $mu) === 1033);\n    assert(calculate_total(20, $mu) === 7513);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestMobiusCalculations();\n?>", "all_code": "<?php\n// compute_mobius calculates the Mbius function values up to a given maximum number.\n// The Mbius function (n) is defined as:\n// - (n) = 1 if n is a square-free positive integer with an even number of prime factors.\n// - (n) = -1 if n is a square-free positive integer with an odd number of prime factors.\n// - (n) = 0 if n has a squared prime factor.\n// The function uses a sieve algorithm to compute the values efficiently.\nfunction compute_mobius($max_d) {\n    $mu = array_fill(0, $max_d + 1, 1);\n    $is_prime = array_fill(0, $max_d + 1, true);\n    $is_prime[0] = $is_prime[1] = false;\n\n    for ($p = 2; $p <= $max_d; $p++) {\n        if ($is_prime[$p]) {\n            for ($multiple = $p; $multiple <= $max_d; $multiple += $p) {\n                $is_prime[$multiple] = ($multiple == $p) ? $is_prime[$multiple] : false;\n                $mu[$multiple] *= -1;\n            }\n            $p_square = $p * $p;\n            for ($multiple = $p_square; $multiple <= $max_d; $multiple += $p_square) {\n                $mu[$multiple] = 0;\n            }\n        }\n    }\n    return $mu;\n}\n\n// calculate_total computes the total value based on the Mbius function and a given number N.\n// The total is calculated by summing (d) * count for each divisor d of N, where count is derived from (m + 1)^3 - 1 and m = N // d.\nfunction calculate_total($N, $mu) {\n    $total = 0;\n    for ($d = 1; $d <= $N; $d++) {\n        $m = intdiv($N, $d);\n        $count = pow($m + 1, 3) - 1;\n        $total += $mu[$d] * $count;\n    }\n    return $total;\n}\nfunction testMobiusCalculations() {\n    $max_d = 100;\n    $mu = compute_mobius($max_d);\n    \n    assert(calculate_total(1, $mu) === 7);\n    assert(calculate_total(2, $mu) === 19);\n    assert(calculate_total(3, $mu) === 49);\n    assert(calculate_total(4, $mu) === 91);\n    assert(calculate_total(5, $mu) === 175);\n    assert(calculate_total(10, $mu) === 1033);\n    assert(calculate_total(20, $mu) === 7513);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestMobiusCalculations();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// precompute_factorials generates an array of factorials from 0! to 12!.\n// This is because the maximum value of n is R + C - 2, where R and C can be up to 7, so 7 + 7 - 2 = 12.\nfunction precompute_factorials() {\n    $factorial = array_fill(0, 13, 1); // Initialize with 1 (0! = 1)\n    for ($i = 1; $i <= 12; $i++) {\n        $factorial[$i] = $factorial[$i - 1] * $i;\n    }\n    return $factorial;\n}\n\n// calculate_combinations computes the number of combinations (n choose k) using precomputed factorials.\n// The formula used is n! / (k! * (n - k)!).\nfunction calculate_combinations($n, $k, $factorial) {\n    return $factorial[$n] / ($factorial[$k] * $factorial[$n - $k]);\n}", "test_cases": "", "test_case_results": "R: 1, C: 1\nCombinations: 1\nR: 2, C: 2\nCombinations: 2\nR: 3, C: 3\nCombinations: 6\nR: 4, C: 4\nCombinations: 20\nR: 5, C: 5\nCombinations: 70\nR: 6, C: 6\nCombinations: 252\nR: 7, C: 7\nCombinations: 924\nR: 2, C: 3\nCombinations: 3\nR: 3, C: 2\nCombinations: 3\nR: 4, C: 5\nCombinations: 35\nR: 5, C: 4\nCombinations: 35", "task_id": 25744, "assertions": "<?php\n\nfunction testCombinations() {\n    $factorial = precompute_factorials();\n    \n    // Test cases with expected results\n    assert(calculate_combinations(0, 0, $factorial) == 1);\n    assert(calculate_combinations(2, 1, $factorial) == 2);\n    assert(calculate_combinations(4, 2, $factorial) == 6);\n    assert(calculate_combinations(6, 3, $factorial) == 20);\n    assert(calculate_combinations(8, 4, $factorial) == 70);\n    assert(calculate_combinations(10, 5, $factorial) == 252);\n    assert(calculate_combinations(12, 6, $factorial) == 924);\n    assert(calculate_combinations(3, 1, $factorial) == 3);\n    assert(calculate_combinations(3, 2, $factorial) == 3);\n    assert(calculate_combinations(7, 3, $factorial) == 35);\n    assert(calculate_combinations(7, 4, $factorial) == 35);\n}\n\ntestCombinations();", "all_code": "<?php\n// precompute_factorials generates an array of factorials from 0! to 12!.\n// This is because the maximum value of n is R + C - 2, where R and C can be up to 7, so 7 + 7 - 2 = 12.\nfunction precompute_factorials() {\n    $factorial = array_fill(0, 13, 1); // Initialize with 1 (0! = 1)\n    for ($i = 1; $i <= 12; $i++) {\n        $factorial[$i] = $factorial[$i - 1] * $i;\n    }\n    return $factorial;\n}\n\n// calculate_combinations computes the number of combinations (n choose k) using precomputed factorials.\n// The formula used is n! / (k! * (n - k)!).\nfunction calculate_combinations($n, $k, $factorial) {\n    return $factorial[$n] / ($factorial[$k] * $factorial[$n - $k]);\n}\nfunction testCombinations() {\n    $factorial = precompute_factorials();\n    \n    // Test cases with expected results\n    assert(calculate_combinations(0, 0, $factorial) == 1);\n    assert(calculate_combinations(2, 1, $factorial) == 2);\n    assert(calculate_combinations(4, 2, $factorial) == 6);\n    assert(calculate_combinations(6, 3, $factorial) == 20);\n    assert(calculate_combinations(8, 4, $factorial) == 70);\n    assert(calculate_combinations(10, 5, $factorial) == 252);\n    assert(calculate_combinations(12, 6, $factorial) == 924);\n    assert(calculate_combinations(3, 1, $factorial) == 3);\n    assert(calculate_combinations(3, 2, $factorial) == 3);\n    assert(calculate_combinations(7, 3, $factorial) == 35);\n    assert(calculate_combinations(7, 4, $factorial) == 35);\n}\n\ntestCombinations();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// max_drinks calculates the maximum number of drinks that can be obtained with given parameters.\n// It considers two scenarios: normal purchase and promotional purchase.\n// - Normal purchase: Each drink costs 'a' units.\n// - Promotional purchase: Buy 'b' units to get 'c' units back (effectively costing 'b - c' units per drink after the first purchase).\n// The function returns the maximum number of drinks that can be obtained with 'n' units.\nfunction max_drinks($n, $a, $b, $c) {\n    $normal = intdiv($n, $a);\n    if ($n < $b) {\n        $promo = 0;\n    } else {\n        $promo = 1 + intdiv($n - $b, $b - $c);\n    }\n    return max($normal, $promo);\n}\n?>", "test_cases": "", "test_case_results": "Input: n = 10, a = 11, b = 9, c = 8\nMax drinks: 2\nInput: n = 10, a = 5, b = 6, c = 1\nMax drinks: 2", "task_id": 10873, "assertions": "<?php\n\nfunction testMaxDrinks() {\n    assert(max_drinks(10, 11, 9, 8) === 2);\n    assert(max_drinks(10, 5, 6, 1) === 2);\n}\n\ntestMaxDrinks();\n?>", "all_code": "<?php\n// max_drinks calculates the maximum number of drinks that can be obtained with given parameters.\n// It considers two scenarios: normal purchase and promotional purchase.\n// - Normal purchase: Each drink costs 'a' units.\n// - Promotional purchase: Buy 'b' units to get 'c' units back (effectively costing 'b - c' units per drink after the first purchase).\n// The function returns the maximum number of drinks that can be obtained with 'n' units.\nfunction max_drinks($n, $a, $b, $c) {\n    $normal = intdiv($n, $a);\n    if ($n < $b) {\n        $promo = 0;\n    } else {\n        $promo = 1 + intdiv($n - $b, $b - $c);\n    }\n    return max($normal, $promo);\n}\nfunction testMaxDrinks() {\n    assert(max_drinks(10, 11, 9, 8) === 2);\n    assert(max_drinks(10, 5, 6, 1) === 2);\n}\n\ntestMaxDrinks();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// find_first_unique_cafe finds the first unique cafe in a list of cafe visits.\n// A cafe is considered unique if it appears only once in the list.\n// The function returns the first unique cafe encountered in the list.\n// If no unique cafe is found, it returns -1.\nfunction find_first_unique_cafe($cafes) {\n    $last_occurrence = [];\n    \n    // Record the last occurrence index of each cafe\n    foreach ($cafes as $idx => $cafe) {\n        $last_occurrence[$cafe] = $idx;\n    }\n    \n    $min_index = PHP_INT_MAX;\n    $result = -1;\n    \n    // Find the cafe with the smallest last occurrence index\n    foreach ($last_occurrence as $cafe => $idx) {\n        if ($idx < $min_index) {\n            $min_index = $idx;\n            $result = $cafe;\n        }\n    }\n    \n    return $result;\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nFirst unique cafe: 1\nInput: [5, 6, 7, 5]\nFirst unique cafe: 6\nInput: [0, 0, 0, 0]\nFirst unique cafe: 0\nInput: [8, 8, 9, 10, 9, 10]\nFirst unique cafe: 8\nInput: [3, 4, 5, 3, 4, 5, 6]\nFirst unique cafe: 3", "task_id": 6988, "assertions": "<?php\n\nfunction testFindFirstUniqueCafe() {\n    assert(find_first_unique_cafe([1, 2, 3, 4]) === 1);\n    assert(find_first_unique_cafe([5, 6, 7, 5]) === 6);\n    assert(find_first_unique_cafe([0, 0, 0, 0]) === 0);\n    assert(find_first_unique_cafe([8, 8, 9, 10, 9, 10]) === 8);\n    assert(find_first_unique_cafe([3, 4, 5, 3, 4, 5, 6]) === 3);\n}\n\ntestFindFirstUniqueCafe();", "all_code": "<?php\n// find_first_unique_cafe finds the first unique cafe in a list of cafe visits.\n// A cafe is considered unique if it appears only once in the list.\n// The function returns the first unique cafe encountered in the list.\n// If no unique cafe is found, it returns -1.\nfunction find_first_unique_cafe($cafes) {\n    $last_occurrence = [];\n    \n    // Record the last occurrence index of each cafe\n    foreach ($cafes as $idx => $cafe) {\n        $last_occurrence[$cafe] = $idx;\n    }\n    \n    $min_index = PHP_INT_MAX;\n    $result = -1;\n    \n    // Find the cafe with the smallest last occurrence index\n    foreach ($last_occurrence as $cafe => $idx) {\n        if ($idx < $min_index) {\n            $min_index = $idx;\n            $result = $cafe;\n        }\n    }\n    \n    return $result;\n}\nfunction testFindFirstUniqueCafe() {\n    assert(find_first_unique_cafe([1, 2, 3, 4]) === 1);\n    assert(find_first_unique_cafe([5, 6, 7, 5]) === 6);\n    assert(find_first_unique_cafe([0, 0, 0, 0]) === 0);\n    assert(find_first_unique_cafe([8, 8, 9, 10, 9, 10]) === 8);\n    assert(find_first_unique_cafe([3, 4, 5, 3, 4, 5, 6]) === 3);\n}\n\ntestFindFirstUniqueCafe();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n/**\n * Finds the length of the shortest continuous subarray that, if sorted in ascending order,\n * would result in the entire array being sorted in ascending order.\n *\n * @param array $nums A list of integers\n * @return int The length of the shortest such subarray\n */\nfunction find_unsorted_subarray($nums) {\n    $n = count($nums);\n    \n    $start = 0;\n    $end = -1;\n    $max_seen = PHP_INT_MIN;\n    $min_seen = PHP_INT_MAX;\n    \n    // Traverse from left to right to find the end of the unsorted subarray\n    for ($i = 0; $i < $n; $i++) {\n        $max_seen = max($max_seen, $nums[$i]);\n        if ($nums[$i] < $max_seen) {\n            $end = $i;\n        }\n    }\n    \n    // Traverse from right to left to find the start of the unsorted subarray\n    for ($i = $n - 1; $i >= 0; $i--) {\n        $min_seen = min($min_seen, $nums[$i]);\n        if ($nums[$i] > $min_seen) {\n            $start = $i;\n        }\n    }\n    \n    return $end - $start + 1;\n}", "test_cases": "", "test_case_results": "Input: [2, 6, 4, 8, 10, 9, 15]\nLength of shortest unsorted subarray: 5\nInput: [1, 2, 3, 4]\nLength of shortest unsorted subarray: 0\nInput: [1, 3, 2, 2, 2]\nLength of shortest unsorted subarray: 4\nInput: [5, 4, 3, 2, 1]\nLength of shortest unsorted subarray: 5\nInput: [1]\nLength of shortest unsorted subarray: 0\nInput: []\nLength of shortest unsorted subarray: 0", "task_id": 27482, "assertions": "<?php\n\nfunction testFindUnsortedSubarray() {\n    assert(find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) === 5);\n    assert(find_unsorted_subarray([1, 2, 3, 4]) === 0);\n    assert(find_unsorted_subarray([1, 3, 2, 2, 2]) === 4);\n    assert(find_unsorted_subarray([5, 4, 3, 2, 1]) === 5);\n    assert(find_unsorted_subarray([1]) === 0);\n    assert(find_unsorted_subarray([]) === 0);\n    echo \"All tests passed!\";\n}\n\ntestFindUnsortedSubarray();", "all_code": "<?php\n/**\n * Finds the length of the shortest continuous subarray that, if sorted in ascending order,\n * would result in the entire array being sorted in ascending order.\n *\n * @param array $nums A list of integers\n * @return int The length of the shortest such subarray\n */\nfunction find_unsorted_subarray($nums) {\n    $n = count($nums);\n    \n    $start = 0;\n    $end = -1;\n    $max_seen = PHP_INT_MIN;\n    $min_seen = PHP_INT_MAX;\n    \n    // Traverse from left to right to find the end of the unsorted subarray\n    for ($i = 0; $i < $n; $i++) {\n        $max_seen = max($max_seen, $nums[$i]);\n        if ($nums[$i] < $max_seen) {\n            $end = $i;\n        }\n    }\n    \n    // Traverse from right to left to find the start of the unsorted subarray\n    for ($i = $n - 1; $i >= 0; $i--) {\n        $min_seen = min($min_seen, $nums[$i]);\n        if ($nums[$i] > $min_seen) {\n            $start = $i;\n        }\n    }\n    \n    return $end - $start + 1;\n}\nfunction testFindUnsortedSubarray() {\n    assert(find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) === 5);\n    assert(find_unsorted_subarray([1, 2, 3, 4]) === 0);\n    assert(find_unsorted_subarray([1, 3, 2, 2, 2]) === 4);\n    assert(find_unsorted_subarray([5, 4, 3, 2, 1]) === 5);\n    assert(find_unsorted_subarray([1]) === 0);\n    assert(find_unsorted_subarray([]) === 0);\n    echo \"All tests passed!\";\n}\n\ntestFindUnsortedSubarray();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// sum_of_distinct_integers calculates the sum of all distinct integers after removing adjacent equal integers in pairs.\n// It uses a stack to process the input array, removing adjacent duplicates and then summing the remaining distinct integers.\nfunction sum_of_distinct_integers($arr) {\n    $stack = array();\n    foreach ($arr as $num) {\n        if (!empty($stack) && end($stack) == $num) {\n            array_pop($stack);\n        } else {\n            array_push($stack, $num);\n        }\n    }\n    $unique_numbers = array_unique($stack);\n    return array_sum($unique_numbers);\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 2, 2, 3, 4, 4, 5]\nSum of distinct integers: 9\nInput: [5, 5, 6, 6, 7, 7, 7]\nSum of distinct integers: 7\nInput: [1, 1, 2, 2, 3, 3, 3]\nSum of distinct integers: 3\nInput: [0, 0, 0, 0, 0]\nSum of distinct integers: 0\nInput: [1, 2, 3, 4, 5]\nSum of distinct integers: 15", "task_id": 21618, "assertions": "<?php\n\nfunction testSumOfDistinctIntegers() {\n    assert(sum_of_distinct_integers([1, 2, 2, 3, 4, 4, 5]) === 9);\n    assert(sum_of_distinct_integers([5, 5, 6, 6, 7, 7, 7]) === 7);\n    assert(sum_of_distinct_integers([1, 1, 2, 2, 3, 3, 3]) === 3);\n    assert(sum_of_distinct_integers([0, 0, 0, 0, 0]) === 0);\n    assert(sum_of_distinct_integers([1, 2, 3, 4, 5]) === 15);\n}\n\ntestSumOfDistinctIntegers();\n?>", "all_code": "<?php\n// sum_of_distinct_integers calculates the sum of all distinct integers after removing adjacent equal integers in pairs.\n// It uses a stack to process the input array, removing adjacent duplicates and then summing the remaining distinct integers.\nfunction sum_of_distinct_integers($arr) {\n    $stack = array();\n    foreach ($arr as $num) {\n        if (!empty($stack) && end($stack) == $num) {\n            array_pop($stack);\n        } else {\n            array_push($stack, $num);\n        }\n    }\n    $unique_numbers = array_unique($stack);\n    return array_sum($unique_numbers);\n}\nfunction testSumOfDistinctIntegers() {\n    assert(sum_of_distinct_integers([1, 2, 2, 3, 4, 4, 5]) === 9);\n    assert(sum_of_distinct_integers([5, 5, 6, 6, 7, 7, 7]) === 7);\n    assert(sum_of_distinct_integers([1, 1, 2, 2, 3, 3, 3]) === 3);\n    assert(sum_of_distinct_integers([0, 0, 0, 0, 0]) === 0);\n    assert(sum_of_distinct_integers([1, 2, 3, 4, 5]) === 15);\n}\n\ntestSumOfDistinctIntegers();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_ternary_numbers_divisible_by_3 calculates the number of n-digit ternary numbers\n// (using digits 0, 1, 2) where the sum of digits is divisible by 3.\n// The function uses dynamic programming to efficiently compute the result.\nfunction count_ternary_numbers_divisible_by_3($n) {\n    // Handle edge case where n is 0 (though problem states n >= 1)\n    if ($n == 0) {\n        return 0;\n    }\n\n    // Initialize DP table: dp[pos][mod] is the count at position pos with sum mod 3\n    $dp = array_fill(0, $n, array_fill(0, 3, 0));\n\n    // First position (0-based) can only be 1 or 2 (can't start with 0 for n-digit number)\n    $dp[0][1] = 1;\n    $dp[0][2] = 1;\n\n    // Fill DP table for positions 1 to n-1 (0-based)\n    for ($pos = 1; $pos < $n; $pos++) {\n        for ($prev_mod = 0; $prev_mod < 3; $prev_mod++) {\n            foreach ([0, 1, 2] as $digit) {\n                $new_mod = ($prev_mod + $digit) % 3;\n                $dp[$pos][$new_mod] += $dp[$pos - 1][$prev_mod];\n            }\n        }\n    }\n\n    // The answer is the count of numbers with sum mod 3 == 0 at the last position\n    return $dp[$n - 1][0];\n}\n?>", "test_cases": "", "test_case_results": "Input (n = 1): 0\nInput (n = 2): 2\nInput (n = 3): 6\nInput (n = 4): 18\nInput (n = 5): 54", "task_id": 7733, "assertions": "<?php\n\nfunction testCountTernaryNumbersDivisibleBy3() {\n    assert(count_ternary_numbers_divisible_by_3(1) === 0);\n    assert(count_ternary_numbers_divisible_by_3(2) === 2);\n    assert(count_ternary_numbers_divisible_by_3(3) === 6);\n    assert(count_ternary_numbers_divisible_by_3(4) === 18);\n    assert(count_ternary_numbers_divisible_by_3(5) === 54);\n}\n\ntestCountTernaryNumbersDivisibleBy3();", "all_code": "<?php\n// count_ternary_numbers_divisible_by_3 calculates the number of n-digit ternary numbers\n// (using digits 0, 1, 2) where the sum of digits is divisible by 3.\n// The function uses dynamic programming to efficiently compute the result.\nfunction count_ternary_numbers_divisible_by_3($n) {\n    // Handle edge case where n is 0 (though problem states n >= 1)\n    if ($n == 0) {\n        return 0;\n    }\n\n    // Initialize DP table: dp[pos][mod] is the count at position pos with sum mod 3\n    $dp = array_fill(0, $n, array_fill(0, 3, 0));\n\n    // First position (0-based) can only be 1 or 2 (can't start with 0 for n-digit number)\n    $dp[0][1] = 1;\n    $dp[0][2] = 1;\n\n    // Fill DP table for positions 1 to n-1 (0-based)\n    for ($pos = 1; $pos < $n; $pos++) {\n        for ($prev_mod = 0; $prev_mod < 3; $prev_mod++) {\n            foreach ([0, 1, 2] as $digit) {\n                $new_mod = ($prev_mod + $digit) % 3;\n                $dp[$pos][$new_mod] += $dp[$pos - 1][$prev_mod];\n            }\n        }\n    }\n\n    // The answer is the count of numbers with sum mod 3 == 0 at the last position\n    return $dp[$n - 1][0];\n}\nfunction testCountTernaryNumbersDivisibleBy3() {\n    assert(count_ternary_numbers_divisible_by_3(1) === 0);\n    assert(count_ternary_numbers_divisible_by_3(2) === 2);\n    assert(count_ternary_numbers_divisible_by_3(3) === 6);\n    assert(count_ternary_numbers_divisible_by_3(4) === 18);\n    assert(count_ternary_numbers_divisible_by_3(5) === 54);\n}\n\ntestCountTernaryNumbersDivisibleBy3();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// reverse_words_and_preserve reverses the order of characters in the input string while preserving the original characters.\n// This function effectively reverses the entire string, including spaces and punctuation.\nfunction reverse_words_and_preserve($input_string) {\n    return strrev($input_string);\n}\n?>", "test_cases": "", "test_case_results": "Input: \"Hello, world!\"\nReversed: \"!dlrow ,olleH\"\nInput: \"This is a test.\"\nReversed: \".tset a si sihT\"\nInput: \"123 456 789\"\nReversed: \"987 654 321\"\nInput: \" Spaces  and   punctuation! \"\nReversed: \" !noitautcnup   dna  secapS \"", "task_id": 381, "assertions": "<?php\nfunction testReverseWordsAndPreserve() {\n    assert(reverse_words_and_preserve(\"Hello, world!\") === \"!dlrow ,olleH\");\n    assert(reverse_words_and_preserve(\"This is a test.\") === \".tset a si sihT\");\n    assert(reverse_words_and_preserve(\"123 456 789\") === \"987 654 321\");\n    assert(reverse_words_and_preserve(\" Spaces  and   punctuation! \") === \" !noitautcnup   dna  secapS \");\n}\n\ntestReverseWordsAndPreserve();\n?>", "all_code": "<?php\n// reverse_words_and_preserve reverses the order of characters in the input string while preserving the original characters.\n// This function effectively reverses the entire string, including spaces and punctuation.\nfunction reverse_words_and_preserve($input_string) {\n    return strrev($input_string);\n}\nfunction testReverseWordsAndPreserve() {\n    assert(reverse_words_and_preserve(\"Hello, world!\") === \"!dlrow ,olleH\");\n    assert(reverse_words_and_preserve(\"This is a test.\") === \".tset a si sihT\");\n    assert(reverse_words_and_preserve(\"123 456 789\") === \"987 654 321\");\n    assert(reverse_words_and_preserve(\" Spaces  and   punctuation! \") === \" !noitautcnup   dna  secapS \");\n}\n\ntestReverseWordsAndPreserve();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// process_operations processes a series of operations on a current value and tracks distressed cases.\n// The function takes an initial value and an array of operations (each operation is an array with an operator and a value).\n// It returns the final current value and the count of distressed cases.\nfunction process_operations($initial_value, $operations) {\n    $current = $initial_value;\n    $distressed = 0;\n\n    foreach ($operations as $op) {\n        $operator = $op[0];\n        $value = $op[1];\n\n        if ($operator == '+') {\n            $current += $value;\n        } else {\n            if ($current >= $value) {\n                $current -= $value;\n            } else {\n                $distressed++;\n            }\n        }\n    }\n\n    return [$current, $distressed];\n}\n?>", "test_cases": "", "test_case_results": "Initial Value: 100\nOperations: +50 -75 -100 +25 -50 \nFinal Value: 50, Distressed Cases: 1\n\nInitial Value: 50\nOperations: -60 +20 -10 -5 \nFinal Value: 55, Distressed Cases: 1\n\nInitial Value: 200\nOperations: +100 -50 -300 +150 \nFinal Value: 400, Distressed Cases: 1", "task_id": 5850, "assertions": "<?php\n\nfunction testProcessOperations() {\n    // Test case 1\n    $result1 = process_operations(100, [['+', 50], ['-', 75], ['-', 100], ['+', 25], ['-', 50]]);\n    assert($result1[0] === 50 && $result1[1] === 1);\n\n    // Test case 2\n    $result2 = process_operations(50, [['-', 60], ['+', 20], ['-', 10], ['-', 5]]);\n    assert($result2[0] === 55 && $result2[1] === 1);\n\n    // Test case 3\n    $result3 = process_operations(200, [['+', 100], ['-', 50], ['-', 300], ['+', 150]]);\n    assert($result3[0] === 400 && $result3[1] === 1);\n}\n\ntestProcessOperations();\n?>", "all_code": "<?php\n// process_operations processes a series of operations on a current value and tracks distressed cases.\n// The function takes an initial value and an array of operations (each operation is an array with an operator and a value).\n// It returns the final current value and the count of distressed cases.\nfunction process_operations($initial_value, $operations) {\n    $current = $initial_value;\n    $distressed = 0;\n\n    foreach ($operations as $op) {\n        $operator = $op[0];\n        $value = $op[1];\n\n        if ($operator == '+') {\n            $current += $value;\n        } else {\n            if ($current >= $value) {\n                $current -= $value;\n            } else {\n                $distressed++;\n            }\n        }\n    }\n\n    return [$current, $distressed];\n}\nfunction testProcessOperations() {\n    // Test case 1\n    $result1 = process_operations(100, [['+', 50], ['-', 75], ['-', 100], ['+', 25], ['-', 50]]);\n    assert($result1[0] === 50 && $result1[1] === 1);\n\n    // Test case 2\n    $result2 = process_operations(50, [['-', 60], ['+', 20], ['-', 10], ['-', 5]]);\n    assert($result2[0] === 55 && $result2[1] === 1);\n\n    // Test case 3\n    $result3 = process_operations(200, [['+', 100], ['-', 50], ['-', 300], ['+', 150]]);\n    assert($result3[0] === 400 && $result3[1] === 1);\n}\n\ntestProcessOperations();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// compute_mod calculates the modulus of a given value 'a' with 'm'.\n// If 'm' is 0, it returns 0 as modulus is undefined in this case.\nfunction compute_mod($a, $m) {\n    return $m != 0 ? $a % $m : 0;\n}", "test_cases": "", "test_case_results": "Case 1: 2\nCase 2: 0\nCase 3: 0\nCase 4: 1\nCase 5: 1", "task_id": 12590, "assertions": "<?php\n\nfunction testComputeMod() {\n    // Test case 1: Normal modulus calculation\n    assert(compute_mod(2, 3) === 2);\n    \n    // Test case 2: Modulus with m=0\n    assert(compute_mod(0, 0) === 0);\n    \n    // Test case 3: Modulus with m=0 (different a value)\n    assert(compute_mod(5, 0) === 0);\n    \n    // Test case 4: Normal modulus calculation\n    assert(compute_mod(3, 2) === 1);\n    \n    // Test case 5: Normal modulus calculation with N=0 case\n    assert(compute_mod(1, 5) === 1);\n}\n\ntestComputeMod();", "all_code": "<?php\n// compute_mod calculates the modulus of a given value 'a' with 'm'.\n// If 'm' is 0, it returns 0 as modulus is undefined in this case.\nfunction compute_mod($a, $m) {\n    return $m != 0 ? $a % $m : 0;\n}\nfunction testComputeMod() {\n    // Test case 1: Normal modulus calculation\n    assert(compute_mod(2, 3) === 2);\n    \n    // Test case 2: Modulus with m=0\n    assert(compute_mod(0, 0) === 0);\n    \n    // Test case 3: Modulus with m=0 (different a value)\n    assert(compute_mod(5, 0) === 0);\n    \n    // Test case 4: Normal modulus calculation\n    assert(compute_mod(3, 2) === 1);\n    \n    // Test case 5: Normal modulus calculation with N=0 case\n    assert(compute_mod(1, 5) === 1);\n}\n\ntestComputeMod();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// calculate_sequence_count calculates the number of elements in a sequence from start to end\n// that follow a specific pattern (x = multiple * 5 + 1).\n// If the start is greater than the end, it returns 0.\nfunction calculate_sequence_count($start, $end) {\n    if ($start > $end) {\n        return 0;\n    }\n    $numerator = ($start - 1) + 4;\n    $multiple = intdiv($numerator, 5);\n    $x = $multiple * 5 + 1;\n    if ($x > $end) {\n        return 0;\n    }\n    $count = intdiv(($end - $x), 5) + 1;\n    return $count;\n}", "test_cases": "", "test_case_results": "Input: N = 10, K = 5\nCount: 1\nInput: N = 15, K = 10\nCount: 1\nInput: N = 5, K = 10\nCount: 0\nInput: N = 20, K = 3\nCount: 3\nInput: N = 25, K = 20\nCount: 1", "task_id": 3518, "assertions": "<?php\n\nfunction testCalculateSequenceCount() {\n    assert(calculate_sequence_count(6, 10) === 1);\n    assert(calculate_sequence_count(11, 15) === 1);\n    assert(calculate_sequence_count(11, 5) === 0);\n    assert(calculate_sequence_count(4, 20) === 3);\n    assert(calculate_sequence_count(21, 25) === 1);\n}\n\ntestCalculateSequenceCount();", "all_code": "<?php\n// calculate_sequence_count calculates the number of elements in a sequence from start to end\n// that follow a specific pattern (x = multiple * 5 + 1).\n// If the start is greater than the end, it returns 0.\nfunction calculate_sequence_count($start, $end) {\n    if ($start > $end) {\n        return 0;\n    }\n    $numerator = ($start - 1) + 4;\n    $multiple = intdiv($numerator, 5);\n    $x = $multiple * 5 + 1;\n    if ($x > $end) {\n        return 0;\n    }\n    $count = intdiv(($end - $x), 5) + 1;\n    return $count;\n}\nfunction testCalculateSequenceCount() {\n    assert(calculate_sequence_count(6, 10) === 1);\n    assert(calculate_sequence_count(11, 15) === 1);\n    assert(calculate_sequence_count(11, 5) === 0);\n    assert(calculate_sequence_count(4, 20) === 3);\n    assert(calculate_sequence_count(21, 25) === 1);\n}\n\ntestCalculateSequenceCount();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// determine_pattern determines the output value based on the input number N.\n// If N is 1, it returns 2; otherwise, it returns 4.\nfunction determine_pattern($N) {\n    if ($N == 1) {\n        return 2;\n    } else {\n        return 4;\n    }\n}\n?>", "test_cases": "", "test_case_results": "Input: 1\nResult: 2\nInput: 2\nResult: 4\nInput: 3\nResult: 4\nInput: 5\nResult: 4\nInput: 10\nResult: 4", "task_id": 28402, "assertions": "<?php\n\nfunction testDeterminePattern() {\n    assert(determine_pattern(1) === 2);\n    assert(determine_pattern(2) === 4);\n    assert(determine_pattern(3) === 4);\n    assert(determine_pattern(5) === 4);\n    assert(determine_pattern(10) === 4);\n}\n\ntestDeterminePattern();\n?>", "all_code": "<?php\n// determine_pattern determines the output value based on the input number N.\n// If N is 1, it returns 2; otherwise, it returns 4.\nfunction determine_pattern($N) {\n    if ($N == 1) {\n        return 2;\n    } else {\n        return 4;\n    }\n}\nfunction testDeterminePattern() {\n    assert(determine_pattern(1) === 2);\n    assert(determine_pattern(2) === 4);\n    assert(determine_pattern(3) === 4);\n    assert(determine_pattern(5) === 4);\n    assert(determine_pattern(10) === 4);\n}\n\ntestDeterminePattern();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Converts a hexadecimal color code to an RGB tuple.\n *\n * @param string $hex_color The hexadecimal color code (e.g., \"#RRGGBB\").\n * @return array The RGB components as an array of integers.\n */\nfunction hex_to_rgb($hex_color) {\n    $red = hexdec(substr($hex_color, 1, 2));\n    $green = hexdec(substr($hex_color, 3, 2));\n    $blue = hexdec(substr($hex_color, 5, 2));\n    return [$red, $green, $blue];\n}\n\n/**\n * Converts an RGB tuple to a hexadecimal color code.\n *\n * @param array $rgb_color The RGB components as an array of integers.\n * @return string The hexadecimal color code (e.g., \"#RRGGBB\").\n */\nfunction rgb_to_hex($rgb_color) {\n    $hex_red = str_pad(dechex($rgb_color[0]), 2, '0', STR_PAD_LEFT);\n    $hex_green = str_pad(dechex($rgb_color[1]), 2, '0', STR_PAD_LEFT);\n    $hex_blue = str_pad(dechex($rgb_color[2]), 2, '0', STR_PAD_LEFT);\n    return \"#\" . $hex_red . $hex_green . $hex_blue;\n}\n\n/**\n * Combines two hexadecimal color codes by averaging their RGB components.\n *\n * @param string $c1 The first hexadecimal color code.\n * @param string $c2 The second hexadecimal color code.\n * @return string The combined hexadecimal color code.\n */\nfunction combine_hex_colors($c1, $c2) {\n    $rgb1 = hex_to_rgb($c1);\n    $rgb2 = hex_to_rgb($c2);\n    \n    $combined_rgb = [\n        ($rgb1[0] + $rgb2[0]) / 2,\n        ($rgb1[1] + $rgb2[1]) / 2,\n        ($rgb1[2] + $rgb2[2]) / 2\n    ];\n    \n    return rgb_to_hex($combined_rgb);\n}\n\n/**\n * Processes a list of color pairs and combines them.\n *\n * @param array $input_list An array of strings, each containing two hexadecimal color codes separated by a space.\n * @return array An array of combined hexadecimal color codes.\n */\nfunction process_color_combinations($input_list) {\n    $results = [];\n    foreach ($input_list as $colors) {\n        if ($colors == \"0 0\") {\n            break;\n        }\n        \n        list($c1, $c2) = explode(' ', $colors);\n        $result_color = combine_hex_colors($c1, $c2);\n        $results[] = $result_color;\n    }\n    \n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Input: #FF0000 #00FF00\nCombined Color: #7f7f00\nInput: #0000FF #FFFF00\nCombined Color: #7f7f7f\nInput: #FFFFFF #000000\nCombined Color: #7f7f7f\nInput: #123456 #789ABC\nCombined Color: #456789\nInput: 0 0\nTermination case encountered.", "task_id": 7982, "assertions": "<?php\n\nfunction testColorCombinations() {\n    assert(combine_hex_colors(\"#FF0000\", \"#00FF00\") === \"#7f7f00\");\n    assert(combine_hex_colors(\"#0000FF\", \"#FFFF00\") === \"#7f7f7f\");\n    assert(combine_hex_colors(\"#FFFFFF\", \"#000000\") === \"#7f7f7f\");\n    assert(combine_hex_colors(\"#123456\", \"#789ABC\") === \"#456789\");\n    \n    $test_input = [\"#FF0000 #00FF00\", \"0 0\"];\n    $test_output = process_color_combinations($test_input);\n    assert($test_output === [\"#7f7f00\"]);\n    \n    $termination_test = [\"0 0\"];\n    $termination_output = process_color_combinations($termination_test);\n    assert($termination_output === []);\n}\n\ntestColorCombinations();\n?>", "all_code": "<?php\n/**\n * Converts a hexadecimal color code to an RGB tuple.\n *\n * @param string $hex_color The hexadecimal color code (e.g., \"#RRGGBB\").\n * @return array The RGB components as an array of integers.\n */\nfunction hex_to_rgb($hex_color) {\n    $red = hexdec(substr($hex_color, 1, 2));\n    $green = hexdec(substr($hex_color, 3, 2));\n    $blue = hexdec(substr($hex_color, 5, 2));\n    return [$red, $green, $blue];\n}\n\n/**\n * Converts an RGB tuple to a hexadecimal color code.\n *\n * @param array $rgb_color The RGB components as an array of integers.\n * @return string The hexadecimal color code (e.g., \"#RRGGBB\").\n */\nfunction rgb_to_hex($rgb_color) {\n    $hex_red = str_pad(dechex($rgb_color[0]), 2, '0', STR_PAD_LEFT);\n    $hex_green = str_pad(dechex($rgb_color[1]), 2, '0', STR_PAD_LEFT);\n    $hex_blue = str_pad(dechex($rgb_color[2]), 2, '0', STR_PAD_LEFT);\n    return \"#\" . $hex_red . $hex_green . $hex_blue;\n}\n\n/**\n * Combines two hexadecimal color codes by averaging their RGB components.\n *\n * @param string $c1 The first hexadecimal color code.\n * @param string $c2 The second hexadecimal color code.\n * @return string The combined hexadecimal color code.\n */\nfunction combine_hex_colors($c1, $c2) {\n    $rgb1 = hex_to_rgb($c1);\n    $rgb2 = hex_to_rgb($c2);\n    \n    $combined_rgb = [\n        ($rgb1[0] + $rgb2[0]) / 2,\n        ($rgb1[1] + $rgb2[1]) / 2,\n        ($rgb1[2] + $rgb2[2]) / 2\n    ];\n    \n    return rgb_to_hex($combined_rgb);\n}\n\n/**\n * Processes a list of color pairs and combines them.\n *\n * @param array $input_list An array of strings, each containing two hexadecimal color codes separated by a space.\n * @return array An array of combined hexadecimal color codes.\n */\nfunction process_color_combinations($input_list) {\n    $results = [];\n    foreach ($input_list as $colors) {\n        if ($colors == \"0 0\") {\n            break;\n        }\n        \n        list($c1, $c2) = explode(' ', $colors);\n        $result_color = combine_hex_colors($c1, $c2);\n        $results[] = $result_color;\n    }\n    \n    return $results;\n}\nfunction testColorCombinations() {\n    assert(combine_hex_colors(\"#FF0000\", \"#00FF00\") === \"#7f7f00\");\n    assert(combine_hex_colors(\"#0000FF\", \"#FFFF00\") === \"#7f7f7f\");\n    assert(combine_hex_colors(\"#FFFFFF\", \"#000000\") === \"#7f7f7f\");\n    assert(combine_hex_colors(\"#123456\", \"#789ABC\") === \"#456789\");\n    \n    $test_input = [\"#FF0000 #00FF00\", \"0 0\"];\n    $test_output = process_color_combinations($test_input);\n    assert($test_output === [\"#7f7f00\"]);\n    \n    $termination_test = [\"0 0\"];\n    $termination_output = process_color_combinations($termination_test);\n    assert($termination_output === []);\n}\n\ntestColorCombinations();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Class DisjointSet represents a disjoint-set data structure (also known as union-find).\n * It supports two operations: finding the root of a set, and merging two sets.\n */\nclass DisjointSet {\n    private $parent;\n    private $rank;\n\n    /**\n     * DisjointSet constructor.\n     * @param int $n The number of elements in the disjoint-set.\n     */\n    public function __construct($n) {\n        $this->parent = range(0, $n - 1);\n        $this->rank = array_fill(0, $n, 1);\n    }\n\n    /**\n     * Finds the root of the set containing element $u.\n     * Implements path compression for efficiency.\n     * @param int $u The element to find.\n     * @return int The root of the set containing $u.\n     */\n    public function find($u) {\n        if ($this->parent[$u] != $u) {\n            $this->parent[$u] = $this->find($this->parent[$u]);\n        }\n        return $this->parent[$u];\n    }\n\n    /**\n     * Merges the sets containing elements $u and $v.\n     * Uses union by rank to keep the tree flat.\n     * @param int $u The first element.\n     * @param int $v The second element.\n     */\n    public function union($u, $v) {\n        $root_u = $this->find($u);\n        $root_v = $this->find($v);\n        if ($root_u != $root_v) {\n            if ($this->rank[$root_u] > $this->rank[$root_v]) {\n                $this->parent[$root_v] = $root_u;\n            } elseif ($this->rank[$root_u] < $this->rank[$root_v]) {\n                $this->parent[$root_u] = $root_v;\n            } else {\n                $this->parent[$root_v] = $root_u;\n                $this->rank[$root_u]++;\n            }\n        }\n    }\n}\n\n/**\n * Determines if villages can be connected within a given budget using Kruskal's algorithm.\n * @param int $N Number of villages.\n * @param int $M Number of roads.\n * @param int $Budget Maximum budget allowed.\n * @param array $roads Array of roads, where each road is represented as [u, v, length].\n * @return string \"YES\" if villages can be connected within budget, \"NO\" otherwise.\n */\nfunction can_connect_villages_within_budget($N, $M, $Budget, $roads) {\n    // Sort roads by length in ascending order\n    usort($roads, function($a, $b) {\n        return $a[2] - $b[2];\n    });\n\n    $ds = new DisjointSet($N);\n    $total_length = 0;\n\n    foreach ($roads as $road) {\n        $u = $road[0] - 1;\n        $v = $road[1] - 1;\n        $length = $road[2];\n\n        if ($ds->find($u) != $ds->find($v)) {\n            $ds->union($u, $v);\n            $total_length += $length;\n            if ($total_length > $Budget) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return $total_length <= $Budget ? \"YES\" : \"NO\";\n}\n?>", "test_cases": "", "test_case_results": "Test Case: Villages can be connected within budget\nN: 3, M: 3, Budget: 10\nRoads: [1, 2, 5] [2, 3, 4] [1, 3, 6] \nResult: YES\n\nTest Case: Villages cannot be connected within budget\nN: 4, M: 4, Budget: 10\nRoads: [1, 2, 3] [2, 3, 4] [3, 4, 5] [1, 4, 6] \nResult: NO\n\nTest Case: Only two villages with one road\nN: 2, M: 1, Budget: 100\nRoads: [1, 2, 50] \nResult: YES", "task_id": 24821, "assertions": "<?php\n\nfunction testCanConnectVillagesWithinBudget() {\n    // Test case 1: Villages can be connected within budget\n    assert(can_connect_villages_within_budget(3, 3, 10, [\n        [1, 2, 5],\n        [2, 3, 4],\n        [1, 3, 6]\n    ]) === \"YES\");\n\n    // Test case 2: Villages cannot be connected within budget\n    assert(can_connect_villages_within_budget(4, 4, 10, [\n        [1, 2, 3],\n        [2, 3, 4],\n        [3, 4, 5],\n        [1, 4, 6]\n    ]) === \"NO\");\n\n    // Test case 3: Only two villages with one road\n    assert(can_connect_villages_within_budget(2, 1, 100, [\n        [1, 2, 50]\n    ]) === \"YES\");\n}\n\ntestCanConnectVillagesWithinBudget();\n?>", "all_code": "<?php\n/**\n * Class DisjointSet represents a disjoint-set data structure (also known as union-find).\n * It supports two operations: finding the root of a set, and merging two sets.\n */\nclass DisjointSet {\n    private $parent;\n    private $rank;\n\n    /**\n     * DisjointSet constructor.\n     * @param int $n The number of elements in the disjoint-set.\n     */\n    public function __construct($n) {\n        $this->parent = range(0, $n - 1);\n        $this->rank = array_fill(0, $n, 1);\n    }\n\n    /**\n     * Finds the root of the set containing element $u.\n     * Implements path compression for efficiency.\n     * @param int $u The element to find.\n     * @return int The root of the set containing $u.\n     */\n    public function find($u) {\n        if ($this->parent[$u] != $u) {\n            $this->parent[$u] = $this->find($this->parent[$u]);\n        }\n        return $this->parent[$u];\n    }\n\n    /**\n     * Merges the sets containing elements $u and $v.\n     * Uses union by rank to keep the tree flat.\n     * @param int $u The first element.\n     * @param int $v The second element.\n     */\n    public function union($u, $v) {\n        $root_u = $this->find($u);\n        $root_v = $this->find($v);\n        if ($root_u != $root_v) {\n            if ($this->rank[$root_u] > $this->rank[$root_v]) {\n                $this->parent[$root_v] = $root_u;\n            } elseif ($this->rank[$root_u] < $this->rank[$root_v]) {\n                $this->parent[$root_u] = $root_v;\n            } else {\n                $this->parent[$root_v] = $root_u;\n                $this->rank[$root_u]++;\n            }\n        }\n    }\n}\n\n/**\n * Determines if villages can be connected within a given budget using Kruskal's algorithm.\n * @param int $N Number of villages.\n * @param int $M Number of roads.\n * @param int $Budget Maximum budget allowed.\n * @param array $roads Array of roads, where each road is represented as [u, v, length].\n * @return string \"YES\" if villages can be connected within budget, \"NO\" otherwise.\n */\nfunction can_connect_villages_within_budget($N, $M, $Budget, $roads) {\n    // Sort roads by length in ascending order\n    usort($roads, function($a, $b) {\n        return $a[2] - $b[2];\n    });\n\n    $ds = new DisjointSet($N);\n    $total_length = 0;\n\n    foreach ($roads as $road) {\n        $u = $road[0] - 1;\n        $v = $road[1] - 1;\n        $length = $road[2];\n\n        if ($ds->find($u) != $ds->find($v)) {\n            $ds->union($u, $v);\n            $total_length += $length;\n            if ($total_length > $Budget) {\n                return \"NO\";\n            }\n        }\n    }\n\n    return $total_length <= $Budget ? \"YES\" : \"NO\";\n}\nfunction testCanConnectVillagesWithinBudget() {\n    // Test case 1: Villages can be connected within budget\n    assert(can_connect_villages_within_budget(3, 3, 10, [\n        [1, 2, 5],\n        [2, 3, 4],\n        [1, 3, 6]\n    ]) === \"YES\");\n\n    // Test case 2: Villages cannot be connected within budget\n    assert(can_connect_villages_within_budget(4, 4, 10, [\n        [1, 2, 3],\n        [2, 3, 4],\n        [3, 4, 5],\n        [1, 4, 6]\n    ]) === \"NO\");\n\n    // Test case 3: Only two villages with one road\n    assert(can_connect_villages_within_budget(2, 1, 100, [\n        [1, 2, 50]\n    ]) === \"YES\");\n}\n\ntestCanConnectVillagesWithinBudget();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_linear_params calculates the parameters (b1 and d) of a linear model\n// given an array of numbers. The model is assumed to be of the form a_i = b1 + d * i.\n// The function returns an array containing b1 and d.\nfunction calculate_linear_params($a) {\n    $n = count($a);\n    if ($n == 0) {\n        return [0.0, 0.0];\n    }\n\n    $sum_a = array_sum($a);\n    $sum_ia = 0;\n    foreach ($a as $i => $x) {\n        $sum_ia += $i * $x;\n    }\n\n    $S = $n * ($n - 1) / 2.0;\n    $S2 = ($n - 1) * $n * (2 * $n - 1) / 6.0;\n\n    $numerator_d = $sum_ia * $n - $sum_a * $S;\n    $denominator = $n * $S2 - $S * $S;\n    $d = $numerator_d / $denominator;\n\n    $b1 = ($sum_a - $S * $d) / $n;\n\n    return [$b1, $d];\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nb1: 1.0000000000, d: 1.0000000000\nInput: [5, 6, 7, 8]\nb1: 5.0000000000, d: 1.0000000000\nInput: [0, 0, 0, 0]\nb1: 0.0000000000, d: 0.0000000000\nInput: [1, 3, 5, 7]\nb1: 1.0000000000, d: 2.0000000000", "task_id": 6327, "assertions": "<?php\n\nfunction testCalculateLinearParams() {\n    // Test case 1: Simple linear sequence\n    list($b1, $d) = calculate_linear_params([1, 2, 3, 4]);\n    assert(abs($b1 - 1.0) < 0.000001);\n    assert(abs($d - 1.0) < 0.000001);\n\n    // Test case 2: Another linear sequence\n    list($b1, $d) = calculate_linear_params([5, 6, 7, 8]);\n    assert(abs($b1 - 5.0) < 0.000001);\n    assert(abs($d - 1.0) < 0.000001);\n\n    // Test case 3: All zeros\n    list($b1, $d) = calculate_linear_params([0, 0, 0, 0]);\n    assert(abs($b1 - 0.0) < 0.000001);\n    assert(abs($d - 0.0) < 0.000001);\n\n    // Test case 4: Sequence with a step of 2\n    list($b1, $d) = calculate_linear_params([1, 3, 5, 7]);\n    assert(abs($b1 - 1.0) < 0.000001);\n    assert(abs($d - 2.0) < 0.000001);\n}\n\ntestCalculateLinearParams();\n?>", "all_code": "<?php\n// calculate_linear_params calculates the parameters (b1 and d) of a linear model\n// given an array of numbers. The model is assumed to be of the form a_i = b1 + d * i.\n// The function returns an array containing b1 and d.\nfunction calculate_linear_params($a) {\n    $n = count($a);\n    if ($n == 0) {\n        return [0.0, 0.0];\n    }\n\n    $sum_a = array_sum($a);\n    $sum_ia = 0;\n    foreach ($a as $i => $x) {\n        $sum_ia += $i * $x;\n    }\n\n    $S = $n * ($n - 1) / 2.0;\n    $S2 = ($n - 1) * $n * (2 * $n - 1) / 6.0;\n\n    $numerator_d = $sum_ia * $n - $sum_a * $S;\n    $denominator = $n * $S2 - $S * $S;\n    $d = $numerator_d / $denominator;\n\n    $b1 = ($sum_a - $S * $d) / $n;\n\n    return [$b1, $d];\n}\nfunction testCalculateLinearParams() {\n    // Test case 1: Simple linear sequence\n    list($b1, $d) = calculate_linear_params([1, 2, 3, 4]);\n    assert(abs($b1 - 1.0) < 0.000001);\n    assert(abs($d - 1.0) < 0.000001);\n\n    // Test case 2: Another linear sequence\n    list($b1, $d) = calculate_linear_params([5, 6, 7, 8]);\n    assert(abs($b1 - 5.0) < 0.000001);\n    assert(abs($d - 1.0) < 0.000001);\n\n    // Test case 3: All zeros\n    list($b1, $d) = calculate_linear_params([0, 0, 0, 0]);\n    assert(abs($b1 - 0.0) < 0.000001);\n    assert(abs($d - 0.0) < 0.000001);\n\n    // Test case 4: Sequence with a step of 2\n    list($b1, $d) = calculate_linear_params([1, 3, 5, 7]);\n    assert(abs($b1 - 1.0) < 0.000001);\n    assert(abs($d - 2.0) < 0.000001);\n}\n\ntestCalculateLinearParams();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * group_strings groups an array of strings by their lowercase versions, ignoring non-alphanumeric characters.\n *\n * @param array $string_list List of strings to be grouped.\n * @return array A dictionary with lowercase keys and arrays of matching strings as values.\n */\nfunction group_strings($string_list) {\n    $grouped_dict = array();\n    \n    foreach ($string_list as $string) {\n        // Remove non-alphanumeric characters and convert to lowercase\n        $cleaned_string = preg_replace('/[^a-zA-Z0-9]/', '', $string);\n        $cleaned_string = strtolower($cleaned_string);\n        \n        if (!array_key_exists($cleaned_string, $grouped_dict)) {\n            $grouped_dict[$cleaned_string] = array();\n        }\n        array_push($grouped_dict[$cleaned_string], $string);\n    }\n    \n    return $grouped_dict;\n}\n?>", "test_cases": "", "test_case_results": "Input: [\"Hello\",\"hello\",\"HELLO\",\"h3llo\",\"h@llo\"]\nGrouped: {\"hello\":[\"Hello\",\"hello\",\"HELLO\"],\"h3llo\":[\"h3llo\"],\"hllo\":[\"h@llo\"]}\nInput: [\"Test1\",\"test1\",\"TEST1\",\"t e s t 1\"]\nGrouped: {\"test1\":[\"Test1\",\"test1\",\"TEST1\",\"t e s t 1\"]}\nInput: [\"abc123\",\"ABC123\",\"a b c 1 2 3\",\"a!b@c#1$2%3\"]\nGrouped: {\"abc123\":[\"abc123\",\"ABC123\",\"a b c 1 2 3\",\"a!b@c#1$2%3\"]}", "task_id": 7212, "assertions": "<?php\n\nfunction testGroupStrings() {\n    assert(group_strings([\"Hello\", \"hello\", \"HELLO\", \"h3llo\", \"h@llo\"]) === [\n        \"hello\" => [\"Hello\", \"hello\", \"HELLO\"],\n        \"h3llo\" => [\"h3llo\"],\n        \"hllo\" => [\"h@llo\"]\n    ]);\n    assert(group_strings([\"Test1\", \"test1\", \"TEST1\", \"t e s t 1\"]) === [\n        \"test1\" => [\"Test1\", \"test1\", \"TEST1\", \"t e s t 1\"]\n    ]);\n    assert(group_strings([\"abc123\", \"ABC123\", \"a b c 1 2 3\", \"a!b@c#1$2%3\"]) === [\n        \"abc123\" => [\"abc123\", \"ABC123\", \"a b c 1 2 3\", \"a!b@c#1$2%3\"]\n    ]);\n}\n\ntestGroupStrings();\n?>", "all_code": "<?php\n/**\n * group_strings groups an array of strings by their lowercase versions, ignoring non-alphanumeric characters.\n *\n * @param array $string_list List of strings to be grouped.\n * @return array A dictionary with lowercase keys and arrays of matching strings as values.\n */\nfunction group_strings($string_list) {\n    $grouped_dict = array();\n    \n    foreach ($string_list as $string) {\n        // Remove non-alphanumeric characters and convert to lowercase\n        $cleaned_string = preg_replace('/[^a-zA-Z0-9]/', '', $string);\n        $cleaned_string = strtolower($cleaned_string);\n        \n        if (!array_key_exists($cleaned_string, $grouped_dict)) {\n            $grouped_dict[$cleaned_string] = array();\n        }\n        array_push($grouped_dict[$cleaned_string], $string);\n    }\n    \n    return $grouped_dict;\n}\nfunction testGroupStrings() {\n    assert(group_strings([\"Hello\", \"hello\", \"HELLO\", \"h3llo\", \"h@llo\"]) === [\n        \"hello\" => [\"Hello\", \"hello\", \"HELLO\"],\n        \"h3llo\" => [\"h3llo\"],\n        \"hllo\" => [\"h@llo\"]\n    ]);\n    assert(group_strings([\"Test1\", \"test1\", \"TEST1\", \"t e s t 1\"]) === [\n        \"test1\" => [\"Test1\", \"test1\", \"TEST1\", \"t e s t 1\"]\n    ]);\n    assert(group_strings([\"abc123\", \"ABC123\", \"a b c 1 2 3\", \"a!b@c#1$2%3\"]) === [\n        \"abc123\" => [\"abc123\", \"ABC123\", \"a b c 1 2 3\", \"a!b@c#1$2%3\"]\n    ]);\n}\n\ntestGroupStrings();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines the ranks of teams based on the number of tasks solved.\n *\n * @param int $n Number of teams.\n * @param array $tasks Tasks solved by each team.\n * @return array The ranks of the teams.\n * @throws InvalidArgumentException If the number of tasks provided does not match the number of teams.\n */\nfunction determine_ranks($n, $tasks) {\n    if ($n != count($tasks)) {\n        throw new InvalidArgumentException(\"The number of tasks provided does not match the number of teams.\");\n    }\n    \n    // Create an array of tuples (tasks, original index) and sort in descending order\n    $sorted_tasks = array();\n    for ($i = 0; $i < $n; $i++) {\n        $sorted_tasks[] = array('tasks' => $tasks[$i], 'index' => $i);\n    }\n    \n    // Sort the array in descending order based on tasks\n    usort($sorted_tasks, function ($a, $b) {\n        return $b['tasks'] - $a['tasks'];\n    });\n    \n    $ranks = array_fill(0, $n, 0);\n    $current_rank = 1;\n    \n    for ($i = 0; $i < $n; $i++) {\n        if ($i > 0 && $sorted_tasks[$i]['tasks'] == $sorted_tasks[$i - 1]['tasks']) {\n            $ranks[$sorted_tasks[$i]['index']] = $ranks[$sorted_tasks[$i - 1]['index']];\n        } else {\n            $ranks[$sorted_tasks[$i]['index']] = $current_rank;\n        }\n        \n        $current_rank++;\n    }\n    \n    return $ranks;\n}\n?>", "test_cases": "", "test_case_results": "Input - Number of teams: 5, Tasks: [3, 5, 5, 1, 2]\nRanks: [3, 1, 1, 5, 4]\nInput - Number of teams: 4, Tasks: [1, 1, 1, 1]\nRanks: [1, 1, 1, 1]\nInput - Number of teams: 3, Tasks: [0, 0, 1]\nRanks: [2, 2, 1]\nInput - Number of teams: 1, Tasks: [10]\nRanks: [1]", "task_id": 22469, "assertions": "<?php\n\nfunction testDetermineRanks() {\n    // Test case 1: Teams with varying tasks\n    assert(determine_ranks(5, [3, 5, 5, 1, 2]) === [3, 1, 1, 5, 4]);\n    \n    // Test case 2: All teams have the same tasks\n    assert(determine_ranks(4, [1, 1, 1, 1]) === [1, 1, 1, 1]);\n    \n    // Test case 3: Some teams have zero tasks\n    assert(determine_ranks(3, [0, 0, 1]) === [2, 2, 1]);\n    \n    // Test case 4: Single team\n    assert(determine_ranks(1, [10]) === [1]);\n    \n    // Test case 5: Invalid argument (number of tasks doesn't match number of teams)\n    try {\n        determine_ranks(2, [1]);\n        assert(false); // This line should not be reached\n    } catch (InvalidArgumentException $e) {\n        assert(true); // Expected exception was thrown\n    }\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestDetermineRanks();\n?>", "all_code": "<?php\n/**\n * Determines the ranks of teams based on the number of tasks solved.\n *\n * @param int $n Number of teams.\n * @param array $tasks Tasks solved by each team.\n * @return array The ranks of the teams.\n * @throws InvalidArgumentException If the number of tasks provided does not match the number of teams.\n */\nfunction determine_ranks($n, $tasks) {\n    if ($n != count($tasks)) {\n        throw new InvalidArgumentException(\"The number of tasks provided does not match the number of teams.\");\n    }\n    \n    // Create an array of tuples (tasks, original index) and sort in descending order\n    $sorted_tasks = array();\n    for ($i = 0; $i < $n; $i++) {\n        $sorted_tasks[] = array('tasks' => $tasks[$i], 'index' => $i);\n    }\n    \n    // Sort the array in descending order based on tasks\n    usort($sorted_tasks, function ($a, $b) {\n        return $b['tasks'] - $a['tasks'];\n    });\n    \n    $ranks = array_fill(0, $n, 0);\n    $current_rank = 1;\n    \n    for ($i = 0; $i < $n; $i++) {\n        if ($i > 0 && $sorted_tasks[$i]['tasks'] == $sorted_tasks[$i - 1]['tasks']) {\n            $ranks[$sorted_tasks[$i]['index']] = $ranks[$sorted_tasks[$i - 1]['index']];\n        } else {\n            $ranks[$sorted_tasks[$i]['index']] = $current_rank;\n        }\n        \n        $current_rank++;\n    }\n    \n    return $ranks;\n}\nfunction testDetermineRanks() {\n    // Test case 1: Teams with varying tasks\n    assert(determine_ranks(5, [3, 5, 5, 1, 2]) === [3, 1, 1, 5, 4]);\n    \n    // Test case 2: All teams have the same tasks\n    assert(determine_ranks(4, [1, 1, 1, 1]) === [1, 1, 1, 1]);\n    \n    // Test case 3: Some teams have zero tasks\n    assert(determine_ranks(3, [0, 0, 1]) === [2, 2, 1]);\n    \n    // Test case 4: Single team\n    assert(determine_ranks(1, [10]) === [1]);\n    \n    // Test case 5: Invalid argument (number of tasks doesn't match number of teams)\n    try {\n        determine_ranks(2, [1]);\n        assert(false); // This line should not be reached\n    } catch (InvalidArgumentException $e) {\n        assert(true); // Expected exception was thrown\n    }\n    \n    echo \"All tests passed successfully!\\n\";\n}\n\ntestDetermineRanks();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// This function calculates the number of subsequences in a given string of digits\n// that form numbers divisible by 8. The result is returned modulo 10^9 + 7.\nfunction count_divisible_by_eight($s) {\n    $MOD = 1000000007;\n    $dp = array_fill(0, 8, 0); // Initialize dp array with 8 zeros\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        $d = intval($c);\n        $temp = $dp; // Make a copy of the current dp array\n\n        for ($r = 0; $r < 8; $r++) {\n            if ($temp[$r] > 0) {\n                $new_r = ($r * 10 + $d) % 8;\n                $dp[$new_r] = ($dp[$new_r] + $temp[$r]) % $MOD;\n            }\n        }\n        $dp[$d % 8] = ($dp[$d % 8] + 1) % $MOD;\n    }\n\n    return $dp[0] % $MOD;\n}", "test_cases": "", "test_case_results": "Input: 1234\nNumber of subsequences divisible by 8: 1\nInput: 888\nNumber of subsequences divisible by 8: 7\nInput: 0123456789\nNumber of subsequences divisible by 8: 81\nInput: 0\nNumber of subsequences divisible by 8: 1\nInput: 8\nNumber of subsequences divisible by 8: 1", "task_id": 12084, "assertions": "<?php\n\nfunction testCountDivisibleByEight() {\n    assert(count_divisible_by_eight(\"1234\") === 1);\n    assert(count_divisible_by_eight(\"888\") === 7);\n    assert(count_divisible_by_eight(\"0123456789\") === 81);\n    assert(count_divisible_by_eight(\"0\") === 1);\n    assert(count_divisible_by_eight(\"8\") === 1);\n    echo \"All tests passed successfully!\";\n}\n\ntestCountDivisibleByEight();", "all_code": "<?php\n// This function calculates the number of subsequences in a given string of digits\n// that form numbers divisible by 8. The result is returned modulo 10^9 + 7.\nfunction count_divisible_by_eight($s) {\n    $MOD = 1000000007;\n    $dp = array_fill(0, 8, 0); // Initialize dp array with 8 zeros\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $c = $s[$i];\n        $d = intval($c);\n        $temp = $dp; // Make a copy of the current dp array\n\n        for ($r = 0; $r < 8; $r++) {\n            if ($temp[$r] > 0) {\n                $new_r = ($r * 10 + $d) % 8;\n                $dp[$new_r] = ($dp[$new_r] + $temp[$r]) % $MOD;\n            }\n        }\n        $dp[$d % 8] = ($dp[$d % 8] + 1) % $MOD;\n    }\n\n    return $dp[0] % $MOD;\n}\nfunction testCountDivisibleByEight() {\n    assert(count_divisible_by_eight(\"1234\") === 1);\n    assert(count_divisible_by_eight(\"888\") === 7);\n    assert(count_divisible_by_eight(\"0123456789\") === 81);\n    assert(count_divisible_by_eight(\"0\") === 1);\n    assert(count_divisible_by_eight(\"8\") === 1);\n    echo \"All tests passed successfully!\";\n}\n\ntestCountDivisibleByEight();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// max_interest calculates the maximum interest that can be obtained by attending workshops\n// without exceeding the total available time T.\n// Parameters:\n// - T: Total available time (integer)\n// - W: Number of workshops (integer), not used in the function but kept for consistency with the original signature\n// - workshops: Array of workshops, where each workshop is represented as [duration, interest]\n// Returns: Maximum interest achievable (integer)\nfunction max_interest($T, $W, $workshops) {\n    // Initialize a dynamic programming array with zeros\n    $dp = array_fill(0, $T + 1, 0);\n    \n    // Iterate through each workshop\n    foreach ($workshops as $workshop) {\n        $duration = $workshop[0];\n        $interest = $workshop[1];\n        \n        // Update the dp array from T down to the duration of the current workshop\n        for ($t = $T; $t >= $duration; $t--) {\n            if ($dp[$t - $duration] + $interest > $dp[$t]) {\n                $dp[$t] = $dp[$t - $duration] + $interest;\n            }\n        }\n    }\n    \n    return $dp[$T];\n}\n?>", "test_cases": "", "test_case_results": "Test case 1: 3 workshops with total time 10\nTotal time (T): 10\nNumber of workshops (W): 3\nWorkshops (duration, interest): [6, 10] [5, 8] [4, 7] \nMaximum interest: 17\n\nTest case 2: 2 workshops with total time 5\nTotal time (T): 5\nNumber of workshops (W): 2\nWorkshops (duration, interest): [3, 5] [2, 4] \nMaximum interest: 9\n\nTest case 3: 4 workshops with total time 7\nTotal time (T): 7\nNumber of workshops (W): 4\nWorkshops (duration, interest): [2, 3] [3, 4] [4, 5] [5, 6] \nMaximum interest: 9", "task_id": 574, "assertions": "<?php\nfunction testMaxInterest() {\n    assert(max_interest(10, 3, [[6, 10], [5, 8], [4, 7]]) === 17);\n    assert(max_interest(5, 2, [[3, 5], [2, 4]]) === 9);\n    assert(max_interest(7, 4, [[2, 3], [3, 4], [4, 5], [5, 6]]) === 9);\n}\n\ntestMaxInterest();\n?>", "all_code": "<?php\n// max_interest calculates the maximum interest that can be obtained by attending workshops\n// without exceeding the total available time T.\n// Parameters:\n// - T: Total available time (integer)\n// - W: Number of workshops (integer), not used in the function but kept for consistency with the original signature\n// - workshops: Array of workshops, where each workshop is represented as [duration, interest]\n// Returns: Maximum interest achievable (integer)\nfunction max_interest($T, $W, $workshops) {\n    // Initialize a dynamic programming array with zeros\n    $dp = array_fill(0, $T + 1, 0);\n    \n    // Iterate through each workshop\n    foreach ($workshops as $workshop) {\n        $duration = $workshop[0];\n        $interest = $workshop[1];\n        \n        // Update the dp array from T down to the duration of the current workshop\n        for ($t = $T; $t >= $duration; $t--) {\n            if ($dp[$t - $duration] + $interest > $dp[$t]) {\n                $dp[$t] = $dp[$t - $duration] + $interest;\n            }\n        }\n    }\n    \n    return $dp[$T];\n}\nfunction testMaxInterest() {\n    assert(max_interest(10, 3, [[6, 10], [5, 8], [4, 7]]) === 17);\n    assert(max_interest(5, 2, [[3, 5], [2, 4]]) === 9);\n    assert(max_interest(7, 4, [[2, 3], [3, 4], [4, 5], [5, 6]]) === 9);\n}\n\ntestMaxInterest();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_total calculates the total value based on given arrays a and delta.\n// The function sorts the candies by delta in ascending order and computes the total value.\n// The total value is the sum of all elements in a plus the sum of each delta multiplied by its index after sorting.\nfunction calculate_total($n, $a, $delta) {\n    // Combine delta and a into an array of pairs and sort by delta in ascending order\n    $candies = array();\n    for ($i = 0; $i < $n; $i++) {\n        $candies[] = array('delta' => $delta[$i], 'a' => $a[$i]);\n    }\n    \n    // Sort candies by delta in ascending order\n    usort($candies, function($x, $y) {\n        return $x['delta'] - $y['delta'];\n    });\n    \n    $total_a = array_sum($a);\n    $sum_t = 0;\n    \n    // Calculate sum_t by multiplying each delta by its index\n    for ($i = 0; $i < $n; $i++) {\n        $sum_t += $candies[$i]['delta'] * $i;\n    }\n    \n    $result = $total_a + $sum_t;\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input:\nn: 3\na: [1, 2, 3]\ndelta: [1, 2, 3]\nResult: 14\n\nInput:\nn: 4\na: [5, 6, 7, 8]\ndelta: [2, 3, 1, 4]\nResult: 46\n\nInput:\nn: 2\na: [10, 20]\ndelta: [5, 1]\nResult: 35", "task_id": 3122, "assertions": "<?php\n\nfunction testCalculateTotal() {\n    assert(calculate_total(3, [1, 2, 3], [1, 2, 3]) === 14);\n    assert(calculate_total(4, [5, 6, 7, 8], [2, 3, 1, 4]) === 46);\n    assert(calculate_total(2, [10, 20], [5, 1]) === 35);\n}\n\ntestCalculateTotal();\n?>", "all_code": "<?php\n// calculate_total calculates the total value based on given arrays a and delta.\n// The function sorts the candies by delta in ascending order and computes the total value.\n// The total value is the sum of all elements in a plus the sum of each delta multiplied by its index after sorting.\nfunction calculate_total($n, $a, $delta) {\n    // Combine delta and a into an array of pairs and sort by delta in ascending order\n    $candies = array();\n    for ($i = 0; $i < $n; $i++) {\n        $candies[] = array('delta' => $delta[$i], 'a' => $a[$i]);\n    }\n    \n    // Sort candies by delta in ascending order\n    usort($candies, function($x, $y) {\n        return $x['delta'] - $y['delta'];\n    });\n    \n    $total_a = array_sum($a);\n    $sum_t = 0;\n    \n    // Calculate sum_t by multiplying each delta by its index\n    for ($i = 0; $i < $n; $i++) {\n        $sum_t += $candies[$i]['delta'] * $i;\n    }\n    \n    $result = $total_a + $sum_t;\n    return $result;\n}\nfunction testCalculateTotal() {\n    assert(calculate_total(3, [1, 2, 3], [1, 2, 3]) === 14);\n    assert(calculate_total(4, [5, 6, 7, 8], [2, 3, 1, 4]) === 46);\n    assert(calculate_total(2, [10, 20], [5, 1]) === 35);\n}\n\ntestCalculateTotal();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_window_stars counts the number of stars in each window of a grid and categorizes them.\n// The grid is divided into n layers and m windows per layer.\n// Each window is a 4x4 area, and the function counts how many of the 4 rows in the window are completely filled with stars.\n// The results are stored in an array where the index represents the number of star-filled rows (0 to 4).\nfunction count_window_stars($n, $m, $lines) {\n    $ans = array_fill(0, 5, 0);\n\n    for ($layer = 0; $layer < $n; $layer++) {\n        $start_row = 5 * $layer + 1;\n        $data_rows = array_slice($lines, $start_row, 4);\n        \n        for ($j = 0; $j < $m; $j++) {\n            $star_count = 0;\n            foreach ($data_rows as $row) {\n                $window_part = substr($row, 5 * $j + 1, 4);\n                if (str_replace('*', '', $window_part) === '') {\n                    $star_count++;\n                }\n            }\n            $ans[$star_count]++;\n        }\n    }\n\n    return $ans;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nn: 1, m: 1\nGrid lines:\n.....\n.***.\n.***.\n.***.\n.***.\n.....\nResult: 1 0 0 0 0\n\nTest Case 2:\nn: 2, m: 2\nGrid lines:\n.....\n.***.....\n.***.....\n.***.....\n.***.....\n.....\n.....***.\n.....***.\n.....***.\n.....***.\n.....\nResult: 4 0 0 0 0\n\nTest Case 3:\nn: 1, m: 1\nGrid lines:\n.....\n.....\n.....\n.....\n.....\n.....\nResult: 1 0 0 0 0", "task_id": 28097, "assertions": "<?php\n\nfunction testCountWindowStars() {\n    // Test Case 1: Simple grid with one layer and one window\n    $n1 = 1;\n    $m1 = 1;\n    $lines1 = [\n        \".....\", // Layer 0 separator\n        \".***.\", // Row 1\n        \".***.\", // Row 2\n        \".***.\", // Row 3\n        \".***.\", // Row 4\n        \".....\"  // Layer 1 separator (not used)\n    ];\n    $expected1 = [1, 0, 0, 0, 0];\n    $result1 = count_window_stars($n1, $m1, $lines1);\n    assert($result1 === $expected1);\n\n    // Test Case 2: Grid with two layers and two windows per layer\n    $n2 = 2;\n    $m2 = 2;\n    $lines2 = [\n        \".....\", // Layer 0 separator\n        \".***.....\", // Row 1\n        \".***.....\", // Row 2\n        \".***.....\", // Row 3\n        \".***.....\", // Row 4\n        \".....\",    // Layer 1 separator\n        \".....***.\", // Row 1\n        \".....***.\", // Row 2\n        \".....***.\", // Row 3\n        \".....***.\", // Row 4\n        \".....\"     // Layer 2 separator (not used)\n    ];\n    $expected2 = [4, 0, 0, 0, 0];\n    $result2 = count_window_stars($n2, $m2, $lines2);\n    assert($result2 === $expected2);\n\n    // Test Case 3: Grid with no stars\n    $n3 = 1;\n    $m3 = 1;\n    $lines3 = [\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\"\n    ];\n    $expected3 = [1, 0, 0, 0, 0];\n    $result3 = count_window_stars($n3, $m3, $lines3);\n    assert($result3 === $expected3);\n}\n\ntestCountWindowStars();\n?>", "all_code": "<?php\n// count_window_stars counts the number of stars in each window of a grid and categorizes them.\n// The grid is divided into n layers and m windows per layer.\n// Each window is a 4x4 area, and the function counts how many of the 4 rows in the window are completely filled with stars.\n// The results are stored in an array where the index represents the number of star-filled rows (0 to 4).\nfunction count_window_stars($n, $m, $lines) {\n    $ans = array_fill(0, 5, 0);\n\n    for ($layer = 0; $layer < $n; $layer++) {\n        $start_row = 5 * $layer + 1;\n        $data_rows = array_slice($lines, $start_row, 4);\n        \n        for ($j = 0; $j < $m; $j++) {\n            $star_count = 0;\n            foreach ($data_rows as $row) {\n                $window_part = substr($row, 5 * $j + 1, 4);\n                if (str_replace('*', '', $window_part) === '') {\n                    $star_count++;\n                }\n            }\n            $ans[$star_count]++;\n        }\n    }\n\n    return $ans;\n}\nfunction testCountWindowStars() {\n    // Test Case 1: Simple grid with one layer and one window\n    $n1 = 1;\n    $m1 = 1;\n    $lines1 = [\n        \".....\", // Layer 0 separator\n        \".***.\", // Row 1\n        \".***.\", // Row 2\n        \".***.\", // Row 3\n        \".***.\", // Row 4\n        \".....\"  // Layer 1 separator (not used)\n    ];\n    $expected1 = [1, 0, 0, 0, 0];\n    $result1 = count_window_stars($n1, $m1, $lines1);\n    assert($result1 === $expected1);\n\n    // Test Case 2: Grid with two layers and two windows per layer\n    $n2 = 2;\n    $m2 = 2;\n    $lines2 = [\n        \".....\", // Layer 0 separator\n        \".***.....\", // Row 1\n        \".***.....\", // Row 2\n        \".***.....\", // Row 3\n        \".***.....\", // Row 4\n        \".....\",    // Layer 1 separator\n        \".....***.\", // Row 1\n        \".....***.\", // Row 2\n        \".....***.\", // Row 3\n        \".....***.\", // Row 4\n        \".....\"     // Layer 2 separator (not used)\n    ];\n    $expected2 = [4, 0, 0, 0, 0];\n    $result2 = count_window_stars($n2, $m2, $lines2);\n    assert($result2 === $expected2);\n\n    // Test Case 3: Grid with no stars\n    $n3 = 1;\n    $m3 = 1;\n    $lines3 = [\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\",\n        \".....\"\n    ];\n    $expected3 = [1, 0, 0, 0, 0];\n    $result3 = count_window_stars($n3, $m3, $lines3);\n    assert($result3 === $expected3);\n}\n\ntestCountWindowStars();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// generate_scatter_data prepares the data for a scatter plot by extracting x and y values and annotations from an array of dictionaries.\n// It filters out entries where x_key, y_key, or annotation_key are missing or have null values.\n// Returns an associative array with 'x_values', 'y_values', and 'annotations'.\nfunction generate_scatter_data($data, $x_key, $y_key, $annotation_key) {\n    $x_values = [];\n    $y_values = [];\n    $annotations = [];\n\n    foreach ($data as $entry) {\n        if (isset($entry[$x_key]) && isset($entry[$y_key]) && isset($entry[$annotation_key]) &&\n            $entry[$x_key] !== null && $entry[$y_key] !== null) {\n            $x_values[] = $entry[$x_key];\n            $y_values[] = $entry[$y_key];\n            $annotations[] = $entry[$annotation_key];\n        }\n    }\n\n    return [\n        'x_values' => $x_values,\n        'y_values' => $y_values,\n        'annotations' => $annotations\n    ];\n}\n?>", "test_cases": "", "test_case_results": "Input Keys - x_key: x, y_key: y, annotation_key: label\nInput Data:\nArray\n(\n    [0] => Array\n        (\n            [x] => 1\n            [y] => 2\n            [label] => A\n        )\n\n    [1] => Array\n        (\n            [x] => 3\n            [y] => 4\n            [label] => B\n        )\n\n    [2] => Array\n        (\n            [x] => \n            [y] => 5\n            [label] => C\n        )\n\n    [3] => Array\n        (\n            [x] => 6\n            [y] => \n            [label] => D\n        )\n\n    [4] => Array\n        (\n            [x] => 7\n            [y] => 8\n            [label] => \n        )\n\n    [5] => Array\n        (\n            [x] => 9\n            [y] => 10\n            [label] => E\n        )\n\n)\nResult - x_values: 1, 3, 9\nResult - y_values: 2, 4, 10\nResult - annotations: A, B, E\n\nInput Keys - x_key: a, y_key: b, annotation_key: name\nInput Data:\nArray\n(\n    [0] => Array\n        (\n            [a] => 10\n            [b] => 20\n            [name] => X\n        )\n\n    [1] => Array\n        (\n            [a] => 30", "task_id": 8734, "assertions": "<?php\nfunction testGenerateScatterData() {\n    // Test case 1\n    $data1 = [\n        ['x' => 1, 'y' => 2, 'label' => 'A'],\n        ['x' => 3, 'y' => 4, 'label' => 'B'],\n        ['x' => null, 'y' => 5, 'label' => 'C'],\n        ['x' => 6, 'y' => null, 'label' => 'D'],\n        ['x' => 7, 'y' => 8, 'label' => null],\n        ['x' => 9, 'y' => 10, 'label' => 'E']\n    ];\n    $result1 = generate_scatter_data($data1, 'x', 'y', 'label');\n    assert($result1['x_values'] === [1, 3, 9]);\n    assert($result1['y_values'] === [2, 4, 10]);\n    assert($result1['annotations'] === ['A', 'B', 'E']);\n\n    // Test case 2\n    $data2 = [\n        ['a' => 10, 'b' => 20, 'name' => 'X'],\n        ['a' => 30, 'b' => 40, 'name' => 'Y'],\n        ['a' => 50, 'b' => 60, 'name' => 'Z']\n    ];\n    $result2 = generate_scatter_data($data2, 'a', 'b', 'name');\n    assert($result2['x_values'] === [10, 30, 50]);\n    assert($result2['y_values'] === [20, 40, 60]);\n    assert($result2['annotations'] === ['X', 'Y', 'Z']);\n}\n\ntestGenerateScatterData();\n?>", "all_code": "<?php\n// generate_scatter_data prepares the data for a scatter plot by extracting x and y values and annotations from an array of dictionaries.\n// It filters out entries where x_key, y_key, or annotation_key are missing or have null values.\n// Returns an associative array with 'x_values', 'y_values', and 'annotations'.\nfunction generate_scatter_data($data, $x_key, $y_key, $annotation_key) {\n    $x_values = [];\n    $y_values = [];\n    $annotations = [];\n\n    foreach ($data as $entry) {\n        if (isset($entry[$x_key]) && isset($entry[$y_key]) && isset($entry[$annotation_key]) &&\n            $entry[$x_key] !== null && $entry[$y_key] !== null) {\n            $x_values[] = $entry[$x_key];\n            $y_values[] = $entry[$y_key];\n            $annotations[] = $entry[$annotation_key];\n        }\n    }\n\n    return [\n        'x_values' => $x_values,\n        'y_values' => $y_values,\n        'annotations' => $annotations\n    ];\n}\nfunction testGenerateScatterData() {\n    // Test case 1\n    $data1 = [\n        ['x' => 1, 'y' => 2, 'label' => 'A'],\n        ['x' => 3, 'y' => 4, 'label' => 'B'],\n        ['x' => null, 'y' => 5, 'label' => 'C'],\n        ['x' => 6, 'y' => null, 'label' => 'D'],\n        ['x' => 7, 'y' => 8, 'label' => null],\n        ['x' => 9, 'y' => 10, 'label' => 'E']\n    ];\n    $result1 = generate_scatter_data($data1, 'x', 'y', 'label');\n    assert($result1['x_values'] === [1, 3, 9]);\n    assert($result1['y_values'] === [2, 4, 10]);\n    assert($result1['annotations'] === ['A', 'B', 'E']);\n\n    // Test case 2\n    $data2 = [\n        ['a' => 10, 'b' => 20, 'name' => 'X'],\n        ['a' => 30, 'b' => 40, 'name' => 'Y'],\n        ['a' => 50, 'b' => 60, 'name' => 'Z']\n    ];\n    $result2 = generate_scatter_data($data2, 'a', 'b', 'name');\n    assert($result2['x_values'] === [10, 30, 50]);\n    assert($result2['y_values'] === [20, 40, 60]);\n    assert($result2['annotations'] === ['X', 'Y', 'Z']);\n}\n\ntestGenerateScatterData();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_unique_roots calculates the number of unique roots in an array of words.\n// A root is defined as the sorted string of unique characters in a word.\nfunction count_unique_roots($words) {\n    $unique_roots = array();\n    \n    foreach ($words as $word) {\n        // Get unique characters\n        $chars = array_unique(str_split($word));\n        // Sort the characters\n        sort($chars);\n        // Join into a string to represent the root\n        $root = implode('', $chars);\n        // Add to the set of unique roots\n        $unique_roots[$root] = true;\n    }\n    \n    return count($unique_roots);\n}", "test_cases": "", "test_case_results": "Input: [hello, world, hell, dlrow, hole]\nNumber of unique roots: 3\nInput: [abc, cba, bac, aabbcc]\nNumber of unique roots: 1\nInput: [a, b, c, aa, bb, cc]\nNumber of unique roots: 3", "task_id": 24024, "assertions": "<?php\n\nfunction testCountUniqueRoots() {\n    assert(count_unique_roots([\"hello\", \"world\", \"hell\", \"dlrow\", \"hole\"]) === 3);\n    assert(count_unique_roots([\"abc\", \"cba\", \"bac\", \"aabbcc\"]) === 1);\n    assert(count_unique_roots([\"a\", \"b\", \"c\", \"aa\", \"bb\", \"cc\"]) === 3);\n}\n\ntestCountUniqueRoots();", "all_code": "<?php\n// count_unique_roots calculates the number of unique roots in an array of words.\n// A root is defined as the sorted string of unique characters in a word.\nfunction count_unique_roots($words) {\n    $unique_roots = array();\n    \n    foreach ($words as $word) {\n        // Get unique characters\n        $chars = array_unique(str_split($word));\n        // Sort the characters\n        sort($chars);\n        // Join into a string to represent the root\n        $root = implode('', $chars);\n        // Add to the set of unique roots\n        $unique_roots[$root] = true;\n    }\n    \n    return count($unique_roots);\n}\nfunction testCountUniqueRoots() {\n    assert(count_unique_roots([\"hello\", \"world\", \"hell\", \"dlrow\", \"hole\"]) === 3);\n    assert(count_unique_roots([\"abc\", \"cba\", \"bac\", \"aabbcc\"]) === 1);\n    assert(count_unique_roots([\"a\", \"b\", \"c\", \"aa\", \"bb\", \"cc\"]) === 3);\n}\n\ntestCountUniqueRoots();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// max_difference_with_reverse calculates the maximum difference between any two elements in an array,\n// considering the possibility of reversing any subarray once to maximize the difference.\n// If the array has fewer than 2 elements, it returns 0.\nfunction max_difference_with_reverse($arr) {\n    $n = count($arr);\n    \n    if ($n < 2) {\n        return 0;\n    }\n    \n    $max_diff = max($arr) - min($arr);\n    \n    // Case without reversal\n    $min_elem = $arr[0];\n    for ($j = 1; $j < $n; $j++) {\n        $max_diff = max($max_diff, $arr[$j] - $min_elem);\n        $min_elem = min($min_elem, $arr[$j]);\n    }\n    \n    // Case with one reversal\n    for ($i = 1; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            // Reverse the subarray from index i to j\n            $reversed_subarray = array_merge(\n                array_slice($arr, 0, $i),\n                array_reverse(array_slice($arr, $i, $j - $i + 1)),\n                array_slice($arr, $j + 1)\n            );\n            \n            $min_elem = $reversed_subarray[0];\n            for ($k = 1; $k < $n; $k++) {\n                $max_diff = max($max_diff, $reversed_subarray[$k] - $min_elem);\n                $min_elem = min($min_elem, $reversed_subarray[$k]);\n            }\n        }\n    }\n    \n    return $max_diff;\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nMaximum Difference: 3\n\nInput: [4, 3, 2, 1]\nMaximum Difference: 3\n\nInput: [1, 2, 3, 2, 1]\nMaximum Difference: 2\n\nInput: [1]\nMaximum Difference: 0\n\nInput: [1, 5, 2, 10]\nMaximum Difference: 9\n\nInput: [7, 9, 5, 6, 3, 2]\nMaximum Difference: 7", "task_id": 26333, "assertions": "<?php\n\nfunction testMaxDifferenceWithReverse() {\n    assert(max_difference_with_reverse([1, 2, 3, 4]) === 3);\n    assert(max_difference_with_reverse([4, 3, 2, 1]) === 3);\n    assert(max_difference_with_reverse([1, 2, 3, 2, 1]) === 2);\n    assert(max_difference_with_reverse([1]) === 0);\n    assert(max_difference_with_reverse([1, 5, 2, 10]) === 9);\n    assert(max_difference_with_reverse([7, 9, 5, 6, 3, 2]) === 7);\n}\n\ntestMaxDifferenceWithReverse();\n?>", "all_code": "<?php\n// max_difference_with_reverse calculates the maximum difference between any two elements in an array,\n// considering the possibility of reversing any subarray once to maximize the difference.\n// If the array has fewer than 2 elements, it returns 0.\nfunction max_difference_with_reverse($arr) {\n    $n = count($arr);\n    \n    if ($n < 2) {\n        return 0;\n    }\n    \n    $max_diff = max($arr) - min($arr);\n    \n    // Case without reversal\n    $min_elem = $arr[0];\n    for ($j = 1; $j < $n; $j++) {\n        $max_diff = max($max_diff, $arr[$j] - $min_elem);\n        $min_elem = min($min_elem, $arr[$j]);\n    }\n    \n    // Case with one reversal\n    for ($i = 1; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            // Reverse the subarray from index i to j\n            $reversed_subarray = array_merge(\n                array_slice($arr, 0, $i),\n                array_reverse(array_slice($arr, $i, $j - $i + 1)),\n                array_slice($arr, $j + 1)\n            );\n            \n            $min_elem = $reversed_subarray[0];\n            for ($k = 1; $k < $n; $k++) {\n                $max_diff = max($max_diff, $reversed_subarray[$k] - $min_elem);\n                $min_elem = min($min_elem, $reversed_subarray[$k]);\n            }\n        }\n    }\n    \n    return $max_diff;\n}\nfunction testMaxDifferenceWithReverse() {\n    assert(max_difference_with_reverse([1, 2, 3, 4]) === 3);\n    assert(max_difference_with_reverse([4, 3, 2, 1]) === 3);\n    assert(max_difference_with_reverse([1, 2, 3, 2, 1]) === 2);\n    assert(max_difference_with_reverse([1]) === 0);\n    assert(max_difference_with_reverse([1, 5, 2, 10]) === 9);\n    assert(max_difference_with_reverse([7, 9, 5, 6, 3, 2]) === 7);\n}\n\ntestMaxDifferenceWithReverse();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_total_damage calculates the total damage based on the attack parameters of two characters.\n// The function takes four parameters: a (Alice's attack), h (Light's HP), b (Light's attack), k (Alice's HP).\n// It returns the total damage dealt in the battle scenario.\nfunction calculate_total_damage($a, $h, $b, $k) {\n    // Calculate the number of turns both characters can attack before one of them dies.\n    $t_total = min(intdiv($h - 1, $a), intdiv($k - 1, $b));\n    // Calculate the base total damage dealt by both characters.\n    $total = ($a + $b) * ($t_total + 1);\n\n    // Calculate remaining HP after the turns.\n    $light_hp = $h - ($t_total + 1) * $a;\n    $alice_hp = $k - ($t_total + 1) * $b;\n\n    // Determine if characters are still alive.\n    $light_alive = $light_hp > 0;\n    $alice_alive = $alice_hp > 0;\n\n    // Calculate extra damage if one character survives.\n    if ($light_alive && $alice_alive) {\n        $extra = 0;\n    } elseif (!$light_alive && !$alice_alive) {\n        $extra = 0;\n    } else {\n        if ($light_alive) {\n            $extra = $b * 10;\n        } else {\n            $extra = $a * 10;\n        }\n    }\n\n    $total += $extra;\n    return $total;\n}\n?>", "test_cases": "", "test_case_results": "Input: a=10, h=100, b=20, k=200\nTotal Damage: 300\nInput: a=20, h=100, b=10, k=200\nTotal Damage: 350\nInput: a=10, h=200, b=20, k=100\nTotal Damage: 350\nInput: a=10, h=100, b=10, k=100\nTotal Damage: 200", "task_id": 20509, "assertions": "<?php\n\nfunction testCalculateTotalDamage() {\n    assert(calculate_total_damage(10, 100, 20, 200) === 300);\n    assert(calculate_total_damage(20, 100, 10, 200) === 350);\n    assert(calculate_total_damage(10, 200, 20, 100) === 350);\n    assert(calculate_total_damage(10, 100, 10, 100) === 200);\n}\n\ntestCalculateTotalDamage();\n?>", "all_code": "<?php\n// calculate_total_damage calculates the total damage based on the attack parameters of two characters.\n// The function takes four parameters: a (Alice's attack), h (Light's HP), b (Light's attack), k (Alice's HP).\n// It returns the total damage dealt in the battle scenario.\nfunction calculate_total_damage($a, $h, $b, $k) {\n    // Calculate the number of turns both characters can attack before one of them dies.\n    $t_total = min(intdiv($h - 1, $a), intdiv($k - 1, $b));\n    // Calculate the base total damage dealt by both characters.\n    $total = ($a + $b) * ($t_total + 1);\n\n    // Calculate remaining HP after the turns.\n    $light_hp = $h - ($t_total + 1) * $a;\n    $alice_hp = $k - ($t_total + 1) * $b;\n\n    // Determine if characters are still alive.\n    $light_alive = $light_hp > 0;\n    $alice_alive = $alice_hp > 0;\n\n    // Calculate extra damage if one character survives.\n    if ($light_alive && $alice_alive) {\n        $extra = 0;\n    } elseif (!$light_alive && !$alice_alive) {\n        $extra = 0;\n    } else {\n        if ($light_alive) {\n            $extra = $b * 10;\n        } else {\n            $extra = $a * 10;\n        }\n    }\n\n    $total += $extra;\n    return $total;\n}\nfunction testCalculateTotalDamage() {\n    assert(calculate_total_damage(10, 100, 20, 200) === 300);\n    assert(calculate_total_damage(20, 100, 10, 200) === 350);\n    assert(calculate_total_damage(10, 200, 20, 100) === 350);\n    assert(calculate_total_damage(10, 100, 10, 100) === 200);\n}\n\ntestCalculateTotalDamage();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * shortest_travel_time calculates the shortest possible time to navigate from the top-left\n * corner (0,0) to the bottom-right corner (n-1, m-1) of the grid using Dijkstra's algorithm.\n * \n * @param array $grid A 2D array representing the grid where each cell has a time cost.\n * @return int The shortest travel time in minutes, or -1 if no path exists.\n */\nfunction shortest_travel_time($grid) {\n    if (empty($grid) || empty($grid[0])) {\n        return -1;\n    }\n\n    $n = count($grid);\n    $m = count($grid[0]);\n    $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    // Priority queue represented as an array of arrays [cost, x, y]\n    $pq = [];\n    array_push($pq, [$grid[0][0], 0, 0]);\n\n    // Visited matrix to keep track of visited cells\n    $visited = array_fill(0, $n, array_fill(0, $m, false));\n\n    // Custom comparison function for the priority queue\n    $compare = function($a, $b) {\n        return $a[0] - $b[0];\n    };\n\n    while (!empty($pq)) {\n        // Extract the element with the smallest cost\n        usort($pq, $compare);\n        $node = array_shift($pq);\n        $cost = $node[0];\n        $x = $node[1];\n        $y = $node[2];\n\n        if ($x == $n - 1 && $y == $m - 1) {\n            return $cost;\n        }\n\n        if ($visited[$x][$y]) {\n            continue;\n        }\n\n        $visited[$x][$y] = true;\n\n        foreach ($directions as $dir) {\n            $nx = $x + $dir[0];\n            $ny = $y + $dir[1];\n\n            if ($nx >= 0 && $nx < $n && $ny >= 0 && $ny < $m && !$visited[$nx][$ny]) {\n                array_push($pq, [$cost + $grid[$nx][$ny], $nx, $ny]);\n            }\n        }\n    }\n\n    return -1;\n}\n?>", "test_cases": "", "test_case_results": "Test Case: 3x3 grid with varying costs\nGrid:\n[1, 3, 1]\n[1, 5, 1]\n[4, 2, 1]\nShortest Travel Time: 7\n\nTest Case: 2x2 grid with increasing costs\nGrid:\n[1, 2]\n[3, 4]\nShortest Travel Time: 7\n\nTest Case: 3x3 grid with uniform costs\nGrid:\n[1, 1, 1]\n[1, 1, 1]\n[1, 1, 1]\nShortest Travel Time: 5\n\nTest Case: Empty grid\nGrid:\nShortest Travel Time: -1", "task_id": 19083, "assertions": "<?php\n\nfunction testShortestTravelTime() {\n    assert(shortest_travel_time([\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]) === 7);\n    \n    assert(shortest_travel_time([\n        [1, 2],\n        [3, 4]\n    ]) === 7);\n    \n    assert(shortest_travel_time([\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]) === 5);\n    \n    assert(shortest_travel_time([]) === -1);\n}\n\ntestShortestTravelTime();\n?>", "all_code": "<?php\n/**\n * shortest_travel_time calculates the shortest possible time to navigate from the top-left\n * corner (0,0) to the bottom-right corner (n-1, m-1) of the grid using Dijkstra's algorithm.\n * \n * @param array $grid A 2D array representing the grid where each cell has a time cost.\n * @return int The shortest travel time in minutes, or -1 if no path exists.\n */\nfunction shortest_travel_time($grid) {\n    if (empty($grid) || empty($grid[0])) {\n        return -1;\n    }\n\n    $n = count($grid);\n    $m = count($grid[0]);\n    $directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    // Priority queue represented as an array of arrays [cost, x, y]\n    $pq = [];\n    array_push($pq, [$grid[0][0], 0, 0]);\n\n    // Visited matrix to keep track of visited cells\n    $visited = array_fill(0, $n, array_fill(0, $m, false));\n\n    // Custom comparison function for the priority queue\n    $compare = function($a, $b) {\n        return $a[0] - $b[0];\n    };\n\n    while (!empty($pq)) {\n        // Extract the element with the smallest cost\n        usort($pq, $compare);\n        $node = array_shift($pq);\n        $cost = $node[0];\n        $x = $node[1];\n        $y = $node[2];\n\n        if ($x == $n - 1 && $y == $m - 1) {\n            return $cost;\n        }\n\n        if ($visited[$x][$y]) {\n            continue;\n        }\n\n        $visited[$x][$y] = true;\n\n        foreach ($directions as $dir) {\n            $nx = $x + $dir[0];\n            $ny = $y + $dir[1];\n\n            if ($nx >= 0 && $nx < $n && $ny >= 0 && $ny < $m && !$visited[$nx][$ny]) {\n                array_push($pq, [$cost + $grid[$nx][$ny], $nx, $ny]);\n            }\n        }\n    }\n\n    return -1;\n}\nfunction testShortestTravelTime() {\n    assert(shortest_travel_time([\n        [1, 3, 1],\n        [1, 5, 1],\n        [4, 2, 1]\n    ]) === 7);\n    \n    assert(shortest_travel_time([\n        [1, 2],\n        [3, 4]\n    ]) === 7);\n    \n    assert(shortest_travel_time([\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]) === 5);\n    \n    assert(shortest_travel_time([]) === -1);\n}\n\ntestShortestTravelTime();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// min_subarrays calculates the minimum number of subarrays required such that\n// the GCD of any two adjacent elements in the original array is greater than 1.\n// If it's not possible to form such subarrays, it returns -1.\nfunction min_subarrays($nums) {\n    $n = count($nums);\n    if ($n == 0) {\n        return 0;\n    }\n    if ($nums[0] == 1 || $nums[$n - 1] == 1) {\n        return -1;\n    }\n    $dp = array_fill(0, $n + 1, INF);\n    $dp[0] = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 0; $j < $i; $j++) {\n            if ($j < $i - 1) {\n                if (gcd($nums[$j], $nums[$i - 1]) > 1) {\n                    if ($dp[$j] + 1 < $dp[$i]) {\n                        $dp[$i] = $dp[$j] + 1;\n                    }\n                }\n            } else {\n                if ($nums[$j] > 1) {\n                    if ($dp[$j] + 1 < $dp[$i]) {\n                        $dp[$i] = $dp[$j] + 1;\n                    }\n                }\n            }\n        }\n    }\n    return $dp[$n] != INF ? $dp[$n] : -1;\n}\n\n// gcd calculates the greatest common divisor of two numbers.\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $temp = $a % $b;\n        $a = $b;\n        $b = $temp;\n    }\n    return $a;\n}\n?>", "test_cases": "", "test_case_results": "Input: [2, 3, 4, 5]\nResult: 2\nInput: [2, 4, 6, 8]\nResult: 1\nInput: [1, 2, 3, 4]\nResult: -1\nInput: [2, 3, 1, 4]\nResult: 1\nInput: [2, 3, 4, 1]\nResult: -1\nInput: [3, 5, 7, 11]\nResult: 4\nInput: [4, 6, 8, 9]\nResult: 2\nInput: [2, 3, 6, 8]\nResult: 1", "task_id": 4224, "assertions": "<?php\n\nfunction testMinSubarrays() {\n    assert(min_subarrays([2, 3, 4, 5]) === 2);\n    assert(min_subarrays([2, 4, 6, 8]) === 1);\n    assert(min_subarrays([1, 2, 3, 4]) === -1);\n    assert(min_subarrays([2, 3, 1, 4]) === 1);\n    assert(min_subarrays([2, 3, 4, 1]) === -1);\n    assert(min_subarrays([3, 5, 7, 11]) === 4);\n    assert(min_subarrays([4, 6, 8, 9]) === 2);\n    assert(min_subarrays([2, 3, 6, 8]) === 1);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestMinSubarrays();\n?>", "all_code": "<?php\n// min_subarrays calculates the minimum number of subarrays required such that\n// the GCD of any two adjacent elements in the original array is greater than 1.\n// If it's not possible to form such subarrays, it returns -1.\nfunction min_subarrays($nums) {\n    $n = count($nums);\n    if ($n == 0) {\n        return 0;\n    }\n    if ($nums[0] == 1 || $nums[$n - 1] == 1) {\n        return -1;\n    }\n    $dp = array_fill(0, $n + 1, INF);\n    $dp[0] = 0;\n    for ($i = 1; $i <= $n; $i++) {\n        for ($j = 0; $j < $i; $j++) {\n            if ($j < $i - 1) {\n                if (gcd($nums[$j], $nums[$i - 1]) > 1) {\n                    if ($dp[$j] + 1 < $dp[$i]) {\n                        $dp[$i] = $dp[$j] + 1;\n                    }\n                }\n            } else {\n                if ($nums[$j] > 1) {\n                    if ($dp[$j] + 1 < $dp[$i]) {\n                        $dp[$i] = $dp[$j] + 1;\n                    }\n                }\n            }\n        }\n    }\n    return $dp[$n] != INF ? $dp[$n] : -1;\n}\n\n// gcd calculates the greatest common divisor of two numbers.\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $temp = $a % $b;\n        $a = $b;\n        $b = $temp;\n    }\n    return $a;\n}\nfunction testMinSubarrays() {\n    assert(min_subarrays([2, 3, 4, 5]) === 2);\n    assert(min_subarrays([2, 4, 6, 8]) === 1);\n    assert(min_subarrays([1, 2, 3, 4]) === -1);\n    assert(min_subarrays([2, 3, 1, 4]) === 1);\n    assert(min_subarrays([2, 3, 4, 1]) === -1);\n    assert(min_subarrays([3, 5, 7, 11]) === 4);\n    assert(min_subarrays([4, 6, 8, 9]) === 2);\n    assert(min_subarrays([2, 3, 6, 8]) === 1);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestMinSubarrays();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Checks if the given string contains a substring that matches the given regular expression pattern.\n *\n * @param string $string The string to search within.\n * @param string $pattern The regular expression pattern to search for.\n * @return bool True if the pattern is found within the string, False otherwise.\n */\nfunction contains_pattern($string, $pattern) {\n    return preg_match(\"/\" . $pattern . \"/\", $string) === 1;\n}\n?>", "test_cases": "", "test_case_results": "String: Hello, World!, Pattern: Hello\nContains pattern: true\nString: The quick brown fox, Pattern: brown\nContains pattern: true\nString: 12345, Pattern: [0-9]+\nContains pattern: true\nString: No match here, Pattern: xyz\nContains pattern: false", "task_id": 11812, "assertions": "<?php\n\nfunction testContainsPattern() {\n    assert(contains_pattern(\"Hello, World!\", \"Hello\") === true);\n    assert(contains_pattern(\"The quick brown fox\", \"brown\") === true);\n    assert(contains_pattern(\"12345\", \"[0-9]+\") === true);\n    assert(contains_pattern(\"No match here\", \"xyz\") === false);\n}\n\ntestContainsPattern();\n?>", "all_code": "<?php\n/**\n * Checks if the given string contains a substring that matches the given regular expression pattern.\n *\n * @param string $string The string to search within.\n * @param string $pattern The regular expression pattern to search for.\n * @return bool True if the pattern is found within the string, False otherwise.\n */\nfunction contains_pattern($string, $pattern) {\n    return preg_match(\"/\" . $pattern . \"/\", $string) === 1;\n}\nfunction testContainsPattern() {\n    assert(contains_pattern(\"Hello, World!\", \"Hello\") === true);\n    assert(contains_pattern(\"The quick brown fox\", \"brown\") === true);\n    assert(contains_pattern(\"12345\", \"[0-9]+\") === true);\n    assert(contains_pattern(\"No match here\", \"xyz\") === false);\n}\n\ntestContainsPattern();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// shortest_palindrome transforms the given string into a palindrome by adding the minimum number of characters in front of it.\n// If the input string is already a palindrome, it returns the string as-is.\nfunction shortest_palindrome($s) {\n    if ($s === strrev($s)) {\n        return $s;\n    }\n\n    $n = strlen($s);\n    \n    // Compute the temporary string to apply KMP on\n    $temp = $s . \"#\" . strrev($s);\n    $lps = array_fill(0, strlen($temp), 0);\n    \n    // KMP preprocessing to create LPS array\n    $i = 1;\n    $length = 0;\n    while ($i < strlen($temp)) {\n        if ($temp[$i] === $temp[$length]) {\n            $length += 1;\n            $lps[$i] = $length;\n            $i += 1;\n        } else {\n            if ($length != 0) {\n                $length = $lps[$length - 1];\n            } else {\n                $lps[$i] = 0;\n                $i += 1;\n            }\n        }\n    }\n    \n    // The last value of the LPS array gives us the count of characters from the start\n    // that are part of the longest palindromic suffix.\n    $characters_to_add = strrev(substr($s, $lps[count($lps) - 1]));\n    $palindrome = $characters_to_add . $s;\n    \n    return $palindrome;\n}\n?>", "test_cases": "", "test_case_results": "Input: aacecaaa\nShortest Palindrome: aaacecaaa\nInput: abcd\nShortest Palindrome: dcbabcd\nInput: abac\nShortest Palindrome: cabac\nInput: a\nShortest Palindrome: a\nInput: aba\nShortest Palindrome: aba", "task_id": 14284, "assertions": "<?php\n\nfunction testShortestPalindrome() {\n    assert(shortest_palindrome(\"aacecaaa\") === \"aaacecaaa\");\n    assert(shortest_palindrome(\"abcd\") === \"dcbabcd\");\n    assert(shortest_palindrome(\"abac\") === \"cabac\");\n    assert(shortest_palindrome(\"a\") === \"a\");\n    assert(shortest_palindrome(\"aba\") === \"aba\");\n}\n\ntestShortestPalindrome();\n?>", "all_code": "<?php\n// shortest_palindrome transforms the given string into a palindrome by adding the minimum number of characters in front of it.\n// If the input string is already a palindrome, it returns the string as-is.\nfunction shortest_palindrome($s) {\n    if ($s === strrev($s)) {\n        return $s;\n    }\n\n    $n = strlen($s);\n    \n    // Compute the temporary string to apply KMP on\n    $temp = $s . \"#\" . strrev($s);\n    $lps = array_fill(0, strlen($temp), 0);\n    \n    // KMP preprocessing to create LPS array\n    $i = 1;\n    $length = 0;\n    while ($i < strlen($temp)) {\n        if ($temp[$i] === $temp[$length]) {\n            $length += 1;\n            $lps[$i] = $length;\n            $i += 1;\n        } else {\n            if ($length != 0) {\n                $length = $lps[$length - 1];\n            } else {\n                $lps[$i] = 0;\n                $i += 1;\n            }\n        }\n    }\n    \n    // The last value of the LPS array gives us the count of characters from the start\n    // that are part of the longest palindromic suffix.\n    $characters_to_add = strrev(substr($s, $lps[count($lps) - 1]));\n    $palindrome = $characters_to_add . $s;\n    \n    return $palindrome;\n}\nfunction testShortestPalindrome() {\n    assert(shortest_palindrome(\"aacecaaa\") === \"aaacecaaa\");\n    assert(shortest_palindrome(\"abcd\") === \"dcbabcd\");\n    assert(shortest_palindrome(\"abac\") === \"cabac\");\n    assert(shortest_palindrome(\"a\") === \"a\");\n    assert(shortest_palindrome(\"aba\") === \"aba\");\n}\n\ntestShortestPalindrome();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// custom_filter returns an array containing only the integers from the original array that are greater than or equal to the cutoff value.\n// If the input array is empty, it returns an empty array.\nfunction custom_filter(array $values, int $cutoff): array {\n    $filtered_values = [];\n    foreach ($values as $value) {\n        if ($value >= $cutoff) {\n            $filtered_values[] = $value;\n        }\n    }\n    return $filtered_values;\n}\n?>", "test_cases": "", "test_case_results": "Input Values: [1, 2, 3, 4], Cutoff: 2\nFiltered Values: [2, 3, 4]\nInput Values: [5, 6, 7, 0], Cutoff: 6\nFiltered Values: [6, 7]\nInput Values: [0, 0, 0, 0], Cutoff: 0\nFiltered Values: [0, 0, 0, 0]\nInput Values: [], Cutoff: 5\nFiltered Values: []", "task_id": 3564, "assertions": "<?php\nfunction testCustomFilter() {\n    assert(custom_filter([1, 2, 3, 4], 2) === [2, 3, 4]);\n    assert(custom_filter([5, 6, 7, 0], 6) === [6, 7]);\n    assert(custom_filter([0, 0, 0, 0], 0) === [0, 0, 0, 0]);\n    assert(custom_filter([], 5) === []);\n}\n\ntestCustomFilter();\n?>", "all_code": "<?php\n// custom_filter returns an array containing only the integers from the original array that are greater than or equal to the cutoff value.\n// If the input array is empty, it returns an empty array.\nfunction custom_filter(array $values, int $cutoff): array {\n    $filtered_values = [];\n    foreach ($values as $value) {\n        if ($value >= $cutoff) {\n            $filtered_values[] = $value;\n        }\n    }\n    return $filtered_values;\n}\nfunction testCustomFilter() {\n    assert(custom_filter([1, 2, 3, 4], 2) === [2, 3, 4]);\n    assert(custom_filter([5, 6, 7, 0], 6) === [6, 7]);\n    assert(custom_filter([0, 0, 0, 0], 0) === [0, 0, 0, 0]);\n    assert(custom_filter([], 5) === []);\n}\n\ntestCustomFilter();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// determine_triangle_possibility checks if three given integers can form a valid triangle.\n// The function returns \"Yes\" if the sum of any two sides is greater than the third side,\n// otherwise it returns \"No\".\nfunction determine_triangle_possibility($x, $y, $z) {\n    $sum = $x + $y + $z;\n    if ($sum == 0) {\n        return \"No\";\n    }\n    $max_val = max($x, $y, $z);\n    if ($max_val > $sum - $max_val) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\n?>", "test_cases": "", "test_case_results": "Input: 1, 2, 3\nYes\nInput: 5, 5, 5\nYes\nInput: 0, 0, 0\nNo\nInput: 10, 20, 30\nYes\nInput: 7, 10, 5\nYes", "task_id": 19167, "assertions": "<?php\nfunction testDetermineTrianglePossibility() {\n    assert(determine_triangle_possibility(1, 2, 3) === \"Yes\");\n    assert(determine_triangle_possibility(5, 5, 5) === \"Yes\");\n    assert(determine_triangle_possibility(0, 0, 0) === \"No\");\n    assert(determine_triangle_possibility(10, 20, 30) === \"Yes\");\n    assert(determine_triangle_possibility(7, 10, 5) === \"Yes\");\n}\n\ntestDetermineTrianglePossibility();\n?>", "all_code": "<?php\n// determine_triangle_possibility checks if three given integers can form a valid triangle.\n// The function returns \"Yes\" if the sum of any two sides is greater than the third side,\n// otherwise it returns \"No\".\nfunction determine_triangle_possibility($x, $y, $z) {\n    $sum = $x + $y + $z;\n    if ($sum == 0) {\n        return \"No\";\n    }\n    $max_val = max($x, $y, $z);\n    if ($max_val > $sum - $max_val) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}\nfunction testDetermineTrianglePossibility() {\n    assert(determine_triangle_possibility(1, 2, 3) === \"Yes\");\n    assert(determine_triangle_possibility(5, 5, 5) === \"Yes\");\n    assert(determine_triangle_possibility(0, 0, 0) === \"No\");\n    assert(determine_triangle_possibility(10, 20, 30) === \"Yes\");\n    assert(determine_triangle_possibility(7, 10, 5) === \"Yes\");\n}\n\ntestDetermineTrianglePossibility();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_depth computes the depth of a binary tree represented by a string.\n// The string consists of 'n' for nodes and 'l' for leaves.\n// The function uses a helper function to recursively traverse the string and compute the depth.\nfunction calculate_depth($s) {\n    $helper = function($index) use ($s, &$helper) {\n        $current = $s[$index];\n        if ($current == 'l') {\n            return [0, $index + 1];\n        } else {\n            list($left_depth, $next_index) = $helper($index + 1);\n            list($right_depth, $next_next) = $helper($next_index);\n            return [1 + max($left_depth, $right_depth), $next_next];\n        }\n    };\n    return $helper(0)[0];\n}\n?>", "test_cases": "", "test_case_results": "Input: nnlll\nDepth: 2\nInput: nlnll\nDepth: 2\nInput: ll\nDepth: 0\nInput: nll\nDepth: 1\nInput: nnnllll\nDepth: 3", "task_id": 29417, "assertions": "<?php\n\nfunction testCalculateDepth() {\n    assert(calculate_depth(\"nnlll\") === 2);\n    assert(calculate_depth(\"nlnll\") === 2);\n    assert(calculate_depth(\"ll\") === 0);\n    assert(calculate_depth(\"nll\") === 1);\n    assert(calculate_depth(\"nnnllll\") === 3);\n}\n\ntestCalculateDepth();\n?>", "all_code": "<?php\n// calculate_depth computes the depth of a binary tree represented by a string.\n// The string consists of 'n' for nodes and 'l' for leaves.\n// The function uses a helper function to recursively traverse the string and compute the depth.\nfunction calculate_depth($s) {\n    $helper = function($index) use ($s, &$helper) {\n        $current = $s[$index];\n        if ($current == 'l') {\n            return [0, $index + 1];\n        } else {\n            list($left_depth, $next_index) = $helper($index + 1);\n            list($right_depth, $next_next) = $helper($next_index);\n            return [1 + max($left_depth, $right_depth), $next_next];\n        }\n    };\n    return $helper(0)[0];\n}\nfunction testCalculateDepth() {\n    assert(calculate_depth(\"nnlll\") === 2);\n    assert(calculate_depth(\"nlnll\") === 2);\n    assert(calculate_depth(\"ll\") === 0);\n    assert(calculate_depth(\"nll\") === 1);\n    assert(calculate_depth(\"nnnllll\") === 3);\n}\n\ntestCalculateDepth();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Calculate the minimum number of steps to reach (r2, c2) from (r1, c1) on a grid.\n * The grid is represented as a 2D array where '.' represents a walkable cell and '#' represents a blocked cell.\n * Uses BFS (Breadth-First Search) to find the shortest path.\n *\n * @param int $n Number of rows in the grid.\n * @param int $m Number of columns in the grid.\n * @param array $grid 2D array representing the grid.\n * @param int $r1 Starting row (1-based index).\n * @param int $c1 Starting column (1-based index).\n * @param int $r2 Target row (1-based index).\n * @param int $c2 Target column (1-based index).\n * @return int Minimum number of steps or -1 if the target is unreachable.\n */\nfunction min_steps_to_reach($n, $m, $grid, $r1, $c1, $r2, $c2) {\n    // Convert to zero-based indices\n    $r1 -= 1;\n    $c1 -= 1;\n    $r2 -= 1;\n    $c2 -= 1;\n    \n    // Validate whether start or end positions are invalid initially\n    if ($grid[$r1][$c1] == '#' || $grid[$r2][$c2] == '#') {\n        return -1;\n    }\n    \n    // Directions for moving up, down, left, right\n    $directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    \n    // BFS queue for storing positions and steps taken\n    $queue = new SplQueue();\n    $queue->enqueue([$r1, $c1, 0]);\n    $visited = [];\n    $visited[$r1][$c1] = true;\n    \n    while (!$queue->isEmpty()) {\n        list($row, $col, $steps) = $queue->dequeue();\n        \n        if ($row == $r2 && $col == $c2) {\n            return $steps;\n        }\n        \n        foreach ($directions as $dir) {\n            $new_row = $row + $dir[0];\n            $new_col = $col + $dir[1];\n            \n            if ($new_row >= 0 && $new_row < $n && $new_col >= 0 && $new_col < $m) {\n                if (!isset($visited[$new_row][$new_col]) && $grid[$new_row][$new_col] == '.') {\n                    $visited[$new_row][$new_col] = true;\n                    $queue->enqueue([$new_row, $new_col, $steps + 1]);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n?>", "test_cases": "", "test_case_results": "Test Case:\nGrid:\n. . .\n. # .\n. . .\nStart: (1, 1)\nEnd: (3, 3)\nResult: 4\nExpected: 4\n---\nTest Case:\nGrid:\n. # .\n. # .\n. # .\nStart: (1, 1)\nEnd: (3, 1)\nResult: 2\nExpected: 2\n---\nTest Case:\nGrid:\n. # .\n# # #\n. # .\nStart: (1, 1)\nEnd: (3, 3)\nResult: -1\nExpected: -1\n---", "task_id": 16626, "assertions": "<?php\n\nfunction testMinStepsToReach() {\n    $test_cases = [\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '.', '.'],\n                ['.', '#', '.'],\n                ['.', '.', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 3,\n            'expected' => 4\n        ],\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '#', '.'],\n                ['.', '#', '.'],\n                ['.', '#', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 1,\n            'expected' => 2\n        ],\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '#', '.'],\n                ['#', '#', '#'],\n                ['.', '#', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 3,\n            'expected' => -1\n        ]\n    ];\n\n    foreach ($test_cases as $test_case) {\n        $result = min_steps_to_reach(\n            $test_case['n'],\n            $test_case['m'],\n            $test_case['grid'],\n            $test_case['r1'],\n            $test_case['c1'],\n            $test_case['r2'],\n            $test_case['c2']\n        );\n        assert($result === $test_case['expected']);\n    }\n}\n\ntestMinStepsToReach();\n?>", "all_code": "<?php\n/**\n * Calculate the minimum number of steps to reach (r2, c2) from (r1, c1) on a grid.\n * The grid is represented as a 2D array where '.' represents a walkable cell and '#' represents a blocked cell.\n * Uses BFS (Breadth-First Search) to find the shortest path.\n *\n * @param int $n Number of rows in the grid.\n * @param int $m Number of columns in the grid.\n * @param array $grid 2D array representing the grid.\n * @param int $r1 Starting row (1-based index).\n * @param int $c1 Starting column (1-based index).\n * @param int $r2 Target row (1-based index).\n * @param int $c2 Target column (1-based index).\n * @return int Minimum number of steps or -1 if the target is unreachable.\n */\nfunction min_steps_to_reach($n, $m, $grid, $r1, $c1, $r2, $c2) {\n    // Convert to zero-based indices\n    $r1 -= 1;\n    $c1 -= 1;\n    $r2 -= 1;\n    $c2 -= 1;\n    \n    // Validate whether start or end positions are invalid initially\n    if ($grid[$r1][$c1] == '#' || $grid[$r2][$c2] == '#') {\n        return -1;\n    }\n    \n    // Directions for moving up, down, left, right\n    $directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    \n    // BFS queue for storing positions and steps taken\n    $queue = new SplQueue();\n    $queue->enqueue([$r1, $c1, 0]);\n    $visited = [];\n    $visited[$r1][$c1] = true;\n    \n    while (!$queue->isEmpty()) {\n        list($row, $col, $steps) = $queue->dequeue();\n        \n        if ($row == $r2 && $col == $c2) {\n            return $steps;\n        }\n        \n        foreach ($directions as $dir) {\n            $new_row = $row + $dir[0];\n            $new_col = $col + $dir[1];\n            \n            if ($new_row >= 0 && $new_row < $n && $new_col >= 0 && $new_col < $m) {\n                if (!isset($visited[$new_row][$new_col]) && $grid[$new_row][$new_col] == '.') {\n                    $visited[$new_row][$new_col] = true;\n                    $queue->enqueue([$new_row, $new_col, $steps + 1]);\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\nfunction testMinStepsToReach() {\n    $test_cases = [\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '.', '.'],\n                ['.', '#', '.'],\n                ['.', '.', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 3,\n            'expected' => 4\n        ],\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '#', '.'],\n                ['.', '#', '.'],\n                ['.', '#', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 1,\n            'expected' => 2\n        ],\n        [\n            'n' => 3,\n            'm' => 3,\n            'grid' => [\n                ['.', '#', '.'],\n                ['#', '#', '#'],\n                ['.', '#', '.']\n            ],\n            'r1' => 1,\n            'c1' => 1,\n            'r2' => 3,\n            'c2' => 3,\n            'expected' => -1\n        ]\n    ];\n\n    foreach ($test_cases as $test_case) {\n        $result = min_steps_to_reach(\n            $test_case['n'],\n            $test_case['m'],\n            $test_case['grid'],\n            $test_case['r1'],\n            $test_case['c1'],\n            $test_case['r2'],\n            $test_case['c2']\n        );\n        assert($result === $test_case['expected']);\n    }\n}\n\ntestMinStepsToReach();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_modular_product calculates the modular product of three terms derived from n and m.\n// The terms are: (n % m), ((n + 1) % m), and ((2 * n + 1) % m).\n// The function returns the product of these three terms modulo m.\nfunction calculate_modular_product($n, $m) {\n    $a = $n % $m;\n    $b = ($n + 1) % $m;\n    $c = (2 * $n + 1) % $m;\n    $result = ($a * $b) % $m;\n    $result = ($result * $c) % $m;\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input: n = 5, m = 3\nResult: 0\nInput: n = 10, m = 7\nResult: 0\nInput: n = 15, m = 11\nResult: 4\nInput: n = 20, m = 13\nResult: 8", "task_id": 5689, "assertions": "<?php\nfunction testCalculateModularProduct() {\n    assert(calculate_modular_product(5, 3) === 0);\n    assert(calculate_modular_product(10, 7) === 0);\n    assert(calculate_modular_product(15, 11) === 4);\n    assert(calculate_modular_product(20, 13) === 8);\n}\n\ntestCalculateModularProduct();\n?>", "all_code": "<?php\n// calculate_modular_product calculates the modular product of three terms derived from n and m.\n// The terms are: (n % m), ((n + 1) % m), and ((2 * n + 1) % m).\n// The function returns the product of these three terms modulo m.\nfunction calculate_modular_product($n, $m) {\n    $a = $n % $m;\n    $b = ($n + 1) % $m;\n    $c = (2 * $n + 1) % $m;\n    $result = ($a * $b) % $m;\n    $result = ($result * $c) % $m;\n    return $result;\n}\nfunction testCalculateModularProduct() {\n    assert(calculate_modular_product(5, 3) === 0);\n    assert(calculate_modular_product(10, 7) === 0);\n    assert(calculate_modular_product(15, 11) === 4);\n    assert(calculate_modular_product(20, 13) === 8);\n}\n\ntestCalculateModularProduct();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines if there exists a permutation of array $b such that\n * every element of the array $b is greater than or equal to the\n * corresponding element of array $a.\n *\n * @param array $a The first array.\n * @param array $b The second array.\n * @return string Returns \"Yes\" if such a permutation exists, otherwise \"No\".\n */\nfunction can_permute_greater_or_equal($a, $b) {\n    // Sort both arrays to compare elements in ascending order\n    sort($a);\n    sort($b);\n    \n    // Iterate through each element of the arrays\n    for ($i = 0; $i < count($a); $i++) {\n        if ($b[$i] < $a[$i]) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\n?>", "test_cases": "", "test_case_results": "Input a: [1, 2, 3]\nInput b: [2, 3, 4]\nResult: Yes\n\nInput a: [1, 2, 3]\nInput b: [1, 1, 1]\nResult: No\n\nInput a: [5, 6, 7]\nInput b: [8, 9, 10]\nResult: Yes\n\nInput a: []\nInput b: []\nResult: Yes\n\nInput a: [1, 1, 1]\nInput b: [1, 1, 1]\nResult: Yes", "task_id": 16143, "assertions": "<?php\n\nfunction testCanPermuteGreaterOrEqual() {\n    assert(can_permute_greater_or_equal([1, 2, 3], [2, 3, 4]) === \"Yes\");\n    assert(can_permute_greater_or_equal([1, 2, 3], [1, 1, 1]) === \"No\");\n    assert(can_permute_greater_or_equal([5, 6, 7], [8, 9, 10]) === \"Yes\");\n    assert(can_permute_greater_or_equal([], []) === \"Yes\");\n    assert(can_permute_greater_or_equal([1, 1, 1], [1, 1, 1]) === \"Yes\");\n}\n\ntestCanPermuteGreaterOrEqual();\n?>", "all_code": "<?php\n/**\n * Determines if there exists a permutation of array $b such that\n * every element of the array $b is greater than or equal to the\n * corresponding element of array $a.\n *\n * @param array $a The first array.\n * @param array $b The second array.\n * @return string Returns \"Yes\" if such a permutation exists, otherwise \"No\".\n */\nfunction can_permute_greater_or_equal($a, $b) {\n    // Sort both arrays to compare elements in ascending order\n    sort($a);\n    sort($b);\n    \n    // Iterate through each element of the arrays\n    for ($i = 0; $i < count($a); $i++) {\n        if ($b[$i] < $a[$i]) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nfunction testCanPermuteGreaterOrEqual() {\n    assert(can_permute_greater_or_equal([1, 2, 3], [2, 3, 4]) === \"Yes\");\n    assert(can_permute_greater_or_equal([1, 2, 3], [1, 1, 1]) === \"No\");\n    assert(can_permute_greater_or_equal([5, 6, 7], [8, 9, 10]) === \"Yes\");\n    assert(can_permute_greater_or_equal([], []) === \"Yes\");\n    assert(can_permute_greater_or_equal([1, 1, 1], [1, 1, 1]) === \"Yes\");\n}\n\ntestCanPermuteGreaterOrEqual();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// uncompress_string decompresses a string that contains patterns like n[substring], where n is a number and substring is a sequence of characters.\n// The function uses a stack to handle nested patterns by keeping track of the current string and the number of times it should be repeated.\nfunction uncompress_string($s) {\n    $stack = [];\n    $result = \"\";\n    $num = 0;\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (ctype_digit($char)) {\n            $num = $num * 10 + intval($char);\n        } elseif ($char == '[') {\n            array_push($stack, [$result, $num]);\n            $result = \"\";\n            $num = 0;\n        } elseif ($char == ']') {\n            $popped = array_pop($stack);\n            $prev_string = $popped[0];\n            $repeat_times = $popped[1];\n            $result = $prev_string . str_repeat($result, $repeat_times);\n        } else {\n            $result .= $char;\n        }\n    }\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input: 3[a]2[4[2[c]]]\nDecompressed: aaacccccccccccccccc\nInput: 2[abc]3[cd]ef\nDecompressed: abcabccdcdcdef\nInput: 10[a]\nDecompressed: aaaaaaaaaa\nInput: 3[a2[c]]\nDecompressed: accaccacc\nInput: 2[3[a]b]\nDecompressed: aaabaaab", "task_id": 10247, "assertions": "<?php\n\nfunction testUncompressString() {\n    assert(uncompress_string(\"3[a]2[4[2[c]]]\") === \"aaacccccccccccccccc\");\n    assert(uncompress_string(\"2[abc]3[cd]ef\") === \"abcabccdcdcdef\");\n    assert(uncompress_string(\"10[a]\") === \"aaaaaaaaaa\");\n    assert(uncompress_string(\"3[a2[c]]\") === \"accaccacc\");\n    assert(uncompress_string(\"2[3[a]b]\") === \"aaabaaab\");\n}\n\ntestUncompressString();\n?>", "all_code": "<?php\n// uncompress_string decompresses a string that contains patterns like n[substring], where n is a number and substring is a sequence of characters.\n// The function uses a stack to handle nested patterns by keeping track of the current string and the number of times it should be repeated.\nfunction uncompress_string($s) {\n    $stack = [];\n    $result = \"\";\n    $num = 0;\n\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (ctype_digit($char)) {\n            $num = $num * 10 + intval($char);\n        } elseif ($char == '[') {\n            array_push($stack, [$result, $num]);\n            $result = \"\";\n            $num = 0;\n        } elseif ($char == ']') {\n            $popped = array_pop($stack);\n            $prev_string = $popped[0];\n            $repeat_times = $popped[1];\n            $result = $prev_string . str_repeat($result, $repeat_times);\n        } else {\n            $result .= $char;\n        }\n    }\n    return $result;\n}\nfunction testUncompressString() {\n    assert(uncompress_string(\"3[a]2[4[2[c]]]\") === \"aaacccccccccccccccc\");\n    assert(uncompress_string(\"2[abc]3[cd]ef\") === \"abcabccdcdcdef\");\n    assert(uncompress_string(\"10[a]\") === \"aaaaaaaaaa\");\n    assert(uncompress_string(\"3[a2[c]]\") === \"accaccacc\");\n    assert(uncompress_string(\"2[3[a]b]\") === \"aaabaaab\");\n}\n\ntestUncompressString();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Determines the smallest unit of repetition for a given word.\n *\n * @param string $word The input word composed of lowercase alphabets.\n * @return string The smallest unit of repetition.\n */\nfunction smallest_repetitive_unit($word) {\n    $length = strlen($word);\n    \n    for ($i = 1; $i <= $length / 2; $i++) {\n        $unit = substr($word, 0, $i);\n        if ($length % $i == 0) {\n            $repeated_unit = str_repeat($unit, $length / $i);\n            if ($repeated_unit === $word) {\n                return $unit;\n            }\n        }\n    }\n    \n    return $word;\n}\n?>", "test_cases": "", "test_case_results": "Input: ababab\nSmallest Repetitive Unit: ab\nInput: abcabcabc\nSmallest Repetitive Unit: abc\nInput: aaaaaa\nSmallest Repetitive Unit: a\nInput: abcdefg\nSmallest Repetitive Unit: abcdefg\nInput: a\nSmallest Repetitive Unit: a\nInput: abababab\nSmallest Repetitive Unit: ab", "task_id": 18462, "assertions": "<?php\n\nfunction testSmallestRepetitiveUnit() {\n    assert(smallest_repetitive_unit(\"ababab\") === \"ab\");\n    assert(smallest_repetitive_unit(\"abcabcabc\") === \"abc\");\n    assert(smallest_repetitive_unit(\"aaaaaa\") === \"a\");\n    assert(smallest_repetitive_unit(\"abcdefg\") === \"abcdefg\");\n    assert(smallest_repetitive_unit(\"a\") === \"a\");\n    assert(smallest_repetitive_unit(\"abababab\") === \"ab\");\n}\n\ntestSmallestRepetitiveUnit();\n?>", "all_code": "<?php\n/**\n * Determines the smallest unit of repetition for a given word.\n *\n * @param string $word The input word composed of lowercase alphabets.\n * @return string The smallest unit of repetition.\n */\nfunction smallest_repetitive_unit($word) {\n    $length = strlen($word);\n    \n    for ($i = 1; $i <= $length / 2; $i++) {\n        $unit = substr($word, 0, $i);\n        if ($length % $i == 0) {\n            $repeated_unit = str_repeat($unit, $length / $i);\n            if ($repeated_unit === $word) {\n                return $unit;\n            }\n        }\n    }\n    \n    return $word;\n}\nfunction testSmallestRepetitiveUnit() {\n    assert(smallest_repetitive_unit(\"ababab\") === \"ab\");\n    assert(smallest_repetitive_unit(\"abcabcabc\") === \"abc\");\n    assert(smallest_repetitive_unit(\"aaaaaa\") === \"a\");\n    assert(smallest_repetitive_unit(\"abcdefg\") === \"abcdefg\");\n    assert(smallest_repetitive_unit(\"a\") === \"a\");\n    assert(smallest_repetitive_unit(\"abababab\") === \"ab\");\n}\n\ntestSmallestRepetitiveUnit();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_odd_differences counts the number of times the difference between consecutive elements in an array is odd.\n// The function takes an array of integers and returns the count of odd differences.\nfunction count_odd_differences($numbers) {\n    $count = 0;\n    $previous_number = 0;\n    foreach ($numbers as $number) {\n        $difference = $number - $previous_number;\n        if ($difference % 2 != 0) {\n            $count++;\n        }\n        $previous_number = $number;\n    }\n    return $count;\n}\n\n// determine_winner determines the winner based on the count of odd differences.\n// If the count is odd, Alice wins; otherwise, Bob wins.\nfunction determine_winner($count) {\n    return ($count % 2 == 1) ? \"Alice\" : \"Bob\";\n}\n?>", "test_cases": "", "test_case_results": "Input: 1, 2, 3, 4\nCount of odd differences: 4\nWinner: Bob\n\nInput: 5, 6, 7, 0\nCount of odd differences: 4\nWinner: Bob\n\nInput: 0, 0, 0, 0\nCount of odd differences: 0\nWinner: Bob\n\nInput: 1, 3, 5, 7\nCount of odd differences: 1\nWinner: Alice\n\nInput: 2, 4, 6, 8\nCount of odd differences: 0\nWinner: Bob", "task_id": 9150, "assertions": "<?php\nfunction testOddDifferences() {\n    assert(count_odd_differences([1, 2, 3, 4]) === 4);\n    assert(determine_winner(4) === \"Bob\");\n    \n    assert(count_odd_differences([5, 6, 7, 0]) === 4);\n    assert(determine_winner(4) === \"Bob\");\n    \n    assert(count_odd_differences([0, 0, 0, 0]) === 0);\n    assert(determine_winner(0) === \"Bob\");\n    \n    assert(count_odd_differences([1, 3, 5, 7]) === 1);\n    assert(determine_winner(1) === \"Alice\");\n    \n    assert(count_odd_differences([2, 4, 6, 8]) === 0);\n    assert(determine_winner(0) === \"Bob\");\n}\n\ntestOddDifferences();\n?>", "all_code": "<?php\n// count_odd_differences counts the number of times the difference between consecutive elements in an array is odd.\n// The function takes an array of integers and returns the count of odd differences.\nfunction count_odd_differences($numbers) {\n    $count = 0;\n    $previous_number = 0;\n    foreach ($numbers as $number) {\n        $difference = $number - $previous_number;\n        if ($difference % 2 != 0) {\n            $count++;\n        }\n        $previous_number = $number;\n    }\n    return $count;\n}\n\n// determine_winner determines the winner based on the count of odd differences.\n// If the count is odd, Alice wins; otherwise, Bob wins.\nfunction determine_winner($count) {\n    return ($count % 2 == 1) ? \"Alice\" : \"Bob\";\n}\nfunction testOddDifferences() {\n    assert(count_odd_differences([1, 2, 3, 4]) === 4);\n    assert(determine_winner(4) === \"Bob\");\n    \n    assert(count_odd_differences([5, 6, 7, 0]) === 4);\n    assert(determine_winner(4) === \"Bob\");\n    \n    assert(count_odd_differences([0, 0, 0, 0]) === 0);\n    assert(determine_winner(0) === \"Bob\");\n    \n    assert(count_odd_differences([1, 3, 5, 7]) === 1);\n    assert(determine_winner(1) === \"Alice\");\n    \n    assert(count_odd_differences([2, 4, 6, 8]) === 0);\n    assert(determine_winner(0) === \"Bob\");\n}\n\ntestOddDifferences();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// generate_lucky_numbers generates all lucky numbers (numbers made of 4 and 8, divisible by 48) up to 15 digits.\n// The function returns an array of sorted lucky numbers.\nfunction generate_lucky_numbers() {\n    $lucky_numbers = array();\n    for ($length = 1; $length <= 15; $length++) {\n        for ($mask = 0; $mask < (1 << $length); $mask++) {\n            $num = 0;\n            for ($i = 0; $i < $length; $i++) {\n                $bit = ($mask >> ($length - 1 - $i)) & 1;\n                $num = $num * 10 + ($bit ? 8 : 4);\n            }\n            if ($num % 48 == 0) {\n                array_push($lucky_numbers, $num);\n            }\n        }\n    }\n    sort($lucky_numbers);\n    return $lucky_numbers;\n}\n\n// count_lucky_numbers_in_range counts how many lucky numbers are in the range [L, R].\n// It uses binary search to find the lower and upper bounds.\nfunction count_lucky_numbers_in_range($lucky_numbers, $L, $R) {\n    $left = binary_search_left($lucky_numbers, $L);\n    $right = binary_search_right($lucky_numbers, $R);\n    return $right - $left;\n}\n\n// binary_search_left finds the first index where the value is >= target.\nfunction binary_search_left($arr, $target) {\n    $low = 0;\n    $high = count($arr);\n    while ($low < $high) {\n        $mid = (int)(($low + $high) / 2);\n        if ($arr[$mid] < $target) {\n            $low = $mid + 1;\n        } else {\n            $high = $mid;\n        }\n    }\n    return $low;\n}\n\n// binary_search_right finds the first index where the value is > target.\nfunction binary_search_right($arr, $target) {\n    $low = 0;\n    $high = count($arr);\n    while ($low < $high) {\n        $mid = (int)(($low + $high) / 2);\n        if ($arr[$mid] <= $target) {\n            $low = $mid + 1;\n        } else {\n            $high = $mid;\n        }\n    }\n    return $low;\n}\n?>", "test_cases": "", "test_case_results": "Range [1, 100]: 1\nRange [48, 4848]: 2\nRange [444, 888]: 0\nRange [4800, 48000]: 3", "task_id": 5129, "assertions": "<?php\nfunction testLuckyNumbers() {\n    // Precompute all lucky numbers\n    $lucky_numbers = generate_lucky_numbers();\n    \n    // Test cases with expected results\n    assert(count_lucky_numbers_in_range($lucky_numbers, 1, 100) === 1);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 48, 4848) === 2);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 444, 888) === 0);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 4800, 48000) === 3);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestLuckyNumbers();\n?>", "all_code": "<?php\n// generate_lucky_numbers generates all lucky numbers (numbers made of 4 and 8, divisible by 48) up to 15 digits.\n// The function returns an array of sorted lucky numbers.\nfunction generate_lucky_numbers() {\n    $lucky_numbers = array();\n    for ($length = 1; $length <= 15; $length++) {\n        for ($mask = 0; $mask < (1 << $length); $mask++) {\n            $num = 0;\n            for ($i = 0; $i < $length; $i++) {\n                $bit = ($mask >> ($length - 1 - $i)) & 1;\n                $num = $num * 10 + ($bit ? 8 : 4);\n            }\n            if ($num % 48 == 0) {\n                array_push($lucky_numbers, $num);\n            }\n        }\n    }\n    sort($lucky_numbers);\n    return $lucky_numbers;\n}\n\n// count_lucky_numbers_in_range counts how many lucky numbers are in the range [L, R].\n// It uses binary search to find the lower and upper bounds.\nfunction count_lucky_numbers_in_range($lucky_numbers, $L, $R) {\n    $left = binary_search_left($lucky_numbers, $L);\n    $right = binary_search_right($lucky_numbers, $R);\n    return $right - $left;\n}\n\n// binary_search_left finds the first index where the value is >= target.\nfunction binary_search_left($arr, $target) {\n    $low = 0;\n    $high = count($arr);\n    while ($low < $high) {\n        $mid = (int)(($low + $high) / 2);\n        if ($arr[$mid] < $target) {\n            $low = $mid + 1;\n        } else {\n            $high = $mid;\n        }\n    }\n    return $low;\n}\n\n// binary_search_right finds the first index where the value is > target.\nfunction binary_search_right($arr, $target) {\n    $low = 0;\n    $high = count($arr);\n    while ($low < $high) {\n        $mid = (int)(($low + $high) / 2);\n        if ($arr[$mid] <= $target) {\n            $low = $mid + 1;\n        } else {\n            $high = $mid;\n        }\n    }\n    return $low;\n}\nfunction testLuckyNumbers() {\n    // Precompute all lucky numbers\n    $lucky_numbers = generate_lucky_numbers();\n    \n    // Test cases with expected results\n    assert(count_lucky_numbers_in_range($lucky_numbers, 1, 100) === 1);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 48, 4848) === 2);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 444, 888) === 0);\n    assert(count_lucky_numbers_in_range($lucky_numbers, 4800, 48000) === 3);\n    \n    echo \"All tests passed successfully!\";\n}\n\ntestLuckyNumbers();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// evaluate_function evaluates a mathematical function over a specified range of x values.\n// The function is provided as a string, and it is evaluated for each x in the range [x_start, x_end] with a given step_size.\n// Returns an array of associative arrays with keys 'x' and 'f_x' representing the x value and the evaluated function result.\nfunction evaluate_function($function_str, $x_start, $x_end, $step_size) {\n    $results = [];\n    \n    // Generate x values from x_start to x_end with step_size increments\n    for ($x = $x_start; $x <= $x_end; $x += $step_size) {\n        try {\n            // Replace '^' with '**' for exponentiation in PHP\n            $func_str = str_replace('^', '**', $function_str);\n            // Replace 'x' with the current value of $x\n            $func_str = str_replace('x', '$x', $func_str);\n            // Evaluate the function\n            eval('$f_x = ' . $func_str . ';');\n            $results[] = ['x' => $x, 'f_x' => $f_x];\n        } catch (Exception $e) {\n            // Handle errors by setting f_x to NAN\n            echo \"Error evaluating function for x = $x: \" . $e->getMessage() . \"\\n\";\n            $results[] = ['x' => $x, 'f_x' => NAN];\n        }\n    }\n    \n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Function: x^2\nRange: [1, 5] with step 1\nx: 1, f(x): 1\nx: 2, f(x): 4\nx: 3, f(x): 9\nx: 4, f(x): 16\nx: 5, f(x): 25\n\nFunction: 2*x + 3\nRange: [0, 4] with step 0.5\nx: 0, f(x): 3\nx: 0.5, f(x): 4\nx: 1, f(x): 5\nx: 1.5, f(x): 6\nx: 2, f(x): 7\nx: 2.5, f(x): 8\nx: 3, f(x): 9\nx: 3.5, f(x): 10\nx: 4, f(x): 11\n\nFunction: sin(x)\nRange: [0, 3.14] with step 1.57\nx: 0, f(x): 0\nx: 1.57, f(x): 0.99999968293183\nx: 3.14, f(x): 0.0015926529164868\n\nFunction: 1 / x\nRange: [-1, 1] with step 1\nx: -1, f(x): -1\nx: 0, f(x): INF\nx: 1, f(x): 1", "task_id": 14127, "assertions": "<?php\nfunction testEvaluateFunction() {\n    // Test case 1: x^2 from 1 to 5 with step 1\n    $result1 = evaluate_function('x^2', 1, 5, 1);\n    assert($result1[0]['x'] == 1 && $result1[0]['f_x'] == 1);\n    assert($result1[1]['x'] == 2 && $result1[1]['f_x'] == 4);\n    assert($result1[2]['x'] == 3 && $result1[2]['f_x'] == 9);\n    assert($result1[3]['x'] == 4 && $result1[3]['f_x'] == 16);\n    assert($result1[4]['x'] == 5 && $result1[4]['f_x'] == 25);\n\n    // Test case 2: 2*x + 3 from 0 to 4 with step 0.5\n    $result2 = evaluate_function('2*x + 3', 0, 4, 0.5);\n    assert($result2[0]['x'] == 0 && $result2[0]['f_x'] == 3);\n    assert($result2[1]['x'] == 0.5 && $result2[1]['f_x'] == 4);\n    assert($result2[2]['x'] == 1 && $result2[2]['f_x'] == 5);\n    assert($result2[3]['x'] == 1.5 && $result2[3]['f_x'] == 6);\n    assert($result2[4]['x'] == 2 && $result2[4]['f_x'] == 7);\n    assert($result2[5]['x'] == 2.5 && $result2[5]['f_x'] == 8);\n    assert($result2[6]['x'] == 3 && $result2[6]['f_x'] == 9);\n    assert($result2[7]['x'] == 3.5 && $result2[7]['f_x'] == 10);\n    assert($result2[8]['x'] == 4 && $result2[8]['f_x'] == 11);\n\n    // Test case 3: sin(x) from 0 to 3.14 with step 1.57\n    $result3 = evaluate_function('sin(x)', 0, 3.14, 1.57);\n    assert($result3[0]['x'] == 0 && $result3[0]['f_x'] == 0);\n    assert(abs($result3[1]['f_x'] - 1) < 0.0001); // Approximately 1\n    assert(abs($result3[2]['f_x'] - 0) < 0.002); // Approximately 0\n\n    // Test case 4: 1 / x from -1 to 1 with step 1\n    $result4 = evaluate_function('1 / x', -1, 1, 1);\n    assert($result4[0]['x'] == -1 && $result4[0]['f_x'] == -1);\n    assert(is_infinite($result4[1]['f_x'])); // Division by zero\n    assert($result4[2]['x'] == 1 && $result4[2]['f_x'] == 1);\n}\n\ntestEvaluateFunction();\n?>", "all_code": "<?php\n// evaluate_function evaluates a mathematical function over a specified range of x values.\n// The function is provided as a string, and it is evaluated for each x in the range [x_start, x_end] with a given step_size.\n// Returns an array of associative arrays with keys 'x' and 'f_x' representing the x value and the evaluated function result.\nfunction evaluate_function($function_str, $x_start, $x_end, $step_size) {\n    $results = [];\n    \n    // Generate x values from x_start to x_end with step_size increments\n    for ($x = $x_start; $x <= $x_end; $x += $step_size) {\n        try {\n            // Replace '^' with '**' for exponentiation in PHP\n            $func_str = str_replace('^', '**', $function_str);\n            // Replace 'x' with the current value of $x\n            $func_str = str_replace('x', '$x', $func_str);\n            // Evaluate the function\n            eval('$f_x = ' . $func_str . ';');\n            $results[] = ['x' => $x, 'f_x' => $f_x];\n        } catch (Exception $e) {\n            // Handle errors by setting f_x to NAN\n            echo \"Error evaluating function for x = $x: \" . $e->getMessage() . \"\\n\";\n            $results[] = ['x' => $x, 'f_x' => NAN];\n        }\n    }\n    \n    return $results;\n}\nfunction testEvaluateFunction() {\n    // Test case 1: x^2 from 1 to 5 with step 1\n    $result1 = evaluate_function('x^2', 1, 5, 1);\n    assert($result1[0]['x'] == 1 && $result1[0]['f_x'] == 1);\n    assert($result1[1]['x'] == 2 && $result1[1]['f_x'] == 4);\n    assert($result1[2]['x'] == 3 && $result1[2]['f_x'] == 9);\n    assert($result1[3]['x'] == 4 && $result1[3]['f_x'] == 16);\n    assert($result1[4]['x'] == 5 && $result1[4]['f_x'] == 25);\n\n    // Test case 2: 2*x + 3 from 0 to 4 with step 0.5\n    $result2 = evaluate_function('2*x + 3', 0, 4, 0.5);\n    assert($result2[0]['x'] == 0 && $result2[0]['f_x'] == 3);\n    assert($result2[1]['x'] == 0.5 && $result2[1]['f_x'] == 4);\n    assert($result2[2]['x'] == 1 && $result2[2]['f_x'] == 5);\n    assert($result2[3]['x'] == 1.5 && $result2[3]['f_x'] == 6);\n    assert($result2[4]['x'] == 2 && $result2[4]['f_x'] == 7);\n    assert($result2[5]['x'] == 2.5 && $result2[5]['f_x'] == 8);\n    assert($result2[6]['x'] == 3 && $result2[6]['f_x'] == 9);\n    assert($result2[7]['x'] == 3.5 && $result2[7]['f_x'] == 10);\n    assert($result2[8]['x'] == 4 && $result2[8]['f_x'] == 11);\n\n    // Test case 3: sin(x) from 0 to 3.14 with step 1.57\n    $result3 = evaluate_function('sin(x)', 0, 3.14, 1.57);\n    assert($result3[0]['x'] == 0 && $result3[0]['f_x'] == 0);\n    assert(abs($result3[1]['f_x'] - 1) < 0.0001); // Approximately 1\n    assert(abs($result3[2]['f_x'] - 0) < 0.002); // Approximately 0\n\n    // Test case 4: 1 / x from -1 to 1 with step 1\n    $result4 = evaluate_function('1 / x', -1, 1, 1);\n    assert($result4[0]['x'] == -1 && $result4[0]['f_x'] == -1);\n    assert(is_infinite($result4[1]['f_x'])); // Division by zero\n    assert($result4[2]['x'] == 1 && $result4[2]['f_x'] == 1);\n}\n\ntestEvaluateFunction();\n?>\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "<?php\n\nfunction generate_train_sequences($n) {\n    $results = [];\n    \n    $backtrack = function($stack, $next_push, $current_seq) use (&$backtrack, &$results, $n) {\n        if (count($current_seq) == $n) {\n            $results[] = implode('', $current_seq);\n            return;\n        }\n        if ($next_push < $n) {\n            $new_stack = $stack;\n            $new_stack[] = $next_push + 1;\n            $backtrack($new_stack, $next_push + 1, $current_seq);\n        }\n        if (!empty($stack)) {\n            $popped = array_pop($stack);\n            $new_current_seq = $current_seq;\n            $new_current_seq[] = $popped;\n            $backtrack($stack, $next_push, $new_current_seq);\n        }\n    };\n    \n    $backtrack([], 0, []);\n    sort($results);\n    return $results;\n}", "test_cases": "", "test_case_results": "Input (n): 3\nFirst 20 sequences (sorted):\n123\n132\n213\n231\n321", "task_id": 27616, "assertions": "<?php\n\nfunction testGenerateTrainSequences() {\n    $expected = ['123', '132', '213', '231', '321'];\n    $actual = generate_train_sequences(3);\n    assert($actual === $expected);\n    \n    // Test with n=1\n    $expected = ['1'];\n    $actual = generate_train_sequences(1);\n    assert($actual === $expected);\n    \n    // Test with n=2\n    $expected = ['12', '21'];\n    $actual = generate_train_sequences(2);\n    assert($actual === $expected);\n}\n\ntestGenerateTrainSequences();", "all_code": "<?php\n\nfunction generate_train_sequences($n) {\n    $results = [];\n    \n    $backtrack = function($stack, $next_push, $current_seq) use (&$backtrack, &$results, $n) {\n        if (count($current_seq) == $n) {\n            $results[] = implode('', $current_seq);\n            return;\n        }\n        if ($next_push < $n) {\n            $new_stack = $stack;\n            $new_stack[] = $next_push + 1;\n            $backtrack($new_stack, $next_push + 1, $current_seq);\n        }\n        if (!empty($stack)) {\n            $popped = array_pop($stack);\n            $new_current_seq = $current_seq;\n            $new_current_seq[] = $popped;\n            $backtrack($stack, $next_push, $new_current_seq);\n        }\n    };\n    \n    $backtrack([], 0, []);\n    sort($results);\n    return $results;\n}\nfunction testGenerateTrainSequences() {\n    $expected = ['123', '132', '213', '231', '321'];\n    $actual = generate_train_sequences(3);\n    assert($actual === $expected);\n    \n    // Test with n=1\n    $expected = ['1'];\n    $actual = generate_train_sequences(1);\n    assert($actual === $expected);\n    \n    // Test with n=2\n    $expected = ['12', '21'];\n    $actual = generate_train_sequences(2);\n    assert($actual === $expected);\n}\n\ntestGenerateTrainSequences();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// check_ticket_coverage checks if all numbers from 1 to 49 are present in the given set of numbers.\n// It returns \"Yes\" if all numbers are present, otherwise \"No\".\nfunction check_ticket_coverage($numbers) {\n    for ($i = 1; $i <= 49; $i++) {\n        if (!in_array($i, $numbers)) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\n?>", "test_cases": "", "test_case_results": "Input N: 2\nNumbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49\nResult: Yes\nInput N: 2\nNumbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48\nResult: No\nInput N: 1\nNumbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49\nResult: Yes\nInput N: 3\nNumbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47\nResult: No", "task_id": 15130, "assertions": "<?php\nfunction testCheckTicketCoverage() {\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) === \"Yes\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48]) === \"No\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) === \"Yes\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) === \"No\");\n}\n\ntestCheckTicketCoverage();\n?>", "all_code": "<?php\n// check_ticket_coverage checks if all numbers from 1 to 49 are present in the given set of numbers.\n// It returns \"Yes\" if all numbers are present, otherwise \"No\".\nfunction check_ticket_coverage($numbers) {\n    for ($i = 1; $i <= 49; $i++) {\n        if (!in_array($i, $numbers)) {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}\nfunction testCheckTicketCoverage() {\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) === \"Yes\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48]) === \"No\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49]) === \"Yes\");\n    assert(check_ticket_coverage([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]) === \"No\");\n}\n\ntestCheckTicketCoverage();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// find_number_of_provinces calculates the number of provinces in a given adjacency matrix.\n// A province is a group of directly or indirectly connected cities.\n// The function uses Breadth-First Search (BFS) to traverse the graph.\nfunction find_number_of_provinces($isConnected) {\n    $n = count($isConnected);\n    if ($n == 0) {\n        return 0;\n    }\n    $visited = array_fill(0, $n, false);\n    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!$visited[$i]) {\n            $count++;\n            $queue = new SplQueue();\n            $queue->enqueue($i);\n            $visited[$i] = true;\n            while (!$queue->isEmpty()) {\n                $u = $queue->dequeue();\n                for ($v = 0; $v < $n; $v++) {\n                    if ($isConnected[$u][$v] == 1 && !$visited[$v]) {\n                        $visited[$v] = true;\n                        $queue->enqueue($v);\n                    }\n                }\n            }\n        }\n    }\n    return $count;\n}\n?>", "test_cases": "", "test_case_results": "Input Matrix:\n[1, 1, 0]\n[1, 1, 0]\n[0, 0, 1]\nNumber of Provinces: 2\n\nInput Matrix:\n[1, 0, 0]\n[0, 1, 0]\n[0, 0, 1]\nNumber of Provinces: 3\n\nInput Matrix:\n[1, 1, 1]\n[1, 1, 1]\n[1, 1, 1]\nNumber of Provinces: 1", "task_id": 27699, "assertions": "<?php\n\nfunction testFindNumberOfProvinces() {\n    assert(find_number_of_provinces([\n        [1, 1, 0],\n        [1, 1, 0],\n        [0, 0, 1]\n    ]) === 2);\n    \n    assert(find_number_of_provinces([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]) === 3);\n    \n    assert(find_number_of_provinces([\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]) === 1);\n}\n\ntestFindNumberOfProvinces();\n?>", "all_code": "<?php\n// find_number_of_provinces calculates the number of provinces in a given adjacency matrix.\n// A province is a group of directly or indirectly connected cities.\n// The function uses Breadth-First Search (BFS) to traverse the graph.\nfunction find_number_of_provinces($isConnected) {\n    $n = count($isConnected);\n    if ($n == 0) {\n        return 0;\n    }\n    $visited = array_fill(0, $n, false);\n    $count = 0;\n    for ($i = 0; $i < $n; $i++) {\n        if (!$visited[$i]) {\n            $count++;\n            $queue = new SplQueue();\n            $queue->enqueue($i);\n            $visited[$i] = true;\n            while (!$queue->isEmpty()) {\n                $u = $queue->dequeue();\n                for ($v = 0; $v < $n; $v++) {\n                    if ($isConnected[$u][$v] == 1 && !$visited[$v]) {\n                        $visited[$v] = true;\n                        $queue->enqueue($v);\n                    }\n                }\n            }\n        }\n    }\n    return $count;\n}\nfunction testFindNumberOfProvinces() {\n    assert(find_number_of_provinces([\n        [1, 1, 0],\n        [1, 1, 0],\n        [0, 0, 1]\n    ]) === 2);\n    \n    assert(find_number_of_provinces([\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]) === 3);\n    \n    assert(find_number_of_provinces([\n        [1, 1, 1],\n        [1, 1, 1],\n        [1, 1, 1]\n    ]) === 1);\n}\n\ntestFindNumberOfProvinces();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// has_unique_characters checks if all characters in a given word are unique.\n// It returns true if all characters are unique, false otherwise.\nfunction has_unique_characters($word) {\n    $characters = str_split($word);\n    $unique_characters = array_unique($characters);\n    return count($characters) == count($unique_characters);\n}\n\n// find_longest_string_without_repeating_characters finds the longest string in an array\n// where all characters are unique. If there are no such strings, it returns an empty string.\nfunction find_longest_string_without_repeating_characters($words) {\n    $longest_word = \"\";\n    foreach ($words as $word) {\n        if (has_unique_characters($word)) {\n            if (strlen($word) > strlen($longest_word)) {\n                $longest_word = $word;\n            }\n        }\n    }\n    return $longest_word;\n}", "test_cases": "", "test_case_results": "Input: [abc, def, ghij, klmno]\nLongest string with unique characters: klmno\nInput: [aabb, ccdd, eeff, gg]\nLongest string with unique characters: \nInput: [unique, characters, test]\nLongest string with unique characters: \nInput: [hello, world, php]\nLongest string with unique characters: world", "task_id": 5440, "assertions": "<?php\n\nfunction testFindLongestStringWithoutRepeatingCharacters() {\n    assert(find_longest_string_without_repeating_characters([\"abc\", \"def\", \"ghij\", \"klmno\"]) === \"klmno\");\n    assert(find_longest_string_without_repeating_characters([\"aabb\", \"ccdd\", \"eeff\", \"gg\"]) === \"\");\n    assert(find_longest_string_without_repeating_characters([\"unique\", \"characters\", \"test\"]) === \"\");\n    assert(find_longest_string_without_repeating_characters([\"hello\", \"world\", \"php\"]) === \"world\");\n}\n\ntestFindLongestStringWithoutRepeatingCharacters();", "all_code": "<?php\n// has_unique_characters checks if all characters in a given word are unique.\n// It returns true if all characters are unique, false otherwise.\nfunction has_unique_characters($word) {\n    $characters = str_split($word);\n    $unique_characters = array_unique($characters);\n    return count($characters) == count($unique_characters);\n}\n\n// find_longest_string_without_repeating_characters finds the longest string in an array\n// where all characters are unique. If there are no such strings, it returns an empty string.\nfunction find_longest_string_without_repeating_characters($words) {\n    $longest_word = \"\";\n    foreach ($words as $word) {\n        if (has_unique_characters($word)) {\n            if (strlen($word) > strlen($longest_word)) {\n                $longest_word = $word;\n            }\n        }\n    }\n    return $longest_word;\n}\nfunction testFindLongestStringWithoutRepeatingCharacters() {\n    assert(find_longest_string_without_repeating_characters([\"abc\", \"def\", \"ghij\", \"klmno\"]) === \"klmno\");\n    assert(find_longest_string_without_repeating_characters([\"aabb\", \"ccdd\", \"eeff\", \"gg\"]) === \"\");\n    assert(find_longest_string_without_repeating_characters([\"unique\", \"characters\", \"test\"]) === \"\");\n    assert(find_longest_string_without_repeating_characters([\"hello\", \"world\", \"php\"]) === \"world\");\n}\n\ntestFindLongestStringWithoutRepeatingCharacters();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// powers_of_two_sum finds all unique combinations of powers of two that sum up to a given number n.\n// The powers of two are generated up to the largest power less than or equal to n.\n// The function uses backtracking to explore all possible combinations.\nfunction powers_of_two_sum($n) {\n    $powers = [];\n    $power = 1;\n    // Generate all powers of two up to n\n    while ($power <= $n) {\n        $powers[] = $power;\n        $power *= 2;\n    }\n\n    $result = [];\n    // Define the backtracking function within the scope\n    $backtrack = function($target, $start, $path, &$result) use ($powers, &$backtrack) {\n        if ($target == 0) {\n            $result[] = $path;\n            return;\n        }\n        for ($i = $start; $i < count($powers); $i++) {\n            if ($powers[$i] > $target) {\n                break;\n            }\n            $path[] = $powers[$i];\n            $backtrack($target - $powers[$i], $i + 1, $path, $result);\n            array_pop($path);\n        }\n    };\n\n    $backtrack($n, 0, [], $result);\n    // Sort the result for consistent output\n    usort($result, function($a, $b) {\n        if (count($a) != count($b)) {\n            return count($a) - count($b);\n        }\n        for ($i = 0; $i < count($a); $i++) {\n            if ($a[$i] != $b[$i]) {\n                return $a[$i] - $b[$i];\n            }\n        }\n        return 0;\n    });\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input: 5\nCombinations: [[1, 4]]\nInput: 10\nCombinations: [[2, 8]]\nInput: 15\nCombinations: [[1, 2, 4, 8]]", "task_id": 24241, "assertions": "<?php\n\nfunction testPowersOfTwoSum() {\n    assert(powers_of_two_sum(5) === [[1, 4]]);\n    assert(powers_of_two_sum(10) === [[2, 8]]);\n    assert(powers_of_two_sum(15) === [[1, 2, 4, 8]]);\n}\n\ntestPowersOfTwoSum();\n?>", "all_code": "<?php\n// powers_of_two_sum finds all unique combinations of powers of two that sum up to a given number n.\n// The powers of two are generated up to the largest power less than or equal to n.\n// The function uses backtracking to explore all possible combinations.\nfunction powers_of_two_sum($n) {\n    $powers = [];\n    $power = 1;\n    // Generate all powers of two up to n\n    while ($power <= $n) {\n        $powers[] = $power;\n        $power *= 2;\n    }\n\n    $result = [];\n    // Define the backtracking function within the scope\n    $backtrack = function($target, $start, $path, &$result) use ($powers, &$backtrack) {\n        if ($target == 0) {\n            $result[] = $path;\n            return;\n        }\n        for ($i = $start; $i < count($powers); $i++) {\n            if ($powers[$i] > $target) {\n                break;\n            }\n            $path[] = $powers[$i];\n            $backtrack($target - $powers[$i], $i + 1, $path, $result);\n            array_pop($path);\n        }\n    };\n\n    $backtrack($n, 0, [], $result);\n    // Sort the result for consistent output\n    usort($result, function($a, $b) {\n        if (count($a) != count($b)) {\n            return count($a) - count($b);\n        }\n        for ($i = 0; $i < count($a); $i++) {\n            if ($a[$i] != $b[$i]) {\n                return $a[$i] - $b[$i];\n            }\n        }\n        return 0;\n    });\n    return $result;\n}\nfunction testPowersOfTwoSum() {\n    assert(powers_of_two_sum(5) === [[1, 4]]);\n    assert(powers_of_two_sum(10) === [[2, 8]]);\n    assert(powers_of_two_sum(15) === [[1, 2, 4, 8]]);\n}\n\ntestPowersOfTwoSum();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_score computes the score based on the given input N according to specific rules:\n// - If N is 10 or less, the score is N multiplied by 6.\n// - If N is between 11 and 20, the score is 60 plus (N - 10) multiplied by 2.\n// - If N is between 21 and 40, the score is 80 plus (N - 20) multiplied by 1.\n// - If N is greater than 40, the score is 100.\nfunction calculate_score($N) {\n    if ($N <= 10) {\n        return $N * 6;\n    } elseif ($N <= 20) {\n        return 60 + ($N - 10) * 2;\n    } elseif ($N <= 40) {\n        return 80 + ($N - 20) * 1;\n    } else {\n        return 100;\n    }\n}\n?>", "test_cases": "", "test_case_results": "Input: 10\nScore: 60\nInput: 40\nScore: 100\nInput: 60\nScore: 100\nInput: 100\nScore: 100", "task_id": 4903, "assertions": "<?php\nfunction testCalculateScore() {\n    assert(calculate_score(10) === 60);\n    assert(calculate_score(40) === 100);\n    assert(calculate_score(60) === 100);\n    assert(calculate_score(100) === 100);\n    // Additional edge cases\n    assert(calculate_score(0) === 0);\n    assert(calculate_score(11) === 62);\n    assert(calculate_score(20) === 80);\n    assert(calculate_score(21) === 81);\n}\n\ntestCalculateScore();\n?>", "all_code": "<?php\n// calculate_score computes the score based on the given input N according to specific rules:\n// - If N is 10 or less, the score is N multiplied by 6.\n// - If N is between 11 and 20, the score is 60 plus (N - 10) multiplied by 2.\n// - If N is between 21 and 40, the score is 80 plus (N - 20) multiplied by 1.\n// - If N is greater than 40, the score is 100.\nfunction calculate_score($N) {\n    if ($N <= 10) {\n        return $N * 6;\n    } elseif ($N <= 20) {\n        return 60 + ($N - 10) * 2;\n    } elseif ($N <= 40) {\n        return 80 + ($N - 20) * 1;\n    } else {\n        return 100;\n    }\n}\nfunction testCalculateScore() {\n    assert(calculate_score(10) === 60);\n    assert(calculate_score(40) === 100);\n    assert(calculate_score(60) === 100);\n    assert(calculate_score(100) === 100);\n    // Additional edge cases\n    assert(calculate_score(0) === 0);\n    assert(calculate_score(11) === 62);\n    assert(calculate_score(20) === 80);\n    assert(calculate_score(21) === 81);\n}\n\ntestCalculateScore();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// count_symmetrical_pairs calculates the number of symmetrical pairs in a grid for both vertical and horizontal symmetry.\n// It returns the maximum count of symmetrical pairs between the two symmetry checks.\n// Parameters:\n// - $n: The size of the grid (n x n).\n// - $grid: A 2D array representing the grid.\nfunction count_symmetrical_pairs($n, $grid) {\n    $vertical_symmetric_pairs = 0;\n    $horizontal_symmetric_pairs = 0;\n    \n    // Check for vertical symmetry\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < intval($n / 2); $j++) {\n            if ($grid[$i][$j] == $grid[$i][$n - $j - 1]) {\n                $vertical_symmetric_pairs++;\n            }\n        }\n    }\n    \n    // Check for horizontal symmetry\n    for ($i = 0; $i < intval($n / 2); $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] == $grid[$n - $i - 1][$j]) {\n                $horizontal_symmetric_pairs++;\n            }\n        }\n    }\n    \n    // Return the maximum of the two counts\n    return max($vertical_symmetric_pairs, $horizontal_symmetric_pairs);\n}\n?>", "test_cases": "", "test_case_results": "Input Grid:\nAABA\nBAAB\nBBAA\nABBB\nNumber of symmetrical pairs: 4\n\nInput Grid:\nABC\nDEF\nGHI\nNumber of symmetrical pairs: 0\n\nInput Grid:\nAA\nAA\nNumber of symmetrical pairs: 2", "task_id": 16084, "assertions": "<?php\nfunction testCountSymmetricalPairs() {\n    // Test case 1\n    $grid1 = [\n        \"AABA\",\n        \"BAAB\",\n        \"BBAA\",\n        \"ABBB\"\n    ];\n    assert(count_symmetrical_pairs(4, $grid1) === 4);\n\n    // Test case 2\n    $grid2 = [\n        \"ABC\",\n        \"DEF\",\n        \"GHI\"\n    ];\n    assert(count_symmetrical_pairs(3, $grid2) === 0);\n\n    // Test case 3\n    $grid3 = [\n        \"AA\",\n        \"AA\"\n    ];\n    assert(count_symmetrical_pairs(2, $grid3) === 2);\n}\n\ntestCountSymmetricalPairs();\n?>", "all_code": "<?php\n// count_symmetrical_pairs calculates the number of symmetrical pairs in a grid for both vertical and horizontal symmetry.\n// It returns the maximum count of symmetrical pairs between the two symmetry checks.\n// Parameters:\n// - $n: The size of the grid (n x n).\n// - $grid: A 2D array representing the grid.\nfunction count_symmetrical_pairs($n, $grid) {\n    $vertical_symmetric_pairs = 0;\n    $horizontal_symmetric_pairs = 0;\n    \n    // Check for vertical symmetry\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < intval($n / 2); $j++) {\n            if ($grid[$i][$j] == $grid[$i][$n - $j - 1]) {\n                $vertical_symmetric_pairs++;\n            }\n        }\n    }\n    \n    // Check for horizontal symmetry\n    for ($i = 0; $i < intval($n / 2); $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($grid[$i][$j] == $grid[$n - $i - 1][$j]) {\n                $horizontal_symmetric_pairs++;\n            }\n        }\n    }\n    \n    // Return the maximum of the two counts\n    return max($vertical_symmetric_pairs, $horizontal_symmetric_pairs);\n}\nfunction testCountSymmetricalPairs() {\n    // Test case 1\n    $grid1 = [\n        \"AABA\",\n        \"BAAB\",\n        \"BBAA\",\n        \"ABBB\"\n    ];\n    assert(count_symmetrical_pairs(4, $grid1) === 4);\n\n    // Test case 2\n    $grid2 = [\n        \"ABC\",\n        \"DEF\",\n        \"GHI\"\n    ];\n    assert(count_symmetrical_pairs(3, $grid2) === 0);\n\n    // Test case 3\n    $grid3 = [\n        \"AA\",\n        \"AA\"\n    ];\n    assert(count_symmetrical_pairs(2, $grid3) === 2);\n}\n\ntestCountSymmetricalPairs();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// max_area calculates the maximum amount of water trapped between two buildings.\n// The function takes an array of integers where each integer represents the height of a building.\n// It uses a two-pointer approach to efficiently find the pair of buildings that can trap the most water.\nfunction max_area($heights) {\n    if (count($heights) < 2) {\n        return 0;  // If less than two buildings, no water can be trapped.\n    }\n    \n    $left = 0;\n    $right = count($heights) - 1;\n    $max_water = 0;\n    \n    while ($left < $right) {\n        $height = min($heights[$left], $heights[$right]);\n        $width = $right - $left;\n        $current_water = $height * $width;\n        $max_water = max($max_water, $current_water);\n        \n        // Move the pointers to try and find a better pair\n        if ($heights[$left] < $heights[$right]) {\n            $left++;\n        } else {\n            $right--;\n        }\n    }\n    \n    return $max_water;\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 8, 6, 2, 5, 4, 8, 3, 7]\nMaximum water trapped: 49\nInput: [1, 1]\nMaximum water trapped: 1\nInput: [4, 3, 2, 1, 4]\nMaximum water trapped: 16\nInput: [1, 2, 1]\nMaximum water trapped: 2", "task_id": 26424, "assertions": "<?php\n\nfunction testMaxArea() {\n    assert(max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) === 49);\n    assert(max_area([1, 1]) === 1);\n    assert(max_area([4, 3, 2, 1, 4]) === 16);\n    assert(max_area([1, 2, 1]) === 2);\n}\n\ntestMaxArea();", "all_code": "<?php\n// max_area calculates the maximum amount of water trapped between two buildings.\n// The function takes an array of integers where each integer represents the height of a building.\n// It uses a two-pointer approach to efficiently find the pair of buildings that can trap the most water.\nfunction max_area($heights) {\n    if (count($heights) < 2) {\n        return 0;  // If less than two buildings, no water can be trapped.\n    }\n    \n    $left = 0;\n    $right = count($heights) - 1;\n    $max_water = 0;\n    \n    while ($left < $right) {\n        $height = min($heights[$left], $heights[$right]);\n        $width = $right - $left;\n        $current_water = $height * $width;\n        $max_water = max($max_water, $current_water);\n        \n        // Move the pointers to try and find a better pair\n        if ($heights[$left] < $heights[$right]) {\n            $left++;\n        } else {\n            $right--;\n        }\n    }\n    \n    return $max_water;\n}\nfunction testMaxArea() {\n    assert(max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) === 49);\n    assert(max_area([1, 1]) === 1);\n    assert(max_area([4, 3, 2, 1, 4]) === 16);\n    assert(max_area([1, 2, 1]) === 2);\n}\n\ntestMaxArea();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// find_consecutive_ranges identifies consecutive integer ranges in an array of numbers.\n// It sorts the input array and then groups consecutive numbers into ranges.\n// Each range is represented as an array with 'start' and 'end' values.\nfunction find_consecutive_ranges($nums) {\n    if (empty($nums)) {\n        return [];\n    }\n\n    sort($nums);\n    $ranges = [];\n    $current_start = $nums[0];\n    $current_end = $current_start;\n\n    for ($i = 1; $i < count($nums); $i++) {\n        $num = $nums[$i];\n        if ($num == $current_end + 1) {\n            $current_end = $num;\n        } else {\n            $ranges[] = ['start' => $current_start, 'end' => $current_end];\n            $current_start = $num;\n            $current_end = $num;\n        }\n    }\n    $ranges[] = ['start' => $current_start, 'end' => $current_end];\n\n    return $ranges;\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 5, 6, 8, 9, 10]\nRanges:\nfor (int i = 1; i <= 3; i++) echo i . \" \"; \nfor (int i = 5; i <= 6; i++) echo i . \" \"; \nfor (int i = 8; i <= 10; i++) echo i . \" \"; \n\nInput: [4, 7, 10, 11, 12]\nRanges:\nfor (int i = 4; i <= 4; i++) echo i . \" \"; \nfor (int i = 7; i <= 7; i++) echo i . \" \"; \nfor (int i = 10; i <= 12; i++) echo i . \" \"; \n\nInput: [1, 3, 5, 7]\nRanges:\nfor (int i = 1; i <= 1; i++) echo i . \" \"; \nfor (int i = 3; i <= 3; i++) echo i . \" \"; \nfor (int i = 5; i <= 5; i++) echo i . \" \"; \nfor (int i = 7; i <= 7; i++) echo i . \" \"; \n\nInput: []\nNo ranges found (empty input)", "task_id": 2295, "assertions": "<?php\n\nfunction testFindConsecutiveRanges() {\n    assert(find_consecutive_ranges([1, 2, 3, 5, 6, 8, 9, 10]) === [\n        ['start' => 1, 'end' => 3],\n        ['start' => 5, 'end' => 6],\n        ['start' => 8, 'end' => 10]\n    ]);\n    assert(find_consecutive_ranges([4, 7, 10, 11, 12]) === [\n        ['start' => 4, 'end' => 4],\n        ['start' => 7, 'end' => 7],\n        ['start' => 10, 'end' => 12]\n    ]);\n    assert(find_consecutive_ranges([1, 3, 5, 7]) === [\n        ['start' => 1, 'end' => 1],\n        ['start' => 3, 'end' => 3],\n        ['start' => 5, 'end' => 5],\n        ['start' => 7, 'end' => 7]\n    ]);\n    assert(find_consecutive_ranges([]) === []);\n}\n\ntestFindConsecutiveRanges();\n?>", "all_code": "<?php\n// find_consecutive_ranges identifies consecutive integer ranges in an array of numbers.\n// It sorts the input array and then groups consecutive numbers into ranges.\n// Each range is represented as an array with 'start' and 'end' values.\nfunction find_consecutive_ranges($nums) {\n    if (empty($nums)) {\n        return [];\n    }\n\n    sort($nums);\n    $ranges = [];\n    $current_start = $nums[0];\n    $current_end = $current_start;\n\n    for ($i = 1; $i < count($nums); $i++) {\n        $num = $nums[$i];\n        if ($num == $current_end + 1) {\n            $current_end = $num;\n        } else {\n            $ranges[] = ['start' => $current_start, 'end' => $current_end];\n            $current_start = $num;\n            $current_end = $num;\n        }\n    }\n    $ranges[] = ['start' => $current_start, 'end' => $current_end];\n\n    return $ranges;\n}\nfunction testFindConsecutiveRanges() {\n    assert(find_consecutive_ranges([1, 2, 3, 5, 6, 8, 9, 10]) === [\n        ['start' => 1, 'end' => 3],\n        ['start' => 5, 'end' => 6],\n        ['start' => 8, 'end' => 10]\n    ]);\n    assert(find_consecutive_ranges([4, 7, 10, 11, 12]) === [\n        ['start' => 4, 'end' => 4],\n        ['start' => 7, 'end' => 7],\n        ['start' => 10, 'end' => 12]\n    ]);\n    assert(find_consecutive_ranges([1, 3, 5, 7]) === [\n        ['start' => 1, 'end' => 1],\n        ['start' => 3, 'end' => 3],\n        ['start' => 5, 'end' => 5],\n        ['start' => 7, 'end' => 7]\n    ]);\n    assert(find_consecutive_ranges([]) === []);\n}\n\ntestFindConsecutiveRanges();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * SessionManager class manages sessions with expiry times.\n * It provides functionality to create sessions, retrieve session data, and clean up expired sessions.\n */\nclass SessionManager {\n    private $sessions;\n    private $expiryQueue;\n\n    public function __construct() {\n        $this->sessions = array();\n        $this->expiryQueue = new SplPriorityQueue();\n        $this->expiryQueue->setExtractFlags(SplPriorityQueue::EXTR_BOTH);\n    }\n\n    /**\n     * Creates a new session with the given session ID, data, and duration.\n     * \n     * @param string $sessionId The ID of the session.\n     * @param mixed $data The data to be stored in the session.\n     * @param int $duration The duration (in seconds) for which the session is valid.\n     */\n    public function create_session($sessionId, $data, $duration) {\n        $expiryTime = time() + $duration;\n        $this->sessions[$sessionId] = array('data' => $data, 'expiry_time' => $expiryTime);\n        $this->expiryQueue->insert($sessionId, -$expiryTime); // Using negative to simulate min-heap\n    }\n\n    /**\n     * Retrieves the session data for the given session ID.\n     * Automatically cleans up expired sessions before retrieval.\n     * \n     * @param string $sessionId The ID of the session.\n     * @return mixed|null The session data if the session exists and is not expired, otherwise null.\n     */\n    public function get_session_data($sessionId) {\n        $currentTime = time();\n        $this->cleanup_sessions($currentTime);\n        return isset($this->sessions[$sessionId]) ? $this->sessions[$sessionId]['data'] : null;\n    }\n\n    /**\n     * Cleans up all sessions that have expired up to the given current time.\n     * \n     * @param int $currentTime The current time in seconds since the Unix epoch.\n     */\n    private function cleanup_sessions($currentTime) {\n        while (!$this->expiryQueue->isEmpty()) {\n            $top = $this->expiryQueue->top();\n            $expiryTime = -$top['priority']; // Retrieve original expiry time\n            $sessionId = $top['data'];\n\n            if ($expiryTime > $currentTime) {\n                break;\n            }\n\n            $this->expiryQueue->extract();\n            if (isset($this->sessions[$sessionId]) && $this->sessions[$sessionId]['expiry_time'] <= $currentTime) {\n                unset($this->sessions[$sessionId]);\n            }\n        }\n    }\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nInput: Create session 'session1' with data 'data1' and duration 5 seconds.\nRetrieve session 'session1' immediately: \"data1\"\n\nTest Case 2:\nInput: Create session 'session2' with data 'data2' and duration 1 second.\nRetrieve session 'session2' after 2 seconds: null\n\nTest Case 3:\nInput: Create sessions 'session3' (duration 3s) and 'session4' (duration 6s).\nRetrieve session 'session3' after 4 seconds: null\nRetrieve session 'session4' after 4 seconds: \"data4\"", "task_id": 1597, "assertions": "<?php\n\nfunction testSessionManager() {\n    $sessionManager = new SessionManager();\n    \n    // Test Case 1: Create a session and retrieve it before expiry\n    $sessionManager->create_session('session1', 'data1', 5);\n    assert($sessionManager->get_session_data('session1') === 'data1');\n    \n    // Test Case 2: Create a session and retrieve it after expiry\n    $sessionManager->create_session('session2', 'data2', 1);\n    sleep(2);\n    assert($sessionManager->get_session_data('session2') === null);\n    \n    // Test Case 3: Create multiple sessions and retrieve them\n    $sessionManager->create_session('session3', 'data3', 3);\n    $sessionManager->create_session('session4', 'data4', 6);\n    sleep(4);\n    assert($sessionManager->get_session_data('session3') === null);\n    assert($sessionManager->get_session_data('session4') === 'data4');\n}\n\ntestSessionManager();\n?>", "all_code": "<?php\n/**\n * SessionManager class manages sessions with expiry times.\n * It provides functionality to create sessions, retrieve session data, and clean up expired sessions.\n */\nclass SessionManager {\n    private $sessions;\n    private $expiryQueue;\n\n    public function __construct() {\n        $this->sessions = array();\n        $this->expiryQueue = new SplPriorityQueue();\n        $this->expiryQueue->setExtractFlags(SplPriorityQueue::EXTR_BOTH);\n    }\n\n    /**\n     * Creates a new session with the given session ID, data, and duration.\n     * \n     * @param string $sessionId The ID of the session.\n     * @param mixed $data The data to be stored in the session.\n     * @param int $duration The duration (in seconds) for which the session is valid.\n     */\n    public function create_session($sessionId, $data, $duration) {\n        $expiryTime = time() + $duration;\n        $this->sessions[$sessionId] = array('data' => $data, 'expiry_time' => $expiryTime);\n        $this->expiryQueue->insert($sessionId, -$expiryTime); // Using negative to simulate min-heap\n    }\n\n    /**\n     * Retrieves the session data for the given session ID.\n     * Automatically cleans up expired sessions before retrieval.\n     * \n     * @param string $sessionId The ID of the session.\n     * @return mixed|null The session data if the session exists and is not expired, otherwise null.\n     */\n    public function get_session_data($sessionId) {\n        $currentTime = time();\n        $this->cleanup_sessions($currentTime);\n        return isset($this->sessions[$sessionId]) ? $this->sessions[$sessionId]['data'] : null;\n    }\n\n    /**\n     * Cleans up all sessions that have expired up to the given current time.\n     * \n     * @param int $currentTime The current time in seconds since the Unix epoch.\n     */\n    private function cleanup_sessions($currentTime) {\n        while (!$this->expiryQueue->isEmpty()) {\n            $top = $this->expiryQueue->top();\n            $expiryTime = -$top['priority']; // Retrieve original expiry time\n            $sessionId = $top['data'];\n\n            if ($expiryTime > $currentTime) {\n                break;\n            }\n\n            $this->expiryQueue->extract();\n            if (isset($this->sessions[$sessionId]) && $this->sessions[$sessionId]['expiry_time'] <= $currentTime) {\n                unset($this->sessions[$sessionId]);\n            }\n        }\n    }\n}\nfunction testSessionManager() {\n    $sessionManager = new SessionManager();\n    \n    // Test Case 1: Create a session and retrieve it before expiry\n    $sessionManager->create_session('session1', 'data1', 5);\n    assert($sessionManager->get_session_data('session1') === 'data1');\n    \n    // Test Case 2: Create a session and retrieve it after expiry\n    $sessionManager->create_session('session2', 'data2', 1);\n    sleep(2);\n    assert($sessionManager->get_session_data('session2') === null);\n    \n    // Test Case 3: Create multiple sessions and retrieve them\n    $sessionManager->create_session('session3', 'data3', 3);\n    $sessionManager->create_session('session4', 'data4', 6);\n    sleep(4);\n    assert($sessionManager->get_session_data('session3') === null);\n    assert($sessionManager->get_session_data('session4') === 'data4');\n}\n\ntestSessionManager();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// The MOD constant is used for modular arithmetic operations.\ndefine('MOD', 10**9 + 7);\n\n// compute_modular_result calculates the result of a specific modular arithmetic operation for a given number.\n// The operation is defined as: (n^3 - n) * 111 mod MOD, where MOD is 10^9 + 7.\n// If the input number is 0, the result is 0.\nfunction compute_modular_result($n) {\n    if ($n == 0) {\n        return 0;\n    }\n    $n_mod = $n % MOD;\n    $ans = $n_mod * (($n_mod * $n_mod) % MOD - 1) % MOD;\n    $ans = $ans * 111 % MOD;\n    return $ans;\n}", "test_cases": "", "test_case_results": "Input: 0\nResult: 0\nInput: 1\nResult: 0\nInput: 2\nResult: 666\nInput: 3\nResult: 2664\nInput: 10\nResult: 109890\nInput: 100\nResult: 110988900\nInput: 1000\nResult: 999888230\nInput: 10000\nResult: 998113007\nInput: 100000\nResult: 211900007\nInput: 1000000\nResult: 889005446", "task_id": 10352, "assertions": "<?php\n\nfunction testComputeModularResult() {\n    assert(compute_modular_result(0) === 0);\n    assert(compute_modular_result(1) === 0);\n    assert(compute_modular_result(2) === 666);\n    assert(compute_modular_result(3) === 2664);\n    assert(compute_modular_result(10) === 109890);\n    assert(compute_modular_result(100) === 110988900);\n    assert(compute_modular_result(1000) === 999888230);\n    assert(compute_modular_result(10000) === 998113007);\n    assert(compute_modular_result(100000) === 211900007);\n    assert(compute_modular_result(1000000) === 889005446);\n}\n\ntestComputeModularResult();", "all_code": "<?php\n// The MOD constant is used for modular arithmetic operations.\ndefine('MOD', 10**9 + 7);\n\n// compute_modular_result calculates the result of a specific modular arithmetic operation for a given number.\n// The operation is defined as: (n^3 - n) * 111 mod MOD, where MOD is 10^9 + 7.\n// If the input number is 0, the result is 0.\nfunction compute_modular_result($n) {\n    if ($n == 0) {\n        return 0;\n    }\n    $n_mod = $n % MOD;\n    $ans = $n_mod * (($n_mod * $n_mod) % MOD - 1) % MOD;\n    $ans = $ans * 111 % MOD;\n    return $ans;\n}\nfunction testComputeModularResult() {\n    assert(compute_modular_result(0) === 0);\n    assert(compute_modular_result(1) === 0);\n    assert(compute_modular_result(2) === 666);\n    assert(compute_modular_result(3) === 2664);\n    assert(compute_modular_result(10) === 109890);\n    assert(compute_modular_result(100) === 110988900);\n    assert(compute_modular_result(1000) === 999888230);\n    assert(compute_modular_result(10000) === 998113007);\n    assert(compute_modular_result(100000) === 211900007);\n    assert(compute_modular_result(1000000) === 889005446);\n}\n\ntestComputeModularResult();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// find_highest_peak finds the highest peak in an n x n grid of integers.\n// A peak is defined as a position that is higher than or equal to all its 8-connected neighbors.\n//\n// Parameters:\n// $grid: A 2-dimensional array of integers representing the n x n grid.\n//\n// Returns:\n// An array [i, j] representing the coordinates of the highest peak.\nfunction find_highest_peak($grid) {\n    $n = count($grid);\n    $highest_peak = [-1, -1];\n    $highest_height = PHP_INT_MIN;\n    \n    // All 8 possible directions (up, down, left, right, and 4 diagonals)\n    $directions = [\n        [-1, 0], [1, 0], [0, -1], [0, 1],\n        [-1, -1], [-1, 1], [1, -1], [1, 1]\n    ];\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $is_peak = true;\n            foreach ($directions as $direction) {\n                $ni = $i + $direction[0];\n                $nj = $j + $direction[1];\n                if ($ni >= 0 && $ni < $n && $nj >= 0 && $nj < $n && $grid[$i][$j] < $grid[$ni][$nj]) {\n                    $is_peak = false;\n                    break;\n                }\n            }\n            if ($is_peak && $grid[$i][$j] > $highest_height) {\n                $highest_height = $grid[$i][$j];\n                $highest_peak = [$i, $j];\n            }\n        }\n    }\n    \n    return $highest_peak;\n}\n?>", "test_cases": "", "test_case_results": "Input Grid:\n1 2 3\n4 5 6\n7 8 9\nHighest Peak Coordinates: [2, 2]\n\nInput Grid:\n9 8 7\n6 5 4\n3 2 1\nHighest Peak Coordinates: [0, 0]\n\nInput Grid:\n1 1 1\n1 2 1\n1 1 1\nHighest Peak Coordinates: [1, 1]", "task_id": 14335, "assertions": "<?php\nfunction testFindHighestPeak() {\n    $test_cases = [\n        [\n            'input' => [\n                [1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]\n            ],\n            'expected' => [2, 2]\n        ],\n        [\n            'input' => [\n                [9, 8, 7],\n                [6, 5, 4],\n                [3, 2, 1]\n            ],\n            'expected' => [0, 0]\n        ],\n        [\n            'input' => [\n                [1, 1, 1],\n                [1, 2, 1],\n                [1, 1, 1]\n            ],\n            'expected' => [1, 1]\n        ]\n    ];\n\n    foreach ($test_cases as $test_case) {\n        $result = find_highest_peak($test_case['input']);\n        assert($result === $test_case['expected'], \"Test failed for input grid\");\n    }\n}\n\ntestFindHighestPeak();\n?>", "all_code": "<?php\n// find_highest_peak finds the highest peak in an n x n grid of integers.\n// A peak is defined as a position that is higher than or equal to all its 8-connected neighbors.\n//\n// Parameters:\n// $grid: A 2-dimensional array of integers representing the n x n grid.\n//\n// Returns:\n// An array [i, j] representing the coordinates of the highest peak.\nfunction find_highest_peak($grid) {\n    $n = count($grid);\n    $highest_peak = [-1, -1];\n    $highest_height = PHP_INT_MIN;\n    \n    // All 8 possible directions (up, down, left, right, and 4 diagonals)\n    $directions = [\n        [-1, 0], [1, 0], [0, -1], [0, 1],\n        [-1, -1], [-1, 1], [1, -1], [1, 1]\n    ];\n    \n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            $is_peak = true;\n            foreach ($directions as $direction) {\n                $ni = $i + $direction[0];\n                $nj = $j + $direction[1];\n                if ($ni >= 0 && $ni < $n && $nj >= 0 && $nj < $n && $grid[$i][$j] < $grid[$ni][$nj]) {\n                    $is_peak = false;\n                    break;\n                }\n            }\n            if ($is_peak && $grid[$i][$j] > $highest_height) {\n                $highest_height = $grid[$i][$j];\n                $highest_peak = [$i, $j];\n            }\n        }\n    }\n    \n    return $highest_peak;\n}\nfunction testFindHighestPeak() {\n    $test_cases = [\n        [\n            'input' => [\n                [1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]\n            ],\n            'expected' => [2, 2]\n        ],\n        [\n            'input' => [\n                [9, 8, 7],\n                [6, 5, 4],\n                [3, 2, 1]\n            ],\n            'expected' => [0, 0]\n        ],\n        [\n            'input' => [\n                [1, 1, 1],\n                [1, 2, 1],\n                [1, 1, 1]\n            ],\n            'expected' => [1, 1]\n        ]\n    ];\n\n    foreach ($test_cases as $test_case) {\n        $result = find_highest_peak($test_case['input']);\n        assert($result === $test_case['expected'], \"Test failed for input grid\");\n    }\n}\n\ntestFindHighestPeak();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// has_hamiltonian_cycle checks if a given graph has a Hamiltonian cycle.\n// A Hamiltonian cycle is a cycle that visits every vertex exactly once and returns to the starting vertex.\n// Parameters:\n// - $n: Number of vertices in the graph.\n// - $m: Number of edges in the graph.\n// - $roads: Array of edges, where each edge is represented as an array of two vertices.\n// Returns: \"YES\" if a Hamiltonian cycle exists, otherwise \"NO\".\nfunction has_hamiltonian_cycle($n, $m, $roads) {\n    if ($m == 0) {\n        return \"NO\";\n    }\n\n    // Build the adjacency list for the graph\n    $graph = array();\n    for ($i = 1; $i <= $n; $i++) {\n        $graph[$i] = array();\n    }\n    foreach ($roads as $road) {\n        $u = $road[0];\n        $v = $road[1];\n        array_push($graph[$u], $v);\n        array_push($graph[$v], $u);\n    }\n\n    // Generate all possible permutations of vertices\n    $vertices = range(1, $n);\n    $perms = permute($vertices);\n\n    // Check each permutation for a Hamiltonian cycle\n    foreach ($perms as $perm) {\n        $is_hamiltonian = true;\n        $length = count($perm);\n        for ($i = 1; $i < $length; $i++) {\n            if (!in_array($perm[$i], $graph[$perm[$i - 1]])) {\n                $is_hamiltonian = false;\n                break;\n            }\n        }\n        if ($is_hamiltonian && in_array($perm[0], $graph[$perm[$length - 1]])) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\n// permute generates all possible permutations of an array.\n// This is a helper function for has_hamiltonian_cycle.\n// Parameters:\n// - $items: The array to permute.\n// Returns: An array of all permutations.\nfunction permute($items) {\n    if (count($items) <= 1) {\n        return array($items);\n    }\n\n    $perms = array();\n    $last = array_pop($items);\n    $permt = permute($items);\n\n    foreach ($permt as $p) {\n        for ($i = 0; $i <= count($p); $i++) {\n            $temp = $p;\n            array_splice($temp, $i, 0, $last);\n            array_push($perms, $temp);\n        }\n    }\n    return $perms;\n}\n?>", "test_cases": "", "test_case_results": "Input: n = 3, m = 3, roads = [[1, 2], [2, 3], [3, 1]]\nResult: YES\nInput: n = 4, m = 4, roads = [[1, 2], [2, 3], [3, 4], [4, 1]]\nResult: YES\nInput: n = 4, m = 3, roads = [[1, 2], [2, 3], [3, 4]]\nResult: NO\nInput: n = 5, m = 0, roads = []\nResult: NO", "task_id": 18822, "assertions": "<?php\nfunction testHasHamiltonianCycle() {\n    assert(has_hamiltonian_cycle(3, 3, [[1, 2], [2, 3], [3, 1]]) === \"YES\");\n    assert(has_hamiltonian_cycle(4, 4, [[1, 2], [2, 3], [3, 4], [4, 1]]) === \"YES\");\n    assert(has_hamiltonian_cycle(4, 3, [[1, 2], [2, 3], [3, 4]]) === \"NO\");\n    assert(has_hamiltonian_cycle(5, 0, []) === \"NO\");\n}\n\ntestHasHamiltonianCycle();\n?>", "all_code": "<?php\n// has_hamiltonian_cycle checks if a given graph has a Hamiltonian cycle.\n// A Hamiltonian cycle is a cycle that visits every vertex exactly once and returns to the starting vertex.\n// Parameters:\n// - $n: Number of vertices in the graph.\n// - $m: Number of edges in the graph.\n// - $roads: Array of edges, where each edge is represented as an array of two vertices.\n// Returns: \"YES\" if a Hamiltonian cycle exists, otherwise \"NO\".\nfunction has_hamiltonian_cycle($n, $m, $roads) {\n    if ($m == 0) {\n        return \"NO\";\n    }\n\n    // Build the adjacency list for the graph\n    $graph = array();\n    for ($i = 1; $i <= $n; $i++) {\n        $graph[$i] = array();\n    }\n    foreach ($roads as $road) {\n        $u = $road[0];\n        $v = $road[1];\n        array_push($graph[$u], $v);\n        array_push($graph[$v], $u);\n    }\n\n    // Generate all possible permutations of vertices\n    $vertices = range(1, $n);\n    $perms = permute($vertices);\n\n    // Check each permutation for a Hamiltonian cycle\n    foreach ($perms as $perm) {\n        $is_hamiltonian = true;\n        $length = count($perm);\n        for ($i = 1; $i < $length; $i++) {\n            if (!in_array($perm[$i], $graph[$perm[$i - 1]])) {\n                $is_hamiltonian = false;\n                break;\n            }\n        }\n        if ($is_hamiltonian && in_array($perm[0], $graph[$perm[$length - 1]])) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\n// permute generates all possible permutations of an array.\n// This is a helper function for has_hamiltonian_cycle.\n// Parameters:\n// - $items: The array to permute.\n// Returns: An array of all permutations.\nfunction permute($items) {\n    if (count($items) <= 1) {\n        return array($items);\n    }\n\n    $perms = array();\n    $last = array_pop($items);\n    $permt = permute($items);\n\n    foreach ($permt as $p) {\n        for ($i = 0; $i <= count($p); $i++) {\n            $temp = $p;\n            array_splice($temp, $i, 0, $last);\n            array_push($perms, $temp);\n        }\n    }\n    return $perms;\n}\nfunction testHasHamiltonianCycle() {\n    assert(has_hamiltonian_cycle(3, 3, [[1, 2], [2, 3], [3, 1]]) === \"YES\");\n    assert(has_hamiltonian_cycle(4, 4, [[1, 2], [2, 3], [3, 4], [4, 1]]) === \"YES\");\n    assert(has_hamiltonian_cycle(4, 3, [[1, 2], [2, 3], [3, 4]]) === \"NO\");\n    assert(has_hamiltonian_cycle(5, 0, []) === \"NO\");\n}\n\ntestHasHamiltonianCycle();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Finds the nth repeated character in a string.\n *\n * @param string $s The input string to search.\n * @param int $n The occurrence rank of the repeated character (1-based index).\n * @return string|null The nth repeated character, or null if it doesn't exist.\n */\nfunction nth_repeated_char($s, $n) {\n    $char_count = [];\n    \n    // Count the occurrences of each character\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (array_key_exists($char, $char_count)) {\n            $char_count[$char]++;\n        } else {\n            $char_count[$char] = 1;\n        }\n    }\n    \n    // Find repeated characters (characters with count > 1)\n    $repeated_chars = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if ($char_count[$char] > 1) {\n            $repeated_chars[] = $char;\n        }\n    }\n    \n    // Filter unique characters from the repeated list while preserving order\n    $seen = [];\n    $result = [];\n    foreach ($repeated_chars as $char) {\n        if (!in_array($char, $seen)) {\n            $seen[] = $char;\n            $result[] = $char;\n        }\n    }\n    \n    // Return the nth repeated character if it exists\n    if (count($result) >= $n) {\n        return $result[$n - 1];\n    }\n    \n    return null;\n}\n?>", "test_cases": "", "test_case_results": "Input: 'aabbcc', n: 1\nResult: 'a'\nExpected: 'a'\n\nInput: 'aabbcc', n: 2\nResult: 'b'\nExpected: 'b'\n\nInput: 'aabbcc', n: 3\nResult: 'c'\nExpected: 'c'\n\nInput: 'aabbcc', n: 4\nResult: null\nExpected: null\n\nInput: 'abcabc', n: 1\nResult: 'a'\nExpected: 'a'\n\nInput: 'abcabc', n: 2\nResult: 'b'\nExpected: 'b'\n\nInput: 'abcabc', n: 3\nResult: 'c'\nExpected: 'c'\n\nInput: 'abcabc', n: 4\nResult: null\nExpected: null\n\nInput: 'abcdef', n: 1\nResult: null\nExpected: null\n\nInput: 'a', n: 1\nResult: null\nExpected: null\n\nInput: '', n: 1\nResult: null\nExpected: null", "task_id": 29108, "assertions": "<?php\n\nfunction testNthRepeatedChar() {\n    assert(nth_repeated_char(\"aabbcc\", 1) === \"a\");\n    assert(nth_repeated_char(\"aabbcc\", 2) === \"b\");\n    assert(nth_repeated_char(\"aabbcc\", 3) === \"c\");\n    assert(nth_repeated_char(\"aabbcc\", 4) === null);\n    assert(nth_repeated_char(\"abcabc\", 1) === \"a\");\n    assert(nth_repeated_char(\"abcabc\", 2) === \"b\");\n    assert(nth_repeated_char(\"abcabc\", 3) === \"c\");\n    assert(nth_repeated_char(\"abcabc\", 4) === null);\n    assert(nth_repeated_char(\"abcdef\", 1) === null);\n    assert(nth_repeated_char(\"a\", 1) === null);\n    assert(nth_repeated_char(\"\", 1) === null);\n}\n\ntestNthRepeatedChar();\n?>", "all_code": "<?php\n/**\n * Finds the nth repeated character in a string.\n *\n * @param string $s The input string to search.\n * @param int $n The occurrence rank of the repeated character (1-based index).\n * @return string|null The nth repeated character, or null if it doesn't exist.\n */\nfunction nth_repeated_char($s, $n) {\n    $char_count = [];\n    \n    // Count the occurrences of each character\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (array_key_exists($char, $char_count)) {\n            $char_count[$char]++;\n        } else {\n            $char_count[$char] = 1;\n        }\n    }\n    \n    // Find repeated characters (characters with count > 1)\n    $repeated_chars = [];\n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if ($char_count[$char] > 1) {\n            $repeated_chars[] = $char;\n        }\n    }\n    \n    // Filter unique characters from the repeated list while preserving order\n    $seen = [];\n    $result = [];\n    foreach ($repeated_chars as $char) {\n        if (!in_array($char, $seen)) {\n            $seen[] = $char;\n            $result[] = $char;\n        }\n    }\n    \n    // Return the nth repeated character if it exists\n    if (count($result) >= $n) {\n        return $result[$n - 1];\n    }\n    \n    return null;\n}\nfunction testNthRepeatedChar() {\n    assert(nth_repeated_char(\"aabbcc\", 1) === \"a\");\n    assert(nth_repeated_char(\"aabbcc\", 2) === \"b\");\n    assert(nth_repeated_char(\"aabbcc\", 3) === \"c\");\n    assert(nth_repeated_char(\"aabbcc\", 4) === null);\n    assert(nth_repeated_char(\"abcabc\", 1) === \"a\");\n    assert(nth_repeated_char(\"abcabc\", 2) === \"b\");\n    assert(nth_repeated_char(\"abcabc\", 3) === \"c\");\n    assert(nth_repeated_char(\"abcabc\", 4) === null);\n    assert(nth_repeated_char(\"abcdef\", 1) === null);\n    assert(nth_repeated_char(\"a\", 1) === null);\n    assert(nth_repeated_char(\"\", 1) === null);\n}\n\ntestNthRepeatedChar();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// calculate_max_polygon_area calculates the maximum area that can be formed by connecting two points in a polygon.\n// The polygon is defined by a list of points, and the function uses the shoelace formula to compute areas.\n// Parameters:\n// - $points: An array of tuples representing the coordinates of the polygon's vertices.\n// - $queries: An array of tuples representing pairs of indices (p, q) to test.\n// Returns the maximum area found.\nfunction calculate_max_polygon_area($points, $queries) {\n    $n = count($points);\n    $prefix = array_fill(0, $n + 1, 0);\n    \n    // Compute prefix sums using the shoelace formula\n    for ($i = 0; $i < $n; $i++) {\n        $x_i = $points[$i][0];\n        $y_i = $points[$i][1];\n        $next_i = ($i + 1) % $n;\n        $x_next = $points[$next_i][0];\n        $y_next = $points[$next_i][1];\n        $prefix[$i + 1] = $prefix[$i] + ($x_i * $y_next - $x_next * $y_i);\n    }\n    \n    $total_area = abs($prefix[$n]) / 2.0;\n    $max_area = 0.0;\n    \n    foreach ($queries as $query) {\n        $p = $query[0];\n        $q = $query[1];\n        $u = $p - 1;\n        $v = $q - 1;\n        \n        if ($u < $v) {\n            $cross = $prefix[$v] - $prefix[$u];\n        } else {\n            $cross = ($prefix[$n] - $prefix[$u]) + $prefix[$v];\n        }\n        \n        $cross_abs = abs($cross);\n        $min_area = min($cross_abs / 2.0, $total_area - $cross_abs / 2.0);\n        if ($min_area > $max_area) {\n            $max_area = $min_area;\n        }\n    }\n    \n    return $max_area;\n}\n?>", "test_cases": "", "test_case_results": "Test Case 1:\nPoints: (0, 0) (1, 0) (1, 1) (0, 1) \nQueries: (1, 3) (2, 4) \nMax Area: 0.500000\n\nTest Case 2:\nPoints: (0, 0) (2, 0) (2, 2) (0, 2) \nQueries: (1, 3) (2, 4) (1, 4) \nMax Area: 2.000000", "task_id": 27875, "assertions": "<?php\n\nfunction testCalculateMaxPolygonArea() {\n    $points1 = [\n        [0, 0],\n        [1, 0],\n        [1, 1],\n        [0, 1]\n    ];\n    $queries1 = [\n        [1, 3],\n        [2, 4]\n    ];\n    assert(calculate_max_polygon_area($points1, $queries1) == 0.5);\n\n    $points2 = [\n        [0, 0],\n        [2, 0],\n        [2, 2],\n        [0, 2]\n    ];\n    $queries2 = [\n        [1, 3],\n        [2, 4],\n        [1, 4]\n    ];\n    assert(calculate_max_polygon_area($points2, $queries2) == 2.0);\n}\n\ntestCalculateMaxPolygonArea();\n?>", "all_code": "<?php\n// calculate_max_polygon_area calculates the maximum area that can be formed by connecting two points in a polygon.\n// The polygon is defined by a list of points, and the function uses the shoelace formula to compute areas.\n// Parameters:\n// - $points: An array of tuples representing the coordinates of the polygon's vertices.\n// - $queries: An array of tuples representing pairs of indices (p, q) to test.\n// Returns the maximum area found.\nfunction calculate_max_polygon_area($points, $queries) {\n    $n = count($points);\n    $prefix = array_fill(0, $n + 1, 0);\n    \n    // Compute prefix sums using the shoelace formula\n    for ($i = 0; $i < $n; $i++) {\n        $x_i = $points[$i][0];\n        $y_i = $points[$i][1];\n        $next_i = ($i + 1) % $n;\n        $x_next = $points[$next_i][0];\n        $y_next = $points[$next_i][1];\n        $prefix[$i + 1] = $prefix[$i] + ($x_i * $y_next - $x_next * $y_i);\n    }\n    \n    $total_area = abs($prefix[$n]) / 2.0;\n    $max_area = 0.0;\n    \n    foreach ($queries as $query) {\n        $p = $query[0];\n        $q = $query[1];\n        $u = $p - 1;\n        $v = $q - 1;\n        \n        if ($u < $v) {\n            $cross = $prefix[$v] - $prefix[$u];\n        } else {\n            $cross = ($prefix[$n] - $prefix[$u]) + $prefix[$v];\n        }\n        \n        $cross_abs = abs($cross);\n        $min_area = min($cross_abs / 2.0, $total_area - $cross_abs / 2.0);\n        if ($min_area > $max_area) {\n            $max_area = $min_area;\n        }\n    }\n    \n    return $max_area;\n}\nfunction testCalculateMaxPolygonArea() {\n    $points1 = [\n        [0, 0],\n        [1, 0],\n        [1, 1],\n        [0, 1]\n    ];\n    $queries1 = [\n        [1, 3],\n        [2, 4]\n    ];\n    assert(calculate_max_polygon_area($points1, $queries1) == 0.5);\n\n    $points2 = [\n        [0, 0],\n        [2, 0],\n        [2, 2],\n        [0, 2]\n    ];\n    $queries2 = [\n        [1, 3],\n        [2, 4],\n        [1, 4]\n    ];\n    assert(calculate_max_polygon_area($points2, $queries2) == 2.0);\n}\n\ntestCalculateMaxPolygonArea();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * filter_strings returns an array of strings from the input array that contain at least one of the specified substrings.\n *\n * @param array $arr The input array of strings to be filtered.\n * @param array $substrings The array of substrings to check for in each string of $arr.\n * @return array The filtered array containing strings that include at least one of the substrings.\n */\nfunction filter_strings(array $arr, array $substrings): array {\n    $filtered_list = [];\n    foreach ($arr as $s) {\n        foreach ($substrings as $sub) {\n            if (strpos($s, $sub) !== false) {\n                $filtered_list[] = $s;\n                break;\n            }\n        }\n    }\n    return $filtered_list;\n}\n?>", "test_cases": "", "test_case_results": "Input Array: [apple, banana, cherry, date]\nSubstrings: [app, na]\nFiltered Results: [apple, banana]\n\nInput Array: [hello, world, php, python]\nSubstrings: [py, rl]\nFiltered Results: [world, python]\n\nInput Array: [cat, dog, fish, bird]\nSubstrings: [at, og]\nFiltered Results: [cat, dog]", "task_id": 11323, "assertions": "<?php\n\nfunction testFilterStrings() {\n    assert(filter_strings(['apple', 'banana', 'cherry', 'date'], ['app', 'na']) === ['apple', 'banana']);\n    assert(filter_strings(['hello', 'world', 'php', 'python'], ['py', 'rl']) === ['world', 'python']);\n    assert(filter_strings(['cat', 'dog', 'fish', 'bird'], ['at', 'og']) === ['cat', 'dog']);\n    assert(filter_strings([], ['any']) === []);\n    assert(filter_strings(['test'], []) === []);\n}\n\ntestFilterStrings();\n?>", "all_code": "<?php\n/**\n * filter_strings returns an array of strings from the input array that contain at least one of the specified substrings.\n *\n * @param array $arr The input array of strings to be filtered.\n * @param array $substrings The array of substrings to check for in each string of $arr.\n * @return array The filtered array containing strings that include at least one of the substrings.\n */\nfunction filter_strings(array $arr, array $substrings): array {\n    $filtered_list = [];\n    foreach ($arr as $s) {\n        foreach ($substrings as $sub) {\n            if (strpos($s, $sub) !== false) {\n                $filtered_list[] = $s;\n                break;\n            }\n        }\n    }\n    return $filtered_list;\n}\nfunction testFilterStrings() {\n    assert(filter_strings(['apple', 'banana', 'cherry', 'date'], ['app', 'na']) === ['apple', 'banana']);\n    assert(filter_strings(['hello', 'world', 'php', 'python'], ['py', 'rl']) === ['world', 'python']);\n    assert(filter_strings(['cat', 'dog', 'fish', 'bird'], ['at', 'og']) === ['cat', 'dog']);\n    assert(filter_strings([], ['any']) === []);\n    assert(filter_strings(['test'], []) === []);\n}\n\ntestFilterStrings();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Encodes the message using a shift cipher.\n * Shifts each letter in the message by the specified number of positions in the alphabet.\n *\n * @param string $message The message to be encoded.\n * @param int $shift The number of positions to shift each letter.\n * @return string The encoded message.\n */\nfunction shift_cipher(string $message, int $shift): string {\n    $encoded_message = [];\n    for ($i = 0; $i < strlen($message); $i++) {\n        $char = $message[$i];\n        $new_char = chr(((ord($char) - ord('a') + $shift) % 26) + ord('a'));\n        $encoded_message[] = $new_char;\n    }\n    return implode($encoded_message);\n}\n\n/**\n * Decodes the message encoded with a shift cipher.\n * Shifts each letter in the message back by the specified number of positions in the alphabet.\n *\n * @param string $message The message to be decoded.\n * @param int $shift The number of positions to shift each letter back.\n * @return string The decoded message.\n */\nfunction unshift_cipher(string $message, int $shift): string {\n    $decoded_message = [];\n    for ($i = 0; $i < strlen($message); $i++) {\n        $char = $message[$i];\n        $new_char = chr(((ord($char) - ord('a') - $shift) % 26) + ord('a'));\n        $decoded_message[] = $new_char;\n    }\n    return implode($decoded_message);\n}\n?>", "test_cases": "", "test_case_results": "Input Message: hello, Shift: 3\nEncoded Message: khoor\nDecoded Message: hello\n\nInput Message: world, Shift: 5\nEncoded Message: btwqi\nDecoded Message: ]orld\n\nInput Message: php, Shift: 10\nEncoded Message: zrz\nDecoded Message: php", "task_id": 11256, "assertions": "<?php\n\nfunction testShiftCipher() {\n    // Test case 1\n    $encoded1 = shift_cipher(\"hello\", 3);\n    $decoded1 = unshift_cipher($encoded1, 3);\n    assert($encoded1 === \"khoor\");\n    assert($decoded1 === \"hello\");\n\n    // Test case 2\n    $encoded2 = shift_cipher(\"world\", 5);\n    $decoded2 = unshift_cipher($encoded2, 5);\n    assert($encoded2 === \"btwqi\");\n    // Note: The original test case shows incorrect decoding for this case\n    // We'll use the correct expected value\n    assert($decoded2 === \"world\");\n\n    // Test case 3\n    $encoded3 = shift_cipher(\"php\", 10);\n    $decoded3 = unshift_cipher($encoded3, 10);\n    assert($encoded3 === \"zrz\");\n    assert($decoded3 === \"php\");\n}\n\ntestShiftCipher();\n?>", "all_code": "<?php\n/**\n * Encodes the message using a shift cipher.\n * Shifts each letter in the message by the specified number of positions in the alphabet.\n *\n * @param string $message The message to be encoded.\n * @param int $shift The number of positions to shift each letter.\n * @return string The encoded message.\n */\nfunction shift_cipher(string $message, int $shift): string {\n    $encoded_message = [];\n    for ($i = 0; $i < strlen($message); $i++) {\n        $char = $message[$i];\n        $new_char = chr(((ord($char) - ord('a') + $shift) % 26) + ord('a'));\n        $encoded_message[] = $new_char;\n    }\n    return implode($encoded_message);\n}\n\n/**\n * Decodes the message encoded with a shift cipher.\n * Shifts each letter in the message back by the specified number of positions in the alphabet.\n *\n * @param string $message The message to be decoded.\n * @param int $shift The number of positions to shift each letter back.\n * @return string The decoded message.\n */\nfunction unshift_cipher(string $message, int $shift): string {\n    $decoded_message = [];\n    for ($i = 0; $i < strlen($message); $i++) {\n        $char = $message[$i];\n        $new_char = chr(((ord($char) - ord('a') - $shift) % 26) + ord('a'));\n        $decoded_message[] = $new_char;\n    }\n    return implode($decoded_message);\n}\nfunction testShiftCipher() {\n    // Test case 1\n    $encoded1 = shift_cipher(\"hello\", 3);\n    $decoded1 = unshift_cipher($encoded1, 3);\n    assert($encoded1 === \"khoor\");\n    assert($decoded1 === \"hello\");\n\n    // Test case 2\n    $encoded2 = shift_cipher(\"world\", 5);\n    $decoded2 = unshift_cipher($encoded2, 5);\n    assert($encoded2 === \"btwqi\");\n    // Note: The original test case shows incorrect decoding for this case\n    // We'll use the correct expected value\n    assert($decoded2 === \"world\");\n\n    // Test case 3\n    $encoded3 = shift_cipher(\"php\", 10);\n    $decoded3 = unshift_cipher($encoded3, 10);\n    assert($encoded3 === \"zrz\");\n    assert($decoded3 === \"php\");\n}\n\ntestShiftCipher();\n?>\n", "exec_outcome": "RUNTIME_ERROR"}
{"code": "<?php\n// longest_subarray calculates the length of the longest contiguous subarray \n// that can be formed by deleting one element from the given array.\n// The array consists of binary values (0s and 1s), and the function returns\n// the maximum length of a subarray with all 1s after deleting at most one 0.\nfunction longest_subarray($nums) {\n    $zero_indices = array();\n    foreach ($nums as $i => $num) {\n        if ($num == 0) {\n            array_push($zero_indices, $i);\n        }\n    }\n    \n    if (empty($zero_indices)) {\n        return count($nums) - (count($nums) > 0 ? 1 : 0);\n    }\n    \n    array_unshift($zero_indices, -1);\n    array_push($zero_indices, count($nums));\n    \n    $max_length = 0;\n    for ($j = 1; $j < count($zero_indices) - 1; $j++) {\n        $i = $zero_indices[$j];\n        $prev = $zero_indices[$j - 1];\n        $next_i = $zero_indices[$j + 1];\n        $left = $i - $prev - 1;\n        $right = $next_i - $i - 1;\n        $current = $left + $right;\n        if ($current > $max_length) {\n            $max_length = $current;\n        }\n    }\n    return $max_length;\n}\n?>", "test_cases": "", "test_case_results": "Input: [1, 1, 0, 1]\nLongest subarray length: 3\nInput: [0, 1, 1, 1, 0, 1]\nLongest subarray length: 4\nInput: [1, 1, 1]\nLongest subarray length: 2\nInput: [0, 0, 0]\nLongest subarray length: 0\nInput: []\nLongest subarray length: 0", "task_id": 15790, "assertions": "<?php\nfunction testLongestSubarray() {\n    assert(longest_subarray([1, 1, 0, 1]) === 3);\n    assert(longest_subarray([0, 1, 1, 1, 0, 1]) === 4);\n    assert(longest_subarray([1, 1, 1]) === 2);\n    assert(longest_subarray([0, 0, 0]) === 0);\n    assert(longest_subarray([]) === 0);\n}\n\ntestLongestSubarray();\n?>", "all_code": "<?php\n// longest_subarray calculates the length of the longest contiguous subarray \n// that can be formed by deleting one element from the given array.\n// The array consists of binary values (0s and 1s), and the function returns\n// the maximum length of a subarray with all 1s after deleting at most one 0.\nfunction longest_subarray($nums) {\n    $zero_indices = array();\n    foreach ($nums as $i => $num) {\n        if ($num == 0) {\n            array_push($zero_indices, $i);\n        }\n    }\n    \n    if (empty($zero_indices)) {\n        return count($nums) - (count($nums) > 0 ? 1 : 0);\n    }\n    \n    array_unshift($zero_indices, -1);\n    array_push($zero_indices, count($nums));\n    \n    $max_length = 0;\n    for ($j = 1; $j < count($zero_indices) - 1; $j++) {\n        $i = $zero_indices[$j];\n        $prev = $zero_indices[$j - 1];\n        $next_i = $zero_indices[$j + 1];\n        $left = $i - $prev - 1;\n        $right = $next_i - $i - 1;\n        $current = $left + $right;\n        if ($current > $max_length) {\n            $max_length = $current;\n        }\n    }\n    return $max_length;\n}\nfunction testLongestSubarray() {\n    assert(longest_subarray([1, 1, 0, 1]) === 3);\n    assert(longest_subarray([0, 1, 1, 1, 0, 1]) === 4);\n    assert(longest_subarray([1, 1, 1]) === 2);\n    assert(longest_subarray([0, 0, 0]) === 0);\n    assert(longest_subarray([]) === 0);\n}\n\ntestLongestSubarray();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n/**\n * Checks if there exists a contiguous subarray of size k in nums\n * whose sum is greater than or equal to the average of the entire array nums.\n *\n * @param array $nums List of integers\n * @param int $k Size of the subarray\n * @return bool True if such a subarray exists, False otherwise\n */\nfunction has_subarray_with_sum_gte_average($nums, $k) {\n    $n = count($nums);\n    $total_sum = array_sum($nums);\n    $average = $total_sum / $n;\n\n    // Calculate initial window sum of the first k elements\n    $current_window_sum = array_sum(array_slice($nums, 0, $k));\n\n    // Check if the initial window sum is equal or greater than the average\n    if ($current_window_sum >= $average * $k) {\n        return true;\n    }\n\n    // Slide the window across the array and keep updating the window sum.\n    for ($i = $k; $i < $n; $i++) {\n        $current_window_sum += $nums[$i] - $nums[$i - $k];\n        if ($current_window_sum >= $average * $k) {\n            return true;\n        }\n    }\n\n    return false;\n}\n?>", "test_cases": "", "test_case_results": "Input nums: [1, 2, 3, 4], k: 2\nResult: true\nInput nums: [5, 6, 7, 0], k: 3\nResult: true\nInput nums: [0, 0, 0, 0], k: 2\nResult: true\nInput nums: [10, 20, 30, 40, 50], k: 1\nResult: true\nInput nums: [1, 1, 1, 1, 1], k: 5\nResult: true", "task_id": 2459, "assertions": "<?php\n\nfunction testHasSubarrayWithSumGteAverage() {\n    assert(has_subarray_with_sum_gte_average([1, 2, 3, 4], 2) === true);\n    assert(has_subarray_with_sum_gte_average([5, 6, 7, 0], 3) === true);\n    assert(has_subarray_with_sum_gte_average([0, 0, 0, 0], 2) === true);\n    assert(has_subarray_with_sum_gte_average([10, 20, 30, 40, 50], 1) === true);\n    assert(has_subarray_with_sum_gte_average([1, 1, 1, 1, 1], 5) === true);\n}\n\ntestHasSubarrayWithSumGteAverage();", "all_code": "<?php\n/**\n * Checks if there exists a contiguous subarray of size k in nums\n * whose sum is greater than or equal to the average of the entire array nums.\n *\n * @param array $nums List of integers\n * @param int $k Size of the subarray\n * @return bool True if such a subarray exists, False otherwise\n */\nfunction has_subarray_with_sum_gte_average($nums, $k) {\n    $n = count($nums);\n    $total_sum = array_sum($nums);\n    $average = $total_sum / $n;\n\n    // Calculate initial window sum of the first k elements\n    $current_window_sum = array_sum(array_slice($nums, 0, $k));\n\n    // Check if the initial window sum is equal or greater than the average\n    if ($current_window_sum >= $average * $k) {\n        return true;\n    }\n\n    // Slide the window across the array and keep updating the window sum.\n    for ($i = $k; $i < $n; $i++) {\n        $current_window_sum += $nums[$i] - $nums[$i - $k];\n        if ($current_window_sum >= $average * $k) {\n            return true;\n        }\n    }\n\n    return false;\n}\nfunction testHasSubarrayWithSumGteAverage() {\n    assert(has_subarray_with_sum_gte_average([1, 2, 3, 4], 2) === true);\n    assert(has_subarray_with_sum_gte_average([5, 6, 7, 0], 3) === true);\n    assert(has_subarray_with_sum_gte_average([0, 0, 0, 0], 2) === true);\n    assert(has_subarray_with_sum_gte_average([10, 20, 30, 40, 50], 1) === true);\n    assert(has_subarray_with_sum_gte_average([1, 1, 1, 1, 1], 5) === true);\n}\n\ntestHasSubarrayWithSumGteAverage();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n// concatenate_first_letters constructs a string by taking the first character of each word in the list\n// and concatenating them in the same order.\n// If the input array is empty, it returns an empty string.\nfunction concatenate_first_letters($words) {\n    $result = '';\n    foreach ($words as $word) {\n        if (strlen($word) > 0) {\n            $result .= $word[0];\n        }\n    }\n    return $result;\n}\n?>", "test_cases": "", "test_case_results": "Input: [\"Hello\", \"World\", \"PHP\"]\nConcatenated First Letters: \"HWP\"\nInput: [\"This\", \"is\", \"a\", \"test\"]\nConcatenated First Letters: \"Tiat\"\nInput: [\"\", \"Another\", \"Test\"]\nConcatenated First Letters: \"AT\"\nInput: []\nConcatenated First Letters: \"\"", "task_id": 3529, "assertions": "<?php\nfunction testConcatenateFirstLetters() {\n    assert(concatenate_first_letters([\"Hello\", \"World\", \"PHP\"]) === \"HWP\");\n    assert(concatenate_first_letters([\"This\", \"is\", \"a\", \"test\"]) === \"Tiat\");\n    assert(concatenate_first_letters([\"\", \"Another\", \"Test\"]) === \"AT\");\n    assert(concatenate_first_letters([]) === \"\");\n}\n\ntestConcatenateFirstLetters();\n?>", "all_code": "<?php\n// concatenate_first_letters constructs a string by taking the first character of each word in the list\n// and concatenating them in the same order.\n// If the input array is empty, it returns an empty string.\nfunction concatenate_first_letters($words) {\n    $result = '';\n    foreach ($words as $word) {\n        if (strlen($word) > 0) {\n            $result .= $word[0];\n        }\n    }\n    return $result;\n}\nfunction testConcatenateFirstLetters() {\n    assert(concatenate_first_letters([\"Hello\", \"World\", \"PHP\"]) === \"HWP\");\n    assert(concatenate_first_letters([\"This\", \"is\", \"a\", \"test\"]) === \"Tiat\");\n    assert(concatenate_first_letters([\"\", \"Another\", \"Test\"]) === \"AT\");\n    assert(concatenate_first_letters([]) === \"\");\n}\n\ntestConcatenateFirstLetters();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// validate_string checks if a string meets the following criteria:\n// - The string must be exactly 6 characters long.\n// - The string must contain only alphanumeric characters.\n// - The string must contain at least one uppercase letter, one lowercase letter, and one digit.\n// Returns true if all conditions are met, otherwise false.\nfunction validate_string($s) {\n    if (strlen($s) != 6) {\n        return false;\n    }\n    \n    $has_upper = false;\n    $has_lower = false;\n    $has_digit = false;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (!ctype_alnum($char)) {\n            return false;\n        }\n        if (ctype_upper($char)) {\n            $has_upper = true;\n        }\n        if (ctype_lower($char)) {\n            $has_lower = true;\n        }\n        if (ctype_digit($char)) {\n            $has_digit = true;\n        }\n    }\n    \n    return $has_upper && $has_lower && $has_digit;\n}", "test_cases": "", "test_case_results": "Input: Abc123\nResult: true\nInput: abc123\nResult: false\nInput: ABC123\nResult: false\nInput: Abcdef\nResult: false\nInput: Ab123\nResult: false\nInput: Abc1234\nResult: false\nInput: Abc 23\nResult: false", "task_id": 24275, "assertions": "<?php\n\nfunction testValidateString() {\n    // Valid case\n    assert(validate_string(\"Abc123\") === true);\n    \n    // Invalid cases\n    assert(validate_string(\"abc123\") === false);  // no uppercase\n    assert(validate_string(\"ABC123\") === false);  // no lowercase\n    assert(validate_string(\"Abcdef\") === false);  // no digit\n    assert(validate_string(\"Ab123\") === false);   // too short\n    assert(validate_string(\"Abc1234\") === false); // too long\n    assert(validate_string(\"Abc 23\") === false);  // non-alphanumeric\n}\n\ntestValidateString();", "all_code": "<?php\n// validate_string checks if a string meets the following criteria:\n// - The string must be exactly 6 characters long.\n// - The string must contain only alphanumeric characters.\n// - The string must contain at least one uppercase letter, one lowercase letter, and one digit.\n// Returns true if all conditions are met, otherwise false.\nfunction validate_string($s) {\n    if (strlen($s) != 6) {\n        return false;\n    }\n    \n    $has_upper = false;\n    $has_lower = false;\n    $has_digit = false;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        $char = $s[$i];\n        if (!ctype_alnum($char)) {\n            return false;\n        }\n        if (ctype_upper($char)) {\n            $has_upper = true;\n        }\n        if (ctype_lower($char)) {\n            $has_lower = true;\n        }\n        if (ctype_digit($char)) {\n            $has_digit = true;\n        }\n    }\n    \n    return $has_upper && $has_lower && $has_digit;\n}\nfunction testValidateString() {\n    // Valid case\n    assert(validate_string(\"Abc123\") === true);\n    \n    // Invalid cases\n    assert(validate_string(\"abc123\") === false);  // no uppercase\n    assert(validate_string(\"ABC123\") === false);  // no lowercase\n    assert(validate_string(\"Abcdef\") === false);  // no digit\n    assert(validate_string(\"Ab123\") === false);   // too short\n    assert(validate_string(\"Abc1234\") === false); // too long\n    assert(validate_string(\"Abc 23\") === false);  // non-alphanumeric\n}\n\ntestValidateString();\n", "exec_outcome": "SYNTAX_ERROR"}
{"code": "<?php\n/**\n * Determines if the string can be classified as an \"almost palindrome\" by changing exactly one character.\n *\n * @param int $M The length of the string.\n * @param string $T The input string consisting of lowercase English letters.\n * @return string Returns \"YES\" if the string can be converted to a palindrome by changing exactly one character, otherwise \"NO\".\n */\nfunction almost_palindrome($M, $T) {\n    // Counter to keep track of mismatches\n    $mismatch_counter = 0;\n    \n    // Iterate from start and end towards the middle to check mismatches\n    for ($i = 0; $i < $M / 2; $i++) {\n        if ($T[$i] != $T[$M - 1 - $i]) {\n            $mismatch_counter++;\n            // If there are more than one mismatch, it cannot be \"almost palindrome\"\n            if ($mismatch_counter > 1) {\n                return \"NO\";\n            }\n        }\n    }\n    \n    // If there's exactly one mismatch, or\n    // If no mismatches found for odd-length strings, they can still be almost palindrome\n    if ($mismatch_counter == 1 || ($mismatch_counter == 0 && $M % 2 == 1)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n?>", "test_cases": "", "test_case_results": "Input: Length = 4, String = \"abca\"\nResult: YES\nInput: Length = 5, String = \"abcba\"\nResult: YES\nInput: Length = 6, String = \"abccba\"\nResult: NO\nInput: Length = 4, String = \"abcd\"\nResult: NO\nInput: Length = 3, String = \"aab\"\nResult: YES\nInput: Length = 3, String = \"aaa\"\nResult: YES\nInput: Length = 4, String = \"aaaa\"\nResult: NO", "task_id": 21473, "assertions": "<?php\n\nfunction testAlmostPalindrome() {\n    assert(almost_palindrome(4, \"abca\") === \"YES\");\n    assert(almost_palindrome(5, \"abcba\") === \"YES\");\n    assert(almost_palindrome(6, \"abccba\") === \"NO\");\n    assert(almost_palindrome(4, \"abcd\") === \"NO\");\n    assert(almost_palindrome(3, \"aab\") === \"YES\");\n    assert(almost_palindrome(3, \"aaa\") === \"YES\");\n    assert(almost_palindrome(4, \"aaaa\") === \"NO\");\n}\n\ntestAlmostPalindrome();\n?>", "all_code": "<?php\n/**\n * Determines if the string can be classified as an \"almost palindrome\" by changing exactly one character.\n *\n * @param int $M The length of the string.\n * @param string $T The input string consisting of lowercase English letters.\n * @return string Returns \"YES\" if the string can be converted to a palindrome by changing exactly one character, otherwise \"NO\".\n */\nfunction almost_palindrome($M, $T) {\n    // Counter to keep track of mismatches\n    $mismatch_counter = 0;\n    \n    // Iterate from start and end towards the middle to check mismatches\n    for ($i = 0; $i < $M / 2; $i++) {\n        if ($T[$i] != $T[$M - 1 - $i]) {\n            $mismatch_counter++;\n            // If there are more than one mismatch, it cannot be \"almost palindrome\"\n            if ($mismatch_counter > 1) {\n                return \"NO\";\n            }\n        }\n    }\n    \n    // If there's exactly one mismatch, or\n    // If no mismatches found for odd-length strings, they can still be almost palindrome\n    if ($mismatch_counter == 1 || ($mismatch_counter == 0 && $M % 2 == 1)) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\nfunction testAlmostPalindrome() {\n    assert(almost_palindrome(4, \"abca\") === \"YES\");\n    assert(almost_palindrome(5, \"abcba\") === \"YES\");\n    assert(almost_palindrome(6, \"abccba\") === \"NO\");\n    assert(almost_palindrome(4, \"abcd\") === \"NO\");\n    assert(almost_palindrome(3, \"aab\") === \"YES\");\n    assert(almost_palindrome(3, \"aaa\") === \"YES\");\n    assert(almost_palindrome(4, \"aaaa\") === \"NO\");\n}\n\ntestAlmostPalindrome();\n?>\n", "exec_outcome": "PASSED"}
{"code": "<?php\n// min_operations_to_special_string calculates the minimum number of operations required to convert a string into a \"special\" string.\n// A \"special\" string is defined as a string where all characters are the same.\n// The number of operations needed is equal to the number of distinct characters in the string minus one.\nfunction min_operations_to_special_string($strings) {\n    $results = [];\n    foreach ($strings as $s) {\n        $distinct_letters = array_unique(str_split($s));\n        $results[] = count($distinct_letters) - 1;\n    }\n    return $results;\n}\n?>", "test_cases": "", "test_case_results": "Input: [aab, abc, aaaa, abab]\nMinimum operations: [1, 2, 0, 1]\nInput: [x, yy, zzz, wwww]\nMinimum operations: [0, 0, 0, 0]\nInput: [abcd, efgh, ijkl]\nMinimum operations: [3, 3, 3]", "task_id": 26052, "assertions": "<?php\nfunction testMinOperationsToSpecialString() {\n    assert(min_operations_to_special_string([\"aab\", \"abc\", \"aaaa\", \"abab\"]) === [1, 2, 0, 1]);\n    assert(min_operations_to_special_string([\"x\", \"yy\", \"zzz\", \"wwww\"]) === [0, 0, 0, 0]);\n    assert(min_operations_to_special_string([\"abcd\", \"efgh\", \"ijkl\"]) === [3, 3, 3]);\n}\n\ntestMinOperationsToSpecialString();\n?>", "all_code": "<?php\n// min_operations_to_special_string calculates the minimum number of operations required to convert a string into a \"special\" string.\n// A \"special\" string is defined as a string where all characters are the same.\n// The number of operations needed is equal to the number of distinct characters in the string minus one.\nfunction min_operations_to_special_string($strings) {\n    $results = [];\n    foreach ($strings as $s) {\n        $distinct_letters = array_unique(str_split($s));\n        $results[] = count($distinct_letters) - 1;\n    }\n    return $results;\n}\nfunction testMinOperationsToSpecialString() {\n    assert(min_operations_to_special_string([\"aab\", \"abc\", \"aaaa\", \"abab\"]) === [1, 2, 0, 1]);\n    assert(min_operations_to_special_string([\"x\", \"yy\", \"zzz\", \"wwww\"]) === [0, 0, 0, 0]);\n    assert(min_operations_to_special_string([\"abcd\", \"efgh\", \"ijkl\"]) === [3, 3, 3]);\n}\n\ntestMinOperationsToSpecialString();\n?>\n", "exec_outcome": "PASSED"}
