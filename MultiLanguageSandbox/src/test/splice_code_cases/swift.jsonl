{"code": "import Foundation\n\nfunc kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n    guard !matrix.isEmpty else { return -1 }\n    \n    var minHeap = [(element: Int, row: Int, col: Int)]()\n    \n    for row in 0..<min(matrix.count, k) {\n        if !matrix[row].isEmpty {\n            minHeap.append((matrix[row][0], row, 0))\n        }\n    }\n    \n    minHeap.sort { $0.element < $1.element }\n    \n    var remainingK = k\n    var result = -1\n    \n    while remainingK > 0 && !minHeap.isEmpty {\n        let (element, row, col) = minHeap.removeFirst()\n        result = element\n        remainingK -= 1\n        \n        if col + 1 < matrix[row].count {\n            minHeap.append((matrix[row][col + 1], row, col + 1))\n            minHeap.sort { $0.element < $1.element }\n        }\n    }\n    \n    return result\n}", "test_cases": "", "test_case_results": "Input matrix: [[1, 5, 9], [10, 11, 13], [12, 13, 15]], k: 8\nResult: 13, Expected: 13\n---\nInput matrix: [[1, 2], [3, 4]], k: 3\nResult: 3, Expected: 3\n---\nInput matrix: [[1, 3, 5], [7, 9, 11], [13, 15, 17]], k: 6\nResult: 11, Expected: 11\n---\nInput matrix: [[1]], k: 1\nResult: 1, Expected: 1\n---\nInput matrix: [[]], k: 1\nResult: -1, Expected: -1\n---", "task_id": 21747, "assertions": "func testKthSmallest() {\n    assert(kthSmallest([\n        [1, 5, 9],\n        [10, 11, 13],\n        [12, 13, 15]\n    ], 8) == 13)\n    \n    assert(kthSmallest([\n        [1, 2],\n        [3, 4]\n    ], 3) == 3)\n    \n    assert(kthSmallest([\n        [1, 3, 5],\n        [7, 9, 11],\n        [13, 15, 17]\n    ], 6) == 11)\n    \n    assert(kthSmallest([\n        [1]\n    ], 1) == 1)\n    \n    assert(kthSmallest([\n        []\n    ], 1) == -1)\n}\n\ntestKthSmallest()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testKthSmallest() {\n    assert(kthSmallest([\n        [1, 5, 9],\n        [10, 11, 13],\n        [12, 13, 15]\n    ], 8) == 13)\n    \n    assert(kthSmallest([\n        [1, 2],\n        [3, 4]\n    ], 3) == 3)\n    \n    assert(kthSmallest([\n        [1, 3, 5],\n        [7, 9, 11],\n        [13, 15, 17]\n    ], 6) == 11)\n    \n    assert(kthSmallest([\n        [1]\n    ], 1) == 1)\n    \n    assert(kthSmallest([\n        []\n    ], 1) == -1)\n}\n\ntestKthSmallest()", "output": "kthSmallest"}, "all_code": "import Foundation\n\nfunc kthSmallest(_ matrix: [[Int]], _ k: Int) -> Int {\n    guard !matrix.isEmpty else { return -1 }\n    \n    var minHeap = [(element: Int, row: Int, col: Int)]()\n    \n    for row in 0..<min(matrix.count, k) {\n        if !matrix[row].isEmpty {\n            minHeap.append((matrix[row][0], row, 0))\n        }\n    }\n    \n    minHeap.sort { $0.element < $1.element }\n    \n    var remainingK = k\n    var result = -1\n    \n    while remainingK > 0 && !minHeap.isEmpty {\n        let (element, row, col) = minHeap.removeFirst()\n        result = element\n        remainingK -= 1\n        \n        if col + 1 < matrix[row].count {\n            minHeap.append((matrix[row][col + 1], row, col + 1))\n            minHeap.sort { $0.element < $1.element }\n        }\n    }\n    \n    return result\n}\nfunc testKthSmallest() {\n    assert(kthSmallest([\n        [1, 5, 9],\n        [10, 11, 13],\n        [12, 13, 15]\n    ], 8) == 13)\n    \n    assert(kthSmallest([\n        [1, 2],\n        [3, 4]\n    ], 3) == 3)\n    \n    assert(kthSmallest([\n        [1, 3, 5],\n        [7, 9, 11],\n        [13, 15, 17]\n    ], 6) == 11)\n    \n    assert(kthSmallest([\n        [1]\n    ], 1) == 1)\n    \n    assert(kthSmallest([\n        []\n    ], 1) == -1)\n}\n\ntestKthSmallest()", "exec_outcome": "PASSED"}
{"code": "// isPalindromeSubstring checks if each substring of a given string, specified by a list of queries, is a palindrome.\n// Each query is a pair of integers (a, b) representing a 1-based substring from index a to b (inclusive).\n// The function returns an array of \"Yes\" or \"No\" strings indicating whether each substring is a palindrome.\nfunc isPalindromeSubstring(_ s: String, queries: [(Int, Int)]) -> [String] {\n    var results: [String] = []\n    let characters = Array(s)\n    \n    for (a, b) in queries {\n        let start = a - 1\n        let end = b - 1\n        var isPalindrome = true\n        \n        var left = start\n        var right = end\n        \n        while left < right {\n            if characters[left] != characters[right] {\n                isPalindrome = false\n                break\n            }\n            left += 1\n            right -= 1\n        }\n        \n        results.append(isPalindrome ? \"Yes\" : \"No\")\n    }\n    \n    return results\n}", "test_cases": "", "test_case_results": "Input string: \"abba\"\nQueries: [(1, 4), (2, 3), (1, 1)]\nResults: [\"Yes\", \"Yes\", \"Yes\"]\n\nInput string: \"abcde\"\nQueries: [(1, 5), (2, 4), (3, 3)]\nResults: [\"No\", \"No\", \"Yes\"]\n\nInput string: \"racecar\"\nQueries: [(1, 7), (2, 6), (3, 5)]\nResults: [\"Yes\", \"Yes\", \"Yes\"]", "task_id": 16101, "assertions": "func testIsPalindromeSubstring() {\n    assert(isPalindromeSubstring(\"abba\", queries: [(1, 4), (2, 3), (1, 1)]) == [\"Yes\", \"Yes\", \"Yes\"])\n    assert(isPalindromeSubstring(\"abcde\", queries: [(1, 5), (2, 4), (3, 3)]) == [\"No\", \"No\", \"Yes\"])\n    assert(isPalindromeSubstring(\"racecar\", queries: [(1, 7), (2, 6), (3, 5)]) == [\"Yes\", \"Yes\", \"Yes\"])\n}\n\ntestIsPalindromeSubstring()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsPalindromeSubstring() {\n    assert(isPalindromeSubstring(\"abba\", queries: [(1, 4), (2, 3), (1, 1)]) == [\"Yes\", \"Yes\", \"Yes\"])\n    assert(isPalindromeSubstring(\"abcde\", queries: [(1, 5), (2, 4), (3, 3)]) == [\"No\", \"No\", \"Yes\"])\n    assert(isPalindromeSubstring(\"racecar\", queries: [(1, 7), (2, 6), (3, 5)]) == [\"Yes\", \"Yes\", \"Yes\"])\n}\n\ntestIsPalindromeSubstring()", "output": "isPalindromeSubstring"}, "all_code": "// isPalindromeSubstring checks if each substring of a given string, specified by a list of queries, is a palindrome.\n// Each query is a pair of integers (a, b) representing a 1-based substring from index a to b (inclusive).\n// The function returns an array of \"Yes\" or \"No\" strings indicating whether each substring is a palindrome.\nfunc isPalindromeSubstring(_ s: String, queries: [(Int, Int)]) -> [String] {\n    var results: [String] = []\n    let characters = Array(s)\n    \n    for (a, b) in queries {\n        let start = a - 1\n        let end = b - 1\n        var isPalindrome = true\n        \n        var left = start\n        var right = end\n        \n        while left < right {\n            if characters[left] != characters[right] {\n                isPalindrome = false\n                break\n            }\n            left += 1\n            right -= 1\n        }\n        \n        results.append(isPalindrome ? \"Yes\" : \"No\")\n    }\n    \n    return results\n}\nfunc testIsPalindromeSubstring() {\n    assert(isPalindromeSubstring(\"abba\", queries: [(1, 4), (2, 3), (1, 1)]) == [\"Yes\", \"Yes\", \"Yes\"])\n    assert(isPalindromeSubstring(\"abcde\", queries: [(1, 5), (2, 4), (3, 3)]) == [\"No\", \"No\", \"Yes\"])\n    assert(isPalindromeSubstring(\"racecar\", queries: [(1, 7), (2, 6), (3, 5)]) == [\"Yes\", \"Yes\", \"Yes\"])\n}\n\ntestIsPalindromeSubstring()", "exec_outcome": "PASSED"}
{"code": "// efficientPower calculates a^n using binary exponentiation (iterative approach).\n// It supports optional modulo operations to handle large numbers.\n// The function takes three parameters: base (a), exponent (n), and an optional modulo (mod).\n// If mod is provided, the result is computed modulo mod; otherwise, it's computed directly.\nfunc efficientPower(a: Int, n: Int, mod: Int? = nil) -> Int {\n    var result = 1\n    var base = mod != nil ? a % mod! : a\n    var exponent = n\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = mod != nil ? (result * base) % mod! : result * base\n        }\n        base = mod != nil ? (base * base) % mod! : base * base\n        exponent /= 2\n    }\n    \n    return result\n}\n\n// efficientPowerRecursive calculates a^n using binary exponentiation (recursive approach).\n// It supports optional modulo operations to handle large numbers.\n// The function takes three parameters: base (a), exponent (n), and an optional modulo (mod).\n// If mod is provided, the result is computed modulo mod; otherwise, it's computed directly.\nfunc efficientPowerRecursive(a: Int, n: Int, mod: Int? = nil) -> Int {\n    if n == 0 {\n        return 1\n    }\n    \n    let halfPower = efficientPowerRecursive(a: a, n: n / 2, mod: mod)\n    var result = mod != nil ? (halfPower * halfPower) % mod! : halfPower * halfPower\n    \n    if n % 2 != 0 {\n        result = mod != nil ? (result * a) % mod! : result * a\n    }\n    \n    return result\n}", "test_cases": "", "test_case_results": "Input: a = 2, n = 10, mod = -1\nIterative result: 1024\nRecursive result: 1024\n---\nInput: a = 3, n = 5, mod = 7\nIterative result: 5\nRecursive result: 5\n---\nInput: a = 5, n = 0, mod = -1\nIterative result: 1\nRecursive result: 1\n---\nInput: a = 4, n = 12, mod = 10\nIterative result: 6\nRecursive result: 6\n---\nInput: a = 10, n = 3, mod = -1\nIterative result: 1000\nRecursive result: 1000\n---", "task_id": 7054, "assertions": "func testEfficientPower() {\n    // Test case 1: 2^10 with no mod\n    assert(efficientPower(a: 2, n: 10) == 1024)\n    assert(efficientPowerRecursive(a: 2, n: 10) == 1024)\n    \n    // Test case 2: 3^5 mod 7\n    assert(efficientPower(a: 3, n: 5, mod: 7) == 5)\n    assert(efficientPowerRecursive(a: 3, n: 5, mod: 7) == 5)\n    \n    // Test case 3: 5^0 with no mod\n    assert(efficientPower(a: 5, n: 0) == 1)\n    assert(efficientPowerRecursive(a: 5, n: 0) == 1)\n    \n    // Test case 4: 4^12 mod 10\n    assert(efficientPower(a: 4, n: 12, mod: 10) == 6)\n    assert(efficientPowerRecursive(a: 4, n: 12, mod: 10) == 6)\n    \n    // Test case 5: 10^3 with no mod\n    assert(efficientPower(a: 10, n: 3) == 1000)\n    assert(efficientPowerRecursive(a: 10, n: 3) == 1000)\n}\n\ntestEfficientPower()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testEfficientPower() {\n    // Test case 1: 2^10 with no mod\n    assert(efficientPower(a: 2, n: 10) == 1024)\n    assert(efficientPowerRecursive(a: 2, n: 10) == 1024)\n    \n    // Test case 2: 3^5 mod 7\n    assert(efficientPower(a: 3, n: 5, mod: 7) == 5)\n    assert(efficientPowerRecursive(a: 3, n: 5, mod: 7) == 5)\n    \n    // Test case 3: 5^0 with no mod\n    assert(efficientPower(a: 5, n: 0) == 1)\n    assert(efficientPowerRecursive(a: 5, n: 0) == 1)\n    \n    // Test case 4: 4^12 mod 10\n    assert(efficientPower(a: 4, n: 12, mod: 10) == 6)\n    assert(efficientPowerRecursive(a: 4, n: 12, mod: 10) == 6)\n    \n    // Test case 5: 10^3 with no mod\n    assert(efficientPower(a: 10, n: 3) == 1000)\n    assert(efficientPowerRecursive(a: 10, n: 3) == 1000)\n}\n\ntestEfficientPower()", "output": "efficientPower"}, "all_code": "import Foundation\nimport Glibc\n\n// efficientPower calculates a^n using binary exponentiation (iterative approach).\n// It supports optional modulo operations to handle large numbers.\n// The function takes three parameters: base (a), exponent (n), and an optional modulo (mod).\n// If mod is provided, the result is computed modulo mod; otherwise, it's computed directly.\nfunc efficientPower(a: Int, n: Int, mod: Int? = nil) -> Int {\n    var result = 1\n    var base = mod != nil ? a % mod! : a\n    var exponent = n\n    \n    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result = mod != nil ? (result * base) % mod! : result * base\n        }\n        base = mod != nil ? (base * base) % mod! : base * base\n        exponent /= 2\n    }\n    \n    return result\n}\n\n// efficientPowerRecursive calculates a^n using binary exponentiation (recursive approach).\n// It supports optional modulo operations to handle large numbers.\n// The function takes three parameters: base (a), exponent (n), and an optional modulo (mod).\n// If mod is provided, the result is computed modulo mod; otherwise, it's computed directly.\nfunc efficientPowerRecursive(a: Int, n: Int, mod: Int? = nil) -> Int {\n    if n == 0 {\n        return 1\n    }\n    \n    let halfPower = efficientPowerRecursive(a: a, n: n / 2, mod: mod)\n    var result = mod != nil ? (halfPower * halfPower) % mod! : halfPower * halfPower\n    \n    if n % 2 != 0 {\n        result = mod != nil ? (result * a) % mod! : result * a\n    }\n    \n    return result\n}\nfunc testEfficientPower() {\n    // Test case 1: 2^10 with no mod\n    assert(efficientPower(a: 2, n: 10) == 1024)\n    assert(efficientPowerRecursive(a: 2, n: 10) == 1024)\n    \n    // Test case 2: 3^5 mod 7\n    assert(efficientPower(a: 3, n: 5, mod: 7) == 5)\n    assert(efficientPowerRecursive(a: 3, n: 5, mod: 7) == 5)\n    \n    // Test case 3: 5^0 with no mod\n    assert(efficientPower(a: 5, n: 0) == 1)\n    assert(efficientPowerRecursive(a: 5, n: 0) == 1)\n    \n    // Test case 4: 4^12 mod 10\n    assert(efficientPower(a: 4, n: 12, mod: 10) == 6)\n    assert(efficientPowerRecursive(a: 4, n: 12, mod: 10) == 6)\n    \n    // Test case 5: 10^3 with no mod\n    assert(efficientPower(a: 10, n: 3) == 1000)\n    assert(efficientPowerRecursive(a: 10, n: 3) == 1000)\n}\n\ntestEfficientPower()", "exec_outcome": "PASSED"}
{"code": "// countCopySubstrings calculates the total number of substrings in `s` that are anagrams of `t`.\n// It uses a sliding window approach to efficiently compare the frequency of characters in substrings of `s` with the frequency of characters in `t`.\n// If the length of `s` is less than `t`, it immediately returns 0 since no anagram can exist.\nfunc countCopySubstrings(s: String, t: String) -> Int {\n    let lenS = s.count\n    let lenT = t.count\n    if lenS < lenT {\n        return 0\n    }\n    \n    // Convert strings to arrays of characters for easier indexing\n    let sArray = Array(s)\n    let tArray = Array(t)\n    \n    // Create frequency dictionary for `t`\n    var tCounter = [Character: Int]()\n    for char in tArray {\n        tCounter[char] = (tCounter[char] ?? 0) + 1\n    }\n    \n    // Initialize the sliding window frequency dictionary for the first window in `s`\n    var currentCounter = [Character: Int]()\n    for i in 0..<lenT {\n        let char = sArray[i]\n        currentCounter[char] = (currentCounter[char] ?? 0) + 1\n    }\n    \n    var totalCopies = 0\n    if currentCounter == tCounter {\n        totalCopies += 1\n    }\n    \n    // Slide the window through the rest of `s`\n    for i in lenT..<lenS {\n        let newChar = sArray[i]\n        let oldChar = sArray[i - lenT]\n        \n        // Update the currentCounter for the new character entering the window\n        currentCounter[newChar] = (currentCounter[newChar] ?? 0) + 1\n        \n        // Update the currentCounter for the old character leaving the window\n        currentCounter[oldChar] = (currentCounter[oldChar] ?? 0) - 1\n        if currentCounter[oldChar] == 0 {\n            currentCounter.removeValue(forKey: oldChar)\n        }\n        \n        // Check if the current window matches the frequency of `t`\n        if currentCounter == tCounter {\n            totalCopies += 1\n        }\n    }\n    \n    return totalCopies\n}", "test_cases": "", "test_case_results": "Input: s = \"abcabc\", t = \"abc\"\nNumber of anagram substrings: 4\nInput: s = \"abab\", t = \"ab\"\nNumber of anagram substrings: 3\nInput: s = \"a\", t = \"b\"\nNumber of anagram substrings: 0\nInput: s = \"\", t = \"abc\"\nNumber of anagram substrings: 0\nInput: s = \"cbaebabacd\", t = \"abc\"\nNumber of anagram substrings: 2\nInput: s = \"ababababab\", t = \"aab\"\nNumber of anagram substrings: 4", "task_id": 25722, "assertions": "func testCountCopySubstrings() {\n    assert(countCopySubstrings(s: \"abcabc\", t: \"abc\") == 4)\n    assert(countCopySubstrings(s: \"abab\", t: \"ab\") == 3)\n    assert(countCopySubstrings(s: \"a\", t: \"b\") == 0)\n    assert(countCopySubstrings(s: \"\", t: \"abc\") == 0)\n    assert(countCopySubstrings(s: \"cbaebabacd\", t: \"abc\") == 2)\n    assert(countCopySubstrings(s: \"ababababab\", t: \"aab\") == 4)\n}\n\ntestCountCopySubstrings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountCopySubstrings() {\n    assert(countCopySubstrings(s: \"abcabc\", t: \"abc\") == 4)\n    assert(countCopySubstrings(s: \"abab\", t: \"ab\") == 3)\n    assert(countCopySubstrings(s: \"a\", t: \"b\") == 0)\n    assert(countCopySubstrings(s: \"\", t: \"abc\") == 0)\n    assert(countCopySubstrings(s: \"cbaebabacd\", t: \"abc\") == 2)\n    assert(countCopySubstrings(s: \"ababababab\", t: \"aab\") == 4)\n}\n\ntestCountCopySubstrings()", "output": "countCopySubstrings"}, "all_code": "import Foundation\nimport Glibc\n\n// countCopySubstrings calculates the total number of substrings in `s` that are anagrams of `t`.\n// It uses a sliding window approach to efficiently compare the frequency of characters in substrings of `s` with the frequency of characters in `t`.\n// If the length of `s` is less than `t`, it immediately returns 0 since no anagram can exist.\nfunc countCopySubstrings(s: String, t: String) -> Int {\n    let lenS = s.count\n    let lenT = t.count\n    if lenS < lenT {\n        return 0\n    }\n    \n    // Convert strings to arrays of characters for easier indexing\n    let sArray = Array(s)\n    let tArray = Array(t)\n    \n    // Create frequency dictionary for `t`\n    var tCounter = [Character: Int]()\n    for char in tArray {\n        tCounter[char] = (tCounter[char] ?? 0) + 1\n    }\n    \n    // Initialize the sliding window frequency dictionary for the first window in `s`\n    var currentCounter = [Character: Int]()\n    for i in 0..<lenT {\n        let char = sArray[i]\n        currentCounter[char] = (currentCounter[char] ?? 0) + 1\n    }\n    \n    var totalCopies = 0\n    if currentCounter == tCounter {\n        totalCopies += 1\n    }\n    \n    // Slide the window through the rest of `s`\n    for i in lenT..<lenS {\n        let newChar = sArray[i]\n        let oldChar = sArray[i - lenT]\n        \n        // Update the currentCounter for the new character entering the window\n        currentCounter[newChar] = (currentCounter[newChar] ?? 0) + 1\n        \n        // Update the currentCounter for the old character leaving the window\n        currentCounter[oldChar] = (currentCounter[oldChar] ?? 0) - 1\n        if currentCounter[oldChar] == 0 {\n            currentCounter.removeValue(forKey: oldChar)\n        }\n        \n        // Check if the current window matches the frequency of `t`\n        if currentCounter == tCounter {\n            totalCopies += 1\n        }\n    }\n    \n    return totalCopies\n}\nfunc testCountCopySubstrings() {\n    assert(countCopySubstrings(s: \"abcabc\", t: \"abc\") == 4)\n    assert(countCopySubstrings(s: \"abab\", t: \"ab\") == 3)\n    assert(countCopySubstrings(s: \"a\", t: \"b\") == 0)\n    assert(countCopySubstrings(s: \"\", t: \"abc\") == 0)\n    assert(countCopySubstrings(s: \"cbaebabacd\", t: \"abc\") == 2)\n    assert(countCopySubstrings(s: \"ababababab\", t: \"aab\") == 4)\n}\n\ntestCountCopySubstrings()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\nfunc findClusters(n: Int, m: Int, roads: [(Int, Int)]) -> Int {\n    var adjacencyList = [Int: [Int]]()\n    \n    for (u, v) in roads {\n        adjacencyList[u, default: []].append(v)\n        adjacencyList[v, default: []].append(u)\n    }\n    \n    var visited = Set<Int>()\n    var clusters = 0\n    \n    func bfs(start: Int) {\n        var queue = [start]\n        visited.insert(start)\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            for neighbor in adjacencyList[node, default: []] {\n                if !visited.contains(neighbor) {\n                    visited.insert(neighbor)\n                    queue.append(neighbor)\n                }\n            }\n        }\n    }\n    \n    for zone in 1...n {\n        if !visited.contains(zone) {\n            bfs(start: zone)\n            clusters += 1\n        }\n    }\n    \n    return clusters\n}", "test_cases": "", "test_case_results": "Zones: 5, Roads: [(1, 2), (2, 3), (4, 5)]\nNumber of clusters: 2\n---\nZones: 4, Roads: [(1, 2), (3, 4)]\nNumber of clusters: 2\n---\nZones: 6, Roads: []\nNumber of clusters: 6\n---\nZones: 3, Roads: [(1, 2), (2, 3)]\nNumber of clusters: 1\n---", "task_id": 27978, "assertions": "func testFindClusters() {\n    assert(findClusters(n: 5, m: 3, roads: [(1, 2), (2, 3), (4, 5)]) == 2)\n    assert(findClusters(n: 4, m: 2, roads: [(1, 2), (3, 4)]) == 2)\n    assert(findClusters(n: 6, m: 0, roads: []) == 6)\n    assert(findClusters(n: 3, m: 2, roads: [(1, 2), (2, 3)]) == 1)\n}\n\ntestFindClusters()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindClusters() {\n    assert(findClusters(n: 5, m: 3, roads: [(1, 2), (2, 3), (4, 5)]) == 2)\n    assert(findClusters(n: 4, m: 2, roads: [(1, 2), (3, 4)]) == 2)\n    assert(findClusters(n: 6, m: 0, roads: []) == 6)\n    assert(findClusters(n: 3, m: 2, roads: [(1, 2), (2, 3)]) == 1)\n}\n\ntestFindClusters()", "output": "findClusters"}, "all_code": "import Foundation\n\nfunc findClusters(n: Int, m: Int, roads: [(Int, Int)]) -> Int {\n    var adjacencyList = [Int: [Int]]()\n    \n    for (u, v) in roads {\n        adjacencyList[u, default: []].append(v)\n        adjacencyList[v, default: []].append(u)\n    }\n    \n    var visited = Set<Int>()\n    var clusters = 0\n    \n    func bfs(start: Int) {\n        var queue = [start]\n        visited.insert(start)\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            for neighbor in adjacencyList[node, default: []] {\n                if !visited.contains(neighbor) {\n                    visited.insert(neighbor)\n                    queue.append(neighbor)\n                }\n            }\n        }\n    }\n    \n    for zone in 1...n {\n        if !visited.contains(zone) {\n            bfs(start: zone)\n            clusters += 1\n        }\n    }\n    \n    return clusters\n}\nfunc testFindClusters() {\n    assert(findClusters(n: 5, m: 3, roads: [(1, 2), (2, 3), (4, 5)]) == 2)\n    assert(findClusters(n: 4, m: 2, roads: [(1, 2), (3, 4)]) == 2)\n    assert(findClusters(n: 6, m: 0, roads: []) == 6)\n    assert(findClusters(n: 3, m: 2, roads: [(1, 2), (2, 3)]) == 1)\n}\n\ntestFindClusters()", "exec_outcome": "PASSED"}
{"code": "struct HashTable<Value> {\n    private var size: Int = 0\n    private var capacity: Int\n    private var table: [[(key: String, value: Value)]]\n    \n    init(initialCapacity: Int = 8) {\n        self.capacity = initialCapacity\n        self.table = Array(repeating: [], count: capacity)\n    }\n    \n    private func hashFunction(key: String) -> Int {\n        return key.unicodeScalars.map { Int($0.value) }.reduce(0, +) % capacity\n    }\n    \n    mutating func insert(key: String, value: Value) {\n        if Double(size) / Double(capacity) > 0.75 {\n            resize()\n        }\n        \n        let index = hashFunction(key: key)\n        for (i, (k, _)) in table[index].enumerated() {\n            if k == key {\n                table[index][i] = (key, value)\n                return\n            }\n        }\n        \n        table[index].append((key, value))\n        size += 1\n    }\n    \n    mutating func delete(key: String) -> Bool {\n        let index = hashFunction(key: key)\n        for (i, (k, _)) in table[index].enumerated() {\n            if k == key {\n                table[index].remove(at: i)\n                size -= 1\n                return true\n            }\n        }\n        return false\n    }\n    \n    func search(key: String) -> Value? {\n        let index = hashFunction(key: key)\n        for (k, v) in table[index] {\n            if k == key {\n                return v\n            }\n        }\n        return nil\n    }\n    \n    private mutating func resize() {\n        let oldTable = table\n        capacity *= 2\n        table = Array(repeating: [], count: capacity)\n        size = 0\n        \n        for bucket in oldTable {\n            for (k, v) in bucket {\n                insert(key: k, value: v)\n            }\n        }\n    }\n}", "test_cases": "", "test_case_results": "Inserting key-value pairs:\nAfter insertion:\nSearch 'apple': fruit\nSearch 'banana': fruit\nSearch 'carrot': vegetable\n\nUpdating value for 'apple':\nSearch 'apple': red fruit\n\nDeleting 'banana':\nDelete successful: true\nSearch 'banana': nil\n\nSearching non-existent key 'grape':\nSearch 'grape': nil\n\nTriggering resize by inserting more items:\nSearch 'dog': animal\nSearch 'cat': animal\nSearch 'elephant': animal", "task_id": 25102, "assertions": "func testHashTable() {\n    var hashTable = HashTable<String>(initialCapacity: 4)\n    \n    // Test insertion\n    hashTable.insert(key: \"apple\", value: \"fruit\")\n    hashTable.insert(key: \"banana\", value: \"fruit\")\n    hashTable.insert(key: \"carrot\", value: \"vegetable\")\n    assert(hashTable.search(key: \"apple\") == \"fruit\")\n    assert(hashTable.search(key: \"banana\") == \"fruit\")\n    assert(hashTable.search(key: \"carrot\") == \"vegetable\")\n    \n    // Test update\n    hashTable.insert(key: \"apple\", value: \"red fruit\")\n    assert(hashTable.search(key: \"apple\") == \"red fruit\")\n    \n    // Test deletion\n    let deleted = hashTable.delete(key: \"banana\")\n    assert(deleted == true)\n    assert(hashTable.search(key: \"banana\") == nil)\n    \n    // Test non-existent key\n    assert(hashTable.search(key: \"grape\") == nil)\n    \n    // Test resize\n    hashTable.insert(key: \"dog\", value: \"animal\")\n    hashTable.insert(key: \"cat\", value: \"animal\")\n    hashTable.insert(key: \"elephant\", value: \"animal\")\n    assert(hashTable.search(key: \"dog\") == \"animal\")\n    assert(hashTable.search(key: \"cat\") == \"animal\")\n    assert(hashTable.search(key: \"elephant\") == \"animal\")\n}\n\ntestHashTable()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testHashTable() {\n    var hashTable = HashTable<String>(initialCapacity: 4)\n    \n    // Test insertion\n    hashTable.insert(key: \"apple\", value: \"fruit\")\n    hashTable.insert(key: \"banana\", value: \"fruit\")\n    hashTable.insert(key: \"carrot\", value: \"vegetable\")\n    assert(hashTable.search(key: \"apple\") == \"fruit\")\n    assert(hashTable.search(key: \"banana\") == \"fruit\")\n    assert(hashTable.search(key: \"carrot\") == \"vegetable\")\n    \n    // Test update\n    hashTable.insert(key: \"apple\", value: \"red fruit\")\n    assert(hashTable.search(key: \"apple\") == \"red fruit\")\n    \n    // Test deletion\n    let deleted = hashTable.delete(key: \"banana\")\n    assert(deleted == true)\n    assert(hashTable.search(key: \"banana\") == nil)\n    \n    // Test non-existent key\n    assert(hashTable.search(key: \"grape\") == nil)\n    \n    // Test resize\n    hashTable.insert(key: \"dog\", value: \"animal\")\n    hashTable.insert(key: \"cat\", value: \"animal\")\n    hashTable.insert(key: \"elephant\", value: \"animal\")\n    assert(hashTable.search(key: \"dog\") == \"animal\")\n    assert(hashTable.search(key: \"cat\") == \"animal\")\n    assert(hashTable.search(key: \"elephant\") == \"animal\")\n}\n\ntestHashTable()", "output": "HashTable"}, "all_code": "struct HashTable<Value> {\n    private var size: Int = 0\n    private var capacity: Int\n    private var table: [[(key: String, value: Value)]]\n    \n    init(initialCapacity: Int = 8) {\n        self.capacity = initialCapacity\n        self.table = Array(repeating: [], count: capacity)\n    }\n    \n    private func hashFunction(key: String) -> Int {\n        return key.unicodeScalars.map { Int($0.value) }.reduce(0, +) % capacity\n    }\n    \n    mutating func insert(key: String, value: Value) {\n        if Double(size) / Double(capacity) > 0.75 {\n            resize()\n        }\n        \n        let index = hashFunction(key: key)\n        for (i, (k, _)) in table[index].enumerated() {\n            if k == key {\n                table[index][i] = (key, value)\n                return\n            }\n        }\n        \n        table[index].append((key, value))\n        size += 1\n    }\n    \n    mutating func delete(key: String) -> Bool {\n        let index = hashFunction(key: key)\n        for (i, (k, _)) in table[index].enumerated() {\n            if k == key {\n                table[index].remove(at: i)\n                size -= 1\n                return true\n            }\n        }\n        return false\n    }\n    \n    func search(key: String) -> Value? {\n        let index = hashFunction(key: key)\n        for (k, v) in table[index] {\n            if k == key {\n                return v\n            }\n        }\n        return nil\n    }\n    \n    private mutating func resize() {\n        let oldTable = table\n        capacity *= 2\n        table = Array(repeating: [], count: capacity)\n        size = 0\n        \n        for bucket in oldTable {\n            for (k, v) in bucket {\n                insert(key: k, value: v)\n            }\n        }\n    }\n}\nfunc testHashTable() {\n    var hashTable = HashTable<String>(initialCapacity: 4)\n    \n    // Test insertion\n    hashTable.insert(key: \"apple\", value: \"fruit\")\n    hashTable.insert(key: \"banana\", value: \"fruit\")\n    hashTable.insert(key: \"carrot\", value: \"vegetable\")\n    assert(hashTable.search(key: \"apple\") == \"fruit\")\n    assert(hashTable.search(key: \"banana\") == \"fruit\")\n    assert(hashTable.search(key: \"carrot\") == \"vegetable\")\n    \n    // Test update\n    hashTable.insert(key: \"apple\", value: \"red fruit\")\n    assert(hashTable.search(key: \"apple\") == \"red fruit\")\n    \n    // Test deletion\n    let deleted = hashTable.delete(key: \"banana\")\n    assert(deleted == true)\n    assert(hashTable.search(key: \"banana\") == nil)\n    \n    // Test non-existent key\n    assert(hashTable.search(key: \"grape\") == nil)\n    \n    // Test resize\n    hashTable.insert(key: \"dog\", value: \"animal\")\n    hashTable.insert(key: \"cat\", value: \"animal\")\n    hashTable.insert(key: \"elephant\", value: \"animal\")\n    assert(hashTable.search(key: \"dog\") == \"animal\")\n    assert(hashTable.search(key: \"cat\") == \"animal\")\n    assert(hashTable.search(key: \"elephant\") == \"animal\")\n}\n\ntestHashTable()", "exec_outcome": "PASSED"}
{"code": "// selectVillages selects three villages such that the first has the lowest wealth,\n// the second has the median wealth, and the third has the highest wealth.\n// It takes the number of villages and an array of their wealth values as input.\n// The function returns an array of three integers representing the indices (1-based) of the selected villages.\nfunc selectVillages(n: Int, wealths: [Int]) -> [Int] {\n    // Create an array of tuples containing wealth and its original 1-based index\n    let sortedWealths = wealths.enumerated().map { (index, wealth) in (wealth, index + 1) }.sorted { $0.0 < $1.0 }\n    // Extract indices for the lowest, median, and highest wealth villages\n    let lowestIndex = sortedWealths[0].1\n    let medianIndex = sortedWealths[n / 2].1\n    let highestIndex = sortedWealths[n - 1].1\n    return [lowestIndex, medianIndex, highestIndex]\n}", "test_cases": "", "test_case_results": "Number of villages: 5, Wealths: [10, 20, 30, 40, 50]\nSelected village indices: [1, 3, 5]\nNumber of villages: 6, Wealths: [60, 10, 30, 20, 50, 40]\nSelected village indices: [2, 6, 1]\nNumber of villages: 3, Wealths: [15, 15, 15]\nSelected village indices: [1, 2, 3]\nNumber of villages: 1, Wealths: [100]\nSelected village indices: [1, 1, 1]\nNumber of villages: 7, Wealths: [5, 3, 9, 1, 4, 8, 2]\nSelected village indices: [4, 5, 3]", "task_id": 3624, "assertions": "func testSelectVillages() {\n    assert(selectVillages(n: 5, wealths: [10, 20, 30, 40, 50]) == [1, 3, 5])\n    assert(selectVillages(n: 6, wealths: [60, 10, 30, 20, 50, 40]) == [2, 6, 1])\n    assert(selectVillages(n: 3, wealths: [15, 15, 15]) == [1, 2, 3])\n    assert(selectVillages(n: 1, wealths: [100]) == [1, 1, 1])\n    assert(selectVillages(n: 7, wealths: [5, 3, 9, 1, 4, 8, 2]) == [4, 5, 3])\n}\n\ntestSelectVillages()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSelectVillages() {\n    assert(selectVillages(n: 5, wealths: [10, 20, 30, 40, 50]) == [1, 3, 5])\n    assert(selectVillages(n: 6, wealths: [60, 10, 30, 20, 50, 40]) == [2, 6, 1])\n    assert(selectVillages(n: 3, wealths: [15, 15, 15]) == [1, 2, 3])\n    assert(selectVillages(n: 1, wealths: [100]) == [1, 1, 1])\n    assert(selectVillages(n: 7, wealths: [5, 3, 9, 1, 4, 8, 2]) == [4, 5, 3])\n}\n\ntestSelectVillages()", "output": "selectVillages"}, "all_code": "// selectVillages selects three villages such that the first has the lowest wealth,\n// the second has the median wealth, and the third has the highest wealth.\n// It takes the number of villages and an array of their wealth values as input.\n// The function returns an array of three integers representing the indices (1-based) of the selected villages.\nfunc selectVillages(n: Int, wealths: [Int]) -> [Int] {\n    // Create an array of tuples containing wealth and its original 1-based index\n    let sortedWealths = wealths.enumerated().map { (index, wealth) in (wealth, index + 1) }.sorted { $0.0 < $1.0 }\n    // Extract indices for the lowest, median, and highest wealth villages\n    let lowestIndex = sortedWealths[0].1\n    let medianIndex = sortedWealths[n / 2].1\n    let highestIndex = sortedWealths[n - 1].1\n    return [lowestIndex, medianIndex, highestIndex]\n}\nfunc testSelectVillages() {\n    assert(selectVillages(n: 5, wealths: [10, 20, 30, 40, 50]) == [1, 3, 5])\n    assert(selectVillages(n: 6, wealths: [60, 10, 30, 20, 50, 40]) == [2, 6, 1])\n    assert(selectVillages(n: 3, wealths: [15, 15, 15]) == [1, 2, 3])\n    assert(selectVillages(n: 1, wealths: [100]) == [1, 1, 1])\n    assert(selectVillages(n: 7, wealths: [5, 3, 9, 1, 4, 8, 2]) == [4, 5, 3])\n}\n\ntestSelectVillages()", "exec_outcome": "PASSED"}
{"code": "func smallestUniqueString(_ s: String) -> String {\n    var lastOccurrence = [Character: Int]()\n    for (i, char) in s.enumerated() {\n        lastOccurrence[char] = i\n    }\n    \n    var stack = [Character]()\n    var inStack = Set<Character>()\n    \n    for (i, char) in s.enumerated() {\n        if inStack.contains(char) {\n            continue\n        }\n        \n        while let last = stack.last, char < last, let lastIndex = lastOccurrence[last], lastIndex > i {\n            inStack.remove(stack.removeLast())\n        }\n        \n        stack.append(char)\n        inStack.insert(char)\n    }\n    \n    return String(stack)\n}", "test_cases": "", "test_case_results": "Input: \"bcabc\"\nResult: \"abc\"\nInput: \"cbacdcbc\"\nResult: \"acdb\"\nInput: \"abacb\"\nResult: \"abc\"\nInput: \"leetcode\"\nResult: \"letcod\"", "task_id": 29385, "assertions": "func testSmallestUniqueString() {\n    assert(smallestUniqueString(\"bcabc\") == \"abc\")\n    assert(smallestUniqueString(\"cbacdcbc\") == \"acdb\")\n    assert(smallestUniqueString(\"abacb\") == \"abc\")\n    assert(smallestUniqueString(\"leetcode\") == \"letcod\")\n}\n\ntestSmallestUniqueString()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSmallestUniqueString() {\n    assert(smallestUniqueString(\"bcabc\") == \"abc\")\n    assert(smallestUniqueString(\"cbacdcbc\") == \"acdb\")\n    assert(smallestUniqueString(\"abacb\") == \"abc\")\n    assert(smallestUniqueString(\"leetcode\") == \"letcod\")\n}\n\ntestSmallestUniqueString()", "output": "smallestUniqueString"}, "all_code": "func smallestUniqueString(_ s: String) -> String {\n    var lastOccurrence = [Character: Int]()\n    for (i, char) in s.enumerated() {\n        lastOccurrence[char] = i\n    }\n    \n    var stack = [Character]()\n    var inStack = Set<Character>()\n    \n    for (i, char) in s.enumerated() {\n        if inStack.contains(char) {\n            continue\n        }\n        \n        while let last = stack.last, char < last, let lastIndex = lastOccurrence[last], lastIndex > i {\n            inStack.remove(stack.removeLast())\n        }\n        \n        stack.append(char)\n        inStack.insert(char)\n    }\n    \n    return String(stack)\n}\nfunc testSmallestUniqueString() {\n    assert(smallestUniqueString(\"bcabc\") == \"abc\")\n    assert(smallestUniqueString(\"cbacdcbc\") == \"acdb\")\n    assert(smallestUniqueString(\"abacb\") == \"abc\")\n    assert(smallestUniqueString(\"leetcode\") == \"letcod\")\n}\n\ntestSmallestUniqueString()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// calculateAnnualCompoundInterest calculates the amount of money accumulated after n years,\n// including interest, with annual compounding.\n// It takes the principal amount, annual interest rate (as a decimal), number of times\n// the interest is compounded per year, and the number of years as inputs.\n// If any input is negative or 'times' is zero or negative, it returns nil to indicate an error.\nfunc calculateAnnualCompoundInterest(principal: Double, rate: Double, times: Int, years: Int) -> Double? {\n    if principal < 0 || rate < 0 || times <= 0 || years < 0 {\n        return nil\n    }\n    return principal * pow(1 + rate / Double(times), Double(times * years))\n}\n\n// calculateContinuousCompoundInterest calculates the amount of money accumulated after n years,\n// including interest, with continuous compounding.\n// It takes the principal amount, annual interest rate (as a decimal), and the number of years as inputs.\n// If any input is negative, it returns nil to indicate an error.\nfunc calculateContinuousCompoundInterest(principal: Double, rate: Double, years: Int) -> Double? {\n    if principal < 0 || rate < 0 || years < 0 {\n        return nil\n    }\n    return principal * exp(rate * Double(years))\n}", "test_cases": "", "test_case_results": "Testing Annual Compound Interest:\nInput: principal = 1000.0, rate = 0.05, times = 1, years = 10\nResult: 1628.894626777442\n---\nInput: principal = 1500.0, rate = 0.03, times = 4, years = 5\nResult: 1741.7762134547988\n---\nInput: principal = -500.0, rate = 0.02, times = 2, years = 3\nError: Invalid input parameters\n---\nInput: principal = 2000.0, rate = -0.01, times = 12, years = 10\nError: Invalid input parameters\n---\nInput: principal = 3000.0, rate = 0.04, times = 0, years = 5\nError: Invalid input parameters\n---\n\nTesting Continuous Compound Interest:\nInput: principal = 1000.0, rate = 0.05, years = 10\nResult: 1648.7212707001281\n---\nInput: principal = 1500.0, rate = 0.03, years = 5\nResult: 1742.7513640924246\n---\nInput: principal = -500.0, rate = 0.02, years = 3\nError: Invalid input parameters\n---\nInput: principal = 2000.0, rate = -0.01, years = 10\nError: Invalid input parameters\n---\nInput: principal = 3000.0, rate = 0.04, years = -5\nError: Invalid input parameters\n---", "task_id": 7885, "assertions": "func testCompoundInterestCalculations() {\n    // Test annual compound interest\n    assert(calculateAnnualCompoundInterest(principal: 1000.0, rate: 0.05, times: 1, years: 10) == 1628.894626777442)\n    assert(calculateAnnualCompoundInterest(principal: 1500.0, rate: 0.03, times: 4, years: 5) == 1741.7762134547988)\n    assert(calculateAnnualCompoundInterest(principal: -500.0, rate: 0.02, times: 2, years: 3) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 2000.0, rate: -0.01, times: 12, years: 10) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 3000.0, rate: 0.04, times: 0, years: 5) == nil)\n    \n    // Test continuous compound interest\n    assert(calculateContinuousCompoundInterest(principal: 1000.0, rate: 0.05, years: 10) == 1648.7212707001281)\n    assert(calculateContinuousCompoundInterest(principal: 1500.0, rate: 0.03, years: 5) == 1742.7513640924246)\n    assert(calculateContinuousCompoundInterest(principal: -500.0, rate: 0.02, years: 3) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 2000.0, rate: -0.01, years: 10) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 3000.0, rate: 0.04, years: -5) == nil)\n}\n\ntestCompoundInterestCalculations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCompoundInterestCalculations() {\n    // Test annual compound interest\n    assert(calculateAnnualCompoundInterest(principal: 1000.0, rate: 0.05, times: 1, years: 10) == 1628.894626777442)\n    assert(calculateAnnualCompoundInterest(principal: 1500.0, rate: 0.03, times: 4, years: 5) == 1741.7762134547988)\n    assert(calculateAnnualCompoundInterest(principal: -500.0, rate: 0.02, times: 2, years: 3) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 2000.0, rate: -0.01, times: 12, years: 10) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 3000.0, rate: 0.04, times: 0, years: 5) == nil)\n    \n    // Test continuous compound interest\n    assert(calculateContinuousCompoundInterest(principal: 1000.0, rate: 0.05, years: 10) == 1648.7212707001281)\n    assert(calculateContinuousCompoundInterest(principal: 1500.0, rate: 0.03, years: 5) == 1742.7513640924246)\n    assert(calculateContinuousCompoundInterest(principal: -500.0, rate: 0.02, years: 3) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 2000.0, rate: -0.01, years: 10) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 3000.0, rate: 0.04, years: -5) == nil)\n}\n\ntestCompoundInterestCalculations()", "output": "The functions being tested are:\n`calculateAnnualCompoundInterest` and `calculateContinuousCompoundInterest`"}, "all_code": "import Glibc\n\nimport Foundation\n\n// calculateAnnualCompoundInterest calculates the amount of money accumulated after n years,\n// including interest, with annual compounding.\n// It takes the principal amount, annual interest rate (as a decimal), number of times\n// the interest is compounded per year, and the number of years as inputs.\n// If any input is negative or 'times' is zero or negative, it returns nil to indicate an error.\nfunc calculateAnnualCompoundInterest(principal: Double, rate: Double, times: Int, years: Int) -> Double? {\n    if principal < 0 || rate < 0 || times <= 0 || years < 0 {\n        return nil\n    }\n    return principal * pow(1 + rate / Double(times), Double(times * years))\n}\n\n// calculateContinuousCompoundInterest calculates the amount of money accumulated after n years,\n// including interest, with continuous compounding.\n// It takes the principal amount, annual interest rate (as a decimal), and the number of years as inputs.\n// If any input is negative, it returns nil to indicate an error.\nfunc calculateContinuousCompoundInterest(principal: Double, rate: Double, years: Int) -> Double? {\n    if principal < 0 || rate < 0 || years < 0 {\n        return nil\n    }\n    return principal * exp(rate * Double(years))\n}\nfunc testCompoundInterestCalculations() {\n    // Test annual compound interest\n    assert(calculateAnnualCompoundInterest(principal: 1000.0, rate: 0.05, times: 1, years: 10) == 1628.894626777442)\n    assert(calculateAnnualCompoundInterest(principal: 1500.0, rate: 0.03, times: 4, years: 5) == 1741.7762134547988)\n    assert(calculateAnnualCompoundInterest(principal: -500.0, rate: 0.02, times: 2, years: 3) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 2000.0, rate: -0.01, times: 12, years: 10) == nil)\n    assert(calculateAnnualCompoundInterest(principal: 3000.0, rate: 0.04, times: 0, years: 5) == nil)\n    \n    // Test continuous compound interest\n    assert(calculateContinuousCompoundInterest(principal: 1000.0, rate: 0.05, years: 10) == 1648.7212707001281)\n    assert(calculateContinuousCompoundInterest(principal: 1500.0, rate: 0.03, years: 5) == 1742.7513640924246)\n    assert(calculateContinuousCompoundInterest(principal: -500.0, rate: 0.02, years: 3) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 2000.0, rate: -0.01, years: 10) == nil)\n    assert(calculateContinuousCompoundInterest(principal: 3000.0, rate: 0.04, years: -5) == nil)\n}\n\ntestCompoundInterestCalculations()", "exec_outcome": "PASSED"}
{"code": "// checkMatrixDiagonal checks if all elements in each diagonal of a square matrix are the same.\n// It uses a nested function checkDiagonal to verify each diagonal starting from the first row and first column.\n// The function returns true if all diagonals have the same elements, otherwise false.\nfunc checkMatrixDiagonal(matrix: [[Int]]) -> Bool {\n    // checkDiagonal verifies if all elements in a diagonal starting at (i, j) are the same.\n    func checkDiagonal(i: Int, j: Int) -> Bool {\n        let value = matrix[i][j]\n        var currentI = i\n        var currentJ = j\n        while currentI < matrix.count && currentJ < matrix[0].count {\n            if matrix[currentI][currentJ] != value {\n                return false\n            }\n            currentI += 1\n            currentJ += 1\n        }\n        return true\n    }\n    \n    // Check diagonals starting from the first row\n    for j in 0..<matrix[0].count {\n        if !checkDiagonal(i: 0, j: j) {\n            return false\n        }\n    }\n    \n    // Check diagonals starting from the first column (excluding the top-left element as it was already checked)\n    for i in 1..<matrix.count {\n        if !checkDiagonal(i: i, j: 0) {\n            return false\n        }\n    }\n    \n    return true\n}", "test_cases": "", "test_case_results": "Input matrix:\n[1, 2, 3]\n[4, 1, 2]\n[5, 4, 1]\nAll diagonals have the same elements: true\n\nInput matrix:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\nAll diagonals have the same elements: false\n\nInput matrix:\n[1, 0, 0]\n[0, 1, 0]\n[0, 0, 1]\nAll diagonals have the same elements: true", "task_id": 29606, "assertions": "func testCheckMatrixDiagonal() {\n    let testCase1 = [\n        [1, 2, 3],\n        [4, 1, 2],\n        [5, 4, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase1) == true)\n    \n    let testCase2 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase2) == false)\n    \n    let testCase3 = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase3) == true)\n}\n\ntestCheckMatrixDiagonal()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCheckMatrixDiagonal() {\n    let testCase1 = [\n        [1, 2, 3],\n        [4, 1, 2],\n        [5, 4, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase1) == true)\n    \n    let testCase2 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase2) == false)\n    \n    let testCase3 = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase3) == true)\n}\n\ntestCheckMatrixDiagonal()", "output": "checkMatrixDiagonal"}, "all_code": "// checkMatrixDiagonal checks if all elements in each diagonal of a square matrix are the same.\n// It uses a nested function checkDiagonal to verify each diagonal starting from the first row and first column.\n// The function returns true if all diagonals have the same elements, otherwise false.\nfunc checkMatrixDiagonal(matrix: [[Int]]) -> Bool {\n    // checkDiagonal verifies if all elements in a diagonal starting at (i, j) are the same.\n    func checkDiagonal(i: Int, j: Int) -> Bool {\n        let value = matrix[i][j]\n        var currentI = i\n        var currentJ = j\n        while currentI < matrix.count && currentJ < matrix[0].count {\n            if matrix[currentI][currentJ] != value {\n                return false\n            }\n            currentI += 1\n            currentJ += 1\n        }\n        return true\n    }\n    \n    // Check diagonals starting from the first row\n    for j in 0..<matrix[0].count {\n        if !checkDiagonal(i: 0, j: j) {\n            return false\n        }\n    }\n    \n    // Check diagonals starting from the first column (excluding the top-left element as it was already checked)\n    for i in 1..<matrix.count {\n        if !checkDiagonal(i: i, j: 0) {\n            return false\n        }\n    }\n    \n    return true\n}\nfunc testCheckMatrixDiagonal() {\n    let testCase1 = [\n        [1, 2, 3],\n        [4, 1, 2],\n        [5, 4, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase1) == true)\n    \n    let testCase2 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase2) == false)\n    \n    let testCase3 = [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]\n    ]\n    assert(checkMatrixDiagonal(matrix: testCase3) == true)\n}\n\ntestCheckMatrixDiagonal()", "exec_outcome": "PASSED"}
{"code": "// canReachEnd checks if there's a path from the start position to the end of the maze (bottom-right corner).\n// The maze is represented as a 2D array where 0 indicates a passable cell and 1 indicates a blocked cell.\n// The function uses Depth-First Search (DFS) to explore possible paths, marking visited cells to avoid cycles.\nfunc canReachEnd(maze: [[Int]], start: (Int, Int)) -> Bool {\n    let rows = maze.count\n    guard rows > 0 else { return false }\n    let cols = maze[0].count\n    let target = (rows - 1, cols - 1)\n    \n    // Make a mutable copy of the maze to mark visited cells\n    var mutableMaze = maze\n    \n    // is_valid checks if the given coordinates are within bounds and the cell is passable\n    func is_valid(x: Int, y: Int) -> Bool {\n        return x >= 0 && x < rows && y >= 0 && y < cols && mutableMaze[x][y] == 0\n    }\n    \n    // dfs performs a depth-first search from the given coordinates\n    func dfs(x: Int, y: Int) -> Bool {\n        if (x, y) == target {\n            return true\n        }\n        mutableMaze[x][y] = 1  // mark as visited to prevent cycles\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions {\n            let nx = x + dx\n            let ny = y + dy\n            if is_valid(x: nx, y: ny) {\n                if dfs(x: nx, y: ny) {\n                    return true\n                }\n            }\n        }\n        \n        return false\n    }\n    \n    return dfs(x: start.0, y: start.1)\n}", "test_cases": "", "test_case_results": "Maze:\n[0, 0, 0]\n[1, 1, 0]\n[0, 0, 0]\nStart position: (0, 0)\nCan reach end: true\n---\nMaze:\n[0, 1, 0]\n[1, 1, 0]\n[0, 0, 0]\nStart position: (0, 0)\nCan reach end: false\n---\nMaze:\n[0, 0, 0, 0]\n[1, 1, 0, 1]\n[0, 0, 0, 0]\n[0, 1, 1, 0]\nStart position: (0, 0)\nCan reach end: true\n---\nMaze:\n[0, 0]\n[0, 0]\nStart position: (0, 0)\nCan reach end: true\n---", "task_id": 14365, "assertions": "func testCanReachEnd() {\n    let testCases: [([[Int]], (Int, Int), Bool)] = [\n        (\n            [\n                [0, 0, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 1, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            false\n        ),\n        (\n            [\n                [0, 0, 0, 0],\n                [1, 1, 0, 1],\n                [0, 0, 0, 0],\n                [0, 1, 1, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 0],\n                [0, 0]\n            ],\n            (0, 0),\n            true\n        )\n    ]\n    \n    for (maze, start, expected) in testCases {\n        let result = canReachEnd(maze: maze, start: start)\n        assert(result == expected, \"Test failed for maze: \\(maze), start: \\(start). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestCanReachEnd()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCanReachEnd() {\n    let testCases: [([[Int]], (Int, Int), Bool)] = [\n        (\n            [\n                [0, 0, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 1, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            false\n        ),\n        (\n            [\n                [0, 0, 0, 0],\n                [1, 1, 0, 1],\n                [0, 0, 0, 0],\n                [0, 1, 1, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 0],\n                [0, 0]\n            ],\n            (0, 0),\n            true\n        )\n    ]\n    \n    for (maze, start, expected) in testCases {\n        let result = canReachEnd(maze: maze, start: start)\n        assert(result == expected, \"Test failed for maze: \\(maze), start: \\(start). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestCanReachEnd()", "output": "canReachEnd"}, "all_code": "import Foundation\nimport Glibc\n\n// canReachEnd checks if there's a path from the start position to the end of the maze (bottom-right corner).\n// The maze is represented as a 2D array where 0 indicates a passable cell and 1 indicates a blocked cell.\n// The function uses Depth-First Search (DFS) to explore possible paths, marking visited cells to avoid cycles.\nfunc canReachEnd(maze: [[Int]], start: (Int, Int)) -> Bool {\n    let rows = maze.count\n    guard rows > 0 else { return false }\n    let cols = maze[0].count\n    let target = (rows - 1, cols - 1)\n    \n    // Make a mutable copy of the maze to mark visited cells\n    var mutableMaze = maze\n    \n    // is_valid checks if the given coordinates are within bounds and the cell is passable\n    func is_valid(x: Int, y: Int) -> Bool {\n        return x >= 0 && x < rows && y >= 0 && y < cols && mutableMaze[x][y] == 0\n    }\n    \n    // dfs performs a depth-first search from the given coordinates\n    func dfs(x: Int, y: Int) -> Bool {\n        if (x, y) == target {\n            return true\n        }\n        mutableMaze[x][y] = 1  // mark as visited to prevent cycles\n        \n        let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for (dx, dy) in directions {\n            let nx = x + dx\n            let ny = y + dy\n            if is_valid(x: nx, y: ny) {\n                if dfs(x: nx, y: ny) {\n                    return true\n                }\n            }\n        }\n        \n        return false\n    }\n    \n    return dfs(x: start.0, y: start.1)\n}\nfunc testCanReachEnd() {\n    let testCases: [([[Int]], (Int, Int), Bool)] = [\n        (\n            [\n                [0, 0, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 1, 0],\n                [1, 1, 0],\n                [0, 0, 0]\n            ],\n            (0, 0),\n            false\n        ),\n        (\n            [\n                [0, 0, 0, 0],\n                [1, 1, 0, 1],\n                [0, 0, 0, 0],\n                [0, 1, 1, 0]\n            ],\n            (0, 0),\n            true\n        ),\n        (\n            [\n                [0, 0],\n                [0, 0]\n            ],\n            (0, 0),\n            true\n        )\n    ]\n    \n    for (maze, start, expected) in testCases {\n        let result = canReachEnd(maze: maze, start: start)\n        assert(result == expected, \"Test failed for maze: \\(maze), start: \\(start). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestCanReachEnd()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// isBeautifulPossible checks if a given string can be rearranged such that no two adjacent characters are the same.\n// The function counts the frequency of each character and determines if the most frequent character's count\n// exceeds the sum of all other characters' counts plus one. If it does, it returns \"NO\"; otherwise, it returns \"YES\".\nfunc isBeautifulPossible(_ s: String) -> String {\n    // Count the frequency of each character\n    var freq = [Character: Int]()\n    for char in s {\n        freq[char] = (freq[char] ?? 0) + 1\n    }\n    \n    // Find the maximum frequency\n    guard let maxFreq = freq.values.max() else {\n        return \"YES\" // Empty string case\n    }\n    \n    // Check if rearrangement is possible\n    if maxFreq > (s.count - maxFreq + 1) {\n        return \"NO\"\n    } else {\n        return \"YES\"\n    }\n}\n\n// processTestCases takes an array of strings and returns an array of results indicating\n// whether each string can be rearranged to meet the adjacency requirement.\nfunc processTestCases(_ testCases: [String]) -> [String] {\n    return testCases.map { isBeautifulPossible($0) }\n}", "test_cases": "", "test_case_results": "Testing individual strings:\nInput: \"aab\"\nResult: YES\nInput: \"aaab\"\nResult: NO\nInput: \"abc\"\nResult: YES\nInput: \"a\"\nResult: YES\nInput: \"\"\nResult: YES\nInput: \"aaaabbcc\"\nResult: YES\n\nTesting batch processing:\nTest case 1: \"aab\" -> YES\nTest case 2: \"aaab\" -> NO\nTest case 3: \"abc\" -> YES\nTest case 4: \"a\" -> YES\nTest case 5: \"\" -> YES\nTest case 6: \"aaaabbcc\" -> YES", "task_id": 21645, "assertions": "func testIsBeautifulPossible() {\n    assert(isBeautifulPossible(\"aab\") == \"YES\")\n    assert(isBeautifulPossible(\"aaab\") == \"NO\")\n    assert(isBeautifulPossible(\"abc\") == \"YES\")\n    assert(isBeautifulPossible(\"a\") == \"YES\")\n    assert(isBeautifulPossible(\"\") == \"YES\")\n    assert(isBeautifulPossible(\"aaaabbcc\") == \"YES\")\n    \n    let testCases = [\"aab\", \"aaab\", \"abc\", \"a\", \"\", \"aaaabbcc\"]\n    let expectedResults = [\"YES\", \"NO\", \"YES\", \"YES\", \"YES\", \"YES\"]\n    let results = processTestCases(testCases)\n    assert(results == expectedResults)\n}\n\ntestIsBeautifulPossible()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsBeautifulPossible() {\n    assert(isBeautifulPossible(\"aab\") == \"YES\")\n    assert(isBeautifulPossible(\"aaab\") == \"NO\")\n    assert(isBeautifulPossible(\"abc\") == \"YES\")\n    assert(isBeautifulPossible(\"a\") == \"YES\")\n    assert(isBeautifulPossible(\"\") == \"YES\")\n    assert(isBeautifulPossible(\"aaaabbcc\") == \"YES\")\n    \n    let testCases = [\"aab\", \"aaab\", \"abc\", \"a\", \"\", \"aaaabbcc\"]\n    let expectedResults = [\"YES\", \"NO\", \"YES\", \"YES\", \"YES\", \"YES\"]\n    let results = processTestCases(testCases)\n    assert(results == expectedResults)\n}\n\ntestIsBeautifulPossible()", "output": "isBeautifulPossible"}, "all_code": "import Foundation\n\n// isBeautifulPossible checks if a given string can be rearranged such that no two adjacent characters are the same.\n// The function counts the frequency of each character and determines if the most frequent character's count\n// exceeds the sum of all other characters' counts plus one. If it does, it returns \"NO\"; otherwise, it returns \"YES\".\nfunc isBeautifulPossible(_ s: String) -> String {\n    // Count the frequency of each character\n    var freq = [Character: Int]()\n    for char in s {\n        freq[char] = (freq[char] ?? 0) + 1\n    }\n    \n    // Find the maximum frequency\n    guard let maxFreq = freq.values.max() else {\n        return \"YES\" // Empty string case\n    }\n    \n    // Check if rearrangement is possible\n    if maxFreq > (s.count - maxFreq + 1) {\n        return \"NO\"\n    } else {\n        return \"YES\"\n    }\n}\n\n// processTestCases takes an array of strings and returns an array of results indicating\n// whether each string can be rearranged to meet the adjacency requirement.\nfunc processTestCases(_ testCases: [String]) -> [String] {\n    return testCases.map { isBeautifulPossible($0) }\n}\nfunc testIsBeautifulPossible() {\n    assert(isBeautifulPossible(\"aab\") == \"YES\")\n    assert(isBeautifulPossible(\"aaab\") == \"NO\")\n    assert(isBeautifulPossible(\"abc\") == \"YES\")\n    assert(isBeautifulPossible(\"a\") == \"YES\")\n    assert(isBeautifulPossible(\"\") == \"YES\")\n    assert(isBeautifulPossible(\"aaaabbcc\") == \"YES\")\n    \n    let testCases = [\"aab\", \"aaab\", \"abc\", \"a\", \"\", \"aaaabbcc\"]\n    let expectedResults = [\"YES\", \"NO\", \"YES\", \"YES\", \"YES\", \"YES\"]\n    let results = processTestCases(testCases)\n    assert(results == expectedResults)\n}\n\ntestIsBeautifulPossible()", "exec_outcome": "PASSED"}
{"code": "// countDistinctArtifacts calculates the number of distinct artifacts in a given sequence.\n// It uses a Set to determine the unique elements in the input string.\n// The function returns the count of these unique elements.\nfunc countDistinctArtifacts(artifactSequence: String) -> Int {\n    let uniqueArtifacts = Set(artifactSequence)\n    return uniqueArtifacts.count\n}", "test_cases": "", "test_case_results": "Input: \"ABCABC\"\nDistinct artifacts: 3\nInput: \"AAAAA\"\nDistinct artifacts: 1\nInput: \"AB\"\nDistinct artifacts: 2\nInput: \"\"\nDistinct artifacts: 0", "task_id": 1647, "assertions": "func testCountDistinctArtifacts() {\n    assert(countDistinctArtifacts(artifactSequence: \"ABCABC\") == 3)\n    assert(countDistinctArtifacts(artifactSequence: \"AAAAA\") == 1)\n    assert(countDistinctArtifacts(artifactSequence: \"AB\") == 2)\n    assert(countDistinctArtifacts(artifactSequence: \"\") == 0)\n}\n\ntestCountDistinctArtifacts()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountDistinctArtifacts() {\n    assert(countDistinctArtifacts(artifactSequence: \"ABCABC\") == 3)\n    assert(countDistinctArtifacts(artifactSequence: \"AAAAA\") == 1)\n    assert(countDistinctArtifacts(artifactSequence: \"AB\") == 2)\n    assert(countDistinctArtifacts(artifactSequence: \"\") == 0)\n}\n\ntestCountDistinctArtifacts()", "output": "countDistinctArtifacts"}, "all_code": "// countDistinctArtifacts calculates the number of distinct artifacts in a given sequence.\n// It uses a Set to determine the unique elements in the input string.\n// The function returns the count of these unique elements.\nfunc countDistinctArtifacts(artifactSequence: String) -> Int {\n    let uniqueArtifacts = Set(artifactSequence)\n    return uniqueArtifacts.count\n}\nfunc testCountDistinctArtifacts() {\n    assert(countDistinctArtifacts(artifactSequence: \"ABCABC\") == 3)\n    assert(countDistinctArtifacts(artifactSequence: \"AAAAA\") == 1)\n    assert(countDistinctArtifacts(artifactSequence: \"AB\") == 2)\n    assert(countDistinctArtifacts(artifactSequence: \"\") == 0)\n}\n\ntestCountDistinctArtifacts()", "exec_outcome": "PASSED"}
{"code": "// uniquePaths calculates the number of unique paths a robot can take from the top-left corner\n// to the bottom-right corner of an m x n grid, avoiding blocked cells.\n// The robot can only move right or down at any point in time.\n// If the start or end cell is blocked, it returns 0.\nfunc uniquePaths(m: Int, n: Int, blocked: [(Int, Int)]) -> Int {\n    // Early exit if the start or end is blocked.\n    if blocked.contains(where: { $0 == (0, 0) }) || blocked.contains(where: { $0 == (m-1, n-1) }) {\n        return 0\n    }\n    \n    // Create a grid to store the number of ways to reach each cell\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n    \n    // Set up the initial position\n    dp[0][0] = 1\n    \n    // Iterate over each cell in the grid\n    for i in 0..<m {\n        for j in 0..<n {\n            if blocked.contains(where: { $0 == (i, j) }) {\n                dp[i][j] = 0  // If the cell is blocked, no paths through it\n            } else {\n                if i > 0 {  // Move from the cell above\n                    dp[i][j] += dp[i-1][j]\n                }\n                if j > 0 {  // Move from the cell on the left\n                    dp[i][j] += dp[i][j-1]\n                }\n            }\n        }\n    }\n    \n    // The value in the bottom-right corner is the number of unique paths\n    return dp[m-1][n-1]\n}", "test_cases": "", "test_case_results": "Grid: 3x3, Blocked: [(1, 1)]\nUnique paths: 2\nGrid: 3x3, Blocked: []\nUnique paths: 6\nGrid: 3x3, Blocked: [(0, 1)]\nUnique paths: 3\nGrid: 2x2, Blocked: [(0, 0)]\nUnique paths: 0\nGrid: 2x2, Blocked: [(1, 1)]\nUnique paths: 0\nGrid: 1x1, Blocked: []\nUnique paths: 1", "task_id": 8995, "assertions": "func testUniquePaths() {\n    assert(uniquePaths(m: 3, n: 3, blocked: [(1, 1)]) == 2)\n    assert(uniquePaths(m: 3, n: 3, blocked: []) == 6)\n    assert(uniquePaths(m: 3, n: 3, blocked: [(0, 1)]) == 3)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(0, 0)]) == 0)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(1, 1)]) == 0)\n    assert(uniquePaths(m: 1, n: 1, blocked: []) == 1)\n}\n\ntestUniquePaths()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testUniquePaths() {\n    assert(uniquePaths(m: 3, n: 3, blocked: [(1, 1)]) == 2)\n    assert(uniquePaths(m: 3, n: 3, blocked: []) == 6)\n    assert(uniquePaths(m: 3, n: 3, blocked: [(0, 1)]) == 3)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(0, 0)]) == 0)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(1, 1)]) == 0)\n    assert(uniquePaths(m: 1, n: 1, blocked: []) == 1)\n}\n\ntestUniquePaths()", "output": "uniquePaths"}, "all_code": "// uniquePaths calculates the number of unique paths a robot can take from the top-left corner\n// to the bottom-right corner of an m x n grid, avoiding blocked cells.\n// The robot can only move right or down at any point in time.\n// If the start or end cell is blocked, it returns 0.\nfunc uniquePaths(m: Int, n: Int, blocked: [(Int, Int)]) -> Int {\n    // Early exit if the start or end is blocked.\n    if blocked.contains(where: { $0 == (0, 0) }) || blocked.contains(where: { $0 == (m-1, n-1) }) {\n        return 0\n    }\n    \n    // Create a grid to store the number of ways to reach each cell\n    var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\n    \n    // Set up the initial position\n    dp[0][0] = 1\n    \n    // Iterate over each cell in the grid\n    for i in 0..<m {\n        for j in 0..<n {\n            if blocked.contains(where: { $0 == (i, j) }) {\n                dp[i][j] = 0  // If the cell is blocked, no paths through it\n            } else {\n                if i > 0 {  // Move from the cell above\n                    dp[i][j] += dp[i-1][j]\n                }\n                if j > 0 {  // Move from the cell on the left\n                    dp[i][j] += dp[i][j-1]\n                }\n            }\n        }\n    }\n    \n    // The value in the bottom-right corner is the number of unique paths\n    return dp[m-1][n-1]\n}\nfunc testUniquePaths() {\n    assert(uniquePaths(m: 3, n: 3, blocked: [(1, 1)]) == 2)\n    assert(uniquePaths(m: 3, n: 3, blocked: []) == 6)\n    assert(uniquePaths(m: 3, n: 3, blocked: [(0, 1)]) == 3)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(0, 0)]) == 0)\n    assert(uniquePaths(m: 2, n: 2, blocked: [(1, 1)]) == 0)\n    assert(uniquePaths(m: 1, n: 1, blocked: []) == 1)\n}\n\ntestUniquePaths()", "exec_outcome": "PASSED"}
{"code": "// findPairsWithSameRemainder finds all pairs of elements in the array that have the same remainder when divided by 5.\n// It uses a dictionary to group numbers by their remainder when divided by 5.\n// For each remainder group with at least two numbers, it generates all possible pairs and returns them as an array of tuples.\nfunc findPairsWithSameRemainder(_ arr: [Int]) -> [(Int, Int)] {\n    var remainders = [Int: [Int]]()\n    var pairs = [(Int, Int)]()\n\n    for num in arr {\n        let remainder = num % 5\n        remainders[remainder, default: []].append(num)\n    }\n\n    for (_, nums) in remainders {\n        if nums.count >= 2 {\n            for i in 0..<nums.count {\n                for j in i+1..<nums.count {\n                    pairs.append((nums[i], nums[j]))\n                }\n            }\n        }\n    }\n\n    return pairs\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nPairs with same remainder when divided by 5: [(2, 7), (3, 8), (5, 10), (4, 9), (1, 6)]\nInput: [5, 10, 15, 20]\nPairs with same remainder when divided by 5: [(5, 10), (5, 15), (5, 20), (10, 15), (10, 20), (15, 20)]\nInput: [3, 8, 13, 18]\nPairs with same remainder when divided by 5: [(3, 8), (3, 13), (3, 18), (8, 13), (8, 18), (13, 18)]\nInput: [1, 2, 3, 4]\nPairs with same remainder when divided by 5: []\nInput: []\nPairs with same remainder when divided by 5: []", "task_id": 14813, "assertions": "func testFindPairsWithSameRemainder() {\n    assert(findPairsWithSameRemainder([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(2, 7), (3, 8), (5, 10), (4, 9), (1, 6)])\n    assert(findPairsWithSameRemainder([5, 10, 15, 20]) == [(5, 10), (5, 15), (5, 20), (10, 15), (10, 20), (15, 20)])\n    assert(findPairsWithSameRemainder([3, 8, 13, 18]) == [(3, 8), (3, 13), (3, 18), (8, 13), (8, 18), (13, 18)])\n    assert(findPairsWithSameRemainder([1, 2, 3, 4]) == [])\n    assert(findPairsWithSameRemainder([]) == [])\n}\n\ntestFindPairsWithSameRemainder()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindPairsWithSameRemainder() {\n    assert(findPairsWithSameRemainder([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(2, 7), (3, 8), (5, 10), (4, 9), (1, 6)])\n    assert(findPairsWithSameRemainder([5, 10, 15, 20]) == [(5, 10), (5, 15), (5, 20), (10, 15), (10, 20), (15, 20)])\n    assert(findPairsWithSameRemainder([3, 8, 13, 18]) == [(3, 8), (3, 13), (3, 18), (8, 13), (8, 18), (13, 18)])\n    assert(findPairsWithSameRemainder([1, 2, 3, 4]) == [])\n    assert(findPairsWithSameRemainder([]) == [])\n}\n\ntestFindPairsWithSameRemainder()", "output": "findPairsWithSameRemainder"}, "all_code": "// findPairsWithSameRemainder finds all pairs of elements in the array that have the same remainder when divided by 5.\n// It uses a dictionary to group numbers by their remainder when divided by 5.\n// For each remainder group with at least two numbers, it generates all possible pairs and returns them as an array of tuples.\nfunc findPairsWithSameRemainder(_ arr: [Int]) -> [(Int, Int)] {\n    var remainders = [Int: [Int]]()\n    var pairs = [(Int, Int)]()\n\n    for num in arr {\n        let remainder = num % 5\n        remainders[remainder, default: []].append(num)\n    }\n\n    for (_, nums) in remainders {\n        if nums.count >= 2 {\n            for i in 0..<nums.count {\n                for j in i+1..<nums.count {\n                    pairs.append((nums[i], nums[j]))\n                }\n            }\n        }\n    }\n\n    return pairs\n}\nfunc testFindPairsWithSameRemainder() {\n    assert(findPairsWithSameRemainder([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(2, 7), (3, 8), (5, 10), (4, 9), (1, 6)])\n    assert(findPairsWithSameRemainder([5, 10, 15, 20]) == [(5, 10), (5, 15), (5, 20), (10, 15), (10, 20), (15, 20)])\n    assert(findPairsWithSameRemainder([3, 8, 13, 18]) == [(3, 8), (3, 13), (3, 18), (8, 13), (8, 18), (13, 18)])\n    assert(findPairsWithSameRemainder([1, 2, 3, 4]) == [])\n    assert(findPairsWithSameRemainder([]) == [])\n}\n\ntestFindPairsWithSameRemainder()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// hasMultiplePair determines if there exists a pair of paintings in the collection such that\n// the number of brush strokes used in one painting is a multiple of the number of brush strokes used in the other painting.\n//\n// Parameters:\n//   - n: The number of paintings.\n//   - brushStrokes: An array of integers representing the number of brush strokes used in each painting.\n//\n// Returns: \"Yes\" if such a pair exists, otherwise \"No\".\nfunc hasMultiplePair(n: Int, brushStrokes: [Int]) -> String {\n    for i in 0..<n {\n        for j in i+1..<n {\n            if brushStrokes[i] % brushStrokes[j] == 0 || brushStrokes[j] % brushStrokes[i] == 0 {\n                return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\n}", "test_cases": "", "test_case_results": "Number of paintings: 3, Brush strokes: [2, 4, 6]\nYes\nNumber of paintings: 4, Brush strokes: [3, 5, 7, 9]\nYes\nNumber of paintings: 2, Brush strokes: [7, 11]\nNo\nNumber of paintings: 1, Brush strokes: [5]\nNo\nNumber of paintings: 5, Brush strokes: [1, 2, 3, 4, 5]\nYes", "task_id": 13186, "assertions": "func testHasMultiplePair() {\n    assert(hasMultiplePair(n: 3, brushStrokes: [2, 4, 6]) == \"Yes\")\n    assert(hasMultiplePair(n: 4, brushStrokes: [3, 5, 7, 9]) == \"Yes\")\n    assert(hasMultiplePair(n: 2, brushStrokes: [7, 11]) == \"No\")\n    assert(hasMultiplePair(n: 1, brushStrokes: [5]) == \"No\")\n    assert(hasMultiplePair(n: 5, brushStrokes: [1, 2, 3, 4, 5]) == \"Yes\")\n}\n\ntestHasMultiplePair()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testHasMultiplePair() {\n    assert(hasMultiplePair(n: 3, brushStrokes: [2, 4, 6]) == \"Yes\")\n    assert(hasMultiplePair(n: 4, brushStrokes: [3, 5, 7, 9]) == \"Yes\")\n    assert(hasMultiplePair(n: 2, brushStrokes: [7, 11]) == \"No\")\n    assert(hasMultiplePair(n: 1, brushStrokes: [5]) == \"No\")\n    assert(hasMultiplePair(n: 5, brushStrokes: [1, 2, 3, 4, 5]) == \"Yes\")\n}\n\ntestHasMultiplePair()", "output": "hasMultiplePair"}, "all_code": "// hasMultiplePair determines if there exists a pair of paintings in the collection such that\n// the number of brush strokes used in one painting is a multiple of the number of brush strokes used in the other painting.\n//\n// Parameters:\n//   - n: The number of paintings.\n//   - brushStrokes: An array of integers representing the number of brush strokes used in each painting.\n//\n// Returns: \"Yes\" if such a pair exists, otherwise \"No\".\nfunc hasMultiplePair(n: Int, brushStrokes: [Int]) -> String {\n    for i in 0..<n {\n        for j in i+1..<n {\n            if brushStrokes[i] % brushStrokes[j] == 0 || brushStrokes[j] % brushStrokes[i] == 0 {\n                return \"Yes\"\n            }\n        }\n    }\n    return \"No\"\n}\nfunc testHasMultiplePair() {\n    assert(hasMultiplePair(n: 3, brushStrokes: [2, 4, 6]) == \"Yes\")\n    assert(hasMultiplePair(n: 4, brushStrokes: [3, 5, 7, 9]) == \"Yes\")\n    assert(hasMultiplePair(n: 2, brushStrokes: [7, 11]) == \"No\")\n    assert(hasMultiplePair(n: 1, brushStrokes: [5]) == \"No\")\n    assert(hasMultiplePair(n: 5, brushStrokes: [1, 2, 3, 4, 5]) == \"Yes\")\n}\n\ntestHasMultiplePair()", "exec_outcome": "PASSED"}
{"code": "// isUniqueString checks if all characters in a given string are unique.\n// It does this by comparing the length of the string to the length of a set created from the string.\n// Sets automatically remove duplicate characters, so if the lengths are equal, all characters are unique.\nfunc isUniqueString(_ s: String) -> Bool {\n    return s.count == Set(s).count\n}", "test_cases": "", "test_case_results": "Input: \"abcde\"\nAll characters unique: true\nInput: \"hello\"\nAll characters unique: false\nInput: \"world\"\nAll characters unique: true\nInput: \"swift\"\nAll characters unique: true\nInput: \"unique\"\nAll characters unique: false", "task_id": 25572, "assertions": "func testIsUniqueString() {\n    assert(isUniqueString(\"abcde\") == true)\n    assert(isUniqueString(\"hello\") == false)\n    assert(isUniqueString(\"world\") == true)\n    assert(isUniqueString(\"swift\") == true)\n    assert(isUniqueString(\"unique\") == false)\n}\n\ntestIsUniqueString()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsUniqueString() {\n    assert(isUniqueString(\"abcde\") == true)\n    assert(isUniqueString(\"hello\") == false)\n    assert(isUniqueString(\"world\") == true)\n    assert(isUniqueString(\"swift\") == true)\n    assert(isUniqueString(\"unique\") == false)\n}\n\ntestIsUniqueString()", "output": "isUniqueString"}, "all_code": "// isUniqueString checks if all characters in a given string are unique.\n// It does this by comparing the length of the string to the length of a set created from the string.\n// Sets automatically remove duplicate characters, so if the lengths are equal, all characters are unique.\nfunc isUniqueString(_ s: String) -> Bool {\n    return s.count == Set(s).count\n}\nfunc testIsUniqueString() {\n    assert(isUniqueString(\"abcde\") == true)\n    assert(isUniqueString(\"hello\") == false)\n    assert(isUniqueString(\"world\") == true)\n    assert(isUniqueString(\"swift\") == true)\n    assert(isUniqueString(\"unique\") == false)\n}\n\ntestIsUniqueString()", "exec_outcome": "PASSED"}
{"code": "// determineWinner calculates the average speeds of two participants and determines the winner of the race.\n// It takes two arrays of integers representing speed readings for each participant.\n// The function returns a string indicating the winner or if the race is a draw.\nfunc determineWinner(participant1Speeds: [Int], participant2Speeds: [Int]) -> String {\n    // Calculate average speed for Participant 1\n    let avgSpeed1 = participant1Speeds.reduce(0, +) / participant1Speeds.count\n    \n    // Calculate average speed for Participant 2\n    let avgSpeed2 = participant2Speeds.reduce(0, +) / participant2Speeds.count\n    \n    // Determine the winner based on average speeds\n    if avgSpeed1 > avgSpeed2 {\n        return \"Participant 1 wins!\"\n    } else if avgSpeed1 < avgSpeed2 {\n        return \"Participant 2 wins!\"\n    } else {\n        return \"It's a draw!\"\n    }\n}", "test_cases": "", "test_case_results": "Participant 1 speeds: [10, 20, 30], Participant 2 speeds: [15, 25, 35]\nParticipant 2 wins!\nParticipant 1 speeds: [40, 50, 60], Participant 2 speeds: [30, 20, 10]\nParticipant 1 wins!\nParticipant 1 speeds: [10, 20, 30], Participant 2 speeds: [10, 20, 30]\nIt's a draw!\nParticipant 1 speeds: [5, 5, 5], Participant 2 speeds: [5, 5, 5]\nIt's a draw!\nParticipant 1 speeds: [100, 200], Participant 2 speeds: [150, 150]\nIt's a draw!", "task_id": 23692, "assertions": "func testDetermineWinner() {\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [15, 25, 35]) == \"Participant 2 wins!\")\n    assert(determineWinner(participant1Speeds: [40, 50, 60], participant2Speeds: [30, 20, 10]) == \"Participant 1 wins!\")\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [10, 20, 30]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [5, 5, 5], participant2Speeds: [5, 5, 5]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [100, 200], participant2Speeds: [150, 150]) == \"It's a draw!\")\n}\n\ntestDetermineWinner()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testDetermineWinner() {\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [15, 25, 35]) == \"Participant 2 wins!\")\n    assert(determineWinner(participant1Speeds: [40, 50, 60], participant2Speeds: [30, 20, 10]) == \"Participant 1 wins!\")\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [10, 20, 30]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [5, 5, 5], participant2Speeds: [5, 5, 5]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [100, 200], participant2Speeds: [150, 150]) == \"It's a draw!\")\n}\n\ntestDetermineWinner()", "output": "determineWinner"}, "all_code": "// determineWinner calculates the average speeds of two participants and determines the winner of the race.\n// It takes two arrays of integers representing speed readings for each participant.\n// The function returns a string indicating the winner or if the race is a draw.\nfunc determineWinner(participant1Speeds: [Int], participant2Speeds: [Int]) -> String {\n    // Calculate average speed for Participant 1\n    let avgSpeed1 = participant1Speeds.reduce(0, +) / participant1Speeds.count\n    \n    // Calculate average speed for Participant 2\n    let avgSpeed2 = participant2Speeds.reduce(0, +) / participant2Speeds.count\n    \n    // Determine the winner based on average speeds\n    if avgSpeed1 > avgSpeed2 {\n        return \"Participant 1 wins!\"\n    } else if avgSpeed1 < avgSpeed2 {\n        return \"Participant 2 wins!\"\n    } else {\n        return \"It's a draw!\"\n    }\n}\nfunc testDetermineWinner() {\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [15, 25, 35]) == \"Participant 2 wins!\")\n    assert(determineWinner(participant1Speeds: [40, 50, 60], participant2Speeds: [30, 20, 10]) == \"Participant 1 wins!\")\n    assert(determineWinner(participant1Speeds: [10, 20, 30], participant2Speeds: [10, 20, 30]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [5, 5, 5], participant2Speeds: [5, 5, 5]) == \"It's a draw!\")\n    assert(determineWinner(participant1Speeds: [100, 200], participant2Speeds: [150, 150]) == \"It's a draw!\")\n}\n\ntestDetermineWinner()", "exec_outcome": "PASSED"}
{"code": "// filterComments removes comments that contain any negative words from a given list.\n// The comparison is case-insensitive, meaning it checks for negative words regardless of their case in the comments.\n// Parameters:\n//   - comments: An array of strings representing the comments to be filtered.\n//   - negativeWords: An array of strings representing the negative words to filter out.\n// Returns: An array of comments that do not contain any of the negative words.\nfunc filterComments(comments: [String], negativeWords: [String]) -> [String] {\n    var filteredComments: [String] = []\n    for comment in comments {\n        let commentLower = comment.lowercased()\n        // Check if the comment contains any of the negative words\n        var containsNegativeWord = false\n        for word in negativeWords {\n            if commentLower.contains(word.lowercased()) {\n                containsNegativeWord = true\n                break\n            }\n        }\n        if !containsNegativeWord {\n            filteredComments.append(comment)\n        }\n    }\n    return filteredComments\n}", "test_cases": "", "test_case_results": "Comments: [\"This is a great day!\", \"I hate Mondays\", \"Awesome weather today\"]\nNegative Words: [\"hate\", \"bad\"]\nFiltered Comments: [\"This is a great day!\", \"Awesome weather today\"]\n---\nComments: [\"No negativity here\", \"This is terrible\", \"Just okay\"]\nNegative Words: [\"terrible\", \"awful\"]\nFiltered Comments: [\"No negativity here\", \"Just okay\"]\n---\nComments: [\"All good\", \"Perfect\", \"Excellent\"]\nNegative Words: [\"poor\", \"horrible\"]\nFiltered Comments: [\"All good\", \"Perfect\", \"Excellent\"]\n---", "task_id": 10686, "assertions": "func testFilterComments() {\n    // Test Case 1\n    assert(filterComments(\n        comments: [\"This is a great day!\", \"I hate Mondays\", \"Awesome weather today\"],\n        negativeWords: [\"hate\", \"bad\"]\n    ) == [\"This is a great day!\", \"Awesome weather today\"])\n    \n    // Test Case 2\n    assert(filterComments(\n        comments: [\"No negativity here\", \"This is terrible\", \"Just okay\"],\n        negativeWords: [\"terrible\", \"awful\"]\n    ) == [\"No negativity here\", \"Just okay\"])\n    \n    // Test Case 3\n    assert(filterComments(\n        comments: [\"All good\", \"Perfect\", \"Excellent\"],\n        negativeWords: [\"poor\", \"horrible\"]\n    ) == [\"All good\", \"Perfect\", \"Excellent\"])\n}\n\ntestFilterComments()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFilterComments() {\n    // Test Case 1\n    assert(filterComments(\n        comments: [\"This is a great day!\", \"I hate Mondays\", \"Awesome weather today\"],\n        negativeWords: [\"hate\", \"bad\"]\n    ) == [\"This is a great day!\", \"Awesome weather today\"])\n    \n    // Test Case 2\n    assert(filterComments(\n        comments: [\"No negativity here\", \"This is terrible\", \"Just okay\"],\n        negativeWords: [\"terrible\", \"awful\"]\n    ) == [\"No negativity here\", \"Just okay\"])\n    \n    // Test Case 3\n    assert(filterComments(\n        comments: [\"All good\", \"Perfect\", \"Excellent\"],\n        negativeWords: [\"poor\", \"horrible\"]\n    ) == [\"All good\", \"Perfect\", \"Excellent\"])\n}\n\ntestFilterComments()", "output": "filterComments"}, "all_code": "// filterComments removes comments that contain any negative words from a given list.\n// The comparison is case-insensitive, meaning it checks for negative words regardless of their case in the comments.\n// Parameters:\n//   - comments: An array of strings representing the comments to be filtered.\n//   - negativeWords: An array of strings representing the negative words to filter out.\n// Returns: An array of comments that do not contain any of the negative words.\nfunc filterComments(comments: [String], negativeWords: [String]) -> [String] {\n    var filteredComments: [String] = []\n    for comment in comments {\n        let commentLower = comment.lowercased()\n        // Check if the comment contains any of the negative words\n        var containsNegativeWord = false\n        for word in negativeWords {\n            if commentLower.contains(word.lowercased()) {\n                containsNegativeWord = true\n                break\n            }\n        }\n        if !containsNegativeWord {\n            filteredComments.append(comment)\n        }\n    }\n    return filteredComments\n}\nfunc testFilterComments() {\n    // Test Case 1\n    assert(filterComments(\n        comments: [\"This is a great day!\", \"I hate Mondays\", \"Awesome weather today\"],\n        negativeWords: [\"hate\", \"bad\"]\n    ) == [\"This is a great day!\", \"Awesome weather today\"])\n    \n    // Test Case 2\n    assert(filterComments(\n        comments: [\"No negativity here\", \"This is terrible\", \"Just okay\"],\n        negativeWords: [\"terrible\", \"awful\"]\n    ) == [\"No negativity here\", \"Just okay\"])\n    \n    // Test Case 3\n    assert(filterComments(\n        comments: [\"All good\", \"Perfect\", \"Excellent\"],\n        negativeWords: [\"poor\", \"horrible\"]\n    ) == [\"All good\", \"Perfect\", \"Excellent\"])\n}\n\ntestFilterComments()", "exec_outcome": "PASSED"}
{"code": "// largestSubarrayWithTwoDistinctNumbers calculates the length of the largest subarray \n// containing exactly two distinct numbers in an array of integers.\n// It uses a sliding window approach to efficiently track the subarray boundaries and \n// a dictionary to keep count of the distinct numbers within the current window.\nfunc largestSubarrayWithTwoDistinctNumbers(_ arr: [Int]) -> Int {\n    let n = arr.count\n    if n < 2 {\n        return n\n    }\n    \n    var left = 0\n    var right = 0\n    var maxLen = 0\n    var freq = [Int: Int]()\n    \n    while right < n {\n        freq[arr[right], default: 0] += 1\n        \n        while freq.count > 2 {\n            freq[arr[left]]! -= 1\n            if freq[arr[left]] == 0 {\n                freq.removeValue(forKey: arr[left])\n            }\n            left += 1\n        }\n        \n        maxLen = max(maxLen, right - left + 1)\n        right += 1\n    }\n    \n    return maxLen\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 1, 2, 3]\nLength of largest subarray with two distinct numbers: 4\nInput: [1, 2, 3, 4, 5]\nLength of largest subarray with two distinct numbers: 2\nInput: [1, 1, 1, 1, 1]\nLength of largest subarray with two distinct numbers: 5\nInput: [1, 2, 3, 2, 2]\nLength of largest subarray with two distinct numbers: 4\nInput: []\nLength of largest subarray with two distinct numbers: 0", "task_id": 27305, "assertions": "func testLargestSubarrayWithTwoDistinctNumbers() {\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 1, 2, 3]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 4, 5]) == 2)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 1, 1, 1, 1]) == 5)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 2, 2]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([]) == 0)\n}\n\ntestLargestSubarrayWithTwoDistinctNumbers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLargestSubarrayWithTwoDistinctNumbers() {\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 1, 2, 3]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 4, 5]) == 2)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 1, 1, 1, 1]) == 5)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 2, 2]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([]) == 0)\n}\n\ntestLargestSubarrayWithTwoDistinctNumbers()", "output": "largestSubarrayWithTwoDistinctNumbers"}, "all_code": "// largestSubarrayWithTwoDistinctNumbers calculates the length of the largest subarray \n// containing exactly two distinct numbers in an array of integers.\n// It uses a sliding window approach to efficiently track the subarray boundaries and \n// a dictionary to keep count of the distinct numbers within the current window.\nfunc largestSubarrayWithTwoDistinctNumbers(_ arr: [Int]) -> Int {\n    let n = arr.count\n    if n < 2 {\n        return n\n    }\n    \n    var left = 0\n    var right = 0\n    var maxLen = 0\n    var freq = [Int: Int]()\n    \n    while right < n {\n        freq[arr[right], default: 0] += 1\n        \n        while freq.count > 2 {\n            freq[arr[left]]! -= 1\n            if freq[arr[left]] == 0 {\n                freq.removeValue(forKey: arr[left])\n            }\n            left += 1\n        }\n        \n        maxLen = max(maxLen, right - left + 1)\n        right += 1\n    }\n    \n    return maxLen\n}\nfunc testLargestSubarrayWithTwoDistinctNumbers() {\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 1, 2, 3]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 4, 5]) == 2)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 1, 1, 1, 1]) == 5)\n    assert(largestSubarrayWithTwoDistinctNumbers([1, 2, 3, 2, 2]) == 4)\n    assert(largestSubarrayWithTwoDistinctNumbers([]) == 0)\n}\n\ntestLargestSubarrayWithTwoDistinctNumbers()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// recommendBooks analyzes reading histories to find the most frequently read books immediately after a given pair of books.\n// It takes an array of reading histories (each history is an array of book titles) and a book pair (a tuple of two book titles).\n// It returns an array of book titles that are most frequently read immediately after the given book pair.\nfunc recommendBooks(readingHistories: [[String]], bookPair: (String, String)) -> [String] {\n    var bookAfterPairCount = [String: Int]()\n    var mostFrequentBooks = [String]()\n    var maxCount = 0\n\n    // Extract the books read immediately after the given pair\n    for history in readingHistories {\n        for i in 0..<(history.count - 2) {\n            if history[i] == bookPair.0 && history[i + 1] == bookPair.1 {\n                let nextBook = history[i + 2]\n                bookAfterPairCount[nextBook] = (bookAfterPairCount[nextBook] ?? 0) + 1\n                if let count = bookAfterPairCount[nextBook], count > maxCount {\n                    maxCount = count\n                }\n            }\n        }\n    }\n\n    // Collect books with maxCount\n    for (book, count) in bookAfterPairCount {\n        if count == maxCount {\n            mostFrequentBooks.append(book)\n        }\n    }\n\n    return mostFrequentBooks\n}", "test_cases": "", "test_case_results": "Reading Histories: [[\"A\", \"B\", \"C\", \"D\"], [\"A\", \"B\", \"E\", \"F\"], [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"]]\nBook Pair: (\"A\", \"B\")\nRecommended Books: [\"C\"]\n---\nReading Histories: [[\"Book1\", \"Book2\", \"Book3\"], [\"Book1\", \"Book2\", \"Book3\"], [\"Book1\", \"Book2\", \"Book4\"]]\nBook Pair: (\"Book1\", \"Book2\")\nRecommended Books: [\"Book3\"]\n---\nReading Histories: [[\"M\", \"N\", \"O\", \"P\"], [\"M\", \"N\", \"Q\", \"R\"], [\"M\", \"N\", \"Q\", \"S\"]]\nBook Pair: (\"M\", \"N\")\nRecommended Books: [\"Q\"]\n---", "task_id": 11038, "assertions": "func testRecommendBooks() {\n    let testCases: [([[String]], (String, String), [String])] = [\n        (\n            [\n                [\"A\", \"B\", \"C\", \"D\"],\n                [\"A\", \"B\", \"E\", \"F\"],\n                [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"]\n            ],\n            (\"A\", \"B\"),\n            [\"C\"]\n        ),\n        (\n            [\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book4\"]\n            ],\n            (\"Book1\", \"Book2\"),\n            [\"Book3\"]\n        ),\n        (\n            [\n                [\"M\", \"N\", \"O\", \"P\"],\n                [\"M\", \"N\", \"Q\", \"R\"],\n                [\"M\", \"N\", \"Q\", \"S\"]\n            ],\n            (\"M\", \"N\"),\n            [\"Q\"]\n        )\n    ]\n    \n    for testCase in testCases {\n        let (histories, pair, expected) = testCase\n        let result = recommendBooks(readingHistories: histories, bookPair: pair)\n        assert(result == expected, \"Test failed for input \\(histories) with pair \\(pair). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestRecommendBooks()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testRecommendBooks() {\n    let testCases: [([[String]], (String, String), [String])] = [\n        (\n            [\n                [\"A\", \"B\", \"C\", \"D\"],\n                [\"A\", \"B\", \"E\", \"F\"],\n                [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"]\n            ],\n            (\"A\", \"B\"),\n            [\"C\"]\n        ),\n        (\n            [\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book4\"]\n            ],\n            (\"Book1\", \"Book2\"),\n            [\"Book3\"]\n        ),\n        (\n            [\n                [\"M\", \"N\", \"O\", \"P\"],\n                [\"M\", \"N\", \"Q\", \"R\"],\n                [\"M\", \"N\", \"Q\", \"S\"]\n            ],\n            (\"M\", \"N\"),\n            [\"Q\"]\n        )\n    ]\n    \n    for testCase in testCases {\n        let (histories, pair, expected) = testCase\n        let result = recommendBooks(readingHistories: histories, bookPair: pair)\n        assert(result == expected, \"Test failed for input \\(histories) with pair \\(pair). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestRecommendBooks()", "output": "recommendBooks"}, "all_code": "import Foundation\n\n// recommendBooks analyzes reading histories to find the most frequently read books immediately after a given pair of books.\n// It takes an array of reading histories (each history is an array of book titles) and a book pair (a tuple of two book titles).\n// It returns an array of book titles that are most frequently read immediately after the given book pair.\nfunc recommendBooks(readingHistories: [[String]], bookPair: (String, String)) -> [String] {\n    var bookAfterPairCount = [String: Int]()\n    var mostFrequentBooks = [String]()\n    var maxCount = 0\n\n    // Extract the books read immediately after the given pair\n    for history in readingHistories {\n        for i in 0..<(history.count - 2) {\n            if history[i] == bookPair.0 && history[i + 1] == bookPair.1 {\n                let nextBook = history[i + 2]\n                bookAfterPairCount[nextBook] = (bookAfterPairCount[nextBook] ?? 0) + 1\n                if let count = bookAfterPairCount[nextBook], count > maxCount {\n                    maxCount = count\n                }\n            }\n        }\n    }\n\n    // Collect books with maxCount\n    for (book, count) in bookAfterPairCount {\n        if count == maxCount {\n            mostFrequentBooks.append(book)\n        }\n    }\n\n    return mostFrequentBooks\n}\nfunc testRecommendBooks() {\n    let testCases: [([[String]], (String, String), [String])] = [\n        (\n            [\n                [\"A\", \"B\", \"C\", \"D\"],\n                [\"A\", \"B\", \"E\", \"F\"],\n                [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"]\n            ],\n            (\"A\", \"B\"),\n            [\"C\"]\n        ),\n        (\n            [\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book3\"],\n                [\"Book1\", \"Book2\", \"Book4\"]\n            ],\n            (\"Book1\", \"Book2\"),\n            [\"Book3\"]\n        ),\n        (\n            [\n                [\"M\", \"N\", \"O\", \"P\"],\n                [\"M\", \"N\", \"Q\", \"R\"],\n                [\"M\", \"N\", \"Q\", \"S\"]\n            ],\n            (\"M\", \"N\"),\n            [\"Q\"]\n        )\n    ]\n    \n    for testCase in testCases {\n        let (histories, pair, expected) = testCase\n        let result = recommendBooks(readingHistories: histories, bookPair: pair)\n        assert(result == expected, \"Test failed for input \\(histories) with pair \\(pair). Expected \\(expected), got \\(result)\")\n    }\n}\n\ntestRecommendBooks()", "exec_outcome": "PASSED"}
{"code": "// mostFrequentProductId takes an array of arrays of integers (each inner array representing records \n// from a file) and returns the product ID that appears most frequently. If there is a tie,\n// it returns the smallest ID.\nfunc mostFrequentProductId(records: [[Int]]) -> Int {\n    // Flatten the input array of arrays\n    let flatList = records.flatMap { $0 }\n    \n    // Count the occurrence of each product ID\n    var counts = [Int: Int]()\n    for id in flatList {\n        counts[id] = (counts[id] ?? 0) + 1\n    }\n    \n    // Find the maximum frequency\n    guard let maxFrequency = counts.values.max() else {\n        return 0 // Return 0 if the input is empty\n    }\n    \n    // Generate an array of product IDs with the maximum frequency\n    let mostFrequentIds = counts.filter { $0.value == maxFrequency }.map { $0.key }\n    \n    // Return the smallest product ID from the array of most frequent IDs\n    return mostFrequentIds.min() ?? 0\n}", "test_cases": "", "test_case_results": "Input: [[1, 2, 3], [2, 3, 4], [2, 5]]\nMost frequent product ID: 2\nInput: [[1, 1, 2], [2, 2, 3], [3, 3, 3]]\nMost frequent product ID: 3\nInput: [[], []]\nMost frequent product ID: 0\nInput: [[1], [1], [2, 2]]\nMost frequent product ID: 1", "task_id": 18342, "assertions": "func testMostFrequentProductId() {\n    assert(mostFrequentProductId(records: [[1, 2, 3], [2, 3, 4], [2, 5]]) == 2)\n    assert(mostFrequentProductId(records: [[1, 1, 2], [2, 2, 3], [3, 3, 3]]) == 3)\n    assert(mostFrequentProductId(records: [[], []]) == 0)\n    assert(mostFrequentProductId(records: [[1], [1], [2, 2]]) == 1)\n}\n\ntestMostFrequentProductId()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMostFrequentProductId() {\n    assert(mostFrequentProductId(records: [[1, 2, 3], [2, 3, 4], [2, 5]]) == 2)\n    assert(mostFrequentProductId(records: [[1, 1, 2], [2, 2, 3], [3, 3, 3]]) == 3)\n    assert(mostFrequentProductId(records: [[], []]) == 0)\n    assert(mostFrequentProductId(records: [[1], [1], [2, 2]]) == 1)\n}\n\ntestMostFrequentProductId()", "output": "mostFrequentProductId"}, "all_code": "// mostFrequentProductId takes an array of arrays of integers (each inner array representing records \n// from a file) and returns the product ID that appears most frequently. If there is a tie,\n// it returns the smallest ID.\nfunc mostFrequentProductId(records: [[Int]]) -> Int {\n    // Flatten the input array of arrays\n    let flatList = records.flatMap { $0 }\n    \n    // Count the occurrence of each product ID\n    var counts = [Int: Int]()\n    for id in flatList {\n        counts[id] = (counts[id] ?? 0) + 1\n    }\n    \n    // Find the maximum frequency\n    guard let maxFrequency = counts.values.max() else {\n        return 0 // Return 0 if the input is empty\n    }\n    \n    // Generate an array of product IDs with the maximum frequency\n    let mostFrequentIds = counts.filter { $0.value == maxFrequency }.map { $0.key }\n    \n    // Return the smallest product ID from the array of most frequent IDs\n    return mostFrequentIds.min() ?? 0\n}\nfunc testMostFrequentProductId() {\n    assert(mostFrequentProductId(records: [[1, 2, 3], [2, 3, 4], [2, 5]]) == 2)\n    assert(mostFrequentProductId(records: [[1, 1, 2], [2, 2, 3], [3, 3, 3]]) == 3)\n    assert(mostFrequentProductId(records: [[], []]) == 0)\n    assert(mostFrequentProductId(records: [[1], [1], [2, 2]]) == 1)\n}\n\ntestMostFrequentProductId()", "exec_outcome": "PASSED"}
{"code": "// canHalfParticipantsFinish determines if at least half of the participants can finish a race within a given time.\n// It takes the number of participants (N), the time limit (T), arrays of speeds and distances for each participant.\n// It returns \"YES\" if at least half of the participants can finish the race within the time limit, otherwise \"NO\".\nfunc canHalfParticipantsFinish(N: Int, T: Int, speeds: [Int], distances: [Int]) -> String {\n    var completedCount = 0\n    \n    for i in 0..<N {\n        // Calculate the time taken for the participant to finish the race\n        let timeTaken = Double(distances[i]) / Double(speeds[i])\n        if timeTaken <= Double(T) {\n            completedCount += 1\n        }\n    }\n    \n    // Check if at least half of the participants can finish\n    return completedCount * 2 >= N ? \"YES\" : \"NO\"\n}", "test_cases": "", "test_case_results": "N: 4, T: 5, speeds: [1, 2, 3, 4], distances: [5, 10, 15, 20]\nYES\nN: 3, T: 10, speeds: [5, 5, 5], distances: [50, 50, 50]\nYES\nN: 2, T: 1, speeds: [1, 2], distances: [2, 2]\nYES", "task_id": 16097, "assertions": "func testCanHalfParticipantsFinish() {\n    // Test case 1: 4 participants, 3 can finish (which is more than half)\n    assert(canHalfParticipantsFinish(N: 4, T: 5, speeds: [1, 2, 3, 4], distances: [5, 10, 15, 20]) == \"YES\")\n    \n    // Test case 2: 3 participants, all can finish (which is exactly half when rounded up)\n    assert(canHalfParticipantsFinish(N: 3, T: 10, speeds: [5, 5, 5], distances: [50, 50, 50]) == \"YES\")\n    \n    // Test case 3: 2 participants, both can finish (exactly half)\n    assert(canHalfParticipantsFinish(N: 2, T: 1, speeds: [1, 2], distances: [2, 2]) == \"YES\")\n    \n    // Additional edge case: 1 participant who can finish\n    assert(canHalfParticipantsFinish(N: 1, T: 10, speeds: [1], distances: [5]) == \"YES\")\n    \n    // Additional edge case: 1 participant who cannot finish\n    assert(canHalfParticipantsFinish(N: 1, T: 1, speeds: [1], distances: [2]) == \"NO\")\n}\n\ntestCanHalfParticipantsFinish()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCanHalfParticipantsFinish() {\n    // Test case 1: 4 participants, 3 can finish (which is more than half)\n    assert(canHalfParticipantsFinish(N: 4, T: 5, speeds: [1, 2, 3, 4], distances: [5, 10, 15, 20]) == \"YES\")\n    \n    // Test case 2: 3 participants, all can finish (which is exactly half when rounded up)\n    assert(canHalfParticipantsFinish(N: 3, T: 10, speeds: [5, 5, 5], distances: [50, 50, 50]) == \"YES\")\n    \n    // Test case 3: 2 participants, both can finish (exactly half)\n    assert(canHalfParticipantsFinish(N: 2, T: 1, speeds: [1, 2], distances: [2, 2]) == \"YES\")\n    \n    // Additional edge case: 1 participant who can finish\n    assert(canHalfParticipantsFinish(N: 1, T: 10, speeds: [1], distances: [5]) == \"YES\")\n    \n    // Additional edge case: 1 participant who cannot finish\n    assert(canHalfParticipantsFinish(N: 1, T: 1, speeds: [1], distances: [2]) == \"NO\")\n}\n\ntestCanHalfParticipantsFinish()", "output": "canHalfParticipantsFinish"}, "all_code": "// canHalfParticipantsFinish determines if at least half of the participants can finish a race within a given time.\n// It takes the number of participants (N), the time limit (T), arrays of speeds and distances for each participant.\n// It returns \"YES\" if at least half of the participants can finish the race within the time limit, otherwise \"NO\".\nfunc canHalfParticipantsFinish(N: Int, T: Int, speeds: [Int], distances: [Int]) -> String {\n    var completedCount = 0\n    \n    for i in 0..<N {\n        // Calculate the time taken for the participant to finish the race\n        let timeTaken = Double(distances[i]) / Double(speeds[i])\n        if timeTaken <= Double(T) {\n            completedCount += 1\n        }\n    }\n    \n    // Check if at least half of the participants can finish\n    return completedCount * 2 >= N ? \"YES\" : \"NO\"\n}\nfunc testCanHalfParticipantsFinish() {\n    // Test case 1: 4 participants, 3 can finish (which is more than half)\n    assert(canHalfParticipantsFinish(N: 4, T: 5, speeds: [1, 2, 3, 4], distances: [5, 10, 15, 20]) == \"YES\")\n    \n    // Test case 2: 3 participants, all can finish (which is exactly half when rounded up)\n    assert(canHalfParticipantsFinish(N: 3, T: 10, speeds: [5, 5, 5], distances: [50, 50, 50]) == \"YES\")\n    \n    // Test case 3: 2 participants, both can finish (exactly half)\n    assert(canHalfParticipantsFinish(N: 2, T: 1, speeds: [1, 2], distances: [2, 2]) == \"YES\")\n    \n    // Additional edge case: 1 participant who can finish\n    assert(canHalfParticipantsFinish(N: 1, T: 10, speeds: [1], distances: [5]) == \"YES\")\n    \n    // Additional edge case: 1 participant who cannot finish\n    assert(canHalfParticipantsFinish(N: 1, T: 1, speeds: [1], distances: [2]) == \"NO\")\n}\n\ntestCanHalfParticipantsFinish()", "exec_outcome": "PASSED"}
{"code": "// customSortByLengthAndValue sorts an array of strings by their lengths in ascending order,\n// and by their lexicographical order if two strings have the same length.\n// The function uses Swift's built-in sorting with a custom key that combines the length and the string itself.\nfunc customSortByLengthAndValue(_ strings: [String]) -> [String] {\n    return strings.sorted {\n        if $0.count == $1.count {\n            return $0 < $1\n        } else {\n            return $0.count < $1.count\n        }\n    }\n}", "test_cases": "", "test_case_results": "Input: [\"apple\", \"banana\", \"cherry\", \"date\"]\nSorted: [\"date\", \"apple\", \"banana\", \"cherry\"]\n\nInput: [\"zebra\", \"elephant\", \"monkey\", \"giraffe\"]\nSorted: [\"zebra\", \"monkey\", \"giraffe\", \"elephant\"]\n\nInput: [\"cat\", \"dog\", \"bat\", \"ant\"]\nSorted: [\"ant\", \"bat\", \"cat\", \"dog\"]\n\nInput: [\"one\", \"two\", \"three\", \"four\", \"five\"]\nSorted: [\"one\", \"two\", \"five\", \"four\", \"three\"]", "task_id": 26266, "assertions": "func testCustomSortByLengthAndValue() {\n    assert(customSortByLengthAndValue([\"apple\", \"banana\", \"cherry\", \"date\"]) == [\"date\", \"apple\", \"banana\", \"cherry\"])\n    assert(customSortByLengthAndValue([\"zebra\", \"elephant\", \"monkey\", \"giraffe\"]) == [\"zebra\", \"monkey\", \"giraffe\", \"elephant\"])\n    assert(customSortByLengthAndValue([\"cat\", \"dog\", \"bat\", \"ant\"]) == [\"ant\", \"bat\", \"cat\", \"dog\"])\n    assert(customSortByLengthAndValue([\"one\", \"two\", \"three\", \"four\", \"five\"]) == [\"one\", \"two\", \"five\", \"four\", \"three\"])\n}\n\ntestCustomSortByLengthAndValue()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCustomSortByLengthAndValue() {\n    assert(customSortByLengthAndValue([\"apple\", \"banana\", \"cherry\", \"date\"]) == [\"date\", \"apple\", \"banana\", \"cherry\"])\n    assert(customSortByLengthAndValue([\"zebra\", \"elephant\", \"monkey\", \"giraffe\"]) == [\"zebra\", \"monkey\", \"giraffe\", \"elephant\"])\n    assert(customSortByLengthAndValue([\"cat\", \"dog\", \"bat\", \"ant\"]) == [\"ant\", \"bat\", \"cat\", \"dog\"])\n    assert(customSortByLengthAndValue([\"one\", \"two\", \"three\", \"four\", \"five\"]) == [\"one\", \"two\", \"five\", \"four\", \"three\"])\n}\n\ntestCustomSortByLengthAndValue()", "output": "customSortByLengthAndValue"}, "all_code": "// customSortByLengthAndValue sorts an array of strings by their lengths in ascending order,\n// and by their lexicographical order if two strings have the same length.\n// The function uses Swift's built-in sorting with a custom key that combines the length and the string itself.\nfunc customSortByLengthAndValue(_ strings: [String]) -> [String] {\n    return strings.sorted {\n        if $0.count == $1.count {\n            return $0 < $1\n        } else {\n            return $0.count < $1.count\n        }\n    }\n}\nfunc testCustomSortByLengthAndValue() {\n    assert(customSortByLengthAndValue([\"apple\", \"banana\", \"cherry\", \"date\"]) == [\"date\", \"apple\", \"banana\", \"cherry\"])\n    assert(customSortByLengthAndValue([\"zebra\", \"elephant\", \"monkey\", \"giraffe\"]) == [\"zebra\", \"monkey\", \"giraffe\", \"elephant\"])\n    assert(customSortByLengthAndValue([\"cat\", \"dog\", \"bat\", \"ant\"]) == [\"ant\", \"bat\", \"cat\", \"dog\"])\n    assert(customSortByLengthAndValue([\"one\", \"two\", \"three\", \"four\", \"five\"]) == [\"one\", \"two\", \"five\", \"four\", \"three\"])\n}\n\ntestCustomSortByLengthAndValue()", "exec_outcome": "PASSED"}
{"code": "// findCycleLengths calculates the length of teleportation cycles for each station in a network.\n// It uses a visited array to track which stations have been processed and a cycleLengths array to store results.\n// The function employs Floyd's cycle-finding algorithm to detect cycles and determine their lengths.\nfunc findCycleLengths(n: Int, teleports: [Int]) -> [Int] {\n    var visited = [Bool](repeating: false, count: n)\n    var cycleLengths = [Int](repeating: 0, count: n)\n    \n    for i in 0..<n {\n        if visited[i] {\n            continue\n        }\n        \n        // Find the cycle starting from station i using Floyd's algorithm\n        var slow = i\n        var fast = i\n        \n        while true {\n            slow = teleports[slow] - 1\n            fast = teleports[teleports[fast] - 1] - 1\n            if slow == fast {\n                break\n            }\n        }\n        \n        // Determine the length of the cycle\n        var cycleLength = 1\n        let start = slow\n        var position = teleports[start] - 1\n        while position != start {\n            cycleLength += 1\n            position = teleports[position] - 1\n        }\n        \n        // Assign cycle length to all stations in the cycle\n        position = slow\n        while !visited[position] {\n            visited[position] = true\n            cycleLengths[position] = cycleLength\n            position = teleports[position] - 1\n        }\n    }\n    \n    return cycleLengths\n}\n\n// solveTeleporterCycles processes multiple test cases of teleportation networks.\n// For each test case (n stations and their teleport destinations), it computes the cycle lengths.\nfunc solveTeleporterCycles(T: Int, testCases: [(n: Int, teleports: [Int])]) -> [[Int]] {\n    var results = [[Int]]()\n    for testCase in testCases {\n        results.append(findCycleLengths(n: testCase.n, teleports: testCase.teleports))\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of stations: 5\nTeleport destinations: [2, 3, 4, 5, 1]\nCycle lengths: [5, 5, 5, 5, 5]\n\nTest Case 2:\nNumber of stations: 4\nTeleport destinations: [2, 1, 4, 3]\nCycle lengths: [2, 2, 2, 2]\n\nTest Case 3:\nNumber of stations: 6\nTeleport destinations: [2, 3, 1, 5, 6, 4]\nCycle lengths: [3, 3, 3, 3, 3, 3]\n\nTest Case 4:\nNumber of stations: 3\nTeleport destinations: [1, 2, 3]\nCycle lengths: [1, 1, 1]\n\nTest Case 5:\nNumber of stations: 7\nTeleport destinations: [2, 3, 4, 5, 6, 7, 1]\nCycle lengths: [7, 7, 7, 7, 7, 7, 7]\n\nProcessing all test cases at once:\nTest Case 1 results: [5, 5, 5, 5, 5]\nTest Case 2 results: [2, 2, 2, 2]\nTest Case 3 results: [3, 3, 3, 3, 3, 3]\nTest Case 4 results: [1, 1, 1]\nTest Case 5 results: [7, 7, 7, 7, 7, 7, 7]", "task_id": 22007, "assertions": "func testTeleporterCycles() {\n    let testCases: [(n: Int, teleports: [Int], expected: [Int])] = [\n        (5, [2, 3, 4, 5, 1], [5, 5, 5, 5, 5]),\n        (4, [2, 1, 4, 3], [2, 2, 2, 2]),\n        (6, [2, 3, 1, 5, 6, 4], [3, 3, 3, 3, 3, 3]),\n        (3, [1, 2, 3], [1, 1, 1]),\n        (7, [2, 3, 4, 5, 6, 7, 1], [7, 7, 7, 7, 7, 7, 7])\n    ]\n    \n    for testCase in testCases {\n        let result = findCycleLengths(n: testCase.n, teleports: testCase.teleports)\n        assert(result == testCase.expected, \n               \"Test failed for n=\\(testCase.n), teleports=\\(testCase.teleports). Expected \\(testCase.expected), got \\(result)\")\n    }\n    \n    let allResults = solveTeleporterCycles(T: testCases.count, testCases: testCases.map { ($0.n, $0.teleports) })\n    for (index, result) in allResults.enumerated() {\n        assert(result == testCases[index].expected,\n               \"Batch test failed for test case \\(index+1). Expected \\(testCases[index].expected), got \\(result)\")\n    }\n}\n\ntestTeleporterCycles()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testTeleporterCycles() {\n    let testCases: [(n: Int, teleports: [Int], expected: [Int])] = [\n        (5, [2, 3, 4, 5, 1], [5, 5, 5, 5, 5]),\n        (4, [2, 1, 4, 3], [2, 2, 2, 2]),\n        (6, [2, 3, 1, 5, 6, 4], [3, 3, 3, 3, 3, 3]),\n        (3, [1, 2, 3], [1, 1, 1]),\n        (7, [2, 3, 4, 5, 6, 7, 1], [7, 7, 7, 7, 7, 7, 7])\n    ]\n    \n    for testCase in testCases {\n        let result = findCycleLengths(n: testCase.n, teleports: testCase.teleports)\n        assert(result == testCase.expected, \n               \"Test failed for n=\\(testCase.n), teleports=\\(testCase.teleports). Expected \\(testCase.expected), got \\(result)\")\n    }\n    \n    let allResults = solveTeleporterCycles(T: testCases.count, testCases: testCases.map { ($0.n, $0.teleports) })\n    for (index, result) in allResults.enumerated() {\n        assert(result == testCases[index].expected,\n               \"Batch test failed for test case \\(index+1). Expected \\(testCases[index].expected), got \\(result)\")\n    }\n}\n\ntestTeleporterCycles()", "output": "findCycleLengths"}, "all_code": "import Foundation\nimport Glibc\n\n// findCycleLengths calculates the length of teleportation cycles for each station in a network.\n// It uses a visited array to track which stations have been processed and a cycleLengths array to store results.\n// The function employs Floyd's cycle-finding algorithm to detect cycles and determine their lengths.\nfunc findCycleLengths(n: Int, teleports: [Int]) -> [Int] {\n    var visited = [Bool](repeating: false, count: n)\n    var cycleLengths = [Int](repeating: 0, count: n)\n    \n    for i in 0..<n {\n        if visited[i] {\n            continue\n        }\n        \n        // Find the cycle starting from station i using Floyd's algorithm\n        var slow = i\n        var fast = i\n        \n        while true {\n            slow = teleports[slow] - 1\n            fast = teleports[teleports[fast] - 1] - 1\n            if slow == fast {\n                break\n            }\n        }\n        \n        // Determine the length of the cycle\n        var cycleLength = 1\n        let start = slow\n        var position = teleports[start] - 1\n        while position != start {\n            cycleLength += 1\n            position = teleports[position] - 1\n        }\n        \n        // Assign cycle length to all stations in the cycle\n        position = slow\n        while !visited[position] {\n            visited[position] = true\n            cycleLengths[position] = cycleLength\n            position = teleports[position] - 1\n        }\n    }\n    \n    return cycleLengths\n}\n\n// solveTeleporterCycles processes multiple test cases of teleportation networks.\n// For each test case (n stations and their teleport destinations), it computes the cycle lengths.\nfunc solveTeleporterCycles(T: Int, testCases: [(n: Int, teleports: [Int])]) -> [[Int]] {\n    var results = [[Int]]()\n    for testCase in testCases {\n        results.append(findCycleLengths(n: testCase.n, teleports: testCase.teleports))\n    }\n    return results\n}\nfunc testTeleporterCycles() {\n    let testCases: [(n: Int, teleports: [Int], expected: [Int])] = [\n        (5, [2, 3, 4, 5, 1], [5, 5, 5, 5, 5]),\n        (4, [2, 1, 4, 3], [2, 2, 2, 2]),\n        (6, [2, 3, 1, 5, 6, 4], [3, 3, 3, 3, 3, 3]),\n        (3, [1, 2, 3], [1, 1, 1]),\n        (7, [2, 3, 4, 5, 6, 7, 1], [7, 7, 7, 7, 7, 7, 7])\n    ]\n    \n    for testCase in testCases {\n        let result = findCycleLengths(n: testCase.n, teleports: testCase.teleports)\n        assert(result == testCase.expected, \n               \"Test failed for n=\\(testCase.n), teleports=\\(testCase.teleports). Expected \\(testCase.expected), got \\(result)\")\n    }\n    \n    let allResults = solveTeleporterCycles(T: testCases.count, testCases: testCases.map { ($0.n, $0.teleports) })\n    for (index, result) in allResults.enumerated() {\n        assert(result == testCases[index].expected,\n               \"Batch test failed for test case \\(index+1). Expected \\(testCases[index].expected), got \\(result)\")\n    }\n}\n\ntestTeleporterCycles()", "exec_outcome": "PASSED"}
{"code": "// lastThreeCharacters returns the last three characters of a given string.\n// If the string is shorter than 3 characters, it returns the entire string.\nfunc lastThreeCharacters(_ s: String) -> String {\n    return s.count >= 3 ? String(s.suffix(3)) : s\n}", "test_cases": "", "test_case_results": "Input: \"Hello\"\nResult: \"llo\"\nInput: \"Swift\"\nResult: \"ift\"\nInput: \"Hi\"\nResult: \"Hi\"\nInput: \"A\"\nResult: \"A\"\nInput: \"\"\nResult: \"\"", "task_id": 19082, "assertions": "func testLastThreeCharacters() {\n    assert(lastThreeCharacters(\"Hello\") == \"llo\")\n    assert(lastThreeCharacters(\"Swift\") == \"ift\")\n    assert(lastThreeCharacters(\"Hi\") == \"Hi\")\n    assert(lastThreeCharacters(\"A\") == \"A\")\n    assert(lastThreeCharacters(\"\") == \"\")\n}\n\ntestLastThreeCharacters()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLastThreeCharacters() {\n    assert(lastThreeCharacters(\"Hello\") == \"llo\")\n    assert(lastThreeCharacters(\"Swift\") == \"ift\")\n    assert(lastThreeCharacters(\"Hi\") == \"Hi\")\n    assert(lastThreeCharacters(\"A\") == \"A\")\n    assert(lastThreeCharacters(\"\") == \"\")\n}\n\ntestLastThreeCharacters()", "output": "lastThreeCharacters"}, "all_code": "// lastThreeCharacters returns the last three characters of a given string.\n// If the string is shorter than 3 characters, it returns the entire string.\nfunc lastThreeCharacters(_ s: String) -> String {\n    return s.count >= 3 ? String(s.suffix(3)) : s\n}\nfunc testLastThreeCharacters() {\n    assert(lastThreeCharacters(\"Hello\") == \"llo\")\n    assert(lastThreeCharacters(\"Swift\") == \"ift\")\n    assert(lastThreeCharacters(\"Hi\") == \"Hi\")\n    assert(lastThreeCharacters(\"A\") == \"A\")\n    assert(lastThreeCharacters(\"\") == \"\")\n}\n\ntestLastThreeCharacters()", "exec_outcome": "PASSED"}
{"code": "// compareDigitSums checks if the sum of the digits of the first number is less than or equal to\n// the sum of the digits of the second number. It converts each number to a string, iterates over\n// each character (digit), converts it back to an integer, and sums them up.\nfunc compareDigitSums(_ n1: Int, _ n2: Int) -> Bool {\n    let sumN1 = String(n1).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    let sumN2 = String(n2).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return sumN1 <= sumN2\n}", "test_cases": "", "test_case_results": "Input: 123, 456\nResult: true\nInput: 999, 1000\nResult: false\nInput: 0, 0\nResult: true\nInput: 5, 23\nResult: true\nInput: 111, 3\nResult: true", "task_id": 16156, "assertions": "func testCompareDigitSums() {\n    assert(compareDigitSums(123, 456) == true)\n    assert(compareDigitSums(999, 1000) == false)\n    assert(compareDigitSums(0, 0) == true)\n    assert(compareDigitSums(5, 23) == true)\n    assert(compareDigitSums(111, 3) == true)\n}\n\ntestCompareDigitSums()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCompareDigitSums() {\n    assert(compareDigitSums(123, 456) == true)\n    assert(compareDigitSums(999, 1000) == false)\n    assert(compareDigitSums(0, 0) == true)\n    assert(compareDigitSums(5, 23) == true)\n    assert(compareDigitSums(111, 3) == true)\n}\n\ntestCompareDigitSums()", "output": "compareDigitSums"}, "all_code": "// compareDigitSums checks if the sum of the digits of the first number is less than or equal to\n// the sum of the digits of the second number. It converts each number to a string, iterates over\n// each character (digit), converts it back to an integer, and sums them up.\nfunc compareDigitSums(_ n1: Int, _ n2: Int) -> Bool {\n    let sumN1 = String(n1).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    let sumN2 = String(n2).compactMap { $0.wholeNumberValue }.reduce(0, +)\n    return sumN1 <= sumN2\n}\nfunc testCompareDigitSums() {\n    assert(compareDigitSums(123, 456) == true)\n    assert(compareDigitSums(999, 1000) == false)\n    assert(compareDigitSums(0, 0) == true)\n    assert(compareDigitSums(5, 23) == true)\n    assert(compareDigitSums(111, 3) == true)\n}\n\ntestCompareDigitSums()", "exec_outcome": "PASSED"}
{"code": "// minKeystrokes calculates the minimum number of keystrokes required to type a given sentence.\n// Each character and space in the sentence must be typed, and the delete command does not reduce keystrokes.\n// Therefore, the minimum keystrokes is simply the length of the sentence.\nfunc minKeystrokes(sentence: String) -> Int {\n    return sentence.count\n}", "test_cases": "", "test_case_results": "Input: \"Hello, world!\"\nMinimum keystrokes: 13\nInput: \"Swift is awesome\"\nMinimum keystrokes: 16\nInput: \"\"\nMinimum keystrokes: 0\nInput: \" \"\nMinimum keystrokes: 1", "task_id": 9755, "assertions": "func testMinKeystrokes() {\n    assert(minKeystrokes(sentence: \"Hello, world!\") == 13)\n    assert(minKeystrokes(sentence: \"Swift is awesome\") == 16)\n    assert(minKeystrokes(sentence: \"\") == 0)\n    assert(minKeystrokes(sentence: \" \") == 1)\n}\n\ntestMinKeystrokes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinKeystrokes() {\n    assert(minKeystrokes(sentence: \"Hello, world!\") == 13)\n    assert(minKeystrokes(sentence: \"Swift is awesome\") == 16)\n    assert(minKeystrokes(sentence: \"\") == 0)\n    assert(minKeystrokes(sentence: \" \") == 1)\n}\n\ntestMinKeystrokes()", "output": "minKeystrokes"}, "all_code": "// minKeystrokes calculates the minimum number of keystrokes required to type a given sentence.\n// Each character and space in the sentence must be typed, and the delete command does not reduce keystrokes.\n// Therefore, the minimum keystrokes is simply the length of the sentence.\nfunc minKeystrokes(sentence: String) -> Int {\n    return sentence.count\n}\nfunc testMinKeystrokes() {\n    assert(minKeystrokes(sentence: \"Hello, world!\") == 13)\n    assert(minKeystrokes(sentence: \"Swift is awesome\") == 16)\n    assert(minKeystrokes(sentence: \"\") == 0)\n    assert(minKeystrokes(sentence: \" \") == 1)\n}\n\ntestMinKeystrokes()", "exec_outcome": "PASSED"}
{"code": "// findModes returns the mode(s) of an array of integers.\n// If there are multiple modes, it returns a sorted array of all modes.\n// If the input array is empty, it returns an empty array.\nfunc findModes(numbers: [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    \n    // Dictionary to count occurrences of each number\n    var countDict = [Int: Int]()\n    for num in numbers {\n        countDict[num] = (countDict[num] ?? 0) + 1\n    }\n    \n    guard let maxFrequency = countDict.values.max() else {\n        return []\n    }\n    \n    // Array of all numbers that have the max frequency\n    let modes = countDict.filter { $0.value == maxFrequency }.map { $0.key }\n    \n    return modes.sorted()\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 2, 3, 4]\nModes: [2]\nInput: [5, 6, 6, 7, 7, 0]\nModes: [6, 7]\nInput: [0, 0, 0, 0]\nModes: [0]\nInput: []\nModes: []", "task_id": 14383, "assertions": "func testFindModes() {\n    assert(findModes(numbers: [1, 2, 2, 3, 4]) == [2])\n    assert(findModes(numbers: [5, 6, 6, 7, 7, 0]) == [6, 7])\n    assert(findModes(numbers: [0, 0, 0, 0]) == [0])\n    assert(findModes(numbers: []) == [])\n}\n\ntestFindModes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindModes() {\n    assert(findModes(numbers: [1, 2, 2, 3, 4]) == [2])\n    assert(findModes(numbers: [5, 6, 6, 7, 7, 0]) == [6, 7])\n    assert(findModes(numbers: [0, 0, 0, 0]) == [0])\n    assert(findModes(numbers: []) == [])\n}\n\ntestFindModes()", "output": "findModes"}, "all_code": "// findModes returns the mode(s) of an array of integers.\n// If there are multiple modes, it returns a sorted array of all modes.\n// If the input array is empty, it returns an empty array.\nfunc findModes(numbers: [Int]) -> [Int] {\n    if numbers.isEmpty {\n        return []\n    }\n    \n    // Dictionary to count occurrences of each number\n    var countDict = [Int: Int]()\n    for num in numbers {\n        countDict[num] = (countDict[num] ?? 0) + 1\n    }\n    \n    guard let maxFrequency = countDict.values.max() else {\n        return []\n    }\n    \n    // Array of all numbers that have the max frequency\n    let modes = countDict.filter { $0.value == maxFrequency }.map { $0.key }\n    \n    return modes.sorted()\n}\nfunc testFindModes() {\n    assert(findModes(numbers: [1, 2, 2, 3, 4]) == [2])\n    assert(findModes(numbers: [5, 6, 6, 7, 7, 0]) == [6, 7])\n    assert(findModes(numbers: [0, 0, 0, 0]) == [0])\n    assert(findModes(numbers: []) == [])\n}\n\ntestFindModes()", "exec_outcome": "PASSED"}
{"code": "// minBlocksToEqualize calculates the minimum number of blocks required to make all towers in the list the same height.\n// The function first finds the maximum height in the list, then computes the sum of differences between each tower's height and the maximum height.\n// This sum represents the total blocks needed to make all towers equal in height.\nfunc minBlocksToEqualize(heights: [Int]) -> Int {\n    guard let maxHeight = heights.max() else {\n        return 0\n    }\n    let totalBlocksRequired = heights.reduce(0) { $0 + (maxHeight - $1) }\n    return totalBlocksRequired\n}", "test_cases": "", "test_case_results": "Input: [5, 3, 7, 2]\nBlocks needed: 11\nInput: [4, 4, 4, 4]\nBlocks needed: 0\nInput: []\nBlocks needed: 0\nInput: [10]\nBlocks needed: 0", "task_id": 22029, "assertions": "func testMinBlocksToEqualize() {\n    assert(minBlocksToEqualize(heights: [5, 3, 7, 2]) == 11)\n    assert(minBlocksToEqualize(heights: [4, 4, 4, 4]) == 0)\n    assert(minBlocksToEqualize(heights: []) == 0)\n    assert(minBlocksToEqualize(heights: [10]) == 0)\n}\n\ntestMinBlocksToEqualize()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinBlocksToEqualize() {\n    assert(minBlocksToEqualize(heights: [5, 3, 7, 2]) == 11)\n    assert(minBlocksToEqualize(heights: [4, 4, 4, 4]) == 0)\n    assert(minBlocksToEqualize(heights: []) == 0)\n    assert(minBlocksToEqualize(heights: [10]) == 0)\n}\n\ntestMinBlocksToEqualize()", "output": "minBlocksToEqualize"}, "all_code": "// minBlocksToEqualize calculates the minimum number of blocks required to make all towers in the list the same height.\n// The function first finds the maximum height in the list, then computes the sum of differences between each tower's height and the maximum height.\n// This sum represents the total blocks needed to make all towers equal in height.\nfunc minBlocksToEqualize(heights: [Int]) -> Int {\n    guard let maxHeight = heights.max() else {\n        return 0\n    }\n    let totalBlocksRequired = heights.reduce(0) { $0 + (maxHeight - $1) }\n    return totalBlocksRequired\n}\nfunc testMinBlocksToEqualize() {\n    assert(minBlocksToEqualize(heights: [5, 3, 7, 2]) == 11)\n    assert(minBlocksToEqualize(heights: [4, 4, 4, 4]) == 0)\n    assert(minBlocksToEqualize(heights: []) == 0)\n    assert(minBlocksToEqualize(heights: [10]) == 0)\n}\n\ntestMinBlocksToEqualize()", "exec_outcome": "PASSED"}
{"code": "// countConsecutiveSubstrings calculates the number of substrings in a string that consist of only one unique character repeated consecutively.\n// It iterates through the string, tracking the length of consecutive identical characters, and uses the formula n*(n+1)/2 to count substrings for each segment.\nfunc countConsecutiveSubstrings(_ s: String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n\n    var count = 0  // To count consecutive substrings\n    var consecutiveLength = 1  // Length of the current consecutive characters\n\n    let characters = Array(s)\n    for i in 1..<characters.count {\n        if characters[i] == characters[i - 1] {\n            consecutiveLength += 1\n        } else {\n            count += consecutiveLength * (consecutiveLength + 1) / 2\n            consecutiveLength = 1\n        }\n    }\n\n    // Add the last segment\n    count += consecutiveLength * (consecutiveLength + 1) / 2\n\n    return count\n}", "test_cases": "", "test_case_results": "Input: \"aabbb\"\nNumber of consecutive substrings: 9\nInput: \"abc\"\nNumber of consecutive substrings: 3\nInput: \"aaa\"\nNumber of consecutive substrings: 6\nInput: \"\"\nNumber of consecutive substrings: 0\nInput: \"a\"\nNumber of consecutive substrings: 1\nInput: \"aaabbbccca\"\nNumber of consecutive substrings: 19", "task_id": 7839, "assertions": "func testCountConsecutiveSubstrings() {\n    assert(countConsecutiveSubstrings(\"aabbb\") == 9)\n    assert(countConsecutiveSubstrings(\"abc\") == 3)\n    assert(countConsecutiveSubstrings(\"aaa\") == 6)\n    assert(countConsecutiveSubstrings(\"\") == 0)\n    assert(countConsecutiveSubstrings(\"a\") == 1)\n    assert(countConsecutiveSubstrings(\"aaabbbccca\") == 19)\n}\n\ntestCountConsecutiveSubstrings()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountConsecutiveSubstrings() {\n    assert(countConsecutiveSubstrings(\"aabbb\") == 9)\n    assert(countConsecutiveSubstrings(\"abc\") == 3)\n    assert(countConsecutiveSubstrings(\"aaa\") == 6)\n    assert(countConsecutiveSubstrings(\"\") == 0)\n    assert(countConsecutiveSubstrings(\"a\") == 1)\n    assert(countConsecutiveSubstrings(\"aaabbbccca\") == 19)\n}\n\ntestCountConsecutiveSubstrings()", "output": "countConsecutiveSubstrings"}, "all_code": "// countConsecutiveSubstrings calculates the number of substrings in a string that consist of only one unique character repeated consecutively.\n// It iterates through the string, tracking the length of consecutive identical characters, and uses the formula n*(n+1)/2 to count substrings for each segment.\nfunc countConsecutiveSubstrings(_ s: String) -> Int {\n    if s.isEmpty {\n        return 0\n    }\n\n    var count = 0  // To count consecutive substrings\n    var consecutiveLength = 1  // Length of the current consecutive characters\n\n    let characters = Array(s)\n    for i in 1..<characters.count {\n        if characters[i] == characters[i - 1] {\n            consecutiveLength += 1\n        } else {\n            count += consecutiveLength * (consecutiveLength + 1) / 2\n            consecutiveLength = 1\n        }\n    }\n\n    // Add the last segment\n    count += consecutiveLength * (consecutiveLength + 1) / 2\n\n    return count\n}\nfunc testCountConsecutiveSubstrings() {\n    assert(countConsecutiveSubstrings(\"aabbb\") == 9)\n    assert(countConsecutiveSubstrings(\"abc\") == 3)\n    assert(countConsecutiveSubstrings(\"aaa\") == 6)\n    assert(countConsecutiveSubstrings(\"\") == 0)\n    assert(countConsecutiveSubstrings(\"a\") == 1)\n    assert(countConsecutiveSubstrings(\"aaabbbccca\") == 19)\n}\n\ntestCountConsecutiveSubstrings()", "exec_outcome": "PASSED"}
{"code": "// categorizeOrders categorizes a list of order quantities into small, medium, and large orders.\n// The categorization is based on the following criteria:\n// - Small: order quantity between 1 and 10 (inclusive)\n// - Medium: order quantity between 11 and 50 (inclusive)\n// - Large: order quantity between 51 and 100 (inclusive)\n// The function returns a tuple of three integers representing the count of small, medium, and large orders respectively.\nfunc categorizeOrders(orders: [Int]) -> (small: Int, medium: Int, large: Int) {\n    var small = 0\n    var medium = 0\n    var large = 0\n    \n    for order in orders {\n        if order >= 1 && order <= 10 {\n            small += 1\n        } else if order >= 11 && order <= 50 {\n            medium += 1\n        } else if order >= 51 && order <= 100 {\n            large += 1\n        }\n    }\n    \n    return (small, medium, large)\n}", "test_cases": "", "test_case_results": "Input orders: [5, 15, 55, 25, 10, 60]\nSmall: 2, Medium: 2, Large: 2\nInput orders: [1, 2, 3, 4, 5]\nSmall: 5, Medium: 0, Large: 0\nInput orders: [20, 30, 40]\nSmall: 0, Medium: 3, Large: 0\nInput orders: [60, 70, 80, 90]\nSmall: 0, Medium: 0, Large: 4\nInput orders: [0, 101, 200]\nSmall: 0, Medium: 0, Large: 0\nInput orders: []\nSmall: 0, Medium: 0, Large: 0", "task_id": 2484, "assertions": "func testCategorizeOrders() {\n    assert(categorizeOrders(orders: [5, 15, 55, 25, 10, 60]) == (small: 2, medium: 2, large: 2))\n    assert(categorizeOrders(orders: [1, 2, 3, 4, 5]) == (small: 5, medium: 0, large: 0))\n    assert(categorizeOrders(orders: [20, 30, 40]) == (small: 0, medium: 3, large: 0))\n    assert(categorizeOrders(orders: [60, 70, 80, 90]) == (small: 0, medium: 0, large: 4))\n    assert(categorizeOrders(orders: [0, 101, 200]) == (small: 0, medium: 0, large: 0))\n    assert(categorizeOrders(orders: []) == (small: 0, medium: 0, large: 0))\n}\n\ntestCategorizeOrders()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCategorizeOrders() {\n    assert(categorizeOrders(orders: [5, 15, 55, 25, 10, 60]) == (small: 2, medium: 2, large: 2))\n    assert(categorizeOrders(orders: [1, 2, 3, 4, 5]) == (small: 5, medium: 0, large: 0))\n    assert(categorizeOrders(orders: [20, 30, 40]) == (small: 0, medium: 3, large: 0))\n    assert(categorizeOrders(orders: [60, 70, 80, 90]) == (small: 0, medium: 0, large: 4))\n    assert(categorizeOrders(orders: [0, 101, 200]) == (small: 0, medium: 0, large: 0))\n    assert(categorizeOrders(orders: []) == (small: 0, medium: 0, large: 0))\n}\n\ntestCategorizeOrders()", "output": "categorizeOrders"}, "all_code": "// categorizeOrders categorizes a list of order quantities into small, medium, and large orders.\n// The categorization is based on the following criteria:\n// - Small: order quantity between 1 and 10 (inclusive)\n// - Medium: order quantity between 11 and 50 (inclusive)\n// - Large: order quantity between 51 and 100 (inclusive)\n// The function returns a tuple of three integers representing the count of small, medium, and large orders respectively.\nfunc categorizeOrders(orders: [Int]) -> (small: Int, medium: Int, large: Int) {\n    var small = 0\n    var medium = 0\n    var large = 0\n    \n    for order in orders {\n        if order >= 1 && order <= 10 {\n            small += 1\n        } else if order >= 11 && order <= 50 {\n            medium += 1\n        } else if order >= 51 && order <= 100 {\n            large += 1\n        }\n    }\n    \n    return (small, medium, large)\n}\nfunc testCategorizeOrders() {\n    assert(categorizeOrders(orders: [5, 15, 55, 25, 10, 60]) == (small: 2, medium: 2, large: 2))\n    assert(categorizeOrders(orders: [1, 2, 3, 4, 5]) == (small: 5, medium: 0, large: 0))\n    assert(categorizeOrders(orders: [20, 30, 40]) == (small: 0, medium: 3, large: 0))\n    assert(categorizeOrders(orders: [60, 70, 80, 90]) == (small: 0, medium: 0, large: 4))\n    assert(categorizeOrders(orders: [0, 101, 200]) == (small: 0, medium: 0, large: 0))\n    assert(categorizeOrders(orders: []) == (small: 0, medium: 0, large: 0))\n}\n\ntestCategorizeOrders()", "exec_outcome": "PASSED"}
{"code": "// countEmployeesByDepartment counts the number of employees in each department.\n// It takes an array of dictionaries (each representing an employee with a \"department\" key) \n// and returns a dictionary with department names as keys and employee counts as values.\n// Departments with invalid or missing names are skipped.\nfunc countEmployeesByDepartment(employees: [[String: String]]) -> [String: Int] {\n    var departmentCount = [String: Int]()\n    for employee in employees {\n        if let department = employee[\"department\"] {\n            departmentCount[department] = (departmentCount[department] ?? 0) + 1\n        }\n    }\n    return departmentCount\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: [[\"name\": \"Alice\", \"department\": \"Engineering\"], [\"name\": \"Bob\", \"department\": \"HR\"], [\"name\": \"Charlie\", \"department\": \"Engineering\"], [\"name\": \"Dave\", \"department\": \"Marketing\"]]\nDepartment Counts: [\"Engineering\": 2, \"Marketing\": 1, \"HR\": 1]\n\nTest Case 2:\nInput: [[\"department\": \"\", \"name\": \"Eve\"], [\"department\": \"HR\", \"name\": \"Frank\"], [\"name\": \"Grace\", \"department\": \"Engineering\"]]\nDepartment Counts: [\"\": 1, \"Engineering\": 1, \"HR\": 1]\n\nTest Case 3:\nInput: [[\"name\": \"Henry\"], [\"department\": \"Marketing\", \"name\": \"Ivy\"], [\"name\": \"Jack\", \"department\": \"HR\"]]\nDepartment Counts: [\"Marketing\": 1, \"HR\": 1]\n\nTest Case 4:\nInput: []\nDepartment Counts: [:]", "task_id": 10849, "assertions": "func testCountEmployeesByDepartment() {\n    let testCase1 = [\n        [\"name\": \"Alice\", \"department\": \"Engineering\"],\n        [\"name\": \"Bob\", \"department\": \"HR\"],\n        [\"name\": \"Charlie\", \"department\": \"Engineering\"],\n        [\"name\": \"Dave\", \"department\": \"Marketing\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase1) == [\"Engineering\": 2, \"Marketing\": 1, \"HR\": 1])\n    \n    let testCase2 = [\n        [\"name\": \"Eve\", \"department\": \"\"],\n        [\"name\": \"Frank\", \"department\": \"HR\"],\n        [\"name\": \"Grace\", \"department\": \"Engineering\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase2) == [\"\": 1, \"Engineering\": 1, \"HR\": 1])\n    \n    let testCase3 = [\n        [\"name\": \"Henry\"],\n        [\"name\": \"Ivy\", \"department\": \"Marketing\"],\n        [\"name\": \"Jack\", \"department\": \"HR\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase3) == [\"Marketing\": 1, \"HR\": 1])\n    \n    let testCase4: [[String: String]] = []\n    assert(countEmployeesByDepartment(employees: testCase4) == [:])\n}\n\ntestCountEmployeesByDepartment()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountEmployeesByDepartment() {\n    let testCase1 = [\n        [\"name\": \"Alice\", \"department\": \"Engineering\"],\n        [\"name\": \"Bob\", \"department\": \"HR\"],\n        [\"name\": \"Charlie\", \"department\": \"Engineering\"],\n        [\"name\": \"Dave\", \"department\": \"Marketing\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase1) == [\"Engineering\": 2, \"Marketing\": 1, \"HR\": 1])\n    \n    let testCase2 = [\n        [\"name\": \"Eve\", \"department\": \"\"],\n        [\"name\": \"Frank\", \"department\": \"HR\"],\n        [\"name\": \"Grace\", \"department\": \"Engineering\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase2) == [\"\": 1, \"Engineering\": 1, \"HR\": 1])\n    \n    let testCase3 = [\n        [\"name\": \"Henry\"],\n        [\"name\": \"Ivy\", \"department\": \"Marketing\"],\n        [\"name\": \"Jack\", \"department\": \"HR\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase3) == [\"Marketing\": 1, \"HR\": 1])\n    \n    let testCase4: [[String: String]] = []\n    assert(countEmployeesByDepartment(employees: testCase4) == [:])\n}\n\ntestCountEmployeesByDepartment()", "output": "countEmployeesByDepartment"}, "all_code": "import Foundation\nimport Glibc\n\n// countEmployeesByDepartment counts the number of employees in each department.\n// It takes an array of dictionaries (each representing an employee with a \"department\" key) \n// and returns a dictionary with department names as keys and employee counts as values.\n// Departments with invalid or missing names are skipped.\nfunc countEmployeesByDepartment(employees: [[String: String]]) -> [String: Int] {\n    var departmentCount = [String: Int]()\n    for employee in employees {\n        if let department = employee[\"department\"] {\n            departmentCount[department] = (departmentCount[department] ?? 0) + 1\n        }\n    }\n    return departmentCount\n}\nfunc testCountEmployeesByDepartment() {\n    let testCase1 = [\n        [\"name\": \"Alice\", \"department\": \"Engineering\"],\n        [\"name\": \"Bob\", \"department\": \"HR\"],\n        [\"name\": \"Charlie\", \"department\": \"Engineering\"],\n        [\"name\": \"Dave\", \"department\": \"Marketing\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase1) == [\"Engineering\": 2, \"Marketing\": 1, \"HR\": 1])\n    \n    let testCase2 = [\n        [\"name\": \"Eve\", \"department\": \"\"],\n        [\"name\": \"Frank\", \"department\": \"HR\"],\n        [\"name\": \"Grace\", \"department\": \"Engineering\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase2) == [\"\": 1, \"Engineering\": 1, \"HR\": 1])\n    \n    let testCase3 = [\n        [\"name\": \"Henry\"],\n        [\"name\": \"Ivy\", \"department\": \"Marketing\"],\n        [\"name\": \"Jack\", \"department\": \"HR\"]\n    ]\n    assert(countEmployeesByDepartment(employees: testCase3) == [\"Marketing\": 1, \"HR\": 1])\n    \n    let testCase4: [[String: String]] = []\n    assert(countEmployeesByDepartment(employees: testCase4) == [:])\n}\n\ntestCountEmployeesByDepartment()", "exec_outcome": "PASSED"}
{"code": "// canBorrowBooks determines if all residents can borrow their desired list of books following given rules.\n// \n// Parameters:\n// - n: The number of residents.\n// - m: The maximum number of books each resident can hold at any time.\n// - bookList: An array of integers representing the desired books for each resident in order.\n//\n// Returns: \"YES\" if all residents can follow the borrowing rules, otherwise \"NO\".\nfunc canBorrowBooks(n: Int, m: Int, bookList: [Int]) -> String {\n    var borrowedBooks = [Int: Bool]()\n    var currentBooks = 0\n    \n    for book in bookList {\n        if borrowedBooks[book] != nil {\n            // If the book is already borrowed, that's a problem\n            return \"NO\"\n        }\n        if currentBooks < m {\n            // If the resident can borrow more books\n            borrowedBooks[book] = true\n            currentBooks += 1\n        } else {\n            // If the resident needs to return a book before borrowing\n            let bookToReturn = bookList[bookList.count - m]\n            borrowedBooks.removeValue(forKey: bookToReturn)\n            borrowedBooks[book] = true\n        }\n    }\n    \n    return \"YES\"\n}", "test_cases": "", "test_case_results": "Input: n = 3, m = 2, bookList = [1, 2, 3, 1, 2, 3]\nResult: NO\nInput: n = 2, m = 2, bookList = [1, 2, 3, 4]\nResult: YES\nInput: n = 1, m = 1, bookList = [1, 2, 1, 2]\nResult: NO\nInput: n = 3, m = 1, bookList = [1, 2, 3, 4, 5, 6]\nResult: YES", "task_id": 3291, "assertions": "func testCanBorrowBooks() {\n    assert(canBorrowBooks(n: 3, m: 2, bookList: [1, 2, 3, 1, 2, 3]) == \"NO\")\n    assert(canBorrowBooks(n: 2, m: 2, bookList: [1, 2, 3, 4]) == \"YES\")\n    assert(canBorrowBooks(n: 1, m: 1, bookList: [1, 2, 1, 2]) == \"NO\")\n    assert(canBorrowBooks(n: 3, m: 1, bookList: [1, 2, 3, 4, 5, 6]) == \"YES\")\n}\n\ntestCanBorrowBooks()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCanBorrowBooks() {\n    assert(canBorrowBooks(n: 3, m: 2, bookList: [1, 2, 3, 1, 2, 3]) == \"NO\")\n    assert(canBorrowBooks(n: 2, m: 2, bookList: [1, 2, 3, 4]) == \"YES\")\n    assert(canBorrowBooks(n: 1, m: 1, bookList: [1, 2, 1, 2]) == \"NO\")\n    assert(canBorrowBooks(n: 3, m: 1, bookList: [1, 2, 3, 4, 5, 6]) == \"YES\")\n}\n\ntestCanBorrowBooks()", "output": "canBorrowBooks"}, "all_code": "// canBorrowBooks determines if all residents can borrow their desired list of books following given rules.\n// \n// Parameters:\n// - n: The number of residents.\n// - m: The maximum number of books each resident can hold at any time.\n// - bookList: An array of integers representing the desired books for each resident in order.\n//\n// Returns: \"YES\" if all residents can follow the borrowing rules, otherwise \"NO\".\nfunc canBorrowBooks(n: Int, m: Int, bookList: [Int]) -> String {\n    var borrowedBooks = [Int: Bool]()\n    var currentBooks = 0\n    \n    for book in bookList {\n        if borrowedBooks[book] != nil {\n            // If the book is already borrowed, that's a problem\n            return \"NO\"\n        }\n        if currentBooks < m {\n            // If the resident can borrow more books\n            borrowedBooks[book] = true\n            currentBooks += 1\n        } else {\n            // If the resident needs to return a book before borrowing\n            let bookToReturn = bookList[bookList.count - m]\n            borrowedBooks.removeValue(forKey: bookToReturn)\n            borrowedBooks[book] = true\n        }\n    }\n    \n    return \"YES\"\n}\nfunc testCanBorrowBooks() {\n    assert(canBorrowBooks(n: 3, m: 2, bookList: [1, 2, 3, 1, 2, 3]) == \"NO\")\n    assert(canBorrowBooks(n: 2, m: 2, bookList: [1, 2, 3, 4]) == \"YES\")\n    assert(canBorrowBooks(n: 1, m: 1, bookList: [1, 2, 1, 2]) == \"NO\")\n    assert(canBorrowBooks(n: 3, m: 1, bookList: [1, 2, 3, 4, 5, 6]) == \"YES\")\n}\n\ntestCanBorrowBooks()", "exec_outcome": "PASSED"}
{"code": "// calculateEffectiveFrequency determines the effective frequency type based on the average noise level.\n// The function categorizes the noise values into predefined frequency types according to their average.\n// If the average noise level does not fall into any predefined range, it returns \"Not Found\".\nfunc calculateEffectiveFrequency(noiseValues: [Double]) -> String {\n    // Calculate the average noise level\n    let avgNoiseLevel = noiseValues.reduce(0.0, +) / Double(noiseValues.count)\n    \n    // Define frequency types and their corresponding ranges\n    let frequencyTypes = [\n        \"Very Low\": (lowerBound: 0.0, upperBound: 5.0),\n        \"Low\": (lowerBound: 5.0, upperBound: 10.0),\n        \"Fair\": (lowerBound: 10.0, upperBound: 15.0),\n        \"Medium\": (lowerBound: 15.0, upperBound: 20.0),\n        \"High\": (lowerBound: 20.0, upperBound: 25.0),\n        \"Very High\": (lowerBound: 25.0, upperBound: 30.0),\n        \"Ultra High\": (lowerBound: 30.0, upperBound: 35.0),\n        \"Extremely High\": (lowerBound: 35.0, upperBound: Double.infinity)\n    ]\n    \n    // Find the frequency type where the average noise level falls within the range\n    for (frequency, range) in frequencyTypes {\n        if avgNoiseLevel < range.upperBound {\n            return frequency\n        }\n    }\n    \n    // Return default if no range is found\n    return \"Not Found\"\n}", "test_cases": "", "test_case_results": "Noise Values: [1.0, 2.0, 3.0, 4.0]\nEffective Frequency: High\nNoise Values: [5.0, 6.0, 7.0, 8.0]\nEffective Frequency: High\nNoise Values: [10.0, 12.0, 14.0, 16.0]\nEffective Frequency: High\nNoise Values: [15.0, 18.0, 21.0, 24.0]\nEffective Frequency: High\nNoise Values: [20.0, 22.0, 24.0, 26.0]\nEffective Frequency: High\nNoise Values: [25.0, 28.0, 30.0, 32.0]\nEffective Frequency: Very High\nNoise Values: [30.0, 33.0, 35.0, 37.0]\nEffective Frequency: Ultra High\nNoise Values: [40.0, 45.0, 50.0, 55.0]\nEffective Frequency: Extremely High\nNoise Values: [0.0, 0.0, 0.0, 0.0]\nEffective Frequency: High", "task_id": 16445, "assertions": "func testCalculateEffectiveFrequency() {\n    assert(calculateEffectiveFrequency(noiseValues: [1, 2, 3, 4]) == \"Very Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [5, 6, 7, 8]) == \"Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [10, 12, 14, 16]) == \"Fair\")\n    assert(calculateEffectiveFrequency(noiseValues: [15, 18, 21, 24]) == \"Medium\")\n    assert(calculateEffectiveFrequency(noiseValues: [20, 22, 24, 26]) == \"High\")\n    assert(calculateEffectiveFrequency(noiseValues: [25, 28, 30, 32]) == \"Very High\")\n    assert(calculateEffectiveFrequency(noiseValues: [30, 33, 35, 37]) == \"Ultra High\")\n    assert(calculateEffectiveFrequency(noiseValues: [40, 45, 50, 55]) == \"Extremely High\")\n    assert(calculateEffectiveFrequency(noiseValues: [0, 0, 0, 0]) == \"Very Low\")\n}\n\ntestCalculateEffectiveFrequency()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCalculateEffectiveFrequency() {\n    assert(calculateEffectiveFrequency(noiseValues: [1, 2, 3, 4]) == \"Very Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [5, 6, 7, 8]) == \"Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [10, 12, 14, 16]) == \"Fair\")\n    assert(calculateEffectiveFrequency(noiseValues: [15, 18, 21, 24]) == \"Medium\")\n    assert(calculateEffectiveFrequency(noiseValues: [20, 22, 24, 26]) == \"High\")\n    assert(calculateEffectiveFrequency(noiseValues: [25, 28, 30, 32]) == \"Very High\")\n    assert(calculateEffectiveFrequency(noiseValues: [30, 33, 35, 37]) == \"Ultra High\")\n    assert(calculateEffectiveFrequency(noiseValues: [40, 45, 50, 55]) == \"Extremely High\")\n    assert(calculateEffectiveFrequency(noiseValues: [0, 0, 0, 0]) == \"Very Low\")\n}\n\ntestCalculateEffectiveFrequency()", "output": "calculateEffectiveFrequency"}, "all_code": "// calculateEffectiveFrequency determines the effective frequency type based on the average noise level.\n// The function categorizes the noise values into predefined frequency types according to their average.\n// If the average noise level does not fall into any predefined range, it returns \"Not Found\".\nfunc calculateEffectiveFrequency(noiseValues: [Double]) -> String {\n    // Calculate the average noise level\n    let avgNoiseLevel = noiseValues.reduce(0.0, +) / Double(noiseValues.count)\n    \n    // Define frequency types and their corresponding ranges\n    let frequencyTypes = [\n        \"Very Low\": (lowerBound: 0.0, upperBound: 5.0),\n        \"Low\": (lowerBound: 5.0, upperBound: 10.0),\n        \"Fair\": (lowerBound: 10.0, upperBound: 15.0),\n        \"Medium\": (lowerBound: 15.0, upperBound: 20.0),\n        \"High\": (lowerBound: 20.0, upperBound: 25.0),\n        \"Very High\": (lowerBound: 25.0, upperBound: 30.0),\n        \"Ultra High\": (lowerBound: 30.0, upperBound: 35.0),\n        \"Extremely High\": (lowerBound: 35.0, upperBound: Double.infinity)\n    ]\n    \n    // Find the frequency type where the average noise level falls within the range\n    for (frequency, range) in frequencyTypes {\n        if avgNoiseLevel < range.upperBound {\n            return frequency\n        }\n    }\n    \n    // Return default if no range is found\n    return \"Not Found\"\n}\nfunc testCalculateEffectiveFrequency() {\n    assert(calculateEffectiveFrequency(noiseValues: [1, 2, 3, 4]) == \"Very Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [5, 6, 7, 8]) == \"Low\")\n    assert(calculateEffectiveFrequency(noiseValues: [10, 12, 14, 16]) == \"Fair\")\n    assert(calculateEffectiveFrequency(noiseValues: [15, 18, 21, 24]) == \"Medium\")\n    assert(calculateEffectiveFrequency(noiseValues: [20, 22, 24, 26]) == \"High\")\n    assert(calculateEffectiveFrequency(noiseValues: [25, 28, 30, 32]) == \"Very High\")\n    assert(calculateEffectiveFrequency(noiseValues: [30, 33, 35, 37]) == \"Ultra High\")\n    assert(calculateEffectiveFrequency(noiseValues: [40, 45, 50, 55]) == \"Extremely High\")\n    assert(calculateEffectiveFrequency(noiseValues: [0, 0, 0, 0]) == \"Very Low\")\n}\n\ntestCalculateEffectiveFrequency()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "import Foundation\n\n// findReachableNode determines if there exists a node in a directed graph from which all other nodes are reachable.\n// It uses BFS (Breadth-First Search) to explore the graph from a starting node and checks reachability.\n// Parameters:\n//   - n: The number of nodes in the graph.\n//   - m: The number of edges in the graph (unused in the function but kept for consistency with the original).\n//   - edges: An array of tuples representing the directed edges between nodes.\n// Returns: The node number if such a node exists, otherwise -1.\nfunc findReachableNode(n: Int, m: Int, edges: [(Int, Int)]) -> Int {\n    // Helper function to perform BFS and return the set of reachable nodes from a start node.\n    func bfs(start: Int, graph: [Int: [Int]]) -> Set<Int> {\n        var visited = Set<Int>()\n        var queue = [start]\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            if !visited.contains(node) {\n                visited.insert(node)\n                if let neighbors = graph[node] {\n                    for neighbor in neighbors where !visited.contains(neighbor) {\n                        queue.append(neighbor)\n                    }\n                }\n            }\n        }\n        return visited\n    }\n    \n    // Create a directed graph from the edges.\n    var graph = [Int: [Int]]()\n    for (u, v) in edges {\n        graph[u, default: []].append(v)\n    }\n    \n    // Determine the starting node (the first node found in the graph).\n    guard let startNode = graph.keys.min() else {\n        return -1 // No edges, so no node can reach others.\n    }\n    \n    // Check if all nodes are reachable from the startNode.\n    let reachableFromStart = bfs(start: startNode, graph: graph)\n    if reachableFromStart.count != n {\n        return -1\n    }\n    \n    // Create a reverse graph to check if all nodes can reach the startNode.\n    var reverseGraph = [Int: [Int]]()\n    for (u, v) in edges {\n        reverseGraph[v, default: []].append(u)\n    }\n    \n    // Check if all nodes can reach the startNode in the reverse graph.\n    let allReachStart = bfs(start: startNode, graph: reverseGraph)\n    if allReachStart.count == n {\n        return startNode\n    } else {\n        return -1\n    }\n}", "test_cases": "", "test_case_results": "Input: n = 4, m = 4, edges = [(1, 2), (2, 3), (3, 4), (1, 3)]\nResult: -1\nInput: n = 3, m = 2, edges = [(1, 2), (2, 3)]\nResult: -1\nInput: n = 3, m = 3, edges = [(1, 2), (2, 3), (3, 1)]\nResult: 1\nInput: n = 4, m = 3, edges = [(1, 2), (2, 3), (3, 4)]\nResult: -1\nInput: n = 4, m = 4, edges = [(1, 2), (2, 3), (3, 4), (4, 1)]\nResult: 1\nInput: n = 3, m = 2, edges = [(1, 2), (3, 2)]\nResult: -1\nInput: n = 1, m = 0, edges = []\nResult: -1", "task_id": 23415, "assertions": "func testFindReachableNode() {\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (1, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (2, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 3, edges: [(1, 2), (2, 3), (3, 1)]) == 1)\n    assert(findReachableNode(n: 4, m: 3, edges: [(1, 2), (2, 3), (3, 4)]) == -1)\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (4, 1)]) == 1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (3, 2)]) == -1)\n    assert(findReachableNode(n: 1, m: 0, edges: []) == -1)\n}\n\ntestFindReachableNode()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindReachableNode() {\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (1, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (2, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 3, edges: [(1, 2), (2, 3), (3, 1)]) == 1)\n    assert(findReachableNode(n: 4, m: 3, edges: [(1, 2), (2, 3), (3, 4)]) == -1)\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (4, 1)]) == 1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (3, 2)]) == -1)\n    assert(findReachableNode(n: 1, m: 0, edges: []) == -1)\n}\n\ntestFindReachableNode()", "output": "findReachableNode"}, "all_code": "import Glibc\n\nimport Foundation\n\n// findReachableNode determines if there exists a node in a directed graph from which all other nodes are reachable.\n// It uses BFS (Breadth-First Search) to explore the graph from a starting node and checks reachability.\n// Parameters:\n//   - n: The number of nodes in the graph.\n//   - m: The number of edges in the graph (unused in the function but kept for consistency with the original).\n//   - edges: An array of tuples representing the directed edges between nodes.\n// Returns: The node number if such a node exists, otherwise -1.\nfunc findReachableNode(n: Int, m: Int, edges: [(Int, Int)]) -> Int {\n    // Helper function to perform BFS and return the set of reachable nodes from a start node.\n    func bfs(start: Int, graph: [Int: [Int]]) -> Set<Int> {\n        var visited = Set<Int>()\n        var queue = [start]\n        while !queue.isEmpty {\n            let node = queue.removeFirst()\n            if !visited.contains(node) {\n                visited.insert(node)\n                if let neighbors = graph[node] {\n                    for neighbor in neighbors where !visited.contains(neighbor) {\n                        queue.append(neighbor)\n                    }\n                }\n            }\n        }\n        return visited\n    }\n    \n    // Create a directed graph from the edges.\n    var graph = [Int: [Int]]()\n    for (u, v) in edges {\n        graph[u, default: []].append(v)\n    }\n    \n    // Determine the starting node (the first node found in the graph).\n    guard let startNode = graph.keys.min() else {\n        return -1 // No edges, so no node can reach others.\n    }\n    \n    // Check if all nodes are reachable from the startNode.\n    let reachableFromStart = bfs(start: startNode, graph: graph)\n    if reachableFromStart.count != n {\n        return -1\n    }\n    \n    // Create a reverse graph to check if all nodes can reach the startNode.\n    var reverseGraph = [Int: [Int]]()\n    for (u, v) in edges {\n        reverseGraph[v, default: []].append(u)\n    }\n    \n    // Check if all nodes can reach the startNode in the reverse graph.\n    let allReachStart = bfs(start: startNode, graph: reverseGraph)\n    if allReachStart.count == n {\n        return startNode\n    } else {\n        return -1\n    }\n}\nfunc testFindReachableNode() {\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (1, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (2, 3)]) == -1)\n    assert(findReachableNode(n: 3, m: 3, edges: [(1, 2), (2, 3), (3, 1)]) == 1)\n    assert(findReachableNode(n: 4, m: 3, edges: [(1, 2), (2, 3), (3, 4)]) == -1)\n    assert(findReachableNode(n: 4, m: 4, edges: [(1, 2), (2, 3), (3, 4), (4, 1)]) == 1)\n    assert(findReachableNode(n: 3, m: 2, edges: [(1, 2), (3, 2)]) == -1)\n    assert(findReachableNode(n: 1, m: 0, edges: []) == -1)\n}\n\ntestFindReachableNode()", "exec_outcome": "PASSED"}
{"code": "// Solution class represents a 2D grid and provides functionality to compute the prefix sum matrix\n// and query the sum of a subgrid efficiently.\nclass Solution {\n    let m: Int\n    let n: Int\n    var prefixSum: [[Int]]\n    \n    // Initializes the Solution object with the given grid.\n    // The grid must be non-empty and rectangular.\n    // Throws a fatal error if the grid is empty.\n    init(grid: [[Int]]) {\n        guard !grid.isEmpty, !grid[0].isEmpty else {\n            fatalError(\"Grid is empty\")\n        }\n        \n        self.m = grid.count\n        self.n = grid[0].count\n        self.prefixSum = Array(repeating: Array(repeating: 0, count: self.n + 1), count: self.m + 1)\n        \n        // Compute the prefix sum matrix\n        for i in 0..<self.m {\n            for j in 0..<self.n {\n                self.prefixSum[i + 1][j + 1] = grid[i][j] + self.prefixSum[i][j + 1] + self.prefixSum[i + 1][j] - self.prefixSum[i][j]\n            }\n        }\n    }\n    \n    // Returns the sum of the heights of all cells within the subgrid formed by (x1, y1) and (x2, y2).\n    // The coordinates are inclusive.\n    func querySum(x1: Int, y1: Int, x2: Int, y2: Int) -> Int {\n        return self.prefixSum[x2 + 1][y2 + 1] - self.prefixSum[x1][y2 + 1] - self.prefixSum[x2 + 1][y1] + self.prefixSum[x1][y1]\n    }\n}", "test_cases": "", "test_case_results": "Test Grid 1: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nQuery from (0, 0) to (1, 1): Sum = 12\nQuery from (0, 0) to (2, 2): Sum = 45\nQuery from (1, 1) to (2, 2): Sum = 28\n\nTest Grid 2: [[1, 1], [1, 1]]\nQuery from (0, 0) to (1, 1): Sum = 4\nQuery from (0, 0) to (0, 1): Sum = 2\n\nTest Grid 3: [[10, 20, 30], [40, 50, 60]]\nQuery from (0, 0) to (1, 2): Sum = 210\nQuery from (1, 1) to (1, 2): Sum = 110", "task_id": 17409, "assertions": "func testSolution() {\n    // Test Grid 1\n    let grid1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    let solution1 = Solution(grid: grid1)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 12)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 2, y2: 2) == 45)\n    assert(solution1.querySum(x1: 1, y1: 1, x2: 2, y2: 2) == 28)\n    \n    // Test Grid 2\n    let grid2 = [\n        [1, 1],\n        [1, 1]\n    ]\n    let solution2 = Solution(grid: grid2)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 4)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 0, y2: 1) == 2)\n    \n    // Test Grid 3\n    let grid3 = [\n        [10, 20, 30],\n        [40, 50, 60]\n    ]\n    let solution3 = Solution(grid: grid3)\n    assert(solution3.querySum(x1: 0, y1: 0, x2: 1, y2: 2) == 210)\n    assert(solution3.querySum(x1: 1, y1: 1, x2: 1, y2: 2) == 110)\n}\n\ntestSolution()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSolution() {\n    // Test Grid 1\n    let grid1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    let solution1 = Solution(grid: grid1)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 12)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 2, y2: 2) == 45)\n    assert(solution1.querySum(x1: 1, y1: 1, x2: 2, y2: 2) == 28)\n    \n    // Test Grid 2\n    let grid2 = [\n        [1, 1],\n        [1, 1]\n    ]\n    let solution2 = Solution(grid: grid2)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 4)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 0, y2: 1) == 2)\n    \n    // Test Grid 3\n    let grid3 = [\n        [10, 20, 30],\n        [40, 50, 60]\n    ]\n    let solution3 = Solution(grid: grid3)\n    assert(solution3.querySum(x1: 0, y1: 0, x2: 1, y2: 2) == 210)\n    assert(solution3.querySum(x1: 1, y1: 1, x2: 1, y2: 2) == 110)\n}\n\ntestSolution()", "output": "querySum"}, "all_code": "// Solution class represents a 2D grid and provides functionality to compute the prefix sum matrix\n// and query the sum of a subgrid efficiently.\nclass Solution {\n    let m: Int\n    let n: Int\n    var prefixSum: [[Int]]\n    \n    // Initializes the Solution object with the given grid.\n    // The grid must be non-empty and rectangular.\n    // Throws a fatal error if the grid is empty.\n    init(grid: [[Int]]) {\n        guard !grid.isEmpty, !grid[0].isEmpty else {\n            fatalError(\"Grid is empty\")\n        }\n        \n        self.m = grid.count\n        self.n = grid[0].count\n        self.prefixSum = Array(repeating: Array(repeating: 0, count: self.n + 1), count: self.m + 1)\n        \n        // Compute the prefix sum matrix\n        for i in 0..<self.m {\n            for j in 0..<self.n {\n                self.prefixSum[i + 1][j + 1] = grid[i][j] + self.prefixSum[i][j + 1] + self.prefixSum[i + 1][j] - self.prefixSum[i][j]\n            }\n        }\n    }\n    \n    // Returns the sum of the heights of all cells within the subgrid formed by (x1, y1) and (x2, y2).\n    // The coordinates are inclusive.\n    func querySum(x1: Int, y1: Int, x2: Int, y2: Int) -> Int {\n        return self.prefixSum[x2 + 1][y2 + 1] - self.prefixSum[x1][y2 + 1] - self.prefixSum[x2 + 1][y1] + self.prefixSum[x1][y1]\n    }\n}\nfunc testSolution() {\n    // Test Grid 1\n    let grid1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    let solution1 = Solution(grid: grid1)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 12)\n    assert(solution1.querySum(x1: 0, y1: 0, x2: 2, y2: 2) == 45)\n    assert(solution1.querySum(x1: 1, y1: 1, x2: 2, y2: 2) == 28)\n    \n    // Test Grid 2\n    let grid2 = [\n        [1, 1],\n        [1, 1]\n    ]\n    let solution2 = Solution(grid: grid2)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 1, y2: 1) == 4)\n    assert(solution2.querySum(x1: 0, y1: 0, x2: 0, y2: 1) == 2)\n    \n    // Test Grid 3\n    let grid3 = [\n        [10, 20, 30],\n        [40, 50, 60]\n    ]\n    let solution3 = Solution(grid: grid3)\n    assert(solution3.querySum(x1: 0, y1: 0, x2: 1, y2: 2) == 210)\n    assert(solution3.querySum(x1: 1, y1: 1, x2: 1, y2: 2) == 110)\n}\n\ntestSolution()", "exec_outcome": "PASSED"}
{"code": "// removeAdjacentDuplicates removes adjacent duplicate characters from a string.\n// It uses a stack to keep track of characters. If the current character matches the top of the stack,\n// it removes the character from the stack. Otherwise, it adds the character to the stack.\n// The final result is the remaining characters in the stack joined into a string.\nfunc removeAdjacentDuplicates(_ s: String) -> String {\n    var stack = [Character]()\n    for char in s {\n        if let last = stack.last, last == char {\n            stack.removeLast()\n        } else {\n            stack.append(char)\n        }\n    }\n    return String(stack)\n}", "test_cases": "", "test_case_results": "Input: \"abbaca\"\nResult: \"ca\"\nInput: \"azxxzy\"\nResult: \"ay\"\nInput: \"aababaab\"\nResult: \"ba\"\nInput: \"aaaaa\"\nResult: \"a\"\nInput: \"\"\nResult: \"\"", "task_id": 20416, "assertions": "func testRemoveAdjacentDuplicates() {\n    assert(removeAdjacentDuplicates(\"abbaca\") == \"ca\")\n    assert(removeAdjacentDuplicates(\"azxxzy\") == \"ay\")\n    assert(removeAdjacentDuplicates(\"aababaab\") == \"ba\")\n    assert(removeAdjacentDuplicates(\"aaaaa\") == \"a\")\n    assert(removeAdjacentDuplicates(\"\") == \"\")\n}\n\ntestRemoveAdjacentDuplicates()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testRemoveAdjacentDuplicates() {\n    assert(removeAdjacentDuplicates(\"abbaca\") == \"ca\")\n    assert(removeAdjacentDuplicates(\"azxxzy\") == \"ay\")\n    assert(removeAdjacentDuplicates(\"aababaab\") == \"ba\")\n    assert(removeAdjacentDuplicates(\"aaaaa\") == \"a\")\n    assert(removeAdjacentDuplicates(\"\") == \"\")\n}\n\ntestRemoveAdjacentDuplicates()", "output": "removeAdjacentDuplicates"}, "all_code": "// removeAdjacentDuplicates removes adjacent duplicate characters from a string.\n// It uses a stack to keep track of characters. If the current character matches the top of the stack,\n// it removes the character from the stack. Otherwise, it adds the character to the stack.\n// The final result is the remaining characters in the stack joined into a string.\nfunc removeAdjacentDuplicates(_ s: String) -> String {\n    var stack = [Character]()\n    for char in s {\n        if let last = stack.last, last == char {\n            stack.removeLast()\n        } else {\n            stack.append(char)\n        }\n    }\n    return String(stack)\n}\nfunc testRemoveAdjacentDuplicates() {\n    assert(removeAdjacentDuplicates(\"abbaca\") == \"ca\")\n    assert(removeAdjacentDuplicates(\"azxxzy\") == \"ay\")\n    assert(removeAdjacentDuplicates(\"aababaab\") == \"ba\")\n    assert(removeAdjacentDuplicates(\"aaaaa\") == \"a\")\n    assert(removeAdjacentDuplicates(\"\") == \"\")\n}\n\ntestRemoveAdjacentDuplicates()", "exec_outcome": "PASSED"}
{"code": "func removeDuplicates<T: Hashable>(from array: [T]) -> [T] {\n    var seen = Set<T>()\n    var result = [T]()\n    for item in array {\n        if !seen.contains(item) {\n            seen.insert(item)\n            result.append(item)\n        }\n    }\n    return result\n}", "test_cases": "", "test_case_results": "Testing with Int arrays:\nInput: [1, 2, 3, 2, 4, 3, 5]\nResult: [1, 2, 3, 4, 5]\nInput: [5, 5, 5, 5, 5]\nResult: [5]\nInput: []\nResult: []\n\nTesting with String arrays:\nInput: [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]\nResult: [\"apple\", \"banana\", \"orange\"]\nInput: [\"a\", \"b\", \"a\", \"c\", \"b\", \"d\"]\nResult: [\"a\", \"b\", \"c\", \"d\"]\nInput: []\nResult: []", "task_id": 17748, "assertions": "func testRemoveDuplicates() {\n    // Test with Int arrays\n    assert(removeDuplicates(from: [1, 2, 3, 2, 4, 3, 5]) == [1, 2, 3, 4, 5])\n    assert(removeDuplicates(from: [5, 5, 5, 5, 5]) == [5])\n    assert(removeDuplicates(from: []) == [])\n    \n    // Test with String arrays\n    assert(removeDuplicates(from: [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]) == [\"apple\", \"banana\", \"orange\"])\n    assert(removeDuplicates(from: [\"a\", \"b\", \"a\", \"c\", \"b\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\n    assert(removeDuplicates(from: []) == [])\n}\n\ntestRemoveDuplicates()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testRemoveDuplicates() {\n    // Test with Int arrays\n    assert(removeDuplicates(from: [1, 2, 3, 2, 4, 3, 5]) == [1, 2, 3, 4, 5])\n    assert(removeDuplicates(from: [5, 5, 5, 5, 5]) == [5])\n    assert(removeDuplicates(from: []) == [])\n    \n    // Test with String arrays\n    assert(removeDuplicates(from: [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]) == [\"apple\", \"banana\", \"orange\"])\n    assert(removeDuplicates(from: [\"a\", \"b\", \"a\", \"c\", \"b\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\n    assert(removeDuplicates(from: []) == [])\n}\n\ntestRemoveDuplicates()", "output": "removeDuplicates"}, "all_code": "func removeDuplicates<T: Hashable>(from array: [T]) -> [T] {\n    var seen = Set<T>()\n    var result = [T]()\n    for item in array {\n        if !seen.contains(item) {\n            seen.insert(item)\n            result.append(item)\n        }\n    }\n    return result\n}\nfunc testRemoveDuplicates() {\n    // Test with Int arrays\n    assert(removeDuplicates(from: [1, 2, 3, 2, 4, 3, 5]) == [1, 2, 3, 4, 5])\n    assert(removeDuplicates(from: [5, 5, 5, 5, 5]) == [5])\n    assert(removeDuplicates(from: []) == [])\n    \n    // Test with String arrays\n    assert(removeDuplicates(from: [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]) == [\"apple\", \"banana\", \"orange\"])\n    assert(removeDuplicates(from: [\"a\", \"b\", \"a\", \"c\", \"b\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\n    assert(removeDuplicates(from: []) == [])\n}\n\ntestRemoveDuplicates()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// longestUniquePath calculates the length of the longest path in a grid where no cell's value is repeated.\n// It uses a depth-first search (DFS) approach to explore all possible paths while keeping track of visited values.\n// The function backtracks to explore all possible paths from each starting cell.\nfunc longestUniquePath(grid: [[Character]]) -> Int {\n    let n = grid.count\n    guard n > 0 else { return 0 }\n    let m = grid[0].count\n    var maxLength = 0\n    \n    // dfs is a nested helper function that performs the depth-first search.\n    // It updates the maxLength variable whenever a longer unique path is found.\n    func dfs(x: Int, y: Int, visited: inout Set<Character>) {\n        maxLength = max(maxLength, visited.count)\n        \n        // Define the four possible directions to move: up, down, left, right.\n        let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for (dx, dy) in directions {\n            let nx = x + dx\n            let ny = y + dy\n            // Check if the next cell is within bounds and its value hasn't been visited.\n            if nx >= 0 && nx < n && ny >= 0 && ny < m && !visited.contains(grid[nx][ny]) {\n                visited.insert(grid[nx][ny])\n                dfs(x: nx, y: ny, visited: &visited)\n                visited.remove(grid[nx][ny]) // Backtrack to explore other paths.\n            }\n        }\n    }\n    \n    // Iterate over each cell in the grid to start the DFS from every possible starting point.\n    for i in 0..<n {\n        for j in 0..<m {\n            var visited: Set<Character> = [grid[i][j]]\n            dfs(x: i, y: j, visited: &visited)\n        }\n    }\n    \n    return maxLength\n}", "test_cases": "", "test_case_results": "Test case 1:\nA B C\nD E F\nG H I\nLongest unique path length: 9\n\nTest case 2:\nA B\nC D\nLongest unique path length: 4\n\nTest case 3:\nA\nLongest unique path length: 1\n\nTest case 4:\nA B C\nA D E\nLongest unique path length: 5", "task_id": 16970, "assertions": "func testLongestUniquePath() {\n    let testCase1: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    assert(longestUniquePath(grid: testCase1) == 9)\n    \n    let testCase2: [[Character]] = [\n        [\"A\", \"B\"],\n        [\"C\", \"D\"]\n    ]\n    assert(longestUniquePath(grid: testCase2) == 4)\n    \n    let testCase3: [[Character]] = [\n        [\"A\"]\n    ]\n    assert(longestUniquePath(grid: testCase3) == 1)\n    \n    let testCase4: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"A\", \"D\", \"E\"]\n    ]\n    assert(longestUniquePath(grid: testCase4) == 5)\n}\n\ntestLongestUniquePath()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLongestUniquePath() {\n    let testCase1: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    assert(longestUniquePath(grid: testCase1) == 9)\n    \n    let testCase2: [[Character]] = [\n        [\"A\", \"B\"],\n        [\"C\", \"D\"]\n    ]\n    assert(longestUniquePath(grid: testCase2) == 4)\n    \n    let testCase3: [[Character]] = [\n        [\"A\"]\n    ]\n    assert(longestUniquePath(grid: testCase3) == 1)\n    \n    let testCase4: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"A\", \"D\", \"E\"]\n    ]\n    assert(longestUniquePath(grid: testCase4) == 5)\n}\n\ntestLongestUniquePath()", "output": "longestUniquePath"}, "all_code": "import Foundation\nimport Glibc\n\n// longestUniquePath calculates the length of the longest path in a grid where no cell's value is repeated.\n// It uses a depth-first search (DFS) approach to explore all possible paths while keeping track of visited values.\n// The function backtracks to explore all possible paths from each starting cell.\nfunc longestUniquePath(grid: [[Character]]) -> Int {\n    let n = grid.count\n    guard n > 0 else { return 0 }\n    let m = grid[0].count\n    var maxLength = 0\n    \n    // dfs is a nested helper function that performs the depth-first search.\n    // It updates the maxLength variable whenever a longer unique path is found.\n    func dfs(x: Int, y: Int, visited: inout Set<Character>) {\n        maxLength = max(maxLength, visited.count)\n        \n        // Define the four possible directions to move: up, down, left, right.\n        let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        for (dx, dy) in directions {\n            let nx = x + dx\n            let ny = y + dy\n            // Check if the next cell is within bounds and its value hasn't been visited.\n            if nx >= 0 && nx < n && ny >= 0 && ny < m && !visited.contains(grid[nx][ny]) {\n                visited.insert(grid[nx][ny])\n                dfs(x: nx, y: ny, visited: &visited)\n                visited.remove(grid[nx][ny]) // Backtrack to explore other paths.\n            }\n        }\n    }\n    \n    // Iterate over each cell in the grid to start the DFS from every possible starting point.\n    for i in 0..<n {\n        for j in 0..<m {\n            var visited: Set<Character> = [grid[i][j]]\n            dfs(x: i, y: j, visited: &visited)\n        }\n    }\n    \n    return maxLength\n}\nfunc testLongestUniquePath() {\n    let testCase1: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"D\", \"E\", \"F\"],\n        [\"G\", \"H\", \"I\"]\n    ]\n    assert(longestUniquePath(grid: testCase1) == 9)\n    \n    let testCase2: [[Character]] = [\n        [\"A\", \"B\"],\n        [\"C\", \"D\"]\n    ]\n    assert(longestUniquePath(grid: testCase2) == 4)\n    \n    let testCase3: [[Character]] = [\n        [\"A\"]\n    ]\n    assert(longestUniquePath(grid: testCase3) == 1)\n    \n    let testCase4: [[Character]] = [\n        [\"A\", \"B\", \"C\"],\n        [\"A\", \"D\", \"E\"]\n    ]\n    assert(longestUniquePath(grid: testCase4) == 5)\n}\n\ntestLongestUniquePath()", "exec_outcome": "PASSED"}
{"code": "// minimumVolunteers calculates the minimum number of volunteers required to cover all shifts without overlapping.\n// The function takes an array of tuples, where each tuple represents a shift with start and end times.\n// The algorithm sorts the shifts by end time and then checks for overlaps to determine the minimum volunteers needed.\nfunc minimumVolunteers(shifts: [(start: Int, end: Int)]) -> Int {\n    if shifts.isEmpty {\n        return 0\n    }\n    \n    // Sort shifts by end time\n    let sortedShifts = shifts.sorted { $0.end < $1.end }\n    var endTime = sortedShifts[0].end\n    var volunteers = 1\n    \n    for i in 1..<sortedShifts.count {\n        if sortedShifts[i].start < endTime {\n            // Overlapping shift, need another volunteer\n            volunteers += 1\n            endTime = sortedShifts[i].start\n        } else {\n            // Non-overlapping shift, update end time\n            endTime = sortedShifts[i].end\n        }\n    }\n    \n    return volunteers\n}", "test_cases": "", "test_case_results": "Shifts: [(start: 1, end: 3), (start: 2, end: 4), (start: 3, end: 5)]\nMinimum Volunteers: 2\nShifts: [(start: 1, end: 2), (start: 3, end: 4), (start: 5, end: 6)]\nMinimum Volunteers: 1\nShifts: [(start: 1, end: 5), (start: 2, end: 3), (start: 4, end: 6)]\nMinimum Volunteers: 2\nShifts: []\nMinimum Volunteers: 0\nShifts: [(start: 1, end: 2)]\nMinimum Volunteers: 1", "task_id": 5593, "assertions": "func testMinimumVolunteers() {\n    assert(minimumVolunteers(shifts: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumVolunteers(shifts: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumVolunteers(shifts: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(minimumVolunteers(shifts: []) == 0)\n    assert(minimumVolunteers(shifts: [(1, 2)]) == 1)\n}\n\ntestMinimumVolunteers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinimumVolunteers() {\n    assert(minimumVolunteers(shifts: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumVolunteers(shifts: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumVolunteers(shifts: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(minimumVolunteers(shifts: []) == 0)\n    assert(minimumVolunteers(shifts: [(1, 2)]) == 1)\n}\n\ntestMinimumVolunteers()", "output": "minimumVolunteers"}, "all_code": "// minimumVolunteers calculates the minimum number of volunteers required to cover all shifts without overlapping.\n// The function takes an array of tuples, where each tuple represents a shift with start and end times.\n// The algorithm sorts the shifts by end time and then checks for overlaps to determine the minimum volunteers needed.\nfunc minimumVolunteers(shifts: [(start: Int, end: Int)]) -> Int {\n    if shifts.isEmpty {\n        return 0\n    }\n    \n    // Sort shifts by end time\n    let sortedShifts = shifts.sorted { $0.end < $1.end }\n    var endTime = sortedShifts[0].end\n    var volunteers = 1\n    \n    for i in 1..<sortedShifts.count {\n        if sortedShifts[i].start < endTime {\n            // Overlapping shift, need another volunteer\n            volunteers += 1\n            endTime = sortedShifts[i].start\n        } else {\n            // Non-overlapping shift, update end time\n            endTime = sortedShifts[i].end\n        }\n    }\n    \n    return volunteers\n}\nfunc testMinimumVolunteers() {\n    assert(minimumVolunteers(shifts: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumVolunteers(shifts: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumVolunteers(shifts: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(minimumVolunteers(shifts: []) == 0)\n    assert(minimumVolunteers(shifts: [(1, 2)]) == 1)\n}\n\ntestMinimumVolunteers()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// cleanText removes punctuation and converts all letters to lowercase in the input string.\n// It uses CharacterSet.punctuationCharacters to identify and remove punctuation marks.\nfunc cleanText(_ text: String) -> String {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleaned = text.lowercased().unicodeScalars.filter { !punctuationSet.contains($0) }\n    return String(String.UnicodeScalarView(cleaned))\n}\n\n// countWordFrequencies counts the frequency of each word in the cleaned text, excluding the stopwords.\n// It splits the cleaned text into words and filters out any words that are in the stopwords set.\n// The function returns a dictionary where keys are words and values are their respective counts.\nfunc countWordFrequencies(_ cleanedText: String, stopwords: Set<String>) -> [String: Int] {\n    let words = cleanedText.components(separatedBy: .whitespaces).filter { !$0.isEmpty }\n    let filteredWords = words.filter { !stopwords.contains($0) }\n    var frequencies = [String: Int]()\n    for word in filteredWords {\n        frequencies[word, default: 0] += 1\n    }\n    return frequencies\n}\n\n// mostCommonWord finds the most frequently occurring word in the frequencies dictionary.\n// It returns the word with the highest count. If the dictionary is empty, it returns an empty string.\nfunc mostCommonWord(_ frequencies: [String: Int]) -> String {\n    return frequencies.max(by: { $0.value < $1.value })?.key ?? \"\"\n}", "test_cases": "", "test_case_results": "Input text: \"Hello, world! This is a test.\"\nStopwords: [\"is\", \"a\"]\nCleaned text: \"hello world this is a test\"\nWord frequencies: [\"hello\": 1, \"this\": 1, \"world\": 1, \"test\": 1]\nMost common word: \"hello\"\n---\nInput text: \"Swift is awesome! Awesome, right?\"\nStopwords: [\"right\"]\nCleaned text: \"swift is awesome awesome right\"\nWord frequencies: [\"is\": 1, \"swift\": 1, \"awesome\": 2]\nMost common word: \"awesome\"\n---\nInput text: \"No stopwords here.\"\nStopwords: []\nCleaned text: \"no stopwords here\"\nWord frequencies: [\"no\": 1, \"stopwords\": 1, \"here\": 1]\nMost common word: \"no\"\n---", "task_id": 29832, "assertions": "func testWordFrequencyFunctions() {\n    // Test case 1\n    let cleaned1 = cleanText(\"Hello, world! This is a test.\")\n    assert(cleaned1 == \"hello world this is a test\")\n    let frequencies1 = countWordFrequencies(cleaned1, stopwords: Set([\"is\", \"a\"]))\n    assert(frequencies1 == [\"hello\": 1, \"this\": 1, \"world\": 1, \"test\": 1])\n    assert(mostCommonWord(frequencies1) == \"hello\")\n    \n    // Test case 2\n    let cleaned2 = cleanText(\"Swift is awesome! Awesome, right?\")\n    assert(cleaned2 == \"swift is awesome awesome right\")\n    let frequencies2 = countWordFrequencies(cleaned2, stopwords: Set([\"right\"]))\n    assert(frequencies2 == [\"is\": 1, \"swift\": 1, \"awesome\": 2])\n    assert(mostCommonWord(frequencies2) == \"awesome\")\n    \n    // Test case 3\n    let cleaned3 = cleanText(\"No stopwords here.\")\n    assert(cleaned3 == \"no stopwords here\")\n    let frequencies3 = countWordFrequencies(cleaned3, stopwords: Set())\n    assert(frequencies3 == [\"no\": 1, \"stopwords\": 1, \"here\": 1])\n    assert(mostCommonWord(frequencies3) == \"no\")\n}\n\ntestWordFrequencyFunctions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testWordFrequencyFunctions() {\n    // Test case 1\n    let cleaned1 = cleanText(\"Hello, world! This is a test.\")\n    assert(cleaned1 == \"hello world this is a test\")\n    let frequencies1 = countWordFrequencies(cleaned1, stopwords: Set([\"is\", \"a\"]))\n    assert(frequencies1 == [\"hello\": 1, \"this\": 1, \"world\": 1, \"test\": 1])\n    assert(mostCommonWord(frequencies1) == \"hello\")\n    \n    // Test case 2\n    let cleaned2 = cleanText(\"Swift is awesome! Awesome, right?\")\n    assert(cleaned2 == \"swift is awesome awesome right\")\n    let frequencies2 = countWordFrequencies(cleaned2, stopwords: Set([\"right\"]))\n    assert(frequencies2 == [\"is\": 1, \"swift\": 1, \"awesome\": 2])\n    assert(mostCommonWord(frequencies2) == \"awesome\")\n    \n    // Test case 3\n    let cleaned3 = cleanText(\"No stopwords here.\")\n    assert(cleaned3 == \"no stopwords here\")\n    let frequencies3 = countWordFrequencies(cleaned3, stopwords: Set())\n    assert(frequencies3 == [\"no\": 1, \"stopwords\": 1, \"here\": 1])\n    assert(mostCommonWord(frequencies3) == \"no\")\n}\n\ntestWordFrequencyFunctions()", "output": "The functions being tested are: `cleanText`, `countWordFrequencies`, and `mostCommonWord`. \n\nHowever, the name of the test function itself is `testWordFrequencyFunctions`. \n\nSince you asked specifically for \"the name of the function that is being tested\" and the test function is testing multiple functions together (as is common in test suites), the most accurate answer would be the name of the test function itself that encompasses all these tests.\n\nTherefore, the answer is: `testWordFrequencyFunctions`"}, "all_code": "import Foundation\n\n// cleanText removes punctuation and converts all letters to lowercase in the input string.\n// It uses CharacterSet.punctuationCharacters to identify and remove punctuation marks.\nfunc cleanText(_ text: String) -> String {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleaned = text.lowercased().unicodeScalars.filter { !punctuationSet.contains($0) }\n    return String(String.UnicodeScalarView(cleaned))\n}\n\n// countWordFrequencies counts the frequency of each word in the cleaned text, excluding the stopwords.\n// It splits the cleaned text into words and filters out any words that are in the stopwords set.\n// The function returns a dictionary where keys are words and values are their respective counts.\nfunc countWordFrequencies(_ cleanedText: String, stopwords: Set<String>) -> [String: Int] {\n    let words = cleanedText.components(separatedBy: .whitespaces).filter { !$0.isEmpty }\n    let filteredWords = words.filter { !stopwords.contains($0) }\n    var frequencies = [String: Int]()\n    for word in filteredWords {\n        frequencies[word, default: 0] += 1\n    }\n    return frequencies\n}\n\n// mostCommonWord finds the most frequently occurring word in the frequencies dictionary.\n// It returns the word with the highest count. If the dictionary is empty, it returns an empty string.\nfunc mostCommonWord(_ frequencies: [String: Int]) -> String {\n    return frequencies.max(by: { $0.value < $1.value })?.key ?? \"\"\n}\nfunc testWordFrequencyFunctions() {\n    // Test case 1\n    let cleaned1 = cleanText(\"Hello, world! This is a test.\")\n    assert(cleaned1 == \"hello world this is a test\")\n    let frequencies1 = countWordFrequencies(cleaned1, stopwords: Set([\"is\", \"a\"]))\n    assert(frequencies1 == [\"hello\": 1, \"this\": 1, \"world\": 1, \"test\": 1])\n    assert(mostCommonWord(frequencies1) == \"hello\")\n    \n    // Test case 2\n    let cleaned2 = cleanText(\"Swift is awesome! Awesome, right?\")\n    assert(cleaned2 == \"swift is awesome awesome right\")\n    let frequencies2 = countWordFrequencies(cleaned2, stopwords: Set([\"right\"]))\n    assert(frequencies2 == [\"is\": 1, \"swift\": 1, \"awesome\": 2])\n    assert(mostCommonWord(frequencies2) == \"awesome\")\n    \n    // Test case 3\n    let cleaned3 = cleanText(\"No stopwords here.\")\n    assert(cleaned3 == \"no stopwords here\")\n    let frequencies3 = countWordFrequencies(cleaned3, stopwords: Set())\n    assert(frequencies3 == [\"no\": 1, \"stopwords\": 1, \"here\": 1])\n    assert(mostCommonWord(frequencies3) == \"no\")\n}\n\ntestWordFrequencyFunctions()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// assignTimeSlots assigns time slots to positions based on the given maximum slots for each position.\n// For each position, it finds the smallest time slot that is a multiple of the position number and does not exceed the maximum slot for that position.\n// If no such time slot is found, it assigns -1 to that position.\nfunc assignTimeSlots(testCases: [[Int]]) -> [[Int]] {\n    var results: [[Int]] = []\n    for caseData in testCases {\n        let n = caseData[0]\n        let maxSlots = Array(caseData[1...])\n        var assignment: [Int] = []\n        for (index, maxSlot) in maxSlots.enumerated() {\n            let pos = index + 1\n            var found = false\n            var timeSlot = pos\n            while timeSlot <= maxSlot {\n                if timeSlot % pos == 0 {\n                    assignment.append(timeSlot)\n                    found = true\n                    break\n                }\n                timeSlot += pos\n            }\n            if !found {\n                assignment.append(-1)\n            }\n        }\n        results.append(assignment)\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Test case 1: [3, 5, 7, 9]\nAssignments: [1, 2, 3]\nTest case 2: [2, 3, 4]\nAssignments: [1, 2]\nTest case 3: [1, 10]\nAssignments: [1]", "task_id": 3656, "assertions": "func testAssignTimeSlots() {\n    let testCases: [[[Int]]] = [\n        [[3, 5, 7, 9]],  // Test case 1\n        [[2, 3, 4]],     // Test case 2\n        [[1, 10]]        // Test case 3\n    ]\n    \n    let expectedResults: [[Int]] = [\n        [1, 2, 3],  // Expected for test case 1\n        [1, 2],     // Expected for test case 2\n        [1]         // Expected for test case 3\n    ]\n    \n    for (index, testCase) in testCases.enumerated() {\n        let result = assignTimeSlots(testCases: testCase)\n        assert(result[0] == expectedResults[index], \n               \"Test case \\(index + 1) failed. Expected \\(expectedResults[index]), got \\(result[0])\")\n    }\n}\n\ntestAssignTimeSlots()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testAssignTimeSlots() {\n    let testCases: [[[Int]]] = [\n        [[3, 5, 7, 9]],  // Test case 1\n        [[2, 3, 4]],     // Test case 2\n        [[1, 10]]        // Test case 3\n    ]\n    \n    let expectedResults: [[Int]] = [\n        [1, 2, 3],  // Expected for test case 1\n        [1, 2],     // Expected for test case 2\n        [1]         // Expected for test case 3\n    ]\n    \n    for (index, testCase) in testCases.enumerated() {\n        let result = assignTimeSlots(testCases: testCase)\n        assert(result[0] == expectedResults[index], \n               \"Test case \\(index + 1) failed. Expected \\(expectedResults[index]), got \\(result[0])\")\n    }\n}\n\ntestAssignTimeSlots()", "output": "assignTimeSlots"}, "all_code": "// assignTimeSlots assigns time slots to positions based on the given maximum slots for each position.\n// For each position, it finds the smallest time slot that is a multiple of the position number and does not exceed the maximum slot for that position.\n// If no such time slot is found, it assigns -1 to that position.\nfunc assignTimeSlots(testCases: [[Int]]) -> [[Int]] {\n    var results: [[Int]] = []\n    for caseData in testCases {\n        let n = caseData[0]\n        let maxSlots = Array(caseData[1...])\n        var assignment: [Int] = []\n        for (index, maxSlot) in maxSlots.enumerated() {\n            let pos = index + 1\n            var found = false\n            var timeSlot = pos\n            while timeSlot <= maxSlot {\n                if timeSlot % pos == 0 {\n                    assignment.append(timeSlot)\n                    found = true\n                    break\n                }\n                timeSlot += pos\n            }\n            if !found {\n                assignment.append(-1)\n            }\n        }\n        results.append(assignment)\n    }\n    return results\n}\nfunc testAssignTimeSlots() {\n    let testCases: [[[Int]]] = [\n        [[3, 5, 7, 9]],  // Test case 1\n        [[2, 3, 4]],     // Test case 2\n        [[1, 10]]        // Test case 3\n    ]\n    \n    let expectedResults: [[Int]] = [\n        [1, 2, 3],  // Expected for test case 1\n        [1, 2],     // Expected for test case 2\n        [1]         // Expected for test case 3\n    ]\n    \n    for (index, testCase) in testCases.enumerated() {\n        let result = assignTimeSlots(testCases: testCase)\n        assert(result[0] == expectedResults[index], \n               \"Test case \\(index + 1) failed. Expected \\(expectedResults[index]), got \\(result[0])\")\n    }\n}\n\ntestAssignTimeSlots()", "exec_outcome": "PASSED"}
{"code": "// cumulativeGreaterSum calculates the cumulative sum of elements in an array that are greater than their immediate predecessor.\n// The function iterates through the array starting from the second element, comparing each element with its predecessor.\n// If the current element is greater, it adds the element to the cumulative sum and appends the sum to the result array.\n// If the input array is empty, the function returns an empty array.\nfunc cumulativeGreaterSum(nums: [Int]) -> [Int] {\n    if nums.isEmpty {\n        return []\n    }\n    \n    var cumulativeSum = 0\n    var result = [Int]()\n    \n    for i in 1..<nums.count {\n        if nums[i] > nums[i - 1] {\n            cumulativeSum += nums[i]\n            result.append(cumulativeSum)\n        }\n    }\n    \n    return result\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nCumulative Sums: [2, 5, 9]\nInput: [4, 3, 2, 1]\nCumulative Sums: []\nInput: [1, 3, 2, 4]\nCumulative Sums: [3, 7]\nInput: [1, 1, 1, 1]\nCumulative Sums: []\nInput: []\nCumulative Sums: []\nInput: [5]\nCumulative Sums: []", "task_id": 13299, "assertions": "func testCumulativeGreaterSum() {\n    assert(cumulativeGreaterSum(nums: [1, 2, 3, 4]) == [2, 5, 9])\n    assert(cumulativeGreaterSum(nums: [4, 3, 2, 1]) == [])\n    assert(cumulativeGreaterSum(nums: [1, 3, 2, 4]) == [3, 7])\n    assert(cumulativeGreaterSum(nums: [1, 1, 1, 1]) == [])\n    assert(cumulativeGreaterSum(nums: []) == [])\n    assert(cumulativeGreaterSum(nums: [5]) == [])\n}\n\ntestCumulativeGreaterSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCumulativeGreaterSum() {\n    assert(cumulativeGreaterSum(nums: [1, 2, 3, 4]) == [2, 5, 9])\n    assert(cumulativeGreaterSum(nums: [4, 3, 2, 1]) == [])\n    assert(cumulativeGreaterSum(nums: [1, 3, 2, 4]) == [3, 7])\n    assert(cumulativeGreaterSum(nums: [1, 1, 1, 1]) == [])\n    assert(cumulativeGreaterSum(nums: []) == [])\n    assert(cumulativeGreaterSum(nums: [5]) == [])\n}\n\ntestCumulativeGreaterSum()", "output": "cumulativeGreaterSum"}, "all_code": "// cumulativeGreaterSum calculates the cumulative sum of elements in an array that are greater than their immediate predecessor.\n// The function iterates through the array starting from the second element, comparing each element with its predecessor.\n// If the current element is greater, it adds the element to the cumulative sum and appends the sum to the result array.\n// If the input array is empty, the function returns an empty array.\nfunc cumulativeGreaterSum(nums: [Int]) -> [Int] {\n    if nums.isEmpty {\n        return []\n    }\n    \n    var cumulativeSum = 0\n    var result = [Int]()\n    \n    for i in 1..<nums.count {\n        if nums[i] > nums[i - 1] {\n            cumulativeSum += nums[i]\n            result.append(cumulativeSum)\n        }\n    }\n    \n    return result\n}\nfunc testCumulativeGreaterSum() {\n    assert(cumulativeGreaterSum(nums: [1, 2, 3, 4]) == [2, 5, 9])\n    assert(cumulativeGreaterSum(nums: [4, 3, 2, 1]) == [])\n    assert(cumulativeGreaterSum(nums: [1, 3, 2, 4]) == [3, 7])\n    assert(cumulativeGreaterSum(nums: [1, 1, 1, 1]) == [])\n    assert(cumulativeGreaterSum(nums: []) == [])\n    assert(cumulativeGreaterSum(nums: [5]) == [])\n}\n\ntestCumulativeGreaterSum()", "exec_outcome": "PASSED"}
{"code": "// longestOnesSubarray calculates the length of the longest continuous subarray of 1's\n// in a binary array that can be achieved by flipping at most k 0's to 1's.\n// The function uses a sliding window approach to efficiently track the maximum subarray length.\nfunc longestOnesSubarray(_ nums: [Int], _ k: Int) -> Int {\n    var left = 0\n    var maxOnes = 0\n    var zeroCount = 0\n    \n    for right in 0..<nums.count {\n        if nums[right] == 0 {\n            zeroCount += 1\n        }\n        \n        while zeroCount > k {\n            if nums[left] == 0 {\n                zeroCount -= 1\n            }\n            left += 1\n        }\n        \n        maxOnes = max(maxOnes, right - left + 1)\n    }\n    \n    return maxOnes\n}", "test_cases": "", "test_case_results": "Input array: [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], k: 2\nLongest subarray length: 6\nInput array: [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], k: 3\nLongest subarray length: 10\nInput array: [1, 0, 1, 0, 1], k: 1\nLongest subarray length: 3\nInput array: [1, 1, 1, 0, 0, 0, 1, 1, 1, 1], k: 0\nLongest subarray length: 4", "task_id": 24150, "assertions": "func testLongestOnesSubarray() {\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2) == 6)\n    assert(longestOnesSubarray([0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], 3) == 10)\n    assert(longestOnesSubarray([1, 0, 1, 0, 1], 1) == 3)\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1], 0) == 4)\n}\n\ntestLongestOnesSubarray()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLongestOnesSubarray() {\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2) == 6)\n    assert(longestOnesSubarray([0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], 3) == 10)\n    assert(longestOnesSubarray([1, 0, 1, 0, 1], 1) == 3)\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1], 0) == 4)\n}\n\ntestLongestOnesSubarray()", "output": "longestOnesSubarray"}, "all_code": "// longestOnesSubarray calculates the length of the longest continuous subarray of 1's\n// in a binary array that can be achieved by flipping at most k 0's to 1's.\n// The function uses a sliding window approach to efficiently track the maximum subarray length.\nfunc longestOnesSubarray(_ nums: [Int], _ k: Int) -> Int {\n    var left = 0\n    var maxOnes = 0\n    var zeroCount = 0\n    \n    for right in 0..<nums.count {\n        if nums[right] == 0 {\n            zeroCount += 1\n        }\n        \n        while zeroCount > k {\n            if nums[left] == 0 {\n                zeroCount -= 1\n            }\n            left += 1\n        }\n        \n        maxOnes = max(maxOnes, right - left + 1)\n    }\n    \n    return maxOnes\n}\nfunc testLongestOnesSubarray() {\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2) == 6)\n    assert(longestOnesSubarray([0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], 3) == 10)\n    assert(longestOnesSubarray([1, 0, 1, 0, 1], 1) == 3)\n    assert(longestOnesSubarray([1, 1, 1, 0, 0, 0, 1, 1, 1, 1], 0) == 4)\n}\n\ntestLongestOnesSubarray()", "exec_outcome": "PASSED"}
{"code": "// canMeasureExactly checks if it's possible to measure exactly 'd' liters using any two of the three jugs with capacities 'a', 'b', and 'c'.\n// The function uses the greatest common divisor (gcd) to determine if 'd' can be measured by any pair of jugs.\nfunc canMeasureExactly(a: Int, b: Int, c: Int, d: Int) -> String {\n    // canMeasureWithTwoJugs checks if 'd' liters can be measured using two jugs with capacities 'x' and 'y'.\n    func canMeasureWithTwoJugs(x: Int, y: Int, d: Int) -> Bool {\n        if d > max(x, y) {\n            return false\n        }\n        return d % gcd(x, y) == 0\n    }\n    \n    // Check all possible pairs of jugs to see if 'd' can be measured.\n    if canMeasureWithTwoJugs(x: a, y: b, d: d) ||\n       canMeasureWithTwoJugs(x: a, y: c, d: d) ||\n       canMeasureWithTwoJugs(x: b, y: c, d: d) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var x = a\n    var y = b\n    while y != 0 {\n        let temp = y\n        y = x % y\n        x = temp\n    }\n    return x\n}\n\n// solve processes multiple test cases and returns an array of results indicating whether 'd' can be measured for each case.\nfunc solve(numCases: Int, testCases: [(Int, Int, Int, Int)]) -> [String] {\n    var results = [String]()\n    for i in 0..<numCases {\n        let (a, b, c, d) = testCases[i]\n        results.append(canMeasureExactly(a: a, b: b, c: c, d: d))\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Test case 1: Jugs 3, 5, 7, Target 1\nYES\nTest case 2: Jugs 4, 6, 8, Target 3\nNO\nTest case 3: Jugs 2, 3, 5, Target 4\nYES\nTest case 4: Jugs 10, 15, 20, Target 5\nYES", "task_id": 12619, "assertions": "func testCanMeasureExactly() {\n    assert(canMeasureExactly(a: 3, b: 5, c: 7, d: 1) == \"YES\")\n    assert(canMeasureExactly(a: 4, b: 6, c: 8, d: 3) == \"NO\")\n    assert(canMeasureExactly(a: 2, b: 3, c: 5, d: 4) == \"YES\")\n    assert(canMeasureExactly(a: 10, b: 15, c: 20, d: 5) == \"YES\")\n}\n\ntestCanMeasureExactly()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCanMeasureExactly() {\n    assert(canMeasureExactly(a: 3, b: 5, c: 7, d: 1) == \"YES\")\n    assert(canMeasureExactly(a: 4, b: 6, c: 8, d: 3) == \"NO\")\n    assert(canMeasureExactly(a: 2, b: 3, c: 5, d: 4) == \"YES\")\n    assert(canMeasureExactly(a: 10, b: 15, c: 20, d: 5) == \"YES\")\n}\n\ntestCanMeasureExactly()", "output": "canMeasureExactly"}, "all_code": "import Foundation\nimport Glibc\n\n// canMeasureExactly checks if it's possible to measure exactly 'd' liters using any two of the three jugs with capacities 'a', 'b', and 'c'.\n// The function uses the greatest common divisor (gcd) to determine if 'd' can be measured by any pair of jugs.\nfunc canMeasureExactly(a: Int, b: Int, c: Int, d: Int) -> String {\n    // canMeasureWithTwoJugs checks if 'd' liters can be measured using two jugs with capacities 'x' and 'y'.\n    func canMeasureWithTwoJugs(x: Int, y: Int, d: Int) -> Bool {\n        if d > max(x, y) {\n            return false\n        }\n        return d % gcd(x, y) == 0\n    }\n    \n    // Check all possible pairs of jugs to see if 'd' can be measured.\n    if canMeasureWithTwoJugs(x: a, y: b, d: d) ||\n       canMeasureWithTwoJugs(x: a, y: c, d: d) ||\n       canMeasureWithTwoJugs(x: b, y: c, d: d) {\n        return \"YES\"\n    } else {\n        return \"NO\"\n    }\n}\n\n// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var x = a\n    var y = b\n    while y != 0 {\n        let temp = y\n        y = x % y\n        x = temp\n    }\n    return x\n}\n\n// solve processes multiple test cases and returns an array of results indicating whether 'd' can be measured for each case.\nfunc solve(numCases: Int, testCases: [(Int, Int, Int, Int)]) -> [String] {\n    var results = [String]()\n    for i in 0..<numCases {\n        let (a, b, c, d) = testCases[i]\n        results.append(canMeasureExactly(a: a, b: b, c: c, d: d))\n    }\n    return results\n}\nfunc testCanMeasureExactly() {\n    assert(canMeasureExactly(a: 3, b: 5, c: 7, d: 1) == \"YES\")\n    assert(canMeasureExactly(a: 4, b: 6, c: 8, d: 3) == \"NO\")\n    assert(canMeasureExactly(a: 2, b: 3, c: 5, d: 4) == \"YES\")\n    assert(canMeasureExactly(a: 10, b: 15, c: 20, d: 5) == \"YES\")\n}\n\ntestCanMeasureExactly()", "exec_outcome": "PASSED"}
{"code": "func countUniqueAddresses(invitations: [(String, String)], queries: [String]) -> [Int] {\n    var addressMap = [String: Set<Int>]()\n    var addresses = [Int: String]()\n    \n    // Initialize addressMap and addresses with the initial invitations\n    for (idx, invitation) in invitations.enumerated() {\n        let (_, address) = invitation\n        addressMap[address, default: []].insert(idx)\n        addresses[idx] = address\n    }\n    \n    var results = [Int]()\n    \n    for query in queries {\n        let parts = query.split(separator: \" \")\n        if parts.isEmpty { continue }\n        \n        let command = String(parts[0])\n        if command == \"c\" {\n            // Count the number of unique addresses\n            results.append(addressMap.count)\n        } else if command == \"u\" && parts.count >= 3 {\n            // Update the address for a specific invitation\n            let idx = Int(parts[1])! - 1\n            let newAddress = String(parts[2])\n            \n            if let oldAddress = addresses[idx] {\n                // Remove the index from the old address in addressMap\n                addressMap[oldAddress]?.remove(idx)\n                if addressMap[oldAddress]?.isEmpty ?? false {\n                    addressMap.removeValue(forKey: oldAddress)\n                }\n                \n                // Add the index to the new address in addressMap\n                addressMap[newAddress, default: []].insert(idx)\n                addresses[idx] = newAddress\n            }\n        }\n    }\n    \n    return results\n}", "test_cases": "", "test_case_results": "Test Invitations: [(\"Alice\", \"123 Main St\"), (\"Bob\", \"456 Elm St\"), (\"Charlie\", \"123 Main St\"), (\"David\", \"789 Oak St\")]\nTest Queries: [\"c\", \"u 2 123 Main St\", \"c\", \"u 1 789 Oak St\", \"c\"]\nResults: [3, 3, 4]", "task_id": 26167, "assertions": "func testCountUniqueAddresses() {\n    let testInvitations = [\n        (\"Alice\", \"123 Main St\"),\n        (\"Bob\", \"456 Elm St\"),\n        (\"Charlie\", \"123 Main St\"),\n        (\"David\", \"789 Oak St\")\n    ]\n    \n    let testQueries = [\n        \"c\",  // Count unique addresses (should be 3)\n        \"u 2 123 Main St\",  // Update Bob's address to \"123 Main St\"\n        \"c\",  // Count unique addresses (should be 2)\n        \"u 1 789 Oak St\",  // Update Alice's address to \"789 Oak St\"\n        \"c\"   // Count unique addresses (should be 2)\n    ]\n    \n    let results = countUniqueAddresses(invitations: testInvitations, queries: testQueries)\n    assert(results == [3, 2, 2], \"Test failed: Expected [3, 2, 2], got \\(results)\")\n}\n\ntestCountUniqueAddresses()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountUniqueAddresses() {\n    let testInvitations = [\n        (\"Alice\", \"123 Main St\"),\n        (\"Bob\", \"456 Elm St\"),\n        (\"Charlie\", \"123 Main St\"),\n        (\"David\", \"789 Oak St\")\n    ]\n    \n    let testQueries = [\n        \"c\",  // Count unique addresses (should be 3)\n        \"u 2 123 Main St\",  // Update Bob's address to \"123 Main St\"\n        \"c\",  // Count unique addresses (should be 2)\n        \"u 1 789 Oak St\",  // Update Alice's address to \"789 Oak St\"\n        \"c\"   // Count unique addresses (should be 2)\n    ]\n    \n    let results = countUniqueAddresses(invitations: testInvitations, queries: testQueries)\n    assert(results == [3, 2, 2], \"Test failed: Expected [3, 2, 2], got \\(results)\")\n}\n\ntestCountUniqueAddresses()", "output": "countUniqueAddresses"}, "all_code": "func countUniqueAddresses(invitations: [(String, String)], queries: [String]) -> [Int] {\n    var addressMap = [String: Set<Int>]()\n    var addresses = [Int: String]()\n    \n    // Initialize addressMap and addresses with the initial invitations\n    for (idx, invitation) in invitations.enumerated() {\n        let (_, address) = invitation\n        addressMap[address, default: []].insert(idx)\n        addresses[idx] = address\n    }\n    \n    var results = [Int]()\n    \n    for query in queries {\n        let parts = query.split(separator: \" \")\n        if parts.isEmpty { continue }\n        \n        let command = String(parts[0])\n        if command == \"c\" {\n            // Count the number of unique addresses\n            results.append(addressMap.count)\n        } else if command == \"u\" && parts.count >= 3 {\n            // Update the address for a specific invitation\n            let idx = Int(parts[1])! - 1\n            let newAddress = String(parts[2])\n            \n            if let oldAddress = addresses[idx] {\n                // Remove the index from the old address in addressMap\n                addressMap[oldAddress]?.remove(idx)\n                if addressMap[oldAddress]?.isEmpty ?? false {\n                    addressMap.removeValue(forKey: oldAddress)\n                }\n                \n                // Add the index to the new address in addressMap\n                addressMap[newAddress, default: []].insert(idx)\n                addresses[idx] = newAddress\n            }\n        }\n    }\n    \n    return results\n}\nfunc testCountUniqueAddresses() {\n    let testInvitations = [\n        (\"Alice\", \"123 Main St\"),\n        (\"Bob\", \"456 Elm St\"),\n        (\"Charlie\", \"123 Main St\"),\n        (\"David\", \"789 Oak St\")\n    ]\n    \n    let testQueries = [\n        \"c\",  // Count unique addresses (should be 3)\n        \"u 2 123 Main St\",  // Update Bob's address to \"123 Main St\"\n        \"c\",  // Count unique addresses (should be 2)\n        \"u 1 789 Oak St\",  // Update Alice's address to \"789 Oak St\"\n        \"c\"   // Count unique addresses (should be 2)\n    ]\n    \n    let results = countUniqueAddresses(invitations: testInvitations, queries: testQueries)\n    assert(results == [3, 2, 2], \"Test failed: Expected [3, 2, 2], got \\(results)\")\n}\n\ntestCountUniqueAddresses()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "import Foundation\n\n// analyzeWords analyzes the given text passage and returns the count of each unique word in the passage.\n// The function is case-insensitive and ignores punctuation.\n// - Parameter passage: A string variable containing a block of text.\n// - Returns: A dictionary where keys are unique words (in lowercase) and values are their counts.\nfunc analyzeWords(passage: String) -> [String: Int] {\n    // Normalize the passage: convert to lowercase and remove punctuation using regex\n    let lowercasedPassage = passage.lowercased()\n    let pattern = \"\\\\b\\\\w+\\\\b\"\n    guard let regex = try? NSRegularExpression(pattern: pattern) else {\n        return [:]\n    }\n    let matches = regex.matches(in: lowercasedPassage, range: NSRange(lowercasedPassage.startIndex..., in: lowercasedPassage))\n    let words = matches.map { match in\n        String(lowercasedPassage[Range(match.range, in: lowercasedPassage)!])\n    }\n    \n    // Creating a dictionary to store word counts\n    var wordCount = [String: Int]()\n    \n    // Count the frequency of each word\n    for word in words {\n        wordCount[word] = (wordCount[word] ?? 0) + 1\n    }\n    \n    return wordCount\n}", "test_cases": "", "test_case_results": "Input: \"Hello, world! Hello Swift!\"\nWord counts: [\"hello\": 2, \"swift\": 1, \"world\": 1]\nInput: \"The quick brown fox jumps over the lazy dog.\"\nWord counts: [\"lazy\": 1, \"dog\": 1, \"over\": 1, \"fox\": 1, \"the\": 2, \"quick\": 1, \"brown\": 1, \"jumps\": 1]\nInput: \"To be, or not to be, that is the question.\"\nWord counts: [\"be\": 2, \"to\": 2, \"is\": 1, \"or\": 1, \"that\": 1, \"not\": 1, \"the\": 1, \"question\": 1]", "task_id": 22612, "assertions": "func testAnalyzeWords() {\n    assert(analyzeWords(passage: \"Hello, world! Hello Swift!\") == [\"hello\": 2, \"swift\": 1, \"world\": 1])\n    assert(analyzeWords(passage: \"The quick brown fox jumps over the lazy dog.\") == [\"lazy\": 1, \"dog\": 1, \"over\": 1, \"fox\": 1, \"the\": 2, \"quick\": 1, \"brown\": 1, \"jumps\": 1])\n    assert(analyzeWords(passage: \"To be, or not to be, that is the question.\") == [\"be\": 2, \"to\": 2, \"is\": 1, \"or\": 1, \"that\": 1, \"not\": 1, \"the\": 1, \"question\": 1])\n}\n\ntestAnalyzeWords()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testAnalyzeWords() {\n    assert(analyzeWords(passage: \"Hello, world! Hello Swift!\") == [\"hello\": 2, \"swift\": 1, \"world\": 1])\n    assert(analyzeWords(passage: \"The quick brown fox jumps over the lazy dog.\") == [\"lazy\": 1, \"dog\": 1, \"over\": 1, \"fox\": 1, \"the\": 2, \"quick\": 1, \"brown\": 1, \"jumps\": 1])\n    assert(analyzeWords(passage: \"To be, or not to be, that is the question.\") == [\"be\": 2, \"to\": 2, \"is\": 1, \"or\": 1, \"that\": 1, \"not\": 1, \"the\": 1, \"question\": 1])\n}\n\ntestAnalyzeWords()", "output": "analyzeWords"}, "all_code": "import Glibc\n\nimport Foundation\n\n// analyzeWords analyzes the given text passage and returns the count of each unique word in the passage.\n// The function is case-insensitive and ignores punctuation.\n// - Parameter passage: A string variable containing a block of text.\n// - Returns: A dictionary where keys are unique words (in lowercase) and values are their counts.\nfunc analyzeWords(passage: String) -> [String: Int] {\n    // Normalize the passage: convert to lowercase and remove punctuation using regex\n    let lowercasedPassage = passage.lowercased()\n    let pattern = \"\\\\b\\\\w+\\\\b\"\n    guard let regex = try? NSRegularExpression(pattern: pattern) else {\n        return [:]\n    }\n    let matches = regex.matches(in: lowercasedPassage, range: NSRange(lowercasedPassage.startIndex..., in: lowercasedPassage))\n    let words = matches.map { match in\n        String(lowercasedPassage[Range(match.range, in: lowercasedPassage)!])\n    }\n    \n    // Creating a dictionary to store word counts\n    var wordCount = [String: Int]()\n    \n    // Count the frequency of each word\n    for word in words {\n        wordCount[word] = (wordCount[word] ?? 0) + 1\n    }\n    \n    return wordCount\n}\nfunc testAnalyzeWords() {\n    assert(analyzeWords(passage: \"Hello, world! Hello Swift!\") == [\"hello\": 2, \"swift\": 1, \"world\": 1])\n    assert(analyzeWords(passage: \"The quick brown fox jumps over the lazy dog.\") == [\"lazy\": 1, \"dog\": 1, \"over\": 1, \"fox\": 1, \"the\": 2, \"quick\": 1, \"brown\": 1, \"jumps\": 1])\n    assert(analyzeWords(passage: \"To be, or not to be, that is the question.\") == [\"be\": 2, \"to\": 2, \"is\": 1, \"or\": 1, \"that\": 1, \"not\": 1, \"the\": 1, \"question\": 1])\n}\n\ntestAnalyzeWords()", "exec_outcome": "PASSED"}
{"code": "// maxNonOverlappingActions calculates the maximum number of non-overlapping actions in a timeline.\n// The function sorts the actions by their end time and then iterates through them to count non-overlapping actions.\n// Parameters:\n//   - N: The number of actions (unused in the function, but kept for consistency with the original code).\n//   - actions: An array of tuples where each tuple contains two integers (start, end) representing the start and end time of an action.\n// Returns:\n//   - An integer representing the maximum number of non-overlapping actions.\nfunc maxNonOverlappingActions(N: Int, actions: [(Int, Int)]) -> Int {\n    // Sort actions by their end time\n    let sortedActions = actions.sorted { $0.1 < $1.1 }\n    \n    var count = 0\n    var endTime = 0\n    \n    for (start, end) in sortedActions {\n        if start >= endTime {\n            count += 1\n            endTime = end\n        }\n    }\n    \n    return count\n}", "test_cases": "", "test_case_results": "Input N: 3, Actions: [(1, 3), (2, 4), (3, 5)]\nMaximum non-overlapping actions: 2\nInput N: 4, Actions: [(1, 2), (3, 4), (5, 6), (7, 8)]\nMaximum non-overlapping actions: 4\nInput N: 2, Actions: [(1, 5), (2, 3)]\nMaximum non-overlapping actions: 1\nInput N: 0, Actions: []\nMaximum non-overlapping actions: 0", "task_id": 12264, "assertions": "func testMaxNonOverlappingActions() {\n    assert(maxNonOverlappingActions(N: 3, actions: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(maxNonOverlappingActions(N: 4, actions: [(1, 2), (3, 4), (5, 6), (7, 8)]) == 4)\n    assert(maxNonOverlappingActions(N: 2, actions: [(1, 5), (2, 3)]) == 1)\n    assert(maxNonOverlappingActions(N: 0, actions: []) == 0)\n}\n\ntestMaxNonOverlappingActions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaxNonOverlappingActions() {\n    assert(maxNonOverlappingActions(N: 3, actions: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(maxNonOverlappingActions(N: 4, actions: [(1, 2), (3, 4), (5, 6), (7, 8)]) == 4)\n    assert(maxNonOverlappingActions(N: 2, actions: [(1, 5), (2, 3)]) == 1)\n    assert(maxNonOverlappingActions(N: 0, actions: []) == 0)\n}\n\ntestMaxNonOverlappingActions()", "output": "maxNonOverlappingActions"}, "all_code": "// maxNonOverlappingActions calculates the maximum number of non-overlapping actions in a timeline.\n// The function sorts the actions by their end time and then iterates through them to count non-overlapping actions.\n// Parameters:\n//   - N: The number of actions (unused in the function, but kept for consistency with the original code).\n//   - actions: An array of tuples where each tuple contains two integers (start, end) representing the start and end time of an action.\n// Returns:\n//   - An integer representing the maximum number of non-overlapping actions.\nfunc maxNonOverlappingActions(N: Int, actions: [(Int, Int)]) -> Int {\n    // Sort actions by their end time\n    let sortedActions = actions.sorted { $0.1 < $1.1 }\n    \n    var count = 0\n    var endTime = 0\n    \n    for (start, end) in sortedActions {\n        if start >= endTime {\n            count += 1\n            endTime = end\n        }\n    }\n    \n    return count\n}\nfunc testMaxNonOverlappingActions() {\n    assert(maxNonOverlappingActions(N: 3, actions: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(maxNonOverlappingActions(N: 4, actions: [(1, 2), (3, 4), (5, 6), (7, 8)]) == 4)\n    assert(maxNonOverlappingActions(N: 2, actions: [(1, 5), (2, 3)]) == 1)\n    assert(maxNonOverlappingActions(N: 0, actions: []) == 0)\n}\n\ntestMaxNonOverlappingActions()", "exec_outcome": "PASSED"}
{"code": "// bitonicMerge is a helper function for the bitonic sort algorithm.\n// It recursively merges two halves of an array in either ascending or descending order based on the given direction.\n// - Parameters:\n//   - arr: The array to be merged.\n//   - low: The starting index of the subarray to be merged.\n//   - cnt: The number of elements in the subarray to be merged.\n//   - direction: A boolean indicating the sorting direction (true for ascending, false for descending).\nfunc bitonicMerge(arr: inout [Int], low: Int, cnt: Int, direction: Bool) {\n    if cnt > 1 {\n        let k = cnt / 2\n        for i in low..<(low + k) {\n            if (direction && arr[i] > arr[i + k]) || (!direction && arr[i] < arr[i + k]) {\n                arr.swapAt(i, i + k)\n            }\n        }\n        bitonicMerge(arr: &arr, low: low, cnt: k, direction: direction)\n        bitonicMerge(arr: &arr, low: low + k, cnt: k, direction: direction)\n    }\n}\n\n// bitonicSortRec is a recursive function that sorts a subarray in bitonic order.\n// It divides the array into two halves, sorts the first half in ascending order,\n// the second half in descending order, and then merges them.\n// - Parameters:\n//   - arr: The array to be sorted.\n//   - low: The starting index of the subarray to be sorted.\n//   - cnt: The number of elements in the subarray to be sorted.\n//   - direction: A boolean indicating the sorting direction (true for ascending, false for descending).\nfunc bitonicSortRec(arr: inout [Int], low: Int, cnt: Int, direction: Bool) {\n    if cnt > 1 {\n        let k = cnt / 2\n        bitonicSortRec(arr: &arr, low: low, cnt: k, direction: true)\n        bitonicSortRec(arr: &arr, low: low + k, cnt: k, direction: false)\n        bitonicMerge(arr: &arr, low: low, cnt: cnt, direction: direction)\n    }\n}\n\n// bitonicSort sorts an array using the bitonic sort algorithm.\n// - Parameters:\n//   - arr: The array to be sorted.\n//   - reverse: A boolean indicating whether to sort in descending order (default is false for ascending order).\n// - Returns: The sorted array.\nfunc bitonicSort(arr: [Int], reverse: Bool = false) -> [Int] {\n    var sortedArr = arr\n    bitonicSortRec(arr: &sortedArr, low: 0, cnt: sortedArr.count, direction: !reverse)\n    return sortedArr\n}", "test_cases": "", "test_case_results": "Input: [3, 7, 4, 8, 6, 2, 1, 5]\nSorted (ascending): [1, 2, 3, 4, 5, 6, 7, 8]\nSorted (descending): [8, 7, 6, 5, 4, 3, 2, 1]\nInput: [10, 20, 30, 40, 50, 60, 70, 80]\nSorted (ascending): [10, 20, 30, 40, 50, 60, 70, 80]\nSorted (descending): [80, 70, 60, 50, 40, 30, 20, 10]\nInput: [5, 4, 3, 2, 1]\nSorted (ascending): [2, 3, 4, 5, 1]\nSorted (descending): [5, 4, 3, 2, 1]\nInput: [1, 2, 3, 4, 5]\nSorted (ascending): [1, 2, 3, 4, 5]\nSorted (descending): [4, 3, 2, 1, 5]\nInput: [1]\nSorted (ascending): [1]\nSorted (descending): [1]", "task_id": 27047, "assertions": "func testBitonicSort() {\n    let testCases: [([Int], [Int], [Int])] = [\n        ([3, 7, 4, 8, 6, 2, 1, 5], [1, 2, 3, 4, 5, 6, 7, 8], [8, 7, 6, 5, 4, 3, 2, 1]),\n        ([10, 20, 30, 40, 50, 60, 70, 80], [10, 20, 30, 40, 50, 60, 70, 80], [80, 70, 60, 50, 40, 30, 20, 10]),\n        ([5, 4, 3, 2, 1], [2, 3, 4, 5, 1], [5, 4, 3, 2, 1]),\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [4, 3, 2, 1, 5]),\n        ([1], [1], [1])\n    ]\n    \n    for (input, expectedAscending, expectedDescending) in testCases {\n        let sortedAscending = bitonicSort(arr: input)\n        assert(sortedAscending == expectedAscending, \"Failed for input: \\(input). Expected: \\(expectedAscending), Got: \\(sortedAscending)\")\n        \n        let sortedDescending = bitonicSort(arr: input, reverse: true)\n        assert(sortedDescending == expectedDescending, \"Failed for input: \\(input). Expected: \\(expectedDescending), Got: \\(sortedDescending)\")\n    }\n}\n\ntestBitonicSort()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testBitonicSort() {\n    let testCases: [([Int], [Int], [Int])] = [\n        ([3, 7, 4, 8, 6, 2, 1, 5], [1, 2, 3, 4, 5, 6, 7, 8], [8, 7, 6, 5, 4, 3, 2, 1]),\n        ([10, 20, 30, 40, 50, 60, 70, 80], [10, 20, 30, 40, 50, 60, 70, 80], [80, 70, 60, 50, 40, 30, 20, 10]),\n        ([5, 4, 3, 2, 1], [2, 3, 4, 5, 1], [5, 4, 3, 2, 1]),\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [4, 3, 2, 1, 5]),\n        ([1], [1], [1])\n    ]\n    \n    for (input, expectedAscending, expectedDescending) in testCases {\n        let sortedAscending = bitonicSort(arr: input)\n        assert(sortedAscending == expectedAscending, \"Failed for input: \\(input). Expected: \\(expectedAscending), Got: \\(sortedAscending)\")\n        \n        let sortedDescending = bitonicSort(arr: input, reverse: true)\n        assert(sortedDescending == expectedDescending, \"Failed for input: \\(input). Expected: \\(expectedDescending), Got: \\(sortedDescending)\")\n    }\n}\n\ntestBitonicSort()", "output": "bitonicSort"}, "all_code": "import Foundation\nimport Glibc\n\n// bitonicMerge is a helper function for the bitonic sort algorithm.\n// It recursively merges two halves of an array in either ascending or descending order based on the given direction.\n// - Parameters:\n//   - arr: The array to be merged.\n//   - low: The starting index of the subarray to be merged.\n//   - cnt: The number of elements in the subarray to be merged.\n//   - direction: A boolean indicating the sorting direction (true for ascending, false for descending).\nfunc bitonicMerge(arr: inout [Int], low: Int, cnt: Int, direction: Bool) {\n    if cnt > 1 {\n        let k = cnt / 2\n        for i in low..<(low + k) {\n            if (direction && arr[i] > arr[i + k]) || (!direction && arr[i] < arr[i + k]) {\n                arr.swapAt(i, i + k)\n            }\n        }\n        bitonicMerge(arr: &arr, low: low, cnt: k, direction: direction)\n        bitonicMerge(arr: &arr, low: low + k, cnt: k, direction: direction)\n    }\n}\n\n// bitonicSortRec is a recursive function that sorts a subarray in bitonic order.\n// It divides the array into two halves, sorts the first half in ascending order,\n// the second half in descending order, and then merges them.\n// - Parameters:\n//   - arr: The array to be sorted.\n//   - low: The starting index of the subarray to be sorted.\n//   - cnt: The number of elements in the subarray to be sorted.\n//   - direction: A boolean indicating the sorting direction (true for ascending, false for descending).\nfunc bitonicSortRec(arr: inout [Int], low: Int, cnt: Int, direction: Bool) {\n    if cnt > 1 {\n        let k = cnt / 2\n        bitonicSortRec(arr: &arr, low: low, cnt: k, direction: true)\n        bitonicSortRec(arr: &arr, low: low + k, cnt: k, direction: false)\n        bitonicMerge(arr: &arr, low: low, cnt: cnt, direction: direction)\n    }\n}\n\n// bitonicSort sorts an array using the bitonic sort algorithm.\n// - Parameters:\n//   - arr: The array to be sorted.\n//   - reverse: A boolean indicating whether to sort in descending order (default is false for ascending order).\n// - Returns: The sorted array.\nfunc bitonicSort(arr: [Int], reverse: Bool = false) -> [Int] {\n    var sortedArr = arr\n    bitonicSortRec(arr: &sortedArr, low: 0, cnt: sortedArr.count, direction: !reverse)\n    return sortedArr\n}\nfunc testBitonicSort() {\n    let testCases: [([Int], [Int], [Int])] = [\n        ([3, 7, 4, 8, 6, 2, 1, 5], [1, 2, 3, 4, 5, 6, 7, 8], [8, 7, 6, 5, 4, 3, 2, 1]),\n        ([10, 20, 30, 40, 50, 60, 70, 80], [10, 20, 30, 40, 50, 60, 70, 80], [80, 70, 60, 50, 40, 30, 20, 10]),\n        ([5, 4, 3, 2, 1], [2, 3, 4, 5, 1], [5, 4, 3, 2, 1]),\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [4, 3, 2, 1, 5]),\n        ([1], [1], [1])\n    ]\n    \n    for (input, expectedAscending, expectedDescending) in testCases {\n        let sortedAscending = bitonicSort(arr: input)\n        assert(sortedAscending == expectedAscending, \"Failed for input: \\(input). Expected: \\(expectedAscending), Got: \\(sortedAscending)\")\n        \n        let sortedDescending = bitonicSort(arr: input, reverse: true)\n        assert(sortedDescending == expectedDescending, \"Failed for input: \\(input). Expected: \\(expectedDescending), Got: \\(sortedDescending)\")\n    }\n}\n\ntestBitonicSort()", "exec_outcome": "PASSED"}
{"code": "func longestCommonSubstring(_ s1: String, _ s2: String) -> String {\n    if s1.isEmpty || s2.isEmpty {\n        return \"\"\n    }\n    \n    let m = s1.count\n    let n = s2.count\n    var lcsuff = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\n    var length = 0\n    var endIndexM = 0\n    \n    let s1Array = Array(s1)\n    let s2Array = Array(s2)\n    \n    for i in 0...m {\n        for j in 0...n {\n            if i == 0 || j == 0 {\n                lcsuff[i][j] = 0\n            } else if s1Array[i - 1] == s2Array[j - 1] {\n                lcsuff[i][j] = lcsuff[i - 1][j - 1] + 1\n                if length < lcsuff[i][j] {\n                    length = lcsuff[i][j]\n                    endIndexM = i\n                }\n            } else {\n                lcsuff[i][j] = 0\n            }\n        }\n    }\n    \n    if length == 0 {\n        return \"\"\n    }\n    \n    let startIndex = s1.index(s1.startIndex, offsetBy: endIndexM - length)\n    let endIndex = s1.index(s1.startIndex, offsetBy: endIndexM)\n    return String(s1[startIndex..<endIndex])\n}", "test_cases": "", "test_case_results": "Input: \"abcdef\", \"xbcdyz\"\nLongest common substring: \"bcd\"\nInput: \"hello\", \"world\"\nLongest common substring: \"l\"\nInput: \"programming\", \"program\"\nLongest common substring: \"program\"\nInput: \"\", \"test\"\nLongest common substring: \"\"\nInput: \"abc\", \"\"\nLongest common substring: \"\"\nInput: \"same\", \"same\"\nLongest common substring: \"same\"", "task_id": 1284, "assertions": "func testLongestCommonSubstring() {\n    assert(longestCommonSubstring(\"abcdef\", \"xbcdyz\") == \"bcd\")\n    assert(longestCommonSubstring(\"hello\", \"world\") == \"l\")\n    assert(longestCommonSubstring(\"programming\", \"program\") == \"program\")\n    assert(longestCommonSubstring(\"\", \"test\") == \"\")\n    assert(longestCommonSubstring(\"abc\", \"\") == \"\")\n    assert(longestCommonSubstring(\"same\", \"same\") == \"same\")\n}\n\ntestLongestCommonSubstring()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLongestCommonSubstring() {\n    assert(longestCommonSubstring(\"abcdef\", \"xbcdyz\") == \"bcd\")\n    assert(longestCommonSubstring(\"hello\", \"world\") == \"l\")\n    assert(longestCommonSubstring(\"programming\", \"program\") == \"program\")\n    assert(longestCommonSubstring(\"\", \"test\") == \"\")\n    assert(longestCommonSubstring(\"abc\", \"\") == \"\")\n    assert(longestCommonSubstring(\"same\", \"same\") == \"same\")\n}\n\ntestLongestCommonSubstring()", "output": "longestCommonSubstring"}, "all_code": "func longestCommonSubstring(_ s1: String, _ s2: String) -> String {\n    if s1.isEmpty || s2.isEmpty {\n        return \"\"\n    }\n    \n    let m = s1.count\n    let n = s2.count\n    var lcsuff = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\n    var length = 0\n    var endIndexM = 0\n    \n    let s1Array = Array(s1)\n    let s2Array = Array(s2)\n    \n    for i in 0...m {\n        for j in 0...n {\n            if i == 0 || j == 0 {\n                lcsuff[i][j] = 0\n            } else if s1Array[i - 1] == s2Array[j - 1] {\n                lcsuff[i][j] = lcsuff[i - 1][j - 1] + 1\n                if length < lcsuff[i][j] {\n                    length = lcsuff[i][j]\n                    endIndexM = i\n                }\n            } else {\n                lcsuff[i][j] = 0\n            }\n        }\n    }\n    \n    if length == 0 {\n        return \"\"\n    }\n    \n    let startIndex = s1.index(s1.startIndex, offsetBy: endIndexM - length)\n    let endIndex = s1.index(s1.startIndex, offsetBy: endIndexM)\n    return String(s1[startIndex..<endIndex])\n}\nfunc testLongestCommonSubstring() {\n    assert(longestCommonSubstring(\"abcdef\", \"xbcdyz\") == \"bcd\")\n    assert(longestCommonSubstring(\"hello\", \"world\") == \"l\")\n    assert(longestCommonSubstring(\"programming\", \"program\") == \"program\")\n    assert(longestCommonSubstring(\"\", \"test\") == \"\")\n    assert(longestCommonSubstring(\"abc\", \"\") == \"\")\n    assert(longestCommonSubstring(\"same\", \"same\") == \"same\")\n}\n\ntestLongestCommonSubstring()", "exec_outcome": "PASSED"}
{"code": "// maximizeAnimalStrength calculates the maximum possible strength of a single animal after performing all possible battles.\n// The function takes the number of animals `n` and an array of their strengths `strengths`.\n// The logic is based on the observation that the maximum possible strength is the sum of all individual strengths,\n// as all strengths can be consolidated into a single animal through battles.\nfunc maximizeAnimalStrength(n: Int, strengths: [Int]) -> Int {\n    return strengths.reduce(0, +)\n}", "test_cases": "", "test_case_results": "Input - n: 3, strengths: [1, 2, 3]\nMaximum possible strength: 6\nInput - n: 5, strengths: [5, 5, 5, 5, 5]\nMaximum possible strength: 25\nInput - n: 1, strengths: [10]\nMaximum possible strength: 10\nInput - n: 4, strengths: [0, 0, 0, 0]\nMaximum possible strength: 0\nInput - n: 2, strengths: [7, 3]\nMaximum possible strength: 10", "task_id": 17811, "assertions": "func testMaximizeAnimalStrength() {\n    assert(maximizeAnimalStrength(n: 3, strengths: [1, 2, 3]) == 6)\n    assert(maximizeAnimalStrength(n: 5, strengths: [5, 5, 5, 5, 5]) == 25)\n    assert(maximizeAnimalStrength(n: 1, strengths: [10]) == 10)\n    assert(maximizeAnimalStrength(n: 4, strengths: [0, 0, 0, 0]) == 0)\n    assert(maximizeAnimalStrength(n: 2, strengths: [7, 3]) == 10)\n}\n\ntestMaximizeAnimalStrength()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaximizeAnimalStrength() {\n    assert(maximizeAnimalStrength(n: 3, strengths: [1, 2, 3]) == 6)\n    assert(maximizeAnimalStrength(n: 5, strengths: [5, 5, 5, 5, 5]) == 25)\n    assert(maximizeAnimalStrength(n: 1, strengths: [10]) == 10)\n    assert(maximizeAnimalStrength(n: 4, strengths: [0, 0, 0, 0]) == 0)\n    assert(maximizeAnimalStrength(n: 2, strengths: [7, 3]) == 10)\n}\n\ntestMaximizeAnimalStrength()", "output": "maximizeAnimalStrength"}, "all_code": "import Foundation\nimport Glibc\n\n// maximizeAnimalStrength calculates the maximum possible strength of a single animal after performing all possible battles.\n// The function takes the number of animals `n` and an array of their strengths `strengths`.\n// The logic is based on the observation that the maximum possible strength is the sum of all individual strengths,\n// as all strengths can be consolidated into a single animal through battles.\nfunc maximizeAnimalStrength(n: Int, strengths: [Int]) -> Int {\n    return strengths.reduce(0, +)\n}\nfunc testMaximizeAnimalStrength() {\n    assert(maximizeAnimalStrength(n: 3, strengths: [1, 2, 3]) == 6)\n    assert(maximizeAnimalStrength(n: 5, strengths: [5, 5, 5, 5, 5]) == 25)\n    assert(maximizeAnimalStrength(n: 1, strengths: [10]) == 10)\n    assert(maximizeAnimalStrength(n: 4, strengths: [0, 0, 0, 0]) == 0)\n    assert(maximizeAnimalStrength(n: 2, strengths: [7, 3]) == 10)\n}\n\ntestMaximizeAnimalStrength()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\nfunc minimumPeopleRequired(tasks: [(start: Int, end: Int)]) -> Int {\n    // Edge case: if there are no tasks\n    if tasks.isEmpty {\n        return 0\n    }\n    \n    // Sort the tasks based on start time\n    let sortedTasks = tasks.sorted { $0.start < $1.start }\n    \n    // Min-heap to keep track of end times\n    var heap = [Int]()\n    \n    for task in sortedTasks {\n        let start = task.start\n        let end = task.end\n        \n        if !heap.isEmpty && heap[0] <= start {\n            // Replace the earliest end time with the new end time\n            heap.removeFirst()\n            heap.append(end)\n            heap.sort() // Maintain heap property\n        } else {\n            // Add new end time\n            heap.append(end)\n            heap.sort() // Maintain heap property\n        }\n    }\n    \n    return heap.count\n}", "test_cases": "", "test_case_results": "Input tasks: [(start: 1, end: 3), (start: 2, end: 4), (start: 3, end: 5)]\nMinimum people required: 2\nInput tasks: [(start: 1, end: 2), (start: 3, end: 4), (start: 5, end: 6)]\nMinimum people required: 1\nInput tasks: [(start: 1, end: 4), (start: 2, end: 3), (start: 3, end: 6)]\nMinimum people required: 2\nInput tasks: []\nMinimum people required: 0\nInput tasks: [(start: 1, end: 10), (start: 2, end: 3), (start: 3, end: 4), (start: 4, end: 5)]\nMinimum people required: 2", "task_id": 22254, "assertions": "func testMinimumPeopleRequired() {\n    assert(minimumPeopleRequired(tasks: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumPeopleRequired(tasks: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumPeopleRequired(tasks: [(1, 4), (2, 3), (3, 6)]) == 2)\n    assert(minimumPeopleRequired(tasks: []) == 0)\n    assert(minimumPeopleRequired(tasks: [(1, 10), (2, 3), (3, 4), (4, 5)]) == 2)\n}\n\ntestMinimumPeopleRequired()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinimumPeopleRequired() {\n    assert(minimumPeopleRequired(tasks: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumPeopleRequired(tasks: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumPeopleRequired(tasks: [(1, 4), (2, 3), (3, 6)]) == 2)\n    assert(minimumPeopleRequired(tasks: []) == 0)\n    assert(minimumPeopleRequired(tasks: [(1, 10), (2, 3), (3, 4), (4, 5)]) == 2)\n}\n\ntestMinimumPeopleRequired()", "output": "minimumPeopleRequired"}, "all_code": "import Foundation\n\nfunc minimumPeopleRequired(tasks: [(start: Int, end: Int)]) -> Int {\n    // Edge case: if there are no tasks\n    if tasks.isEmpty {\n        return 0\n    }\n    \n    // Sort the tasks based on start time\n    let sortedTasks = tasks.sorted { $0.start < $1.start }\n    \n    // Min-heap to keep track of end times\n    var heap = [Int]()\n    \n    for task in sortedTasks {\n        let start = task.start\n        let end = task.end\n        \n        if !heap.isEmpty && heap[0] <= start {\n            // Replace the earliest end time with the new end time\n            heap.removeFirst()\n            heap.append(end)\n            heap.sort() // Maintain heap property\n        } else {\n            // Add new end time\n            heap.append(end)\n            heap.sort() // Maintain heap property\n        }\n    }\n    \n    return heap.count\n}\nfunc testMinimumPeopleRequired() {\n    assert(minimumPeopleRequired(tasks: [(1, 3), (2, 4), (3, 5)]) == 2)\n    assert(minimumPeopleRequired(tasks: [(1, 2), (3, 4), (5, 6)]) == 1)\n    assert(minimumPeopleRequired(tasks: [(1, 4), (2, 3), (3, 6)]) == 2)\n    assert(minimumPeopleRequired(tasks: []) == 0)\n    assert(minimumPeopleRequired(tasks: [(1, 10), (2, 3), (3, 4), (4, 5)]) == 2)\n}\n\ntestMinimumPeopleRequired()", "exec_outcome": "PASSED"}
{"code": "// getMinOperations calculates the minimum number of operations required to completely remove the periodic substring p from S.\n// The function finds the smallest period p of the string S by checking for the smallest k such that S is made of k repetitions of p.\n// If no such k is found, it returns 1 as the default case (the entire string is considered as one operation).\nfunc getMinOperations(_ S: String) -> Int {\n    let n = S.count\n    for k in 1...n {\n        if n % k == 0 {\n            let p = String(S.prefix(k))\n            let repeatedString = String(repeating: p, count: n / k)\n            if repeatedString == S {\n                return n / k\n            }\n        }\n    }\n    return 1\n}\n\n// solve processes each test case in the input array and returns an array of results.\n// Each result corresponds to the minimum number of operations required for the respective string in the test cases.\nfunc solve(testCases: [String]) -> [Int] {\n    return testCases.map { getMinOperations($0) }\n}", "test_cases": "", "test_case_results": "Testing individual strings:\nInput: \"abcabcabc\", Operations: 3\nInput: \"aaaa\", Operations: 4\nInput: \"ababab\", Operations: 3\nInput: \"abcdefg\", Operations: 1\nInput: \"xxyxxy\", Operations: 2\n\nTesting solve function with all test cases:\nTest case 1: \"abcabcabc\", Operations: 3\nTest case 2: \"aaaa\", Operations: 4\nTest case 3: \"ababab\", Operations: 3\nTest case 4: \"abcdefg\", Operations: 1\nTest case 5: \"xxyxxy\", Operations: 2", "task_id": 25154, "assertions": "func testGetMinOperations() {\n    assert(getMinOperations(\"abcabcabc\") == 3)\n    assert(getMinOperations(\"aaaa\") == 4)\n    assert(getMinOperations(\"ababab\") == 3)\n    assert(getMinOperations(\"abcdefg\") == 1)\n    assert(getMinOperations(\"xxyxxy\") == 2)\n    \n    let testCases = [\n        \"abcabcabc\",\n        \"aaaa\",\n        \"ababab\",\n        \"abcdefg\",\n        \"xxyxxy\"\n    ]\n    let expectedResults = [3, 4, 3, 1, 2]\n    let results = solve(testCases: testCases)\n    for (index, result) in results.enumerated() {\n        assert(result == expectedResults[index])\n    }\n}\n\ntestGetMinOperations()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testGetMinOperations() {\n    assert(getMinOperations(\"abcabcabc\") == 3)\n    assert(getMinOperations(\"aaaa\") == 4)\n    assert(getMinOperations(\"ababab\") == 3)\n    assert(getMinOperations(\"abcdefg\") == 1)\n    assert(getMinOperations(\"xxyxxy\") == 2)\n    \n    let testCases = [\n        \"abcabcabc\",\n        \"aaaa\",\n        \"ababab\",\n        \"abcdefg\",\n        \"xxyxxy\"\n    ]\n    let expectedResults = [3, 4, 3, 1, 2]\n    let results = solve(testCases: testCases)\n    for (index, result) in results.enumerated() {\n        assert(result == expectedResults[index])\n    }\n}\n\ntestGetMinOperations()", "output": "getMinOperations"}, "all_code": "// getMinOperations calculates the minimum number of operations required to completely remove the periodic substring p from S.\n// The function finds the smallest period p of the string S by checking for the smallest k such that S is made of k repetitions of p.\n// If no such k is found, it returns 1 as the default case (the entire string is considered as one operation).\nfunc getMinOperations(_ S: String) -> Int {\n    let n = S.count\n    for k in 1...n {\n        if n % k == 0 {\n            let p = String(S.prefix(k))\n            let repeatedString = String(repeating: p, count: n / k)\n            if repeatedString == S {\n                return n / k\n            }\n        }\n    }\n    return 1\n}\n\n// solve processes each test case in the input array and returns an array of results.\n// Each result corresponds to the minimum number of operations required for the respective string in the test cases.\nfunc solve(testCases: [String]) -> [Int] {\n    return testCases.map { getMinOperations($0) }\n}\nfunc testGetMinOperations() {\n    assert(getMinOperations(\"abcabcabc\") == 3)\n    assert(getMinOperations(\"aaaa\") == 4)\n    assert(getMinOperations(\"ababab\") == 3)\n    assert(getMinOperations(\"abcdefg\") == 1)\n    assert(getMinOperations(\"xxyxxy\") == 2)\n    \n    let testCases = [\n        \"abcabcabc\",\n        \"aaaa\",\n        \"ababab\",\n        \"abcdefg\",\n        \"xxyxxy\"\n    ]\n    let expectedResults = [3, 4, 3, 1, 2]\n    let results = solve(testCases: testCases)\n    for (index, result) in results.enumerated() {\n        assert(result == expectedResults[index])\n    }\n}\n\ntestGetMinOperations()", "exec_outcome": "PASSED"}
{"code": "// kthNebulaNumber returns the k-th Nebula Number.\n// A Nebula Number is a number that is divisible by either 3 or 5 but not both.\n// The function uses a while loop to iterate through numbers until it finds the k-th number that meets the criteria.\nfunc kthNebulaNumber(k: Int) -> Int {\n    var count = 0\n    var number = 0\n    \n    while count < k {\n        number += 1\n        \n        if (number % 3 == 0) != (number % 5 == 0) {\n            count += 1\n        }\n    }\n    \n    return number\n}\n\n// processNebulaNumbers processes multiple test cases to find the respective K-th Nebula Number for each case.\n// It takes the number of test cases and an array of K values, then returns an array of results.\nfunc processNebulaNumbers(T: Int, testCases: [Int]) -> [Int] {\n    var results = [Int]()\n    for k in testCases {\n        results.append(kthNebulaNumber(k: k))\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Number of test cases: 5\nTest cases: [1, 5, 10, 15, 20]\nK: 1, Nebula Number: 3\nK: 5, Nebula Number: 10\nK: 10, Nebula Number: 24\nK: 15, Nebula Number: 36\nK: 20, Nebula Number: 50", "task_id": 9129, "assertions": "func testNebulaNumbers() {\n    assert(kthNebulaNumber(k: 1) == 3)\n    assert(kthNebulaNumber(k: 5) == 10)\n    assert(kthNebulaNumber(k: 10) == 24)\n    assert(kthNebulaNumber(k: 15) == 36)\n    assert(kthNebulaNumber(k: 20) == 50)\n    \n    let testCases = [1, 5, 10, 15, 20]\n    let expectedResults = [3, 10, 24, 36, 50]\n    let results = processNebulaNumbers(T: testCases.count, testCases: testCases)\n    assert(results == expectedResults)\n}\n\ntestNebulaNumbers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testNebulaNumbers() {\n    assert(kthNebulaNumber(k: 1) == 3)\n    assert(kthNebulaNumber(k: 5) == 10)\n    assert(kthNebulaNumber(k: 10) == 24)\n    assert(kthNebulaNumber(k: 15) == 36)\n    assert(kthNebulaNumber(k: 20) == 50)\n    \n    let testCases = [1, 5, 10, 15, 20]\n    let expectedResults = [3, 10, 24, 36, 50]\n    let results = processNebulaNumbers(T: testCases.count, testCases: testCases)\n    assert(results == expectedResults)\n}\n\ntestNebulaNumbers()", "output": "The function being tested is `kthNebulaNumber`."}, "all_code": "// kthNebulaNumber returns the k-th Nebula Number.\n// A Nebula Number is a number that is divisible by either 3 or 5 but not both.\n// The function uses a while loop to iterate through numbers until it finds the k-th number that meets the criteria.\nfunc kthNebulaNumber(k: Int) -> Int {\n    var count = 0\n    var number = 0\n    \n    while count < k {\n        number += 1\n        \n        if (number % 3 == 0) != (number % 5 == 0) {\n            count += 1\n        }\n    }\n    \n    return number\n}\n\n// processNebulaNumbers processes multiple test cases to find the respective K-th Nebula Number for each case.\n// It takes the number of test cases and an array of K values, then returns an array of results.\nfunc processNebulaNumbers(T: Int, testCases: [Int]) -> [Int] {\n    var results = [Int]()\n    for k in testCases {\n        results.append(kthNebulaNumber(k: k))\n    }\n    return results\n}\nfunc testNebulaNumbers() {\n    assert(kthNebulaNumber(k: 1) == 3)\n    assert(kthNebulaNumber(k: 5) == 10)\n    assert(kthNebulaNumber(k: 10) == 24)\n    assert(kthNebulaNumber(k: 15) == 36)\n    assert(kthNebulaNumber(k: 20) == 50)\n    \n    let testCases = [1, 5, 10, 15, 20]\n    let expectedResults = [3, 10, 24, 36, 50]\n    let results = processNebulaNumbers(T: testCases.count, testCases: testCases)\n    assert(results == expectedResults)\n}\n\ntestNebulaNumbers()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// highlightKeywords takes a text string and a list of keywords, and returns the text\n// with each occurrence of the keywords wrapped in <strong> tags.\n// The matching is case-insensitive and applies to whole words only.\n// - Parameters:\n//   - text: The input text string.\n//   - keywords: An array of keywords to be highlighted.\n// - Returns: The text with keywords surrounded by <strong> tags.\nfunc highlightKeywords(text: String, keywords: [String]) -> String {\n    var result = text\n    for keyword in keywords {\n        // Create a regular expression pattern to match the whole word case-insensitively\n        let pattern = \"\\\\b\\(NSRegularExpression.escapedPattern(for: keyword))\\\\b\"\n        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]) else {\n            continue\n        }\n        // Replace each match with the same word wrapped in <strong> tags\n        result = regex.stringByReplacingMatches(in: result, options: [], range: NSRange(location: 0, length: result.utf16.count), withTemplate: \"<strong>$0</strong>\")\n    }\n    return result\n}", "test_cases": "", "test_case_results": "Input Text: \"Hello world, welcome to Swift programming.\"\nKeywords: [\"hello\", \"swift\"]\nResult: \"<strong>Hello</strong> world, welcome to <strong>Swift</strong> programming.\"\n---\nInput Text: \"The quick brown fox jumps over the lazy dog.\"\nKeywords: [\"the\", \"fox\"]\nResult: \"<strong>The</strong> quick brown <strong>fox</strong> jumps over <strong>the</strong> lazy dog.\"\n---\nInput Text: \"This is a test sentence with no keywords.\"\nKeywords: [\"missing\"]\nResult: \"This is a test sentence with no keywords.\"\n---\nInput Text: \"Case sensitivity test: Swift vs swift.\"\nKeywords: [\"swift\"]\nResult: \"Case sensitivity test: <strong>Swift</strong> vs <strong>swift</strong>.\"\n---", "task_id": 26003, "assertions": "func testHighlightKeywords() {\n    assert(highlightKeywords(text: \"Hello world, welcome to Swift programming.\", keywords: [\"hello\", \"swift\"]) == \"<strong>Hello</strong> world, welcome to <strong>Swift</strong> programming.\")\n    assert(highlightKeywords(text: \"The quick brown fox jumps over the lazy dog.\", keywords: [\"the\", \"fox\"]) == \"<strong>The</strong> quick brown <strong>fox</strong> jumps over <strong>the</strong> lazy dog.\")\n    assert(highlightKeywords(text: \"This is a test sentence with no keywords.\", keywords: [\"missing\"]) == \"This is a test sentence with no keywords.\")\n    assert(highlightKeywords(text: \"Case sensitivity test: Swift vs swift.\", keywords: [\"swift\"]) == \"Case sensitivity test: <strong>Swift</strong> vs <strong>swift</strong>.\")\n}\n\ntestHighlightKeywords()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testHighlightKeywords() {\n    assert(highlightKeywords(text: \"Hello world, welcome to Swift programming.\", keywords: [\"hello\", \"swift\"]) == \"<strong>Hello</strong> world, welcome to <strong>Swift</strong> programming.\")\n    assert(highlightKeywords(text: \"The quick brown fox jumps over the lazy dog.\", keywords: [\"the\", \"fox\"]) == \"<strong>The</strong> quick brown <strong>fox</strong> jumps over <strong>the</strong> lazy dog.\")\n    assert(highlightKeywords(text: \"This is a test sentence with no keywords.\", keywords: [\"missing\"]) == \"This is a test sentence with no keywords.\")\n    assert(highlightKeywords(text: \"Case sensitivity test: Swift vs swift.\", keywords: [\"swift\"]) == \"Case sensitivity test: <strong>Swift</strong> vs <strong>swift</strong>.\")\n}\n\ntestHighlightKeywords()", "output": "highlightKeywords"}, "all_code": "import Glibc\n\nimport Foundation\n\n// highlightKeywords takes a text string and a list of keywords, and returns the text\n// with each occurrence of the keywords wrapped in <strong> tags.\n// The matching is case-insensitive and applies to whole words only.\n// - Parameters:\n//   - text: The input text string.\n//   - keywords: An array of keywords to be highlighted.\n// - Returns: The text with keywords surrounded by <strong> tags.\nfunc highlightKeywords(text: String, keywords: [String]) -> String {\n    var result = text\n    for keyword in keywords {\n        // Create a regular expression pattern to match the whole word case-insensitively\n        let pattern = \"\\\\b\\(NSRegularExpression.escapedPattern(for: keyword))\\\\b\"\n        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]) else {\n            continue\n        }\n        // Replace each match with the same word wrapped in <strong> tags\n        result = regex.stringByReplacingMatches(in: result, options: [], range: NSRange(location: 0, length: result.utf16.count), withTemplate: \"<strong>$0</strong>\")\n    }\n    return result\n}\nfunc testHighlightKeywords() {\n    assert(highlightKeywords(text: \"Hello world, welcome to Swift programming.\", keywords: [\"hello\", \"swift\"]) == \"<strong>Hello</strong> world, welcome to <strong>Swift</strong> programming.\")\n    assert(highlightKeywords(text: \"The quick brown fox jumps over the lazy dog.\", keywords: [\"the\", \"fox\"]) == \"<strong>The</strong> quick brown <strong>fox</strong> jumps over <strong>the</strong> lazy dog.\")\n    assert(highlightKeywords(text: \"This is a test sentence with no keywords.\", keywords: [\"missing\"]) == \"This is a test sentence with no keywords.\")\n    assert(highlightKeywords(text: \"Case sensitivity test: Swift vs swift.\", keywords: [\"swift\"]) == \"Case sensitivity test: <strong>Swift</strong> vs <strong>swift</strong>.\")\n}\n\ntestHighlightKeywords()", "exec_outcome": "PASSED"}
{"code": "// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// It takes two non-zero integers and returns their GCD.\n// If either input is zero, it throws a fatal error.\nfunc gcd(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    var a = abs(a)\n    var b = abs(b)\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\n// lcm calculates the least common multiple of two integers.\n// It takes two non-zero integers and returns their LCM.\n// If either input is zero, it throws a fatal error.\nfunc lcm(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    let a = abs(a)\n    let b = abs(b)\n    return a * b / gcd(a: a, b: b)\n}\n\n// trailingZero counts the number of trailing zero bits in the binary representation of an integer.\n// It returns 0 if the input is zero.\nfunc trailingZero(x: Int) -> Int {\n    if x == 0 {\n        return 0\n    }\n    var x = x\n    var count = 0\n    while (x & 1) == 0 {\n        x >>= 1\n        count += 1\n    }\n    return count\n}\n\n// gcdBit calculates the greatest common divisor of two integers using bitwise operations.\n// It takes two non-zero integers and returns their GCD.\n// If either input is zero, it throws a fatal error.\nfunc gcdBit(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    var a = abs(a)\n    var b = abs(b)\n    if a == b {\n        return a\n    }\n    if a == 0 {\n        return b\n    }\n    if b == 0 {\n        return a\n    }\n    // a and b are both even\n    if (a & 1) == 0 && (b & 1) == 0 {\n        return gcdBit(a: a >> 1, b: b >> 1) << 1\n    }\n    // a is even, b is odd\n    else if (a & 1) == 0 {\n        return gcdBit(a: a >> 1, b: b)\n    }\n    // a is odd, b is even\n    else if (b & 1) == 0 {\n        return gcdBit(a: a, b: b >> 1)\n    }\n    // both a and b are odd, reduce larger number\n    else if a > b {\n        return gcdBit(a: a - b, b: b)\n    } else {\n        return gcdBit(a: a, b: b - a)\n    }\n}", "test_cases": "", "test_case_results": "Testing gcd function:\nInput: a = 48, b = 18\nInput: a = 0, b = 5\nInput: a = -36, b = 24\nInput: a = 17, b = 23\n\nTesting lcm function:\nInput: a = 12, b = 15\nInput: a = 0, b = 10\nInput: a = -8, b = 6\nInput: a = 7, b = 3\n\nTesting trailingZero function:\nInput: 0\nTrailing zeros: 0\nInput: 8\nTrailing zeros: 3\nInput: 12\nTrailing zeros: 2\nInput: 16\nTrailing zeros: 4\nInput: 1\nTrailing zeros: 0\n\nTesting gcdBit function:\nInput: a = 48, b = 18\nInput: a = 0, b = 5\nInput: a = -36, b = 24\nInput: a = 17, b = 23", "task_id": 25994, "assertions": "func testMathFunctions() {\n    // Test gcd function\n    assert(gcd(a: 48, b: 18) == 6)\n    assert(gcd(a: -36, b: 24) == 12)\n    assert(gcd(a: 17, b: 23) == 1)\n    \n    // Test lcm function\n    assert(lcm(a: 12, b: 15) == 60)\n    assert(lcm(a: -8, b: 6) == 24)\n    assert(lcm(a: 7, b: 3) == 21)\n    \n    // Test trailingZero function\n    assert(trailingZero(x: 0) == 0)\n    assert(trailingZero(x: 8) == 3)\n    assert(trailingZero(x: 12) == 2)\n    assert(trailingZero(x: 16) == 4)\n    assert(trailingZero(x: 1) == 0)\n    \n    // Test gcdBit function\n    assert(gcdBit(a: 48, b: 18) == 6)\n    assert(gcdBit(a: -36, b: 24) == 12)\n    assert(gcdBit(a: 17, b: 23) == 1)\n}\n\ntestMathFunctions()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMathFunctions() {\n    // Test gcd function\n    assert(gcd(a: 48, b: 18) == 6)\n    assert(gcd(a: -36, b: 24) == 12)\n    assert(gcd(a: 17, b: 23) == 1)\n    \n    // Test lcm function\n    assert(lcm(a: 12, b: 15) == 60)\n    assert(lcm(a: -8, b: 6) == 24)\n    assert(lcm(a: 7, b: 3) == 21)\n    \n    // Test trailingZero function\n    assert(trailingZero(x: 0) == 0)\n    assert(trailingZero(x: 8) == 3)\n    assert(trailingZero(x: 12) == 2)\n    assert(trailingZero(x: 16) == 4)\n    assert(trailingZero(x: 1) == 0)\n    \n    // Test gcdBit function\n    assert(gcdBit(a: 48, b: 18) == 6)\n    assert(gcdBit(a: -36, b: 24) == 12)\n    assert(gcdBit(a: 17, b: 23) == 1)\n}\n\ntestMathFunctions()", "output": "gcd, lcm, trailingZero, gcdBit"}, "all_code": "import Foundation\nimport Glibc\n\n// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// It takes two non-zero integers and returns their GCD.\n// If either input is zero, it throws a fatal error.\nfunc gcd(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    var a = abs(a)\n    var b = abs(b)\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\n// lcm calculates the least common multiple of two integers.\n// It takes two non-zero integers and returns their LCM.\n// If either input is zero, it throws a fatal error.\nfunc lcm(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    let a = abs(a)\n    let b = abs(b)\n    return a * b / gcd(a: a, b: b)\n}\n\n// trailingZero counts the number of trailing zero bits in the binary representation of an integer.\n// It returns 0 if the input is zero.\nfunc trailingZero(x: Int) -> Int {\n    if x == 0 {\n        return 0\n    }\n    var x = x\n    var count = 0\n    while (x & 1) == 0 {\n        x >>= 1\n        count += 1\n    }\n    return count\n}\n\n// gcdBit calculates the greatest common divisor of two integers using bitwise operations.\n// It takes two non-zero integers and returns their GCD.\n// If either input is zero, it throws a fatal error.\nfunc gcdBit(a: Int, b: Int) -> Int {\n    if a == 0 || b == 0 {\n        fatalError(\"Inputs must be non-zero integers.\")\n    }\n    var a = abs(a)\n    var b = abs(b)\n    if a == b {\n        return a\n    }\n    if a == 0 {\n        return b\n    }\n    if b == 0 {\n        return a\n    }\n    // a and b are both even\n    if (a & 1) == 0 && (b & 1) == 0 {\n        return gcdBit(a: a >> 1, b: b >> 1) << 1\n    }\n    // a is even, b is odd\n    else if (a & 1) == 0 {\n        return gcdBit(a: a >> 1, b: b)\n    }\n    // a is odd, b is even\n    else if (b & 1) == 0 {\n        return gcdBit(a: a, b: b >> 1)\n    }\n    // both a and b are odd, reduce larger number\n    else if a > b {\n        return gcdBit(a: a - b, b: b)\n    } else {\n        return gcdBit(a: a, b: b - a)\n    }\n}\nfunc testMathFunctions() {\n    // Test gcd function\n    assert(gcd(a: 48, b: 18) == 6)\n    assert(gcd(a: -36, b: 24) == 12)\n    assert(gcd(a: 17, b: 23) == 1)\n    \n    // Test lcm function\n    assert(lcm(a: 12, b: 15) == 60)\n    assert(lcm(a: -8, b: 6) == 24)\n    assert(lcm(a: 7, b: 3) == 21)\n    \n    // Test trailingZero function\n    assert(trailingZero(x: 0) == 0)\n    assert(trailingZero(x: 8) == 3)\n    assert(trailingZero(x: 12) == 2)\n    assert(trailingZero(x: 16) == 4)\n    assert(trailingZero(x: 1) == 0)\n    \n    // Test gcdBit function\n    assert(gcdBit(a: 48, b: 18) == 6)\n    assert(gcdBit(a: -36, b: 24) == 12)\n    assert(gcdBit(a: 17, b: 23) == 1)\n}\n\ntestMathFunctions()", "exec_outcome": "PASSED"}
{"code": "// firstDuplicateIndex returns the index of the first duplicate element in the given integer array.\n// If no duplicate is found, it returns -1.\n// The function uses a dictionary to keep track of the elements seen so far and their indices.\nfunc firstDuplicateIndex(nums: [Int]) -> Int {\n    var seen = [Int: Int]()\n    for (index, num) in nums.enumerated() {\n        if let firstIndex = seen[num] {\n            return firstIndex\n        }\n        seen[num] = index\n    }\n    return -1\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 5, 2]\nFirst duplicate index: 1\nInput: [5, 6, 7, 8, 9]\nFirst duplicate index: -1\nInput: [1, 1, 2, 3, 4]\nFirst duplicate index: 0\nInput: [10, 20, 30, 20, 10]\nFirst duplicate index: 1", "task_id": 1688, "assertions": "func testFirstDuplicateIndex() {\n    assert(firstDuplicateIndex(nums: [1, 2, 3, 4, 5, 2]) == 1)\n    assert(firstDuplicateIndex(nums: [5, 6, 7, 8, 9]) == -1)\n    assert(firstDuplicateIndex(nums: [1, 1, 2, 3, 4]) == 0)\n    assert(firstDuplicateIndex(nums: [10, 20, 30, 20, 10]) == 1)\n}\n\ntestFirstDuplicateIndex()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFirstDuplicateIndex() {\n    assert(firstDuplicateIndex(nums: [1, 2, 3, 4, 5, 2]) == 1)\n    assert(firstDuplicateIndex(nums: [5, 6, 7, 8, 9]) == -1)\n    assert(firstDuplicateIndex(nums: [1, 1, 2, 3, 4]) == 0)\n    assert(firstDuplicateIndex(nums: [10, 20, 30, 20, 10]) == 1)\n}\n\ntestFirstDuplicateIndex()", "output": "firstDuplicateIndex"}, "all_code": "// firstDuplicateIndex returns the index of the first duplicate element in the given integer array.\n// If no duplicate is found, it returns -1.\n// The function uses a dictionary to keep track of the elements seen so far and their indices.\nfunc firstDuplicateIndex(nums: [Int]) -> Int {\n    var seen = [Int: Int]()\n    for (index, num) in nums.enumerated() {\n        if let firstIndex = seen[num] {\n            return firstIndex\n        }\n        seen[num] = index\n    }\n    return -1\n}\nfunc testFirstDuplicateIndex() {\n    assert(firstDuplicateIndex(nums: [1, 2, 3, 4, 5, 2]) == 1)\n    assert(firstDuplicateIndex(nums: [5, 6, 7, 8, 9]) == -1)\n    assert(firstDuplicateIndex(nums: [1, 1, 2, 3, 4]) == 0)\n    assert(firstDuplicateIndex(nums: [10, 20, 30, 20, 10]) == 1)\n}\n\ntestFirstDuplicateIndex()", "exec_outcome": "PASSED"}
{"code": "// findFriendCircles calculates the number of distinct friend circles in a group of friends using the Union-Find (Disjoint Set Union) algorithm.\n// - Parameters:\n//   - n: The number of friends.\n//   - m: The number of friendships (unused in this implementation, but kept for consistency with the original function signature).\n//   - friendships: An array of tuples representing the friendships between friends.\n// - Returns: The number of distinct friend circles.\nfunc findFriendCircles(n: Int, m: Int, friendships: [(Int, Int)]) -> Int {\n    var parent = [Int](0...n) // Parent array for Union-Find, initialized such that each friend is their own parent initially.\n\n    // find is a helper function that finds the root parent of a friend with path compression.\n    // Path compression flattens the structure of the tree to make future queries faster.\n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x]) // Path compression.\n        }\n        return parent[x]\n    }\n\n    // union is a helper function that merges two friend circles.\n    func union(_ x: Int, _ y: Int) {\n        let rootX = find(x)\n        let rootY = find(y)\n        if rootX != rootY {\n            parent[rootY] = rootX // Merge the two circles by setting one root as the parent of the other.\n        }\n    }\n\n    // Process each friendship to merge friend circles.\n    for (a, b) in friendships {\n        union(a, b)\n    }\n\n    // Count the number of distinct roots, which corresponds to the number of distinct friend circles.\n    var distinctRoots = Set<Int>()\n    for x in 1...n {\n        distinctRoots.insert(find(x))\n    }\n    return distinctRoots.count\n}", "test_cases": "", "test_case_results": "Input: n = 3, m = 2, friendships = [(1, 2), (2, 3)]\nDistinct friend circles: 1\nInput: n = 4, m = 2, friendships = [(1, 2), (3, 4)]\nDistinct friend circles: 2\nInput: n = 5, m = 0, friendships = []\nDistinct friend circles: 5\nInput: n = 6, m = 3, friendships = [(1, 2), (2, 3), (4, 5)]\nDistinct friend circles: 3", "task_id": 11867, "assertions": "func testFindFriendCircles() {\n    assert(findFriendCircles(n: 3, m: 2, friendships: [(1, 2), (2, 3)]) == 1)\n    assert(findFriendCircles(n: 4, m: 2, friendships: [(1, 2), (3, 4)]) == 2)\n    assert(findFriendCircles(n: 5, m: 0, friendships: []) == 5)\n    assert(findFriendCircles(n: 6, m: 3, friendships: [(1, 2), (2, 3), (4, 5)]) == 3)\n}\n\ntestFindFriendCircles()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindFriendCircles() {\n    assert(findFriendCircles(n: 3, m: 2, friendships: [(1, 2), (2, 3)]) == 1)\n    assert(findFriendCircles(n: 4, m: 2, friendships: [(1, 2), (3, 4)]) == 2)\n    assert(findFriendCircles(n: 5, m: 0, friendships: []) == 5)\n    assert(findFriendCircles(n: 6, m: 3, friendships: [(1, 2), (2, 3), (4, 5)]) == 3)\n}\n\ntestFindFriendCircles()", "output": "findFriendCircles"}, "all_code": "import Foundation\nimport Glibc\n\n// findFriendCircles calculates the number of distinct friend circles in a group of friends using the Union-Find (Disjoint Set Union) algorithm.\n// - Parameters:\n//   - n: The number of friends.\n//   - m: The number of friendships (unused in this implementation, but kept for consistency with the original function signature).\n//   - friendships: An array of tuples representing the friendships between friends.\n// - Returns: The number of distinct friend circles.\nfunc findFriendCircles(n: Int, m: Int, friendships: [(Int, Int)]) -> Int {\n    var parent = [Int](0...n) // Parent array for Union-Find, initialized such that each friend is their own parent initially.\n\n    // find is a helper function that finds the root parent of a friend with path compression.\n    // Path compression flattens the structure of the tree to make future queries faster.\n    func find(_ x: Int) -> Int {\n        if parent[x] != x {\n            parent[x] = find(parent[x]) // Path compression.\n        }\n        return parent[x]\n    }\n\n    // union is a helper function that merges two friend circles.\n    func union(_ x: Int, _ y: Int) {\n        let rootX = find(x)\n        let rootY = find(y)\n        if rootX != rootY {\n            parent[rootY] = rootX // Merge the two circles by setting one root as the parent of the other.\n        }\n    }\n\n    // Process each friendship to merge friend circles.\n    for (a, b) in friendships {\n        union(a, b)\n    }\n\n    // Count the number of distinct roots, which corresponds to the number of distinct friend circles.\n    var distinctRoots = Set<Int>()\n    for x in 1...n {\n        distinctRoots.insert(find(x))\n    }\n    return distinctRoots.count\n}\nfunc testFindFriendCircles() {\n    assert(findFriendCircles(n: 3, m: 2, friendships: [(1, 2), (2, 3)]) == 1)\n    assert(findFriendCircles(n: 4, m: 2, friendships: [(1, 2), (3, 4)]) == 2)\n    assert(findFriendCircles(n: 5, m: 0, friendships: []) == 5)\n    assert(findFriendCircles(n: 6, m: 3, friendships: [(1, 2), (2, 3), (4, 5)]) == 3)\n}\n\ntestFindFriendCircles()", "exec_outcome": "PASSED"}
{"code": "// maxDifferenceMinSum calculates the maximum possible difference between any two elements in an array\n// such that after removing those two elements, the sum of the remaining elements is minimized.\n// The function sorts the array to easily find the smallest and largest elements, whose difference is returned.\nfunc maxDifferenceMinSum(_ n: Int, _ arr: [Int]) -> Int {\n    guard n >= 2 else {\n        return 0\n    }\n    let sortedArr = arr.sorted()\n    let maxDiff = sortedArr[n - 1] - sortedArr[0]\n    return maxDiff\n}", "test_cases": "", "test_case_results": "Input array: [4, 2, 1, 3]\nMaximum difference with min sum after removal: 3\nInput array: [5, 1, 3, 9, 2]\nMaximum difference with min sum after removal: 8\nInput array: [10, 20]\nMaximum difference with min sum after removal: 10\nInput array: [5]\nMaximum difference with min sum after removal: 0", "task_id": 3779, "assertions": "func testMaxDifferenceMinSum() {\n    assert(maxDifferenceMinSum(4, [4, 2, 1, 3]) == 3)\n    assert(maxDifferenceMinSum(5, [5, 1, 3, 9, 2]) == 8)\n    assert(maxDifferenceMinSum(2, [10, 20]) == 10)\n    assert(maxDifferenceMinSum(1, [5]) == 0)\n}\n\ntestMaxDifferenceMinSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaxDifferenceMinSum() {\n    assert(maxDifferenceMinSum(4, [4, 2, 1, 3]) == 3)\n    assert(maxDifferenceMinSum(5, [5, 1, 3, 9, 2]) == 8)\n    assert(maxDifferenceMinSum(2, [10, 20]) == 10)\n    assert(maxDifferenceMinSum(1, [5]) == 0)\n}\n\ntestMaxDifferenceMinSum()", "output": "maxDifferenceMinSum"}, "all_code": "// maxDifferenceMinSum calculates the maximum possible difference between any two elements in an array\n// such that after removing those two elements, the sum of the remaining elements is minimized.\n// The function sorts the array to easily find the smallest and largest elements, whose difference is returned.\nfunc maxDifferenceMinSum(_ n: Int, _ arr: [Int]) -> Int {\n    guard n >= 2 else {\n        return 0\n    }\n    let sortedArr = arr.sorted()\n    let maxDiff = sortedArr[n - 1] - sortedArr[0]\n    return maxDiff\n}\nfunc testMaxDifferenceMinSum() {\n    assert(maxDifferenceMinSum(4, [4, 2, 1, 3]) == 3)\n    assert(maxDifferenceMinSum(5, [5, 1, 3, 9, 2]) == 8)\n    assert(maxDifferenceMinSum(2, [10, 20]) == 10)\n    assert(maxDifferenceMinSum(1, [5]) == 0)\n}\n\ntestMaxDifferenceMinSum()", "exec_outcome": "PASSED"}
{"code": "// countWays determines the number of distinct ways to spend exactly the given amount using the provided prices.\n// It uses dynamic programming to build up the solution by iterating through each price and updating the ways to make each amount.\n// - Parameters:\n//   - N: The number of different prices (unused in the function, kept for consistency with the original).\n//   - prices: An array of item prices.\n//   - amount: The exact amount of money to be spent.\n// - Returns: The number of distinct ways to spend the exact amount.\nfunc countWays(N: Int, prices: [Int], amount: Int) -> Int {\n    // Initialize dp array where dp[i] represents the number of ways to make sum i\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1 // One way to make sum 0, by choosing none of the items\n    \n    // For each price, update the dp array\n    for price in prices {\n        for j in price...amount {\n            dp[j] += dp[j - price]\n        }\n    }\n    \n    return dp[amount]\n}", "test_cases": "", "test_case_results": "Input - N: 3, Prices: [1, 2, 3], Amount: 4\nNumber of ways: 4\nInput - N: 2, Prices: [2, 3], Amount: 5\nNumber of ways: 1\nInput - N: 4, Prices: [1, 2, 3, 4], Amount: 6\nNumber of ways: 9\nInput - N: 1, Prices: [5], Amount: 10\nNumber of ways: 1", "task_id": 21122, "assertions": "func testCountWays() {\n    assert(countWays(N: 3, prices: [1, 2, 3], amount: 4) == 4)\n    assert(countWays(N: 2, prices: [2, 3], amount: 5) == 1)\n    assert(countWays(N: 4, prices: [1, 2, 3, 4], amount: 6) == 9)\n    assert(countWays(N: 1, prices: [5], amount: 10) == 1)\n}\n\ntestCountWays()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountWays() {\n    assert(countWays(N: 3, prices: [1, 2, 3], amount: 4) == 4)\n    assert(countWays(N: 2, prices: [2, 3], amount: 5) == 1)\n    assert(countWays(N: 4, prices: [1, 2, 3, 4], amount: 6) == 9)\n    assert(countWays(N: 1, prices: [5], amount: 10) == 1)\n}\n\ntestCountWays()", "output": "countWays"}, "all_code": "import Foundation\nimport Glibc\n\n// countWays determines the number of distinct ways to spend exactly the given amount using the provided prices.\n// It uses dynamic programming to build up the solution by iterating through each price and updating the ways to make each amount.\n// - Parameters:\n//   - N: The number of different prices (unused in the function, kept for consistency with the original).\n//   - prices: An array of item prices.\n//   - amount: The exact amount of money to be spent.\n// - Returns: The number of distinct ways to spend the exact amount.\nfunc countWays(N: Int, prices: [Int], amount: Int) -> Int {\n    // Initialize dp array where dp[i] represents the number of ways to make sum i\n    var dp = [Int](repeating: 0, count: amount + 1)\n    dp[0] = 1 // One way to make sum 0, by choosing none of the items\n    \n    // For each price, update the dp array\n    for price in prices {\n        for j in price...amount {\n            dp[j] += dp[j - price]\n        }\n    }\n    \n    return dp[amount]\n}\nfunc testCountWays() {\n    assert(countWays(N: 3, prices: [1, 2, 3], amount: 4) == 4)\n    assert(countWays(N: 2, prices: [2, 3], amount: 5) == 1)\n    assert(countWays(N: 4, prices: [1, 2, 3, 4], amount: 6) == 9)\n    assert(countWays(N: 1, prices: [5], amount: 10) == 1)\n}\n\ntestCountWays()", "exec_outcome": "PASSED"}
{"code": "// countOddTimesNumbers calculates the number of distinct integers in an array that appear an odd number of times.\n// It uses a dictionary to count the occurrences of each integer in the array.\n// The function then filters the dictionary to find integers with odd counts and returns the count of such integers.\nfunc countOddTimesNumbers(_ arr: [Int]) -> Int {\n    var counts = [Int: Int]()\n    \n    // Count the occurrences of each number in the array\n    for number in arr {\n        counts[number] = (counts[number] ?? 0) + 1\n    }\n    \n    // Filter numbers with odd counts and return the count of such numbers\n    let oddTimesNumbers = counts.filter { $0.value % 2 != 0 }\n    return oddTimesNumbers.count\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\nDistinct integers with odd counts: 2\nInput: [5, 5, 6, 6, 6, 7, 7, 7, 7]\nDistinct integers with odd counts: 1\nInput: [0, 0, 0, 0, 0]\nDistinct integers with odd counts: 1\nInput: [1, 2, 3, 4, 5]\nDistinct integers with odd counts: 5\nInput: []\nDistinct integers with odd counts: 0", "task_id": 11360, "assertions": "func testCountOddTimesNumbers() {\n    assert(countOddTimesNumbers([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == 2)\n    assert(countOddTimesNumbers([5, 5, 6, 6, 6, 7, 7, 7, 7]) == 1)\n    assert(countOddTimesNumbers([0, 0, 0, 0, 0]) == 1)\n    assert(countOddTimesNumbers([1, 2, 3, 4, 5]) == 5)\n    assert(countOddTimesNumbers([]) == 0)\n}\n\ntestCountOddTimesNumbers()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCountOddTimesNumbers() {\n    assert(countOddTimesNumbers([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == 2)\n    assert(countOddTimesNumbers([5, 5, 6, 6, 6, 7, 7, 7, 7]) == 1)\n    assert(countOddTimesNumbers([0, 0, 0, 0, 0]) == 1)\n    assert(countOddTimesNumbers([1, 2, 3, 4, 5]) == 5)\n    assert(countOddTimesNumbers([]) == 0)\n}\n\ntestCountOddTimesNumbers()", "output": "countOddTimesNumbers"}, "all_code": "// countOddTimesNumbers calculates the number of distinct integers in an array that appear an odd number of times.\n// It uses a dictionary to count the occurrences of each integer in the array.\n// The function then filters the dictionary to find integers with odd counts and returns the count of such integers.\nfunc countOddTimesNumbers(_ arr: [Int]) -> Int {\n    var counts = [Int: Int]()\n    \n    // Count the occurrences of each number in the array\n    for number in arr {\n        counts[number] = (counts[number] ?? 0) + 1\n    }\n    \n    // Filter numbers with odd counts and return the count of such numbers\n    let oddTimesNumbers = counts.filter { $0.value % 2 != 0 }\n    return oddTimesNumbers.count\n}\nfunc testCountOddTimesNumbers() {\n    assert(countOddTimesNumbers([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) == 2)\n    assert(countOddTimesNumbers([5, 5, 6, 6, 6, 7, 7, 7, 7]) == 1)\n    assert(countOddTimesNumbers([0, 0, 0, 0, 0]) == 1)\n    assert(countOddTimesNumbers([1, 2, 3, 4, 5]) == 5)\n    assert(countOddTimesNumbers([]) == 0)\n}\n\ntestCountOddTimesNumbers()", "exec_outcome": "PASSED"}
{"code": "// isScheduleFeasible determines if a medication schedule is feasible without any overlapping times.\n// It checks each medication's times and ensures no time is repeated across all medications.\n// If any time is found to be overlapping, it returns \"Not Feasible\"; otherwise, it returns \"Feasible\".\nfunc isScheduleFeasible(n: Int, medicationList: [(name: String, count: Int, times: [Int])]) -> String {\n    var takenTimes = Set<Int>()\n    \n    for medication in medicationList {\n        for time in medication.times {\n            if takenTimes.contains(time) {\n                return \"Not Feasible\"\n            }\n            takenTimes.insert(time)\n        }\n    }\n    \n    return \"Feasible\"\n}", "test_cases": "", "test_case_results": "Input:\nNumber of medications: 2\nMedication list: [(name: \"Aspirin\", count: 2, times: [8, 20]), (name: \"VitaminD\", count: 3, times: [7, 13, 19])]\nResult: Feasible\n---\nInput:\nNumber of medications: 3\nMedication list: [(name: \"MedA\", count: 2, times: [8, 16]), (name: \"MedB\", count: 1, times: [16]), (name: \"MedC\", count: 3, times: [9, 12, 15])]\nResult: Not Feasible\n---\nInput:\nNumber of medications: 1\nMedication list: [(name: \"MedX\", count: 4, times: [6, 12, 18, 24])]\nResult: Feasible\n---", "task_id": 26117, "assertions": "func testIsScheduleFeasible() {\n    let testCases: [(n: Int, medicationList: [(name: String, count: Int, times: [Int])], expected: String)] = [\n        (\n            2,\n            [\n                (\"Aspirin\", 2, [8, 20]),\n                (\"VitaminD\", 3, [7, 13, 19])\n            ],\n            \"Feasible\"\n        ),\n        (\n            3,\n            [\n                (\"MedA\", 2, [8, 16]),\n                (\"MedB\", 1, [16]),\n                (\"MedC\", 3, [9, 12, 15])\n            ],\n            \"Not Feasible\"\n        ),\n        (\n            1,\n            [\n                (\"MedX\", 4, [6, 12, 18, 24])\n            ],\n            \"Feasible\"\n        )\n    ]\n    \n    for testCase in testCases {\n        let result = isScheduleFeasible(n: testCase.n, medicationList: testCase.medicationList)\n        assert(result == testCase.expected, \"Test failed for input: \\(testCase.medicationList). Expected: \\(testCase.expected), got: \\(result)\")\n    }\n}\n\ntestIsScheduleFeasible()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsScheduleFeasible() {\n    let testCases: [(n: Int, medicationList: [(name: String, count: Int, times: [Int])], expected: String)] = [\n        (\n            2,\n            [\n                (\"Aspirin\", 2, [8, 20]),\n                (\"VitaminD\", 3, [7, 13, 19])\n            ],\n            \"Feasible\"\n        ),\n        (\n            3,\n            [\n                (\"MedA\", 2, [8, 16]),\n                (\"MedB\", 1, [16]),\n                (\"MedC\", 3, [9, 12, 15])\n            ],\n            \"Not Feasible\"\n        ),\n        (\n            1,\n            [\n                (\"MedX\", 4, [6, 12, 18, 24])\n            ],\n            \"Feasible\"\n        )\n    ]\n    \n    for testCase in testCases {\n        let result = isScheduleFeasible(n: testCase.n, medicationList: testCase.medicationList)\n        assert(result == testCase.expected, \"Test failed for input: \\(testCase.medicationList). Expected: \\(testCase.expected), got: \\(result)\")\n    }\n}\n\ntestIsScheduleFeasible()", "output": "isScheduleFeasible"}, "all_code": "// isScheduleFeasible determines if a medication schedule is feasible without any overlapping times.\n// It checks each medication's times and ensures no time is repeated across all medications.\n// If any time is found to be overlapping, it returns \"Not Feasible\"; otherwise, it returns \"Feasible\".\nfunc isScheduleFeasible(n: Int, medicationList: [(name: String, count: Int, times: [Int])]) -> String {\n    var takenTimes = Set<Int>()\n    \n    for medication in medicationList {\n        for time in medication.times {\n            if takenTimes.contains(time) {\n                return \"Not Feasible\"\n            }\n            takenTimes.insert(time)\n        }\n    }\n    \n    return \"Feasible\"\n}\nfunc testIsScheduleFeasible() {\n    let testCases: [(n: Int, medicationList: [(name: String, count: Int, times: [Int])], expected: String)] = [\n        (\n            2,\n            [\n                (\"Aspirin\", 2, [8, 20]),\n                (\"VitaminD\", 3, [7, 13, 19])\n            ],\n            \"Feasible\"\n        ),\n        (\n            3,\n            [\n                (\"MedA\", 2, [8, 16]),\n                (\"MedB\", 1, [16]),\n                (\"MedC\", 3, [9, 12, 15])\n            ],\n            \"Not Feasible\"\n        ),\n        (\n            1,\n            [\n                (\"MedX\", 4, [6, 12, 18, 24])\n            ],\n            \"Feasible\"\n        )\n    ]\n    \n    for testCase in testCases {\n        let result = isScheduleFeasible(n: testCase.n, medicationList: testCase.medicationList)\n        assert(result == testCase.expected, \"Test failed for input: \\(testCase.medicationList). Expected: \\(testCase.expected), got: \\(result)\")\n    }\n}\n\ntestIsScheduleFeasible()", "exec_outcome": "PASSED"}
{"code": "// nonConflictingTasks calculates the maximum number of non-conflicting tasks that can be performed.\n// Each task is represented by a start and end time, provided as an array of tuples.\n// The function sorts the tasks by their end time and then iterates through them to count non-conflicting tasks.\nfunc nonConflictingTasks(intervals: [(start: Int, end: Int)]) -> Int {\n    if intervals.isEmpty {\n        return 0\n    }\n\n    // Sort intervals by end time\n    let sortedIntervals = intervals.sorted { $0.end < $1.end }\n\n    var count = 1  // We can always take at least one task\n    var endTime = sortedIntervals[0].end\n\n    for i in 1..<sortedIntervals.count {\n        if sortedIntervals[i].start >= endTime {\n            count += 1\n            endTime = sortedIntervals[i].end\n        }\n    }\n\n    return count\n}", "test_cases": "", "test_case_results": "Input intervals: [(start: 1, end: 3), (start: 2, end: 5), (start: 4, end: 6), (start: 7, end: 9)]\nMaximum non-conflicting tasks: 3\nInput intervals: [(start: 1, end: 2), (start: 3, end: 4), (start: 5, end: 6)]\nMaximum non-conflicting tasks: 3\nInput intervals: [(start: 1, end: 5), (start: 2, end: 3), (start: 4, end: 6)]\nMaximum non-conflicting tasks: 2\nInput intervals: []\nMaximum non-conflicting tasks: 0\nInput intervals: [(start: 1, end: 4), (start: 4, end: 6)]\nMaximum non-conflicting tasks: 2", "task_id": 2287, "assertions": "func testNonConflictingTasks() {\n    assert(nonConflictingTasks(intervals: [(1, 3), (2, 5), (4, 6), (7, 9)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 2), (3, 4), (5, 6)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(nonConflictingTasks(intervals: []) == 0)\n    assert(nonConflictingTasks(intervals: [(1, 4), (4, 6)]) == 2)\n}\n\ntestNonConflictingTasks()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testNonConflictingTasks() {\n    assert(nonConflictingTasks(intervals: [(1, 3), (2, 5), (4, 6), (7, 9)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 2), (3, 4), (5, 6)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(nonConflictingTasks(intervals: []) == 0)\n    assert(nonConflictingTasks(intervals: [(1, 4), (4, 6)]) == 2)\n}\n\ntestNonConflictingTasks()", "output": "nonConflictingTasks"}, "all_code": "// nonConflictingTasks calculates the maximum number of non-conflicting tasks that can be performed.\n// Each task is represented by a start and end time, provided as an array of tuples.\n// The function sorts the tasks by their end time and then iterates through them to count non-conflicting tasks.\nfunc nonConflictingTasks(intervals: [(start: Int, end: Int)]) -> Int {\n    if intervals.isEmpty {\n        return 0\n    }\n\n    // Sort intervals by end time\n    let sortedIntervals = intervals.sorted { $0.end < $1.end }\n\n    var count = 1  // We can always take at least one task\n    var endTime = sortedIntervals[0].end\n\n    for i in 1..<sortedIntervals.count {\n        if sortedIntervals[i].start >= endTime {\n            count += 1\n            endTime = sortedIntervals[i].end\n        }\n    }\n\n    return count\n}\nfunc testNonConflictingTasks() {\n    assert(nonConflictingTasks(intervals: [(1, 3), (2, 5), (4, 6), (7, 9)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 2), (3, 4), (5, 6)]) == 3)\n    assert(nonConflictingTasks(intervals: [(1, 5), (2, 3), (4, 6)]) == 2)\n    assert(nonConflictingTasks(intervals: []) == 0)\n    assert(nonConflictingTasks(intervals: [(1, 4), (4, 6)]) == 2)\n}\n\ntestNonConflictingTasks()", "exec_outcome": "PASSED"}
{"code": "// isMultipleOfThree checks if the binary number represented by the string is a multiple of 3.\n// It converts the binary string to an integer and then checks if the integer is divisible by 3.\n// If the string is empty or contains non-binary characters, it will cause a runtime error.\nfunc isMultipleOfThree(_ s: String) -> Bool {\n    // Convert the binary string to an integer\n    let num = Int(s, radix: 2) ?? 0\n    \n    // Check if the number is divisible by 3\n    return num % 3 == 0\n}", "test_cases": "", "test_case_results": "Input: \"0\"\nIs multiple of 3: true\nInput: \"1\"\nIs multiple of 3: false\nInput: \"11\"\nIs multiple of 3: true\nInput: \"100\"\nIs multiple of 3: false\nInput: \"110\"\nIs multiple of 3: true\nInput: \"1001\"\nIs multiple of 3: true\nInput: \"1010\"\nIs multiple of 3: false\nInput: \"1100\"\nIs multiple of 3: true", "task_id": 4459, "assertions": "func testIsMultipleOfThree() {\n    assert(isMultipleOfThree(\"0\") == true)\n    assert(isMultipleOfThree(\"1\") == false)\n    assert(isMultipleOfThree(\"11\") == true)\n    assert(isMultipleOfThree(\"100\") == false)\n    assert(isMultipleOfThree(\"110\") == true)\n    assert(isMultipleOfThree(\"1001\") == true)\n    assert(isMultipleOfThree(\"1010\") == false)\n    assert(isMultipleOfThree(\"1100\") == true)\n}\n\ntestIsMultipleOfThree()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsMultipleOfThree() {\n    assert(isMultipleOfThree(\"0\") == true)\n    assert(isMultipleOfThree(\"1\") == false)\n    assert(isMultipleOfThree(\"11\") == true)\n    assert(isMultipleOfThree(\"100\") == false)\n    assert(isMultipleOfThree(\"110\") == true)\n    assert(isMultipleOfThree(\"1001\") == true)\n    assert(isMultipleOfThree(\"1010\") == false)\n    assert(isMultipleOfThree(\"1100\") == true)\n}\n\ntestIsMultipleOfThree()", "output": "isMultipleOfThree"}, "all_code": "// isMultipleOfThree checks if the binary number represented by the string is a multiple of 3.\n// It converts the binary string to an integer and then checks if the integer is divisible by 3.\n// If the string is empty or contains non-binary characters, it will cause a runtime error.\nfunc isMultipleOfThree(_ s: String) -> Bool {\n    // Convert the binary string to an integer\n    let num = Int(s, radix: 2) ?? 0\n    \n    // Check if the number is divisible by 3\n    return num % 3 == 0\n}\nfunc testIsMultipleOfThree() {\n    assert(isMultipleOfThree(\"0\") == true)\n    assert(isMultipleOfThree(\"1\") == false)\n    assert(isMultipleOfThree(\"11\") == true)\n    assert(isMultipleOfThree(\"100\") == false)\n    assert(isMultipleOfThree(\"110\") == true)\n    assert(isMultipleOfThree(\"1001\") == true)\n    assert(isMultipleOfThree(\"1010\") == false)\n    assert(isMultipleOfThree(\"1100\") == true)\n}\n\ntestIsMultipleOfThree()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// fastestDeliveryTimes calculates the fastest delivery time between pairs of nodes in a graph,\n// considering facilities that can potentially reduce the delivery time.\n// The function uses Dijkstra's algorithm to find the shortest path, taking into account whether a facility is present on the path.\nfunc fastestDeliveryTimes(n: Int, m: Int, q: Int, facilities: [Int], roads: [(Int, Int, Int)], queries: [(Int, Int)]) -> [Int] {\n    // Build the adjacency list for the graph\n    var graph = [[(Int, Int)]](repeating: [], count: n + 1)\n    for (x, y, d) in roads {\n        graph[x].append((y, d))\n    }\n    \n    // Dijkstra's algorithm to find the shortest path from source to target, considering facilities\n    func dijkstra(source: Int, target: Int) -> Int {\n        // Priority queue represented as a heap, storing tuples of (time, node, hasFacility)\n        var pq = [(0, source, false)]\n        // Distance dictionary to keep track of the shortest time to reach each node\n        var dist = [Int](repeating: Int.max, count: n + 1)\n        dist[source] = 0\n        \n        while !pq.isEmpty {\n            // Extract the node with the smallest time\n            let (time, node, hasFacility) = pq.removeFirst()\n            \n            // If the target node is reached and either has a facility or the path includes a facility, return the time\n            if node == target {\n                if hasFacility || facilities[node - 1] == 1 {\n                    return time\n                }\n            }\n            \n            // Explore all neighbors\n            for (neighbor, d) in graph[node] {\n                let newDist = time + d\n                // If a shorter path is found, update the distance and add to the priority queue\n                if newDist < dist[neighbor] {\n                    dist[neighbor] = newDist\n                    pq.append((newDist, neighbor, hasFacility || facilities[neighbor - 1] == 1))\n                    // Maintain the priority queue by sorting (simulating a heap)\n                    pq.sort { $0.0 < $1.0 }\n                }\n            }\n        }\n        return -1\n    }\n    \n    // Process each query and collect results\n    var results = [Int]()\n    for (u, v) in queries {\n        let result = dijkstra(source: u, target: v)\n        results.append(result)\n    }\n    \n    return results\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 3, m: 3, q: 2\nFacilities: [1, 0, 1]\nRoads: [(1, 2, 1), (2, 3, 2), (1, 3, 4)]\nQueries: [(1, 3), (2, 3)]\nResults: [3, 2]\n\nTest Case 2:\nn: 4, m: 4, q: 2\nFacilities: [0, 1, 0, 1]\nRoads: [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)]\nQueries: [(1, 4), (2, 4)]\nResults: [6, 5]", "task_id": 13243, "assertions": "func testFastestDeliveryTimes() {\n    // Test Case 1\n    let result1 = fastestDeliveryTimes(\n        n: 3,\n        m: 3,\n        q: 2,\n        facilities: [1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (1, 3, 4)],\n        queries: [(1, 3), (2, 3)]\n    )\n    assert(result1 == [3, 2])\n    \n    // Test Case 2\n    let result2 = fastestDeliveryTimes(\n        n: 4,\n        m: 4,\n        q: 2,\n        facilities: [0, 1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)],\n        queries: [(1, 4), (2, 4)]\n    )\n    assert(result2 == [6, 5])\n}\n\ntestFastestDeliveryTimes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFastestDeliveryTimes() {\n    // Test Case 1\n    let result1 = fastestDeliveryTimes(\n        n: 3,\n        m: 3,\n        q: 2,\n        facilities: [1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (1, 3, 4)],\n        queries: [(1, 3), (2, 3)]\n    )\n    assert(result1 == [3, 2])\n    \n    // Test Case 2\n    let result2 = fastestDeliveryTimes(\n        n: 4,\n        m: 4,\n        q: 2,\n        facilities: [0, 1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)],\n        queries: [(1, 4), (2, 4)]\n    )\n    assert(result2 == [6, 5])\n}\n\ntestFastestDeliveryTimes()", "output": "fastestDeliveryTimes"}, "all_code": "import Foundation\n\n// fastestDeliveryTimes calculates the fastest delivery time between pairs of nodes in a graph,\n// considering facilities that can potentially reduce the delivery time.\n// The function uses Dijkstra's algorithm to find the shortest path, taking into account whether a facility is present on the path.\nfunc fastestDeliveryTimes(n: Int, m: Int, q: Int, facilities: [Int], roads: [(Int, Int, Int)], queries: [(Int, Int)]) -> [Int] {\n    // Build the adjacency list for the graph\n    var graph = [[(Int, Int)]](repeating: [], count: n + 1)\n    for (x, y, d) in roads {\n        graph[x].append((y, d))\n    }\n    \n    // Dijkstra's algorithm to find the shortest path from source to target, considering facilities\n    func dijkstra(source: Int, target: Int) -> Int {\n        // Priority queue represented as a heap, storing tuples of (time, node, hasFacility)\n        var pq = [(0, source, false)]\n        // Distance dictionary to keep track of the shortest time to reach each node\n        var dist = [Int](repeating: Int.max, count: n + 1)\n        dist[source] = 0\n        \n        while !pq.isEmpty {\n            // Extract the node with the smallest time\n            let (time, node, hasFacility) = pq.removeFirst()\n            \n            // If the target node is reached and either has a facility or the path includes a facility, return the time\n            if node == target {\n                if hasFacility || facilities[node - 1] == 1 {\n                    return time\n                }\n            }\n            \n            // Explore all neighbors\n            for (neighbor, d) in graph[node] {\n                let newDist = time + d\n                // If a shorter path is found, update the distance and add to the priority queue\n                if newDist < dist[neighbor] {\n                    dist[neighbor] = newDist\n                    pq.append((newDist, neighbor, hasFacility || facilities[neighbor - 1] == 1))\n                    // Maintain the priority queue by sorting (simulating a heap)\n                    pq.sort { $0.0 < $1.0 }\n                }\n            }\n        }\n        return -1\n    }\n    \n    // Process each query and collect results\n    var results = [Int]()\n    for (u, v) in queries {\n        let result = dijkstra(source: u, target: v)\n        results.append(result)\n    }\n    \n    return results\n}\nfunc testFastestDeliveryTimes() {\n    // Test Case 1\n    let result1 = fastestDeliveryTimes(\n        n: 3,\n        m: 3,\n        q: 2,\n        facilities: [1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (1, 3, 4)],\n        queries: [(1, 3), (2, 3)]\n    )\n    assert(result1 == [3, 2])\n    \n    // Test Case 2\n    let result2 = fastestDeliveryTimes(\n        n: 4,\n        m: 4,\n        q: 2,\n        facilities: [0, 1, 0, 1],\n        roads: [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10)],\n        queries: [(1, 4), (2, 4)]\n    )\n    assert(result2 == [6, 5])\n}\n\ntestFastestDeliveryTimes()", "exec_outcome": "PASSED"}
{"code": "// minDifferenceOfBooks calculates the minimum possible difference between the sums of thicknesses of two groups of books.\n// It uses dynamic programming to determine the closest possible sum to half of the total sum of thicknesses.\n// The function returns the minimum difference achievable by splitting the books into two groups.\nfunc minDifferenceOfBooks(n: Int, thicknesses: [Int]) -> Int {\n    let totalSum = thicknesses.reduce(0, +)\n    let halfSum = totalSum / 2\n    var dp = [Bool](repeating: false, count: halfSum + 1)\n    dp[0] = true\n\n    for t in thicknesses {\n        for j in stride(from: halfSum, through: t, by: -1) {\n            if dp[j - t] {\n                dp[j] = true\n            }\n        }\n    }\n\n    var j = halfSum\n    while j >= 0 {\n        if dp[j] {\n            let diff = totalSum - 2 * j\n            return diff\n        }\n        j -= 1\n    }\n\n    return totalSum\n}", "test_cases": "", "test_case_results": "Number of books: 4, Thicknesses: [1, 2, 3, 4]\nMinimum difference: 0\nNumber of books: 5, Thicknesses: [5, 6, 7, 0, 1]\nMinimum difference: 3\nNumber of books: 3, Thicknesses: [10, 20, 30]\nMinimum difference: 0\nNumber of books: 2, Thicknesses: [1, 1]\nMinimum difference: 0", "task_id": 26455, "assertions": "func testMinDifferenceOfBooks() {\n    assert(minDifferenceOfBooks(n: 4, thicknesses: [1, 2, 3, 4]) == 0)\n    assert(minDifferenceOfBooks(n: 5, thicknesses: [5, 6, 7, 0, 1]) == 3)\n    assert(minDifferenceOfBooks(n: 3, thicknesses: [10, 20, 30]) == 0)\n    assert(minDifferenceOfBooks(n: 2, thicknesses: [1, 1]) == 0)\n}\n\ntestMinDifferenceOfBooks()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinDifferenceOfBooks() {\n    assert(minDifferenceOfBooks(n: 4, thicknesses: [1, 2, 3, 4]) == 0)\n    assert(minDifferenceOfBooks(n: 5, thicknesses: [5, 6, 7, 0, 1]) == 3)\n    assert(minDifferenceOfBooks(n: 3, thicknesses: [10, 20, 30]) == 0)\n    assert(minDifferenceOfBooks(n: 2, thicknesses: [1, 1]) == 0)\n}\n\ntestMinDifferenceOfBooks()", "output": "minDifferenceOfBooks"}, "all_code": "// minDifferenceOfBooks calculates the minimum possible difference between the sums of thicknesses of two groups of books.\n// It uses dynamic programming to determine the closest possible sum to half of the total sum of thicknesses.\n// The function returns the minimum difference achievable by splitting the books into two groups.\nfunc minDifferenceOfBooks(n: Int, thicknesses: [Int]) -> Int {\n    let totalSum = thicknesses.reduce(0, +)\n    let halfSum = totalSum / 2\n    var dp = [Bool](repeating: false, count: halfSum + 1)\n    dp[0] = true\n\n    for t in thicknesses {\n        for j in stride(from: halfSum, through: t, by: -1) {\n            if dp[j - t] {\n                dp[j] = true\n            }\n        }\n    }\n\n    var j = halfSum\n    while j >= 0 {\n        if dp[j] {\n            let diff = totalSum - 2 * j\n            return diff\n        }\n        j -= 1\n    }\n\n    return totalSum\n}\nfunc testMinDifferenceOfBooks() {\n    assert(minDifferenceOfBooks(n: 4, thicknesses: [1, 2, 3, 4]) == 0)\n    assert(minDifferenceOfBooks(n: 5, thicknesses: [5, 6, 7, 0, 1]) == 3)\n    assert(minDifferenceOfBooks(n: 3, thicknesses: [10, 20, 30]) == 0)\n    assert(minDifferenceOfBooks(n: 2, thicknesses: [1, 1]) == 0)\n}\n\ntestMinDifferenceOfBooks()", "exec_outcome": "PASSED"}
{"code": "// minModificationsToAlternating calculates the minimum number of contiguous substrings \n// that need to be modified to make a binary string alternating (i.e., no two adjacent characters are the same).\n// The function counts the number of contiguous same characters and then determines the minimum modifications needed.\nfunc minModificationsToAlternating(binaryString: String) -> Int {\n    let n = binaryString.count\n    \n    // If the length of the binary string is <= 1, no modifications are needed.\n    if n <= 1 {\n        return 0\n    }\n    \n    var modifications = 0\n    let characters = Array(binaryString)\n    \n    // Traverse through the binary string to count the number of contiguous same characters.\n    for i in 1..<n {\n        if characters[i] == characters[i - 1] {\n            modifications += 1\n        }\n    }\n    \n    // Each pair of same character accounts for one modification.\n    return (modifications + 1) / 2\n}", "test_cases": "", "test_case_results": "Input: \"0000\"\nMinimum modifications: 2\nInput: \"0101\"\nMinimum modifications: 0\nInput: \"0011\"\nMinimum modifications: 1\nInput: \"0\"\nMinimum modifications: 0\nInput: \"01\"\nMinimum modifications: 0\nInput: \"011\"\nMinimum modifications: 1\nInput: \"0110\"\nMinimum modifications: 1\nInput: \"0111\"\nMinimum modifications: 1", "task_id": 19102, "assertions": "func testMinModificationsToAlternating() {\n    assert(minModificationsToAlternating(binaryString: \"0000\") == 2)\n    assert(minModificationsToAlternating(binaryString: \"0101\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"0011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"01\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0110\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0111\") == 1)\n}\n\ntestMinModificationsToAlternating()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinModificationsToAlternating() {\n    assert(minModificationsToAlternating(binaryString: \"0000\") == 2)\n    assert(minModificationsToAlternating(binaryString: \"0101\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"0011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"01\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0110\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0111\") == 1)\n}\n\ntestMinModificationsToAlternating()", "output": "minModificationsToAlternating"}, "all_code": "// minModificationsToAlternating calculates the minimum number of contiguous substrings \n// that need to be modified to make a binary string alternating (i.e., no two adjacent characters are the same).\n// The function counts the number of contiguous same characters and then determines the minimum modifications needed.\nfunc minModificationsToAlternating(binaryString: String) -> Int {\n    let n = binaryString.count\n    \n    // If the length of the binary string is <= 1, no modifications are needed.\n    if n <= 1 {\n        return 0\n    }\n    \n    var modifications = 0\n    let characters = Array(binaryString)\n    \n    // Traverse through the binary string to count the number of contiguous same characters.\n    for i in 1..<n {\n        if characters[i] == characters[i - 1] {\n            modifications += 1\n        }\n    }\n    \n    // Each pair of same character accounts for one modification.\n    return (modifications + 1) / 2\n}\nfunc testMinModificationsToAlternating() {\n    assert(minModificationsToAlternating(binaryString: \"0000\") == 2)\n    assert(minModificationsToAlternating(binaryString: \"0101\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"0011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"01\") == 0)\n    assert(minModificationsToAlternating(binaryString: \"011\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0110\") == 1)\n    assert(minModificationsToAlternating(binaryString: \"0111\") == 1)\n}\n\ntestMinModificationsToAlternating()", "exec_outcome": "PASSED"}
{"code": "// DynamicArray is a simple implementation of a dynamic array in Swift.\n// It provides methods to append elements, retrieve and remove the last element, and find the maximum element.\nstruct DynamicArray {\n    private var array: [Int] = []\n    \n    // Appends an integer to the end of the array.\n    mutating func append(_ x: Int) {\n        array.append(x)\n    }\n    \n    // Removes and returns the last element of the array.\n    // Returns nil if the array is empty.\n    mutating func getLast() -> Int? {\n        return array.isEmpty ? nil : array.removeLast()\n    }\n    \n    // Returns the maximum element in the array.\n    // Returns nil if the array is empty.\n    func getMax() -> Int? {\n        return array.max()\n    }\n}", "test_cases": "", "test_case_results": "Appended elements: 5, 10, 15\nLast element: 15\nAppended elements: 20, 25\nMax element: 25\nLast element: nil (array is empty)\nMax element: nil (array is empty)", "task_id": 26143, "assertions": "func testDynamicArray() {\n    // Test case 1: Append elements and get the last one\n    var dynamicArray1 = DynamicArray()\n    dynamicArray1.append(5)\n    dynamicArray1.append(10)\n    dynamicArray1.append(15)\n    assert(dynamicArray1.getLast() == 15)\n    \n    // Test case 2: Get the maximum element\n    var dynamicArray2 = DynamicArray()\n    dynamicArray2.append(20)\n    dynamicArray2.append(25)\n    assert(dynamicArray2.getMax() == 25)\n    \n    // Test case 3: Try to get the last element from an empty array\n    var emptyArray1 = DynamicArray()\n    assert(emptyArray1.getLast() == nil)\n    \n    // Test case 4: Try to get the max element from an empty array\n    var emptyArray2 = DynamicArray()\n    assert(emptyArray2.getMax() == nil)\n}\n\ntestDynamicArray()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testDynamicArray() {\n    // Test case 1: Append elements and get the last one\n    var dynamicArray1 = DynamicArray()\n    dynamicArray1.append(5)\n    dynamicArray1.append(10)\n    dynamicArray1.append(15)\n    assert(dynamicArray1.getLast() == 15)\n    \n    // Test case 2: Get the maximum element\n    var dynamicArray2 = DynamicArray()\n    dynamicArray2.append(20)\n    dynamicArray2.append(25)\n    assert(dynamicArray2.getMax() == 25)\n    \n    // Test case 3: Try to get the last element from an empty array\n    var emptyArray1 = DynamicArray()\n    assert(emptyArray1.getLast() == nil)\n    \n    // Test case 4: Try to get the max element from an empty array\n    var emptyArray2 = DynamicArray()\n    assert(emptyArray2.getMax() == nil)\n}\n\ntestDynamicArray()", "output": "DynamicArray"}, "all_code": "// DynamicArray is a simple implementation of a dynamic array in Swift.\n// It provides methods to append elements, retrieve and remove the last element, and find the maximum element.\nstruct DynamicArray {\n    private var array: [Int] = []\n    \n    // Appends an integer to the end of the array.\n    mutating func append(_ x: Int) {\n        array.append(x)\n    }\n    \n    // Removes and returns the last element of the array.\n    // Returns nil if the array is empty.\n    mutating func getLast() -> Int? {\n        return array.isEmpty ? nil : array.removeLast()\n    }\n    \n    // Returns the maximum element in the array.\n    // Returns nil if the array is empty.\n    func getMax() -> Int? {\n        return array.max()\n    }\n}\nfunc testDynamicArray() {\n    // Test case 1: Append elements and get the last one\n    var dynamicArray1 = DynamicArray()\n    dynamicArray1.append(5)\n    dynamicArray1.append(10)\n    dynamicArray1.append(15)\n    assert(dynamicArray1.getLast() == 15)\n    \n    // Test case 2: Get the maximum element\n    var dynamicArray2 = DynamicArray()\n    dynamicArray2.append(20)\n    dynamicArray2.append(25)\n    assert(dynamicArray2.getMax() == 25)\n    \n    // Test case 3: Try to get the last element from an empty array\n    var emptyArray1 = DynamicArray()\n    assert(emptyArray1.getLast() == nil)\n    \n    // Test case 4: Try to get the max element from an empty array\n    var emptyArray2 = DynamicArray()\n    assert(emptyArray2.getMax() == nil)\n}\n\ntestDynamicArray()", "exec_outcome": "PASSED"}
{"code": "// average calculates the average of an array of Double values.\n// If the input array is empty, it returns 0.0.\nfunc average(numbers: [Double]) -> Double {\n    if numbers.isEmpty {\n        return 0.0\n    }\n    let sum = numbers.reduce(0.0, +)\n    return sum / Double(numbers.count)\n}", "test_cases": "", "test_case_results": "Input: [1.0, 2.0, 3.0, 4.0]\nAverage: 2.5\nInput: [5.0, 6.0, 7.0, 0.0]\nAverage: 4.5\nInput: [0.0, 0.0, 0.0, 0.0]\nAverage: 0.0\nInput: []\nAverage: 0.0", "task_id": 22099, "assertions": "func testAverage() {\n    assert(average(numbers: [1.0, 2.0, 3.0, 4.0]) == 2.5)\n    assert(average(numbers: [5.0, 6.0, 7.0, 0.0]) == 4.5)\n    assert(average(numbers: [0.0, 0.0, 0.0, 0.0]) == 0.0)\n    assert(average(numbers: []) == 0.0)\n}\n\ntestAverage()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testAverage() {\n    assert(average(numbers: [1.0, 2.0, 3.0, 4.0]) == 2.5)\n    assert(average(numbers: [5.0, 6.0, 7.0, 0.0]) == 4.5)\n    assert(average(numbers: [0.0, 0.0, 0.0, 0.0]) == 0.0)\n    assert(average(numbers: []) == 0.0)\n}\n\ntestAverage()", "output": "average"}, "all_code": "// average calculates the average of an array of Double values.\n// If the input array is empty, it returns 0.0.\nfunc average(numbers: [Double]) -> Double {\n    if numbers.isEmpty {\n        return 0.0\n    }\n    let sum = numbers.reduce(0.0, +)\n    return sum / Double(numbers.count)\n}\nfunc testAverage() {\n    assert(average(numbers: [1.0, 2.0, 3.0, 4.0]) == 2.5)\n    assert(average(numbers: [5.0, 6.0, 7.0, 0.0]) == 4.5)\n    assert(average(numbers: [0.0, 0.0, 0.0, 0.0]) == 0.0)\n    assert(average(numbers: []) == 0.0)\n}\n\ntestAverage()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// capitalizeSentences capitalizes the first letter of each sentence in the given text.\n// A sentence is defined as ending with a period (.), exclamation mark (!), or question mark (?).\n// The function splits the text into sentences and punctuation marks, capitalizes the first letter of each sentence,\n// and then joins them back together.\nfunc capitalizeSentences(text: String) -> String {\n    // Split the text into sentences and punctuation marks using regular expression\n    let pattern = \"([.!?] )\"\n    guard let regex = try? NSRegularExpression(pattern: pattern) else {\n        return text\n    }\n    \n    let matches = regex.matches(in: text, range: NSRange(text.startIndex..., in: text))\n    var sentences: [String] = []\n    var previousEnd = text.startIndex\n    \n    for match in matches {\n        let range = match.range\n        if let sentenceRange = Range(range, in: text) {\n            let sentencePart = String(text[previousEnd..<sentenceRange.lowerBound])\n            let punctuationPart = String(text[sentenceRange.lowerBound..<sentenceRange.upperBound])\n            sentences.append(sentencePart)\n            sentences.append(punctuationPart)\n            previousEnd = sentenceRange.upperBound\n        }\n    }\n    \n    // Add the remaining part of the text if any\n    if previousEnd < text.endIndex {\n        let remainingPart = String(text[previousEnd...])\n        sentences.append(remainingPart)\n    }\n    \n    // Capitalize the first letter of each sentence\n    var capitalizedSentences: [String] = []\n    for i in 0..<sentences.count {\n        if i % 2 == 0 {\n            let sentence = sentences[i]\n            if !sentence.isEmpty {\n                let firstLetter = sentence.prefix(1).capitalized\n                let remainingLetters = sentence.dropFirst()\n                capitalizedSentences.append(firstLetter + remainingLetters)\n            } else {\n                capitalizedSentences.append(sentence)\n            }\n        } else {\n            capitalizedSentences.append(sentences[i])\n        }\n    }\n    \n    return capitalizedSentences.joined()\n}", "test_cases": "", "test_case_results": "Input: \"hello. world! how are you? i am fine.\"\nResult: \"Hello. World! How are you? I am fine.\"\n---\nInput: \"this is a test. another test! and another one? yes.\"\nResult: \"This is a test. Another test! And another one? Yes.\"\n---\nInput: \"no punctuation here\"\nResult: \"No punctuation here\"\n---\nInput: \"\"\nResult: \"\"\n---", "task_id": 23634, "assertions": "func testCapitalizeSentences() {\n    assert(capitalizeSentences(text: \"hello. world! how are you? i am fine.\") == \"Hello. World! How are you? I am fine.\")\n    assert(capitalizeSentences(text: \"this is a test. another test! and another one? yes.\") == \"This is a test. Another test! And another one? Yes.\")\n    assert(capitalizeSentences(text: \"no punctuation here\") == \"No punctuation here\")\n    assert(capitalizeSentences(text: \"\") == \"\")\n}\n\ntestCapitalizeSentences()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testCapitalizeSentences() {\n    assert(capitalizeSentences(text: \"hello. world! how are you? i am fine.\") == \"Hello. World! How are you? I am fine.\")\n    assert(capitalizeSentences(text: \"this is a test. another test! and another one? yes.\") == \"This is a test. Another test! And another one? Yes.\")\n    assert(capitalizeSentences(text: \"no punctuation here\") == \"No punctuation here\")\n    assert(capitalizeSentences(text: \"\") == \"\")\n}\n\ntestCapitalizeSentences()", "output": "capitalizeSentences"}, "all_code": "import Glibc\n\nimport Foundation\n\n// capitalizeSentences capitalizes the first letter of each sentence in the given text.\n// A sentence is defined as ending with a period (.), exclamation mark (!), or question mark (?).\n// The function splits the text into sentences and punctuation marks, capitalizes the first letter of each sentence,\n// and then joins them back together.\nfunc capitalizeSentences(text: String) -> String {\n    // Split the text into sentences and punctuation marks using regular expression\n    let pattern = \"([.!?] )\"\n    guard let regex = try? NSRegularExpression(pattern: pattern) else {\n        return text\n    }\n    \n    let matches = regex.matches(in: text, range: NSRange(text.startIndex..., in: text))\n    var sentences: [String] = []\n    var previousEnd = text.startIndex\n    \n    for match in matches {\n        let range = match.range\n        if let sentenceRange = Range(range, in: text) {\n            let sentencePart = String(text[previousEnd..<sentenceRange.lowerBound])\n            let punctuationPart = String(text[sentenceRange.lowerBound..<sentenceRange.upperBound])\n            sentences.append(sentencePart)\n            sentences.append(punctuationPart)\n            previousEnd = sentenceRange.upperBound\n        }\n    }\n    \n    // Add the remaining part of the text if any\n    if previousEnd < text.endIndex {\n        let remainingPart = String(text[previousEnd...])\n        sentences.append(remainingPart)\n    }\n    \n    // Capitalize the first letter of each sentence\n    var capitalizedSentences: [String] = []\n    for i in 0..<sentences.count {\n        if i % 2 == 0 {\n            let sentence = sentences[i]\n            if !sentence.isEmpty {\n                let firstLetter = sentence.prefix(1).capitalized\n                let remainingLetters = sentence.dropFirst()\n                capitalizedSentences.append(firstLetter + remainingLetters)\n            } else {\n                capitalizedSentences.append(sentence)\n            }\n        } else {\n            capitalizedSentences.append(sentences[i])\n        }\n    }\n    \n    return capitalizedSentences.joined()\n}\nfunc testCapitalizeSentences() {\n    assert(capitalizeSentences(text: \"hello. world! how are you? i am fine.\") == \"Hello. World! How are you? I am fine.\")\n    assert(capitalizeSentences(text: \"this is a test. another test! and another one? yes.\") == \"This is a test. Another test! And another one? Yes.\")\n    assert(capitalizeSentences(text: \"no punctuation here\") == \"No punctuation here\")\n    assert(capitalizeSentences(text: \"\") == \"\")\n}\n\ntestCapitalizeSentences()", "exec_outcome": "PASSED"}
{"code": "// extractFirstAndLastChars returns a new string containing only the first and last characters of the original string.\n// If the input string has fewer than 2 characters, it returns the string as is.\nfunc extractFirstAndLastChars(_ s: String) -> String {\n    if s.count < 2 {\n        return s\n    }\n    let firstChar = s.first!\n    let lastChar = s.last!\n    return String(firstChar) + String(lastChar)\n}", "test_cases": "", "test_case_results": "Input: \"hello\"\nResult: \"ho\"\nInput: \"a\"\nResult: \"a\"\nInput: \"swift\"\nResult: \"st\"\nInput: \"hi\"\nResult: \"hi\"\nInput: \"\"\nResult: \"\"", "task_id": 21011, "assertions": "func testExtractFirstAndLastChars() {\n    assert(extractFirstAndLastChars(\"hello\") == \"ho\")\n    assert(extractFirstAndLastChars(\"a\") == \"a\")\n    assert(extractFirstAndLastChars(\"swift\") == \"st\")\n    assert(extractFirstAndLastChars(\"hi\") == \"hi\")\n    assert(extractFirstAndLastChars(\"\") == \"\")\n}\n\ntestExtractFirstAndLastChars()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testExtractFirstAndLastChars() {\n    assert(extractFirstAndLastChars(\"hello\") == \"ho\")\n    assert(extractFirstAndLastChars(\"a\") == \"a\")\n    assert(extractFirstAndLastChars(\"swift\") == \"st\")\n    assert(extractFirstAndLastChars(\"hi\") == \"hi\")\n    assert(extractFirstAndLastChars(\"\") == \"\")\n}\n\ntestExtractFirstAndLastChars()", "output": "extractFirstAndLastChars"}, "all_code": "// extractFirstAndLastChars returns a new string containing only the first and last characters of the original string.\n// If the input string has fewer than 2 characters, it returns the string as is.\nfunc extractFirstAndLastChars(_ s: String) -> String {\n    if s.count < 2 {\n        return s\n    }\n    let firstChar = s.first!\n    let lastChar = s.last!\n    return String(firstChar) + String(lastChar)\n}\nfunc testExtractFirstAndLastChars() {\n    assert(extractFirstAndLastChars(\"hello\") == \"ho\")\n    assert(extractFirstAndLastChars(\"a\") == \"a\")\n    assert(extractFirstAndLastChars(\"swift\") == \"st\")\n    assert(extractFirstAndLastChars(\"hi\") == \"hi\")\n    assert(extractFirstAndLastChars(\"\") == \"\")\n}\n\ntestExtractFirstAndLastChars()", "exec_outcome": "PASSED"}
{"code": "// numUniqueIslands calculates the number of unique islands in a given grid.\n// An island is represented by '.' and water by '#'. The function uses Depth-First Search (DFS) to explore each island.\n// Once an island is visited, it's marked as water to avoid counting it again.\nfunc numUniqueIslands(n: Int, m: Int, grid: inout [[Character]]) -> Int {\n    // Define the four possible directions to move in the grid (up, down, left, right)\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    // Nested DFS function to explore all connected '.' cells starting from (x, y)\n    func dfs(x: Int, y: Int) {\n        var stack = [(x, y)]\n        while !stack.isEmpty {\n            let (i, j) = stack.removeLast()\n            for (di, dj) in directions {\n                let ni = i + di\n                let nj = j + dj\n                // Check if the new position is within bounds and is part of an unvisited island\n                if ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == \".\" {\n                    stack.append((ni, nj))\n                    grid[ni][nj] = \"#\" // Mark the cell as visited\n                }\n            }\n        }\n    }\n    \n    var islandCount = 0\n    // Iterate through each cell in the grid\n    for i in 0..<n {\n        for j in 0..<m {\n            if grid[i][j] == \".\" {\n                // If an unvisited island is found, explore it and increment the count\n                dfs(x: i, y: j)\n                islandCount += 1\n            }\n        }\n    }\n    return islandCount\n}", "test_cases": "", "test_case_results": "Input Grid:\n. . #\n# . #\n# # .\nNumber of unique islands: 2\n---\nInput Grid:\n. # # #\n. # # #\n# . . #\n# # # .\nNumber of unique islands: 3\n---\nInput Grid:\n.\nNumber of unique islands: 1\n---\nInput Grid:\n# #\n# #\nNumber of unique islands: 0\n---", "task_id": 4947, "assertions": "func testNumUniqueIslands() {\n    var grid1 = [\n        [\".\", \".\", \"#\"],\n        [\"#\", \".\", \"#\"],\n        [\"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 3, m: 3, grid: &grid1) == 2)\n    \n    var grid2 = [\n        [\".\", \"#\", \"#\", \"#\"],\n        [\".\", \"#\", \"#\", \"#\"],\n        [\"#\", \".\", \".\", \"#\"],\n        [\"#\", \"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 4, m: 4, grid: &grid2) == 3)\n    \n    var grid3 = [\n        [\".\"]\n    ]\n    assert(numUniqueIslands(n: 1, m: 1, grid: &grid3) == 1)\n    \n    var grid4 = [\n        [\"#\", \"#\"],\n        [\"#\", \"#\"]\n    ]\n    assert(numUniqueIslands(n: 2, m: 2, grid: &grid4) == 0)\n}\n\ntestNumUniqueIslands()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testNumUniqueIslands() {\n    var grid1 = [\n        [\".\", \".\", \"#\"],\n        [\"#\", \".\", \"#\"],\n        [\"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 3, m: 3, grid: &grid1) == 2)\n    \n    var grid2 = [\n        [\".\", \"#\", \"#\", \"#\"],\n        [\".\", \"#\", \"#\", \"#\"],\n        [\"#\", \".\", \".\", \"#\"],\n        [\"#\", \"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 4, m: 4, grid: &grid2) == 3)\n    \n    var grid3 = [\n        [\".\"]\n    ]\n    assert(numUniqueIslands(n: 1, m: 1, grid: &grid3) == 1)\n    \n    var grid4 = [\n        [\"#\", \"#\"],\n        [\"#\", \"#\"]\n    ]\n    assert(numUniqueIslands(n: 2, m: 2, grid: &grid4) == 0)\n}\n\ntestNumUniqueIslands()", "output": "numUniqueIslands"}, "all_code": "import Foundation\nimport Glibc\n\n// numUniqueIslands calculates the number of unique islands in a given grid.\n// An island is represented by '.' and water by '#'. The function uses Depth-First Search (DFS) to explore each island.\n// Once an island is visited, it's marked as water to avoid counting it again.\nfunc numUniqueIslands(n: Int, m: Int, grid: inout [[Character]]) -> Int {\n    // Define the four possible directions to move in the grid (up, down, left, right)\n    let directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    // Nested DFS function to explore all connected '.' cells starting from (x, y)\n    func dfs(x: Int, y: Int) {\n        var stack = [(x, y)]\n        while !stack.isEmpty {\n            let (i, j) = stack.removeLast()\n            for (di, dj) in directions {\n                let ni = i + di\n                let nj = j + dj\n                // Check if the new position is within bounds and is part of an unvisited island\n                if ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == \".\" {\n                    stack.append((ni, nj))\n                    grid[ni][nj] = \"#\" // Mark the cell as visited\n                }\n            }\n        }\n    }\n    \n    var islandCount = 0\n    // Iterate through each cell in the grid\n    for i in 0..<n {\n        for j in 0..<m {\n            if grid[i][j] == \".\" {\n                // If an unvisited island is found, explore it and increment the count\n                dfs(x: i, y: j)\n                islandCount += 1\n            }\n        }\n    }\n    return islandCount\n}\nfunc testNumUniqueIslands() {\n    var grid1 = [\n        [\".\", \".\", \"#\"],\n        [\"#\", \".\", \"#\"],\n        [\"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 3, m: 3, grid: &grid1) == 2)\n    \n    var grid2 = [\n        [\".\", \"#\", \"#\", \"#\"],\n        [\".\", \"#\", \"#\", \"#\"],\n        [\"#\", \".\", \".\", \"#\"],\n        [\"#\", \"#\", \"#\", \".\"]\n    ]\n    assert(numUniqueIslands(n: 4, m: 4, grid: &grid2) == 3)\n    \n    var grid3 = [\n        [\".\"]\n    ]\n    assert(numUniqueIslands(n: 1, m: 1, grid: &grid3) == 1)\n    \n    var grid4 = [\n        [\"#\", \"#\"],\n        [\"#\", \"#\"]\n    ]\n    assert(numUniqueIslands(n: 2, m: 2, grid: &grid4) == 0)\n}\n\ntestNumUniqueIslands()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// addIndexToElements takes an array of integers and returns a new array where each element\n// is the sum of the original element and its corresponding index in the array.\n// This is achieved by iterating through the array and adding the index to each element.\nfunc addIndexToElements(_ list: [Int]) -> [Int] {\n    return list.enumerated().map { index, element in\n        return element + index\n    }\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nResult: [1, 3, 5, 7]\nInput: [0, 0, 0, 0]\nResult: [0, 1, 2, 3]\nInput: [10, 20, 30]\nResult: [10, 21, 32]\nInput: []\nResult: []", "task_id": 12857, "assertions": "func testAddIndexToElements() {\n    assert(addIndexToElements([1, 2, 3, 4]) == [1, 3, 5, 7])\n    assert(addIndexToElements([0, 0, 0, 0]) == [0, 1, 2, 3])\n    assert(addIndexToElements([10, 20, 30]) == [10, 21, 32])\n    assert(addIndexToElements([]) == [])\n}\n\ntestAddIndexToElements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testAddIndexToElements() {\n    assert(addIndexToElements([1, 2, 3, 4]) == [1, 3, 5, 7])\n    assert(addIndexToElements([0, 0, 0, 0]) == [0, 1, 2, 3])\n    assert(addIndexToElements([10, 20, 30]) == [10, 21, 32])\n    assert(addIndexToElements([]) == [])\n}\n\ntestAddIndexToElements()", "output": "addIndexToElements"}, "all_code": "// addIndexToElements takes an array of integers and returns a new array where each element\n// is the sum of the original element and its corresponding index in the array.\n// This is achieved by iterating through the array and adding the index to each element.\nfunc addIndexToElements(_ list: [Int]) -> [Int] {\n    return list.enumerated().map { index, element in\n        return element + index\n    }\n}\nfunc testAddIndexToElements() {\n    assert(addIndexToElements([1, 2, 3, 4]) == [1, 3, 5, 7])\n    assert(addIndexToElements([0, 0, 0, 0]) == [0, 1, 2, 3])\n    assert(addIndexToElements([10, 20, 30]) == [10, 21, 32])\n    assert(addIndexToElements([]) == [])\n}\n\ntestAddIndexToElements()", "exec_outcome": "PASSED"}
{"code": "// secondSmallest returns the second smallest number in an array of integers.\n// It uses a bubble sort algorithm to sort the array in ascending order and then returns the second element.\n// If the input array has fewer than two elements, it throws a fatal error.\nfunc secondSmallest(_ nums: [Int]) -> Int {\n    guard nums.count >= 2 else {\n        fatalError(\"List must contain at least two elements\")\n    }\n    \n    var sortedNums = nums\n    // Bubble sort implementation\n    for i in 0..<sortedNums.count {\n        for j in 0..<sortedNums.count - i - 1 {\n            if sortedNums[j] > sortedNums[j + 1] {\n                sortedNums.swapAt(j, j + 1)\n            }\n        }\n    }\n    \n    return sortedNums[1]\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nSecond smallest number: 2\nInput: [5, 6, 7, 0]\nSecond smallest number: 5\nInput: [10, 20, 30, 40, 50]\nSecond smallest number: 20\nInput: [100, 200, 300]\nSecond smallest number: 200", "task_id": 16579, "assertions": "func testSecondSmallest() {\n    assert(secondSmallest([1, 2, 3, 4]) == 2)\n    assert(secondSmallest([5, 6, 7, 0]) == 5)\n    assert(secondSmallest([10, 20, 30, 40, 50]) == 20)\n    assert(secondSmallest([100, 200, 300]) == 200)\n}\n\ntestSecondSmallest()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSecondSmallest() {\n    assert(secondSmallest([1, 2, 3, 4]) == 2)\n    assert(secondSmallest([5, 6, 7, 0]) == 5)\n    assert(secondSmallest([10, 20, 30, 40, 50]) == 20)\n    assert(secondSmallest([100, 200, 300]) == 200)\n}\n\ntestSecondSmallest()", "output": "secondSmallest"}, "all_code": "// secondSmallest returns the second smallest number in an array of integers.\n// It uses a bubble sort algorithm to sort the array in ascending order and then returns the second element.\n// If the input array has fewer than two elements, it throws a fatal error.\nfunc secondSmallest(_ nums: [Int]) -> Int {\n    guard nums.count >= 2 else {\n        fatalError(\"List must contain at least two elements\")\n    }\n    \n    var sortedNums = nums\n    // Bubble sort implementation\n    for i in 0..<sortedNums.count {\n        for j in 0..<sortedNums.count - i - 1 {\n            if sortedNums[j] > sortedNums[j + 1] {\n                sortedNums.swapAt(j, j + 1)\n            }\n        }\n    }\n    \n    return sortedNums[1]\n}\nfunc testSecondSmallest() {\n    assert(secondSmallest([1, 2, 3, 4]) == 2)\n    assert(secondSmallest([5, 6, 7, 0]) == 5)\n    assert(secondSmallest([10, 20, 30, 40, 50]) == 20)\n    assert(secondSmallest([100, 200, 300]) == 200)\n}\n\ntestSecondSmallest()", "exec_outcome": "PASSED"}
{"code": "// findCommonElements returns an array containing the elements that are common to both input arrays.\n// The elements in the resulting array are ordered as they first appear in the first array.\n// The comparison is case-sensitive.\nfunc findCommonElements<T: Equatable>(_ array1: [T], _ array2: [T]) -> [T] {\n    var commonElements = [T]()\n    for element in array1 {\n        if array2.contains(element) && !commonElements.contains(element) {\n            commonElements.append(element)\n        }\n    }\n    return commonElements\n}", "test_cases": "", "test_case_results": "Testing with Int arrays:\nInput 1: [1, 2, 3, 4], Input 2: [3, 4, 5, 6]\nCommon elements: [3, 4]\nInput 1: [7, 8, 9], Input 2: [10, 11, 12]\nCommon elements: []\nInput 1: [], Input 2: [1, 2, 3]\nCommon elements: []\nInput 1: [1, 2, 2, 3], Input 2: [2, 3, 3, 4]\nCommon elements: [2, 3]\n\nTesting with String arrays:\nInput 1: [\"apple\", \"banana\", \"orange\"], Input 2: [\"banana\", \"kiwi\", \"apple\"]\nCommon elements: [\"apple\", \"banana\"]\nInput 1: [\"Hello\", \"World\"], Input 2: [\"hello\", \"world\"]\nCommon elements: []\nInput 1: [\"a\", \"b\", \"c\"], Input 2: [\"d\", \"e\", \"f\"]\nCommon elements: []\nInput 1: [\"x\", \"y\", \"z\"], Input 2: [\"x\", \"y\", \"z\"]\nCommon elements: [\"x\", \"y\", \"z\"]", "task_id": 16953, "assertions": "func testFindCommonElements() {\n    // Test with Int arrays\n    assert(findCommonElements([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4])\n    assert(findCommonElements([7, 8, 9], [10, 11, 12]) == [])\n    assert(findCommonElements([], [1, 2, 3]) == [])\n    assert(findCommonElements([1, 2, 2, 3], [2, 3, 3, 4]) == [2, 3])\n    \n    // Test with String arrays\n    assert(findCommonElements([\"apple\", \"banana\", \"orange\"], [\"banana\", \"kiwi\", \"apple\"]) == [\"apple\", \"banana\"])\n    assert(findCommonElements([\"Hello\", \"World\"], [\"hello\", \"world\"]) == [])\n    assert(findCommonElements([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]) == [])\n    assert(findCommonElements([\"x\", \"y\", \"z\"], [\"x\", \"y\", \"z\"]) == [\"x\", \"y\", \"z\"])\n}\n\ntestFindCommonElements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFindCommonElements() {\n    // Test with Int arrays\n    assert(findCommonElements([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4])\n    assert(findCommonElements([7, 8, 9], [10, 11, 12]) == [])\n    assert(findCommonElements([], [1, 2, 3]) == [])\n    assert(findCommonElements([1, 2, 2, 3], [2, 3, 3, 4]) == [2, 3])\n    \n    // Test with String arrays\n    assert(findCommonElements([\"apple\", \"banana\", \"orange\"], [\"banana\", \"kiwi\", \"apple\"]) == [\"apple\", \"banana\"])\n    assert(findCommonElements([\"Hello\", \"World\"], [\"hello\", \"world\"]) == [])\n    assert(findCommonElements([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]) == [])\n    assert(findCommonElements([\"x\", \"y\", \"z\"], [\"x\", \"y\", \"z\"]) == [\"x\", \"y\", \"z\"])\n}\n\ntestFindCommonElements()", "output": "findCommonElements"}, "all_code": "// findCommonElements returns an array containing the elements that are common to both input arrays.\n// The elements in the resulting array are ordered as they first appear in the first array.\n// The comparison is case-sensitive.\nfunc findCommonElements<T: Equatable>(_ array1: [T], _ array2: [T]) -> [T] {\n    var commonElements = [T]()\n    for element in array1 {\n        if array2.contains(element) && !commonElements.contains(element) {\n            commonElements.append(element)\n        }\n    }\n    return commonElements\n}\nfunc testFindCommonElements() {\n    // Test with Int arrays\n    assert(findCommonElements([1, 2, 3, 4], [3, 4, 5, 6]) == [3, 4])\n    assert(findCommonElements([7, 8, 9], [10, 11, 12]) == [])\n    assert(findCommonElements([], [1, 2, 3]) == [])\n    assert(findCommonElements([1, 2, 2, 3], [2, 3, 3, 4]) == [2, 3])\n    \n    // Test with String arrays\n    assert(findCommonElements([\"apple\", \"banana\", \"orange\"], [\"banana\", \"kiwi\", \"apple\"]) == [\"apple\", \"banana\"])\n    assert(findCommonElements([\"Hello\", \"World\"], [\"hello\", \"world\"]) == [])\n    assert(findCommonElements([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]) == [])\n    assert(findCommonElements([\"x\", \"y\", \"z\"], [\"x\", \"y\", \"z\"]) == [\"x\", \"y\", \"z\"])\n}\n\ntestFindCommonElements()", "exec_outcome": "PASSED"}
{"code": "// subarraySum determines if there is a contiguous subarray in the given array of integers\n// whose sum is exactly equal to the target value k.\n// It uses a dictionary to keep track of prefix sums and their indices to efficiently check for the target sum.\n// If such a subarray exists, it returns \"Yes\"; otherwise, it returns \"No\".\nfunc subarraySum(nums: [Int], k: Int) -> String {\n    var currentSum = 0\n    var sumIndices = [0: -1] // Initialize with 0 sum at index -1 to handle prefix sum\n    \n    for (i, num) in nums.enumerated() {\n        currentSum += num\n        \n        if sumIndices[currentSum - k] != nil {\n            return \"Yes\"\n        }\n        \n        if sumIndices[currentSum] == nil {\n            sumIndices[currentSum] = i\n        }\n    }\n    \n    return \"No\"\n}", "test_cases": "", "test_case_results": "Input array: [1, 2, 3, 4], Target sum: 6\nResult: Yes\nInput array: [1, -1, 1, 1], Target sum: 1\nResult: Yes\nInput array: [10, 2, -2, -20, 10], Target sum: -10\nResult: Yes\nInput array: [1, 2, 3], Target sum: 7\nResult: No\nInput array: [], Target sum: 0\nResult: No", "task_id": 1777, "assertions": "func testSubarraySum() {\n    assert(subarraySum(nums: [1, 2, 3, 4], k: 6) == \"Yes\")\n    assert(subarraySum(nums: [1, -1, 1, 1], k: 1) == \"Yes\")\n    assert(subarraySum(nums: [10, 2, -2, -20, 10], k: -10) == \"Yes\")\n    assert(subarraySum(nums: [1, 2, 3], k: 7) == \"No\")\n    assert(subarraySum(nums: [], k: 0) == \"No\")\n}\n\ntestSubarraySum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSubarraySum() {\n    assert(subarraySum(nums: [1, 2, 3, 4], k: 6) == \"Yes\")\n    assert(subarraySum(nums: [1, -1, 1, 1], k: 1) == \"Yes\")\n    assert(subarraySum(nums: [10, 2, -2, -20, 10], k: -10) == \"Yes\")\n    assert(subarraySum(nums: [1, 2, 3], k: 7) == \"No\")\n    assert(subarraySum(nums: [], k: 0) == \"No\")\n}\n\ntestSubarraySum()", "output": "subarraySum"}, "all_code": "// subarraySum determines if there is a contiguous subarray in the given array of integers\n// whose sum is exactly equal to the target value k.\n// It uses a dictionary to keep track of prefix sums and their indices to efficiently check for the target sum.\n// If such a subarray exists, it returns \"Yes\"; otherwise, it returns \"No\".\nfunc subarraySum(nums: [Int], k: Int) -> String {\n    var currentSum = 0\n    var sumIndices = [0: -1] // Initialize with 0 sum at index -1 to handle prefix sum\n    \n    for (i, num) in nums.enumerated() {\n        currentSum += num\n        \n        if sumIndices[currentSum - k] != nil {\n            return \"Yes\"\n        }\n        \n        if sumIndices[currentSum] == nil {\n            sumIndices[currentSum] = i\n        }\n    }\n    \n    return \"No\"\n}\nfunc testSubarraySum() {\n    assert(subarraySum(nums: [1, 2, 3, 4], k: 6) == \"Yes\")\n    assert(subarraySum(nums: [1, -1, 1, 1], k: 1) == \"Yes\")\n    assert(subarraySum(nums: [10, 2, -2, -20, 10], k: -10) == \"Yes\")\n    assert(subarraySum(nums: [1, 2, 3], k: 7) == \"No\")\n    assert(subarraySum(nums: [], k: 0) == \"No\")\n}\n\ntestSubarraySum()", "exec_outcome": "PASSED"}
{"code": "// sumOfSquares calculates the sum of the squares of the first n positive integers.\n// It uses a loop to iterate from 1 to n, squares each number, and accumulates the sum.\n// If the input n is less than or equal to 0, it returns 0 since there are no positive integers to square.\nfunc sumOfSquares(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n    var sum = 0\n    for i in 1...n {\n        sum += i * i\n    }\n    return sum\n}", "test_cases": "", "test_case_results": "Input: 1\nSum of squares: 1\nInput: 2\nSum of squares: 5\nInput: 5\nSum of squares: 55\nInput: 0\nSum of squares: 0\nInput: -3\nSum of squares: 0", "task_id": 13149, "assertions": "func testSumOfSquares() {\n    assert(sumOfSquares(n: 1) == 1)\n    assert(sumOfSquares(n: 2) == 5)\n    assert(sumOfSquares(n: 5) == 55)\n    assert(sumOfSquares(n: 0) == 0)\n    assert(sumOfSquares(n: -3) == 0)\n}\n\ntestSumOfSquares()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSumOfSquares() {\n    assert(sumOfSquares(n: 1) == 1)\n    assert(sumOfSquares(n: 2) == 5)\n    assert(sumOfSquares(n: 5) == 55)\n    assert(sumOfSquares(n: 0) == 0)\n    assert(sumOfSquares(n: -3) == 0)\n}\n\ntestSumOfSquares()", "output": "sumOfSquares"}, "all_code": "import Foundation\nimport Glibc\n\n// sumOfSquares calculates the sum of the squares of the first n positive integers.\n// It uses a loop to iterate from 1 to n, squares each number, and accumulates the sum.\n// If the input n is less than or equal to 0, it returns 0 since there are no positive integers to square.\nfunc sumOfSquares(n: Int) -> Int {\n    if n <= 0 {\n        return 0\n    }\n    var sum = 0\n    for i in 1...n {\n        sum += i * i\n    }\n    return sum\n}\nfunc testSumOfSquares() {\n    assert(sumOfSquares(n: 1) == 1)\n    assert(sumOfSquares(n: 2) == 5)\n    assert(sumOfSquares(n: 5) == 55)\n    assert(sumOfSquares(n: 0) == 0)\n    assert(sumOfSquares(n: -3) == 0)\n}\n\ntestSumOfSquares()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// This is a helper function used to simplify the slope representation.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\n// slope calculates the simplified slope between two points (p1 and p2) as a tuple of integers.\n// If the line is vertical (dx == 0), it returns (0, x-coordinate).\n// If the line is horizontal (dy == 0), it returns (y-coordinate, 0).\n// Otherwise, it returns the simplified (dy, dx) pair.\nfunc slope(_ p1: (Int, Int), _ p2: (Int, Int)) -> (Int, Int) {\n    let dy = p2.1 - p1.1\n    let dx = p2.0 - p1.0\n    if dx == 0 {\n        return (0, p1.0)\n    }\n    if dy == 0 {\n        return (p1.1, 0)\n    }\n    let d = gcd(dy, dx)\n    return (dy / d, dx / d)\n}\n\n// maxPointsOnLine finds the maximum number of points that lie on the same straight line.\n// It iterates through each point, calculates the slope with every other point, and counts the occurrences of each slope.\n// The result is the maximum count of points sharing the same slope (plus the point itself and any duplicate points).\nfunc maxPointsOnLine(_ points: [(Int, Int)]) -> Int {\n    let n = points.count\n    if n <= 2 {\n        return n\n    }\n    \n    var maxPoints = 0\n    \n    for i in 0..<n {\n        var slopes = [String: Int]()\n        var samePoint = 0\n        var currentMax = 0\n        for j in 0..<n {\n            if i != j {\n                if points[i] == points[j] {\n                    samePoint += 1\n                } else {\n                    let s = slope(points[i], points[j])\n                    let key = \"\\(s.0),\\(s.1)\"\n                    slopes[key, default: 0] += 1\n                    currentMax = max(currentMax, slopes[key]!)\n                }\n            }\n        }\n        maxPoints = max(maxPoints, currentMax + samePoint + 1)\n    }\n    \n    return maxPoints\n}", "test_cases": "", "test_case_results": "Input: [(1, 1), (2, 2), (3, 3)]\nMax points on a line: 3\nInput: [(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]\nMax points on a line: 4\nInput: [(0, 0), (1, 1), (0, 0)]\nMax points on a line: 3\nInput: [(0, 0)]\nMax points on a line: 1\nInput: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]\nMax points on a line: 5", "task_id": 15044, "assertions": "func testMaxPointsOnLine() {\n    assert(maxPointsOnLine([(1, 1), (2, 2), (3, 3)]) == 3)\n    assert(maxPointsOnLine([(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]) == 4)\n    assert(maxPointsOnLine([(0, 0), (1, 1), (0, 0)]) == 3)\n    assert(maxPointsOnLine([(0, 0)]) == 1)\n    assert(maxPointsOnLine([(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]) == 5)\n}\n\ntestMaxPointsOnLine()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaxPointsOnLine() {\n    assert(maxPointsOnLine([(1, 1), (2, 2), (3, 3)]) == 3)\n    assert(maxPointsOnLine([(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]) == 4)\n    assert(maxPointsOnLine([(0, 0), (1, 1), (0, 0)]) == 3)\n    assert(maxPointsOnLine([(0, 0)]) == 1)\n    assert(maxPointsOnLine([(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]) == 5)\n}\n\ntestMaxPointsOnLine()", "output": "maxPointsOnLine"}, "all_code": "import Glibc\n\nimport Foundation\n\n// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// This is a helper function used to simplify the slope representation.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}\n\n// slope calculates the simplified slope between two points (p1 and p2) as a tuple of integers.\n// If the line is vertical (dx == 0), it returns (0, x-coordinate).\n// If the line is horizontal (dy == 0), it returns (y-coordinate, 0).\n// Otherwise, it returns the simplified (dy, dx) pair.\nfunc slope(_ p1: (Int, Int), _ p2: (Int, Int)) -> (Int, Int) {\n    let dy = p2.1 - p1.1\n    let dx = p2.0 - p1.0\n    if dx == 0 {\n        return (0, p1.0)\n    }\n    if dy == 0 {\n        return (p1.1, 0)\n    }\n    let d = gcd(dy, dx)\n    return (dy / d, dx / d)\n}\n\n// maxPointsOnLine finds the maximum number of points that lie on the same straight line.\n// It iterates through each point, calculates the slope with every other point, and counts the occurrences of each slope.\n// The result is the maximum count of points sharing the same slope (plus the point itself and any duplicate points).\nfunc maxPointsOnLine(_ points: [(Int, Int)]) -> Int {\n    let n = points.count\n    if n <= 2 {\n        return n\n    }\n    \n    var maxPoints = 0\n    \n    for i in 0..<n {\n        var slopes = [String: Int]()\n        var samePoint = 0\n        var currentMax = 0\n        for j in 0..<n {\n            if i != j {\n                if points[i] == points[j] {\n                    samePoint += 1\n                } else {\n                    let s = slope(points[i], points[j])\n                    let key = \"\\(s.0),\\(s.1)\"\n                    slopes[key, default: 0] += 1\n                    currentMax = max(currentMax, slopes[key]!)\n                }\n            }\n        }\n        maxPoints = max(maxPoints, currentMax + samePoint + 1)\n    }\n    \n    return maxPoints\n}\nfunc testMaxPointsOnLine() {\n    assert(maxPointsOnLine([(1, 1), (2, 2), (3, 3)]) == 3)\n    assert(maxPointsOnLine([(1, 1), (3, 2), (5, 3), (4, 1), (2, 3), (1, 4)]) == 4)\n    assert(maxPointsOnLine([(0, 0), (1, 1), (0, 0)]) == 3)\n    assert(maxPointsOnLine([(0, 0)]) == 1)\n    assert(maxPointsOnLine([(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]) == 5)\n}\n\ntestMaxPointsOnLine()", "exec_outcome": "PASSED"}
{"code": "// uniqueGearsCount calculates the number of unique gears in the union of two clock strings.\n// It uses Swift's Set to find the union of characters in both strings and returns the count of unique characters.\nfunc uniqueGearsCount(clock1: String, clock2: String) -> Int {\n    let set1 = Set(clock1)\n    let set2 = Set(clock2)\n    let uniqueGears = set1.union(set2)\n    return uniqueGears.count\n}\n\n// processTestCases processes multiple test cases and returns an array of results.\n// Each test case is a tuple of two clock strings, and the function applies uniqueGearsCount to each pair.\nfunc processTestCases(testCases: [(String, String)]) -> [Int] {\n    var results: [Int] = []\n    for (clock1, clock2) in testCases {\n        results.append(uniqueGearsCount(clock1: clock1, clock2: clock2))\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Test Case 1:\nClock 1: abc, Clock 2: def\nUnique gears count: 6\n\nTest Case 2:\nClock 1: aabbcc, Clock 2: abc\nUnique gears count: 3\n\nTest Case 3:\nClock 1: xyz, Clock 2: xyz\nUnique gears count: 3\n\nTest Case 4:\nClock 1: 123, Clock 2: 456\nUnique gears count: 6\n\nTest Case 5:\nClock 1: , Clock 2: \nUnique gears count: 0\n\nProcessing all test cases at once:\nResults for all test cases: [6, 3, 3, 6, 0]", "task_id": 28389, "assertions": "func testUniqueGearsCount() {\n    // Test individual cases\n    assert(uniqueGearsCount(clock1: \"abc\", clock2: \"def\") == 6)\n    assert(uniqueGearsCount(clock1: \"aabbcc\", clock2: \"abc\") == 3)\n    assert(uniqueGearsCount(clock1: \"xyz\", clock2: \"xyz\") == 3)\n    assert(uniqueGearsCount(clock1: \"123\", clock2: \"456\") == 6)\n    assert(uniqueGearsCount(clock1: \"\", clock2: \"\") == 0)\n    \n    // Test batch processing\n    let testCases: [(String, String)] = [\n        (\"abc\", \"def\"),\n        (\"aabbcc\", \"abc\"),\n        (\"xyz\", \"xyz\"),\n        (\"123\", \"456\"),\n        (\"\", \"\")\n    ]\n    let expectedResults = [6, 3, 3, 6, 0]\n    let actualResults = processTestCases(testCases: testCases)\n    assert(actualResults == expectedResults)\n}\n\ntestUniqueGearsCount()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testUniqueGearsCount() {\n    // Test individual cases\n    assert(uniqueGearsCount(clock1: \"abc\", clock2: \"def\") == 6)\n    assert(uniqueGearsCount(clock1: \"aabbcc\", clock2: \"abc\") == 3)\n    assert(uniqueGearsCount(clock1: \"xyz\", clock2: \"xyz\") == 3)\n    assert(uniqueGearsCount(clock1: \"123\", clock2: \"456\") == 6)\n    assert(uniqueGearsCount(clock1: \"\", clock2: \"\") == 0)\n    \n    // Test batch processing\n    let testCases: [(String, String)] = [\n        (\"abc\", \"def\"),\n        (\"aabbcc\", \"abc\"),\n        (\"xyz\", \"xyz\"),\n        (\"123\", \"456\"),\n        (\"\", \"\")\n    ]\n    let expectedResults = [6, 3, 3, 6, 0]\n    let actualResults = processTestCases(testCases: testCases)\n    assert(actualResults == expectedResults)\n}\n\ntestUniqueGearsCount()", "output": "uniqueGearsCount"}, "all_code": "// uniqueGearsCount calculates the number of unique gears in the union of two clock strings.\n// It uses Swift's Set to find the union of characters in both strings and returns the count of unique characters.\nfunc uniqueGearsCount(clock1: String, clock2: String) -> Int {\n    let set1 = Set(clock1)\n    let set2 = Set(clock2)\n    let uniqueGears = set1.union(set2)\n    return uniqueGears.count\n}\n\n// processTestCases processes multiple test cases and returns an array of results.\n// Each test case is a tuple of two clock strings, and the function applies uniqueGearsCount to each pair.\nfunc processTestCases(testCases: [(String, String)]) -> [Int] {\n    var results: [Int] = []\n    for (clock1, clock2) in testCases {\n        results.append(uniqueGearsCount(clock1: clock1, clock2: clock2))\n    }\n    return results\n}\nfunc testUniqueGearsCount() {\n    // Test individual cases\n    assert(uniqueGearsCount(clock1: \"abc\", clock2: \"def\") == 6)\n    assert(uniqueGearsCount(clock1: \"aabbcc\", clock2: \"abc\") == 3)\n    assert(uniqueGearsCount(clock1: \"xyz\", clock2: \"xyz\") == 3)\n    assert(uniqueGearsCount(clock1: \"123\", clock2: \"456\") == 6)\n    assert(uniqueGearsCount(clock1: \"\", clock2: \"\") == 0)\n    \n    // Test batch processing\n    let testCases: [(String, String)] = [\n        (\"abc\", \"def\"),\n        (\"aabbcc\", \"abc\"),\n        (\"xyz\", \"xyz\"),\n        (\"123\", \"456\"),\n        (\"\", \"\")\n    ]\n    let expectedResults = [6, 3, 3, 6, 0]\n    let actualResults = processTestCases(testCases: testCases)\n    assert(actualResults == expectedResults)\n}\n\ntestUniqueGearsCount()", "exec_outcome": "PASSED"}
{"code": "// encrypt performs a simple substitution cipher encryption on the given plaintext.\n// It maps each letter in the plaintext to a corresponding letter in a reversed alphabet.\n// Non-alphabetic characters are left unchanged.\nfunc encrypt(plaintext: String) -> String {\n    let ciphertextAlphabet = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    let plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var substitutionDict: [Character: Character] = [:]\n    \n    for (i, char) in plaintextAlphabet.enumerated() {\n        let cipherIndex = ciphertextAlphabet.index(ciphertextAlphabet.startIndex, offsetBy: i)\n        substitutionDict[char] = ciphertextAlphabet[cipherIndex]\n    }\n    \n    var encryptedText = \"\"\n    for char in plaintext.uppercased() {\n        if let substitutedChar = substitutionDict[char] {\n            encryptedText.append(substitutedChar)\n        } else {\n            encryptedText.append(char)\n        }\n    }\n    \n    return encryptedText\n}\n\n// decrypt performs a simple substitution cipher decryption on the given ciphertext.\n// It reverses the encryption process by mapping each letter back to the original alphabet.\n// Non-alphabetic characters are left unchanged.\nfunc decrypt(ciphertext: String) -> String {\n    let ciphertextAlphabet = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    let plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var substitutionDict: [Character: Character] = [:]\n    \n    for (i, char) in ciphertextAlphabet.enumerated() {\n        let plainIndex = plaintextAlphabet.index(plaintextAlphabet.startIndex, offsetBy: i)\n        substitutionDict[char] = plaintextAlphabet[plainIndex]\n    }\n    \n    var decryptedText = \"\"\n    for char in ciphertext.uppercased() {\n        if let substitutedChar = substitutionDict[char] {\n            decryptedText.append(substitutedChar)\n        } else {\n            decryptedText.append(char)\n        }\n    }\n    \n    return decryptedText\n}", "test_cases": "", "test_case_results": "Original: HELLO WORLD\nEncrypted: SVOOL DLIOW\nDecrypted: HELLO WORLD\n---\nOriginal: SWIFT IS AWESOME\nEncrypted: HDRUG RH ZDVHLNV\nDecrypted: SWIFT IS AWESOME\n---\nOriginal: 123!@#\nEncrypted: 123!@#\nDecrypted: 123!@#\n---\nOriginal: A\nEncrypted: Z\nDecrypted: A\n---", "task_id": 2036, "assertions": "func testEncryptDecrypt() {\n    assert(encrypt(plaintext: \"HELLO WORLD\") == \"SVOOL DLIOW\")\n    assert(decrypt(ciphertext: \"SVOOL DLIOW\") == \"HELLO WORLD\")\n    assert(encrypt(plaintext: \"SWIFT IS AWESOME\") == \"HDRUG RH ZDVHLNV\")\n    assert(decrypt(ciphertext: \"HDRUG RH ZDVHLNV\") == \"SWIFT IS AWESOME\")\n    assert(encrypt(plaintext: \"123!@#\") == \"123!@#\")\n    assert(decrypt(ciphertext: \"123!@#\") == \"123!@#\")\n    assert(encrypt(plaintext: \"A\") == \"Z\")\n    assert(decrypt(ciphertext: \"Z\") == \"A\")\n}\n\ntestEncryptDecrypt()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testEncryptDecrypt() {\n    assert(encrypt(plaintext: \"HELLO WORLD\") == \"SVOOL DLIOW\")\n    assert(decrypt(ciphertext: \"SVOOL DLIOW\") == \"HELLO WORLD\")\n    assert(encrypt(plaintext: \"SWIFT IS AWESOME\") == \"HDRUG RH ZDVHLNV\")\n    assert(decrypt(ciphertext: \"HDRUG RH ZDVHLNV\") == \"SWIFT IS AWESOME\")\n    assert(encrypt(plaintext: \"123!@#\") == \"123!@#\")\n    assert(decrypt(ciphertext: \"123!@#\") == \"123!@#\")\n    assert(encrypt(plaintext: \"A\") == \"Z\")\n    assert(decrypt(ciphertext: \"Z\") == \"A\")\n}\n\ntestEncryptDecrypt()", "output": "encrypt, decrypt"}, "all_code": "// encrypt performs a simple substitution cipher encryption on the given plaintext.\n// It maps each letter in the plaintext to a corresponding letter in a reversed alphabet.\n// Non-alphabetic characters are left unchanged.\nfunc encrypt(plaintext: String) -> String {\n    let ciphertextAlphabet = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    let plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var substitutionDict: [Character: Character] = [:]\n    \n    for (i, char) in plaintextAlphabet.enumerated() {\n        let cipherIndex = ciphertextAlphabet.index(ciphertextAlphabet.startIndex, offsetBy: i)\n        substitutionDict[char] = ciphertextAlphabet[cipherIndex]\n    }\n    \n    var encryptedText = \"\"\n    for char in plaintext.uppercased() {\n        if let substitutedChar = substitutionDict[char] {\n            encryptedText.append(substitutedChar)\n        } else {\n            encryptedText.append(char)\n        }\n    }\n    \n    return encryptedText\n}\n\n// decrypt performs a simple substitution cipher decryption on the given ciphertext.\n// It reverses the encryption process by mapping each letter back to the original alphabet.\n// Non-alphabetic characters are left unchanged.\nfunc decrypt(ciphertext: String) -> String {\n    let ciphertextAlphabet = \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    let plaintextAlphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    var substitutionDict: [Character: Character] = [:]\n    \n    for (i, char) in ciphertextAlphabet.enumerated() {\n        let plainIndex = plaintextAlphabet.index(plaintextAlphabet.startIndex, offsetBy: i)\n        substitutionDict[char] = plaintextAlphabet[plainIndex]\n    }\n    \n    var decryptedText = \"\"\n    for char in ciphertext.uppercased() {\n        if let substitutedChar = substitutionDict[char] {\n            decryptedText.append(substitutedChar)\n        } else {\n            decryptedText.append(char)\n        }\n    }\n    \n    return decryptedText\n}\nfunc testEncryptDecrypt() {\n    assert(encrypt(plaintext: \"HELLO WORLD\") == \"SVOOL DLIOW\")\n    assert(decrypt(ciphertext: \"SVOOL DLIOW\") == \"HELLO WORLD\")\n    assert(encrypt(plaintext: \"SWIFT IS AWESOME\") == \"HDRUG RH ZDVHLNV\")\n    assert(decrypt(ciphertext: \"HDRUG RH ZDVHLNV\") == \"SWIFT IS AWESOME\")\n    assert(encrypt(plaintext: \"123!@#\") == \"123!@#\")\n    assert(decrypt(ciphertext: \"123!@#\") == \"123!@#\")\n    assert(encrypt(plaintext: \"A\") == \"Z\")\n    assert(decrypt(ciphertext: \"Z\") == \"A\")\n}\n\ntestEncryptDecrypt()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// maxDistanceBetweenEpicenters calculates the maximum Euclidean distance between any two points in each test case.\n// Each test case consists of a number of points (N) and their coordinates.\n// The function returns an array of formatted strings representing the maximum distance for each test case, rounded to 6 decimal places.\nfunc maxDistanceBetweenEpicenters(testCases: [(Int, [(Double, Double)])]) -> [String] {\n    var results: [String] = []\n    for testCase in testCases {\n        let (N, coordinates) = testCase\n        var maxDistance: Double = 0.0\n        \n        for i in 0..<N {\n            for j in (i+1)..<N {\n                let (x1, y1) = coordinates[i]\n                let (x2, y2) = coordinates[j]\n                let distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n                maxDistance = max(maxDistance, distance)\n            }\n        }\n        \n        results.append(String(format: \"%.6f\", maxDistance))\n    }\n    return results\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of points: 3\nCoordinates: [(0.0, 0.0), (3.0, 4.0), (6.0, 8.0)]\nMaximum distance: 10.000000\n\nTest Case 2:\nNumber of points: 2\nCoordinates: [(1.0, 1.0), (2.0, 2.0)]\nMaximum distance: 1.414214\n\nTest Case 3:\nNumber of points: 4\nCoordinates: [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)]\nMaximum distance: 1.414214", "task_id": 15025, "assertions": "func testMaxDistanceBetweenEpicenters() {\n    let testCases: [(Int, [(Double, Double)])] = [\n        (3, [(0.0, 0.0), (3.0, 4.0), (6.0, 8.0)]),\n        (2, [(1.0, 1.0), (2.0, 2.0)]),\n        (4, [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)])\n    ]\n    \n    let results = maxDistanceBetweenEpicenters(testCases: testCases)\n    assert(results[0] == \"10.000000\")\n    assert(results[1] == \"1.414214\")\n    assert(results[2] == \"1.414214\")\n}\n\ntestMaxDistanceBetweenEpicenters()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaxDistanceBetweenEpicenters() {\n    let testCases: [(Int, [(Double, Double)])] = [\n        (3, [(0.0, 0.0), (3.0, 4.0), (6.0, 8.0)]),\n        (2, [(1.0, 1.0), (2.0, 2.0)]),\n        (4, [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)])\n    ]\n    \n    let results = maxDistanceBetweenEpicenters(testCases: testCases)\n    assert(results[0] == \"10.000000\")\n    assert(results[1] == \"1.414214\")\n    assert(results[2] == \"1.414214\")\n}\n\ntestMaxDistanceBetweenEpicenters()", "output": "maxDistanceBetweenEpicenters"}, "all_code": "import Glibc\n\nimport Foundation\n\n// maxDistanceBetweenEpicenters calculates the maximum Euclidean distance between any two points in each test case.\n// Each test case consists of a number of points (N) and their coordinates.\n// The function returns an array of formatted strings representing the maximum distance for each test case, rounded to 6 decimal places.\nfunc maxDistanceBetweenEpicenters(testCases: [(Int, [(Double, Double)])]) -> [String] {\n    var results: [String] = []\n    for testCase in testCases {\n        let (N, coordinates) = testCase\n        var maxDistance: Double = 0.0\n        \n        for i in 0..<N {\n            for j in (i+1)..<N {\n                let (x1, y1) = coordinates[i]\n                let (x2, y2) = coordinates[j]\n                let distance = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n                maxDistance = max(maxDistance, distance)\n            }\n        }\n        \n        results.append(String(format: \"%.6f\", maxDistance))\n    }\n    return results\n}\nfunc testMaxDistanceBetweenEpicenters() {\n    let testCases: [(Int, [(Double, Double)])] = [\n        (3, [(0.0, 0.0), (3.0, 4.0), (6.0, 8.0)]),\n        (2, [(1.0, 1.0), (2.0, 2.0)]),\n        (4, [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0)])\n    ]\n    \n    let results = maxDistanceBetweenEpicenters(testCases: testCases)\n    assert(results[0] == \"10.000000\")\n    assert(results[1] == \"1.414214\")\n    assert(results[2] == \"1.414214\")\n}\n\ntestMaxDistanceBetweenEpicenters()", "exec_outcome": "PASSED"}
{"code": "// matrixDiagonals returns an array of arrays, each corresponding to a diagonal of the matrix.\n// The function traverses the matrix from the top-left to the bottom-right, collecting elements along each diagonal.\n// If the input matrix is empty, it returns an empty array.\nfunc matrixDiagonals(matrix: [[Int]]) -> [[Int]] {\n    if matrix.isEmpty {\n        return []\n    }\n\n    var result = [[Int]]()\n    let rows = matrix.count\n    let cols = matrix[0].count\n\n    for start in 0..<(rows + cols - 1) {\n        var diagonal = [Int]()\n        var row: Int\n        var col: Int\n\n        if start < rows {\n            row = start\n            col = 0\n        } else {\n            row = rows - 1\n            col = start - (rows - 1)\n        }\n\n        while row >= 0 && col < cols {\n            diagonal.append(matrix[row][col])\n            row -= 1\n            col += 1\n        }\n\n        result.append(diagonal)\n    }\n\n    return result\n}", "test_cases": "", "test_case_results": "Input Matrix:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\nDiagonals: [[1], [4, 2], [7, 5, 3], [8, 6], [9]]\n\nInput Matrix:\n[1, 2]\n[3, 4]\nDiagonals: [[1], [3, 2], [4]]\n\nInput Matrix:\n[1]\nDiagonals: [[1]]\n\nInput Matrix:\nDiagonals: []", "task_id": 13921, "assertions": "func testMatrixDiagonals() {\n    // Test case 1: 3x3 matrix\n    let matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(matrixDiagonals(matrix: matrix1) == [[1], [4, 2], [7, 5, 3], [8, 6], [9]])\n    \n    // Test case 2: 2x2 matrix\n    let matrix2 = [\n        [1, 2],\n        [3, 4]\n    ]\n    assert(matrixDiagonals(matrix: matrix2) == [[1], [3, 2], [4]])\n    \n    // Test case 3: 1x1 matrix\n    let matrix3 = [\n        [1]\n    ]\n    assert(matrixDiagonals(matrix: matrix3) == [[1]])\n    \n    // Test case 4: Empty matrix\n    let matrix4: [[Int]] = []\n    assert(matrixDiagonals(matrix: matrix4) == [])\n}\n\ntestMatrixDiagonals()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMatrixDiagonals() {\n    // Test case 1: 3x3 matrix\n    let matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(matrixDiagonals(matrix: matrix1) == [[1], [4, 2], [7, 5, 3], [8, 6], [9]])\n    \n    // Test case 2: 2x2 matrix\n    let matrix2 = [\n        [1, 2],\n        [3, 4]\n    ]\n    assert(matrixDiagonals(matrix: matrix2) == [[1], [3, 2], [4]])\n    \n    // Test case 3: 1x1 matrix\n    let matrix3 = [\n        [1]\n    ]\n    assert(matrixDiagonals(matrix: matrix3) == [[1]])\n    \n    // Test case 4: Empty matrix\n    let matrix4: [[Int]] = []\n    assert(matrixDiagonals(matrix: matrix4) == [])\n}\n\ntestMatrixDiagonals()", "output": "matrixDiagonals"}, "all_code": "// matrixDiagonals returns an array of arrays, each corresponding to a diagonal of the matrix.\n// The function traverses the matrix from the top-left to the bottom-right, collecting elements along each diagonal.\n// If the input matrix is empty, it returns an empty array.\nfunc matrixDiagonals(matrix: [[Int]]) -> [[Int]] {\n    if matrix.isEmpty {\n        return []\n    }\n\n    var result = [[Int]]()\n    let rows = matrix.count\n    let cols = matrix[0].count\n\n    for start in 0..<(rows + cols - 1) {\n        var diagonal = [Int]()\n        var row: Int\n        var col: Int\n\n        if start < rows {\n            row = start\n            col = 0\n        } else {\n            row = rows - 1\n            col = start - (rows - 1)\n        }\n\n        while row >= 0 && col < cols {\n            diagonal.append(matrix[row][col])\n            row -= 1\n            col += 1\n        }\n\n        result.append(diagonal)\n    }\n\n    return result\n}\nfunc testMatrixDiagonals() {\n    // Test case 1: 3x3 matrix\n    let matrix1 = [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9]\n    ]\n    assert(matrixDiagonals(matrix: matrix1) == [[1], [4, 2], [7, 5, 3], [8, 6], [9]])\n    \n    // Test case 2: 2x2 matrix\n    let matrix2 = [\n        [1, 2],\n        [3, 4]\n    ]\n    assert(matrixDiagonals(matrix: matrix2) == [[1], [3, 2], [4]])\n    \n    // Test case 3: 1x1 matrix\n    let matrix3 = [\n        [1]\n    ]\n    assert(matrixDiagonals(matrix: matrix3) == [[1]])\n    \n    // Test case 4: Empty matrix\n    let matrix4: [[Int]] = []\n    assert(matrixDiagonals(matrix: matrix4) == [])\n}\n\ntestMatrixDiagonals()", "exec_outcome": "PASSED"}
{"code": "// isSubstring checks if a given substring is present within a main string.\n// It returns true if the substring is found, otherwise false.\nfunc isSubstring(sub: String, main: String) -> Bool {\n    return main.contains(sub)\n}", "test_cases": "", "test_case_results": "Substring: \"hello\", Main string: \"hello world\"\nIs substring: true\nSubstring: \"abc\", Main string: \"defghi\"\nIs substring: false\nSubstring: \"\", Main string: \"empty string check\"\nIs substring: true\nSubstring: \"test\", Main string: \"this is a test string\"\nIs substring: true", "task_id": 6143, "assertions": "func testIsSubstring() {\n    assert(isSubstring(sub: \"hello\", main: \"hello world\") == true)\n    assert(isSubstring(sub: \"abc\", main: \"defghi\") == false)\n    assert(isSubstring(sub: \"\", main: \"empty string check\") == true)\n    assert(isSubstring(sub: \"test\", main: \"this is a test string\") == true)\n}\n\ntestIsSubstring()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsSubstring() {\n    assert(isSubstring(sub: \"hello\", main: \"hello world\") == true)\n    assert(isSubstring(sub: \"abc\", main: \"defghi\") == false)\n    assert(isSubstring(sub: \"\", main: \"empty string check\") == true)\n    assert(isSubstring(sub: \"test\", main: \"this is a test string\") == true)\n}\n\ntestIsSubstring()", "output": "isSubstring"}, "all_code": "// isSubstring checks if a given substring is present within a main string.\n// It returns true if the substring is found, otherwise false.\nfunc isSubstring(sub: String, main: String) -> Bool {\n    return main.contains(sub)\n}\nfunc testIsSubstring() {\n    assert(isSubstring(sub: \"hello\", main: \"hello world\") == true)\n    assert(isSubstring(sub: \"abc\", main: \"defghi\") == false)\n    assert(isSubstring(sub: \"\", main: \"empty string check\") == true)\n    assert(isSubstring(sub: \"test\", main: \"this is a test string\") == true)\n}\n\ntestIsSubstring()", "exec_outcome": "PASSED"}
{"code": "// evaluateTicTacToeGame determines the winner of a 3x3 Tic-Tac-Toe game.\n// It checks for winning conditions for both players 'X' and 'O', and if no winner is found,\n// it checks if the game is still ongoing or if it's a tie.\n// The function takes a 3x3 game board as input, where each element is \"X\", \"O\", or an empty string.\n// It returns one of the following strings: \"X Wins\", \"O Wins\", \"Tie\", or \"Ongoing\".\nfunc evaluateTicTacToeGame(board: [[String]]) -> String {\n    // checkWinner is a nested function that checks if the specified player has won the game.\n    // It checks all rows, columns, and both diagonals for a winning condition.\n    func checkWinner(_ player: String) -> Bool {\n        // Check rows\n        for row in board {\n            if row.allSatisfy { $0 == player } {\n                return true\n            }\n        }\n        // Check columns\n        for col in 0..<3 {\n            if (0..<3).allSatisfy { board[$0][col] == player } {\n                return true\n            }\n        }\n        // Check diagonals\n        if (0..<3).allSatisfy { board[$0][$0] == player } {\n            return true\n        }\n        if (0..<3).allSatisfy { board[$0][2 - $0] == player } {\n            return true\n        }\n        return false\n    }\n    \n    if checkWinner(\"X\") {\n        return \"X Wins\"\n    }\n    \n    if checkWinner(\"O\") {\n        return \"O Wins\"\n    }\n    \n    // Check if the game is still ongoing\n    if board.contains(where: { $0.contains(\"\") }) {\n        return \"Ongoing\"\n    }\n    \n    // If no winner and no empty spaces, it's a tie\n    return \"Tie\"\n}", "test_cases": "", "test_case_results": "Input Board:\n[\"X\", \"X\", \"X\"]\n[\"O\", \"O\", \"\"]\n[\"\", \"\", \"\"]\nResult: X Wins\n------------------\nInput Board:\n[\"O\", \"X\", \"\"]\n[\"X\", \"O\", \"\"]\n[\"\", \"\", \"O\"]\nResult: O Wins\n------------------\nInput Board:\n[\"X\", \"O\", \"X\"]\n[\"O\", \"X\", \"O\"]\n[\"\", \"\", \"\"]\nResult: Ongoing\n------------------\nInput Board:\n[\"X\", \"O\", \"X\"]\n[\"O\", \"X\", \"O\"]\n[\"O\", \"X\", \"O\"]\nResult: Tie\n------------------", "task_id": 18004, "assertions": "func testEvaluateTicTacToeGame() {\n    // X wins via first row\n    let board1 = [\n        [\"X\", \"X\", \"X\"],\n        [\"O\", \"O\", \"\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board1) == \"X Wins\")\n    \n    // O wins via diagonal\n    let board2 = [\n        [\"O\", \"X\", \"\"],\n        [\"X\", \"O\", \"\"],\n        [\"\", \"\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board2) == \"O Wins\")\n    \n    // Ongoing game\n    let board3 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board3) == \"Ongoing\")\n    \n    // Tie game\n    let board4 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"O\", \"X\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board4) == \"Tie\")\n}\n\ntestEvaluateTicTacToeGame()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testEvaluateTicTacToeGame() {\n    // X wins via first row\n    let board1 = [\n        [\"X\", \"X\", \"X\"],\n        [\"O\", \"O\", \"\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board1) == \"X Wins\")\n    \n    // O wins via diagonal\n    let board2 = [\n        [\"O\", \"X\", \"\"],\n        [\"X\", \"O\", \"\"],\n        [\"\", \"\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board2) == \"O Wins\")\n    \n    // Ongoing game\n    let board3 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board3) == \"Ongoing\")\n    \n    // Tie game\n    let board4 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"O\", \"X\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board4) == \"Tie\")\n}\n\ntestEvaluateTicTacToeGame()", "output": "evaluateTicTacToeGame"}, "all_code": "// evaluateTicTacToeGame determines the winner of a 3x3 Tic-Tac-Toe game.\n// It checks for winning conditions for both players 'X' and 'O', and if no winner is found,\n// it checks if the game is still ongoing or if it's a tie.\n// The function takes a 3x3 game board as input, where each element is \"X\", \"O\", or an empty string.\n// It returns one of the following strings: \"X Wins\", \"O Wins\", \"Tie\", or \"Ongoing\".\nfunc evaluateTicTacToeGame(board: [[String]]) -> String {\n    // checkWinner is a nested function that checks if the specified player has won the game.\n    // It checks all rows, columns, and both diagonals for a winning condition.\n    func checkWinner(_ player: String) -> Bool {\n        // Check rows\n        for row in board {\n            if row.allSatisfy { $0 == player } {\n                return true\n            }\n        }\n        // Check columns\n        for col in 0..<3 {\n            if (0..<3).allSatisfy { board[$0][col] == player } {\n                return true\n            }\n        }\n        // Check diagonals\n        if (0..<3).allSatisfy { board[$0][$0] == player } {\n            return true\n        }\n        if (0..<3).allSatisfy { board[$0][2 - $0] == player } {\n            return true\n        }\n        return false\n    }\n    \n    if checkWinner(\"X\") {\n        return \"X Wins\"\n    }\n    \n    if checkWinner(\"O\") {\n        return \"O Wins\"\n    }\n    \n    // Check if the game is still ongoing\n    if board.contains(where: { $0.contains(\"\") }) {\n        return \"Ongoing\"\n    }\n    \n    // If no winner and no empty spaces, it's a tie\n    return \"Tie\"\n}\nfunc testEvaluateTicTacToeGame() {\n    // X wins via first row\n    let board1 = [\n        [\"X\", \"X\", \"X\"],\n        [\"O\", \"O\", \"\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board1) == \"X Wins\")\n    \n    // O wins via diagonal\n    let board2 = [\n        [\"O\", \"X\", \"\"],\n        [\"X\", \"O\", \"\"],\n        [\"\", \"\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board2) == \"O Wins\")\n    \n    // Ongoing game\n    let board3 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"\", \"\", \"\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board3) == \"Ongoing\")\n    \n    // Tie game\n    let board4 = [\n        [\"X\", \"O\", \"X\"],\n        [\"O\", \"X\", \"O\"],\n        [\"O\", \"X\", \"O\"]\n    ]\n    assert(evaluateTicTacToeGame(board: board4) == \"Tie\")\n}\n\ntestEvaluateTicTacToeGame()", "exec_outcome": "PASSED"}
{"code": "// filterEvents filters an array of event timestamps based on the given minimum and maximum time limits.\n// If minTime or maxTime is nil, it means there is no lower or upper bound, respectively.\n// The function returns a new array containing only the events that fall within the specified time range.\nfunc filterEvents(events: [Int], minTime: Int? = nil, maxTime: Int? = nil) -> [Int] {\n    var filteredEvents: [Int] = []\n    \n    for event in events {\n        let isAfterMinTime = minTime == nil || event >= minTime!\n        let isBeforeMaxTime = maxTime == nil || event <= maxTime!\n        \n        if isAfterMinTime && isBeforeMaxTime {\n            filteredEvents.append(event)\n        }\n    }\n    \n    return filteredEvents\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4, 5]\nMinTime: Optional(2), MaxTime: Optional(4)\nFiltered Events: [2, 3, 4]\n---\nInput: [10, 20, 30, 40]\nMinTime: nil, MaxTime: Optional(30)\nFiltered Events: [10, 20, 30]\n---\nInput: [5, 10, 15, 20]\nMinTime: Optional(10), MaxTime: nil\nFiltered Events: [10, 15, 20]\n---\nInput: [1, 2, 3, 4]\nMinTime: nil, MaxTime: nil\nFiltered Events: [1, 2, 3, 4]\n---\nInput: []\nMinTime: Optional(1), MaxTime: Optional(10)\nFiltered Events: []\n---", "task_id": 27746, "assertions": "func testFilterEvents() {\n    assert(filterEvents(events: [1, 2, 3, 4, 5], minTime: 2, maxTime: 4) == [2, 3, 4])\n    assert(filterEvents(events: [10, 20, 30, 40], minTime: nil, maxTime: 30) == [10, 20, 30])\n    assert(filterEvents(events: [5, 10, 15, 20], minTime: 10, maxTime: nil) == [10, 15, 20])\n    assert(filterEvents(events: [1, 2, 3, 4], minTime: nil, maxTime: nil) == [1, 2, 3, 4])\n    assert(filterEvents(events: [], minTime: 1, maxTime: 10) == [])\n}\n\ntestFilterEvents()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFilterEvents() {\n    assert(filterEvents(events: [1, 2, 3, 4, 5], minTime: 2, maxTime: 4) == [2, 3, 4])\n    assert(filterEvents(events: [10, 20, 30, 40], minTime: nil, maxTime: 30) == [10, 20, 30])\n    assert(filterEvents(events: [5, 10, 15, 20], minTime: 10, maxTime: nil) == [10, 15, 20])\n    assert(filterEvents(events: [1, 2, 3, 4], minTime: nil, maxTime: nil) == [1, 2, 3, 4])\n    assert(filterEvents(events: [], minTime: 1, maxTime: 10) == [])\n}\n\ntestFilterEvents()", "output": "filterEvents"}, "all_code": "// filterEvents filters an array of event timestamps based on the given minimum and maximum time limits.\n// If minTime or maxTime is nil, it means there is no lower or upper bound, respectively.\n// The function returns a new array containing only the events that fall within the specified time range.\nfunc filterEvents(events: [Int], minTime: Int? = nil, maxTime: Int? = nil) -> [Int] {\n    var filteredEvents: [Int] = []\n    \n    for event in events {\n        let isAfterMinTime = minTime == nil || event >= minTime!\n        let isBeforeMaxTime = maxTime == nil || event <= maxTime!\n        \n        if isAfterMinTime && isBeforeMaxTime {\n            filteredEvents.append(event)\n        }\n    }\n    \n    return filteredEvents\n}\nfunc testFilterEvents() {\n    assert(filterEvents(events: [1, 2, 3, 4, 5], minTime: 2, maxTime: 4) == [2, 3, 4])\n    assert(filterEvents(events: [10, 20, 30, 40], minTime: nil, maxTime: 30) == [10, 20, 30])\n    assert(filterEvents(events: [5, 10, 15, 20], minTime: 10, maxTime: nil) == [10, 15, 20])\n    assert(filterEvents(events: [1, 2, 3, 4], minTime: nil, maxTime: nil) == [1, 2, 3, 4])\n    assert(filterEvents(events: [], minTime: 1, maxTime: 10) == [])\n}\n\ntestFilterEvents()", "exec_outcome": "PASSED"}
{"code": "// largestPalindromeLessThanOrEqualTo finds the largest palindrome number less than or equal to a given number N.\n// A palindrome number reads the same forwards and backwards.\n// The function checks each number from N down to 0 and returns the first palindrome it finds.\nfunc largestPalindromeLessThanOrEqualTo(_ N: Int) -> Int {\n    for num in stride(from: N, through: 0, by: -1) {\n        let numStr = String(num)\n        if numStr == String(numStr.reversed()) {\n            return num\n        }\n    }\n    return 0 // This line is theoretically unreachable if N >= 0\n}", "test_cases": "", "test_case_results": "Input: 123\nLargest Palindrome: 121\nInput: 45654\nLargest Palindrome: 45654\nInput: 1000\nLargest Palindrome: 999\nInput: 999\nLargest Palindrome: 999\nInput: 0\nLargest Palindrome: 0\nInput: 1\nLargest Palindrome: 1", "task_id": 20072, "assertions": "func testLargestPalindrome() {\n    assert(largestPalindromeLessThanOrEqualTo(123) == 121)\n    assert(largestPalindromeLessThanOrEqualTo(45654) == 45654)\n    assert(largestPalindromeLessThanOrEqualTo(1000) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(999) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(0) == 0)\n    assert(largestPalindromeLessThanOrEqualTo(1) == 1)\n}\n\ntestLargestPalindrome()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testLargestPalindrome() {\n    assert(largestPalindromeLessThanOrEqualTo(123) == 121)\n    assert(largestPalindromeLessThanOrEqualTo(45654) == 45654)\n    assert(largestPalindromeLessThanOrEqualTo(1000) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(999) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(0) == 0)\n    assert(largestPalindromeLessThanOrEqualTo(1) == 1)\n}\n\ntestLargestPalindrome()", "output": "largestPalindromeLessThanOrEqualTo"}, "all_code": "// largestPalindromeLessThanOrEqualTo finds the largest palindrome number less than or equal to a given number N.\n// A palindrome number reads the same forwards and backwards.\n// The function checks each number from N down to 0 and returns the first palindrome it finds.\nfunc largestPalindromeLessThanOrEqualTo(_ N: Int) -> Int {\n    for num in stride(from: N, through: 0, by: -1) {\n        let numStr = String(num)\n        if numStr == String(numStr.reversed()) {\n            return num\n        }\n    }\n    return 0 // This line is theoretically unreachable if N >= 0\n}\nfunc testLargestPalindrome() {\n    assert(largestPalindromeLessThanOrEqualTo(123) == 121)\n    assert(largestPalindromeLessThanOrEqualTo(45654) == 45654)\n    assert(largestPalindromeLessThanOrEqualTo(1000) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(999) == 999)\n    assert(largestPalindromeLessThanOrEqualTo(0) == 0)\n    assert(largestPalindromeLessThanOrEqualTo(1) == 1)\n}\n\ntestLargestPalindrome()", "exec_outcome": "PASSED"}
{"code": "// groupBalls groups consecutive identical characters in a string and returns the count of groups and the groups themselves.\n// The function takes an integer `n` representing the length of the string and a string `s` to be processed.\n// If `n` is 0, it returns 0 and an empty array.\n// The function iterates through the string, grouping consecutive identical characters into substrings.\nfunc groupBalls(n: Int, s: String) -> (Int, [String]) {\n    if n == 0 {\n        return (0, [])\n    }\n    \n    var groups: [String] = []\n    var i = s.startIndex\n    \n    while i < s.endIndex {\n        var group = String(s[i])\n        var nextIndex = s.index(after: i)\n        \n        while nextIndex < s.endIndex && s[nextIndex] == s[i] {\n            group.append(s[nextIndex])\n            nextIndex = s.index(after: nextIndex)\n        }\n        \n        groups.append(group)\n        i = nextIndex\n    }\n    \n    return (groups.count, groups)\n}", "test_cases": "", "test_case_results": "Input: n = 0, s = \"\"\nGroup count: 0, Groups: []\nInput: n = 5, s = \"aabbb\"\nGroup count: 2, Groups: [\"aa\", \"bbb\"]\nInput: n = 6, s = \"aaabbb\"\nGroup count: 2, Groups: [\"aaa\", \"bbb\"]\nInput: n = 7, s = \"abcdeff\"\nGroup count: 6, Groups: [\"a\", \"b\", \"c\", \"d\", \"e\", \"ff\"]\nInput: n = 10, s = \"aabbccddee\"\nGroup count: 5, Groups: [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"]", "task_id": 1200, "assertions": "func testGroupBalls() {\n    // Test empty string case\n    let (count0, groups0) = groupBalls(n: 0, s: \"\")\n    assert(count0 == 0)\n    assert(groups0 == [])\n    \n    // Test case with 2 groups\n    let (count1, groups1) = groupBalls(n: 5, s: \"aabbb\")\n    assert(count1 == 2)\n    assert(groups1 == [\"aa\", \"bbb\"])\n    \n    // Test case with 2 groups of equal length\n    let (count2, groups2) = groupBalls(n: 6, s: \"aaabbb\")\n    assert(count2 == 2)\n    assert(groups2 == [\"aaa\", \"bbb\"])\n    \n    // Test case with multiple single-character groups and one double\n    let (count3, groups3) = groupBalls(n: 7, s: \"abcdeff\")\n    assert(count3 == 6)\n    assert(groups3 == [\"a\", \"b\", \"c\", \"d\", \"e\", \"ff\"])\n    \n    // Test case with multiple pairs\n    let (count4, groups4) = groupBalls(n: 10, s: \"aabbccddee\")\n    assert(count4 == 5)\n    assert(groups4 == [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"])\n}\n\ntestGroupBalls()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testGroupBalls() {\n    // Test empty string case\n    let (count0, groups0) = groupBalls(n: 0, s: \"\")\n    assert(count0 == 0)\n    assert(groups0 == [])\n    \n    // Test case with 2 groups\n    let (count1, groups1) = groupBalls(n: 5, s: \"aabbb\")\n    assert(count1 == 2)\n    assert(groups1 == [\"aa\", \"bbb\"])\n    \n    // Test case with 2 groups of equal length\n    let (count2, groups2) = groupBalls(n: 6, s: \"aaabbb\")\n    assert(count2 == 2)\n    assert(groups2 == [\"aaa\", \"bbb\"])\n    \n    // Test case with multiple single-character groups and one double\n    let (count3, groups3) = groupBalls(n: 7, s: \"abcdeff\")\n    assert(count3 == 6)\n    assert(groups3 == [\"a\", \"b\", \"c\", \"d\", \"e\", \"ff\"])\n    \n    // Test case with multiple pairs\n    let (count4, groups4) = groupBalls(n: 10, s: \"aabbccddee\")\n    assert(count4 == 5)\n    assert(groups4 == [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"])\n}\n\ntestGroupBalls()", "output": "groupBalls"}, "all_code": "// groupBalls groups consecutive identical characters in a string and returns the count of groups and the groups themselves.\n// The function takes an integer `n` representing the length of the string and a string `s` to be processed.\n// If `n` is 0, it returns 0 and an empty array.\n// The function iterates through the string, grouping consecutive identical characters into substrings.\nfunc groupBalls(n: Int, s: String) -> (Int, [String]) {\n    if n == 0 {\n        return (0, [])\n    }\n    \n    var groups: [String] = []\n    var i = s.startIndex\n    \n    while i < s.endIndex {\n        var group = String(s[i])\n        var nextIndex = s.index(after: i)\n        \n        while nextIndex < s.endIndex && s[nextIndex] == s[i] {\n            group.append(s[nextIndex])\n            nextIndex = s.index(after: nextIndex)\n        }\n        \n        groups.append(group)\n        i = nextIndex\n    }\n    \n    return (groups.count, groups)\n}\nfunc testGroupBalls() {\n    // Test empty string case\n    let (count0, groups0) = groupBalls(n: 0, s: \"\")\n    assert(count0 == 0)\n    assert(groups0 == [])\n    \n    // Test case with 2 groups\n    let (count1, groups1) = groupBalls(n: 5, s: \"aabbb\")\n    assert(count1 == 2)\n    assert(groups1 == [\"aa\", \"bbb\"])\n    \n    // Test case with 2 groups of equal length\n    let (count2, groups2) = groupBalls(n: 6, s: \"aaabbb\")\n    assert(count2 == 2)\n    assert(groups2 == [\"aaa\", \"bbb\"])\n    \n    // Test case with multiple single-character groups and one double\n    let (count3, groups3) = groupBalls(n: 7, s: \"abcdeff\")\n    assert(count3 == 6)\n    assert(groups3 == [\"a\", \"b\", \"c\", \"d\", \"e\", \"ff\"])\n    \n    // Test case with multiple pairs\n    let (count4, groups4) = groupBalls(n: 10, s: \"aabbccddee\")\n    assert(count4 == 5)\n    assert(groups4 == [\"aa\", \"bb\", \"cc\", \"dd\", \"ee\"])\n}\n\ntestGroupBalls()", "exec_outcome": "PASSED"}
{"code": "// diagonalTraversal returns the elements of the matrix in diagonal order traversal.\n// The traversal alternates between moving up-right and down-left diagonally.\n// For example, given the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]], the traversal order is [1, 2, 4, 7, 5, 3, 6, 8, 9].\nfunc diagonalTraversal(matrix: [[Int]]) -> [Int] {\n    // Check if the matrix is empty or if any row is empty\n    if matrix.isEmpty || matrix[0].isEmpty {\n        return []\n    }\n    \n    let m = matrix.count\n    let n = matrix[0].count\n    var result = [Int]()\n    \n    for d in 0..<(m + n - 1) {\n        if d % 2 == 0 {\n            // Traverse up-right\n            for i in stride(from: min(d, m - 1), through: max(0, d - n + 1), by: -1) {\n                let j = d - i\n                result.append(matrix[i][j])\n            }\n        } else {\n            // Traverse down-left\n            for i in max(0, d - n + 1)...min(d, m - 1) {\n                let j = d - i\n                result.append(matrix[i][j])\n            }\n        }\n    }\n    \n    return result\n}", "test_cases": "", "test_case_results": "Input matrix:\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\nDiagonal traversal: [1, 2, 4, 7, 5, 3, 6, 8, 9]\n\nInput matrix:\n[1, 2]\n[3, 4]\nDiagonal traversal: [1, 2, 3, 4]\n\nInput matrix:\n[1, 2, 3, 4]\n[5, 6, 7, 8]\nDiagonal traversal: [1, 2, 5, 6, 3, 4, 7, 8]\n\nInput matrix:\n[1]\n[2]\n[3]\nDiagonal traversal: [1, 2, 3]\n\nInput matrix:\nDiagonal traversal: []", "task_id": 22833, "assertions": "func testDiagonalTraversal() {\n    assert(diagonalTraversal(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 4, 7, 5, 3, 6, 8, 9])\n    assert(diagonalTraversal(matrix: [[1, 2], [3, 4]]) == [1, 2, 3, 4])\n    assert(diagonalTraversal(matrix: [[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 5, 6, 3, 4, 7, 8])\n    assert(diagonalTraversal(matrix: [[1], [2], [3]]) == [1, 2, 3])\n    assert(diagonalTraversal(matrix: []) == [])\n}\n\ntestDiagonalTraversal()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testDiagonalTraversal() {\n    assert(diagonalTraversal(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 4, 7, 5, 3, 6, 8, 9])\n    assert(diagonalTraversal(matrix: [[1, 2], [3, 4]]) == [1, 2, 3, 4])\n    assert(diagonalTraversal(matrix: [[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 5, 6, 3, 4, 7, 8])\n    assert(diagonalTraversal(matrix: [[1], [2], [3]]) == [1, 2, 3])\n    assert(diagonalTraversal(matrix: []) == [])\n}\n\ntestDiagonalTraversal()", "output": "diagonalTraversal"}, "all_code": "// diagonalTraversal returns the elements of the matrix in diagonal order traversal.\n// The traversal alternates between moving up-right and down-left diagonally.\n// For example, given the matrix [[1, 2, 3], [4, 5, 6], [7, 8, 9]], the traversal order is [1, 2, 4, 7, 5, 3, 6, 8, 9].\nfunc diagonalTraversal(matrix: [[Int]]) -> [Int] {\n    // Check if the matrix is empty or if any row is empty\n    if matrix.isEmpty || matrix[0].isEmpty {\n        return []\n    }\n    \n    let m = matrix.count\n    let n = matrix[0].count\n    var result = [Int]()\n    \n    for d in 0..<(m + n - 1) {\n        if d % 2 == 0 {\n            // Traverse up-right\n            for i in stride(from: min(d, m - 1), through: max(0, d - n + 1), by: -1) {\n                let j = d - i\n                result.append(matrix[i][j])\n            }\n        } else {\n            // Traverse down-left\n            for i in max(0, d - n + 1)...min(d, m - 1) {\n                let j = d - i\n                result.append(matrix[i][j])\n            }\n        }\n    }\n    \n    return result\n}\nfunc testDiagonalTraversal() {\n    assert(diagonalTraversal(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 4, 7, 5, 3, 6, 8, 9])\n    assert(diagonalTraversal(matrix: [[1, 2], [3, 4]]) == [1, 2, 3, 4])\n    assert(diagonalTraversal(matrix: [[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 5, 6, 3, 4, 7, 8])\n    assert(diagonalTraversal(matrix: [[1], [2], [3]]) == [1, 2, 3])\n    assert(diagonalTraversal(matrix: []) == [])\n}\n\ntestDiagonalTraversal()", "exec_outcome": "PASSED"}
{"code": "// sumQuery returns the sum of elements from index l to index r (1-based indexing) in the array.\n// It converts the 1-based indices to 0-based for Swift array access.\nfunc sumQuery(l: Int, r: Int, array: [Int]) -> Int {\n    let startIndex = l - 1\n    let endIndex = r - 1\n    return array[startIndex...endIndex].reduce(0, +)\n}\n\n// findSegments identifies segments of zeros and segments of the maximum value (m) in the array.\n// It returns two arrays of tuples representing the start and end indices (1-based) of these segments.\nfunc findSegments(n: Int, m: Int, array: [Int]) -> ([(Int, Int)], [(Int, Int)]) {\n    var zeroSegments: [(Int, Int)] = []\n    var highSegments: [(Int, Int)] = []\n    var i = 0\n    \n    while i < n {\n        if array[i] == 0 {\n            let start = i\n            while i < n && array[i] == 0 {\n                i += 1\n            }\n            zeroSegments.append((start + 1, i)) // converting to 1-based indexing\n        } else if array[i] == m {\n            let start = i\n            while i < n && array[i] == m {\n                i += 1\n            }\n            highSegments.append((start + 1, i)) // converting to 1-based indexing\n        } else {\n            i += 1\n        }\n    }\n    \n    return (zeroSegments, highSegments)\n}", "test_cases": "", "test_case_results": "Testing sumQuery function:\nInput array: [1, 0, 3, 4, 0, 5, 6, 0, 7], l: 1, r: 3\nSum: 4\nInput array: [1, 0, 3, 4, 0, 5, 6, 0, 7], l: 2, r: 5\nSum: 7\nInput array: [1, 0, 3, 4, 0, 5, 6, 0, 7], l: 4, r: 7\nSum: 15\n\nTesting findSegments function:\nInput array: [1, 0, 3, 4, 0, 5, 6, 0, 7], n: 9, m: 7\nZero segments: [(2, 2), (5, 5), (8, 8)]\nHigh segments: [(9, 9)]", "task_id": 17275, "assertions": "func testSumQueryAndFindSegments() {\n    let testArray = [1, 0, 3, 4, 0, 5, 6, 0, 7]\n    let n = testArray.count\n    let m = 7\n    \n    // Test sumQuery\n    assert(sumQuery(l: 1, r: 3, array: testArray) == 4)\n    assert(sumQuery(l: 2, r: 5, array: testArray) == 7)\n    assert(sumQuery(l: 4, r: 7, array: testArray) == 15)\n    \n    // Test findSegments\n    let (zeroSegments, highSegments) = findSegments(n: n, m: m, array: testArray)\n    assert(zeroSegments == [(2, 2), (5, 5), (8, 8)])\n    assert(highSegments == [(9, 9)])\n}\n\ntestSumQueryAndFindSegments()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSumQueryAndFindSegments() {\n    let testArray = [1, 0, 3, 4, 0, 5, 6, 0, 7]\n    let n = testArray.count\n    let m = 7\n    \n    // Test sumQuery\n    assert(sumQuery(l: 1, r: 3, array: testArray) == 4)\n    assert(sumQuery(l: 2, r: 5, array: testArray) == 7)\n    assert(sumQuery(l: 4, r: 7, array: testArray) == 15)\n    \n    // Test findSegments\n    let (zeroSegments, highSegments) = findSegments(n: n, m: m, array: testArray)\n    assert(zeroSegments == [(2, 2), (5, 5), (8, 8)])\n    assert(highSegments == [(9, 9)])\n}\n\ntestSumQueryAndFindSegments()", "output": "The names of the functions being tested are:\n\nsumQuery\nfindSegments"}, "all_code": "// sumQuery returns the sum of elements from index l to index r (1-based indexing) in the array.\n// It converts the 1-based indices to 0-based for Swift array access.\nfunc sumQuery(l: Int, r: Int, array: [Int]) -> Int {\n    let startIndex = l - 1\n    let endIndex = r - 1\n    return array[startIndex...endIndex].reduce(0, +)\n}\n\n// findSegments identifies segments of zeros and segments of the maximum value (m) in the array.\n// It returns two arrays of tuples representing the start and end indices (1-based) of these segments.\nfunc findSegments(n: Int, m: Int, array: [Int]) -> ([(Int, Int)], [(Int, Int)]) {\n    var zeroSegments: [(Int, Int)] = []\n    var highSegments: [(Int, Int)] = []\n    var i = 0\n    \n    while i < n {\n        if array[i] == 0 {\n            let start = i\n            while i < n && array[i] == 0 {\n                i += 1\n            }\n            zeroSegments.append((start + 1, i)) // converting to 1-based indexing\n        } else if array[i] == m {\n            let start = i\n            while i < n && array[i] == m {\n                i += 1\n            }\n            highSegments.append((start + 1, i)) // converting to 1-based indexing\n        } else {\n            i += 1\n        }\n    }\n    \n    return (zeroSegments, highSegments)\n}\nfunc testSumQueryAndFindSegments() {\n    let testArray = [1, 0, 3, 4, 0, 5, 6, 0, 7]\n    let n = testArray.count\n    let m = 7\n    \n    // Test sumQuery\n    assert(sumQuery(l: 1, r: 3, array: testArray) == 4)\n    assert(sumQuery(l: 2, r: 5, array: testArray) == 7)\n    assert(sumQuery(l: 4, r: 7, array: testArray) == 15)\n    \n    // Test findSegments\n    let (zeroSegments, highSegments) = findSegments(n: n, m: m, array: testArray)\n    assert(zeroSegments == [(2, 2), (5, 5), (8, 8)])\n    assert(highSegments == [(9, 9)])\n}\n\ntestSumQueryAndFindSegments()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Graph represents a directed graph and provides functionality to find strongly connected components\n// using Kosaraju's algorithm.\nclass Graph {\n    let numNodes: Int\n    let numEdges: Int\n    var adjList: [[Int]]\n    var revAdjList: [[Int]]\n    \n    // Initialize the graph with the given number of nodes and edges\n    init(numNodes: Int, numEdges: Int) {\n        self.numNodes = numNodes\n        self.numEdges = numEdges\n        self.adjList = Array(repeating: [Int](), count: numNodes)\n        self.revAdjList = Array(repeating: [Int](), count: numNodes)\n    }\n    \n    // Add a directed edge from source node to destination node\n    func addEdge(src: Int, dest: Int) {\n        adjList[src].append(dest)\n        revAdjList[dest].append(src)\n    }\n    \n    // Perform depth-first search and fill the stack with nodes in order of finishing times\n    private func dfs(node: Int, visited: inout [Bool], stack: inout [Int]) {\n        visited[node] = true\n        for neighbor in adjList[node] {\n            if !visited[neighbor] {\n                dfs(node: neighbor, visited: &visited, stack: &stack)\n            }\n        }\n        stack.append(node)\n    }\n    \n    // Perform depth-first search on the reversed graph\n    private func reverseDfs(node: Int, visited: inout [Bool]) {\n        visited[node] = true\n        for neighbor in revAdjList[node] {\n            if !visited[neighbor] {\n                reverseDfs(node: neighbor, visited: &visited)\n            }\n        }\n    }\n    \n    // Find the number of strongly connected components using Kosaraju's algorithm\n    func kosaraju() -> Int {\n        var stack = [Int]()\n        var visited = Array(repeating: false, count: numNodes)\n        \n        // Step 1: Fill stack with nodes in order of finishing times\n        for i in 0..<numNodes {\n            if !visited[i] {\n                dfs(node: i, visited: &visited, stack: &stack)\n            }\n        }\n        \n        // Step 2: Process nodes in reverse order of finishing times on reversed graph\n        visited = Array(repeating: false, count: numNodes)\n        var sccCount = 0\n        \n        while !stack.isEmpty {\n            let node = stack.removeLast()\n            if !visited[node] {\n                reverseDfs(node: node, visited: &visited)\n                sccCount += 1\n            }\n        }\n        \n        return sccCount\n    }\n}", "test_cases": "", "test_case_results": "Test Case 1:\nNumber of nodes: 5\nEdges: [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]\nNumber of strongly connected components: 1\nExpected: 1\nTest Passed\n\nTest Case 2:\nNumber of nodes: 5\nEdges: [(0, 1), (1, 2), (3, 4)]\nNumber of strongly connected components: 5\nExpected: 3\nTest Failed\n\nTest Case 3:\nNumber of nodes: 4\nEdges: [(0, 1), (1, 0), (2, 3), (3, 2)]\nNumber of strongly connected components: 2\nExpected: 2\nTest Passed\n\nTest Case 4:\nNumber of nodes: 3\nEdges: []\nNumber of strongly connected components: 3\nExpected: 3\nTest Passed", "task_id": 25185, "assertions": "func testGraphKosaraju() {\n    // Test case 1: Graph with 5 nodes and 5 edges forming one SCC\n    let graph1 = Graph(numNodes: 5, numEdges: 5)\n    for edge in [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] {\n        graph1.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph1.kosaraju() == 1)\n    \n    // Test case 2: Graph with 5 nodes and 3 edges forming 3 SCCs\n    let graph2 = Graph(numNodes: 5, numEdges: 3)\n    for edge in [(0, 1), (1, 2), (3, 4)] {\n        graph2.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph2.kosaraju() == 3)\n    \n    // Test case 3: Graph with 4 nodes and 4 edges forming 2 SCCs\n    let graph3 = Graph(numNodes: 4, numEdges: 4)\n    for edge in [(0, 1), (1, 0), (2, 3), (3, 2)] {\n        graph3.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph3.kosaraju() == 2)\n    \n    // Test case 4: Graph with 3 nodes and no edges (3 SCCs)\n    let graph4 = Graph(numNodes: 3, numEdges: 0)\n    assert(graph4.kosaraju() == 3)\n}\n\ntestGraphKosaraju()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testGraphKosaraju() {\n    // Test case 1: Graph with 5 nodes and 5 edges forming one SCC\n    let graph1 = Graph(numNodes: 5, numEdges: 5)\n    for edge in [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] {\n        graph1.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph1.kosaraju() == 1)\n    \n    // Test case 2: Graph with 5 nodes and 3 edges forming 3 SCCs\n    let graph2 = Graph(numNodes: 5, numEdges: 3)\n    for edge in [(0, 1), (1, 2), (3, 4)] {\n        graph2.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph2.kosaraju() == 3)\n    \n    // Test case 3: Graph with 4 nodes and 4 edges forming 2 SCCs\n    let graph3 = Graph(numNodes: 4, numEdges: 4)\n    for edge in [(0, 1), (1, 0), (2, 3), (3, 2)] {\n        graph3.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph3.kosaraju() == 2)\n    \n    // Test case 4: Graph with 3 nodes and no edges (3 SCCs)\n    let graph4 = Graph(numNodes: 3, numEdges: 0)\n    assert(graph4.kosaraju() == 3)\n}\n\ntestGraphKosaraju()", "output": "kosaraju"}, "all_code": "import Foundation\nimport Glibc\n\n// Graph represents a directed graph and provides functionality to find strongly connected components\n// using Kosaraju's algorithm.\nclass Graph {\n    let numNodes: Int\n    let numEdges: Int\n    var adjList: [[Int]]\n    var revAdjList: [[Int]]\n    \n    // Initialize the graph with the given number of nodes and edges\n    init(numNodes: Int, numEdges: Int) {\n        self.numNodes = numNodes\n        self.numEdges = numEdges\n        self.adjList = Array(repeating: [Int](), count: numNodes)\n        self.revAdjList = Array(repeating: [Int](), count: numNodes)\n    }\n    \n    // Add a directed edge from source node to destination node\n    func addEdge(src: Int, dest: Int) {\n        adjList[src].append(dest)\n        revAdjList[dest].append(src)\n    }\n    \n    // Perform depth-first search and fill the stack with nodes in order of finishing times\n    private func dfs(node: Int, visited: inout [Bool], stack: inout [Int]) {\n        visited[node] = true\n        for neighbor in adjList[node] {\n            if !visited[neighbor] {\n                dfs(node: neighbor, visited: &visited, stack: &stack)\n            }\n        }\n        stack.append(node)\n    }\n    \n    // Perform depth-first search on the reversed graph\n    private func reverseDfs(node: Int, visited: inout [Bool]) {\n        visited[node] = true\n        for neighbor in revAdjList[node] {\n            if !visited[neighbor] {\n                reverseDfs(node: neighbor, visited: &visited)\n            }\n        }\n    }\n    \n    // Find the number of strongly connected components using Kosaraju's algorithm\n    func kosaraju() -> Int {\n        var stack = [Int]()\n        var visited = Array(repeating: false, count: numNodes)\n        \n        // Step 1: Fill stack with nodes in order of finishing times\n        for i in 0..<numNodes {\n            if !visited[i] {\n                dfs(node: i, visited: &visited, stack: &stack)\n            }\n        }\n        \n        // Step 2: Process nodes in reverse order of finishing times on reversed graph\n        visited = Array(repeating: false, count: numNodes)\n        var sccCount = 0\n        \n        while !stack.isEmpty {\n            let node = stack.removeLast()\n            if !visited[node] {\n                reverseDfs(node: node, visited: &visited)\n                sccCount += 1\n            }\n        }\n        \n        return sccCount\n    }\n}\nfunc testGraphKosaraju() {\n    // Test case 1: Graph with 5 nodes and 5 edges forming one SCC\n    let graph1 = Graph(numNodes: 5, numEdges: 5)\n    for edge in [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)] {\n        graph1.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph1.kosaraju() == 1)\n    \n    // Test case 2: Graph with 5 nodes and 3 edges forming 3 SCCs\n    let graph2 = Graph(numNodes: 5, numEdges: 3)\n    for edge in [(0, 1), (1, 2), (3, 4)] {\n        graph2.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph2.kosaraju() == 3)\n    \n    // Test case 3: Graph with 4 nodes and 4 edges forming 2 SCCs\n    let graph3 = Graph(numNodes: 4, numEdges: 4)\n    for edge in [(0, 1), (1, 0), (2, 3), (3, 2)] {\n        graph3.addEdge(src: edge.0, dest: edge.1)\n    }\n    assert(graph3.kosaraju() == 2)\n    \n    // Test case 4: Graph with 3 nodes and no edges (3 SCCs)\n    let graph4 = Graph(numNodes: 3, numEdges: 0)\n    assert(graph4.kosaraju() == 3)\n}\n\ntestGraphKosaraju()", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// isCircularChainValid checks if a given sequence of clues forms a valid circular chain.\n// The function takes two parameters:\n// - n: the number of elements in the chain.\n// - clues: an array of integers where each element points to the next position in the chain.\n// The function returns \"YES\" if the chain is valid (i.e., it forms a single cycle visiting all elements exactly once and ending at the start),\n// otherwise it returns \"NO\".\nfunc isCircularChainValid(n: Int, clues: [Int]) -> String {\n    var visited = [Bool](repeating: false, count: n)\n    var current = 0\n    for _ in 0..<n {\n        if visited[current] {\n            return \"NO\"\n        }\n        visited[current] = true\n        current = clues[current] - 1\n    }\n    return current == 0 ? \"YES\" : \"NO\"\n}", "test_cases": "", "test_case_results": "n: 3, clues: [2, 3, 1]\nYES\nn: 3, clues: [2, 1, 3]\nNO\nn: 4, clues: [2, 3, 4, 1]\nYES\nn: 4, clues: [2, 1, 4, 3]\nNO\nn: 1, clues: [1]\nYES", "task_id": 22100, "assertions": "func testIsCircularChainValid() {\n    assert(isCircularChainValid(n: 3, clues: [2, 3, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 3, clues: [2, 1, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 4, clues: [2, 3, 4, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 4, clues: [2, 1, 4, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 1, clues: [1]) == \"YES\")\n}\n\ntestIsCircularChainValid()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testIsCircularChainValid() {\n    assert(isCircularChainValid(n: 3, clues: [2, 3, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 3, clues: [2, 1, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 4, clues: [2, 3, 4, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 4, clues: [2, 1, 4, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 1, clues: [1]) == \"YES\")\n}\n\ntestIsCircularChainValid()", "output": "isCircularChainValid"}, "all_code": "import Foundation\nimport Glibc\n\n// isCircularChainValid checks if a given sequence of clues forms a valid circular chain.\n// The function takes two parameters:\n// - n: the number of elements in the chain.\n// - clues: an array of integers where each element points to the next position in the chain.\n// The function returns \"YES\" if the chain is valid (i.e., it forms a single cycle visiting all elements exactly once and ending at the start),\n// otherwise it returns \"NO\".\nfunc isCircularChainValid(n: Int, clues: [Int]) -> String {\n    var visited = [Bool](repeating: false, count: n)\n    var current = 0\n    for _ in 0..<n {\n        if visited[current] {\n            return \"NO\"\n        }\n        visited[current] = true\n        current = clues[current] - 1\n    }\n    return current == 0 ? \"YES\" : \"NO\"\n}\nfunc testIsCircularChainValid() {\n    assert(isCircularChainValid(n: 3, clues: [2, 3, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 3, clues: [2, 1, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 4, clues: [2, 3, 4, 1]) == \"YES\")\n    assert(isCircularChainValid(n: 4, clues: [2, 1, 4, 3]) == \"NO\")\n    assert(isCircularChainValid(n: 1, clues: [1]) == \"YES\")\n}\n\ntestIsCircularChainValid()", "exec_outcome": "PASSED"}
{"code": "// repeatElements takes an array of integers and repeats its elements a specified number of times.\n// For example, given the input [1, 2, 3] and times = 2, the result will be [1, 2, 3, 1, 2, 3].\n// If the input array is empty or times is zero, the result will be an empty array.\nfunc repeatElements(inputList: [Int], times: Int) -> [Int] {\n    guard times > 0 else {\n        return []\n    }\n    return Array(repeating: inputList, count: times).flatMap { $0 }\n}", "test_cases": "", "test_case_results": "Input List: [1, 2, 3], Times: 2\nResult: [1, 2, 3, 1, 2, 3]\nInput List: [4, 5], Times: 3\nResult: [4, 5, 4, 5, 4, 5]\nInput List: [], Times: 5\nResult: []\nInput List: [10, 20, 30], Times: 0\nResult: []\nInput List: [7], Times: 1\nResult: [7]", "task_id": 21647, "assertions": "func testRepeatElements() {\n    assert(repeatElements(inputList: [1, 2, 3], times: 2) == [1, 2, 3, 1, 2, 3])\n    assert(repeatElements(inputList: [4, 5], times: 3) == [4, 5, 4, 5, 4, 5])\n    assert(repeatElements(inputList: [], times: 5) == [])\n    assert(repeatElements(inputList: [10, 20, 30], times: 0) == [])\n    assert(repeatElements(inputList: [7], times: 1) == [7])\n}\n\ntestRepeatElements()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testRepeatElements() {\n    assert(repeatElements(inputList: [1, 2, 3], times: 2) == [1, 2, 3, 1, 2, 3])\n    assert(repeatElements(inputList: [4, 5], times: 3) == [4, 5, 4, 5, 4, 5])\n    assert(repeatElements(inputList: [], times: 5) == [])\n    assert(repeatElements(inputList: [10, 20, 30], times: 0) == [])\n    assert(repeatElements(inputList: [7], times: 1) == [7])\n}\n\ntestRepeatElements()", "output": "repeatElements"}, "all_code": "// repeatElements takes an array of integers and repeats its elements a specified number of times.\n// For example, given the input [1, 2, 3] and times = 2, the result will be [1, 2, 3, 1, 2, 3].\n// If the input array is empty or times is zero, the result will be an empty array.\nfunc repeatElements(inputList: [Int], times: Int) -> [Int] {\n    guard times > 0 else {\n        return []\n    }\n    return Array(repeating: inputList, count: times).flatMap { $0 }\n}\nfunc testRepeatElements() {\n    assert(repeatElements(inputList: [1, 2, 3], times: 2) == [1, 2, 3, 1, 2, 3])\n    assert(repeatElements(inputList: [4, 5], times: 3) == [4, 5, 4, 5, 4, 5])\n    assert(repeatElements(inputList: [], times: 5) == [])\n    assert(repeatElements(inputList: [10, 20, 30], times: 0) == [])\n    assert(repeatElements(inputList: [7], times: 1) == [7])\n}\n\ntestRepeatElements()", "exec_outcome": "PASSED"}
{"code": "// filterAlphabets takes a string and returns a new string consisting only of the alphabetic characters\n// from the original string, preserving their original order.\n// Non-alphabetic characters are ignored and not included in the result.\nfunc filterAlphabets(from text: String) -> String {\n    var result = \"\"\n    for char in text {\n        if char.isLetter {\n            result.append(char)\n        }\n    }\n    return result\n}", "test_cases": "", "test_case_results": "Input: \"Hello, World!\"\nFiltered: \"HelloWorld\"\nInput: \"123Swift456\"\nFiltered: \"Swift\"\nInput: \"NoNumbersHere\"\nFiltered: \"NoNumbersHere\"\nInput: \"!@#$%^&*()\"\nFiltered: \"\"\nInput: \"\"\nFiltered: \"\"", "task_id": 29814, "assertions": "func testFilterAlphabets() {\n    assert(filterAlphabets(from: \"Hello, World!\") == \"HelloWorld\")\n    assert(filterAlphabets(from: \"123Swift456\") == \"Swift\")\n    assert(filterAlphabets(from: \"NoNumbersHere\") == \"NoNumbersHere\")\n    assert(filterAlphabets(from: \"!@#$%^&*()\") == \"\")\n    assert(filterAlphabets(from: \"\") == \"\")\n}\n\ntestFilterAlphabets()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testFilterAlphabets() {\n    assert(filterAlphabets(from: \"Hello, World!\") == \"HelloWorld\")\n    assert(filterAlphabets(from: \"123Swift456\") == \"Swift\")\n    assert(filterAlphabets(from: \"NoNumbersHere\") == \"NoNumbersHere\")\n    assert(filterAlphabets(from: \"!@#$%^&*()\") == \"\")\n    assert(filterAlphabets(from: \"\") == \"\")\n}\n\ntestFilterAlphabets()", "output": "filterAlphabets"}, "all_code": "// filterAlphabets takes a string and returns a new string consisting only of the alphabetic characters\n// from the original string, preserving their original order.\n// Non-alphabetic characters are ignored and not included in the result.\nfunc filterAlphabets(from text: String) -> String {\n    var result = \"\"\n    for char in text {\n        if char.isLetter {\n            result.append(char)\n        }\n    }\n    return result\n}\nfunc testFilterAlphabets() {\n    assert(filterAlphabets(from: \"Hello, World!\") == \"HelloWorld\")\n    assert(filterAlphabets(from: \"123Swift456\") == \"Swift\")\n    assert(filterAlphabets(from: \"NoNumbersHere\") == \"NoNumbersHere\")\n    assert(filterAlphabets(from: \"!@#$%^&*()\") == \"\")\n    assert(filterAlphabets(from: \"\") == \"\")\n}\n\ntestFilterAlphabets()", "exec_outcome": "PASSED"}
{"code": "// minOperationsToUniformMultiples calculates the minimum number of operations required to make all elements in an array\n// either multiples of a given number 'k' or all non-multiples of 'k'.\n// The function counts how many elements are already multiples of 'k' and how many are not,\n// then returns the smaller count, representing the least operations needed to make all elements uniform.\nfunc minOperationsToUniformMultiples(n: Int, k: Int, array: [Int]) -> Int {\n    var countMultiples = 0\n    var countNonMultiples = 0\n    \n    // Count the multiples and non-multiples of k in the array\n    for num in array {\n        if num % k == 0 {\n            countMultiples += 1\n        } else {\n            countNonMultiples += 1\n        }\n    }\n    \n    // The answer is the minimum of modifying all to multiples or all to non-multiples\n    return min(countMultiples, countNonMultiples)\n}", "test_cases": "", "test_case_results": "Input - n: 5, k: 2, array: [1, 2, 3, 4, 5]\nMinimum operations needed: 2\nInput - n: 4, k: 3, array: [3, 6, 9, 12]\nMinimum operations needed: 0\nInput - n: 6, k: 5, array: [10, 20, 30, 11, 21, 31]\nMinimum operations needed: 3\nInput - n: 3, k: 7, array: [1, 2, 3]\nMinimum operations needed: 0", "task_id": 28338, "assertions": "func testMinOperationsToUniformMultiples() {\n    assert(minOperationsToUniformMultiples(n: 5, k: 2, array: [1, 2, 3, 4, 5]) == 2)\n    assert(minOperationsToUniformMultiples(n: 4, k: 3, array: [3, 6, 9, 12]) == 0)\n    assert(minOperationsToUniformMultiples(n: 6, k: 5, array: [10, 20, 30, 11, 21, 31]) == 3)\n    assert(minOperationsToUniformMultiples(n: 3, k: 7, array: [1, 2, 3]) == 0)\n}\n\ntestMinOperationsToUniformMultiples()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMinOperationsToUniformMultiples() {\n    assert(minOperationsToUniformMultiples(n: 5, k: 2, array: [1, 2, 3, 4, 5]) == 2)\n    assert(minOperationsToUniformMultiples(n: 4, k: 3, array: [3, 6, 9, 12]) == 0)\n    assert(minOperationsToUniformMultiples(n: 6, k: 5, array: [10, 20, 30, 11, 21, 31]) == 3)\n    assert(minOperationsToUniformMultiples(n: 3, k: 7, array: [1, 2, 3]) == 0)\n}\n\ntestMinOperationsToUniformMultiples()", "output": "minOperationsToUniformMultiples"}, "all_code": "// minOperationsToUniformMultiples calculates the minimum number of operations required to make all elements in an array\n// either multiples of a given number 'k' or all non-multiples of 'k'.\n// The function counts how many elements are already multiples of 'k' and how many are not,\n// then returns the smaller count, representing the least operations needed to make all elements uniform.\nfunc minOperationsToUniformMultiples(n: Int, k: Int, array: [Int]) -> Int {\n    var countMultiples = 0\n    var countNonMultiples = 0\n    \n    // Count the multiples and non-multiples of k in the array\n    for num in array {\n        if num % k == 0 {\n            countMultiples += 1\n        } else {\n            countNonMultiples += 1\n        }\n    }\n    \n    // The answer is the minimum of modifying all to multiples or all to non-multiples\n    return min(countMultiples, countNonMultiples)\n}\nfunc testMinOperationsToUniformMultiples() {\n    assert(minOperationsToUniformMultiples(n: 5, k: 2, array: [1, 2, 3, 4, 5]) == 2)\n    assert(minOperationsToUniformMultiples(n: 4, k: 3, array: [3, 6, 9, 12]) == 0)\n    assert(minOperationsToUniformMultiples(n: 6, k: 5, array: [10, 20, 30, 11, 21, 31]) == 3)\n    assert(minOperationsToUniformMultiples(n: 3, k: 7, array: [1, 2, 3]) == 0)\n}\n\ntestMinOperationsToUniformMultiples()", "exec_outcome": "PASSED"}
{"code": "// sortedKeepingNegatives returns an array sorted in non-decreasing order, while keeping negative numbers in their original positions.\n// The function processes the input array by first extracting non-negative numbers along with their indices,\n// then sorts these non-negative numbers, and finally places them back into their original positions in the array.\nfunc sortedKeepingNegatives(_ nums: [Int]) -> [Int] {\n    // Extract the indices and values of the non-negative numbers\n    let nonNegatives = nums.enumerated().filter { $0.element >= 0 }\n    \n    // Sort the non-negative values while keeping their original indices\n    let sortedNonNegatives = nonNegatives.sorted { $0.element < $1.element }\n    \n    // Place the sorted non-negative values back into their original positions\n    var result = nums\n    for (originalIndex, newValue) in zip(nonNegatives.map { $0.offset }, sortedNonNegatives.map { $0.element }) {\n        result[originalIndex] = newValue\n    }\n    \n    return result\n}", "test_cases": "", "test_case_results": "Input: [1, -2, 3, -4, 5]\nResult: [1, -2, 3, -4, 5]\nInput: [-1, -2, -3, -4]\nResult: [-1, -2, -3, -4]\nInput: [4, 3, 2, 1]\nResult: [1, 2, 3, 4]\nInput: [1, 2, 3, 4]\nResult: [1, 2, 3, 4]\nInput: []\nResult: []", "task_id": 17741, "assertions": "func testSortedKeepingNegatives() {\n    assert(sortedKeepingNegatives([1, -2, 3, -4, 5]) == [1, -2, 3, -4, 5])\n    assert(sortedKeepingNegatives([-1, -2, -3, -4]) == [-1, -2, -3, -4])\n    assert(sortedKeepingNegatives([4, 3, 2, 1]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([1, 2, 3, 4]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([]) == [])\n}\n\ntestSortedKeepingNegatives()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSortedKeepingNegatives() {\n    assert(sortedKeepingNegatives([1, -2, 3, -4, 5]) == [1, -2, 3, -4, 5])\n    assert(sortedKeepingNegatives([-1, -2, -3, -4]) == [-1, -2, -3, -4])\n    assert(sortedKeepingNegatives([4, 3, 2, 1]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([1, 2, 3, 4]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([]) == [])\n}\n\ntestSortedKeepingNegatives()", "output": "sortedKeepingNegatives"}, "all_code": "import Foundation\nimport Glibc\n\n// sortedKeepingNegatives returns an array sorted in non-decreasing order, while keeping negative numbers in their original positions.\n// The function processes the input array by first extracting non-negative numbers along with their indices,\n// then sorts these non-negative numbers, and finally places them back into their original positions in the array.\nfunc sortedKeepingNegatives(_ nums: [Int]) -> [Int] {\n    // Extract the indices and values of the non-negative numbers\n    let nonNegatives = nums.enumerated().filter { $0.element >= 0 }\n    \n    // Sort the non-negative values while keeping their original indices\n    let sortedNonNegatives = nonNegatives.sorted { $0.element < $1.element }\n    \n    // Place the sorted non-negative values back into their original positions\n    var result = nums\n    for (originalIndex, newValue) in zip(nonNegatives.map { $0.offset }, sortedNonNegatives.map { $0.element }) {\n        result[originalIndex] = newValue\n    }\n    \n    return result\n}\nfunc testSortedKeepingNegatives() {\n    assert(sortedKeepingNegatives([1, -2, 3, -4, 5]) == [1, -2, 3, -4, 5])\n    assert(sortedKeepingNegatives([-1, -2, -3, -4]) == [-1, -2, -3, -4])\n    assert(sortedKeepingNegatives([4, 3, 2, 1]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([1, 2, 3, 4]) == [1, 2, 3, 4])\n    assert(sortedKeepingNegatives([]) == [])\n}\n\ntestSortedKeepingNegatives()", "exec_outcome": "PASSED"}
{"code": "// maxEmployeesWithBikes determines the maximum number of employees who can use bikes without overlapping their time slots.\n// It sorts the time slots based on end time and then assigns bikes to employees in a way that minimizes overlaps.\n// The function uses a greedy algorithm to maximize the number of employees who can use the bikes.\n//\n// Parameters:\n//   - n: The number of employees.\n//   - m: The number of bikes.\n//   - timeSlots: An array of tuples where each tuple contains the start and end time for each employee.\n//\n// Returns:\n//   - The maximum number of employees who can use the bikes without overlapping time slots.\nfunc maxEmployeesWithBikes(n: Int, m: Int, timeSlots: [(start: Int, end: Int)]) -> Int {\n    // Sort the time slots based on end time\n    let sortedSlots = timeSlots.sorted { $0.end < $1.end }\n    \n    // Initialize an array to keep track of the end times of the bikes\n    var bikeEndTimes = [Int](repeating: 0, count: m)\n    var usedBikes = 0\n    \n    for slot in sortedSlots {\n        for i in 0..<m {\n            if bikeEndTimes[i] <= slot.start {\n                bikeEndTimes[i] = slot.end\n                usedBikes += 1\n                break\n            }\n        }\n    }\n    \n    return usedBikes\n}", "test_cases": "", "test_case_results": "Input - Employees: 3, Bikes: 2, Time Slots: [(1, 3), (2, 4), (3, 5)]\nMaximum employees with bikes: 3\n\nInput - Employees: 4, Bikes: 3, Time Slots: [(1, 2), (2, 3), (3, 4), (4, 5)]\nMaximum employees with bikes: 4\n\nInput - Employees: 5, Bikes: 1, Time Slots: [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]\nMaximum employees with bikes: 5\n\nInput - Employees: 2, Bikes: 2, Time Slots: [(1, 4), (2, 3)]\nMaximum employees with bikes: 2", "task_id": 23432, "assertions": "func testMaxEmployeesWithBikes() {\n    // Test case 1\n    assert(maxEmployeesWithBikes(n: 3, m: 2, timeSlots: [(1, 3), (2, 4), (3, 5)]) == 3)\n    \n    // Test case 2\n    assert(maxEmployeesWithBikes(n: 4, m: 3, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4)\n    \n    // Test case 3\n    assert(maxEmployeesWithBikes(n: 5, m: 1, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 5)\n    \n    // Test case 4\n    assert(maxEmployeesWithBikes(n: 2, m: 2, timeSlots: [(1, 4), (2, 3)]) == 2)\n}\n\ntestMaxEmployeesWithBikes()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMaxEmployeesWithBikes() {\n    // Test case 1\n    assert(maxEmployeesWithBikes(n: 3, m: 2, timeSlots: [(1, 3), (2, 4), (3, 5)]) == 3)\n    \n    // Test case 2\n    assert(maxEmployeesWithBikes(n: 4, m: 3, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4)\n    \n    // Test case 3\n    assert(maxEmployeesWithBikes(n: 5, m: 1, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 5)\n    \n    // Test case 4\n    assert(maxEmployeesWithBikes(n: 2, m: 2, timeSlots: [(1, 4), (2, 3)]) == 2)\n}\n\ntestMaxEmployeesWithBikes()", "output": "maxEmployeesWithBikes"}, "all_code": "// maxEmployeesWithBikes determines the maximum number of employees who can use bikes without overlapping their time slots.\n// It sorts the time slots based on end time and then assigns bikes to employees in a way that minimizes overlaps.\n// The function uses a greedy algorithm to maximize the number of employees who can use the bikes.\n//\n// Parameters:\n//   - n: The number of employees.\n//   - m: The number of bikes.\n//   - timeSlots: An array of tuples where each tuple contains the start and end time for each employee.\n//\n// Returns:\n//   - The maximum number of employees who can use the bikes without overlapping time slots.\nfunc maxEmployeesWithBikes(n: Int, m: Int, timeSlots: [(start: Int, end: Int)]) -> Int {\n    // Sort the time slots based on end time\n    let sortedSlots = timeSlots.sorted { $0.end < $1.end }\n    \n    // Initialize an array to keep track of the end times of the bikes\n    var bikeEndTimes = [Int](repeating: 0, count: m)\n    var usedBikes = 0\n    \n    for slot in sortedSlots {\n        for i in 0..<m {\n            if bikeEndTimes[i] <= slot.start {\n                bikeEndTimes[i] = slot.end\n                usedBikes += 1\n                break\n            }\n        }\n    }\n    \n    return usedBikes\n}\nfunc testMaxEmployeesWithBikes() {\n    // Test case 1\n    assert(maxEmployeesWithBikes(n: 3, m: 2, timeSlots: [(1, 3), (2, 4), (3, 5)]) == 3)\n    \n    // Test case 2\n    assert(maxEmployeesWithBikes(n: 4, m: 3, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5)]) == 4)\n    \n    // Test case 3\n    assert(maxEmployeesWithBikes(n: 5, m: 1, timeSlots: [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) == 5)\n    \n    // Test case 4\n    assert(maxEmployeesWithBikes(n: 2, m: 2, timeSlots: [(1, 4), (2, 3)]) == 2)\n}\n\ntestMaxEmployeesWithBikes()", "exec_outcome": "PASSED"}
{"code": "import Foundation\n\n// bfs performs a breadth-first search on a grid starting from a given position.\n// It calculates the shortest distances from the start position to all other positions in the grid.\n// The grid is represented as a 2D array where 0 indicates a passable cell and any other value indicates an obstacle.\n// Returns a 2D array of distances where each cell contains the shortest distance from the start position.\nfunc bfs(grid: [[Int]], start: (Int, Int)) -> [[Int]] {\n    let rows = grid.count\n    let cols = grid[0].count\n    var distances = Array(repeating: Array(repeating: Int.max, count: cols), count: rows)\n    distances[start.0][start.1] = 0\n    var queue = [(Int, Int)]()\n    queue.append(start)\n    \n    while !queue.isEmpty {\n        let (x, y) = queue.removeFirst()\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)] {\n            let nx = x + dx\n            let ny = y + dy\n            if nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 0 && distances[nx][ny] == Int.max {\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n            }\n        }\n    }\n    \n    return distances\n}\n\n// shortestDeliveryRoute calculates the total shortest path length from a warehouse to all customer positions on a grid.\n// The grid is represented as a 2D array where 0 indicates a passable cell and any other value indicates an obstacle.\n// The warehouse and customer positions are given as tuples of (row, column).\n// Throws an error if the warehouse or any customer position is invalid or obstructed.\n// Returns the total shortest path length from the warehouse to all customers.\nfunc shortestDeliveryRoute(grid: [[Int]], warehouse: (Int, Int), customers: [(Int, Int)]) throws -> Int {\n    // Edge case if there are no customers\n    if customers.isEmpty {\n        return 0\n    }\n    \n    let rows = grid.count\n    let cols = grid[0].count\n    \n    // Check if warehouse position is valid\n    if warehouse.0 < 0 || warehouse.0 >= rows || warehouse.1 < 0 || warehouse.1 >= cols || grid[warehouse.0][warehouse.1] != 0 {\n        throw NSError(domain: \"Invalid warehouse position\", code: 1, userInfo: nil)\n    }\n    \n    // Check if all customer positions are valid\n    for customer in customers {\n        if customer.0 < 0 || customer.0 >= rows || customer.1 < 0 || customer.1 >= cols || grid[customer.0][customer.1] != 0 {\n            throw NSError(domain: \"Invalid customer position\", code: 2, userInfo: nil)\n        }\n    }\n    \n    // Calculate shortest paths from warehouse to all points\n    let warehouseDistances = bfs(grid: grid, start: warehouse)\n    \n    // Accumulate total length by finding the shortest paths to each customer\n    var totalLength = 0\n    for customer in customers {\n        totalLength += warehouseDistances[customer.0][customer.1]\n    }\n    \n    return totalLength\n}", "test_cases": "", "test_case_results": "Test case 1:\nGrid: [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\nWarehouse: (0, 0)\nCustomers: [(2, 2)]\nTotal shortest path length: 4\n\nTest case 2:\nGrid: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\nWarehouse: (1, 1)\nCustomers: [(0, 0), (2, 2)]\nTotal shortest path length: 4\n\nTest case 3:\nGrid: [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nWarehouse: (0, 0)\nCustomers: [(2, 2)]\nTotal shortest path length: 9223372036854775807", "task_id": 11861, "assertions": "func testShortestDeliveryRoute() {\n    // Test case 1\n    let grid1 = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    let warehouse1 = (0, 0)\n    let customers1 = [(2, 2)]\n    do {\n        let result1 = try shortestDeliveryRoute(grid: grid1, warehouse: warehouse1, customers: customers1)\n        assert(result1 == 4)\n    } catch {\n        assert(false, \"Test case 1 failed\")\n    }\n    \n    // Test case 2\n    let grid2 = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    let warehouse2 = (1, 1)\n    let customers2 = [(0, 0), (2, 2)]\n    do {\n        let result2 = try shortestDeliveryRoute(grid: grid2, warehouse: warehouse2, customers: customers2)\n        assert(result2 == 4)\n    } catch {\n        assert(false, \"Test case 2 failed\")\n    }\n    \n    // Test case 3\n    let grid3 = [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]\n    let warehouse3 = (0, 0)\n    let customers3 = [(2, 2)]\n    do {\n        let result3 = try shortestDeliveryRoute(grid: grid3, warehouse: warehouse3, customers: customers3)\n        assert(result3 == Int.max)\n    } catch {\n        assert(false, \"Test case 3 failed\")\n    }\n}\n\ntestShortestDeliveryRoute()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testShortestDeliveryRoute() {\n    // Test case 1\n    let grid1 = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    let warehouse1 = (0, 0)\n    let customers1 = [(2, 2)]\n    do {\n        let result1 = try shortestDeliveryRoute(grid: grid1, warehouse: warehouse1, customers: customers1)\n        assert(result1 == 4)\n    } catch {\n        assert(false, \"Test case 1 failed\")\n    }\n    \n    // Test case 2\n    let grid2 = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    let warehouse2 = (1, 1)\n    let customers2 = [(0, 0), (2, 2)]\n    do {\n        let result2 = try shortestDeliveryRoute(grid: grid2, warehouse: warehouse2, customers: customers2)\n        assert(result2 == 4)\n    } catch {\n        assert(false, \"Test case 2 failed\")\n    }\n    \n    // Test case 3\n    let grid3 = [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]\n    let warehouse3 = (0, 0)\n    let customers3 = [(2, 2)]\n    do {\n        let result3 = try shortestDeliveryRoute(grid: grid3, warehouse: warehouse3, customers: customers3)\n        assert(result3 == Int.max)\n    } catch {\n        assert(false, \"Test case 3 failed\")\n    }\n}\n\ntestShortestDeliveryRoute()", "output": "shortestDeliveryRoute"}, "all_code": "import Foundation\n\n// bfs performs a breadth-first search on a grid starting from a given position.\n// It calculates the shortest distances from the start position to all other positions in the grid.\n// The grid is represented as a 2D array where 0 indicates a passable cell and any other value indicates an obstacle.\n// Returns a 2D array of distances where each cell contains the shortest distance from the start position.\nfunc bfs(grid: [[Int]], start: (Int, Int)) -> [[Int]] {\n    let rows = grid.count\n    let cols = grid[0].count\n    var distances = Array(repeating: Array(repeating: Int.max, count: cols), count: rows)\n    distances[start.0][start.1] = 0\n    var queue = [(Int, Int)]()\n    queue.append(start)\n    \n    while !queue.isEmpty {\n        let (x, y) = queue.removeFirst()\n        for (dx, dy) in [(-1, 0), (1, 0), (0, -1), (0, 1)] {\n            let nx = x + dx\n            let ny = y + dy\n            if nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 0 && distances[nx][ny] == Int.max {\n                distances[nx][ny] = distances[x][y] + 1\n                queue.append((nx, ny))\n            }\n        }\n    }\n    \n    return distances\n}\n\n// shortestDeliveryRoute calculates the total shortest path length from a warehouse to all customer positions on a grid.\n// The grid is represented as a 2D array where 0 indicates a passable cell and any other value indicates an obstacle.\n// The warehouse and customer positions are given as tuples of (row, column).\n// Throws an error if the warehouse or any customer position is invalid or obstructed.\n// Returns the total shortest path length from the warehouse to all customers.\nfunc shortestDeliveryRoute(grid: [[Int]], warehouse: (Int, Int), customers: [(Int, Int)]) throws -> Int {\n    // Edge case if there are no customers\n    if customers.isEmpty {\n        return 0\n    }\n    \n    let rows = grid.count\n    let cols = grid[0].count\n    \n    // Check if warehouse position is valid\n    if warehouse.0 < 0 || warehouse.0 >= rows || warehouse.1 < 0 || warehouse.1 >= cols || grid[warehouse.0][warehouse.1] != 0 {\n        throw NSError(domain: \"Invalid warehouse position\", code: 1, userInfo: nil)\n    }\n    \n    // Check if all customer positions are valid\n    for customer in customers {\n        if customer.0 < 0 || customer.0 >= rows || customer.1 < 0 || customer.1 >= cols || grid[customer.0][customer.1] != 0 {\n            throw NSError(domain: \"Invalid customer position\", code: 2, userInfo: nil)\n        }\n    }\n    \n    // Calculate shortest paths from warehouse to all points\n    let warehouseDistances = bfs(grid: grid, start: warehouse)\n    \n    // Accumulate total length by finding the shortest paths to each customer\n    var totalLength = 0\n    for customer in customers {\n        totalLength += warehouseDistances[customer.0][customer.1]\n    }\n    \n    return totalLength\n}\nfunc testShortestDeliveryRoute() {\n    // Test case 1\n    let grid1 = [\n        [0, 0, 0],\n        [0, 1, 0],\n        [0, 0, 0]\n    ]\n    let warehouse1 = (0, 0)\n    let customers1 = [(2, 2)]\n    do {\n        let result1 = try shortestDeliveryRoute(grid: grid1, warehouse: warehouse1, customers: customers1)\n        assert(result1 == 4)\n    } catch {\n        assert(false, \"Test case 1 failed\")\n    }\n    \n    // Test case 2\n    let grid2 = [\n        [0, 0, 0],\n        [0, 0, 0],\n        [0, 0, 0]\n    ]\n    let warehouse2 = (1, 1)\n    let customers2 = [(0, 0), (2, 2)]\n    do {\n        let result2 = try shortestDeliveryRoute(grid: grid2, warehouse: warehouse2, customers: customers2)\n        assert(result2 == 4)\n    } catch {\n        assert(false, \"Test case 2 failed\")\n    }\n    \n    // Test case 3\n    let grid3 = [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]\n    let warehouse3 = (0, 0)\n    let customers3 = [(2, 2)]\n    do {\n        let result3 = try shortestDeliveryRoute(grid: grid3, warehouse: warehouse3, customers: customers3)\n        assert(result3 == Int.max)\n    } catch {\n        assert(false, \"Test case 3 failed\")\n    }\n}\n\ntestShortestDeliveryRoute()", "exec_outcome": "PASSED"}
{"code": "// smallestPositiveIntegerNotInSum calculates the smallest positive integer that is not present in the list\n// and not the sum of any subset of integers from the list.\n// The function sorts the input array and iterates through it to determine the smallest missing positive integer.\n// The algorithm works by maintaining a running sum (smallestMissing) and checking each element in the sorted array.\n// If an element is greater than smallestMissing, the loop breaks, and smallestMissing is returned.\n// Otherwise, smallestMissing is incremented by the current element.\nfunc smallestPositiveIntegerNotInSum(_ list: [Int]) -> Int {\n    var sortedList = list.sorted()\n    var smallestMissing = 1\n    for num in sortedList {\n        if num > smallestMissing {\n            break\n        }\n        smallestMissing += num\n    }\n    return smallestMissing\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nSmallest positive integer not in sum: 11\nInput: [1, 1, 1, 1]\nSmallest positive integer not in sum: 5\nInput: [1, 3, 6, 10, 11, 15]\nSmallest positive integer not in sum: 2\nInput: [1, 1, 3, 4]\nSmallest positive integer not in sum: 10\nInput: [1, 2, 5, 10, 20, 40]\nSmallest positive integer not in sum: 4", "task_id": 4587, "assertions": "func testSmallestPositiveIntegerNotInSum() {\n    assert(smallestPositiveIntegerNotInSum([1, 2, 3, 4]) == 11)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 1, 1]) == 5)\n    assert(smallestPositiveIntegerNotInSum([1, 3, 6, 10, 11, 15]) == 2)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 3, 4]) == 10)\n    assert(smallestPositiveIntegerNotInSum([1, 2, 5, 10, 20, 40]) == 4)\n}\n\ntestSmallestPositiveIntegerNotInSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testSmallestPositiveIntegerNotInSum() {\n    assert(smallestPositiveIntegerNotInSum([1, 2, 3, 4]) == 11)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 1, 1]) == 5)\n    assert(smallestPositiveIntegerNotInSum([1, 3, 6, 10, 11, 15]) == 2)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 3, 4]) == 10)\n    assert(smallestPositiveIntegerNotInSum([1, 2, 5, 10, 20, 40]) == 4)\n}\n\ntestSmallestPositiveIntegerNotInSum()", "output": "smallestPositiveIntegerNotInSum"}, "all_code": "import Foundation\nimport Glibc\n\n// smallestPositiveIntegerNotInSum calculates the smallest positive integer that is not present in the list\n// and not the sum of any subset of integers from the list.\n// The function sorts the input array and iterates through it to determine the smallest missing positive integer.\n// The algorithm works by maintaining a running sum (smallestMissing) and checking each element in the sorted array.\n// If an element is greater than smallestMissing, the loop breaks, and smallestMissing is returned.\n// Otherwise, smallestMissing is incremented by the current element.\nfunc smallestPositiveIntegerNotInSum(_ list: [Int]) -> Int {\n    var sortedList = list.sorted()\n    var smallestMissing = 1\n    for num in sortedList {\n        if num > smallestMissing {\n            break\n        }\n        smallestMissing += num\n    }\n    return smallestMissing\n}\nfunc testSmallestPositiveIntegerNotInSum() {\n    assert(smallestPositiveIntegerNotInSum([1, 2, 3, 4]) == 11)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 1, 1]) == 5)\n    assert(smallestPositiveIntegerNotInSum([1, 3, 6, 10, 11, 15]) == 2)\n    assert(smallestPositiveIntegerNotInSum([1, 1, 3, 4]) == 10)\n    assert(smallestPositiveIntegerNotInSum([1, 2, 5, 10, 20, 40]) == 4)\n}\n\ntestSmallestPositiveIntegerNotInSum()", "exec_outcome": "PASSED"}
{"code": "// matrixThresholdSum calculates the sum of all elements in a 2D matrix that are greater than a given threshold.\n// The function iterates through each element in the matrix and adds it to the total sum if it exceeds the threshold.\n// If the matrix is empty, the function returns 0.\nfunc matrixThresholdSum(matrix: [[Int]], threshold: Int) -> Int {\n    var totalSum = 0\n    for row in matrix {\n        for element in row {\n            if element > threshold {\n                totalSum += element\n            }\n        }\n    }\n    return totalSum\n}", "test_cases": "", "test_case_results": "Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], Threshold: 5\nSum of elements greater than threshold: 30\nMatrix: [[10, 20], [30, 40]], Threshold: 25\nSum of elements greater than threshold: 70\nMatrix: [[0, 0], [0, 0]], Threshold: 0\nSum of elements greater than threshold: 0\nMatrix: [[]], Threshold: 10\nSum of elements greater than threshold: 0", "task_id": 53, "assertions": "func testMatrixThresholdSum() {\n    assert(matrixThresholdSum(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], threshold: 5) == 30)\n    assert(matrixThresholdSum(matrix: [[10, 20], [30, 40]], threshold: 25) == 70)\n    assert(matrixThresholdSum(matrix: [[0, 0], [0, 0]], threshold: 0) == 0)\n    assert(matrixThresholdSum(matrix: [[]], threshold: 10) == 0)\n}\n\ntestMatrixThresholdSum()", "result": {"input": "Please read the following test code and identify the name of the function that is being tested. Only return the name of the function under test, without any explanation or additional output. The programming language may vary.\n\nTest code:\n\nfunc testMatrixThresholdSum() {\n    assert(matrixThresholdSum(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], threshold: 5) == 30)\n    assert(matrixThresholdSum(matrix: [[10, 20], [30, 40]], threshold: 25) == 70)\n    assert(matrixThresholdSum(matrix: [[0, 0], [0, 0]], threshold: 0) == 0)\n    assert(matrixThresholdSum(matrix: [[]], threshold: 10) == 0)\n}\n\ntestMatrixThresholdSum()", "output": "matrixThresholdSum"}, "all_code": "// matrixThresholdSum calculates the sum of all elements in a 2D matrix that are greater than a given threshold.\n// The function iterates through each element in the matrix and adds it to the total sum if it exceeds the threshold.\n// If the matrix is empty, the function returns 0.\nfunc matrixThresholdSum(matrix: [[Int]], threshold: Int) -> Int {\n    var totalSum = 0\n    for row in matrix {\n        for element in row {\n            if element > threshold {\n                totalSum += element\n            }\n        }\n    }\n    return totalSum\n}\nfunc testMatrixThresholdSum() {\n    assert(matrixThresholdSum(matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]], threshold: 5) == 30)\n    assert(matrixThresholdSum(matrix: [[10, 20], [30, 40]], threshold: 25) == 70)\n    assert(matrixThresholdSum(matrix: [[0, 0], [0, 0]], threshold: 0) == 0)\n    assert(matrixThresholdSum(matrix: [[]], threshold: 10) == 0)\n}\n\ntestMatrixThresholdSum()", "exec_outcome": "PASSED"}
