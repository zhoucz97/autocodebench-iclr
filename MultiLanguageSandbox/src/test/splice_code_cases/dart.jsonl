{"code": "List<int> minDifference(int T, List<List<dynamic>> testCases) {\n  List<int> results = [];\n  \n  for (var caseData in testCases) {\n    int N = caseData[0];\n    List<int> cards = List<int>.from(caseData[1]);\n    cards.sort();\n    int pile1 = 0, pile2 = 0;\n    \n    for (int i = N - 1; i >= 0; i--) {\n      if (pile1 < pile2) {\n        pile1 += cards[i];\n      } else {\n        pile2 += cards[i];\n      }\n    }\n    \n    results.add((pile1 - pile2).abs());\n  }\n  \n  return results;\n}", "test_cases": "", "test_case_results": "Number of test cases: 5\n---\nTest Case 1:\nNumber of cards: 4\nCard values: [1, 2, 3, 4]\nMinimum difference: 0\n---\nTest Case 2:\nNumber of cards: 5\nCard values: [5, 6, 7, 8, 9]\nMinimum difference: 5\n---\nTest Case 3:\nNumber of cards: 3\nCard values: [10, 20, 30]\nMinimum difference: 0\n---\nTest Case 4:\nNumber of cards: 1\nCard values: [100]\nMinimum difference: 100\n---\nTest Case 5:\nNumber of cards: 6\nCard values: [1, 1, 1, 1, 1, 1]\nMinimum difference: 0\n---", "task_id": 9094, "assertions": "void testMinDifference() {\n  List<List<dynamic>> testCases = [\n    [4, [1, 2, 3, 4]],\n    [5, [5, 6, 7, 8, 9]],\n    [3, [10, 20, 30]],\n    [1, [100]],\n    [6, [1, 1, 1, 1, 1, 1]],\n  ];\n  \n  List<int> expectedResults = [0, 5, 0, 100, 0];\n  List<int> actualResults = minDifference(testCases.length, testCases);\n  \n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i], \n           'Test case ${i+1} failed: Expected ${expectedResults[i]}, got ${actualResults[i]}');\n  }\n  print('All tests passed!');\n}\n\ntestMinDifference();", "all_code": "List<int> minDifference(int T, List<List<dynamic>> testCases) {\n  List<int> results = [];\n  \n  for (var caseData in testCases) {\n    int N = caseData[0];\n    List<int> cards = List<int>.from(caseData[1]);\n    cards.sort();\n    int pile1 = 0, pile2 = 0;\n    \n    for (int i = N - 1; i >= 0; i--) {\n      if (pile1 < pile2) {\n        pile1 += cards[i];\n      } else {\n        pile2 += cards[i];\n      }\n    }\n    \n    results.add((pile1 - pile2).abs());\n  }\n  \n  return results;\n}\n\nvoid testMinDifference() {\n  List<List<dynamic>> testCases = [\n    [4, [1, 2, 3, 4]],\n    [5, [5, 6, 7, 8, 9]],\n    [3, [10, 20, 30]],\n    [1, [100]],\n    [6, [1, 1, 1, 1, 1, 1]],\n  ];\n  \n  List<int> expectedResults = [0, 5, 0, 100, 0];\n  List<int> actualResults = minDifference(testCases.length, testCases);\n  \n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i], \n           'Test case ${i+1} failed: Expected ${expectedResults[i]}, got ${actualResults[i]}');\n  }\n  print('All tests passed!');\n}\n\ntestMinDifference();", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// calculateJaccardSimilarity computes the Jaccard similarity coefficient between two strings.\n// The Jaccard similarity is defined as the size of the intersection divided by the size of the union\n// of the character sets of the two strings. Returns 1.0 if both strings are empty.\ndouble calculateJaccardSimilarity(String str1, String str2) {\n  // Convert strings to sets of characters\n  final set1 = str1.split('').toSet();\n  final set2 = str2.split('').toSet();\n\n  // Calculate intersection and union\n  final intersection = set1.intersection(set2);\n  final union = set1.union(set2);\n\n  // Handle empty union case (both strings empty)\n  if (union.isEmpty) {\n    return 1.0;\n  }\n  return intersection.length / union.length;\n}", "test_cases": "", "test_case_results": "String 1: \"hello\", String 2: \"hallo\"\nJaccard Similarity: 0.6000\n---\nString 1: \"abc\", String 2: \"def\"\nJaccard Similarity: 0.0000\n---\nString 1: \"\", String 2: \"\"\nJaccard Similarity: 1.0000\n---\nString 1: \"aabbcc\", String 2: \"abc\"\nJaccard Similarity: 1.0000\n---\nString 1: \"123\", String 2: \"12345\"\nJaccard Similarity: 0.6000\n---\nString 1: \"dart\", String 2: \"flutter\"\nJaccard Similarity: 0.2500\n---", "task_id": 12199, "assertions": "void testCalculateJaccardSimilarity() {\n  assert(calculateJaccardSimilarity('hello', 'hallo').toStringAsFixed(4) == '0.6000');\n  assert(calculateJaccardSimilarity('abc', 'def').toStringAsFixed(4) == '0.0000');\n  assert(calculateJaccardSimilarity('', '').toStringAsFixed(4) == '1.0000');\n  assert(calculateJaccardSimilarity('aabbcc', 'abc').toStringAsFixed(4) == '1.0000');\n  assert(calculateJaccardSimilarity('123', '12345').toStringAsFixed(4) == '0.6000');\n  assert(calculateJaccardSimilarity('dart', 'flutter').toStringAsFixed(4) == '0.2500');\n}\n\nvoid main() {\n  testCalculateJaccardSimilarity();\n  print('All tests passed!');\n}", "all_code": "// calculateJaccardSimilarity computes the Jaccard similarity coefficient between two strings.\n// The Jaccard similarity is defined as the size of the intersection divided by the size of the union\n// of the character sets of the two strings. Returns 1.0 if both strings are empty.\ndouble calculateJaccardSimilarity(String str1, String str2) {\n  // Convert strings to sets of characters\n  final set1 = str1.split('').toSet();\n  final set2 = str2.split('').toSet();\n\n  // Calculate intersection and union\n  final intersection = set1.intersection(set2);\n  final union = set1.union(set2);\n\n  // Handle empty union case (both strings empty)\n  if (union.isEmpty) {\n    return 1.0;\n  }\n  return intersection.length / union.length;\n}\n\nvoid testCalculateJaccardSimilarity() {\n  assert(calculateJaccardSimilarity('hello', 'hallo').toStringAsFixed(4) == '0.6000');\n  assert(calculateJaccardSimilarity('abc', 'def').toStringAsFixed(4) == '0.0000');\n  assert(calculateJaccardSimilarity('', '').toStringAsFixed(4) == '1.0000');\n  assert(calculateJaccardSimilarity('aabbcc', 'abc').toStringAsFixed(4) == '1.0000');\n  assert(calculateJaccardSimilarity('123', '12345').toStringAsFixed(4) == '0.6000');\n  assert(calculateJaccardSimilarity('dart', 'flutter').toStringAsFixed(4) == '0.2500');\n}\n\nvoid main() {\n  testCalculateJaccardSimilarity();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// isPermutationPossible determines if it's possible to achieve the target permutation\n// with the given number of commands.\n//\n// Parameters:\n// - N: The number of animals\n// - target: The target permutation of the animals' positions\n// - M: The number of commands available\n//\n// Returns:\n// - \"YES\" if the target permutation can be achieved, otherwise \"NO\"\nString isPermutationPossible(int N, List<int> target, int M) {\n  // We can always achieve the target permutation if M is greater than or equal to N-1.\n  // This is because in the worst case, we'd need N-1 swaps to sort the animals into any permutation.\n  if (M >= N - 1) {\n    return \"YES\";\n  }\n\n  // Check if the target permutation is already sorted\n  List<int> sortedTarget = List.from(target)..sort();\n  if (listEquals(target, sortedTarget)) {\n    return \"YES\";\n  }\n\n  return \"NO\";\n}\n\n// Helper function to compare two lists for equality\nbool listEquals(List<int> a, List<int> b) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nN: 4, Target: [4, 1, 2, 3], M: 5\nYES\n\nTest Case 2:\nN: 3, Target: [3, 1, 2], M: 2\nYES\n\nTest Case 3:\nN: 5, Target: [5, 4, 3, 2, 1], M: 3\nNO\n\nTest Case 4:\nN: 4, Target: [1, 2, 3, 4], M: 0\nYES\n\nTest Case 5:\nN: 1, Target: [1], M: 0\nYES", "task_id": 23907, "assertions": "void testIsPermutationPossible() {\n  assert(isPermutationPossible(4, [4, 1, 2, 3], 5) == \"YES\");\n  assert(isPermutationPossible(3, [3, 1, 2], 2) == \"YES\");\n  assert(isPermutationPossible(5, [5, 4, 3, 2, 1], 3) == \"NO\");\n  assert(isPermutationPossible(4, [1, 2, 3, 4], 0) == \"YES\");\n  assert(isPermutationPossible(1, [1], 0) == \"YES\");\n}\n\nvoid main() {\n  testIsPermutationPossible();\n}", "all_code": "// isPermutationPossible determines if it's possible to achieve the target permutation\n// with the given number of commands.\n//\n// Parameters:\n// - N: The number of animals\n// - target: The target permutation of the animals' positions\n// - M: The number of commands available\n//\n// Returns:\n// - \"YES\" if the target permutation can be achieved, otherwise \"NO\"\nString isPermutationPossible(int N, List<int> target, int M) {\n  // We can always achieve the target permutation if M is greater than or equal to N-1.\n  // This is because in the worst case, we'd need N-1 swaps to sort the animals into any permutation.\n  if (M >= N - 1) {\n    return \"YES\";\n  }\n\n  // Check if the target permutation is already sorted\n  List<int> sortedTarget = List.from(target)..sort();\n  if (listEquals(target, sortedTarget)) {\n    return \"YES\";\n  }\n\n  return \"NO\";\n}\n\n// Helper function to compare two lists for equality\nbool listEquals(List<int> a, List<int> b) {\n  if (a.length != b.length) return false;\n  for (int i = 0; i < a.length; i++) {\n    if (a[i] != b[i]) return false;\n  }\n  return true;\n}\n\nvoid testIsPermutationPossible() {\n  assert(isPermutationPossible(4, [4, 1, 2, 3], 5) == \"YES\");\n  assert(isPermutationPossible(3, [3, 1, 2], 2) == \"YES\");\n  assert(isPermutationPossible(5, [5, 4, 3, 2, 1], 3) == \"NO\");\n  assert(isPermutationPossible(4, [1, 2, 3, 4], 0) == \"YES\");\n  assert(isPermutationPossible(1, [1], 0) == \"YES\");\n}\n\nvoid main() {\n  testIsPermutationPossible();\n}", "exec_outcome": "PASSED"}
{"code": "List<String> sortMixedCharacters(String s) {\n  // Separate characters into three categories\n  List<String> letters = [];\n  List<String> digits = [];\n  List<String> specials = [];\n  \n  for (int i = 0; i < s.length; i++) {\n    String ch = s[i];\n    if (RegExp(r'[a-zA-Z]').hasMatch(ch)) {\n      letters.add(ch);\n    } else if (RegExp(r'[0-9]').hasMatch(ch)) {\n      digits.add(ch);\n    } else {\n      specials.add(ch);\n    }\n  }\n  \n  // Sort letters and digits\n  letters.sort();\n  digits.sort();\n  \n  // Combine results while maintaining original order of special characters\n  return [...letters, ...digits, ...specials];\n}", "test_cases": "", "test_case_results": "Input: \"a1b2c3!@#\"\nSorted: [a, b, c, 1, 2, 3, !, @, #]\n---\nInput: \"x3y2z1*&^\"\nSorted: [x, y, z, 1, 2, 3, *, &, ^]\n---\nInput: \"Hello123World!\"\nSorted: [H, W, d, e, l, l, l, o, o, r, 1, 2, 3, !]\n---\nInput: \"987abc654\"\nSorted: [a, b, c, 4, 5, 6, 7, 8, 9]\n---\nInput: \"!@#$%^&*\"\nSorted: [!, @, #, $, %, ^, &, *]\n---\nInput: \"mixed123with!@#symbols456\"\nSorted: [b, d, e, h, i, i, l, m, m, o, s, s, t, w, x, y, 1, 2, 3, 4, 5, 6, !, @, #]\n---\nInput: \"\"\nSorted: []\n---", "task_id": 19759, "assertions": "import 'dart:core';\n\nvoid testSortMixedCharacters() {\n  assert(sortMixedCharacters(\"a1b2c3!@#\") == ['a', 'b', 'c', '1', '2', '3', '!', '@', '#']);\n  assert(sortMixedCharacters(\"x3y2z1*&^\") == ['x', 'y', 'z', '1', '2', '3', '*', '&', '^']);\n  assert(sortMixedCharacters(\"Hello123World!\") == ['H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', '1', '2', '3', '!']);\n  assert(sortMixedCharacters(\"987abc654\") == ['a', 'b', 'c', '4', '5', '6', '7', '8', '9']);\n  assert(sortMixedCharacters(\"!@#\\$%^&*\") == ['!', '@', '#', '\\$', '%', '^', '&', '*']);\n  assert(sortMixedCharacters(\"mixed123with!@#symbols456\") == ['b', 'd', 'e', 'h', 'i', 'i', 'l', 'm', 'm', 'o', 's', 's', 't', 'w', 'x', 'y', '1', '2', '3', '4', '5', '6', '!', '@', '#']);\n  assert(sortMixedCharacters(\"\").isEmpty);\n}\n\nvoid main() {\n  testSortMixedCharacters();\n  print(\"All tests passed!\");\n}", "all_code": "import 'dart:core';\n\nList<String> sortMixedCharacters(String s) {\n  // Separate characters into three categories\n  List<String> letters = [];\n  List<String> digits = [];\n  List<String> specials = [];\n  \n  for (int i = 0; i < s.length; i++) {\n    String ch = s[i];\n    if (RegExp(r'[a-zA-Z]').hasMatch(ch)) {\n      letters.add(ch);\n    } else if (RegExp(r'[0-9]').hasMatch(ch)) {\n      digits.add(ch);\n    } else {\n      specials.add(ch);\n    }\n  }\n  \n  // Sort letters and digits\n  letters.sort();\n  digits.sort();\n  \n  // Combine results while maintaining original order of special characters\n  return [...letters, ...digits, ...specials];\n}\n\nvoid testSortMixedCharacters() {\n  assert(sortMixedCharacters(\"a1b2c3!@#\") == ['a', 'b', 'c', '1', '2', '3', '!', '@', '#']);\n  assert(sortMixedCharacters(\"x3y2z1*&^\") == ['x', 'y', 'z', '1', '2', '3', '*', '&', '^']);\n  assert(sortMixedCharacters(\"Hello123World!\") == ['H', 'W', 'd', 'e', 'l', 'l', 'l', 'o', 'o', 'r', '1', '2', '3', '!']);\n  assert(sortMixedCharacters(\"987abc654\") == ['a', 'b', 'c', '4', '5', '6', '7', '8', '9']);\n  assert(sortMixedCharacters(\"!@#\\$%^&*\") == ['!', '@', '#', '\\$', '%', '^', '&', '*']);\n  assert(sortMixedCharacters(\"mixed123with!@#symbols456\") == ['b', 'd', 'e', 'h', 'i', 'i', 'l', 'm', 'm', 'o', 's', 's', 't', 'w', 'x', 'y', '1', '2', '3', '4', '5', '6', '!', '@', '#']);\n  assert(sortMixedCharacters(\"\").isEmpty);\n}\n\nvoid main() {\n  testSortMixedCharacters();\n  print(\"All tests passed!\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// maxSequenceIncrease calculates the maximum length of a contiguous subsequence\n// where each subsequent number is greater than the previous one.\n// If the input list is empty, it returns 0.\nint maxSequenceIncrease(List<int> arr) {\n  if (arr.isEmpty) {\n    return 0;\n  }\n\n  int maxLength = 1;\n  int currentLength = 1;\n\n  for (int i = 1; i < arr.length; i++) {\n    if (arr[i] > arr[i - 1]) {\n      currentLength++;\n    } else {\n      currentLength = 1;\n    }\n    if (currentLength > maxLength) {\n      maxLength = currentLength;\n    }\n  }\n\n  return maxLength;\n}", "test_cases": "", "test_case_results": "Input: []\nMaximum increasing sequence length: 0\n---\nInput: [1]\nMaximum increasing sequence length: 1\n---\nInput: [1, 2, 3, 4]\nMaximum increasing sequence length: 4\n---\nInput: [5, 4, 3, 2, 1]\nMaximum increasing sequence length: 1\n---\nInput: [1, 2, 3, 2, 1, 2, 3, 4]\nMaximum increasing sequence length: 4\n---\nInput: [1, 1, 1, 1]\nMaximum increasing sequence length: 1\n---\nInput: [1, 2, 3, 2, 3, 4, 5]\nMaximum increasing sequence length: 4\n---", "task_id": 14509, "assertions": "void testMaxSequenceIncrease() {\n  assert(maxSequenceIncrease([]) == 0);\n  assert(maxSequenceIncrease([1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 4]) == 4);\n  assert(maxSequenceIncrease([5, 4, 3, 2, 1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 2, 1, 2, 3, 4]) == 4);\n  assert(maxSequenceIncrease([1, 1, 1, 1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 2, 3, 4, 5]) == 4);\n}\n\nvoid main() {\n  testMaxSequenceIncrease();\n  print('All tests passed!');\n}", "all_code": "// maxSequenceIncrease calculates the maximum length of a contiguous subsequence\n// where each subsequent number is greater than the previous one.\n// If the input list is empty, it returns 0.\nint maxSequenceIncrease(List<int> arr) {\n  if (arr.isEmpty) {\n    return 0;\n  }\n\n  int maxLength = 1;\n  int currentLength = 1;\n\n  for (int i = 1; i < arr.length; i++) {\n    if (arr[i] > arr[i - 1]) {\n      currentLength++;\n    } else {\n      currentLength = 1;\n    }\n    if (currentLength > maxLength) {\n      maxLength = currentLength;\n    }\n  }\n\n  return maxLength;\n}\n\nvoid testMaxSequenceIncrease() {\n  assert(maxSequenceIncrease([]) == 0);\n  assert(maxSequenceIncrease([1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 4]) == 4);\n  assert(maxSequenceIncrease([5, 4, 3, 2, 1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 2, 1, 2, 3, 4]) == 4);\n  assert(maxSequenceIncrease([1, 1, 1, 1]) == 1);\n  assert(maxSequenceIncrease([1, 2, 3, 2, 3, 4, 5]) == 4);\n}\n\nvoid main() {\n  testMaxSequenceIncrease();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// filterWordsBySymbols processes a list of words by finding the longest matching symbol\n// from a given list of symbols in each word and wrapping that symbol in square brackets.\n// If no symbols are found in a word, the word remains unchanged.\nList<String> filterWordsBySymbols(List<String> words, List<String> symbols) {\n  // Helper function to find the longest symbol present in a word\n  String findLongestMatch(String word, List<String> symbols) {\n    String longestSymbol = \"\";\n    for (String symbol in symbols) {\n      if (word.contains(symbol) && symbol.length > longestSymbol.length) {\n        longestSymbol = symbol;\n      }\n    }\n    return longestSymbol;\n  }\n\n  List<String> transformedWords = [];\n  for (String word in words) {\n    String longestSymbol = findLongestMatch(word, symbols);\n    if (longestSymbol.isNotEmpty) {\n      word = word.replaceAll(longestSymbol, \"[$longestSymbol]\");\n    }\n    transformedWords.add(word);\n  }\n\n  return transformedWords;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nWords: [hello, world, programming]\nSymbols: [ell, orl, pro]\nResult: [h[ell]o, w[orl]d, [pro]gramming]\n\nTest Case 2:\nWords: [banana, apple, orange]\nSymbols: [an, ana, app]\nResult: [b[ana]na, [app]le, or[an]ge]\n\nTest Case 3:\nWords: [dart, flutter, mobile]\nSymbols: [xyz, abc]\nResult: [dart, flutter, mobile]\n\nTest Case 4:\nWords: []\nSymbols: [test]\nResult: []\n\nTest Case 5:\nWords: [abcdefg]\nSymbols: [abc, bcd, cde]\nResult: [[abc]defg]", "task_id": 15900, "assertions": "void testFilterWordsBySymbols() {\n  // Test Case 1: Basic case with single matches\n  assert(filterWordsBySymbols([\"hello\", \"world\", \"programming\"], [\"ell\", \"orl\", \"pro\"]).toString() == \n         '[h[ell]o, w[orl]d, [pro]gramming]');\n  \n  // Test Case 2: Multiple possible matches (should pick longest)\n  assert(filterWordsBySymbols([\"banana\", \"apple\", \"orange\"], [\"an\", \"ana\", \"app\"]).toString() == \n         '[b[ana]na, [app]le, or[an]ge]');\n  \n  // Test Case 3: No matches\n  assert(filterWordsBySymbols([\"dart\", \"flutter\", \"mobile\"], [\"xyz\", \"abc\"]).toString() == \n         '[dart, flutter, mobile]');\n  \n  // Test Case 4: Empty inputs\n  assert(filterWordsBySymbols([], [\"test\"]).toString() == '[]');\n  \n  // Test Case 5: Overlapping symbols\n  assert(filterWordsBySymbols([\"abcdefg\"], [\"abc\", \"bcd\", \"cde\"]).toString() == \n         '[[abc]defg]');\n}\n\nvoid main() {\n  testFilterWordsBySymbols();\n  print('All tests passed!');\n}", "all_code": "// filterWordsBySymbols processes a list of words by finding the longest matching symbol\n// from a given list of symbols in each word and wrapping that symbol in square brackets.\n// If no symbols are found in a word, the word remains unchanged.\nList<String> filterWordsBySymbols(List<String> words, List<String> symbols) {\n  // Helper function to find the longest symbol present in a word\n  String findLongestMatch(String word, List<String> symbols) {\n    String longestSymbol = \"\";\n    for (String symbol in symbols) {\n      if (word.contains(symbol) && symbol.length > longestSymbol.length) {\n        longestSymbol = symbol;\n      }\n    }\n    return longestSymbol;\n  }\n\n  List<String> transformedWords = [];\n  for (String word in words) {\n    String longestSymbol = findLongestMatch(word, symbols);\n    if (longestSymbol.isNotEmpty) {\n      word = word.replaceAll(longestSymbol, \"[$longestSymbol]\");\n    }\n    transformedWords.add(word);\n  }\n\n  return transformedWords;\n}\n\nvoid testFilterWordsBySymbols() {\n  // Test Case 1: Basic case with single matches\n  assert(filterWordsBySymbols([\"hello\", \"world\", \"programming\"], [\"ell\", \"orl\", \"pro\"]).toString() == \n         '[h[ell]o, w[orl]d, [pro]gramming]');\n  \n  // Test Case 2: Multiple possible matches (should pick longest)\n  assert(filterWordsBySymbols([\"banana\", \"apple\", \"orange\"], [\"an\", \"ana\", \"app\"]).toString() == \n         '[b[ana]na, [app]le, or[an]ge]');\n  \n  // Test Case 3: No matches\n  assert(filterWordsBySymbols([\"dart\", \"flutter\", \"mobile\"], [\"xyz\", \"abc\"]).toString() == \n         '[dart, flutter, mobile]');\n  \n  // Test Case 4: Empty inputs\n  assert(filterWordsBySymbols([], [\"test\"]).toString() == '[]');\n  \n  // Test Case 5: Overlapping symbols\n  assert(filterWordsBySymbols([\"abcdefg\"], [\"abc\", \"bcd\", \"cde\"]).toString() == \n         '[[abc]defg]');\n}\n\nvoid main() {\n  testFilterWordsBySymbols();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// largestContiguousBlock finds the size of the largest contiguous block of 1s in a 2D grid.\n// It uses a depth-first search (DFS) approach to explore connected 1s in all four directions.\n// Parameters:\n//   - n: number of rows in the grid\n//   - m: number of columns in the grid\n//   - grid: 2D list representing the grid (0s and 1s)\n// Returns:\n//   - size of the largest contiguous block of 1s\nint largestContiguousBlock(int n, int m, List<List<int>> grid) {\n  // Helper function for DFS traversal\n  int dfs(int x, int y) {\n    // Check boundaries and if current cell is 0\n    if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0) {\n      return 0;\n    }\n    // Mark current cell as visited\n    grid[x][y] = 0;\n    // Initialize block size with current cell\n    int size = 1;\n    // Explore all four directions and accumulate size\n    size += dfs(x + 1, y); // Down\n    size += dfs(x - 1, y); // Up\n    size += dfs(x, y + 1); // Right\n    size += dfs(x, y - 1); // Left\n    return size;\n  }\n\n  int maxBlockSize = 0;\n  // Iterate through each cell in the grid\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == 1) {\n        // Calculate size of current block\n        int currentBlockSize = dfs(i, j);\n        // Update max block size if current is larger\n        if (currentBlockSize > maxBlockSize) {\n          maxBlockSize = currentBlockSize;\n        }\n      }\n    }\n  }\n  return maxBlockSize;\n}", "test_cases": "", "test_case_results": "Test case:\nGrid size: 3x3\nGrid:\n[1, 1, 0]\n[0, 1, 1]\n[0, 0, 1]\nLargest contiguous block size: 5\n---\nTest case:\nGrid size: 4x5\nGrid:\n[1, 1, 0, 0, 0]\n[1, 1, 0, 0, 0]\n[0, 0, 1, 0, 0]\n[0, 0, 0, 1, 1]\nLargest contiguous block size: 4\n---\nTest case:\nGrid size: 2x2\nGrid:\n[0, 0]\n[0, 0]\nLargest contiguous block size: 0\n---\nTest case:\nGrid size: 5x5\nGrid:\n[1, 0, 1, 0, 1]\n[0, 1, 0, 1, 0]\n[1, 0, 1, 0, 1]\n[0, 1, 0, 1, 0]\n[1, 0, 1, 0, 1]\nLargest contiguous block size: 1\n---", "task_id": 20015, "assertions": "void testLargestContiguousBlock() {\n  // Test case 1\n  List<List<int>> grid1 = [\n    [1, 1, 0],\n    [0, 1, 1],\n    [0, 0, 1],\n  ];\n  assert(largestContiguousBlock(3, 3, grid1) == 5);\n\n  // Test case 2\n  List<List<int>> grid2 = [\n    [1, 1, 0, 0, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 1],\n  ];\n  assert(largestContiguousBlock(4, 5, grid2) == 4);\n\n  // Test case 3\n  List<List<int>> grid3 = [\n    [0, 0],\n    [0, 0],\n  ];\n  assert(largestContiguousBlock(2, 2, grid3) == 0);\n\n  // Test case 4\n  List<List<int>> grid4 = [\n    [1, 0, 1, 0, 1],\n    [0, 1, 0, 1, 0],\n    [1, 0, 1, 0, 1],\n    [0, 1, 0, 1, 0],\n    [1, 0, 1, 0, 1],\n  ];\n  assert(largestContiguousBlock(5, 5, grid4) == 1);\n}\n\nvoid main() {\n  testLargestContiguousBlock();\n  print(\"All tests passed!\");\n}", "all_code": "// largestContiguousBlock finds the size of the largest contiguous block of 1s in a 2D grid.\n// It uses a depth-first search (DFS) approach to explore connected 1s in all four directions.\n// Parameters:\n//   - n: number of rows in the grid\n//   - m: number of columns in the grid\n//   - grid: 2D list representing the grid (0s and 1s)\n// Returns:\n//   - size of the largest contiguous block of 1s\nint largestContiguousBlock(int n, int m, List<List<int>> grid) {\n  // Helper function for DFS traversal\n  int dfs(int x, int y) {\n    // Check boundaries and if current cell is 0\n    if (x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 0) {\n      return 0;\n    }\n    // Mark current cell as visited\n    grid[x][y] = 0;\n    // Initialize block size with current cell\n    int size = 1;\n    // Explore all four directions and accumulate size\n    size += dfs(x + 1, y); // Down\n    size += dfs(x - 1, y); // Up\n    size += dfs(x, y + 1); // Right\n    size += dfs(x, y - 1); // Left\n    return size;\n  }\n\n  int maxBlockSize = 0;\n  // Iterate through each cell in the grid\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (grid[i][j] == 1) {\n        // Calculate size of current block\n        int currentBlockSize = dfs(i, j);\n        // Update max block size if current is larger\n        if (currentBlockSize > maxBlockSize) {\n          maxBlockSize = currentBlockSize;\n        }\n      }\n    }\n  }\n  return maxBlockSize;\n}\n\nvoid testLargestContiguousBlock() {\n  // Test case 1\n  List<List<int>> grid1 = [\n    [1, 1, 0],\n    [0, 1, 1],\n    [0, 0, 1],\n  ];\n  assert(largestContiguousBlock(3, 3, grid1) == 5);\n\n  // Test case 2\n  List<List<int>> grid2 = [\n    [1, 1, 0, 0, 0],\n    [1, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 1],\n  ];\n  assert(largestContiguousBlock(4, 5, grid2) == 4);\n\n  // Test case 3\n  List<List<int>> grid3 = [\n    [0, 0],\n    [0, 0],\n  ];\n  assert(largestContiguousBlock(2, 2, grid3) == 0);\n\n  // Test case 4\n  List<List<int>> grid4 = [\n    [1, 0, 1, 0, 1],\n    [0, 1, 0, 1, 0],\n    [1, 0, 1, 0, 1],\n    [0, 1, 0, 1, 0],\n    [1, 0, 1, 0, 1],\n  ];\n  assert(largestContiguousBlock(5, 5, grid4) == 1);\n}\n\nvoid main() {\n  testLargestContiguousBlock();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:math';\n\n/// Calculates the number of ways to arrange a set of objects where some objects are indistinguishable.\n///\n/// [n] is the total number of objects.\n/// [counts] is a list of counts for each type of indistinguishable object.\n///\n/// Returns the number of distinct arrangements possible.\n/// Throws an [ArgumentError] if the sum of counts doesn't equal n.\nint arrangeObjects(int n, List<int> counts) {\n  if (counts.reduce((a, b) => a + b) != n) {\n    throw ArgumentError(\"The sum of counts must be equal to n.\");\n  }\n\n  // Calculate the total number of permutations for n objects\n  int totalPermutations = factorial(n);\n\n  // Account for indistinguishable objects\n  for (int count in counts) {\n    totalPermutations ~/= factorial(count);\n  }\n\n  return totalPermutations;\n}\n\n/// Helper function to calculate factorial of a number.\nint factorial(int x) {\n  if (x < 0) throw ArgumentError(\"Factorial is not defined for negative numbers.\");\n  if (x <= 1) return 1;\n  \n  int result = 1;\n  for (int i = 2; i <= x; i++) {\n    result *= i;\n  }\n  return result;\n}", "test_cases": "", "test_case_results": "Test Case: 5 objects with 2 of type A and 3 of type B\nInput: n = 5, counts = [2, 3]\nNumber of arrangements: 10\n\nTest Case: 6 objects with 2 of each type\nInput: n = 6, counts = [2, 2, 2]\nNumber of arrangements: 90\n\nTest Case: 4 distinct objects\nInput: n = 4, counts = [1, 1, 1, 1]\nNumber of arrangements: 24\n\nTest Case: 7 objects with 3 of type X and 4 of type Y\nInput: n = 7, counts = [3, 4]\nNumber of arrangements: 35\n\nTesting error case (sum of counts != n):\nInput: n = 5, counts = [2, 2]\nError correctly caught: Invalid argument(s): The sum of counts must be equal to n.", "task_id": 27576, "assertions": "import 'dart:math';\n\nvoid testArrangeObjects() {\n  // Test normal cases\n  assert(arrangeObjects(5, [2, 3]) == 10);\n  assert(arrangeObjects(6, [2, 2, 2]) == 90);\n  assert(arrangeObjects(4, [1, 1, 1, 1]) == 24);\n  assert(arrangeObjects(7, [3, 4]) == 35);\n\n  // Test error case\n  try {\n    arrangeObjects(5, [2, 2]);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n  }\n}\n\nvoid main() {\n  testArrangeObjects();\n  print('All tests passed!');\n}", "all_code": "import 'dart:math';\n\n/// Calculates the number of ways to arrange a set of objects where some objects are indistinguishable.\n///\n/// [n] is the total number of objects.\n/// [counts] is a list of counts for each type of indistinguishable object.\n///\n/// Returns the number of distinct arrangements possible.\n/// Throws an [ArgumentError] if the sum of counts doesn't equal n.\nint arrangeObjects(int n, List<int> counts) {\n  if (counts.reduce((a, b) => a + b) != n) {\n    throw ArgumentError(\"The sum of counts must be equal to n.\");\n  }\n\n  // Calculate the total number of permutations for n objects\n  int totalPermutations = factorial(n);\n\n  // Account for indistinguishable objects\n  for (int count in counts) {\n    totalPermutations ~/= factorial(count);\n  }\n\n  return totalPermutations;\n}\n\n/// Helper function to calculate factorial of a number.\nint factorial(int x) {\n  if (x < 0) throw ArgumentError(\"Factorial is not defined for negative numbers.\");\n  if (x <= 1) return 1;\n  \n  int result = 1;\n  for (int i = 2; i <= x; i++) {\n    result *= i;\n  }\n  return result;\n}\n\nvoid testArrangeObjects() {\n  // Test normal cases\n  assert(arrangeObjects(5, [2, 3]) == 10);\n  assert(arrangeObjects(6, [2, 2, 2]) == 90);\n  assert(arrangeObjects(4, [1, 1, 1, 1]) == 24);\n  assert(arrangeObjects(7, [3, 4]) == 35);\n\n  // Test error case\n  try {\n    arrangeObjects(5, [2, 2]);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n  }\n}\n\nvoid main() {\n  testArrangeObjects();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// transpose returns the transpose of a given matrix (rows become columns and vice versa)\nList<List<dynamic>> transpose(List<List<dynamic>> matrix) {\n  return [\n    for (int i = 0; i < matrix[0].length; i++)\n      [for (List<dynamic> row in matrix) row[i]]\n  ];\n}\n\n// rotateClockwise rotates a matrix 90 degrees clockwise\nList<List<dynamic>> rotateClockwise(List<List<dynamic>> matrix) {\n  return [\n    for (int i = 0; i < matrix[0].length; i++)\n      [for (List<dynamic> row in matrix.reversed) row[i]]\n  ];\n}\n\n// rotateCounterclockwise rotates a matrix 90 degrees counter-clockwise\nList<List<dynamic>> rotateCounterclockwise(List<List<dynamic>> matrix) {\n  return [\n    for (int i = matrix[0].length - 1; i >= 0; i--)\n      [for (List<dynamic> row in matrix) row[i]]\n  ];\n}\n\n// flipHorizontal flips a matrix horizontally (left becomes right)\nList<List<dynamic>> flipHorizontal(List<List<dynamic>> matrix) {\n  return [for (List<dynamic> row in matrix) row.reversed.toList()];\n}\n\n// flipVertical flips a matrix vertically (top becomes bottom)\nList<List<dynamic>> flipVertical(List<List<dynamic>> matrix) {\n  return matrix.reversed.toList();\n}\n\n// applyMatrixTransformations applies a sequence of transformations to a matrix\nList<List<dynamic>> applyMatrixTransformations(\n    List<List<dynamic>> matrix, List<String> sequence) {\n  for (String command in sequence) {\n    switch (command) {\n      case \"transpose\":\n        matrix = transpose(matrix);\n        break;\n      case \"rotate_clockwise\":\n        matrix = rotateClockwise(matrix);\n        break;\n      case \"rotate_counterclockwise\":\n        matrix = rotateCounterclockwise(matrix);\n        break;\n      case \"flip_horizontal\":\n        matrix = flipHorizontal(matrix);\n        break;\n      case \"flip_vertical\":\n        matrix = flipVertical(matrix);\n        break;\n    }\n  }\n  return matrix;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [transpose]\nResult Matrix: [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n\nTest Case 2:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [rotate_clockwise]\nResult Matrix: [[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\nTest Case 3:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [rotate_counterclockwise]\nResult Matrix: [[3, 6, 9], [2, 5, 8], [1, 4, 7]]\n\nTest Case 4:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [flip_horizontal]\nResult Matrix: [[3, 2, 1], [6, 5, 4], [9, 8, 7]]\n\nTest Case 5:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [flip_vertical]\nResult Matrix: [[7, 8, 9], [4, 5, 6], [1, 2, 3]]\n\nTest Case 6:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nTransformation Sequence: [rotate_clockwise, flip_vertical]\nResult Matrix: [[9, 6, 3], [8, 5, 2], [7, 4, 1]]\n\nTest Case 7:\nOriginal Matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nT", "task_id": 29091, "assertions": "void testMatrixTransformations() {\n  List<List<dynamic>> testMatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ];\n\n  // Test Case 1: transpose\n  assert(applyMatrixTransformations(testMatrix, [\"transpose\"]) == \n      [[1, 4, 7], [2, 5, 8], [3, 6, 9]]);\n  \n  // Test Case 2: rotate_clockwise\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_clockwise\"]) == \n      [[7, 4, 1], [8, 5, 2], [9, 6, 3]]);\n  \n  // Test Case 3: rotate_counterclockwise\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_counterclockwise\"]) == \n      [[3, 6, 9], [2, 5, 8], [1, 4, 7]]);\n  \n  // Test Case 4: flip_horizontal\n  assert(applyMatrixTransformations(testMatrix, [\"flip_horizontal\"]) == \n      [[3, 2, 1], [6, 5, 4], [9, 8, 7]]);\n  \n  // Test Case 5: flip_vertical\n  assert(applyMatrixTransformations(testMatrix, [\"flip_vertical\"]) == \n      [[7, 8, 9], [4, 5, 6], [1, 2, 3]]);\n  \n  // Test Case 6: rotate_clockwise + flip_vertical\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_clockwise\", \"flip_vertical\"]) == \n      [[9, 6, 3], [8, 5, 2], [7, 4, 1]]);\n}\n\nvoid main() {\n  testMatrixTransformations();\n  print(\"All tests passed!\");\n}", "all_code": "// transpose returns the transpose of a given matrix (rows become columns and vice versa)\nList<List<dynamic>> transpose(List<List<dynamic>> matrix) {\n  return [\n    for (int i = 0; i < matrix[0].length; i++)\n      [for (List<dynamic> row in matrix) row[i]]\n  ];\n}\n\n// rotateClockwise rotates a matrix 90 degrees clockwise\nList<List<dynamic>> rotateClockwise(List<List<dynamic>> matrix) {\n  return [\n    for (int i = 0; i < matrix[0].length; i++)\n      [for (List<dynamic> row in matrix.reversed) row[i]]\n  ];\n}\n\n// rotateCounterclockwise rotates a matrix 90 degrees counter-clockwise\nList<List<dynamic>> rotateCounterclockwise(List<List<dynamic>> matrix) {\n  return [\n    for (int i = matrix[0].length - 1; i >= 0; i--)\n      [for (List<dynamic> row in matrix) row[i]]\n  ];\n}\n\n// flipHorizontal flips a matrix horizontally (left becomes right)\nList<List<dynamic>> flipHorizontal(List<List<dynamic>> matrix) {\n  return [for (List<dynamic> row in matrix) row.reversed.toList()];\n}\n\n// flipVertical flips a matrix vertically (top becomes bottom)\nList<List<dynamic>> flipVertical(List<List<dynamic>> matrix) {\n  return matrix.reversed.toList();\n}\n\n// applyMatrixTransformations applies a sequence of transformations to a matrix\nList<List<dynamic>> applyMatrixTransformations(\n    List<List<dynamic>> matrix, List<String> sequence) {\n  for (String command in sequence) {\n    switch (command) {\n      case \"transpose\":\n        matrix = transpose(matrix);\n        break;\n      case \"rotate_clockwise\":\n        matrix = rotateClockwise(matrix);\n        break;\n      case \"rotate_counterclockwise\":\n        matrix = rotateCounterclockwise(matrix);\n        break;\n      case \"flip_horizontal\":\n        matrix = flipHorizontal(matrix);\n        break;\n      case \"flip_vertical\":\n        matrix = flipVertical(matrix);\n        break;\n    }\n  }\n  return matrix;\n}\n\nvoid testMatrixTransformations() {\n  List<List<dynamic>> testMatrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ];\n\n  // Test Case 1: transpose\n  assert(applyMatrixTransformations(testMatrix, [\"transpose\"]) == \n      [[1, 4, 7], [2, 5, 8], [3, 6, 9]]);\n  \n  // Test Case 2: rotate_clockwise\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_clockwise\"]) == \n      [[7, 4, 1], [8, 5, 2], [9, 6, 3]]);\n  \n  // Test Case 3: rotate_counterclockwise\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_counterclockwise\"]) == \n      [[3, 6, 9], [2, 5, 8], [1, 4, 7]]);\n  \n  // Test Case 4: flip_horizontal\n  assert(applyMatrixTransformations(testMatrix, [\"flip_horizontal\"]) == \n      [[3, 2, 1], [6, 5, 4], [9, 8, 7]]);\n  \n  // Test Case 5: flip_vertical\n  assert(applyMatrixTransformations(testMatrix, [\"flip_vertical\"]) == \n      [[7, 8, 9], [4, 5, 6], [1, 2, 3]]);\n  \n  // Test Case 6: rotate_clockwise + flip_vertical\n  assert(applyMatrixTransformations(testMatrix, [\"rotate_clockwise\", \"flip_vertical\"]) == \n      [[9, 6, 3], [8, 5, 2], [7, 4, 1]]);\n}\n\nvoid main() {\n  testMatrixTransformations();\n  print(\"All tests passed!\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// processProducts filters a list of products based on a price threshold and calculates total stock value.\n// \n// Parameters:\n//   products - A list of tuples, each containing (product name, price, quantity in stock)\n//   threshold - The minimum price for products to be included in the filtered list\n//\n// Returns:\n//   A tuple containing:\n//     - List of filtered products (price > threshold)\n//     - Total stock value for all products\nList<dynamic> processProducts(List<List<dynamic>> products, double threshold) {\n  // Filter products where price is greater than threshold\n  var filteredProducts = products.where((product) => product[1] > threshold).toList();\n  \n  // Calculate total stock value (price * quantity for all products)\n  double totalValue = products.fold(0.0, (sum, product) => sum + (product[1] * product[2]));\n  \n  return [filteredProducts, totalValue];\n}", "test_cases": "", "test_case_results": "Test Case:\nProducts: [[Widget, 30.0, 5], [Gadget, 55.5, 2], [Thingamajig, 10.0, 15]]\nThreshold: 25.0\nFiltered Products: [[Widget, 30.0, 5], [Gadget, 55.5, 2]]\nTotal Stock Value: 411.0\n---\nTest Case:\nProducts: [[Premium, 100.0, 3], [Standard, 50.0, 10], [Budget, 20.0, 20]]\nThreshold: 49.99\nFiltered Products: [[Premium, 100.0, 3], [Standard, 50.0, 10]]\nTotal Stock Value: 1200.0\n---\nTest Case:\nProducts: [[A, 15.0, 100], [B, 15.0, 100], [C, 15.0, 100]]\nThreshold: 20.0\nFiltered Products: []\nTotal Stock Value: 4500.0\n---", "task_id": 16874, "assertions": "void testProcessProducts() {\n  // Test case 1\n  var result1 = processProducts([\n    ['Widget', 30.0, 5],\n    ['Gadget', 55.5, 2],\n    ['Thingamajig', 10.0, 15]\n  ], 25.0);\n  assert(result1[0].length == 2);\n  assert(result1[0][0][0] == 'Widget');\n  assert(result1[0][1][0] == 'Gadget');\n  assert(result1[1] == 411.0);\n\n  // Test case 2\n  var result2 = processProducts([\n    ['Premium', 100.0, 3],\n    ['Standard', 50.0, 10],\n    ['Budget', 20.0, 20]\n  ], 49.99);\n  assert(result2[0].length == 2);\n  assert(result2[0][0][0] == 'Premium');\n  assert(result2[0][1][0] == 'Standard');\n  assert(result2[1] == 1200.0);\n\n  // Test case 3\n  var result3 = processProducts([\n    ['A', 15.0, 100],\n    ['B', 15.0, 100],\n    ['C', 15.0, 100]\n  ], 20.0);\n  assert(result3[0].isEmpty);\n  assert(result3[1] == 4500.0);\n}\n\nvoid main() {\n  testProcessProducts();\n  print('All tests passed!');\n}", "all_code": "// processProducts filters a list of products based on a price threshold and calculates total stock value.\n// \n// Parameters:\n//   products - A list of tuples, each containing (product name, price, quantity in stock)\n//   threshold - The minimum price for products to be included in the filtered list\n//\n// Returns:\n//   A tuple containing:\n//     - List of filtered products (price > threshold)\n//     - Total stock value for all products\nList<dynamic> processProducts(List<List<dynamic>> products, double threshold) {\n  // Filter products where price is greater than threshold\n  var filteredProducts = products.where((product) => product[1] > threshold).toList();\n  \n  // Calculate total stock value (price * quantity for all products)\n  double totalValue = products.fold(0.0, (sum, product) => sum + (product[1] * product[2]));\n  \n  return [filteredProducts, totalValue];\n}\n\nvoid testProcessProducts() {\n  // Test case 1\n  var result1 = processProducts([\n    ['Widget', 30.0, 5],\n    ['Gadget', 55.5, 2],\n    ['Thingamajig', 10.0, 15]\n  ], 25.0);\n  assert(result1[0].length == 2);\n  assert(result1[0][0][0] == 'Widget');\n  assert(result1[0][1][0] == 'Gadget');\n  assert(result1[1] == 411.0);\n\n  // Test case 2\n  var result2 = processProducts([\n    ['Premium', 100.0, 3],\n    ['Standard', 50.0, 10],\n    ['Budget', 20.0, 20]\n  ], 49.99);\n  assert(result2[0].length == 2);\n  assert(result2[0][0][0] == 'Premium');\n  assert(result2[0][1][0] == 'Standard');\n  assert(result2[1] == 1200.0);\n\n  // Test case 3\n  var result3 = processProducts([\n    ['A', 15.0, 100],\n    ['B', 15.0, 100],\n    ['C', 15.0, 100]\n  ], 20.0);\n  assert(result3[0].isEmpty);\n  assert(result3[1] == 4500.0);\n}\n\nvoid main() {\n  testProcessProducts();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// efficientCombSort sorts a list using an improved version of the Comb Sort algorithm.\n// It first uses comb sort with a shrink factor of 1.3 to get the list nearly sorted,\n// then finishes with an insertion sort for the final sorting pass.\nList<int> efficientCombSort(List<int> arr) {\n  if (arr.isEmpty) {\n    return arr;\n  }\n\n  // insertionSort performs a standard insertion sort on the list.\n  // This is used as the final step after the comb sort phase.\n  List<int> insertionSort(List<int> arr) {\n    int n = arr.length;\n    for (int i = 1; i < n; i++) {\n      int key = arr[i];\n      int j = i - 1;\n      while (j >= 0 && key < arr[j]) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = key;\n    }\n    return arr;\n  }\n\n  int n = arr.length;\n  int gap = n;\n  double shrinkFactor = 1.3;\n  bool isSorted = false;\n\n  while (!isSorted) {\n    // Update the gap for the next comb pass\n    gap = (gap / shrinkFactor).floor();\n    if (gap <= 1) {\n      gap = 1;\n      isSorted = true;\n    }\n\n    // Perform a single comb pass\n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        // Swap elements\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        isSorted = false;\n      }\n    }\n  }\n\n  return insertionSort(arr);\n}", "test_cases": "", "test_case_results": "Input: []\nSorted: []\n---\nInput: [1]\nSorted: [1]\n---\nInput: [5, 2, 9, 3, 6]\nSorted: [2, 3, 5, 6, 9]\n---\nInput: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nSorted: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n---\nInput: [1, 2, 3, 4, 5]\nSorted: [1, 2, 3, 4, 5]\n---\nInput: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\nSorted: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n---", "task_id": 13106, "assertions": "void testEfficientCombSort() {\n  assert(efficientCombSort([]).isEmpty);\n  assert(efficientCombSort([1])[0] == 1);\n  assert(efficientCombSort([5, 2, 9, 3, 6]).toString() == [2, 3, 5, 6, 9].toString());\n  assert(efficientCombSort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]).toString() == \n         [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].toString());\n  assert(efficientCombSort([1, 2, 3, 4, 5]).toString() == [1, 2, 3, 4, 5].toString());\n  assert(efficientCombSort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]).toString() == \n         [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9].toString());\n}\n\nvoid main() {\n  testEfficientCombSort();\n  print('All tests passed!');\n}", "all_code": "// efficientCombSort sorts a list using an improved version of the Comb Sort algorithm.\n// It first uses comb sort with a shrink factor of 1.3 to get the list nearly sorted,\n// then finishes with an insertion sort for the final sorting pass.\nList<int> efficientCombSort(List<int> arr) {\n  if (arr.isEmpty) {\n    return arr;\n  }\n\n  // insertionSort performs a standard insertion sort on the list.\n  // This is used as the final step after the comb sort phase.\n  List<int> insertionSort(List<int> arr) {\n    int n = arr.length;\n    for (int i = 1; i < n; i++) {\n      int key = arr[i];\n      int j = i - 1;\n      while (j >= 0 && key < arr[j]) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = key;\n    }\n    return arr;\n  }\n\n  int n = arr.length;\n  int gap = n;\n  double shrinkFactor = 1.3;\n  bool isSorted = false;\n\n  while (!isSorted) {\n    // Update the gap for the next comb pass\n    gap = (gap / shrinkFactor).floor();\n    if (gap <= 1) {\n      gap = 1;\n      isSorted = true;\n    }\n\n    // Perform a single comb pass\n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        // Swap elements\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        isSorted = false;\n      }\n    }\n  }\n\n  return insertionSort(arr);\n}\n\nvoid testEfficientCombSort() {\n  assert(efficientCombSort([]).isEmpty);\n  assert(efficientCombSort([1])[0] == 1);\n  assert(efficientCombSort([5, 2, 9, 3, 6]).toString() == [2, 3, 5, 6, 9].toString());\n  assert(efficientCombSort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]).toString() == \n         [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].toString());\n  assert(efficientCombSort([1, 2, 3, 4, 5]).toString() == [1, 2, 3, 4, 5].toString());\n  assert(efficientCombSort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]).toString() == \n         [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9].toString());\n}\n\nvoid main() {\n  testEfficientCombSort();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "class Spreadsheet {\n  late int rows;\n  late int cols;\n  late List<List<int>> sheet;\n\n  Spreadsheet(int rows, int cols) {\n    this.rows = rows;\n    this.cols = cols;\n    sheet = List.generate(rows, (_) => List.filled(cols, 0));\n  }\n\n  void setCell(int row, int col, int value) {\n    sheet[row][col] = value;\n  }\n\n  int getCell(int row, int col) {\n    return sheet[row][col];\n  }\n\n  int sumRange(int rowStart, int colStart, int rowEnd, int colEnd) {\n    int sum = 0;\n    for (int i = rowStart; i <= rowEnd; i++) {\n      for (int j = colStart; j <= colEnd; j++) {\n        sum += sheet[i][j];\n      }\n    }\n    return sum;\n  }\n\n  void setRange(int rowStart, int colStart, int rowEnd, int colEnd, int value) {\n    for (int i = rowStart; i <= rowEnd; i++) {\n      for (int j = colStart; j <= colEnd; j++) {\n        sheet[i][j] = value;\n      }\n    }\n  }\n}", "test_cases": "", "test_case_results": "Creating a 3x3 spreadsheet...\n\nTest 1: Initial state (all zeros)\nCell (0,0): 0\nSum of entire sheet: 0\n\nTest 2: Setting individual cells\nCell (0,0): 5\nCell (1,1): 10\nCell (2,2): 15\n\nTest 3: Summing a range\nSum of diagonal: 30\nSum of top-left 2x2: 15\n\nTest 4: Setting a range\nUpdated middle column:\nRow 0: 7\nRow 1: 7\nRow 2: 7\nNew sum of entire sheet: 41\n\nTest 5: Single cell operations\nCell (2,2): 100\nSum of single cell: 100", "task_id": 20882, "assertions": "void testSpreadsheet() {\n  // Test initialization\n  final spreadsheet = Spreadsheet(3, 3);\n  assert(spreadsheet.getCell(0, 0) == 0);\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 0);\n\n  // Test setting individual cells\n  spreadsheet.setCell(0, 0, 5);\n  spreadsheet.setCell(1, 1, 10);\n  spreadsheet.setCell(2, 2, 15);\n  assert(spreadsheet.getCell(0, 0) == 5);\n  assert(spreadsheet.getCell(1, 1) == 10);\n  assert(spreadsheet.getCell(2, 2) == 15);\n\n  // Test summing ranges\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 30);\n  assert(spreadsheet.sumRange(0, 0, 1, 1) == 15);\n\n  // Test setting ranges\n  spreadsheet.setRange(0, 1, 2, 1, 7);\n  assert(spreadsheet.getCell(0, 1) == 7);\n  assert(spreadsheet.getCell(1, 1) == 7);\n  assert(spreadsheet.getCell(2, 1) == 7);\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 41);\n\n  // Test single cell operations\n  spreadsheet.setRange(2, 2, 2, 2, 100);\n  assert(spreadsheet.getCell(2, 2) == 100);\n  assert(spreadsheet.sumRange(2, 2, 2, 2) == 100);\n}\n\nvoid main() {\n  testSpreadsheet();\n  print('All tests passed!');\n}", "all_code": "class Spreadsheet {\n  late int rows;\n  late int cols;\n  late List<List<int>> sheet;\n\n  Spreadsheet(int rows, int cols) {\n    this.rows = rows;\n    this.cols = cols;\n    sheet = List.generate(rows, (_) => List.filled(cols, 0));\n  }\n\n  void setCell(int row, int col, int value) {\n    sheet[row][col] = value;\n  }\n\n  int getCell(int row, int col) {\n    return sheet[row][col];\n  }\n\n  int sumRange(int rowStart, int colStart, int rowEnd, int colEnd) {\n    int sum = 0;\n    for (int i = rowStart; i <= rowEnd; i++) {\n      for (int j = colStart; j <= colEnd; j++) {\n        sum += sheet[i][j];\n      }\n    }\n    return sum;\n  }\n\n  void setRange(int rowStart, int colStart, int rowEnd, int colEnd, int value) {\n    for (int i = rowStart; i <= rowEnd; i++) {\n      for (int j = colStart; j <= colEnd; j++) {\n        sheet[i][j] = value;\n      }\n    }\n  }\n}\n\nvoid testSpreadsheet() {\n  // Test initialization\n  final spreadsheet = Spreadsheet(3, 3);\n  assert(spreadsheet.getCell(0, 0) == 0);\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 0);\n\n  // Test setting individual cells\n  spreadsheet.setCell(0, 0, 5);\n  spreadsheet.setCell(1, 1, 10);\n  spreadsheet.setCell(2, 2, 15);\n  assert(spreadsheet.getCell(0, 0) == 5);\n  assert(spreadsheet.getCell(1, 1) == 10);\n  assert(spreadsheet.getCell(2, 2) == 15);\n\n  // Test summing ranges\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 30);\n  assert(spreadsheet.sumRange(0, 0, 1, 1) == 15);\n\n  // Test setting ranges\n  spreadsheet.setRange(0, 1, 2, 1, 7);\n  assert(spreadsheet.getCell(0, 1) == 7);\n  assert(spreadsheet.getCell(1, 1) == 7);\n  assert(spreadsheet.getCell(2, 1) == 7);\n  assert(spreadsheet.sumRange(0, 0, 2, 2) == 41);\n\n  // Test single cell operations\n  spreadsheet.setRange(2, 2, 2, 2, 100);\n  assert(spreadsheet.getCell(2, 2) == 100);\n  assert(spreadsheet.sumRange(2, 2, 2, 2) == 100);\n}\n\nvoid main() {\n  testSpreadsheet();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "String rearrangeString(String s, Map<String, bool> dict) {\n  List<String> words = s.split(' ');\n  List<String> validWords = [];\n  List<String> invalidWords = [];\n  \n  for (String word in words) {\n    if (dict[word] ?? false) {\n      validWords.add(word);\n    } else {\n      invalidWords.add(word);\n    }\n  }\n  \n  return '${validWords.join(' ')} ${invalidWords.join(' ')}'.trim();\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: \"apple orange banana pear grape\"\nDictionary: {apple: true, banana: true, orange: false, pear: true}\nResult: \"apple banana pear orange grape\"\n\nTest Case 2:\nInput: \"hello world dart\"\nDictionary: {hello: true, world: true, dart: true}\nResult: \"hello world dart\"\n\nTest Case 3:\nInput: \"cat dog bird\"\nDictionary: {cat: false, dog: false, bird: false}\nResult: \"cat dog bird\"\n\nTest Case 4:\nInput: \"\"\nDictionary: {word: true}\nResult: \"\"\n\nTest Case 5:\nInput: \"Hello world! How are you?\"\nDictionary: {Hello: true, world!: false, How: true, are: false, you?: true}\nResult: \"Hello How you? world! are\"", "task_id": 9946, "assertions": "void testRearrangeString() {\n  // Test case 1: Basic case with some valid and invalid words\n  Map<String, bool> dict1 = {\n    'apple': true,\n    'banana': true,\n    'orange': false,\n    'pear': true,\n  };\n  assert(rearrangeString('apple orange banana pear grape', dict1) == \n      'apple banana pear orange grape');\n\n  // Test case 2: All words are valid\n  Map<String, bool> dict2 = {\n    'hello': true,\n    'world': true,\n    'dart': true,\n  };\n  assert(rearrangeString('hello world dart', dict2) == 'hello world dart');\n\n  // Test case 3: All words are invalid\n  Map<String, bool> dict3 = {\n    'cat': false,\n    'dog': false,\n    'bird': false,\n  };\n  assert(rearrangeString('cat dog bird', dict3) == 'cat dog bird');\n\n  // Test case 4: Empty string input\n  Map<String, bool> dict4 = {\n    'word': true,\n  };\n  assert(rearrangeString('', dict4) == '');\n\n  // Test case 5: Mixed case with punctuation\n  Map<String, bool> dict5 = {\n    'Hello': true,\n    'world!': false,\n    'How': true,\n    'are': false,\n    'you?': true,\n  };\n  assert(rearrangeString('Hello world! How are you?', dict5) == \n      'Hello How you? world! are');\n}\n\nvoid main() {\n  testRearrangeString();\n}", "all_code": "String rearrangeString(String s, Map<String, bool> dict) {\n  List<String> words = s.split(' ');\n  List<String> validWords = [];\n  List<String> invalidWords = [];\n  \n  for (String word in words) {\n    if (dict[word] ?? false) {\n      validWords.add(word);\n    } else {\n      invalidWords.add(word);\n    }\n  }\n  \n  return '${validWords.join(' ')} ${invalidWords.join(' ')}'.trim();\n}\n\nvoid testRearrangeString() {\n  // Test case 1: Basic case with some valid and invalid words\n  Map<String, bool> dict1 = {\n    'apple': true,\n    'banana': true,\n    'orange': false,\n    'pear': true,\n  };\n  assert(rearrangeString('apple orange banana pear grape', dict1) == \n      'apple banana pear orange grape');\n\n  // Test case 2: All words are valid\n  Map<String, bool> dict2 = {\n    'hello': true,\n    'world': true,\n    'dart': true,\n  };\n  assert(rearrangeString('hello world dart', dict2) == 'hello world dart');\n\n  // Test case 3: All words are invalid\n  Map<String, bool> dict3 = {\n    'cat': false,\n    'dog': false,\n    'bird': false,\n  };\n  assert(rearrangeString('cat dog bird', dict3) == 'cat dog bird');\n\n  // Test case 4: Empty string input\n  Map<String, bool> dict4 = {\n    'word': true,\n  };\n  assert(rearrangeString('', dict4) == '');\n\n  // Test case 5: Mixed case with punctuation\n  Map<String, bool> dict5 = {\n    'Hello': true,\n    'world!': false,\n    'How': true,\n    'are': false,\n    'you?': true,\n  };\n  assert(rearrangeString('Hello world! How are you?', dict5) == \n      'Hello How you? world! are');\n}\n\nvoid main() {\n  testRearrangeString();\n}", "exec_outcome": "PASSED"}
{"code": "// minTimeToFinalSpeed calculates the minimum time required for all cars to reach\n// the final speed, which is the maximum speed in the given list.\n// Each car can increase its speed by 1 unit per time unit.\n// The function returns the maximum difference between the final speed and any car's initial speed.\nint minTimeToFinalSpeed(int N, List<int> speeds) {\n  // Find the maximum speed in the list, which will be the final speed for all cars\n  int maxSpeed = speeds.reduce((a, b) => a > b ? a : b);\n  int time = 0;\n  \n  // Calculate the time needed for each car to reach the final speed\n  for (int speed in speeds) {\n    time = time > (maxSpeed - speed) ? time : (maxSpeed - speed);\n  }\n  \n  return time;\n}", "test_cases": "", "test_case_results": "Test Case 1 - N: 4, Speeds: [3, 5, 2, 7]\nMinimum Time: 5\n\nTest Case 2 - N: 3, Speeds: [5, 5, 5]\nMinimum Time: 0\n\nTest Case 3 - N: 1, Speeds: [10]\nMinimum Time: 0\n\nTest Case 4 - N: 5, Speeds: [1, 10, 100, 1000, 10000]\nMinimum Time: 9999\n\nTest Case 5 - N: 0, Speeds: []\nError: Bad state: No element", "task_id": 20103, "assertions": "void testMinTimeToFinalSpeed() {\n  // Test case 1: Normal case with varying speeds\n  assert(minTimeToFinalSpeed(4, [3, 5, 2, 7]) == 5);\n  \n  // Test case 2: All cars already at maximum speed\n  assert(minTimeToFinalSpeed(3, [5, 5, 5]) == 0);\n  \n  // Test case 3: Single car\n  assert(minTimeToFinalSpeed(1, [10]) == 0);\n  \n  // Test case 4: Large difference in speeds\n  assert(minTimeToFinalSpeed(5, [1, 10, 100, 1000, 10000]) == 9999);\n  \n  // Test case 5: Empty list (edge case)\n  try {\n    minTimeToFinalSpeed(0, []);\n    assert(false); // This line should not be reached\n  } catch (e) {\n    assert(e.toString().contains('No element'));\n  }\n}\n\nvoid main() {\n  testMinTimeToFinalSpeed();\n  print('All tests passed!');\n}", "all_code": "// minTimeToFinalSpeed calculates the minimum time required for all cars to reach\n// the final speed, which is the maximum speed in the given list.\n// Each car can increase its speed by 1 unit per time unit.\n// The function returns the maximum difference between the final speed and any car's initial speed.\nint minTimeToFinalSpeed(int N, List<int> speeds) {\n  // Find the maximum speed in the list, which will be the final speed for all cars\n  int maxSpeed = speeds.reduce((a, b) => a > b ? a : b);\n  int time = 0;\n  \n  // Calculate the time needed for each car to reach the final speed\n  for (int speed in speeds) {\n    time = time > (maxSpeed - speed) ? time : (maxSpeed - speed);\n  }\n  \n  return time;\n}\n\nvoid testMinTimeToFinalSpeed() {\n  // Test case 1: Normal case with varying speeds\n  assert(minTimeToFinalSpeed(4, [3, 5, 2, 7]) == 5);\n  \n  // Test case 2: All cars already at maximum speed\n  assert(minTimeToFinalSpeed(3, [5, 5, 5]) == 0);\n  \n  // Test case 3: Single car\n  assert(minTimeToFinalSpeed(1, [10]) == 0);\n  \n  // Test case 4: Large difference in speeds\n  assert(minTimeToFinalSpeed(5, [1, 10, 100, 1000, 10000]) == 9999);\n  \n  // Test case 5: Empty list (edge case)\n  try {\n    minTimeToFinalSpeed(0, []);\n    assert(false); // This line should not be reached\n  } catch (e) {\n    assert(e.toString().contains('No element'));\n  }\n}\n\nvoid main() {\n  testMinTimeToFinalSpeed();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// sortEvenIndices sorts the elements at even indices in the input array in ascending order,\n// while leaving the elements at odd indices unchanged.\n// The sorting is done in-place on a copy of the original array to avoid mutation.\nList<int> sortEvenIndices(List<int> arr) {\n  // Extract values at even indices (0, 2, 4, ...)\n  List<int> evenIndicesVals = [];\n  for (int i = 0; i < arr.length; i += 2) {\n    evenIndicesVals.add(arr[i]);\n  }\n  \n  // Sort the extracted even index values\n  evenIndicesVals.sort();\n  \n  // Create a copy of the original array to modify\n  List<int> sortedArr = List.from(arr);\n  int evenIndex = 0;\n  \n  // Replace the even indices in the copy with the sorted values\n  for (int i = 0; i < arr.length; i += 2) {\n    sortedArr[i] = evenIndicesVals[evenIndex];\n    evenIndex++;\n  }\n  \n  return sortedArr;\n}", "test_cases": "", "test_case_results": "Input: [5, 3, 2, 8, 1, 4]\nSorted even indices: [1, 3, 2, 8, 5, 4]\n---\nInput: [1, 2, 3, 4, 5, 6]\nSorted even indices: [1, 2, 3, 4, 5, 6]\n---\nInput: [9, 7, 5, 3, 1]\nSorted even indices: [1, 7, 5, 3, 9]\n---\nInput: [0]\nSorted even indices: [0]\n---\nInput: []\nSorted even indices: []\n---\nInput: [4, 2, 8, 6, 0, 10, 12, 14]\nSorted even indices: [0, 2, 4, 6, 8, 10, 12, 14]\n---", "task_id": 20182, "assertions": "void testSortEvenIndices() {\n  assert(sortEvenIndices([5, 3, 2, 8, 1, 4]) == [1, 3, 2, 8, 5, 4]);\n  assert(sortEvenIndices([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]);\n  assert(sortEvenIndices([9, 7, 5, 3, 1]) == [1, 7, 5, 3, 9]);\n  assert(sortEvenIndices([0]) == [0]);\n  assert(sortEvenIndices([]) == []);\n  assert(sortEvenIndices([4, 2, 8, 6, 0, 10, 12, 14]) == [0, 2, 4, 6, 8, 10, 12, 14]);\n}\n\nvoid main() {\n  testSortEvenIndices();\n  print('All tests passed!');\n}", "all_code": "// sortEvenIndices sorts the elements at even indices in the input array in ascending order,\n// while leaving the elements at odd indices unchanged.\n// The sorting is done in-place on a copy of the original array to avoid mutation.\nList<int> sortEvenIndices(List<int> arr) {\n  // Extract values at even indices (0, 2, 4, ...)\n  List<int> evenIndicesVals = [];\n  for (int i = 0; i < arr.length; i += 2) {\n    evenIndicesVals.add(arr[i]);\n  }\n  \n  // Sort the extracted even index values\n  evenIndicesVals.sort();\n  \n  // Create a copy of the original array to modify\n  List<int> sortedArr = List.from(arr);\n  int evenIndex = 0;\n  \n  // Replace the even indices in the copy with the sorted values\n  for (int i = 0; i < arr.length; i += 2) {\n    sortedArr[i] = evenIndicesVals[evenIndex];\n    evenIndex++;\n  }\n  \n  return sortedArr;\n}\n\nvoid testSortEvenIndices() {\n  assert(sortEvenIndices([5, 3, 2, 8, 1, 4]) == [1, 3, 2, 8, 5, 4]);\n  assert(sortEvenIndices([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]);\n  assert(sortEvenIndices([9, 7, 5, 3, 1]) == [1, 7, 5, 3, 9]);\n  assert(sortEvenIndices([0]) == [0]);\n  assert(sortEvenIndices([]) == []);\n  assert(sortEvenIndices([4, 2, 8, 6, 0, 10, 12, 14]) == [0, 2, 4, 6, 8, 10, 12, 14]);\n}\n\nvoid main() {\n  testSortEvenIndices();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "int minOperationsToAllOnes(int n, int k, String s) {\n  int operations = 0;\n  int i = 0;\n  while (i < n) {\n    if (s[i] == '0') {\n      operations += 1;\n      i += k; // Skip the next k-1 characters because they are flipped\n    } else {\n      i += 1;\n    }\n  }\n  return operations;\n}", "test_cases": "", "test_case_results": "Test 1 - n: 5, k: 2, s: 10101\nOperations: 2\n\nTest 2 - n: 4, k: 3, s: 1111\nOperations: 0\n\nTest 3 - n: 6, k: 2, s: 000000\nOperations: 3\n\nTest 4 - n: 8, k: 3, s: 01010101\nOperations: 2\n\nTest 5 - n: 1, k: 1, s: 0\nOperations: 1", "task_id": 8804, "assertions": "void testMinOperationsToAllOnes() {\n  assert(minOperationsToAllOnes(5, 2, '10101') == 2);\n  assert(minOperationsToAllOnes(4, 3, '1111') == 0);\n  assert(minOperationsToAllOnes(6, 2, '000000') == 3);\n  assert(minOperationsToAllOnes(8, 3, '01010101') == 2);\n  assert(minOperationsToAllOnes(1, 1, '0') == 1);\n}\n\nvoid main() {\n  testMinOperationsToAllOnes();\n}", "all_code": "int minOperationsToAllOnes(int n, int k, String s) {\n  int operations = 0;\n  int i = 0;\n  while (i < n) {\n    if (s[i] == '0') {\n      operations += 1;\n      i += k; // Skip the next k-1 characters because they are flipped\n    } else {\n      i += 1;\n    }\n  }\n  return operations;\n}\n\nvoid testMinOperationsToAllOnes() {\n  assert(minOperationsToAllOnes(5, 2, '10101') == 2);\n  assert(minOperationsToAllOnes(4, 3, '1111') == 0);\n  assert(minOperationsToAllOnes(6, 2, '000000') == 3);\n  assert(minOperationsToAllOnes(8, 3, '01010101') == 2);\n  assert(minOperationsToAllOnes(1, 1, '0') == 1);\n}\n\nvoid main() {\n  testMinOperationsToAllOnes();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n/// Finds the length of the shortest path between two nodes in an unweighted, undirected graph.\n/// \n/// The function uses a breadth-first search (BFS) approach to explore the graph level by level,\n/// which guarantees finding the shortest path in an unweighted graph.\n/// \n/// Parameters:\n///   - graph: A Map representing the adjacency list of the graph (key: node, value: list of connected nodes)\n///   - start: The starting node\n///   - end: The destination node\n/// \n/// Returns:\n///   - The length of the shortest path as an integer, or -1 if no path exists\nint shortestPath(Map<int, List<int>> graph, int start, int end) {\n  if (start == end) {\n    return 0;\n  }\n\n  Set<int> visited = {};\n  Queue<List<int>> queue = Queue<List<int>>();\n  queue.add([start, 0]); // Each queue element is a pair: [currentNode, currentDistance]\n\n  while (queue.isNotEmpty) {\n    List<int> current = queue.removeFirst();\n    int currentNode = current[0];\n    int currentDistance = current[1];\n\n    if (currentNode == end) {\n      return currentDistance;\n    }\n\n    visited.add(currentNode);\n\n    for (int neighbor in graph[currentNode] ?? []) {\n      if (!visited.contains(neighbor)) {\n        queue.add([neighbor, currentDistance + 1]);\n        visited.add(neighbor);\n      }\n    }\n  }\n\n  return -1;\n}", "test_cases": "", "test_case_results": "Test Case: Simple connected graph\nGraph: {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4]}\nStart: 1, End: 5\nShortest path length: 3\n---\nTest Case: Start equals end\nGraph: {1: [2], 2: [1, 3], 3: [2]}\nStart: 2, End: 2\nShortest path length: 0\n---\nTest Case: Disconnected graph\nGraph: {1: [2], 2: [1], 3: [4], 4: [3]}\nStart: 1, End: 3\nShortest path length: -1\n---\nTest Case: Linear graph\nGraph: {1: [2], 2: [1, 3], 3: [2, 4], 4: [3]}\nStart: 1, End: 4\nShortest path length: 3\n---", "task_id": 22789, "assertions": "import 'dart:collection';\n\nvoid testShortestPath() {\n  // Test case 1: Simple connected graph\n  assert(shortestPath({\n    1: [2, 3],\n    2: [1, 4],\n    3: [1, 4],\n    4: [2, 3, 5],\n    5: [4]\n  }, 1, 5) == 3);\n\n  // Test case 2: Start equals end\n  assert(shortestPath({\n    1: [2],\n    2: [1, 3],\n    3: [2]\n  }, 2, 2) == 0);\n\n  // Test case 3: Disconnected graph\n  assert(shortestPath({\n    1: [2],\n    2: [1],\n    3: [4],\n    4: [3]\n  }, 1, 3) == -1);\n\n  // Test case 4: Linear graph\n  assert(shortestPath({\n    1: [2],\n    2: [1, 3],\n    3: [2, 4],\n    4: [3]\n  }, 1, 4) == 3);\n}\n\nvoid main() {\n  testShortestPath();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n/// Finds the length of the shortest path between two nodes in an unweighted, undirected graph.\n/// \n/// The function uses a breadth-first search (BFS) approach to explore the graph level by level,\n/// which guarantees finding the shortest path in an unweighted graph.\n/// \n/// Parameters:\n///   - graph: A Map representing the adjacency list of the graph (key: node, value: list of connected nodes)\n///   - start: The starting node\n///   - end: The destination node\n/// \n/// Returns:\n///   - The length of the shortest path as an integer, or -1 if no path exists\nint shortestPath(Map<int, List<int>> graph, int start, int end) {\n  if (start == end) {\n    return 0;\n  }\n\n  Set<int> visited = {};\n  Queue<List<int>> queue = Queue<List<int>>();\n  queue.add([start, 0]); // Each queue element is a pair: [currentNode, currentDistance]\n\n  while (queue.isNotEmpty) {\n    List<int> current = queue.removeFirst();\n    int currentNode = current[0];\n    int currentDistance = current[1];\n\n    if (currentNode == end) {\n      return currentDistance;\n    }\n\n    visited.add(currentNode);\n\n    for (int neighbor in graph[currentNode] ?? []) {\n      if (!visited.contains(neighbor)) {\n        queue.add([neighbor, currentDistance + 1]);\n        visited.add(neighbor);\n      }\n    }\n  }\n\n  return -1;\n}\n\nvoid testShortestPath() {\n  // Test case 1: Simple connected graph\n  assert(shortestPath({\n    1: [2, 3],\n    2: [1, 4],\n    3: [1, 4],\n    4: [2, 3, 5],\n    5: [4]\n  }, 1, 5) == 3);\n\n  // Test case 2: Start equals end\n  assert(shortestPath({\n    1: [2],\n    2: [1, 3],\n    3: [2]\n  }, 2, 2) == 0);\n\n  // Test case 3: Disconnected graph\n  assert(shortestPath({\n    1: [2],\n    2: [1],\n    3: [4],\n    4: [3]\n  }, 1, 3) == -1);\n\n  // Test case 4: Linear graph\n  assert(shortestPath({\n    1: [2],\n    2: [1, 3],\n    3: [2, 4],\n    4: [3]\n  }, 1, 4) == 3);\n}\n\nvoid main() {\n  testShortestPath();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n/// MovingAverage calculates the moving average, maximum, and minimum values\n/// within a sliding window of a specified size.\nclass MovingAverage {\n  final int size;\n  final Queue<double> queue = Queue();\n  double windowSum = 0.0;\n\n  /// Creates a MovingAverage instance with a specified window size.\n  MovingAverage(this.size);\n\n  /// Adds a new value to the window and returns the current moving average.\n  /// If the window is full, the oldest value is removed before adding the new one.\n  double next(double val) {\n    if (queue.length == size) {\n      windowSum -= queue.removeFirst();\n    }\n    queue.add(val);\n    windowSum += val;\n    return windowSum / queue.length;\n  }\n\n  /// Returns the maximum value in the current window.\n  /// Returns 0 if the window is empty.\n  double max() {\n    if (queue.isEmpty) return 0.0;\n    return queue.reduce((a, b) => a > b ? a : b);\n  }\n\n  /// Returns the minimum value in the current window.\n  /// Returns 0 if the window is empty.\n  double min() {\n    if (queue.isEmpty) return 0.0;\n    return queue.reduce((a, b) => a < b ? a : b);\n  }\n}", "test_cases": "", "test_case_results": "Input: 1.0, Average: 1.0, Max: 1.0, Min: 1.0\nInput: 2.0, Average: 1.5, Max: 2.0, Min: 1.0\nInput: 3.0, Average: 2.0, Max: 3.0, Min: 1.0\nInput: 4.0, Average: 3.0, Max: 4.0, Min: 2.0\nInput: 5.0, Average: 4.0, Max: 5.0, Min: 3.0", "task_id": 21030, "assertions": "import 'dart:collection';\n\nvoid testMovingAverage() {\n  MovingAverage movingAverage = MovingAverage(3);\n  \n  // Test case 1\n  double avg1 = movingAverage.next(1.0);\n  assert(avg1 == 1.0);\n  assert(movingAverage.max() == 1.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 2\n  double avg2 = movingAverage.next(2.0);\n  assert(avg2 == 1.5);\n  assert(movingAverage.max() == 2.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 3\n  double avg3 = movingAverage.next(3.0);\n  assert(avg3 == 2.0);\n  assert(movingAverage.max() == 3.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 4\n  double avg4 = movingAverage.next(4.0);\n  assert(avg4 == 3.0);\n  assert(movingAverage.max() == 4.0);\n  assert(movingAverage.min() == 2.0);\n  \n  // Test case 5\n  double avg5 = movingAverage.next(5.0);\n  assert(avg5 == 4.0);\n  assert(movingAverage.max() == 5.0);\n  assert(movingAverage.min() == 3.0);\n}\n\nvoid main() {\n  testMovingAverage();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n/// MovingAverage calculates the moving average, maximum, and minimum values\n/// within a sliding window of a specified size.\nclass MovingAverage {\n  final int size;\n  final Queue<double> queue = Queue();\n  double windowSum = 0.0;\n\n  /// Creates a MovingAverage instance with a specified window size.\n  MovingAverage(this.size);\n\n  /// Adds a new value to the window and returns the current moving average.\n  /// If the window is full, the oldest value is removed before adding the new one.\n  double next(double val) {\n    if (queue.length == size) {\n      windowSum -= queue.removeFirst();\n    }\n    queue.add(val);\n    windowSum += val;\n    return windowSum / queue.length;\n  }\n\n  /// Returns the maximum value in the current window.\n  /// Returns 0 if the window is empty.\n  double max() {\n    if (queue.isEmpty) return 0.0;\n    return queue.reduce((a, b) => a > b ? a : b);\n  }\n\n  /// Returns the minimum value in the current window.\n  /// Returns 0 if the window is empty.\n  double min() {\n    if (queue.isEmpty) return 0.0;\n    return queue.reduce((a, b) => a < b ? a : b);\n  }\n}\n\nvoid testMovingAverage() {\n  MovingAverage movingAverage = MovingAverage(3);\n  \n  // Test case 1\n  double avg1 = movingAverage.next(1.0);\n  assert(avg1 == 1.0);\n  assert(movingAverage.max() == 1.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 2\n  double avg2 = movingAverage.next(2.0);\n  assert(avg2 == 1.5);\n  assert(movingAverage.max() == 2.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 3\n  double avg3 = movingAverage.next(3.0);\n  assert(avg3 == 2.0);\n  assert(movingAverage.max() == 3.0);\n  assert(movingAverage.min() == 1.0);\n  \n  // Test case 4\n  double avg4 = movingAverage.next(4.0);\n  assert(avg4 == 3.0);\n  assert(movingAverage.max() == 4.0);\n  assert(movingAverage.min() == 2.0);\n  \n  // Test case 5\n  double avg5 = movingAverage.next(5.0);\n  assert(avg5 == 4.0);\n  assert(movingAverage.max() == 5.0);\n  assert(movingAverage.min() == 3.0);\n}\n\nvoid main() {\n  testMovingAverage();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n/// A class that calculates the moving average of the last `k` numbers in a stream.\nclass MovingAverage {\n  final int k;\n  final Queue<int> _queue = Queue<int>();\n  double _sum = 0;\n\n  /// Initializes the MovingAverage with the specified window size [k].\n  MovingAverage(this.k);\n\n  /// Adds a new value to the stream and returns the moving average of the last `k` numbers.\n  double next(int val) {\n    _queue.add(val);\n    _sum += val;\n\n    if (_queue.length > k) {\n      _sum -= _queue.removeFirst();\n    }\n\n    return _sum / (_queue.length < k ? _queue.length : k);\n  }\n\n  /// Returns the current moving average of the last `k` numbers.\n  double getAverage() {\n    return _sum / (_queue.length < k ? _queue.length : k);\n  }\n}", "test_cases": "", "test_case_results": "Test Case 1: Window size = 3\nAdding 1, current average: 1.0\nAdding 10, current average: 5.5\nAdding 3, current average: 4.666666666666667\nAdding 5, current average: 6.0\nCurrent average (using getAverage): 6.0\n\nTest Case 2: Window size = 1\nAdding 4, current average: 4.0\nAdding 2, current average: 2.0\nCurrent average (using getAverage): 2.0\n\nTest Case 3: Window size = 5\nAdding 1, current average: 1.0\nAdding 2, current average: 1.5\nAdding 3, current average: 2.0\nCurrent average (using getAverage): 2.0", "task_id": 17437, "assertions": "import 'dart:collection';\n\nvoid testMovingAverage() {\n  // Test case 1: Window size of 3\n  var ma1 = MovingAverage(3);\n  assert(ma1.next(1) == 1.0);\n  assert(ma1.next(10) == 5.5);\n  assert((ma1.next(3) - 4.666666666666667).abs() < 0.000001);\n  assert(ma1.next(5) == 6.0);\n  assert(ma1.getAverage() == 6.0);\n\n  // Test case 2: Window size of 1\n  var ma2 = MovingAverage(1);\n  assert(ma2.next(4) == 4.0);\n  assert(ma2.next(2) == 2.0);\n  assert(ma2.getAverage() == 2.0);\n\n  // Test case 3: Window size of 5 (larger than input sequence)\n  var ma3 = MovingAverage(5);\n  assert(ma3.next(1) == 1.0);\n  assert(ma3.next(2) == 1.5);\n  assert(ma3.next(3) == 2.0);\n  assert(ma3.getAverage() == 2.0);\n}\n\nvoid main() {\n  testMovingAverage();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n/// A class that calculates the moving average of the last `k` numbers in a stream.\nclass MovingAverage {\n  final int k;\n  final Queue<int> _queue = Queue<int>();\n  double _sum = 0;\n\n  /// Initializes the MovingAverage with the specified window size [k].\n  MovingAverage(this.k);\n\n  /// Adds a new value to the stream and returns the moving average of the last `k` numbers.\n  double next(int val) {\n    _queue.add(val);\n    _sum += val;\n\n    if (_queue.length > k) {\n      _sum -= _queue.removeFirst();\n    }\n\n    return _sum / (_queue.length < k ? _queue.length : k);\n  }\n\n  /// Returns the current moving average of the last `k` numbers.\n  double getAverage() {\n    return _sum / (_queue.length < k ? _queue.length : k);\n  }\n}\n\nvoid testMovingAverage() {\n  // Test case 1: Window size of 3\n  var ma1 = MovingAverage(3);\n  assert(ma1.next(1) == 1.0);\n  assert(ma1.next(10) == 5.5);\n  assert((ma1.next(3) - 4.666666666666667).abs() < 0.000001);\n  assert(ma1.next(5) == 6.0);\n  assert(ma1.getAverage() == 6.0);\n\n  // Test case 2: Window size of 1\n  var ma2 = MovingAverage(1);\n  assert(ma2.next(4) == 4.0);\n  assert(ma2.next(2) == 2.0);\n  assert(ma2.getAverage() == 2.0);\n\n  // Test case 3: Window size of 5 (larger than input sequence)\n  var ma3 = MovingAverage(5);\n  assert(ma3.next(1) == 1.0);\n  assert(ma3.next(2) == 1.5);\n  assert(ma3.next(3) == 2.0);\n  assert(ma3.getAverage() == 2.0);\n}\n\nvoid main() {\n  testMovingAverage();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// mysticSequence calculates the k-th number in a special sequence where:\n// - The first two numbers are 1\n// - Each subsequent number is the sum of the previous two, modulo 10^9 + 7\n// This is similar to the Fibonacci sequence but with modulo operation at each step.\nint mysticSequence(int k) {\n  const int MOD = 1000000007; // 10^9 + 7\n  if (k == 1 || k == 2) {\n    return 1;\n  }\n\n  int prev = 1;\n  int curr = 1;\n  for (int i = 3; i <= k; i++) {\n    int next = (prev + curr) % MOD;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}\n\n// processTestCases processes multiple test cases by applying the mysticSequence function to each input.\n// It takes the number of test cases (t) and a list of integers (ks) as input.\nList<int> processTestCases(int t, List<int> ks) {\n  return ks.map((k) => mysticSequence(k)).toList();\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: 5\nOutput: 5\n\nTest Case 2:\nInputs: [1, 2]\nOutputs: [1, 1]\n\nTest Case 3:\nInput: 100\nOutput: 687995182\n\nTest Case 4:\nInputs: [1, 2, 3, 4, 5, 10, 20]\nOutputs: [1, 1, 2, 3, 5, 55, 6765]", "task_id": 20350, "assertions": "void testMysticSequence() {\n  // Test individual values\n  assert(mysticSequence(1) == 1);\n  assert(mysticSequence(2) == 1);\n  assert(mysticSequence(5) == 5);\n  assert(mysticSequence(100) == 687995182);\n\n  // Test batch processing\n  assert(processTestCases(7, [1, 2, 3, 4, 5, 10, 20]).toString() == [1, 1, 2, 3, 5, 55, 6765].toString());\n}\n\nvoid main() {\n  testMysticSequence();\n  print('All tests passed!');\n}", "all_code": "// mysticSequence calculates the k-th number in a special sequence where:\n// - The first two numbers are 1\n// - Each subsequent number is the sum of the previous two, modulo 10^9 + 7\n// This is similar to the Fibonacci sequence but with modulo operation at each step.\nint mysticSequence(int k) {\n  const int MOD = 1000000007; // 10^9 + 7\n  if (k == 1 || k == 2) {\n    return 1;\n  }\n\n  int prev = 1;\n  int curr = 1;\n  for (int i = 3; i <= k; i++) {\n    int next = (prev + curr) % MOD;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}\n\n// processTestCases processes multiple test cases by applying the mysticSequence function to each input.\n// It takes the number of test cases (t) and a list of integers (ks) as input.\nList<int> processTestCases(int t, List<int> ks) {\n  return ks.map((k) => mysticSequence(k)).toList();\n}\n\nvoid testMysticSequence() {\n  // Test individual values\n  assert(mysticSequence(1) == 1);\n  assert(mysticSequence(2) == 1);\n  assert(mysticSequence(5) == 5);\n  assert(mysticSequence(100) == 687995182);\n\n  // Test batch processing\n  assert(processTestCases(7, [1, 2, 3, 4, 5, 10, 20]).toString() == [1, 1, 2, 3, 5, 55, 6765].toString());\n}\n\nvoid main() {\n  testMysticSequence();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n// countWaysToDivideTree calculates the number of ways to divide a tree into two parts\n// by removing one edge. It uses Depth-First Search (DFS) to calculate the size of\n// each subtree and counts how many subtrees have a size that would result in a valid division.\nint countWaysToDivideTree(int n, List<List<int>> edges) {\n  // Create a graph from the edges using adjacency list representation\n  Map<int, List<int>> graph = HashMap();\n  for (var edge in edges) {\n    int u = edge[0];\n    int v = edge[1];\n    graph.putIfAbsent(u, () => []);\n    graph.putIfAbsent(v, () => []);\n    graph[u]!.add(v);\n    graph[v]!.add(u);\n  }\n\n  // To hold the size of each subtree\n  List<int> subtreeSize = List.filled(n + 1, 0);\n\n  // DFS function to calculate subtree sizes\n  int dfs(int node, int parent) {\n    // Initial size of current node's subtree is 1 (the node itself)\n    int size = 1;\n    for (int neighbor in graph[node] ?? []) {\n      if (neighbor != parent) { // Avoid going back to the parent node\n        size += dfs(neighbor, node);\n      }\n    }\n    subtreeSize[node] = size;\n    return size;\n  }\n\n  // Run DFS from node 1 (or any arbitrary node, here we choose 1)\n  dfs(1, -1);\n\n  int ways = 0;\n  for (int i = 1; i <= n; i++) {\n    // Check the size of this subtree\n    if (subtreeSize[i] != n) { // Ensuring we're not at the root\n      ways++;\n    }\n  }\n\n  return ways;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: n = 3, edges = [[1, 2], [1, 3]]\nNumber of ways: 2\n\nTest Case 2:\nInput: n = 7, edges = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7]]\nNumber of ways: 6\n\nTest Case 3:\nInput: n = 4, edges = [[1, 2], [2, 3], [3, 4]]\nNumber of ways: 3\n\nTest Case 4:\nInput: n = 5, edges = [[1, 2], [1, 3], [1, 4], [1, 5]]\nNumber of ways: 4", "task_id": 12590, "assertions": "import 'dart:collection';\n\nvoid testCountWaysToDivideTree() {\n  // Test Case 1: Simple tree with 3 nodes\n  assert(countWaysToDivideTree(3, [\n    [1, 2],\n    [1, 3]\n  ]) == 2);\n\n  // Test Case 2: Binary tree with 7 nodes\n  assert(countWaysToDivideTree(7, [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [2, 5],\n    [3, 6],\n    [3, 7]\n  ]) == 6);\n\n  // Test Case 3: Linear tree (linked list) with 4 nodes\n  assert(countWaysToDivideTree(4, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ]) == 3);\n\n  // Test Case 4: Star-shaped tree with 5 nodes\n  assert(countWaysToDivideTree(5, [\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    [1, 5]\n  ]) == 4);\n}\n\nvoid main() {\n  testCountWaysToDivideTree();\n}", "all_code": "import 'dart:collection';\n\n// countWaysToDivideTree calculates the number of ways to divide a tree into two parts\n// by removing one edge. It uses Depth-First Search (DFS) to calculate the size of\n// each subtree and counts how many subtrees have a size that would result in a valid division.\nint countWaysToDivideTree(int n, List<List<int>> edges) {\n  // Create a graph from the edges using adjacency list representation\n  Map<int, List<int>> graph = HashMap();\n  for (var edge in edges) {\n    int u = edge[0];\n    int v = edge[1];\n    graph.putIfAbsent(u, () => []);\n    graph.putIfAbsent(v, () => []);\n    graph[u]!.add(v);\n    graph[v]!.add(u);\n  }\n\n  // To hold the size of each subtree\n  List<int> subtreeSize = List.filled(n + 1, 0);\n\n  // DFS function to calculate subtree sizes\n  int dfs(int node, int parent) {\n    // Initial size of current node's subtree is 1 (the node itself)\n    int size = 1;\n    for (int neighbor in graph[node] ?? []) {\n      if (neighbor != parent) { // Avoid going back to the parent node\n        size += dfs(neighbor, node);\n      }\n    }\n    subtreeSize[node] = size;\n    return size;\n  }\n\n  // Run DFS from node 1 (or any arbitrary node, here we choose 1)\n  dfs(1, -1);\n\n  int ways = 0;\n  for (int i = 1; i <= n; i++) {\n    // Check the size of this subtree\n    if (subtreeSize[i] != n) { // Ensuring we're not at the root\n      ways++;\n    }\n  }\n\n  return ways;\n}\n\nvoid testCountWaysToDivideTree() {\n  // Test Case 1: Simple tree with 3 nodes\n  assert(countWaysToDivideTree(3, [\n    [1, 2],\n    [1, 3]\n  ]) == 2);\n\n  // Test Case 2: Binary tree with 7 nodes\n  assert(countWaysToDivideTree(7, [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [2, 5],\n    [3, 6],\n    [3, 7]\n  ]) == 6);\n\n  // Test Case 3: Linear tree (linked list) with 4 nodes\n  assert(countWaysToDivideTree(4, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ]) == 3);\n\n  // Test Case 4: Star-shaped tree with 5 nodes\n  assert(countWaysToDivideTree(5, [\n    [1, 2],\n    [1, 3],\n    [1, 4],\n    [1, 5]\n  ]) == 4);\n}\n\nvoid main() {\n  testCountWaysToDivideTree();\n}", "exec_outcome": "PASSED"}
{"code": "// firstVowelIndex returns the index of the first vowel in the string s.\n// Vowels are considered to be 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts.\n// If no vowels are found in the string, it returns -1.\nint firstVowelIndex(String s) {\n  const vowels = 'aeiouAEIOU';\n  for (int i = 0; i < s.length; i++) {\n    if (vowels.contains(s[i])) {\n      return i;\n    }\n  }\n  return -1;\n}", "test_cases": "", "test_case_results": "Input: \"hello\"\nFirst vowel at index: 1\n---\nInput: \"Apple\"\nFirst vowel at index: 0\n---\nInput: \"rhythm\"\nNo vowels found\n---\nInput: \"STRING\"\nFirst vowel at index: 3\n---\nInput: \"bcdfg\"\nNo vowels found\n---\nInput: \"\"\nNo vowels found\n---\nInput: \"Uppercase\"\nFirst vowel at index: 0\n---\nInput: \"zebra\"\nFirst vowel at index: 1\n---", "task_id": 15528, "assertions": "void testFirstVowelIndex() {\n  assert(firstVowelIndex('hello') == 1);\n  assert(firstVowelIndex('Apple') == 0);\n  assert(firstVowelIndex('rhythm') == -1);\n  assert(firstVowelIndex('STRING') == 3);\n  assert(firstVowelIndex('bcdfg') == -1);\n  assert(firstVowelIndex('') == -1);\n  assert(firstVowelIndex('Uppercase') == 0);\n  assert(firstVowelIndex('zebra') == 1);\n  print('All tests passed!');\n}\n\nvoid main() {\n  testFirstVowelIndex();\n}", "all_code": "// firstVowelIndex returns the index of the first vowel in the string s.\n// Vowels are considered to be 'a', 'e', 'i', 'o', 'u' and their uppercase counterparts.\n// If no vowels are found in the string, it returns -1.\nint firstVowelIndex(String s) {\n  const vowels = 'aeiouAEIOU';\n  for (int i = 0; i < s.length; i++) {\n    if (vowels.contains(s[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nvoid testFirstVowelIndex() {\n  assert(firstVowelIndex('hello') == 1);\n  assert(firstVowelIndex('Apple') == 0);\n  assert(firstVowelIndex('rhythm') == -1);\n  assert(firstVowelIndex('STRING') == 3);\n  assert(firstVowelIndex('bcdfg') == -1);\n  assert(firstVowelIndex('') == -1);\n  assert(firstVowelIndex('Uppercase') == 0);\n  assert(firstVowelIndex('zebra') == 1);\n  print('All tests passed!');\n}\n\nvoid main() {\n  testFirstVowelIndex();\n}", "exec_outcome": "PASSED"}
{"code": "// maxPairs calculates the maximum number of pairs that can be formed\n// from a given sequence of 'W' (women) and 'M' (men) characters.\n// A pair consists of one 'M' and one 'W'.\n// The function counts the occurrences of each and returns the minimum count,\n// which represents the maximum possible pairs.\nint maxPairs(String sequence) {\n  int countW = 'W'.allMatches(sequence).length;\n  int countM = 'M'.allMatches(sequence).length;\n  \n  // The maximum number of pairs is the minimum of the count of 'W' and 'M'\n  return countW < countM ? countW : countM;\n}", "test_cases": "", "test_case_results": "Input: 'WMWM'\nMaximum pairs: 2\n\nInput: 'WWMMM'\nMaximum pairs: 2\n\nInput: 'WWW'\nMaximum pairs: 0\n\nInput: 'MMM'\nMaximum pairs: 0\n\nInput: 'W'\nMaximum pairs: 0\n\nInput: 'M'\nMaximum pairs: 0\n\nInput: ''\nMaximum pairs: 0\n\nInput: 'WMWMWMWMWM'\nMaximum pairs: 5", "task_id": 114, "assertions": "void testMaxPairs() {\n  assert(maxPairs(\"WMWM\") == 2);\n  assert(maxPairs(\"WWMMM\") == 2);\n  assert(maxPairs(\"WWW\") == 0);\n  assert(maxPairs(\"MMM\") == 0);\n  assert(maxPairs(\"W\") == 0);\n  assert(maxPairs(\"M\") == 0);\n  assert(maxPairs(\"\") == 0);\n  assert(maxPairs(\"WMWMWMWMWM\") == 5);\n}\n\nvoid main() {\n  testMaxPairs();\n}", "all_code": "// maxPairs calculates the maximum number of pairs that can be formed\n// from a given sequence of 'W' (women) and 'M' (men) characters.\n// A pair consists of one 'M' and one 'W'.\n// The function counts the occurrences of each and returns the minimum count,\n// which represents the maximum possible pairs.\nint maxPairs(String sequence) {\n  int countW = 'W'.allMatches(sequence).length;\n  int countM = 'M'.allMatches(sequence).length;\n  \n  // The maximum number of pairs is the minimum of the count of 'W' and 'M'\n  return countW < countM ? countW : countM;\n}\n\nvoid testMaxPairs() {\n  assert(maxPairs(\"WMWM\") == 2);\n  assert(maxPairs(\"WWMMM\") == 2);\n  assert(maxPairs(\"WWW\") == 0);\n  assert(maxPairs(\"MMM\") == 0);\n  assert(maxPairs(\"W\") == 0);\n  assert(maxPairs(\"M\") == 0);\n  assert(maxPairs(\"\") == 0);\n  assert(maxPairs(\"WMWMWMWMWM\") == 5);\n}\n\nvoid main() {\n  testMaxPairs();\n}", "exec_outcome": "PASSED"}
{"code": "// replaceSubstringCaseInsensitive replaces all occurrences of 'toReplace' in 'originalString'\n// with 'replacement' in a case-insensitive manner.\n// \n// Parameters:\n// originalString - The string in which to perform the replacements.\n// toReplace - The substring to look for in a case-insensitive manner.\n// replacement - The substring to replace with.\n//\n// Returns:\n// A new string with all case-insensitive occurrences of 'toReplace' replaced by 'replacement'.\nString replaceSubstringCaseInsensitive(String originalString, String toReplace, String replacement) {\n  // Create a regular expression pattern that matches the target string case-insensitively\n  final pattern = RegExp(toReplace, caseSensitive: false);\n  // Replace all occurrences of the pattern with the replacement string\n  return originalString.replaceAll(pattern, replacement);\n}", "test_cases": "", "test_case_results": "Original: \"Hello World\", Replace: \"hello\", With: \"Hi\"\nResult: \"Hi World\"\n\nOriginal: \"Dart is great\", Replace: \"GREAT\", With: \"awesome\"\nResult: \"Dart is awesome\"\n\nOriginal: \"Case INSENSITIVE\", Replace: \"insensitive\", With: \"sensitive\"\nResult: \"Case sensitive\"\n\nOriginal: \"No match here\", Replace: \"python\", With: \"dart\"\nResult: \"No match here\"\n\nOriginal: \"Multiple words words words\", Replace: \"words\", With: \"replacements\"\nResult: \"Multiple replacements replacements replacements\"\n\nOriginal: \"Mixed CASE exAmple\", Replace: \"example\", With: \"test\"\nResult: \"Mixed CASE test\"", "task_id": 25117, "assertions": "void testReplaceSubstringCaseInsensitive() {\n  assert(replaceSubstringCaseInsensitive('Hello World', 'hello', 'Hi') == 'Hi World');\n  assert(replaceSubstringCaseInsensitive('Dart is great', 'GREAT', 'awesome') == 'Dart is awesome');\n  assert(replaceSubstringCaseInsensitive('Case INSENSITIVE', 'insensitive', 'sensitive') == 'Case sensitive');\n  assert(replaceSubstringCaseInsensitive('No match here', 'python', 'dart') == 'No match here');\n  assert(replaceSubstringCaseInsensitive('Multiple words words words', 'words', 'replacements') == 'Multiple replacements replacements replacements');\n  assert(replaceSubstringCaseInsensitive('Mixed CASE exAmple', 'example', 'test') == 'Mixed CASE test');\n}\n\nvoid main() {\n  testReplaceSubstringCaseInsensitive();\n}", "all_code": "// replaceSubstringCaseInsensitive replaces all occurrences of 'toReplace' in 'originalString'\n// with 'replacement' in a case-insensitive manner.\n// \n// Parameters:\n// originalString - The string in which to perform the replacements.\n// toReplace - The substring to look for in a case-insensitive manner.\n// replacement - The substring to replace with.\n//\n// Returns:\n// A new string with all case-insensitive occurrences of 'toReplace' replaced by 'replacement'.\nString replaceSubstringCaseInsensitive(String originalString, String toReplace, String replacement) {\n  // Create a regular expression pattern that matches the target string case-insensitively\n  final pattern = RegExp(toReplace, caseSensitive: false);\n  // Replace all occurrences of the pattern with the replacement string\n  return originalString.replaceAll(pattern, replacement);\n}\n\nvoid testReplaceSubstringCaseInsensitive() {\n  assert(replaceSubstringCaseInsensitive('Hello World', 'hello', 'Hi') == 'Hi World');\n  assert(replaceSubstringCaseInsensitive('Dart is great', 'GREAT', 'awesome') == 'Dart is awesome');\n  assert(replaceSubstringCaseInsensitive('Case INSENSITIVE', 'insensitive', 'sensitive') == 'Case sensitive');\n  assert(replaceSubstringCaseInsensitive('No match here', 'python', 'dart') == 'No match here');\n  assert(replaceSubstringCaseInsensitive('Multiple words words words', 'words', 'replacements') == 'Multiple replacements replacements replacements');\n  assert(replaceSubstringCaseInsensitive('Mixed CASE exAmple', 'example', 'test') == 'Mixed CASE test');\n}\n\nvoid main() {\n  testReplaceSubstringCaseInsensitive();\n}", "exec_outcome": "PASSED"}
{"code": "int maxPairsForSquareTable(List<int> sticks) {\n  // Create a frequency map of stick lengths\n  Map<int, int> counter = {};\n  for (int stick in sticks) {\n    counter[stick] = (counter[stick] ?? 0) + 1;\n  }\n\n  // Calculate total pairs by integer division of each count by 2\n  int pairs = 0;\n  counter.forEach((key, count) {\n    pairs += count ~/ 2;\n  });\n\n  return pairs;\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nMaximum pairs: 0\n---\nInput: [1, 1, 2, 2, 3, 3]\nMaximum pairs: 3\n---\nInput: [5, 5, 5, 5, 5]\nMaximum pairs: 2\n---\nInput: [10, 20, 30]\nMaximum pairs: 0\n---\nInput: [7, 7, 7, 7, 7, 7]\nMaximum pairs: 3\n---\nInput: [1, 1, 1, 2, 2, 2, 2]\nMaximum pairs: 3\n---\nInput: []\nMaximum pairs: 0\n---", "task_id": 26143, "assertions": "void testMaxPairsForSquareTable() {\n  assert(maxPairsForSquareTable([1, 2, 3, 4]) == 0);\n  assert(maxPairsForSquareTable([1, 1, 2, 2, 3, 3]) == 3);\n  assert(maxPairsForSquareTable([5, 5, 5, 5, 5]) == 2);\n  assert(maxPairsForSquareTable([10, 20, 30]) == 0);\n  assert(maxPairsForSquareTable([7, 7, 7, 7, 7, 7]) == 3);\n  assert(maxPairsForSquareTable([1, 1, 1, 2, 2, 2, 2]) == 3);\n  assert(maxPairsForSquareTable([]) == 0);\n}\n\nvoid main() {\n  testMaxPairsForSquareTable();\n  print('All tests passed!');\n}", "all_code": "int maxPairsForSquareTable(List<int> sticks) {\n  // Create a frequency map of stick lengths\n  Map<int, int> counter = {};\n  for (int stick in sticks) {\n    counter[stick] = (counter[stick] ?? 0) + 1;\n  }\n\n  // Calculate total pairs by integer division of each count by 2\n  int pairs = 0;\n  counter.forEach((key, count) {\n    pairs += count ~/ 2;\n  });\n\n  return pairs;\n}\n\nvoid testMaxPairsForSquareTable() {\n  assert(maxPairsForSquareTable([1, 2, 3, 4]) == 0);\n  assert(maxPairsForSquareTable([1, 1, 2, 2, 3, 3]) == 3);\n  assert(maxPairsForSquareTable([5, 5, 5, 5, 5]) == 2);\n  assert(maxPairsForSquareTable([10, 20, 30]) == 0);\n  assert(maxPairsForSquareTable([7, 7, 7, 7, 7, 7]) == 3);\n  assert(maxPairsForSquareTable([1, 1, 1, 2, 2, 2, 2]) == 3);\n  assert(maxPairsForSquareTable([]) == 0);\n}\n\nvoid main() {\n  testMaxPairsForSquareTable();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// isUniqueAnagramIdentifier checks which words in a list are unique anagram identifiers.\n// For each word in the input list, it returns true if no other word is an anagram of it,\n// and false if there are other anagrams of the word in the list.\n// The function uses a map to group words by their sorted characters to identify anagrams.\nList<bool> isUniqueAnagramIdentifier(List<String> wordList) {\n  Map<String, List<int>> anagramMap = {};\n  List<bool> result = List.filled(wordList.length, true);\n  \n  for (int idx = 0; idx < wordList.length; idx++) {\n    String word = wordList[idx];\n    String sortedWord = String.fromCharCodes(word.runes.toList()..sort());\n    \n    if (anagramMap.containsKey(sortedWord)) {\n      for (int linkedIdx in anagramMap[sortedWord]!) {\n        result[linkedIdx] = false;\n      }\n      result[idx] = false;\n      anagramMap[sortedWord]!.add(idx);\n    } else {\n      anagramMap[sortedWord] = [idx];\n    }\n  }\n  \n  return result;\n}", "test_cases": "", "test_case_results": "Input: [listen, silent, enlist, hello, world]\nResults: [false, false, false, true, true]\n\nInput: [debitcard, badcredit, elvis, lives, levis]\nResults: [false, false, false, false, false]\n\nInput: [dormitory, dirtyroom, theeyes, theysee]\nResults: [false, false, false, false]\n\nInput: [cat, dog, bird]\nResults: [true, true, true]\n\nInput: [a, a, a]\nResults: [false, false, false]", "task_id": 1744, "assertions": "void testIsUniqueAnagramIdentifier() {\n  assert(isUniqueAnagramIdentifier([\"listen\", \"silent\", \"enlist\", \"hello\", \"world\"]) == \n      [false, false, false, true, true]);\n  assert(isUniqueAnagramIdentifier([\"debitcard\", \"badcredit\", \"elvis\", \"lives\", \"levis\"]) == \n      [false, false, false, false, false]);\n  assert(isUniqueAnagramIdentifier([\"dormitory\", \"dirtyroom\", \"theeyes\", \"theysee\"]) == \n      [false, false, false, false]);\n  assert(isUniqueAnagramIdentifier([\"cat\", \"dog\", \"bird\"]) == \n      [true, true, true]);\n  assert(isUniqueAnagramIdentifier([\"a\", \"a\", \"a\"]) == \n      [false, false, false]);\n}\n\nvoid main() {\n  testIsUniqueAnagramIdentifier();\n  print(\"All tests passed!\");\n}", "all_code": "// isUniqueAnagramIdentifier checks which words in a list are unique anagram identifiers.\n// For each word in the input list, it returns true if no other word is an anagram of it,\n// and false if there are other anagrams of the word in the list.\n// The function uses a map to group words by their sorted characters to identify anagrams.\nList<bool> isUniqueAnagramIdentifier(List<String> wordList) {\n  Map<String, List<int>> anagramMap = {};\n  List<bool> result = List.filled(wordList.length, true);\n  \n  for (int idx = 0; idx < wordList.length; idx++) {\n    String word = wordList[idx];\n    String sortedWord = String.fromCharCodes(word.runes.toList()..sort());\n    \n    if (anagramMap.containsKey(sortedWord)) {\n      for (int linkedIdx in anagramMap[sortedWord]!) {\n        result[linkedIdx] = false;\n      }\n      result[idx] = false;\n      anagramMap[sortedWord]!.add(idx);\n    } else {\n      anagramMap[sortedWord] = [idx];\n    }\n  }\n  \n  return result;\n}\n\nvoid testIsUniqueAnagramIdentifier() {\n  assert(isUniqueAnagramIdentifier([\"listen\", \"silent\", \"enlist\", \"hello\", \"world\"]) == \n      [false, false, false, true, true]);\n  assert(isUniqueAnagramIdentifier([\"debitcard\", \"badcredit\", \"elvis\", \"lives\", \"levis\"]) == \n      [false, false, false, false, false]);\n  assert(isUniqueAnagramIdentifier([\"dormitory\", \"dirtyroom\", \"theeyes\", \"theysee\"]) == \n      [false, false, false, false]);\n  assert(isUniqueAnagramIdentifier([\"cat\", \"dog\", \"bird\"]) == \n      [true, true, true]);\n  assert(isUniqueAnagramIdentifier([\"a\", \"a\", \"a\"]) == \n      [false, false, false]);\n}\n\nvoid main() {\n  testIsUniqueAnagramIdentifier();\n  print(\"All tests passed!\");\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// roadTripSnacks calculates the maximum number of snacks that can be consumed\n// without exceeding the calorie limit, and the total calories consumed.\n// It sorts the snacks by calorie count and then selects them in order until\n// the calorie limit is reached.\nList<dynamic> roadTripSnacks(int N, int C, List<int> snacks) {\n  // Sort the snacks by calorie count\n  snacks.sort();\n  \n  int totalCalories = 0;\n  int countSnacks = 0;\n  \n  for (int calorie in snacks) {\n    if (totalCalories + calorie <= C) {\n      totalCalories += calorie;\n      countSnacks++;\n    } else {\n      break;\n    }\n  }\n  \n  return [countSnacks, totalCalories];\n}", "test_cases": "", "test_case_results": "Test Case 1 - N: 4, C: 10, Snacks: [5, 3, 2, 4]\nMax snacks: 3, Total calories: 9\n\nTest Case 2 - N: 3, C: 15, Snacks: [4, 5, 6]\nMax snacks: 3, Total calories: 15\n\nTest Case 3 - N: 5, C: 7, Snacks: [8, 9, 2, 5, 6]\nMax snacks: 2, Total calories: 7\n\nTest Case 4 - N: 0, C: 10, Snacks: []\nMax snacks: 0, Total calories: 0\n\nTest Case 5 - N: 3, C: 0, Snacks: [1, 2, 3]\nMax snacks: 0, Total calories: 0", "task_id": 5968, "assertions": "void testRoadTripSnacks() {\n  // Test case 1: Basic case with 4 snacks\n  assert(roadTripSnacks(4, 10, [5, 3, 2, 4]).toString() == '[3, 9]');\n  \n  // Test case 2: All snacks can be consumed\n  assert(roadTripSnacks(3, 15, [4, 5, 6]).toString() == '[3, 15]');\n  \n  // Test case 3: Only one snack can be consumed\n  assert(roadTripSnacks(5, 7, [8, 9, 2, 5, 6]).toString() == '[2, 7]');\n  \n  // Test case 4: Edge case with no snacks\n  assert(roadTripSnacks(0, 10, []).toString() == '[0, 0]');\n  \n  // Test case 5: Edge case with zero calorie limit\n  assert(roadTripSnacks(3, 0, [1, 2, 3]).toString() == '[0, 0]');\n}\n\nvoid main() {\n  testRoadTripSnacks();\n  print('All tests passed!');\n}", "all_code": "// roadTripSnacks calculates the maximum number of snacks that can be consumed\n// without exceeding the calorie limit, and the total calories consumed.\n// It sorts the snacks by calorie count and then selects them in order until\n// the calorie limit is reached.\nList<dynamic> roadTripSnacks(int N, int C, List<int> snacks) {\n  // Sort the snacks by calorie count\n  snacks.sort();\n  \n  int totalCalories = 0;\n  int countSnacks = 0;\n  \n  for (int calorie in snacks) {\n    if (totalCalories + calorie <= C) {\n      totalCalories += calorie;\n      countSnacks++;\n    } else {\n      break;\n    }\n  }\n  \n  return [countSnacks, totalCalories];\n}\n\nvoid testRoadTripSnacks() {\n  // Test case 1: Basic case with 4 snacks\n  assert(roadTripSnacks(4, 10, [5, 3, 2, 4]).toString() == '[3, 9]');\n  \n  // Test case 2: All snacks can be consumed\n  assert(roadTripSnacks(3, 15, [4, 5, 6]).toString() == '[3, 15]');\n  \n  // Test case 3: Only one snack can be consumed\n  assert(roadTripSnacks(5, 7, [8, 9, 2, 5, 6]).toString() == '[2, 7]');\n  \n  // Test case 4: Edge case with no snacks\n  assert(roadTripSnacks(0, 10, []).toString() == '[0, 0]');\n  \n  // Test case 5: Edge case with zero calorie limit\n  assert(roadTripSnacks(3, 0, [1, 2, 3]).toString() == '[0, 0]');\n}\n\nvoid main() {\n  testRoadTripSnacks();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// phoneCombinations generates all possible letter combinations that the provided digits string could represent.\n// It uses backtracking to explore all possible combinations of letters for each digit.\n// The digits should be from '2' to '9' inclusive.\nList<String> phoneCombinations(String digits) {\n  if (digits.isEmpty) {\n    return [];\n  }\n\n  // Mapping of digit to corresponding letters\n  final phoneMap = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n  };\n\n  final combinations = <String>[];\n\n  // Helper function for backtracking\n  void backtrack(int index, String path) {\n    if (index == digits.length) {\n      combinations.add(path);\n      return;\n    }\n    final possibleLetters = phoneMap[digits[index]]!;\n    for (final letter in possibleLetters.runes) {\n      backtrack(index + 1, path + String.fromCharCode(letter));\n    }\n  }\n\n  backtrack(0, '');\n  return combinations;\n}", "test_cases": "", "test_case_results": "Input: \"\"\nCombinations: []\n---\nInput: \"2\"\nCombinations: [a, b, c]\n---\nInput: \"23\"\nCombinations: [ad, ae, af, bd, be, bf, cd, ce, cf]\n---\nInput: \"79\"\nCombinations: [pw, px, py, pz, qw, qx, qy, qz, rw, rx, ry, rz, sw, sx, sy, sz]\n---\nInput: \"234\"\nCombinations: [adg, adh, adi, aeg, aeh, aei, afg, afh, afi, bdg, bdh, bdi, beg, beh, bei, bfg, bfh, bfi, cdg, cdh, cdi, ceg, ceh, cei, cfg, cfh, cfi]\n---", "task_id": 2452, "assertions": "void testPhoneCombinations() {\n  assert(phoneCombinations(\"\").isEmpty);\n  assert(phoneCombinations(\"2\").toString() == \"[a, b, c]\");\n  assert(phoneCombinations(\"23\").toString() == \"[ad, ae, af, bd, be, bf, cd, ce, cf]\");\n  assert(phoneCombinations(\"79\").toString() == \n         \"[pw, px, py, pz, qw, qx, qy, qz, rw, rx, ry, rz, sw, sx, sy, sz]\");\n  assert(phoneCombinations(\"234\").toString() == \n         \"[adg, adh, adi, aeg, aeh, aei, afg, afh, afi, bdg, bdh, bdi, beg, beh, bei, bfg, bfh, bfi, cdg, cdh, cdi, ceg, ceh, cei, cfg, cfh, cfi]\");\n}\n\nvoid main() {\n  testPhoneCombinations();\n  print(\"All tests passed!\");\n}", "all_code": "// phoneCombinations generates all possible letter combinations that the provided digits string could represent.\n// It uses backtracking to explore all possible combinations of letters for each digit.\n// The digits should be from '2' to '9' inclusive.\nList<String> phoneCombinations(String digits) {\n  if (digits.isEmpty) {\n    return [];\n  }\n\n  // Mapping of digit to corresponding letters\n  final phoneMap = {\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n  };\n\n  final combinations = <String>[];\n\n  // Helper function for backtracking\n  void backtrack(int index, String path) {\n    if (index == digits.length) {\n      combinations.add(path);\n      return;\n    }\n    final possibleLetters = phoneMap[digits[index]]!;\n    for (final letter in possibleLetters.runes) {\n      backtrack(index + 1, path + String.fromCharCode(letter));\n    }\n  }\n\n  backtrack(0, '');\n  return combinations;\n}\n\nvoid testPhoneCombinations() {\n  assert(phoneCombinations(\"\").isEmpty);\n  assert(phoneCombinations(\"2\").toString() == \"[a, b, c]\");\n  assert(phoneCombinations(\"23\").toString() == \"[ad, ae, af, bd, be, bf, cd, ce, cf]\");\n  assert(phoneCombinations(\"79\").toString() == \n         \"[pw, px, py, pz, qw, qx, qy, qz, rw, rx, ry, rz, sw, sx, sy, sz]\");\n  assert(phoneCombinations(\"234\").toString() == \n         \"[adg, adh, adi, aeg, aeh, aei, afg, afh, afi, bdg, bdh, bdi, beg, beh, bei, bfg, bfh, bfi, cdg, cdh, cdi, ceg, ceh, cei, cfg, cfh, cfi]\");\n}\n\nvoid main() {\n  testPhoneCombinations();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n// Detects if an undirected graph contains a cycle using Depth-First Search (DFS).\n// The graph is represented as an adjacency list (Map<int, List<int>>).\n// Returns true if a cycle is found, false otherwise.\nbool hasCycle(Map<int, List<int>> graph) {\n  Set<int> visited = {};\n\n  bool dfs(int v, int? parent) {\n    visited.add(v);\n    for (int neighbor in graph[v] ?? []) {\n      if (!visited.contains(neighbor)) {\n        if (dfs(neighbor, v)) {\n          return true;\n        }\n      } else if (parent != neighbor) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  for (int node in graph.keys) {\n    if (!visited.contains(node)) {\n      if (dfs(node, null)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Finds the shortest path between two nodes in an undirected graph using Breadth-First Search (BFS).\n// The graph is represented as an adjacency list (Map<int, List<int>>).\n// Returns an empty list if no path exists or if start/end nodes are not in the graph.\nList<int> findShortestPath(Map<int, List<int>> graph, int start, int end) {\n  if (!graph.containsKey(start) || !graph.containsKey(end)) {\n    return [];\n  }\n\n  Queue<List<int>> queue = Queue()..add([start]);\n  Set<int> visited = {start};\n\n  while (queue.isNotEmpty) {\n    List<int> path = queue.removeFirst();\n    int current = path.last;\n    \n    if (current == end) {\n      return path;\n    }\n\n    for (int neighbor in graph[current] ?? []) {\n      if (!visited.contains(neighbor)) {\n        visited.add(neighbor);\n        queue.add([...path, neighbor]);\n      }\n    }\n  }\n\n  return [];\n}", "test_cases": "", "test_case_results": "Cycle Detection Tests:\nGraph 1 (cyclic): true\nGraph 2 (acyclic): false\nGraph 3 (disconnected acyclic): false\n\nShortest Path Tests:\nPath from 0 to 3: [0, 1, 3]\nPath from 2 to 4: [2, 1, 4]\nPath from 0 to 5 (non-existent node): []\nPath from 0 to 0 (same node): [0]", "task_id": 6968, "assertions": "import 'dart:collection';\n\nvoid testGraphFunctions() {\n  // Test cases for cycle detection\n  Map<int, List<int>> testGraph1 = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3],\n    3: [2],\n  };\n\n  Map<int, List<int>> testGraph2 = {\n    0: [1],\n    1: [0, 2],\n    2: [1, 3],\n    3: [2],\n  };\n\n  Map<int, List<int>> testGraph3 = {\n    0: [1],\n    1: [0],\n    2: [3],\n    3: [2],\n  };\n\n  assert(hasCycle(testGraph1) == true);\n  assert(hasCycle(testGraph2) == false);\n  assert(hasCycle(testGraph3) == false);\n\n  // Test cases for shortest path finding\n  Map<int, List<int>> testGraph4 = {\n    0: [1, 4],\n    1: [0, 2, 3, 4],\n    2: [1, 3],\n    3: [1, 2, 4],\n    4: [0, 1, 3],\n  };\n\n  assert(findShortestPath(testGraph4, 0, 3).toString() == [0, 1, 3].toString());\n  assert(findShortestPath(testGraph4, 2, 4).toString() == [2, 1, 4].toString());\n  assert(findShortestPath(testGraph4, 0, 5).isEmpty);\n  assert(findShortestPath(testGraph4, 0, 0).toString() == [0].toString());\n}\n\nvoid main() {\n  testGraphFunctions();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n// Detects if an undirected graph contains a cycle using Depth-First Search (DFS).\n// The graph is represented as an adjacency list (Map<int, List<int>>).\n// Returns true if a cycle is found, false otherwise.\nbool hasCycle(Map<int, List<int>> graph) {\n  Set<int> visited = {};\n\n  bool dfs(int v, int? parent) {\n    visited.add(v);\n    for (int neighbor in graph[v] ?? []) {\n      if (!visited.contains(neighbor)) {\n        if (dfs(neighbor, v)) {\n          return true;\n        }\n      } else if (parent != neighbor) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  for (int node in graph.keys) {\n    if (!visited.contains(node)) {\n      if (dfs(node, null)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n// Finds the shortest path between two nodes in an undirected graph using Breadth-First Search (BFS).\n// The graph is represented as an adjacency list (Map<int, List<int>>).\n// Returns an empty list if no path exists or if start/end nodes are not in the graph.\nList<int> findShortestPath(Map<int, List<int>> graph, int start, int end) {\n  if (!graph.containsKey(start) || !graph.containsKey(end)) {\n    return [];\n  }\n\n  Queue<List<int>> queue = Queue()..add([start]);\n  Set<int> visited = {start};\n\n  while (queue.isNotEmpty) {\n    List<int> path = queue.removeFirst();\n    int current = path.last;\n    \n    if (current == end) {\n      return path;\n    }\n\n    for (int neighbor in graph[current] ?? []) {\n      if (!visited.contains(neighbor)) {\n        visited.add(neighbor);\n        queue.add([...path, neighbor]);\n      }\n    }\n  }\n\n  return [];\n}\n\nvoid testGraphFunctions() {\n  // Test cases for cycle detection\n  Map<int, List<int>> testGraph1 = {\n    0: [1, 2],\n    1: [0, 2],\n    2: [0, 1, 3],\n    3: [2],\n  };\n\n  Map<int, List<int>> testGraph2 = {\n    0: [1],\n    1: [0, 2],\n    2: [1, 3],\n    3: [2],\n  };\n\n  Map<int, List<int>> testGraph3 = {\n    0: [1],\n    1: [0],\n    2: [3],\n    3: [2],\n  };\n\n  assert(hasCycle(testGraph1) == true);\n  assert(hasCycle(testGraph2) == false);\n  assert(hasCycle(testGraph3) == false);\n\n  // Test cases for shortest path finding\n  Map<int, List<int>> testGraph4 = {\n    0: [1, 4],\n    1: [0, 2, 3, 4],\n    2: [1, 3],\n    3: [1, 2, 4],\n    4: [0, 1, 3],\n  };\n\n  assert(findShortestPath(testGraph4, 0, 3).toString() == [0, 1, 3].toString());\n  assert(findShortestPath(testGraph4, 2, 4).toString() == [2, 1, 4].toString());\n  assert(findShortestPath(testGraph4, 0, 5).isEmpty);\n  assert(findShortestPath(testGraph4, 0, 0).toString() == [0].toString());\n}\n\nvoid main() {\n  testGraphFunctions();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// cumulativeIndexSum calculates the cumulative sum of a list of integers,\n// where each element is multiplied by its index in the list.\n// For example, for input [1, 2, 3], the calculation would be:\n// (0*1) + (1*2) + (2*3) = 0 + 2 + 6 = 8\nint cumulativeIndexSum(List<int> lst) {\n  int sum = 0;\n  for (int i = 0; i < lst.length; i++) {\n    sum += i * lst[i];\n  }\n  return sum;\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3]\nResult: 8\n---\nInput: [4, 5, 6, 7]\nResult: 38\n---\nInput: [10]\nResult: 0\n---\nInput: []\nResult: 0\n---\nInput: [1, 1, 1, 1, 1]\nResult: 10\n---", "task_id": 27410, "assertions": "void testCumulativeIndexSum() {\n  assert(cumulativeIndexSum([1, 2, 3]) == 8);\n  assert(cumulativeIndexSum([4, 5, 6, 7]) == 38);\n  assert(cumulativeIndexSum([10]) == 0);\n  assert(cumulativeIndexSum([]) == 0);\n  assert(cumulativeIndexSum([1, 1, 1, 1, 1]) == 10);\n  print('All tests passed!');\n}\n\nvoid main() {\n  testCumulativeIndexSum();\n}", "all_code": "// cumulativeIndexSum calculates the cumulative sum of a list of integers,\n// where each element is multiplied by its index in the list.\n// For example, for input [1, 2, 3], the calculation would be:\n// (0*1) + (1*2) + (2*3) = 0 + 2 + 6 = 8\nint cumulativeIndexSum(List<int> lst) {\n  int sum = 0;\n  for (int i = 0; i < lst.length; i++) {\n    sum += i * lst[i];\n  }\n  return sum;\n}\n\nvoid testCumulativeIndexSum() {\n  assert(cumulativeIndexSum([1, 2, 3]) == 8);\n  assert(cumulativeIndexSum([4, 5, 6, 7]) == 38);\n  assert(cumulativeIndexSum([10]) == 0);\n  assert(cumulativeIndexSum([]) == 0);\n  assert(cumulativeIndexSum([1, 1, 1, 1, 1]) == 10);\n  print('All tests passed!');\n}\n\nvoid main() {\n  testCumulativeIndexSum();\n}", "exec_outcome": "PASSED"}
{"code": "// canSeeBuilding calculates how many buildings can see at least one other building to their right.\n// A building can see another if there exists a building to its right that is of equal or greater height.\n// The function takes a list of building heights and returns the count of such buildings.\nint canSeeBuilding(List<int> heights) {\n  int n = heights.length;\n  int visibleCount = 0;\n\n  for (int i = 0; i < n; i++) {\n    bool canSee = false;\n    for (int j = i + 1; j < n; j++) {\n      if (heights[j] >= heights[i]) {\n        canSee = true;\n        break;\n      }\n    }\n    if (canSee) {\n      visibleCount++;\n    }\n  }\n\n  return visibleCount;\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nVisible buildings: 3\n---\nInput: [4, 3, 2, 1]\nVisible buildings: 0\n---\nInput: [2, 2, 2, 2]\nVisible buildings: 3\n---\nInput: [1, 3, 2, 4]\nVisible buildings: 3\n---\nInput: [5]\nVisible buildings: 0\n---\nInput: []\nVisible buildings: 0\n---\nInput: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nVisible buildings: 0\n---\nInput: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nVisible buildings: 9\n---", "task_id": 496, "assertions": "void testCanSeeBuilding() {\n  assert(canSeeBuilding([1, 2, 3, 4]) == 3);\n  assert(canSeeBuilding([4, 3, 2, 1]) == 0);\n  assert(canSeeBuilding([2, 2, 2, 2]) == 3);\n  assert(canSeeBuilding([1, 3, 2, 4]) == 3);\n  assert(canSeeBuilding([5]) == 0);\n  assert(canSeeBuilding([]) == 0);\n  assert(canSeeBuilding([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0);\n  assert(canSeeBuilding([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9);\n}\n\nvoid main() {\n  testCanSeeBuilding();\n}", "all_code": "// canSeeBuilding calculates how many buildings can see at least one other building to their right.\n// A building can see another if there exists a building to its right that is of equal or greater height.\n// The function takes a list of building heights and returns the count of such buildings.\nint canSeeBuilding(List<int> heights) {\n  int n = heights.length;\n  int visibleCount = 0;\n\n  for (int i = 0; i < n; i++) {\n    bool canSee = false;\n    for (int j = i + 1; j < n; j++) {\n      if (heights[j] >= heights[i]) {\n        canSee = true;\n        break;\n      }\n    }\n    if (canSee) {\n      visibleCount++;\n    }\n  }\n\n  return visibleCount;\n}\n\nvoid testCanSeeBuilding() {\n  assert(canSeeBuilding([1, 2, 3, 4]) == 3);\n  assert(canSeeBuilding([4, 3, 2, 1]) == 0);\n  assert(canSeeBuilding([2, 2, 2, 2]) == 3);\n  assert(canSeeBuilding([1, 3, 2, 4]) == 3);\n  assert(canSeeBuilding([5]) == 0);\n  assert(canSeeBuilding([]) == 0);\n  assert(canSeeBuilding([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 0);\n  assert(canSeeBuilding([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 9);\n}\n\nvoid main() {\n  testCanSeeBuilding();\n}", "exec_outcome": "PASSED"}
{"code": "// mergeItems merges a list of items where each item is a list with an ID as the first element.\n// Items with the same ID are merged by concatenating their subsequent elements with commas.\n// The first item in the input list is treated as a header and preserved as-is.\nList<List<dynamic>> mergeItems(List<List<dynamic>> items) {\n  // Return early if the list is empty or has only one item (the header)\n  if (items.isEmpty || items.length <= 1) {\n    return items;\n  }\n\n  // Preserve the header from the original list\n  List<dynamic> header = items[0];\n  Map<dynamic, List<dynamic>> mergedDict = {};\n\n  // Process each item (skipping the header)\n  for (List<dynamic> item in items.sublist(1)) {\n    dynamic itemId = item[0];\n    \n    // If the item ID hasn't been seen before, add it to the dictionary\n    if (!mergedDict.containsKey(itemId)) {\n      mergedDict[itemId] = item;\n    } else {\n      // For existing items, merge the subsequent elements\n      for (int i = 1; i < item.length; i++) {\n        // Only merge if the current element isn't already in the merged item\n        if (!mergedDict[itemId]![i].toString().contains(item[i].toString())) {\n          mergedDict[itemId]![i] = '${mergedDict[itemId]![i]}, ${item[i]}';\n        }\n      }\n    }\n  }\n\n  // Combine the header with the merged items\n  return [header] + mergedDict.values.toList();\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput: [[ID, Name, Value], [1, Item1, 100]]\nResult: [[ID, Name, Value], [1, Item1, 100]]\n\nTest Case 2:\nInput: [[ID, Name, Value], [1, Item1, 100], [1, Item1, 200], [2, Item2, 300]]\nResult: [[ID, Name, Value], [1, Item1, 100, 200], [2, Item2, 300]]\n\nTest Case 3:\nInput: [[ID, Name, Value], [1, Item1, 100], [2, Item2, 200], [3, Item3, 300]]\nResult: [[ID, Name, Value], [1, Item1, 100], [2, Item2, 200], [3, Item3, 300]]\n\nTest Case 4:\nInput: []\nResult: []\n\nTest Case 5:\nInput: [[ID, Name, Value]]\nResult: [[ID, Name, Value]]", "task_id": 18806, "assertions": "void testMergeItems() {\n  // Test case 1: No items to merge\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100]].toString());\n\n  // Test case 2: Items with same ID should be merged\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100'],\n    [1, 'Item1', '200'],\n    [2, 'Item2', '300']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100, 200], [2, Item2, 300]].toString());\n\n  // Test case 3: Items with different IDs should remain separate\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100'],\n    [2, 'Item2', '200'],\n    [3, 'Item3', '300']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100], [2, Item2, 200], [3, Item3, 300]].toString());\n\n  // Test case 4: Empty input\n  assert(mergeItems([]).toString() == [].toString());\n\n  // Test case 5: Only header\n  assert(mergeItems([\n    ['ID', 'Name', 'Value']\n  ]).toString() == [[ID, Name, Value]].toString());\n}\n\nvoid main() {\n  testMergeItems();\n  print('All tests passed!');\n}", "all_code": "// mergeItems merges a list of items where each item is a list with an ID as the first element.\n// Items with the same ID are merged by concatenating their subsequent elements with commas.\n// The first item in the input list is treated as a header and preserved as-is.\nList<List<dynamic>> mergeItems(List<List<dynamic>> items) {\n  // Return early if the list is empty or has only one item (the header)\n  if (items.isEmpty || items.length <= 1) {\n    return items;\n  }\n\n  // Preserve the header from the original list\n  List<dynamic> header = items[0];\n  Map<dynamic, List<dynamic>> mergedDict = {};\n\n  // Process each item (skipping the header)\n  for (List<dynamic> item in items.sublist(1)) {\n    dynamic itemId = item[0];\n    \n    // If the item ID hasn't been seen before, add it to the dictionary\n    if (!mergedDict.containsKey(itemId)) {\n      mergedDict[itemId] = item;\n    } else {\n      // For existing items, merge the subsequent elements\n      for (int i = 1; i < item.length; i++) {\n        // Only merge if the current element isn't already in the merged item\n        if (!mergedDict[itemId]![i].toString().contains(item[i].toString())) {\n          mergedDict[itemId]![i] = '${mergedDict[itemId]![i]}, ${item[i]}';\n        }\n      }\n    }\n  }\n\n  // Combine the header with the merged items\n  return [header] + mergedDict.values.toList();\n}\n\nvoid testMergeItems() {\n  // Test case 1: No items to merge\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100]].toString());\n\n  // Test case 2: Items with same ID should be merged\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100'],\n    [1, 'Item1', '200'],\n    [2, 'Item2', '300']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100, 200], [2, Item2, 300]].toString());\n\n  // Test case 3: Items with different IDs should remain separate\n  assert(mergeItems([\n    ['ID', 'Name', 'Value'],\n    [1, 'Item1', '100'],\n    [2, 'Item2', '200'],\n    [3, 'Item3', '300']\n  ]).toString() == [[ID, Name, Value], [1, Item1, 100], [2, Item2, 200], [3, Item3, 300]].toString());\n\n  // Test case 4: Empty input\n  assert(mergeItems([]).toString() == [].toString());\n\n  // Test case 5: Only header\n  assert(mergeItems([\n    ['ID', 'Name', 'Value']\n  ]).toString() == [[ID, Name, Value]].toString());\n}\n\nvoid main() {\n  testMergeItems();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// findBestHike determines the best trail with the least total elevation change.\n// It calculates the total elevation change for each trail by summing the absolute\n// differences between consecutive points, then returns the trail with the minimum total.\nList<int> findBestHike(List<List<int>> trails) {\n  // Helper function to calculate total elevation change for a single trail\n  int totalElevationChange(List<int> trail) {\n    int total = 0;\n    for (int i = 0; i < trail.length - 1; i++) {\n      total += (trail[i] - trail[i + 1]).abs();\n    }\n    return total;\n  }\n\n  // Find the trail with minimum elevation change\n  List<int> bestTrail = trails[0];\n  int minChange = totalElevationChange(bestTrail);\n\n  for (List<int> trail in trails) {\n    int currentChange = totalElevationChange(trail);\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      bestTrail = trail;\n    }\n  }\n\n  return bestTrail;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Trails: [[100, 120, 110, 90], [100, 105, 110, 115], [100, 90, 80, 70]]\nBest Trail: [100, 105, 110, 115]\n---\nTest Case 2:\nInput Trails: [[200, 200, 200], [150, 150, 150], [300, 300, 300]]\nBest Trail: [200, 200, 200]\n---\nTest Case 3:\nInput Trails: [[500, 600, 550, 450], [400, 350, 400, 450], [300, 400, 300, 200]]\nBest Trail: [400, 350, 400, 450]\n---\nTest Case 4:\nInput Trails: [[1000], [2000], [3000]]\nBest Trail: [1000]\n---", "task_id": 291, "assertions": "void testFindBestHike() {\n  // Test case 1: Simple trails with obvious best choice\n  assert(\n    findBestHike([\n      [100, 120, 110, 90],\n      [100, 105, 110, 115],\n      [100, 90, 80, 70]\n    ]).toString() == [100, 105, 110, 115].toString()\n  );\n\n  // Test case 2: Trails with equal elevation changes\n  assert(\n    findBestHike([\n      [200, 200, 200],\n      [150, 150, 150],\n      [300, 300, 300]\n    ]).toString() == [200, 200, 200].toString()\n  );\n\n  // Test case 3: More complex trails\n  assert(\n    findBestHike([\n      [500, 600, 550, 450],\n      [400, 350, 400, 450],\n      [300, 400, 300, 200]\n    ]).toString() == [400, 350, 400, 450].toString()\n  );\n\n  // Test case 4: Single-point trails (edge case)\n  assert(\n    findBestHike([\n      [1000],\n      [2000],\n      [3000]\n    ]).toString() == [1000].toString()\n  );\n}\n\nvoid main() {\n  testFindBestHike();\n  print('All tests passed!');\n}", "all_code": "// findBestHike determines the best trail with the least total elevation change.\n// It calculates the total elevation change for each trail by summing the absolute\n// differences between consecutive points, then returns the trail with the minimum total.\nList<int> findBestHike(List<List<int>> trails) {\n  // Helper function to calculate total elevation change for a single trail\n  int totalElevationChange(List<int> trail) {\n    int total = 0;\n    for (int i = 0; i < trail.length - 1; i++) {\n      total += (trail[i] - trail[i + 1]).abs();\n    }\n    return total;\n  }\n\n  // Find the trail with minimum elevation change\n  List<int> bestTrail = trails[0];\n  int minChange = totalElevationChange(bestTrail);\n\n  for (List<int> trail in trails) {\n    int currentChange = totalElevationChange(trail);\n    if (currentChange < minChange) {\n      minChange = currentChange;\n      bestTrail = trail;\n    }\n  }\n\n  return bestTrail;\n}\n\nvoid testFindBestHike() {\n  // Test case 1: Simple trails with obvious best choice\n  assert(\n    findBestHike([\n      [100, 120, 110, 90],\n      [100, 105, 110, 115],\n      [100, 90, 80, 70]\n    ]).toString() == [100, 105, 110, 115].toString()\n  );\n\n  // Test case 2: Trails with equal elevation changes\n  assert(\n    findBestHike([\n      [200, 200, 200],\n      [150, 150, 150],\n      [300, 300, 300]\n    ]).toString() == [200, 200, 200].toString()\n  );\n\n  // Test case 3: More complex trails\n  assert(\n    findBestHike([\n      [500, 600, 550, 450],\n      [400, 350, 400, 450],\n      [300, 400, 300, 200]\n    ]).toString() == [400, 350, 400, 450].toString()\n  );\n\n  // Test case 4: Single-point trails (edge case)\n  assert(\n    findBestHike([\n      [1000],\n      [2000],\n      [3000]\n    ]).toString() == [1000].toString()\n  );\n}\n\nvoid main() {\n  testFindBestHike();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// isUniqueString checks if all characters in a string are unique.\n// It does this by comparing the length of the string with the length of a set\n// created from the string's characters (which automatically removes duplicates).\n// Returns true if all characters are unique, false otherwise.\nbool isUniqueString(String s) {\n  return s.length == Set.from(s.split('')).length;\n}", "test_cases": "", "test_case_results": "Input: \"abcde\" - All unique characters: true\nInput: \"hello\" - All unique characters: false\nInput: \"world\" - All unique characters: true\nInput: \"apple\" - All unique characters: false\nInput: \"banana\" - All unique characters: false\nInput: \"\" - All unique characters: true\nInput: \"a\" - All unique characters: true\nInput: \"  \" - All unique characters: false", "task_id": 15915, "assertions": "void testIsUniqueString() {\n  assert(isUniqueString(\"abcde\") == true);\n  assert(isUniqueString(\"hello\") == false);\n  assert(isUniqueString(\"world\") == true);\n  assert(isUniqueString(\"apple\") == false);\n  assert(isUniqueString(\"banana\") == false);\n  assert(isUniqueString(\"\") == true);\n  assert(isUniqueString(\"a\") == true);\n  assert(isUniqueString(\"  \") == false);\n}\n\nvoid main() {\n  testIsUniqueString();\n}", "all_code": "// isUniqueString checks if all characters in a string are unique.\n// It does this by comparing the length of the string with the length of a set\n// created from the string's characters (which automatically removes duplicates).\n// Returns true if all characters are unique, false otherwise.\nbool isUniqueString(String s) {\n  return s.length == Set.from(s.split('')).length;\n}\n\nvoid testIsUniqueString() {\n  assert(isUniqueString(\"abcde\") == true);\n  assert(isUniqueString(\"hello\") == false);\n  assert(isUniqueString(\"world\") == true);\n  assert(isUniqueString(\"apple\") == false);\n  assert(isUniqueString(\"banana\") == false);\n  assert(isUniqueString(\"\") == true);\n  assert(isUniqueString(\"a\") == true);\n  assert(isUniqueString(\"  \") == false);\n}\n\nvoid main() {\n  testIsUniqueString();\n}", "exec_outcome": "PASSED"}
{"code": "// minNumberOfRoads calculates the minimum number of roads needed to connect all cities\n// in a grid layout with n rows and m columns. The formula used is:\n// (n - 1) * m + (m - 1) * n, which accounts for horizontal and vertical connections.\nList<int> minNumberOfRoads(int t, List<List<int>> testCases) {\n  List<int> result = [];\n  for (List<int> testCase in testCases) {\n    int n = testCase[0];\n    int m = testCase[1];\n    // Calculate minimum roads: horizontal connections + vertical connections\n    int roads = (n - 1) * m + (m - 1) * n;\n    result.add(roads);\n  }\n  return result;\n}", "test_cases": "", "test_case_results": "Testing with single test case:\nGrid [2, 3]: 7 roads needed\n\nTesting with multiple test cases:\nGrid [1, 1]: 0 roads needed\nGrid [3, 4]: 17 roads needed\nGrid [5, 5]: 40 roads needed\n\nTesting edge cases:\nGrid [1, 100]: 99 roads needed\nGrid [100, 1]: 99 roads needed", "task_id": 21598, "assertions": "void testMinNumberOfRoads() {\n  // Test single test case\n  List<int> result1 = minNumberOfRoads(1, [\n    [2, 3]\n  ]);\n  assert(result1[0] == 7);\n\n  // Test multiple test cases\n  List<int> result2 = minNumberOfRoads(3, [\n    [1, 1],\n    [3, 4],\n    [5, 5]\n  ]);\n  assert(result2[0] == 0);\n  assert(result2[1] == 17);\n  assert(result2[2] == 40);\n\n  // Test edge cases\n  List<int> result3 = minNumberOfRoads(2, [\n    [1, 100],\n    [100, 1]\n  ]);\n  assert(result3[0] == 99);\n  assert(result3[1] == 99);\n}\n\nvoid main() {\n  testMinNumberOfRoads();\n  print('All tests passed!');\n}", "all_code": "// minNumberOfRoads calculates the minimum number of roads needed to connect all cities\n// in a grid layout with n rows and m columns. The formula used is:\n// (n - 1) * m + (m - 1) * n, which accounts for horizontal and vertical connections.\nList<int> minNumberOfRoads(int t, List<List<int>> testCases) {\n  List<int> result = [];\n  for (List<int> testCase in testCases) {\n    int n = testCase[0];\n    int m = testCase[1];\n    // Calculate minimum roads: horizontal connections + vertical connections\n    int roads = (n - 1) * m + (m - 1) * n;\n    result.add(roads);\n  }\n  return result;\n}\n\nvoid testMinNumberOfRoads() {\n  // Test single test case\n  List<int> result1 = minNumberOfRoads(1, [\n    [2, 3]\n  ]);\n  assert(result1[0] == 7);\n\n  // Test multiple test cases\n  List<int> result2 = minNumberOfRoads(3, [\n    [1, 1],\n    [3, 4],\n    [5, 5]\n  ]);\n  assert(result2[0] == 0);\n  assert(result2[1] == 17);\n  assert(result2[2] == 40);\n\n  // Test edge cases\n  List<int> result3 = minNumberOfRoads(2, [\n    [1, 100],\n    [100, 1]\n  ]);\n  assert(result3[0] == 99);\n  assert(result3[1] == 99);\n}\n\nvoid main() {\n  testMinNumberOfRoads();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// calculateTotalTime computes the total time for each dataset by summing the times\n// for each row in the dataset. It takes a list of datasets where each dataset contains\n// dimensions (m, n) and a 2D list of times, and returns a list of total times.\nList<int> calculateTotalTime(List<List<dynamic>> datasets) {\n  List<int> result = [];\n  for (var dataset in datasets) {\n    List<int> dimensions = dataset[0];\n    int m = dimensions[0];\n    List<List<int>> times = dataset[1];\n    for (int i = 0; i < m; i++) {\n      result.add(times[i].reduce((a, b) => a + b));\n    }\n  }\n  return result;\n}\n\n// parseInput processes a multi-line input string into structured datasets.\n// Each dataset consists of dimensions (m, n) and a 2D list of times.\n// The input stops processing when encountering \"0 0\".\nList<List<dynamic>> parseInput(String inputStr) {\n  List<String> lines = inputStr.trim().split('\\n');\n  List<List<dynamic>> datasets = [];\n  int i = 0;\n  while (i < lines.length) {\n    List<int> dimensions = lines[i].split(' ').map(int.parse).toList();\n    int m = dimensions[0];\n    int n = dimensions[1];\n    if (m == 0 && n == 0) {\n      break;\n    }\n    i++;\n    List<List<int>> times = [];\n    for (int _ = 0; _ < m; _++) {\n      times.add(lines[i].split(' ').map(int.parse).toList());\n      i++;\n    }\n    datasets.add([dimensions, times]);\n  }\n  return datasets;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput:\n2 3\n1 2 3\n4 5 6\n0 0\n\nTotal Times: [6, 15]\n\nTest Case 2:\nInput:\n1 2\n10 20\n2 2\n1 1\n2 2\n0 0\n\nTotal Times: [30, 2, 4]\n\nTest Case 3:\nInput:\n0 0\n\nTotal Times: []", "task_id": 25371, "assertions": "void testTimeCalculations() {\n  // Test case 1: Simple dataset\n  String input1 = '''\n2 3\n1 2 3\n4 5 6\n0 0\n''';\n  List<List<dynamic>> dataset1 = parseInput(input1);\n  List<int> result1 = calculateTotalTime(dataset1);\n  assert(result1.length == 2);\n  assert(result1[0] == 6);\n  assert(result1[1] == 15);\n\n  // Test case 2: Multiple datasets\n  String input2 = '''\n1 2\n10 20\n2 2\n1 1\n2 2\n0 0\n''';\n  List<List<dynamic>> dataset2 = parseInput(input2);\n  List<int> result2 = calculateTotalTime(dataset2);\n  assert(result2.length == 3);\n  assert(result2[0] == 30);\n  assert(result2[1] == 2);\n  assert(result2[2] == 4);\n\n  // Test case 3: Empty dataset (only termination)\n  String input3 = '''\n0 0\n''';\n  List<List<dynamic>> dataset3 = parseInput(input3);\n  List<int> result3 = calculateTotalTime(dataset3);\n  assert(result3.isEmpty);\n}\n\nvoid main() {\n  testTimeCalculations();\n  print('All tests passed!');\n}", "all_code": "// calculateTotalTime computes the total time for each dataset by summing the times\n// for each row in the dataset. It takes a list of datasets where each dataset contains\n// dimensions (m, n) and a 2D list of times, and returns a list of total times.\nList<int> calculateTotalTime(List<List<dynamic>> datasets) {\n  List<int> result = [];\n  for (var dataset in datasets) {\n    List<int> dimensions = dataset[0];\n    int m = dimensions[0];\n    List<List<int>> times = dataset[1];\n    for (int i = 0; i < m; i++) {\n      result.add(times[i].reduce((a, b) => a + b));\n    }\n  }\n  return result;\n}\n\n// parseInput processes a multi-line input string into structured datasets.\n// Each dataset consists of dimensions (m, n) and a 2D list of times.\n// The input stops processing when encountering \"0 0\".\nList<List<dynamic>> parseInput(String inputStr) {\n  List<String> lines = inputStr.trim().split('\\n');\n  List<List<dynamic>> datasets = [];\n  int i = 0;\n  while (i < lines.length) {\n    List<int> dimensions = lines[i].split(' ').map(int.parse).toList();\n    int m = dimensions[0];\n    int n = dimensions[1];\n    if (m == 0 && n == 0) {\n      break;\n    }\n    i++;\n    List<List<int>> times = [];\n    for (int _ = 0; _ < m; _++) {\n      times.add(lines[i].split(' ').map(int.parse).toList());\n      i++;\n    }\n    datasets.add([dimensions, times]);\n  }\n  return datasets;\n}\n\nvoid testTimeCalculations() {\n  // Test case 1: Simple dataset\n  String input1 = '''\n2 3\n1 2 3\n4 5 6\n0 0\n''';\n  List<List<dynamic>> dataset1 = parseInput(input1);\n  List<int> result1 = calculateTotalTime(dataset1);\n  assert(result1.length == 2);\n  assert(result1[0] == 6);\n  assert(result1[1] == 15);\n\n  // Test case 2: Multiple datasets\n  String input2 = '''\n1 2\n10 20\n2 2\n1 1\n2 2\n0 0\n''';\n  List<List<dynamic>> dataset2 = parseInput(input2);\n  List<int> result2 = calculateTotalTime(dataset2);\n  assert(result2.length == 3);\n  assert(result2[0] == 30);\n  assert(result2[1] == 2);\n  assert(result2[2] == 4);\n\n  // Test case 3: Empty dataset (only termination)\n  String input3 = '''\n0 0\n''';\n  List<List<dynamic>> dataset3 = parseInput(input3);\n  List<int> result3 = calculateTotalTime(dataset3);\n  assert(result3.isEmpty);\n}\n\nvoid main() {\n  testTimeCalculations();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// compareGreater compares elements of list1 with list2 (which can be either a list or a single number)\n// and returns a list of booleans indicating where the elements of list1 are greater.\n// \n// Parameters:\n//   list1: List of numbers to compare\n//   list2: List of numbers or a single number to compare against\n//\n// Returns:\n//   List<bool>: A list of booleans indicating where elements of list1 are greater than list2\n// \n// Throws:\n//   ArgumentError: If list2 is a list and has different length than list1\nList<bool> compareGreater(List<num> list1, dynamic list2) {\n  if (list2 is List<num>) {\n    if (list1.length != list2.length) {\n      throw ArgumentError('Both lists must be of the same length.');\n    }\n    return List.generate(list1.length, (i) => list1[i] > list2[i]);\n  } else if (list2 is num) {\n    return list1.map((a) => a > list2).toList();\n  } else {\n    throw ArgumentError('list2 must be either a number or a list of numbers');\n  }\n}", "test_cases": "", "test_case_results": "Test: Compare list with single number\nList1: [1, 2, 3, 4]\nList2: 2\nResult: [false, false, true, true]\nExpected: [false, false, true, true]\nTest passed\n---\nTest: Compare two lists of equal length\nList1: [5, 3, 8, 2]\nList2: [4, 3, 7, 2]\nResult: [true, false, true, false]\nExpected: [true, false, true, false]\nTest passed\n---\nTest: All elements greater than comparison number\nList1: [10, 20, 30]\nList2: 5\nResult: [true, true, true]\nExpected: [true, true, true]\nTest passed\n---\nTest: No elements greater than comparison number\nList1: [1, 2, 3]\nList2: 5\nResult: [false, false, false]\nExpected: [false, false, false]\nTest passed\n---\nTesting error case - unequal list lengths:\nCaught expected error: Invalid argument(s): Both lists must be of the same length.", "task_id": 10494, "assertions": "void testCompareGreater() {\n  // Test case 1: Compare list with single number\n  assert(compareGreater([1, 2, 3, 4], 2).toString() == [false, false, true, true].toString());\n  \n  // Test case 2: Compare two lists of equal length\n  assert(compareGreater([5, 3, 8, 2], [4, 3, 7, 2]).toString() == [true, false, true, false].toString());\n  \n  // Test case 3: All elements greater than comparison number\n  assert(compareGreater([10, 20, 30], 5).toString() == [true, true, true].toString());\n  \n  // Test case 4: No elements greater than comparison number\n  assert(compareGreater([1, 2, 3], 5).toString() == [false, false, false].toString());\n  \n  // Test error case (unequal list lengths)\n  try {\n    compareGreater([1, 2, 3], [1, 2]);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n    assert(e.toString() == 'Invalid argument(s): Both lists must be of the same length.');\n  }\n  \n  print('All tests passed!');\n}\n\nvoid main() {\n  testCompareGreater();\n}", "all_code": "// compareGreater compares elements of list1 with list2 (which can be either a list or a single number)\n// and returns a list of booleans indicating where the elements of list1 are greater.\n// \n// Parameters:\n//   list1: List of numbers to compare\n//   list2: List of numbers or a single number to compare against\n//\n// Returns:\n//   List<bool>: A list of booleans indicating where elements of list1 are greater than list2\n// \n// Throws:\n//   ArgumentError: If list2 is a list and has different length than list1\nList<bool> compareGreater(List<num> list1, dynamic list2) {\n  if (list2 is List<num>) {\n    if (list1.length != list2.length) {\n      throw ArgumentError('Both lists must be of the same length.');\n    }\n    return List.generate(list1.length, (i) => list1[i] > list2[i]);\n  } else if (list2 is num) {\n    return list1.map((a) => a > list2).toList();\n  } else {\n    throw ArgumentError('list2 must be either a number or a list of numbers');\n  }\n}\n\nvoid testCompareGreater() {\n  // Test case 1: Compare list with single number\n  assert(compareGreater([1, 2, 3, 4], 2).toString() == [false, false, true, true].toString());\n  \n  // Test case 2: Compare two lists of equal length\n  assert(compareGreater([5, 3, 8, 2], [4, 3, 7, 2]).toString() == [true, false, true, false].toString());\n  \n  // Test case 3: All elements greater than comparison number\n  assert(compareGreater([10, 20, 30], 5).toString() == [true, true, true].toString());\n  \n  // Test case 4: No elements greater than comparison number\n  assert(compareGreater([1, 2, 3], 5).toString() == [false, false, false].toString());\n  \n  // Test error case (unequal list lengths)\n  try {\n    compareGreater([1, 2, 3], [1, 2]);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n    assert(e.toString() == 'Invalid argument(s): Both lists must be of the same length.');\n  }\n  \n  print('All tests passed!');\n}\n\nvoid main() {\n  testCompareGreater();\n}", "exec_outcome": "PASSED"}
{"code": "// sortNames sorts a list of strings containing only first names in alphabetical order,\n// case insensitive. It uses Dart's built-in sort function with a custom comparator\n// that compares the lowercase versions of the names.\nList<String> sortNames(List<String> names) {\n  names.sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));\n  return names;\n}", "test_cases": "", "test_case_results": "Input: [Tom, Jerry, John, Justin, Will, Julia, vanya, Nino, Alice]\nSorted: [Alice, Jerry, John, Julia, Justin, Nino, Tom, vanya, Will]\n---\nInput: [bob, Alice, Charlie, alex, DAVE]\nSorted: [alex, Alice, bob, Charlie, DAVE]\n---\nInput: [Zoe, zoe, ZOË, Zoey]\nSorted: [Zoe, zoe, Zoey, ZOË]\n---\nInput: []\nSorted: []\n---\nInput: [Single]\nSorted: [Single]\n---", "task_id": 5860, "assertions": "void testSortNames() {\n  assert(sortNames([\"Tom\", \"Jerry\", \"John\", \"Justin\", \"Will\", \"Julia\", \"vanya\", \"Nino\", \"Alice\"]) == \n      [\"Alice\", \"Jerry\", \"John\", \"Julia\", \"Justin\", \"Nino\", \"Tom\", \"vanya\", \"Will\"]);\n  assert(sortNames([\"bob\", \"Alice\", \"Charlie\", \"alex\", \"DAVE\"]) == \n      [\"alex\", \"Alice\", \"bob\", \"Charlie\", \"DAVE\"]);\n  assert(sortNames([\"Zoe\", \"zoe\", \"ZOË\", \"Zoey\"]) == \n      [\"Zoe\", \"zoe\", \"Zoey\", \"ZOË\"]);\n  assert(sortNames([]) == []);\n  assert(sortNames([\"Single\"]) == [\"Single\"]);\n}\n\nvoid main() {\n  testSortNames();\n}", "all_code": "// sortNames sorts a list of strings containing only first names in alphabetical order,\n// case insensitive. It uses Dart's built-in sort function with a custom comparator\n// that compares the lowercase versions of the names.\nList<String> sortNames(List<String> names) {\n  names.sort((a, b) => a.toLowerCase().compareTo(b.toLowerCase()));\n  return names;\n}\n\nvoid testSortNames() {\n  assert(sortNames([\"Tom\", \"Jerry\", \"John\", \"Justin\", \"Will\", \"Julia\", \"vanya\", \"Nino\", \"Alice\"]) == \n      [\"Alice\", \"Jerry\", \"John\", \"Julia\", \"Justin\", \"Nino\", \"Tom\", \"vanya\", \"Will\"]);\n  assert(sortNames([\"bob\", \"Alice\", \"Charlie\", \"alex\", \"DAVE\"]) == \n      [\"alex\", \"Alice\", \"bob\", \"Charlie\", \"DAVE\"]);\n  assert(sortNames([\"Zoe\", \"zoe\", \"ZOË\", \"Zoey\"]) == \n      [\"Zoe\", \"zoe\", \"Zoey\", \"ZOË\"]);\n  assert(sortNames([]) == []);\n  assert(sortNames([\"Single\"]) == [\"Single\"]);\n}\n\nvoid main() {\n  testSortNames();\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "import 'dart:collection';\n\n// Checks if each province in the input is strongly connected from the given city 'c'\n// using BFS in both the original graph and its transpose.\nList<String> isStronglyConnected(int n, List<List<dynamic>> provinces) {\n  // Performs BFS starting from 'start' node and checks if all nodes are reachable\n  bool bfs(int start, Map<int, List<int>> graph) {\n    Set<int> visited = {};\n    Queue<int> queue = Queue.from([start]);\n    \n    while (queue.isNotEmpty) {\n      int node = queue.removeFirst();\n      if (!visited.contains(node)) {\n        visited.add(node);\n        if (graph.containsKey(node)) {\n          queue.addAll(graph[node]!);\n        }\n      }\n    }\n    return visited.length == graph.length;\n  }\n\n  // Creates the transpose of the given graph (all edges reversed)\n  Map<int, List<int>> transposeGraph(Map<int, List<int>> graph) {\n    Map<int, List<int>> transposed = {};\n    \n    graph.forEach((u, neighbors) {\n      for (int v in neighbors) {\n        transposed.putIfAbsent(v, () => []).add(u);\n      }\n    });\n    \n    return transposed;\n  }\n\n  List<String> results = [];\n  \n  for (var province in provinces) {\n    int v = province[0];\n    int e = province[1];\n    int c = province[2];\n    List<List<int>> edges = List.castFrom(province[3]);\n    \n    Map<int, List<int>> graph = {};\n    for (var edge in edges) {\n      int u = edge[0];\n      int v = edge[1];\n      graph.putIfAbsent(u, () => []).add(v);\n    }\n    \n    bool forwardCheck = bfs(c, graph);\n    if (!forwardCheck) {\n      results.add(\"NO\");\n      continue;\n    }\n    \n    Map<int, List<int>> transposedGraph = transposeGraph(graph);\n    bool backwardCheck = bfs(c, transposedGraph);\n    \n    results.add(forwardCheck && backwardCheck ? \"YES\" : \"NO\");\n  }\n  \n  return results;\n}", "test_cases": "", "test_case_results": "Testing isStronglyConnected function:\n\nTest case 1:\nVertices: 4, Edges: 4, Start city: 0\nEdges: [[0, 1], [1, 2], [2, 3], [3, 0]]\nIs strongly connected: YES\n\nTest case 2:\nVertices: 4, Edges: 3, Start city: 0\nEdges: [[0, 1], [1, 2], [2, 0]]\nIs strongly connected: YES\n\nTest case 3:\nVertices: 3, Edges: 3, Start city: 0\nEdges: [[0, 1], [1, 2], [2, 0]]\nIs strongly connected: YES\n\nTest case 4:\nVertices: 5, Edges: 6, Start city: 0\nEdges: [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4], [4, 1]]\nIs strongly connected: YES", "task_id": 11014, "assertions": "import 'dart:collection';\n\nvoid testIsStronglyConnected() {\n  List<List<dynamic>> testProvinces = [\n    [\n      4, 4, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 3],\n        [3, 0]\n      ]\n    ],\n    [\n      4, 3, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0]\n      ]\n    ],\n    [\n      3, 3, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0]\n      ]\n    ],\n    [\n      5, 6, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0],\n        [1, 3],\n        [3, 4],\n        [4, 1]\n      ]\n    ],\n  ];\n\n  List<String> results = isStronglyConnected(4, testProvinces);\n  assert(results[0] == \"YES\");\n  assert(results[1] == \"YES\");\n  assert(results[2] == \"YES\");\n  assert(results[3] == \"YES\");\n}\n\nvoid main() {\n  testIsStronglyConnected();\n  print(\"All tests passed!\");\n}", "all_code": "import 'dart:collection';\n\n// Checks if each province in the input is strongly connected from the given city 'c'\n// using BFS in both the original graph and its transpose.\nList<String> isStronglyConnected(int n, List<List<dynamic>> provinces) {\n  // Performs BFS starting from 'start' node and checks if all nodes are reachable\n  bool bfs(int start, Map<int, List<int>> graph) {\n    Set<int> visited = {};\n    Queue<int> queue = Queue.from([start]);\n    \n    while (queue.isNotEmpty) {\n      int node = queue.removeFirst();\n      if (!visited.contains(node)) {\n        visited.add(node);\n        if (graph.containsKey(node)) {\n          queue.addAll(graph[node]!);\n        }\n      }\n    }\n    return visited.length == graph.length;\n  }\n\n  // Creates the transpose of the given graph (all edges reversed)\n  Map<int, List<int>> transposeGraph(Map<int, List<int>> graph) {\n    Map<int, List<int>> transposed = {};\n    \n    graph.forEach((u, neighbors) {\n      for (int v in neighbors) {\n        transposed.putIfAbsent(v, () => []).add(u);\n      }\n    });\n    \n    return transposed;\n  }\n\n  List<String> results = [];\n  \n  for (var province in provinces) {\n    int v = province[0];\n    int e = province[1];\n    int c = province[2];\n    List<List<int>> edges = List.castFrom(province[3]);\n    \n    Map<int, List<int>> graph = {};\n    for (var edge in edges) {\n      int u = edge[0];\n      int v = edge[1];\n      graph.putIfAbsent(u, () => []).add(v);\n    }\n    \n    bool forwardCheck = bfs(c, graph);\n    if (!forwardCheck) {\n      results.add(\"NO\");\n      continue;\n    }\n    \n    Map<int, List<int>> transposedGraph = transposeGraph(graph);\n    bool backwardCheck = bfs(c, transposedGraph);\n    \n    results.add(forwardCheck && backwardCheck ? \"YES\" : \"NO\");\n  }\n  \n  return results;\n}\n\nvoid testIsStronglyConnected() {\n  List<List<dynamic>> testProvinces = [\n    [\n      4, 4, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 3],\n        [3, 0]\n      ]\n    ],\n    [\n      4, 3, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0]\n      ]\n    ],\n    [\n      3, 3, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0]\n      ]\n    ],\n    [\n      5, 6, 0, [\n        [0, 1],\n        [1, 2],\n        [2, 0],\n        [1, 3],\n        [3, 4],\n        [4, 1]\n      ]\n    ],\n  ];\n\n  List<String> results = isStronglyConnected(4, testProvinces);\n  assert(results[0] == \"YES\");\n  assert(results[1] == \"YES\");\n  assert(results[2] == \"YES\");\n  assert(results[3] == \"YES\");\n}\n\nvoid main() {\n  testIsStronglyConnected();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// minCoins calculates the minimum number of coins needed to make a given amount in cents\n// using pennies (1 cent), nickels (5 cents), and dimes (10 cents).\n// The function starts with the largest denomination (dimes) and works its way down to pennies.\nint minCoins(int n) {\n  int numCoins = 0;\n  \n  // Number of dimes (10 cents)\n  int numDimes = n ~/ 10;\n  n -= numDimes * 10;\n  numCoins += numDimes;\n  \n  // Number of nickels (5 cents)\n  int numNickels = n ~/ 5;\n  n -= numNickels * 5;\n  numCoins += numNickels;\n  \n  // Number of pennies (1 cent)\n  int numPennies = n;\n  numCoins += numPennies;\n  \n  return numCoins;\n}", "test_cases": "", "test_case_results": "Amount: 25 cents\nMinimum coins needed: 3\nAmount: 17 cents\nMinimum coins needed: 4\nAmount: 8 cents\nMinimum coins needed: 4\nAmount: 3 cents\nMinimum coins needed: 3\nAmount: 0 cents\nMinimum coins needed: 0", "task_id": 310, "assertions": "void testMinCoins() {\n  assert(minCoins(25) == 3);\n  assert(minCoins(17) == 4);\n  assert(minCoins(8) == 4);\n  assert(minCoins(3) == 3);\n  assert(minCoins(0) == 0);\n}\n\nvoid main() {\n  testMinCoins();\n  print('All tests passed!');\n}", "all_code": "// minCoins calculates the minimum number of coins needed to make a given amount in cents\n// using pennies (1 cent), nickels (5 cents), and dimes (10 cents).\n// The function starts with the largest denomination (dimes) and works its way down to pennies.\nint minCoins(int n) {\n  int numCoins = 0;\n  \n  // Number of dimes (10 cents)\n  int numDimes = n ~/ 10;\n  n -= numDimes * 10;\n  numCoins += numDimes;\n  \n  // Number of nickels (5 cents)\n  int numNickels = n ~/ 5;\n  n -= numNickels * 5;\n  numCoins += numNickels;\n  \n  // Number of pennies (1 cent)\n  int numPennies = n;\n  numCoins += numPennies;\n  \n  return numCoins;\n}\n\nvoid testMinCoins() {\n  assert(minCoins(25) == 3);\n  assert(minCoins(17) == 4);\n  assert(minCoins(8) == 4);\n  assert(minCoins(3) == 3);\n  assert(minCoins(0) == 0);\n}\n\nvoid main() {\n  testMinCoins();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// Converts a number to currency format with commas and 2 decimal places\n// Example: 1234.5 becomes \"1,234.50\"\nString currencyFormat(double number) {\n  // Split into whole and decimal parts\n  String str = number.toStringAsFixed(2);\n  List<String> parts = str.split('.');\n  String wholePart = parts[0];\n  String decimalPart = parts[1];\n  \n  // Add commas for thousands separators\n  String formattedWhole = '';\n  int length = wholePart.length;\n  for (int i = 0; i < length; i++) {\n    int digit = length - i;\n    formattedWhole += wholePart[i];\n    if (digit > 1 && digit % 3 == 1) {\n      formattedWhole += ',';\n    }\n  }\n  \n  return '\\$$formattedWhole.$decimalPart';\n}\n\n// Evaluates a mathematical expression string and returns the result\ndouble evaluateMathExpression(String expression) {\n  // This is a simplified evaluator that handles basic arithmetic\n  // Note: A real implementation would need a proper expression parser\n  // For demonstration, we'll just handle simple cases\n  expression = expression.replaceAll(' ', '');\n  \n  if (expression.contains('+')) {\n    List<String> parts = expression.split('+');\n    return double.parse(parts[0]) + double.parse(parts[1]);\n  } else if (expression.contains('-')) {\n    List<String> parts = expression.split('-');\n    return double.parse(parts[0]) - double.parse(parts[1]);\n  } else if (expression.contains('*')) {\n    List<String> parts = expression.split('*');\n    return double.parse(parts[0]) * double.parse(parts[1]);\n  } else if (expression.contains('/')) {\n    List<String> parts = expression.split('/');\n    return double.parse(parts[0]) / double.parse(parts[1]);\n  } else {\n    return double.parse(expression);\n  }\n}", "test_cases": "", "test_case_results": "Currency Format Tests:\nInput: 1234.0 -> $1,234.00\nInput: 5678.9 -> $5,678.90\nInput: 1000000.5 -> $1,000,000.50\nInput: 0.99 -> $0.99\nInput: -2500.75 -> $-2,500.75\n\nMath Expression Tests:\nExpression: \"100 + 200\" -> $300.00\nExpression: \"500 - 300\" -> $200.00\nExpression: \"50 * 10\" -> $500.00\nExpression: \"1000 / 5\" -> $200.00\nExpression: \"123.45\" -> $123.45", "task_id": 29809, "assertions": "void testCurrencyAndMathFunctions() {\n  // Test currencyFormat function\n  assert(currencyFormat(1234.0) == r'$1,234.00');\n  assert(currencyFormat(5678.9) == r'$5,678.90');\n  assert(currencyFormat(1000000.5) == r'$1,000,000.50');\n  assert(currencyFormat(0.99) == r'$0.99');\n  assert(currencyFormat(-2500.75) == r'$-2,500.75');\n\n  // Test evaluateMathExpression function\n  assert(evaluateMathExpression('100 + 200') == 300.0);\n  assert(evaluateMathExpression('500 - 300') == 200.0);\n  assert(evaluateMathExpression('50 * 10') == 500.0);\n  assert(evaluateMathExpression('1000 / 5') == 200.0);\n  assert(evaluateMathExpression('123.45') == 123.45);\n}\n\nvoid main() {\n  testCurrencyAndMathFunctions();\n  print('All tests passed!');\n}", "all_code": "// Converts a number to currency format with commas and 2 decimal places\n// Example: 1234.5 becomes \"1,234.50\"\nString currencyFormat(double number) {\n  // Split into whole and decimal parts\n  String str = number.toStringAsFixed(2);\n  List<String> parts = str.split('.');\n  String wholePart = parts[0];\n  String decimalPart = parts[1];\n  \n  // Add commas for thousands separators\n  String formattedWhole = '';\n  int length = wholePart.length;\n  for (int i = 0; i < length; i++) {\n    int digit = length - i;\n    formattedWhole += wholePart[i];\n    if (digit > 1 && digit % 3 == 1) {\n      formattedWhole += ',';\n    }\n  }\n  \n  return '\\$$formattedWhole.$decimalPart';\n}\n\n// Evaluates a mathematical expression string and returns the result\ndouble evaluateMathExpression(String expression) {\n  // This is a simplified evaluator that handles basic arithmetic\n  // Note: A real implementation would need a proper expression parser\n  // For demonstration, we'll just handle simple cases\n  expression = expression.replaceAll(' ', '');\n  \n  if (expression.contains('+')) {\n    List<String> parts = expression.split('+');\n    return double.parse(parts[0]) + double.parse(parts[1]);\n  } else if (expression.contains('-')) {\n    List<String> parts = expression.split('-');\n    return double.parse(parts[0]) - double.parse(parts[1]);\n  } else if (expression.contains('*')) {\n    List<String> parts = expression.split('*');\n    return double.parse(parts[0]) * double.parse(parts[1]);\n  } else if (expression.contains('/')) {\n    List<String> parts = expression.split('/');\n    return double.parse(parts[0]) / double.parse(parts[1]);\n  } else {\n    return double.parse(expression);\n  }\n}\n\nvoid testCurrencyAndMathFunctions() {\n  // Test currencyFormat function\n  assert(currencyFormat(1234.0) == r'$1,234.00');\n  assert(currencyFormat(5678.9) == r'$5,678.90');\n  assert(currencyFormat(1000000.5) == r'$1,000,000.50');\n  assert(currencyFormat(0.99) == r'$0.99');\n  assert(currencyFormat(-2500.75) == r'$-2,500.75');\n\n  // Test evaluateMathExpression function\n  assert(evaluateMathExpression('100 + 200') == 300.0);\n  assert(evaluateMathExpression('500 - 300') == 200.0);\n  assert(evaluateMathExpression('50 * 10') == 500.0);\n  assert(evaluateMathExpression('1000 / 5') == 200.0);\n  assert(evaluateMathExpression('123.45') == 123.45);\n}\n\nvoid main() {\n  testCurrencyAndMathFunctions();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// distributeCandies calculates the maximum number of groups of three candies that can be formed\n// from a list of candy bags, along with the number of leftover candies.\n// \n// Parameters:\n// - n: The number of bags (unused in calculation but kept for interface consistency)\n// - candies: A list of integers representing the number of candies in each bag\n//\n// Returns:\n// A List<int> where the first element is the total number of groups of three,\n// and the second element is the number of leftover candies.\nList<int> distributeCandies(int n, List<int> candies) {\n  int totalGroups = 0;\n  int leftoverCandies = 0;\n\n  for (int candy in candies) {\n    totalGroups += candy ~/ 3;  // Integer division for groups of three\n    leftoverCandies += candy % 3;  // Remainder is leftover candies\n  }\n\n  // Convert leftover candies into additional groups if possible\n  int additionalGroups = leftoverCandies ~/ 3;\n  leftoverCandies = leftoverCandies % 3;\n\n  totalGroups += additionalGroups;\n\n  return [totalGroups, leftoverCandies];\n}", "test_cases": "", "test_case_results": "Test Case 1 - Input: n=3, candies=[9, 6, 3]\nGroups: 6, Leftovers: 0\n\nTest Case 2 - Input: n=4, candies=[5, 8, 2, 10]\nGroups: 8, Leftovers: 1\n\nTest Case 3 - Input: n=2, candies=[1, 2]\nGroups: 1, Leftovers: 0\n\nTest Case 4 - Input: n=0, candies=[]\nGroups: 0, Leftovers: 0", "task_id": 13769, "assertions": "void testDistributeCandies() {\n  // Test case 1: Basic case with exact groups\n  assert(distributeCandies(3, [9, 6, 3])[0] == 6);\n  assert(distributeCandies(3, [9, 6, 3])[1] == 0);\n\n  // Test Case 2: Mixed groups with leftovers\n  assert(distributeCandies(4, [5, 8, 2, 10])[0] == 8);\n  assert(distributeCandies(4, [5, 8, 2, 10])[1] == 1);\n\n  // Test Case 3: All small numbers with potential leftover conversion\n  assert(distributeCandies(2, [1, 2])[0] == 1);\n  assert(distributeCandies(2, [1, 2])[1] == 0);\n\n  // Test Case 4: Edge case with no candies\n  assert(distributeCandies(0, [])[0] == 0);\n  assert(distributeCandies(0, [])[1] == 0);\n}\n\nvoid main() {\n  testDistributeCandies();\n  print('All tests passed!');\n}", "all_code": "// distributeCandies calculates the maximum number of groups of three candies that can be formed\n// from a list of candy bags, along with the number of leftover candies.\n// \n// Parameters:\n// - n: The number of bags (unused in calculation but kept for interface consistency)\n// - candies: A list of integers representing the number of candies in each bag\n//\n// Returns:\n// A List<int> where the first element is the total number of groups of three,\n// and the second element is the number of leftover candies.\nList<int> distributeCandies(int n, List<int> candies) {\n  int totalGroups = 0;\n  int leftoverCandies = 0;\n\n  for (int candy in candies) {\n    totalGroups += candy ~/ 3;  // Integer division for groups of three\n    leftoverCandies += candy % 3;  // Remainder is leftover candies\n  }\n\n  // Convert leftover candies into additional groups if possible\n  int additionalGroups = leftoverCandies ~/ 3;\n  leftoverCandies = leftoverCandies % 3;\n\n  totalGroups += additionalGroups;\n\n  return [totalGroups, leftoverCandies];\n}\n\nvoid testDistributeCandies() {\n  // Test case 1: Basic case with exact groups\n  assert(distributeCandies(3, [9, 6, 3])[0] == 6);\n  assert(distributeCandies(3, [9, 6, 3])[1] == 0);\n\n  // Test Case 2: Mixed groups with leftovers\n  assert(distributeCandies(4, [5, 8, 2, 10])[0] == 8);\n  assert(distributeCandies(4, [5, 8, 2, 10])[1] == 1);\n\n  // Test Case 3: All small numbers with potential leftover conversion\n  assert(distributeCandies(2, [1, 2])[0] == 1);\n  assert(distributeCandies(2, [1, 2])[1] == 0);\n\n  // Test Case 4: Edge case with no candies\n  assert(distributeCandies(0, [])[0] == 0);\n  assert(distributeCandies(0, [])[1] == 0);\n}\n\nvoid main() {\n  testDistributeCandies();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// countRegions counts the number of connected regions of '.' characters in a 2D maze.\n// It uses depth-first search (DFS) to explore and mark visited cells.\n// The function modifies the original maze by marking visited cells with '#'.\nint countRegions(List<List<String>> maze, int n, int m) {\n  // Nested DFS function to explore a region\n  void dfs(int x, int y) {\n    // Check if current cell is out of bounds or not part of a region\n    if (x < 0 || y < 0 || x >= n || y >= m || maze[x][y] != '.') {\n      return;\n    }\n    // Mark current cell as visited\n    maze[x][y] = '#';\n    // Explore all four adjacent cells\n    dfs(x + 1, y); // down\n    dfs(x - 1, y); // up\n    dfs(x, y + 1); // right\n    dfs(x, y - 1); // left\n  }\n\n  int regionsCount = 0;\n  // Iterate through each cell in the maze\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      // When an unvisited region is found\n      if (maze[i][j] == '.') {\n        regionsCount++;\n        // Explore and mark all connected cells\n        dfs(i, j);\n      }\n    }\n  }\n  return regionsCount;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nMaze:\n[., ., #, #, ., .]\n[#, ., ., #, #, .]\n[#, ., #, #, ., .]\n[., ., #, #, #, #]\n[#, ., ., #, ., .]\nNumber of regions: 3\n\nTest Case 2:\nMaze:\n[., ., .]\n[., ., .]\n[., ., .]\nNumber of regions: 1\n\nTest Case 3:\nMaze:\n[#, #, #]\n[#, #, #]\n[#, #, #]\nNumber of regions: 0\n\nTest Case 4:\nMaze:\n[., #, ., #]\n[#, ., #, .]\n[., #, ., #]\nNumber of regions: 6", "task_id": 28700, "assertions": "void testCountRegions() {\n  // Test Case 1: Original example (should return 3)\n  var maze1 = [\n    ['.', '.', '#', '#', '.', '.'],\n    ['#', '.', '.', '#', '#', '.'],\n    ['#', '.', '#', '#', '.', '.'],\n    ['.', '.', '#', '#', '#', '#'],\n    ['#', '.', '.', '#', '.', '.']\n  ];\n  assert(countRegions(maze1, 5, 6) == 3);\n\n  // Test Case 2: Single region (should return 1)\n  var maze2 = [\n    ['.', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n  ];\n  assert(countRegions(maze2, 3, 3) == 1);\n\n  // Test Case 3: No regions (should return 0)\n  var maze3 = [\n    ['#', '#', '#'],\n    ['#', '#', '#'],\n    ['#', '#', '#']\n  ];\n  assert(countRegions(maze3, 3, 3) == 0);\n\n  // Test Case 4: Multiple small regions (should return 6)\n  var maze4 = [\n    ['.', '#', '.', '#'],\n    ['#', '.', '#', '.'],\n    ['.', '#', '.', '#']\n  ];\n  assert(countRegions(maze4, 3, 4) == 6);\n}\n\nvoid main() {\n  testCountRegions();\n  print('All tests passed!');\n}", "all_code": "// countRegions counts the number of connected regions of '.' characters in a 2D maze.\n// It uses depth-first search (DFS) to explore and mark visited cells.\n// The function modifies the original maze by marking visited cells with '#'.\nint countRegions(List<List<String>> maze, int n, int m) {\n  // Nested DFS function to explore a region\n  void dfs(int x, int y) {\n    // Check if current cell is out of bounds or not part of a region\n    if (x < 0 || y < 0 || x >= n || y >= m || maze[x][y] != '.') {\n      return;\n    }\n    // Mark current cell as visited\n    maze[x][y] = '#';\n    // Explore all four adjacent cells\n    dfs(x + 1, y); // down\n    dfs(x - 1, y); // up\n    dfs(x, y + 1); // right\n    dfs(x, y - 1); // left\n  }\n\n  int regionsCount = 0;\n  // Iterate through each cell in the maze\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      // When an unvisited region is found\n      if (maze[i][j] == '.') {\n        regionsCount++;\n        // Explore and mark all connected cells\n        dfs(i, j);\n      }\n    }\n  }\n  return regionsCount;\n}\n\nvoid testCountRegions() {\n  // Test Case 1: Original example (should return 3)\n  var maze1 = [\n    ['.', '.', '#', '#', '.', '.'],\n    ['#', '.', '.', '#', '#', '.'],\n    ['#', '.', '#', '#', '.', '.'],\n    ['.', '.', '#', '#', '#', '#'],\n    ['#', '.', '.', '#', '.', '.']\n  ];\n  assert(countRegions(maze1, 5, 6) == 3);\n\n  // Test Case 2: Single region (should return 1)\n  var maze2 = [\n    ['.', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n  ];\n  assert(countRegions(maze2, 3, 3) == 1);\n\n  // Test Case 3: No regions (should return 0)\n  var maze3 = [\n    ['#', '#', '#'],\n    ['#', '#', '#'],\n    ['#', '#', '#']\n  ];\n  assert(countRegions(maze3, 3, 3) == 0);\n\n  // Test Case 4: Multiple small regions (should return 6)\n  var maze4 = [\n    ['.', '#', '.', '#'],\n    ['#', '.', '#', '.'],\n    ['.', '#', '.', '#']\n  ];\n  assert(countRegions(maze4, 3, 4) == 6);\n}\n\nvoid main() {\n  testCountRegions();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// canMakeEqualByOneSubstitution checks if two strings can be made equal by either:\n// 1. Swapping any two characters in one string (when sorted versions are equal), or\n// 2. Making exactly one character substitution in one string.\nList<String> canMakeEqualByOneSubstitution(int t, List<List<String>> testCases) {\n  List<String> results = [];\n  \n  for (List<String> testCase in testCases) {\n    String s1 = testCase[0];\n    String s2 = testCase[1];\n    \n    // Convert strings to lists of characters, sort them, and compare\n    List<String> s1Sorted = s1.split('')..sort();\n    List<String> s2Sorted = s2.split('')..sort();\n    \n    if (s1Sorted.join() == s2Sorted.join()) {\n      results.add(\"YES\");\n    } else if (canBeEqualWithOneSubstitution(s1, s2)) {\n      results.add(\"YES\");\n    } else {\n      results.add(\"NO\");\n    }\n  }\n  \n  return results;\n}\n\n// canBeEqualWithOneSubstitution checks if two strings can be made equal by\n// changing exactly one character in one string.\nbool canBeEqualWithOneSubstitution(String s1, String s2) {\n  if (s1.length != s2.length) {\n    return false;\n  }\n  \n  Map<String, int> counter = {};\n  \n  // Count characters in s1\n  for (int i = 0; i < s1.length; i++) {\n    String char = s1[i];\n    counter[char] = (counter[char] ?? 0) + 1;\n  }\n  \n  int mismatchPairs = 0;\n  \n  // Check characters in s2 against the counter\n  for (int i = 0; i < s2.length; i++) {\n    String char = s2[i];\n    if (counter.containsKey(char) && counter[char]! > 0) {\n      counter[char] = counter[char]! - 1;\n    } else {\n      mismatchPairs++;\n    }\n  }\n  \n  // If there's exactly one mismatch, one substitution can fix it\n  return mismatchPairs == 1;\n}", "test_cases": "", "test_case_results": "Test Cases:\n1. abc vs bca\n2. aabb vs abac\n3. abc vs def\n4. abcd vs abce\n\nResults:\n1. YES\n2. YES\n3. NO\n4. YES", "task_id": 8914, "assertions": "void testCanMakeEqualByOneSubstitution() {\n  int t = 4;\n  List<List<String>> testCases = [\n    [\"abc\", \"bca\"],\n    [\"aabb\", \"abac\"],\n    [\"abc\", \"def\"],\n    [\"abcd\", \"abce\"],\n  ];\n  \n  List<String> expectedResults = [\"YES\", \"YES\", \"NO\", \"YES\"];\n  List<String> actualResults = canMakeEqualByOneSubstitution(t, testCases);\n  \n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testCanMakeEqualByOneSubstitution();\n  print(\"All tests passed!\");\n}", "all_code": "// canMakeEqualByOneSubstitution checks if two strings can be made equal by either:\n// 1. Swapping any two characters in one string (when sorted versions are equal), or\n// 2. Making exactly one character substitution in one string.\nList<String> canMakeEqualByOneSubstitution(int t, List<List<String>> testCases) {\n  List<String> results = [];\n  \n  for (List<String> testCase in testCases) {\n    String s1 = testCase[0];\n    String s2 = testCase[1];\n    \n    // Convert strings to lists of characters, sort them, and compare\n    List<String> s1Sorted = s1.split('')..sort();\n    List<String> s2Sorted = s2.split('')..sort();\n    \n    if (s1Sorted.join() == s2Sorted.join()) {\n      results.add(\"YES\");\n    } else if (canBeEqualWithOneSubstitution(s1, s2)) {\n      results.add(\"YES\");\n    } else {\n      results.add(\"NO\");\n    }\n  }\n  \n  return results;\n}\n\n// canBeEqualWithOneSubstitution checks if two strings can be made equal by\n// changing exactly one character in one string.\nbool canBeEqualWithOneSubstitution(String s1, String s2) {\n  if (s1.length != s2.length) {\n    return false;\n  }\n  \n  Map<String, int> counter = {};\n  \n  // Count characters in s1\n  for (int i = 0; i < s1.length; i++) {\n    String char = s1[i];\n    counter[char] = (counter[char] ?? 0) + 1;\n  }\n  \n  int mismatchPairs = 0;\n  \n  // Check characters in s2 against the counter\n  for (int i = 0; i < s2.length; i++) {\n    String char = s2[i];\n    if (counter.containsKey(char) && counter[char]! > 0) {\n      counter[char] = counter[char]! - 1;\n    } else {\n      mismatchPairs++;\n    }\n  }\n  \n  // If there's exactly one mismatch, one substitution can fix it\n  return mismatchPairs == 1;\n}\n\nvoid testCanMakeEqualByOneSubstitution() {\n  int t = 4;\n  List<List<String>> testCases = [\n    [\"abc\", \"bca\"],\n    [\"aabb\", \"abac\"],\n    [\"abc\", \"def\"],\n    [\"abcd\", \"abce\"],\n  ];\n  \n  List<String> expectedResults = [\"YES\", \"YES\", \"NO\", \"YES\"];\n  List<String> actualResults = canMakeEqualByOneSubstitution(t, testCases);\n  \n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testCanMakeEqualByOneSubstitution();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:math';\n\n// processText processes the given text string and returns a map with word count,\n// sorted unique words, and total number of words.\n//\n// Parameters:\n//   text (String): A string of text to be processed.\n//\n// Returns:\n//   Map<String, dynamic>: A map with keys 'wordCount', 'uniqueWords', and 'totalWords'.\nMap<String, dynamic> processText(String text) {\n  // Step 1: Normalize the text by converting it to lowercase\n  text = text.toLowerCase();\n  \n  // Step 2: Remove all punctuation (replace with spaces to separate words instead of joining)\n  text = text.replaceAll(RegExp(r'[^\\w\\s]'), ' ');\n  \n  // Step 3: Split the text into individual words\n  List<String> words = text.split(RegExp(r'\\s+')).where((word) => word.isNotEmpty).toList();\n  \n  // Step 4: Count the occurrences of each unique word\n  Map<String, int> wordCount = {};\n  for (String word in words) {\n    wordCount.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n  \n  // Step 5: Create a list of all unique words sorted in alphabetical order\n  List<String> uniqueWords = wordCount.keys.toList()..sort();\n  \n  // Step 6: Calculate the total number of words\n  int totalWords = words.length;\n  \n  // Step 7: Return the results as a map\n  return {\n    'wordCount': wordCount,\n    'uniqueWords': uniqueWords,\n    'totalWords': totalWords,\n  };\n}", "test_cases": "", "test_case_results": "Input: \"Hello, world! Hello Dart!\"\nWord Count: {hello: 2, world: 1, dart: 1}\nUnique Words: [dart, hello, world]\nTotal Words: 4\n---\nInput: \"The quick brown fox jumps over the lazy dog.\"\nWord Count: {the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}\nUnique Words: [brown, dog, fox, jumps, lazy, over, quick, the]\nTotal Words: 9\n---\nInput: \"Flutter is awesome! Awesome is Flutter.\"\nWord Count: {flutter: 2, is: 2, awesome: 2}\nUnique Words: [awesome, flutter, is]\nTotal Words: 6\n---\nInput: \"\"\nWord Count: {}\nUnique Words: []\nTotal Words: 0\n---", "task_id": 5177, "assertions": "import 'dart:math';\n\nvoid testProcessText() {\n  // Test case 1\n  var result1 = processText(\"Hello, world! Hello Dart!\");\n  assert(result1['wordCount'].toString() == '{hello: 2, world: 1, dart: 1}');\n  assert(result1['uniqueWords'].toString() == '[dart, hello, world]');\n  assert(result1['totalWords'] == 4);\n\n  // Test case 2\n  var result2 = processText(\"The quick brown fox jumps over the lazy dog.\");\n  assert(result2['wordCount'].toString() == '{the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}');\n  assert(result2['uniqueWords'].toString() == '[brown, dog, fox, jumps, lazy, over, quick, the]');\n  assert(result2['totalWords'] == 9);\n\n  // Test case 3\n  var result3 = processText(\"Flutter is awesome! Awesome is Flutter.\");\n  assert(result3['wordCount'].toString() == '{flutter: 2, is: 2, awesome: 2}');\n  assert(result3['uniqueWords'].toString() == '[awesome, flutter, is]');\n  assert(result3['totalWords'] == 6);\n\n  // Test case 4 (empty string)\n  var result4 = processText(\"\");\n  assert(result4['wordCount'].toString() == '{}');\n  assert(result4['uniqueWords'].toString() == '[]');\n  assert(result4['totalWords'] == 0);\n}\n\nvoid main() {\n  testProcessText();\n  print('All tests passed!');\n}", "all_code": "import 'dart:math';\n\n// processText processes the given text string and returns a map with word count,\n// sorted unique words, and total number of words.\n//\n// Parameters:\n//   text (String): A string of text to be processed.\n//\n// Returns:\n//   Map<String, dynamic>: A map with keys 'wordCount', 'uniqueWords', and 'totalWords'.\nMap<String, dynamic> processText(String text) {\n  // Step 1: Normalize the text by converting it to lowercase\n  text = text.toLowerCase();\n  \n  // Step 2: Remove all punctuation (replace with spaces to separate words instead of joining)\n  text = text.replaceAll(RegExp(r'[^\\w\\s]'), ' ');\n  \n  // Step 3: Split the text into individual words\n  List<String> words = text.split(RegExp(r'\\s+')).where((word) => word.isNotEmpty).toList();\n  \n  // Step 4: Count the occurrences of each unique word\n  Map<String, int> wordCount = {};\n  for (String word in words) {\n    wordCount.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n  \n  // Step 5: Create a list of all unique words sorted in alphabetical order\n  List<String> uniqueWords = wordCount.keys.toList()..sort();\n  \n  // Step 6: Calculate the total number of words\n  int totalWords = words.length;\n  \n  // Step 7: Return the results as a map\n  return {\n    'wordCount': wordCount,\n    'uniqueWords': uniqueWords,\n    'totalWords': totalWords,\n  };\n}\n\nvoid testProcessText() {\n  // Test case 1\n  var result1 = processText(\"Hello, world! Hello Dart!\");\n  assert(result1['wordCount'].toString() == '{hello: 2, world: 1, dart: 1}');\n  assert(result1['uniqueWords'].toString() == '[dart, hello, world]');\n  assert(result1['totalWords'] == 4);\n\n  // Test case 2\n  var result2 = processText(\"The quick brown fox jumps over the lazy dog.\");\n  assert(result2['wordCount'].toString() == '{the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}');\n  assert(result2['uniqueWords'].toString() == '[brown, dog, fox, jumps, lazy, over, quick, the]');\n  assert(result2['totalWords'] == 9);\n\n  // Test case 3\n  var result3 = processText(\"Flutter is awesome! Awesome is Flutter.\");\n  assert(result3['wordCount'].toString() == '{flutter: 2, is: 2, awesome: 2}');\n  assert(result3['uniqueWords'].toString() == '[awesome, flutter, is]');\n  assert(result3['totalWords'] == 6);\n\n  // Test case 4 (empty string)\n  var result4 = processText(\"\");\n  assert(result4['wordCount'].toString() == '{}');\n  assert(result4['uniqueWords'].toString() == '[]');\n  assert(result4['totalWords'] == 0);\n}\n\nvoid main() {\n  testProcessText();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// countSubsequenceOccurrences counts how many times a subsequence appears\n// within a main sequence as a contiguous segment.\n// \n// Parameters:\n//   mainSequence: List of integers representing the main sequence.\n//   subsequence: List of integers representing the subsequence to find.\n// Returns:\n//   An integer count of how many times the subsequence appears in the main sequence.\nint countSubsequenceOccurrences(List<int> mainSequence, List<int> subsequence) {\n  int n = mainSequence.length;\n  int m = subsequence.length;\n  \n  // If either sequence is empty or subsequence is longer than main sequence,\n  // return 0 as no matches are possible\n  if (n == 0 || m == 0 || m > n) {\n    return 0;\n  }\n  \n  int count = 0;\n  \n  // Check each possible starting position in the main sequence\n  for (int i = 0; i <= n - m; i++) {\n    bool match = true;\n    \n    // Check if the current window matches the subsequence\n    for (int j = 0; j < m; j++) {\n      if (mainSequence[i + j] != subsequence[j]) {\n        match = false;\n        break;\n      }\n    }\n    \n    if (match) {\n      count++;\n    }\n  }\n  \n  return count;\n}", "test_cases": "", "test_case_results": "Main sequence: [1, 2, 3, 4, 1, 2, 3]\nSubsequence: [1, 2, 3]\nOccurrences: 2\n\nMain sequence: [1, 1, 1, 1, 1]\nSubsequence: [1, 1]\nOccurrences: 4\n\nMain sequence: [5, 6, 7, 8, 9]\nSubsequence: [6, 7, 8]\nOccurrences: 1\n\nMain sequence: [1, 2, 3]\nSubsequence: [4, 5, 6]\nOccurrences: 0\n\nMain sequence: []\nSubsequence: [1, 2]\nOccurrences: 0\n\nMain sequence: [1, 2, 3, 4]\nSubsequence: []\nOccurrences: 0\n\nMain sequence: [1, 2, 3, 1, 2, 3, 1, 2, 3]\nSubsequence: [1, 2, 3]\nOccurrences: 3", "task_id": 8034, "assertions": "void testCountSubsequenceOccurrences() {\n  assert(countSubsequenceOccurrences([1, 2, 3, 4, 1, 2, 3], [1, 2, 3]) == 2);\n  assert(countSubsequenceOccurrences([1, 1, 1, 1, 1], [1, 1]) == 4);\n  assert(countSubsequenceOccurrences([5, 6, 7, 8, 9], [6, 7, 8]) == 1);\n  assert(countSubsequenceOccurrences([1, 2, 3], [4, 5, 6]) == 0);\n  assert(countSubsequenceOccurrences([], [1, 2]) == 0);\n  assert(countSubsequenceOccurrences([1, 2, 3, 4], []) == 0);\n  assert(countSubsequenceOccurrences([1, 2, 3, 1, 2, 3, 1, 2, 3], [1, 2, 3]) == 3);\n}\n\nvoid main() {\n  testCountSubsequenceOccurrences();\n  print('All tests passed!');\n}", "all_code": "// countSubsequenceOccurrences counts how many times a subsequence appears\n// within a main sequence as a contiguous segment.\n// \n// Parameters:\n//   mainSequence: List of integers representing the main sequence.\n//   subsequence: List of integers representing the subsequence to find.\n// Returns:\n//   An integer count of how many times the subsequence appears in the main sequence.\nint countSubsequenceOccurrences(List<int> mainSequence, List<int> subsequence) {\n  int n = mainSequence.length;\n  int m = subsequence.length;\n  \n  // If either sequence is empty or subsequence is longer than main sequence,\n  // return 0 as no matches are possible\n  if (n == 0 || m == 0 || m > n) {\n    return 0;\n  }\n  \n  int count = 0;\n  \n  // Check each possible starting position in the main sequence\n  for (int i = 0; i <= n - m; i++) {\n    bool match = true;\n    \n    // Check if the current window matches the subsequence\n    for (int j = 0; j < m; j++) {\n      if (mainSequence[i + j] != subsequence[j]) {\n        match = false;\n        break;\n      }\n    }\n    \n    if (match) {\n      count++;\n    }\n  }\n  \n  return count;\n}\n\nvoid testCountSubsequenceOccurrences() {\n  assert(countSubsequenceOccurrences([1, 2, 3, 4, 1, 2, 3], [1, 2, 3]) == 2);\n  assert(countSubsequenceOccurrences([1, 1, 1, 1, 1], [1, 1]) == 4);\n  assert(countSubsequenceOccurrences([5, 6, 7, 8, 9], [6, 7, 8]) == 1);\n  assert(countSubsequenceOccurrences([1, 2, 3], [4, 5, 6]) == 0);\n  assert(countSubsequenceOccurrences([], [1, 2]) == 0);\n  assert(countSubsequenceOccurrences([1, 2, 3, 4], []) == 0);\n  assert(countSubsequenceOccurrences([1, 2, 3, 1, 2, 3, 1, 2, 3], [1, 2, 3]) == 3);\n}\n\nvoid main() {\n  testCountSubsequenceOccurrences();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// maxNestingDepth calculates the maximum nesting depth of parentheses in a given string.\n// It assumes the input string contains only valid parentheses (balanced and properly nested).\n// The function iterates through each character, tracking the current depth and updating the maximum depth encountered.\nint maxNestingDepth(String s) {\n  int maxDepth = 0;\n  int currentDepth = 0;\n  \n  for (int i = 0; i < s.length; i++) {\n    if (s[i] == '(') {\n      currentDepth++;\n      if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n      }\n    } else if (s[i] == ')') {\n      currentDepth--;\n    }\n  }\n  \n  return maxDepth;\n}", "test_cases": "", "test_case_results": "Input: \"()\"\nMaximum Nesting Depth: 1\nInput: \"()()\"\nMaximum Nesting Depth: 1\nInput: \"(())\"\nMaximum Nesting Depth: 2\nInput: \"(()())\"\nMaximum Nesting Depth: 2\nInput: \"((()))\"\nMaximum Nesting Depth: 3\nInput: \"((()()))()(())\"\nMaximum Nesting Depth: 3\nInput: \"\"\nMaximum Nesting Depth: 0", "task_id": 15926, "assertions": "void testMaxNestingDepth() {\n  assert(maxNestingDepth(\"()\") == 1);\n  assert(maxNestingDepth(\"()()\") == 1);\n  assert(maxNestingDepth(\"(())\") == 2);\n  assert(maxNestingDepth(\"(()())\") == 2);\n  assert(maxNestingDepth(\"((()))\") == 3);\n  assert(maxNestingDepth(\"((()()))()(())\") == 3);\n  assert(maxNestingDepth(\"\") == 0);\n}\n\nvoid main() {\n  testMaxNestingDepth();\n}", "all_code": "// maxNestingDepth calculates the maximum nesting depth of parentheses in a given string.\n// It assumes the input string contains only valid parentheses (balanced and properly nested).\n// The function iterates through each character, tracking the current depth and updating the maximum depth encountered.\nint maxNestingDepth(String s) {\n  int maxDepth = 0;\n  int currentDepth = 0;\n  \n  for (int i = 0; i < s.length; i++) {\n    if (s[i] == '(') {\n      currentDepth++;\n      if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n      }\n    } else if (s[i] == ')') {\n      currentDepth--;\n    }\n  }\n  \n  return maxDepth;\n}\n\nvoid testMaxNestingDepth() {\n  assert(maxNestingDepth(\"()\") == 1);\n  assert(maxNestingDepth(\"()()\") == 1);\n  assert(maxNestingDepth(\"(())\") == 2);\n  assert(maxNestingDepth(\"(()())\") == 2);\n  assert(maxNestingDepth(\"((()))\") == 3);\n  assert(maxNestingDepth(\"((()()))()(())\") == 3);\n  assert(maxNestingDepth(\"\") == 0);\n}\n\nvoid main() {\n  testMaxNestingDepth();\n}", "exec_outcome": "PASSED"}
{"code": "// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// The function recursively applies the Euclidean algorithm until the remainder is zero.\n// If either number is negative, it uses their absolute values for the calculation.\nint gcd(int a, int b) {\n  // Take absolute values to handle negative numbers\n  a = a.abs();\n  b = b.abs();\n  \n  // Base case: when b is 0, the GCD is a\n  if (b == 0) {\n    return a;\n  } \n  // Recursive case: apply Euclidean algorithm\n  else {\n    return gcd(b, a % b);\n  }\n}", "test_cases": "", "test_case_results": "Input: a = 48, b = 18\nGCD: 6\n---\nInput: a = 0, b = 5\nGCD: 5\n---\nInput: a = 5, b = 0\nGCD: 5\n---\nInput: a = 17, b = 23\nGCD: 1\n---\nInput: a = 60, b = 48\nGCD: 12\n---\nInput: a = -36, b = 24\nGCD: 12\n---\nInput: a = 36, b = -24\nGCD: 12\n---\nInput: a = -36, b = -24\nGCD: 12\n---\nInput: a = 0, b = 0\nGCD: 0\n---", "task_id": 22927, "assertions": "void testGCD() {\n  assert(gcd(48, 18) == 6);\n  assert(gcd(0, 5) == 5);\n  assert(gcd(5, 0) == 5);\n  assert(gcd(17, 23) == 1);\n  assert(gcd(60, 48) == 12);\n  assert(gcd(-36, 24) == 12);\n  assert(gcd(36, -24) == 12);\n  assert(gcd(-36, -24) == 12);\n  assert(gcd(0, 0) == 0);\n}\n\nvoid main() {\n  testGCD();\n  print('All tests passed!');\n}", "all_code": "// gcd calculates the greatest common divisor of two integers using the Euclidean algorithm.\n// The function recursively applies the Euclidean algorithm until the remainder is zero.\n// If either number is negative, it uses their absolute values for the calculation.\nint gcd(int a, int b) {\n  // Take absolute values to handle negative numbers\n  a = a.abs();\n  b = b.abs();\n  \n  // Base case: when b is 0, the GCD is a\n  if (b == 0) {\n    return a;\n  } \n  // Recursive case: apply Euclidean algorithm\n  else {\n    return gcd(b, a % b);\n  }\n}\n\nvoid testGCD() {\n  assert(gcd(48, 18) == 6);\n  assert(gcd(0, 5) == 5);\n  assert(gcd(5, 0) == 5);\n  assert(gcd(17, 23) == 1);\n  assert(gcd(60, 48) == 12);\n  assert(gcd(-36, 24) == 12);\n  assert(gcd(36, -24) == 12);\n  assert(gcd(-36, -24) == 12);\n  assert(gcd(0, 0) == 0);\n}\n\nvoid main() {\n  testGCD();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// replaceSubstrings replaces all occurrences of keys in the replacements map\n// with their corresponding values in the given text.\n// \n// Parameters:\n//   text - the input string to process\n//   replacements - a map where keys are substrings to be replaced and values are their replacements\n// Returns:\n//   A new string with all replacements applied\nString replaceSubstrings(String text, Map<String, String> replacements) {\n  String result = text;\n  replacements.forEach((oldStr, newStr) {\n    result = result.replaceAll(oldStr, newStr);\n  });\n  return result;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nOriginal text: Hello world! Welcome to the world of programming.\nReplacements: {world: Dart, programming: coding}\nResult: Hello Dart! Welcome to the Dart of coding.\n\nTest Case 2:\nOriginal text: apple app application\nReplacements: {app: APP, apple: FRUIT, application: SOFTWARE}\nResult: APPle APP APPlication\n\nTest Case 3:\nOriginal text: This text remains unchanged\nReplacements: {foo: bar, baz: qux}\nResult: This text remains unchanged\n\nTest Case 4:\nOriginal text: \nReplacements: {something: nothing}\nResult:", "task_id": 19513, "assertions": "void testReplaceSubstrings() {\n  // Test case 1: Basic replacements\n  assert(replaceSubstrings(\n    \"Hello world! Welcome to the world of programming.\",\n    {\"world\": \"Dart\", \"programming\": \"coding\"}\n  ) == \"Hello Dart! Welcome to the Dart of coding.\");\n\n  // Test case 2: Overlapping replacements\n  assert(replaceSubstrings(\n    \"apple app application\",\n    {\"app\": \"APP\", \"apple\": \"FRUIT\", \"application\": \"SOFTWARE\"}\n  ) == \"APPle APP APPlication\");\n\n  // Test case 3: No replacements\n  assert(replaceSubstrings(\n    \"This text remains unchanged\",\n    {\"foo\": \"bar\", \"baz\": \"qux\"}\n  ) == \"This text remains unchanged\");\n\n  // Test case 4: Empty string\n  assert(replaceSubstrings(\n    \"\",\n    {\"something\": \"nothing\"}\n  ) == \"\");\n}\n\nvoid main() {\n  testReplaceSubstrings();\n  print(\"All tests passed!\");\n}", "all_code": "// replaceSubstrings replaces all occurrences of keys in the replacements map\n// with their corresponding values in the given text.\n// \n// Parameters:\n//   text - the input string to process\n//   replacements - a map where keys are substrings to be replaced and values are their replacements\n// Returns:\n//   A new string with all replacements applied\nString replaceSubstrings(String text, Map<String, String> replacements) {\n  String result = text;\n  replacements.forEach((oldStr, newStr) {\n    result = result.replaceAll(oldStr, newStr);\n  });\n  return result;\n}\n\nvoid testReplaceSubstrings() {\n  // Test case 1: Basic replacements\n  assert(replaceSubstrings(\n    \"Hello world! Welcome to the world of programming.\",\n    {\"world\": \"Dart\", \"programming\": \"coding\"}\n  ) == \"Hello Dart! Welcome to the Dart of coding.\");\n\n  // Test case 2: Overlapping replacements\n  assert(replaceSubstrings(\n    \"apple app application\",\n    {\"app\": \"APP\", \"apple\": \"FRUIT\", \"application\": \"SOFTWARE\"}\n  ) == \"APPle APP APPlication\");\n\n  // Test case 3: No replacements\n  assert(replaceSubstrings(\n    \"This text remains unchanged\",\n    {\"foo\": \"bar\", \"baz\": \"qux\"}\n  ) == \"This text remains unchanged\");\n\n  // Test case 4: Empty string\n  assert(replaceSubstrings(\n    \"\",\n    {\"something\": \"nothing\"}\n  ) == \"\");\n}\n\nvoid main() {\n  testReplaceSubstrings();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// binaryToHexStr converts a binary string to its equivalent hexadecimal string prefixed with '0x'.\n// If the input string is \"0\", it returns \"0x0\".\n// For other valid binary strings, it converts them to their hexadecimal representation.\nString binaryToHexStr(String binaryStr) {\n  if (binaryStr == \"0\") {\n    return \"0x0\";\n  }\n\n  // Convert binary string to integer\n  int decimalValue = int.parse(binaryStr, radix: 2);\n  // Convert integer to hexadecimal string and prefix with '0x'\n  String hexValue = \"0x${decimalValue.toRadixString(16)}\";\n  return hexValue;\n}", "test_cases": "", "test_case_results": "Input: \"0\"\nHex: 0x0\n---\nInput: \"1\"\nHex: 0x1\n---\nInput: \"1010\"\nHex: 0xa\n---\nInput: \"1111\"\nHex: 0xf\n---\nInput: \"10000000\"\nHex: 0x80\n---\nInput: \"10101010\"\nHex: 0xaa\n---\nInput: \"11111111\"\nHex: 0xff\n---", "task_id": 19853, "assertions": "void testBinaryToHexStr() {\n  assert(binaryToHexStr(\"0\") == \"0x0\");\n  assert(binaryToHexStr(\"1\") == \"0x1\");\n  assert(binaryToHexStr(\"1010\") == \"0xa\");\n  assert(binaryToHexStr(\"1111\") == \"0xf\");\n  assert(binaryToHexStr(\"10000000\") == \"0x80\");\n  assert(binaryToHexStr(\"10101010\") == \"0xaa\");\n  assert(binaryToHexStr(\"11111111\") == \"0xff\");\n}\n\nvoid main() {\n  testBinaryToHexStr();\n}", "all_code": "// binaryToHexStr converts a binary string to its equivalent hexadecimal string prefixed with '0x'.\n// If the input string is \"0\", it returns \"0x0\".\n// For other valid binary strings, it converts them to their hexadecimal representation.\nString binaryToHexStr(String binaryStr) {\n  if (binaryStr == \"0\") {\n    return \"0x0\";\n  }\n\n  // Convert binary string to integer\n  int decimalValue = int.parse(binaryStr, radix: 2);\n  // Convert integer to hexadecimal string and prefix with '0x'\n  String hexValue = \"0x${decimalValue.toRadixString(16)}\";\n  return hexValue;\n}\n\nvoid testBinaryToHexStr() {\n  assert(binaryToHexStr(\"0\") == \"0x0\");\n  assert(binaryToHexStr(\"1\") == \"0x1\");\n  assert(binaryToHexStr(\"1010\") == \"0xa\");\n  assert(binaryToHexStr(\"1111\") == \"0xf\");\n  assert(binaryToHexStr(\"10000000\") == \"0x80\");\n  assert(binaryToHexStr(\"10101010\") == \"0xaa\");\n  assert(binaryToHexStr(\"11111111\") == \"0xff\");\n}\n\nvoid main() {\n  testBinaryToHexStr();\n}", "exec_outcome": "PASSED"}
{"code": "// countUniqueIntegers calculates the number of unique integers in a list.\n// It converts the list to a Set to automatically remove duplicates,\n// then returns the size of the Set which represents the count of unique integers.\nint countUniqueIntegers(List<int> arr) {\n  return arr.toSet().length;\n}", "test_cases": "", "test_case_results": "Input: [1, 2, 3, 4]\nUnique count: 4\n---\nInput: [1, 1, 2, 2, 3, 3]\nUnique count: 3\n---\nInput: []\nUnique count: 0\n---\nInput: [5, 5, 5, 5]\nUnique count: 1\n---\nInput: [1, 2, 3, 4, 1, 2]\nUnique count: 4\n---", "task_id": 27698, "assertions": "void testCountUniqueIntegers() {\n  assert(countUniqueIntegers([1, 2, 3, 4]) == 4);\n  assert(countUniqueIntegers([1, 1, 2, 2, 3, 3]) == 3);\n  assert(countUniqueIntegers([]) == 0);\n  assert(countUniqueIntegers([5, 5, 5, 5]) == 1);\n  assert(countUniqueIntegers([1, 2, 3, 4, 1, 2]) == 4);\n}\n\nvoid main() {\n  testCountUniqueIntegers();\n}", "all_code": "// countUniqueIntegers calculates the number of unique integers in a list.\n// It converts the list to a Set to automatically remove duplicates,\n// then returns the size of the Set which represents the count of unique integers.\nint countUniqueIntegers(List<int> arr) {\n  return arr.toSet().length;\n}\n\nvoid testCountUniqueIntegers() {\n  assert(countUniqueIntegers([1, 2, 3, 4]) == 4);\n  assert(countUniqueIntegers([1, 1, 2, 2, 3, 3]) == 3);\n  assert(countUniqueIntegers([]) == 0);\n  assert(countUniqueIntegers([5, 5, 5, 5]) == 1);\n  assert(countUniqueIntegers([1, 2, 3, 4, 1, 2]) == 4);\n}\n\nvoid main() {\n  testCountUniqueIntegers();\n}", "exec_outcome": "PASSED"}
{"code": "// findPeakCells identifies all peak cells in a 2D grid.\n// A peak cell is defined as a cell whose value is strictly greater than all its adjacent cells\n// (top, bottom, left, right). The function returns the coordinates of these peaks in lexicographical order.\nList<List<int>> findPeakCells(int m, int n, List<List<int>> grid) {\n  // Helper function to check if a cell is a peak\n  bool isPeak(int i, int j) {\n    // Check top neighbor\n    if (i > 0 && grid[i][j] <= grid[i - 1][j]) {\n      return false;\n    }\n    // Check bottom neighbor\n    if (i < m - 1 && grid[i][j] <= grid[i + 1][j]) {\n      return false;\n    }\n    // Check left neighbor\n    if (j > 0 && grid[i][j] <= grid[i][j - 1]) {\n      return false;\n    }\n    // Check right neighbor\n    if (j < n - 1 && grid[i][j] <= grid[i][j + 1]) {\n      return false;\n    }\n    return true;\n  }\n\n  List<List<int>> peakCells = [];\n  \n  // Iterate through each cell in the grid\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (isPeak(i, j)) {\n        peakCells.add([i, j]);\n      }\n    }\n  }\n  \n  // Sort the peaks in lexicographical order\n  peakCells.sort((a, b) {\n    if (a[0] != b[0]) {\n      return a[0].compareTo(b[0]);\n    }\n    return a[1].compareTo(b[1]);\n  });\n  \n  return peakCells;\n}", "test_cases": "", "test_case_results": "Input grid (3x3):\n[1, 4, 3]\n[3, 2, 1]\n[5, 6, 2]\nPeak cells: [[0, 1], [2, 1]]\n\nInput grid (2x2):\n[1, 1]\n[1, 1]\nPeak cells: []\n\nInput grid (4x3):\n[10, 20, 15]\n[21, 30, 14]\n[7, 16, 32]\n[1, 2, 3]\nPeak cells: [[1, 1], [2, 2]]\n\nInput grid (1x1):\n[5]\nPeak cells: [[0, 0]]", "task_id": 2459, "assertions": "void testFindPeakCells() {\n  // Test case 1\n  assert(\n    findPeakCells(3, 3, [\n      [1, 4, 3],\n      [3, 2, 1],\n      [5, 6, 2],\n    ]).toString() == '[[0, 1], [2, 1]]',\n  );\n\n  // Test case 2\n  assert(\n    findPeakCells(2, 2, [\n      [1, 1],\n      [1, 1],\n    ]).toString() == '[]',\n  );\n\n  // Test case 3\n  assert(\n    findPeakCells(4, 3, [\n      [10, 20, 15],\n      [21, 30, 14],\n      [7, 16, 32],\n      [1, 2, 3],\n    ]).toString() == '[[1, 1], [2, 2]]',\n  );\n\n  // Test case 4\n  assert(\n    findPeakCells(1, 1, [\n      [5],\n    ]).toString() == '[[0, 0]]',\n  );\n}\n\nvoid main() {\n  testFindPeakCells();\n  print('All tests passed!');\n}", "all_code": "// findPeakCells identifies all peak cells in a 2D grid.\n// A peak cell is defined as a cell whose value is strictly greater than all its adjacent cells\n// (top, bottom, left, right). The function returns the coordinates of these peaks in lexicographical order.\nList<List<int>> findPeakCells(int m, int n, List<List<int>> grid) {\n  // Helper function to check if a cell is a peak\n  bool isPeak(int i, int j) {\n    // Check top neighbor\n    if (i > 0 && grid[i][j] <= grid[i - 1][j]) {\n      return false;\n    }\n    // Check bottom neighbor\n    if (i < m - 1 && grid[i][j] <= grid[i + 1][j]) {\n      return false;\n    }\n    // Check left neighbor\n    if (j > 0 && grid[i][j] <= grid[i][j - 1]) {\n      return false;\n    }\n    // Check right neighbor\n    if (j < n - 1 && grid[i][j] <= grid[i][j + 1]) {\n      return false;\n    }\n    return true;\n  }\n\n  List<List<int>> peakCells = [];\n  \n  // Iterate through each cell in the grid\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (isPeak(i, j)) {\n        peakCells.add([i, j]);\n      }\n    }\n  }\n  \n  // Sort the peaks in lexicographical order\n  peakCells.sort((a, b) {\n    if (a[0] != b[0]) {\n      return a[0].compareTo(b[0]);\n    }\n    return a[1].compareTo(b[1]);\n  });\n  \n  return peakCells;\n}\n\nvoid testFindPeakCells() {\n  // Test case 1\n  assert(\n    findPeakCells(3, 3, [\n      [1, 4, 3],\n      [3, 2, 1],\n      [5, 6, 2],\n    ]).toString() == '[[0, 1], [2, 1]]',\n  );\n\n  // Test case 2\n  assert(\n    findPeakCells(2, 2, [\n      [1, 1],\n      [1, 1],\n    ]).toString() == '[]',\n  );\n\n  // Test case 3\n  assert(\n    findPeakCells(4, 3, [\n      [10, 20, 15],\n      [21, 30, 14],\n      [7, 16, 32],\n      [1, 2, 3],\n    ]).toString() == '[[1, 1], [2, 2]]',\n  );\n\n  // Test case 4\n  assert(\n    findPeakCells(1, 1, [\n      [5],\n    ]).toString() == '[[0, 0]]',\n  );\n}\n\nvoid main() {\n  testFindPeakCells();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n/// updateMatrix calculates the distance of each cell to the nearest 0 in the given matrix.\n/// It uses a breadth-first search (BFS) approach starting from all 0 cells simultaneously.\n/// The function returns a new matrix with the same dimensions where each cell contains\n/// the minimum distance to the nearest 0 from the original matrix.\nList<List<int>> updateMatrix(List<List<int>> mat) {\n  if (mat.isEmpty || mat[0].isEmpty) {\n    return [];\n  }\n\n  int m = mat.length;\n  int n = mat[0].length;\n  List<List<int>> dist = List.generate(m, (_) => List.filled(n, 0x7FFFFFFF));\n  Queue<List<int>> queue = Queue();\n\n  // Initialize the queue with all 0 positions and set their distance to 0\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (mat[i][j] == 0) {\n        dist[i][j] = 0;\n        queue.add([i, j]);\n      }\n    }\n  }\n\n  // Define the four possible movement directions (up, down, left, right)\n  List<List<int>> directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1]\n  ];\n\n  // Process the queue using BFS\n  while (queue.isNotEmpty) {\n    List<int> cell = queue.removeFirst();\n    int x = cell[0], y = cell[1];\n\n    for (List<int> dir in directions) {\n      int xi = x + dir[0];\n      int yi = y + dir[1];\n\n      // Check if the new position is within bounds\n      if (xi >= 0 && xi < m && yi >= 0 && yi < n) {\n        // Update the distance if a shorter path is found\n        if (dist[xi][yi] > dist[x][y] + 1) {\n          dist[xi][yi] = dist[x][y] + 1;\n          queue.add([xi, yi]);\n        }\n      }\n    }\n  }\n\n  return dist;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Matrix:\n[0, 0, 0]\n[0, 1, 0]\n[0, 0, 0]\n\nDistance Matrix:\n[0, 0, 0]\n[0, 1, 0]\n[0, 0, 0]\n\nTest Case 2:\nInput Matrix:\n[0, 0, 0]\n[0, 1, 0]\n[1, 1, 1]\n\nDistance Matrix:\n[0, 0, 0]\n[0, 1, 0]\n[1, 2, 1]\n\nTest Case 3:\nInput Matrix:\n[1, 1, 1]\n[1, 1, 1]\n[1, 0, 1]\n\nDistance Matrix:\n[3, 2, 3]\n[2, 1, 2]\n[1, 0, 1]\n\nTest Case 4:\nInput Matrix:\n[1, 0, 1, 1, 0]\n[1, 1, 1, 1, 1]\n[1, 1, 1, 1, 1]\n[0, 0, 1, 0, 0]\n\nDistance Matrix:\n[1, 0, 1, 1, 0]\n[2, 1, 2, 2, 1]\n[1, 1, 2, 1, 1]\n[0, 0, 1, 0, 0]", "task_id": 16934, "assertions": "import 'dart:collection';\n\nvoid testUpdateMatrix() {\n  // Test Case 1\n  assert(updateMatrix([\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n  ]) == [\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n  ]);\n\n  // Test Case 2\n  assert(updateMatrix([\n    [0, 0, 0],\n    [0, 1, 0],\n    [1, 1, 1]\n  ]) == [\n    [0, 0, 0],\n    [0, 1, 0],\n    [1, 2, 1]\n  ]);\n\n  // Test Case 3\n  assert(updateMatrix([\n    [1, 1, 1],\n    [1, 1, 1],\n    [1, 0, 1]\n  ]) == [\n    [3, 2, 3],\n    [2, 1, 2],\n    [1, 0, 1]\n  ]);\n\n  // Test Case 4\n  assert(updateMatrix([\n    [1, 0, 1, 1, 0],\n    [1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [0, 0, 1, 0, 0]\n  ]) == [\n    [1, 0, 1, 1, 0],\n    [2, 1, 2, 2, 1],\n    [1, 1, 2, 1, 1],\n    [0, 0, 1, 0, 0]\n  ]);\n}\n\nvoid main() {\n  testUpdateMatrix();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n/// updateMatrix calculates the distance of each cell to the nearest 0 in the given matrix.\n/// It uses a breadth-first search (BFS) approach starting from all 0 cells simultaneously.\n/// The function returns a new matrix with the same dimensions where each cell contains\n/// the minimum distance to the nearest 0 from the original matrix.\nList<List<int>> updateMatrix(List<List<int>> mat) {\n  if (mat.isEmpty || mat[0].isEmpty) {\n    return [];\n  }\n\n  int m = mat.length;\n  int n = mat[0].length;\n  List<List<int>> dist = List.generate(m, (_) => List.filled(n, 0x7FFFFFFF));\n  Queue<List<int>> queue = Queue();\n\n  // Initialize the queue with all 0 positions and set their distance to 0\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j < n; j++) {\n      if (mat[i][j] == 0) {\n        dist[i][j] = 0;\n        queue.add([i, j]);\n      }\n    }\n  }\n\n  // Define the four possible movement directions (up, down, left, right)\n  List<List<int>> directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1]\n  ];\n\n  // Process the queue using BFS\n  while (queue.isNotEmpty) {\n    List<int> cell = queue.removeFirst();\n    int x = cell[0], y = cell[1];\n\n    for (List<int> dir in directions) {\n      int xi = x + dir[0];\n      int yi = y + dir[1];\n\n      // Check if the new position is within bounds\n      if (xi >= 0 && xi < m && yi >= 0 && yi < n) {\n        // Update the distance if a shorter path is found\n        if (dist[xi][yi] > dist[x][y] + 1) {\n          dist[xi][yi] = dist[x][y] + 1;\n          queue.add([xi, yi]);\n        }\n      }\n    }\n  }\n\n  return dist;\n}\n\nvoid testUpdateMatrix() {\n  // Test Case 1\n  assert(updateMatrix([\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n  ]) == [\n    [0, 0, 0],\n    [0, 1, 0],\n    [0, 0, 0]\n  ]);\n\n  // Test Case 2\n  assert(updateMatrix([\n    [0, 0, 0],\n    [0, 1, 0],\n    [1, 1, 1]\n  ]) == [\n    [0, 0, 0],\n    [0, 1, 0],\n    [1, 2, 1]\n  ]);\n\n  // Test Case 3\n  assert(updateMatrix([\n    [1, 1, 1],\n    [1, 1, 1],\n    [1, 0, 1]\n  ]) == [\n    [3, 2, 3],\n    [2, 1, 2],\n    [1, 0, 1]\n  ]);\n\n  // Test Case 4\n  assert(updateMatrix([\n    [1, 0, 1, 1, 0],\n    [1, 1, 1, 1, 1],\n    [1, 1, 1, 1, 1],\n    [0, 0, 1, 0, 0]\n  ]) == [\n    [1, 0, 1, 1, 0],\n    [2, 1, 2, 2, 1],\n    [1, 1, 2, 1, 1],\n    [0, 0, 1, 0, 0]\n  ]);\n}\n\nvoid main() {\n  testUpdateMatrix();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// minOperationsToTransform calculates the minimum number of operations needed to transform string S into string T.\n// The operations allowed are:\n// 1. Cyclic shift of the entire string (counts as 1 operation)\n// 2. Swapping any two characters (counts as 1 operation per swap)\n// Returns -1 if the transformation is not possible due to character mismatch.\nint minOperationsToTransform(int N, String T, String S) {\n  // First check if both strings have the same characters (same frequency of each character)\n  if (!_haveSameCharacters(T, S)) {\n    return -1;\n  }\n\n  // Check if a single cyclic shift can transform T into S\n  for (int i = 0; i < N; i++) {\n    String shifted = T.substring(i) + T.substring(0, i);\n    if (shifted == S) {\n      return 1;\n    }\n  }\n\n  // If no single cyclic shift works, return 2 as per the problem's examples\n  return 2;\n}\n\n// Helper function to check if two strings have the same characters with the same frequencies\nbool _haveSameCharacters(String a, String b) {\n  if (a.length != b.length) return false;\n\n  Map<String, int> charCount = {};\n\n  // Count characters in string a\n  for (int i = 0; i < a.length; i++) {\n    String char = a[i];\n    charCount[char] = (charCount[char] ?? 0) + 1;\n  }\n\n  // Subtract counts using string b\n  for (int i = 0; i < b.length; i++) {\n    String char = b[i];\n    if (!charCount.containsKey(char) || charCount[char] == 0) {\n      return false;\n    }\n    charCount[char] = charCount[char]! - 1;\n  }\n\n  return true;\n}", "test_cases": "", "test_case_results": "Test Case:\nN: 3, T: \"abc\", S: \"cab\"\nMinimum operations: 1\n---\nTest Case:\nN: 4, T: \"abcd\", S: \"dabc\"\nMinimum operations: 1\n---\nTest Case:\nN: 3, T: \"abc\", S: \"bac\"\nMinimum operations: 2\n---\nTest Case:\nN: 3, T: \"abc\", S: \"def\"\nMinimum operations: -1\n---\nTest Case:\nN: 5, T: \"aabbb\", S: \"bbbaa\"\nMinimum operations: 1\n---\nTest Case:\nN: 4, T: \"abcd\", S: \"badc\"\nMinimum operations: 2\n---", "task_id": 25957, "assertions": "void testMinOperationsToTransform() {\n  assert(minOperationsToTransform(3, 'abc', 'cab') == 1);\n  assert(minOperationsToTransform(4, 'abcd', 'dabc') == 1);\n  assert(minOperationsToTransform(3, 'abc', 'bac') == 2);\n  assert(minOperationsToTransform(3, 'abc', 'def') == -1);\n  assert(minOperationsToTransform(5, 'aabbb', 'bbbaa') == 1);\n  assert(minOperationsToTransform(4, 'abcd', 'badc') == 2);\n}\n\nvoid main() {\n  testMinOperationsToTransform();\n  print('All tests passed!');\n}", "all_code": "// minOperationsToTransform calculates the minimum number of operations needed to transform string S into string T.\n// The operations allowed are:\n// 1. Cyclic shift of the entire string (counts as 1 operation)\n// 2. Swapping any two characters (counts as 1 operation per swap)\n// Returns -1 if the transformation is not possible due to character mismatch.\nint minOperationsToTransform(int N, String T, String S) {\n  // First check if both strings have the same characters (same frequency of each character)\n  if (!_haveSameCharacters(T, S)) {\n    return -1;\n  }\n\n  // Check if a single cyclic shift can transform T into S\n  for (int i = 0; i < N; i++) {\n    String shifted = T.substring(i) + T.substring(0, i);\n    if (shifted == S) {\n      return 1;\n    }\n  }\n\n  // If no single cyclic shift works, return 2 as per the problem's examples\n  return 2;\n}\n\n// Helper function to check if two strings have the same characters with the same frequencies\nbool _haveSameCharacters(String a, String b) {\n  if (a.length != b.length) return false;\n\n  Map<String, int> charCount = {};\n\n  // Count characters in string a\n  for (int i = 0; i < a.length; i++) {\n    String char = a[i];\n    charCount[char] = (charCount[char] ?? 0) + 1;\n  }\n\n  // Subtract counts using string b\n  for (int i = 0; i < b.length; i++) {\n    String char = b[i];\n    if (!charCount.containsKey(char) || charCount[char] == 0) {\n      return false;\n    }\n    charCount[char] = charCount[char]! - 1;\n  }\n\n  return true;\n}\n\nvoid testMinOperationsToTransform() {\n  assert(minOperationsToTransform(3, 'abc', 'cab') == 1);\n  assert(minOperationsToTransform(4, 'abcd', 'dabc') == 1);\n  assert(minOperationsToTransform(3, 'abc', 'bac') == 2);\n  assert(minOperationsToTransform(3, 'abc', 'def') == -1);\n  assert(minOperationsToTransform(5, 'aabbb', 'bbbaa') == 1);\n  assert(minOperationsToTransform(4, 'abcd', 'badc') == 2);\n}\n\nvoid main() {\n  testMinOperationsToTransform();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// filterWordsByLength filters words from a given string that are longer than a specified length.\n// It splits the input string into words and checks each word's length against the threshold.\n// Returns a list of words that meet the length criteria.\nList<String> filterWordsByLength(String s, int n) {\n  List<String> words = s.split(' ');\n  List<String> filteredWords = [];\n  for (String word in words) {\n    if (word.length > n) {\n      filteredWords.add(word);\n    }\n  }\n  return filteredWords;\n}", "test_cases": "", "test_case_results": "Input: \"Hello world this is a test\", Threshold: 3\nFiltered Words: [Hello, world, this, test]\nInput: \"Dart is a great language\", Threshold: 4\nFiltered Words: [great, language]\nInput: \"Short words only\", Threshold: 5\nFiltered Words: []", "task_id": 14816, "assertions": "void testFilterWordsByLength() {\n  assert(filterWordsByLength('Hello world this is a test', 3).toString() == \n      '[Hello, world, this, test]');\n  assert(filterWordsByLength('Dart is a great language', 4).toString() == \n      '[great, language]');\n  assert(filterWordsByLength('Short words only', 5).toString() == '[]');\n}\n\nvoid main() {\n  testFilterWordsByLength();\n}", "all_code": "// filterWordsByLength filters words from a given string that are longer than a specified length.\n// It splits the input string into words and checks each word's length against the threshold.\n// Returns a list of words that meet the length criteria.\nList<String> filterWordsByLength(String s, int n) {\n  List<String> words = s.split(' ');\n  List<String> filteredWords = [];\n  for (String word in words) {\n    if (word.length > n) {\n      filteredWords.add(word);\n    }\n  }\n  return filteredWords;\n}\n\nvoid testFilterWordsByLength() {\n  assert(filterWordsByLength('Hello world this is a test', 3).toString() == \n      '[Hello, world, this, test]');\n  assert(filterWordsByLength('Dart is a great language', 4).toString() == \n      '[great, language]');\n  assert(filterWordsByLength('Short words only', 5).toString() == '[]');\n}\n\nvoid main() {\n  testFilterWordsByLength();\n}", "exec_outcome": "PASSED"}
{"code": "// findMultiplesInList returns all numbers in the given list that are multiples of a specified number.\n// It filters the input list to only include numbers that are divisible by 'multipleOf' with no remainder.\nList<int> findMultiplesInList(List<int> numbersList, int multipleOf) {\n  return numbersList.where((num) => num % multipleOf == 0).toList();\n}\n\n// findMultiplesInRange returns all multiples of a specified number within a specified range [start, end].\n// It generates numbers from start to end (inclusive) and includes those divisible by 'multipleOf' with no remainder.\nList<int> findMultiplesInRange(int start, int end, int multipleOf) {\n  List<int> result = [];\n  for (int num = start; num <= end; num++) {\n    if (num % multipleOf == 0) {\n      result.add(num);\n    }\n  }\n  return result;\n}", "test_cases": "", "test_case_results": "Testing findMultiplesInList:\n\nInput list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Multiple of: 2\nMultiples found: [2, 4, 6, 8, 10]\n\nInput list: [15, 20, 25, 30, 35, 40], Multiple of: 5\nMultiples found: [15, 20, 25, 30, 35, 40]\n\nInput list: [3, 6, 9, 12, 15, 18], Multiple of: 3\nMultiples found: [3, 6, 9, 12, 15, 18]\n\nInput list: [7, 14, 21, 28, 35], Multiple of: 7\nMultiples found: [7, 14, 21, 28, 35]\n\nTesting findMultiplesInRange:\n\nRange: 1-10, Multiple of: 2\nMultiples found: [2, 4, 6, 8, 10]\n\nRange: 15-40, Multiple of: 5\nMultiples found: [15, 20, 25, 30, 35, 40]\n\nRange: 3-18, Multiple of: 3\nMultiples found: [3, 6, 9, 12, 15, 18]\n\nRange: 7-35, Multiple of: 7\nMultiples found: [7, 14, 21, 28, 35]", "task_id": 18731, "assertions": "void testMultiplesFunctions() {\n  // Test cases for findMultiplesInList\n  assert(findMultiplesInList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [2, 4, 6, 8, 10]);\n  assert(findMultiplesInList([15, 20, 25, 30, 35, 40], 5) == [15, 20, 25, 30, 35, 40]);\n  assert(findMultiplesInList([3, 6, 9, 12, 15, 18], 3) == [3, 6, 9, 12, 15, 18]);\n  assert(findMultiplesInList([7, 14, 21, 28, 35], 7) == [7, 14, 21, 28, 35]);\n\n  // Test cases for findMultiplesInRange\n  assert(findMultiplesInRange(1, 10, 2) == [2, 4, 6, 8, 10]);\n  assert(findMultiplesInRange(15, 40, 5) == [15, 20, 25, 30, 35, 40]);\n  assert(findMultiplesInRange(3, 18, 3) == [3, 6, 9, 12, 15, 18]);\n  assert(findMultiplesInRange(7, 35, 7) == [7, 14, 21, 28, 35]);\n}\n\nvoid main() {\n  testMultiplesFunctions();\n  print('All tests passed!');\n}", "all_code": "// findMultiplesInList returns all numbers in the given list that are multiples of a specified number.\n// It filters the input list to only include numbers that are divisible by 'multipleOf' with no remainder.\nList<int> findMultiplesInList(List<int> numbersList, int multipleOf) {\n  return numbersList.where((num) => num % multipleOf == 0).toList();\n}\n\n// findMultiplesInRange returns all multiples of a specified number within a specified range [start, end].\n// It generates numbers from start to end (inclusive) and includes those divisible by 'multipleOf' with no remainder.\nList<int> findMultiplesInRange(int start, int end, int multipleOf) {\n  List<int> result = [];\n  for (int num = start; num <= end; num++) {\n    if (num % multipleOf == 0) {\n      result.add(num);\n    }\n  }\n  return result;\n}\n\nvoid testMultiplesFunctions() {\n  // Test cases for findMultiplesInList\n  assert(findMultiplesInList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2) == [2, 4, 6, 8, 10]);\n  assert(findMultiplesInList([15, 20, 25, 30, 35, 40], 5) == [15, 20, 25, 30, 35, 40]);\n  assert(findMultiplesInList([3, 6, 9, 12, 15, 18], 3) == [3, 6, 9, 12, 15, 18]);\n  assert(findMultiplesInList([7, 14, 21, 28, 35], 7) == [7, 14, 21, 28, 35]);\n\n  // Test cases for findMultiplesInRange\n  assert(findMultiplesInRange(1, 10, 2) == [2, 4, 6, 8, 10]);\n  assert(findMultiplesInRange(15, 40, 5) == [15, 20, 25, 30, 35, 40]);\n  assert(findMultiplesInRange(3, 18, 3) == [3, 6, 9, 12, 15, 18]);\n  assert(findMultiplesInRange(7, 35, 7) == [7, 14, 21, 28, 35]);\n}\n\nvoid main() {\n  testMultiplesFunctions();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// maxOperationsToAvoidAdjacentOnes calculates the maximum number of bit flip operations required\n// to ensure that no two '1's are adjacent in the given binary string.\n// It traverses the string and counts operations needed to flip every second '1' in a sequence.\nint maxOperationsToAvoidAdjacentOnes(String binaryString) {\n  int operations = 0;\n  int n = binaryString.length;\n  int i = 0;\n  \n  // Traverse the binary string\n  while (i < n) {\n    // If current character is '1' and next character is '1', we have to flip one of them\n    if (i + 1 < n && binaryString[i] == '1' && binaryString[i + 1] == '1') {\n      operations += 1;\n      // Skip the next character to avoid consecutive '1's\n      i += 2;\n    } else {\n      i += 1;\n    }\n  }\n  \n  return operations;\n}", "test_cases": "", "test_case_results": "Input: \"1101\"\nOperations needed: 1\n---\nInput: \"1111\"\nOperations needed: 2\n---\nInput: \"1010\"\nOperations needed: 0\n---\nInput: \"0000\"\nOperations needed: 0\n---\nInput: \"1110111\"\nOperations needed: 2\n---\nInput: \"1\"\nOperations needed: 0\n---\nInput: \"0\"\nOperations needed: 0\n---\nInput: \"110011001\"\nOperations needed: 2\n---", "task_id": 5492, "assertions": "void testMaxOperationsToAvoidAdjacentOnes() {\n  assert(maxOperationsToAvoidAdjacentOnes('1101') == 1);\n  assert(maxOperationsToAvoidAdjacentOnes('1111') == 2);\n  assert(maxOperationsToAvoidAdjacentOnes('1010') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('0000') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('1110111') == 2);\n  assert(maxOperationsToAvoidAdjacentOnes('1') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('0') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('110011001') == 2);\n}\n\nvoid main() {\n  testMaxOperationsToAvoidAdjacentOnes();\n}", "all_code": "// maxOperationsToAvoidAdjacentOnes calculates the maximum number of bit flip operations required\n// to ensure that no two '1's are adjacent in the given binary string.\n// It traverses the string and counts operations needed to flip every second '1' in a sequence.\nint maxOperationsToAvoidAdjacentOnes(String binaryString) {\n  int operations = 0;\n  int n = binaryString.length;\n  int i = 0;\n  \n  // Traverse the binary string\n  while (i < n) {\n    // If current character is '1' and next character is '1', we have to flip one of them\n    if (i + 1 < n && binaryString[i] == '1' && binaryString[i + 1] == '1') {\n      operations += 1;\n      // Skip the next character to avoid consecutive '1's\n      i += 2;\n    } else {\n      i += 1;\n    }\n  }\n  \n  return operations;\n}\n\nvoid testMaxOperationsToAvoidAdjacentOnes() {\n  assert(maxOperationsToAvoidAdjacentOnes('1101') == 1);\n  assert(maxOperationsToAvoidAdjacentOnes('1111') == 2);\n  assert(maxOperationsToAvoidAdjacentOnes('1010') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('0000') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('1110111') == 2);\n  assert(maxOperationsToAvoidAdjacentOnes('1') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('0') == 0);\n  assert(maxOperationsToAvoidAdjacentOnes('110011001') == 2);\n}\n\nvoid main() {\n  testMaxOperationsToAvoidAdjacentOnes();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:math';\n\n// Finds the nearest neighbor to the target point using brute force approach.\n// Returns null if the points list is empty.\nList<double>? bruteForceNearest(List<List<double>> points, List<double> target) {\n  if (points.isEmpty) {\n    return null;\n  }\n\n  double minDistance = double.infinity;\n  List<double>? nearestPoint;\n\n  for (var point in points) {\n    double distance = _calculateDistance(point, target);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestPoint = point;\n    }\n  }\n\n  return nearestPoint;\n}\n\n// KD-Tree Node class to store points and child nodes\nclass KDTreeNode {\n  final List<double> point;\n  final KDTreeNode? left;\n  final KDTreeNode? right;\n\n  KDTreeNode({required this.point, this.left, this.right});\n}\n\n// Finds the nearest neighbor to the target point using KD-Tree approach.\n// Returns null if the points list is empty.\nList<double>? kdTreeNearest(List<List<double>> points, List<double> target) {\n  if (points.isEmpty) {\n    return null;\n  }\n\n  // Builds a KD-Tree from the given points\n  KDTreeNode buildKdTree(List<List<double>> points, [int depth = 0]) {\n    if (points.isEmpty) {\n      throw StateError(\"Empty points list in buildKdTree\");\n    }\n\n    int k = points[0].length; // Assumes all points have the same dimension\n    int axis = depth % k;\n\n    // Sort points based on current axis\n    points.sort((a, b) => a[axis].compareTo(b[axis]));\n    int median = points.length ~/ 2;\n\n    return KDTreeNode(\n      point: points[median],\n      left: median > 0 ? buildKdTree(points.sublist(0, median), depth + 1) : null,\n      right: median + 1 < points.length\n          ? buildKdTree(points.sublist(median + 1), depth + 1)\n          : null,\n    );\n  }\n\n  // Recursive helper function to find nearest neighbor in KD-Tree\n  (List<double>, double) kdTreeNearestRec(KDTreeNode? node, List<double> target,\n      [int depth = 0,\n      List<double>? bestNode,\n      double bestDist = double.infinity]) {\n    if (node == null) {\n      return (bestNode ?? [], bestDist);\n    }\n\n    int k = target.length;\n    int axis = depth % k;\n    List<double> point = node.point;\n\n    double d = _calculateDistance(point, target);\n    if (d < bestDist) {\n      bestDist = d;\n      bestNode = point;\n    }\n\n    double diff = target[axis] - point[axis];\n\n    if (diff <= 0) {\n      var (newBestNode, newBestDist) =\n          kdTreeNearestRec(node.left, target, depth + 1, bestNode, bestDist);\n      if (newBestDist < bestDist) {\n        bestDist = newBestDist;\n        bestNode = newBestNode;\n      }\n      if (diff.abs() < bestDist) {\n        var (rightBestNode, rightBestDist) = kdTreeNearestRec(\n            node.right, target, depth + 1, bestNode, bestDist);\n        if (rightBestDist < bestDist) {\n          bestDist = rightBestDist;\n          bestNode = rightBestNode;\n        }\n      }\n    } else {\n      var (newBestNode, newBestDist) =\n          kdTreeNearestRec(node.right, target, depth + 1, bestNode, bestDist);\n      if (newBestDist < bestDist) {\n        bestDist = newBestDist;\n        bestNode = newBestNode;\n      }\n      if (diff.abs() < bestDist) {\n        var (leftBestNode, leftBestDist) = kdTreeNearestRec(\n            node.left, target, depth + 1, bestNode, bestDist);\n        if (leftBestDist < bestDist) {\n          bestDist = leftBestDist;\n          bestNode = leftBestNode;\n        }\n      }\n    }\n\n    return (bestNode ?? [], bestDist);\n  }\n\n  final kdTreeRoot = buildKdTree(points);\n  final (nearestPoint, _) = kdTreeNearestRec(kdTreeRoot, target);\n  return nearestPoint;\n}\n\n// Helper function to calculate Euclidean distance between two points\ndouble _calculateDistance(List<double> a, List<double> b) {\n  if (a.length != b.length) {\n    throw ArgumentError(\"Points must have the same dimension\");\n  }\n  double sum = 0;\n  for (int i = 0; i < a.length; i++) {\n    sum += pow(a[i] - b[i], 2);\n  }\n  return sqrt(sum);\n}", "test_cases": "", "test_case_results": "Testing Brute Force Nearest Neighbor:\nTarget: [9.0, 2.0], Nearest: [8.0, 1.0]\nTarget: [3.0, 4.5], Nearest: [2.0, 3.0]\nTarget: [6.0, 3.0], Nearest: [5.0, 4.0]\n\nTesting KD-Tree Nearest Neighbor:\nTarget: [9.0, 2.0], Nearest: [8.0, 1.0]\nTarget: [3.0, 4.5], Nearest: [2.0, 3.0]\nTarget: [6.0, 3.0], Nearest: [7.0, 2.0]\n\nTesting Edge Cases:\nEmpty list brute force result: null\nEmpty list KD-Tree result: null", "task_id": 29202, "assertions": "import 'dart:math';\n\nvoid testNearestNeighbor() {\n  final testPoints = [\n    [2.0, 3.0],\n    [5.0, 4.0],\n    [9.0, 6.0],\n    [4.0, 7.0],\n    [8.0, 1.0],\n    [7.0, 2.0]\n  ];\n\n  // Test bruteForceNearest\n  assert(bruteForceNearest(testPoints, [9.0, 2.0]) == [8.0, 1.0]);\n  assert(bruteForceNearest(testPoints, [3.0, 4.5]) == [2.0, 3.0]);\n  assert(bruteForceNearest(testPoints, [6.0, 3.0]) == [5.0, 4.0]);\n\n  // Test kdTreeNearest\n  assert(kdTreeNearest(testPoints, [9.0, 2.0]) == [8.0, 1.0]);\n  assert(kdTreeNearest(testPoints, [3.0, 4.5]) == [2.0, 3.0]);\n  assert(kdTreeNearest(testPoints, [6.0, 3.0]) == [7.0, 2.0]);\n\n  // Test edge cases\n  assert(bruteForceNearest([], [1.0, 2.0]) == null);\n  assert(kdTreeNearest([], [1.0, 2.0]) == null);\n\n  print('All tests passed!');\n}\n\nvoid main() => testNearestNeighbor();", "all_code": "import 'dart:math';\n\n// Finds the nearest neighbor to the target point using brute force approach.\n// Returns null if the points list is empty.\nList<double>? bruteForceNearest(List<List<double>> points, List<double> target) {\n  if (points.isEmpty) {\n    return null;\n  }\n\n  double minDistance = double.infinity;\n  List<double>? nearestPoint;\n\n  for (var point in points) {\n    double distance = _calculateDistance(point, target);\n    if (distance < minDistance) {\n      minDistance = distance;\n      nearestPoint = point;\n    }\n  }\n\n  return nearestPoint;\n}\n\n// KD-Tree Node class to store points and child nodes\nclass KDTreeNode {\n  final List<double> point;\n  final KDTreeNode? left;\n  final KDTreeNode? right;\n\n  KDTreeNode({required this.point, this.left, this.right});\n}\n\n// Finds the nearest neighbor to the target point using KD-Tree approach.\n// Returns null if the points list is empty.\nList<double>? kdTreeNearest(List<List<double>> points, List<double> target) {\n  if (points.isEmpty) {\n    return null;\n  }\n\n  // Builds a KD-Tree from the given points\n  KDTreeNode buildKdTree(List<List<double>> points, [int depth = 0]) {\n    if (points.isEmpty) {\n      throw StateError(\"Empty points list in buildKdTree\");\n    }\n\n    int k = points[0].length; // Assumes all points have the same dimension\n    int axis = depth % k;\n\n    // Sort points based on current axis\n    points.sort((a, b) => a[axis].compareTo(b[axis]));\n    int median = points.length ~/ 2;\n\n    return KDTreeNode(\n      point: points[median],\n      left: median > 0 ? buildKdTree(points.sublist(0, median), depth + 1) : null,\n      right: median + 1 < points.length\n          ? buildKdTree(points.sublist(median + 1), depth + 1)\n          : null,\n    );\n  }\n\n  // Recursive helper function to find nearest neighbor in KD-Tree\n  (List<double>, double) kdTreeNearestRec(KDTreeNode? node, List<double> target,\n      [int depth = 0,\n      List<double>? bestNode,\n      double bestDist = double.infinity]) {\n    if (node == null) {\n      return (bestNode ?? [], bestDist);\n    }\n\n    int k = target.length;\n    int axis = depth % k;\n    List<double> point = node.point;\n\n    double d = _calculateDistance(point, target);\n    if (d < bestDist) {\n      bestDist = d;\n      bestNode = point;\n    }\n\n    double diff = target[axis] - point[axis];\n\n    if (diff <= 0) {\n      var (newBestNode, newBestDist) =\n          kdTreeNearestRec(node.left, target, depth + 1, bestNode, bestDist);\n      if (newBestDist < bestDist) {\n        bestDist = newBestDist;\n        bestNode = newBestNode;\n      }\n      if (diff.abs() < bestDist) {\n        var (rightBestNode, rightBestDist) = kdTreeNearestRec(\n            node.right, target, depth + 1, bestNode, bestDist);\n        if (rightBestDist < bestDist) {\n          bestDist = rightBestDist;\n          bestNode = rightBestNode;\n        }\n      }\n    } else {\n      var (newBestNode, newBestDist) =\n          kdTreeNearestRec(node.right, target, depth + 1, bestNode, bestDist);\n      if (newBestDist < bestDist) {\n        bestDist = newBestDist;\n        bestNode = newBestNode;\n      }\n      if (diff.abs() < bestDist) {\n        var (leftBestNode, leftBestDist) = kdTreeNearestRec(\n            node.left, target, depth + 1, bestNode, bestDist);\n        if (leftBestDist < bestDist) {\n          bestDist = leftBestDist;\n          bestNode = leftBestNode;\n        }\n      }\n    }\n\n    return (bestNode ?? [], bestDist);\n  }\n\n  final kdTreeRoot = buildKdTree(points);\n  final (nearestPoint, _) = kdTreeNearestRec(kdTreeRoot, target);\n  return nearestPoint;\n}\n\n// Helper function to calculate Euclidean distance between two points\ndouble _calculateDistance(List<double> a, List<double> b) {\n  if (a.length != b.length) {\n    throw ArgumentError(\"Points must have the same dimension\");\n  }\n  double sum = 0;\n  for (int i = 0; i < a.length; i++) {\n    sum += pow(a[i] - b[i], 2);\n  }\n  return sqrt(sum);\n}\n\nvoid testNearestNeighbor() {\n  final testPoints = [\n    [2.0, 3.0],\n    [5.0, 4.0],\n    [9.0, 6.0],\n    [4.0, 7.0],\n    [8.0, 1.0],\n    [7.0, 2.0]\n  ];\n\n  // Test bruteForceNearest\n  assert(bruteForceNearest(testPoints, [9.0, 2.0]) == [8.0, 1.0]);\n  assert(bruteForceNearest(testPoints, [3.0, 4.5]) == [2.0, 3.0]);\n  assert(bruteForceNearest(testPoints, [6.0, 3.0]) == [5.0, 4.0]);\n\n  // Test kdTreeNearest\n  assert(kdTreeNearest(testPoints, [9.0, 2.0]) == [8.0, 1.0]);\n  assert(kdTreeNearest(testPoints, [3.0, 4.5]) == [2.0, 3.0]);\n  assert(kdTreeNearest(testPoints, [6.0, 3.0]) == [7.0, 2.0]);\n\n  // Test edge cases\n  assert(bruteForceNearest([], [1.0, 2.0]) == null);\n  assert(kdTreeNearest([], [1.0, 2.0]) == null);\n\n  print('All tests passed!');\n}\n\nvoid main() => testNearestNeighbor();", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// customFibonacci calculates the n-th term of a Fibonacci-like sequence\n// where the first term is 'a' and the second term is 'b'.\n// The sequence follows the standard Fibonacci pattern where each subsequent term\n// is the sum of the two preceding ones.\nint customFibonacci(int n, int a, int b) {\n  if (n == 1) {\n    return a;\n  } else if (n == 2) {\n    return b;\n  }\n\n  int first = a;\n  int second = b;\n  for (int i = 3; i <= n; i++) {\n    int nextTerm = first + second;\n    first = second;\n    second = nextTerm;\n  }\n\n  return second;\n}", "test_cases": "", "test_case_results": "Input: n=1, a=0, b=1\nComputed: 0, Expected: 0\n---\nInput: n=2, a=0, b=1\nComputed: 1, Expected: 1\n---\nInput: n=5, a=0, b=1\nComputed: 3, Expected: 3\n---\nInput: n=4, a=2, b=3\nComputed: 8, Expected: 5\n---\nInput: n=6, a=1, b=1\nComputed: 8, Expected: 5\n---\nInput: n=7, a=5, b=7\nComputed: 81, Expected: 34\n---", "task_id": 2253, "assertions": "void testCustomFibonacci() {\n  // Test cases in format [n, a, b, expected]\n  assert(customFibonacci(1, 0, 1) == 0);\n  assert(customFibonacci(2, 0, 1) == 1);\n  assert(customFibonacci(5, 0, 1) == 3);\n  assert(customFibonacci(4, 2, 3) == 5);\n  assert(customFibonacci(6, 1, 1) == 5);\n  assert(customFibonacci(7, 5, 7) == 34);\n}\n\nvoid main() {\n  testCustomFibonacci();\n  print('All tests passed!');\n}", "all_code": "// customFibonacci calculates the n-th term of a Fibonacci-like sequence\n// where the first term is 'a' and the second term is 'b'.\n// The sequence follows the standard Fibonacci pattern where each subsequent term\n// is the sum of the two preceding ones.\nint customFibonacci(int n, int a, int b) {\n  if (n == 1) {\n    return a;\n  } else if (n == 2) {\n    return b;\n  }\n\n  int first = a;\n  int second = b;\n  for (int i = 3; i <= n; i++) {\n    int nextTerm = first + second;\n    first = second;\n    second = nextTerm;\n  }\n\n  return second;\n}\n\nvoid testCustomFibonacci() {\n  // Test cases in format [n, a, b, expected]\n  assert(customFibonacci(1, 0, 1) == 0);\n  assert(customFibonacci(2, 0, 1) == 1);\n  assert(customFibonacci(5, 0, 1) == 3);\n  assert(customFibonacci(4, 2, 3) == 5);\n  assert(customFibonacci(6, 1, 1) == 5);\n  assert(customFibonacci(7, 5, 7) == 34);\n}\n\nvoid main() {\n  testCustomFibonacci();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// reverseSentence reverses the order of words in a given string while properly\n// handling leading, trailing, and multiple consecutive spaces.\n// It splits the input string into words, reverses their order, and joins them back\n// with single spaces between words.\nString reverseSentence(String sentence) {\n  // Split the sentence into words, which automatically handles multiple spaces\n  List<String> words = sentence.split(' ').where((word) => word.isNotEmpty).toList();\n  \n  // Reverse the order of words\n  List<String> reversedWords = words.reversed.toList();\n  \n  // Join the reversed words with a single space in between\n  String reversedSentence = reversedWords.join(' ');\n  \n  return reversedSentence;\n}", "test_cases": "", "test_case_results": "Input: \"Hello world\"\nReversed: \"world Hello\"\n\nInput: \"  Leading spaces\"\nReversed: \"spaces Leading\"\n\nInput: \"Trailing spaces   \"\nReversed: \"spaces Trailing\"\n\nInput: \"Multiple   between   words\"\nReversed: \"words between Multiple\"\n\nInput: \"\"\nReversed: \"\"\n\nInput: \"   \"\nReversed: \"\"\n\nInput: \"SingleWord\"\nReversed: \"SingleWord\"", "task_id": 20993, "assertions": "void testReverseSentence() {\n  assert(reverseSentence(\"Hello world\") == \"world Hello\");\n  assert(reverseSentence(\"  Leading spaces\") == \"spaces Leading\");\n  assert(reverseSentence(\"Trailing spaces   \") == \"spaces Trailing\");\n  assert(reverseSentence(\"Multiple   between   words\") == \"words between Multiple\");\n  assert(reverseSentence(\"\") == \"\");\n  assert(reverseSentence(\"   \") == \"\");\n  assert(reverseSentence(\"SingleWord\") == \"SingleWord\");\n}\n\nvoid main() {\n  testReverseSentence();\n  print(\"All tests passed!\");\n}", "all_code": "// reverseSentence reverses the order of words in a given string while properly\n// handling leading, trailing, and multiple consecutive spaces.\n// It splits the input string into words, reverses their order, and joins them back\n// with single spaces between words.\nString reverseSentence(String sentence) {\n  // Split the sentence into words, which automatically handles multiple spaces\n  List<String> words = sentence.split(' ').where((word) => word.isNotEmpty).toList();\n  \n  // Reverse the order of words\n  List<String> reversedWords = words.reversed.toList();\n  \n  // Join the reversed words with a single space in between\n  String reversedSentence = reversedWords.join(' ');\n  \n  return reversedSentence;\n}\n\nvoid testReverseSentence() {\n  assert(reverseSentence(\"Hello world\") == \"world Hello\");\n  assert(reverseSentence(\"  Leading spaces\") == \"spaces Leading\");\n  assert(reverseSentence(\"Trailing spaces   \") == \"spaces Trailing\");\n  assert(reverseSentence(\"Multiple   between   words\") == \"words between Multiple\");\n  assert(reverseSentence(\"\") == \"\");\n  assert(reverseSentence(\"   \") == \"\");\n  assert(reverseSentence(\"SingleWord\") == \"SingleWord\");\n}\n\nvoid main() {\n  testReverseSentence();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "int maxCount(int m, int n, List<List<int>> ops) {\n  // If there are no operations, all cells contain the maximum integer (0)\n  if (ops.isEmpty) {\n    return m * n;\n  }\n  \n  // Find the minimum a and b values across all operations\n  int minA = ops[0][0];\n  int minB = ops[0][1];\n  \n  for (var op in ops) {\n    if (op[0] < minA) minA = op[0];\n    if (op[1] < minB) minB = op[1];\n  }\n  \n  return minA * minB;\n}", "test_cases": "", "test_case_results": "Test 1 - m: 3, n: 3, ops: []\nResult: 9\n\nTest 2 - m: 3, n: 3, ops: [[2, 2]]\nResult: 4\n\nTest 3 - m: 3, n: 3, ops: [[2, 2], [3, 3]]\nResult: 4\n\nTest 4 - m: 3, n: 3, ops: [[1, 2], [3, 1]]\nResult: 1\n\nTest 5 - m: 40000, n: 40000, ops: [[19999, 19999], [20000, 20000]]\nResult: 399960001", "task_id": 15540, "assertions": "void testMaxCount() {\n  assert(maxCount(3, 3, []) == 9);\n  assert(maxCount(3, 3, [[2, 2]]) == 4);\n  assert(maxCount(3, 3, [[2, 2], [3, 3]]) == 4);\n  assert(maxCount(3, 3, [[1, 2], [3, 1]]) == 1);\n  assert(maxCount(40000, 40000, [[19999, 19999], [20000, 20000]]) == 399960001);\n}\n\nvoid main() {\n  testMaxCount();\n}", "all_code": "int maxCount(int m, int n, List<List<int>> ops) {\n  // If there are no operations, all cells contain the maximum integer (0)\n  if (ops.isEmpty) {\n    return m * n;\n  }\n  \n  // Find the minimum a and b values across all operations\n  int minA = ops[0][0];\n  int minB = ops[0][1];\n  \n  for (var op in ops) {\n    if (op[0] < minA) minA = op[0];\n    if (op[1] < minB) minB = op[1];\n  }\n  \n  return minA * minB;\n}\n\nvoid testMaxCount() {\n  assert(maxCount(3, 3, []) == 9);\n  assert(maxCount(3, 3, [[2, 2]]) == 4);\n  assert(maxCount(3, 3, [[2, 2], [3, 3]]) == 4);\n  assert(maxCount(3, 3, [[1, 2], [3, 1]]) == 1);\n  assert(maxCount(40000, 40000, [[19999, 19999], [20000, 20000]]) == 399960001);\n}\n\nvoid main() {\n  testMaxCount();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:io';\n\n// analyzeWordFrequency analyzes the frequency of words in a given text string.\n// It removes punctuation, converts words to lowercase, and counts occurrences.\n// Returns a map where keys are words and values are their frequencies.\nMap<String, int> analyzeWordFrequency(String text) {\n  final wordCount = <String, int>{};\n  if (text.isEmpty) {\n    return wordCount;\n  }\n\n  // Remove punctuation and make lowercase\n  final punctuation = RegExp(r'[^\\w\\s]');\n  final cleanedText = text.replaceAll(punctuation, '').toLowerCase();\n  final words = cleanedText.split(RegExp(r'\\s+'));\n\n  for (final word in words) {\n    if (word.isEmpty) continue;\n    wordCount.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n\n  return wordCount;\n}", "test_cases": "", "test_case_results": "Input Text: \"Hello world! Hello Dart. World of Dart is great.\"\nWord Frequencies: {hello: 2, world: 2, dart: 2, of: 1, is: 1, great: 1}\n---\nInput Text: \"The quick brown fox jumps over the lazy dog.\"\nWord Frequencies: {the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}\n---\nInput Text: \"To be, or not to be: that is the question.\"\nWord Frequencies: {to: 2, be: 2, or: 1, not: 1, that: 1, is: 1, the: 1, question: 1}\n---\nInput Text: \"\"\nWord Frequencies: {}\n---\nInput Text: \"Punctuation! Test? This, is. A: test; with-lots of punctuation.\"\nWord Frequencies: {punctuation: 2, test: 2, this: 1, is: 1, a: 1, withlots: 1, of: 1}\n---\nMultiline Input Text:\n  This is a multiline test.\n  It should count words across lines.\n  The word \"the\" appears twice here.\n  The word \"multiline\" appears once.\n  \nWord Frequencies: {this: 1, is: 1, a: 1, multiline: 2, test: 1, it: 1, should: 1, count: 1, words: 1, across: 1, lines: 1, the: 3, word: 2, appears: 2, twice: 1, here: 1, once: 1}", "task_id": 6905, "assertions": "import 'dart:io';\n\nvoid testAnalyzeWordFrequency() {\n  // Test case 1\n  assert(\n    analyzeWordFrequency(\"Hello world! Hello Dart. World of Dart is great.\").toString() == \n    '{hello: 2, world: 2, dart: 2, of: 1, is: 1, great: 1}'\n  );\n\n  // Test case 2\n  assert(\n    analyzeWordFrequency(\"The quick brown fox jumps over the lazy dog.\").toString() == \n    '{the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}'\n  );\n\n  // Test case 3\n  assert(\n    analyzeWordFrequency(\"To be, or not to be: that is the question.\").toString() == \n    '{to: 2, be: 2, or: 1, not: 1, that: 1, is: 1, the: 1, question: 1}'\n  );\n\n  // Test case 4 (empty string)\n  assert(\n    analyzeWordFrequency(\"\").toString() == '{}'\n  );\n\n  // Test case 5 (punctuation)\n  assert(\n    analyzeWordFrequency(\"Punctuation! Test? This, is. A: test; with-lots of punctuation.\").toString() == \n    '{punctuation: 2, test: 2, this: 1, is: 1, a: 1, withlots: 1, of: 1}'\n  );\n\n  // Test case 6 (multiline)\n  final multilineTest = '''\n  This is a multiline test.\n  It should count words across lines.\n  The word \"the\" appears twice here.\n  The word \"multiline\" appears once.\n  ''';\n  assert(\n    analyzeWordFrequency(multilineTest).toString() == \n    '{this: 1, is: 1, a: 1, multiline: 2, test: 1, it: 1, should: 1, count: 1, words: 1, across: 1, lines: 1, the: 3, word: 2, appears: 2, twice: 1, here: 1, once: 1}'\n  );\n\n  print('All tests passed!');\n}\n\nvoid main() {\n  testAnalyzeWordFrequency();\n}", "all_code": "import 'dart:io';\n\n// analyzeWordFrequency analyzes the frequency of words in a given text string.\n// It removes punctuation, converts words to lowercase, and counts occurrences.\n// Returns a map where keys are words and values are their frequencies.\nMap<String, int> analyzeWordFrequency(String text) {\n  final wordCount = <String, int>{};\n  if (text.isEmpty) {\n    return wordCount;\n  }\n\n  // Remove punctuation and make lowercase\n  final punctuation = RegExp(r'[^\\w\\s]');\n  final cleanedText = text.replaceAll(punctuation, '').toLowerCase();\n  final words = cleanedText.split(RegExp(r'\\s+'));\n\n  for (final word in words) {\n    if (word.isEmpty) continue;\n    wordCount.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n\n  return wordCount;\n}\n\nvoid testAnalyzeWordFrequency() {\n  // Test case 1\n  assert(\n    analyzeWordFrequency(\"Hello world! Hello Dart. World of Dart is great.\").toString() == \n    '{hello: 2, world: 2, dart: 2, of: 1, is: 1, great: 1}'\n  );\n\n  // Test case 2\n  assert(\n    analyzeWordFrequency(\"The quick brown fox jumps over the lazy dog.\").toString() == \n    '{the: 2, quick: 1, brown: 1, fox: 1, jumps: 1, over: 1, lazy: 1, dog: 1}'\n  );\n\n  // Test case 3\n  assert(\n    analyzeWordFrequency(\"To be, or not to be: that is the question.\").toString() == \n    '{to: 2, be: 2, or: 1, not: 1, that: 1, is: 1, the: 1, question: 1}'\n  );\n\n  // Test case 4 (empty string)\n  assert(\n    analyzeWordFrequency(\"\").toString() == '{}'\n  );\n\n  // Test case 5 (punctuation)\n  assert(\n    analyzeWordFrequency(\"Punctuation! Test? This, is. A: test; with-lots of punctuation.\").toString() == \n    '{punctuation: 2, test: 2, this: 1, is: 1, a: 1, withlots: 1, of: 1}'\n  );\n\n  // Test case 6 (multiline)\n  final multilineTest = '''\n  This is a multiline test.\n  It should count words across lines.\n  The word \"the\" appears twice here.\n  The word \"multiline\" appears once.\n  ''';\n  assert(\n    analyzeWordFrequency(multilineTest).toString() == \n    '{this: 1, is: 1, a: 1, multiline: 2, test: 1, it: 1, should: 1, count: 1, words: 1, across: 1, lines: 1, the: 3, word: 2, appears: 2, twice: 1, here: 1, once: 1}'\n  );\n\n  print('All tests passed!');\n}\n\nvoid main() {\n  testAnalyzeWordFrequency();\n}", "exec_outcome": "PASSED"}
{"code": "// analyzeLogs processes a list of log entries to determine the number of unique users\n// for each action. Each log entry is expected to be in the format \"action ... user_id\".\n// Returns a map where keys are actions and values are counts of unique users for each action.\nMap<String, int> analyzeLogs(List<String> logs) {\n  final Map<String, Set<String>> actionUsers = {};\n\n  for (final log in logs) {\n    final parts = log.split(' ');\n    if (parts.length < 2) continue; // Skip malformed entries\n    \n    final action = parts[0];\n    final userId = parts.last;\n\n    // Initialize the set if this action hasn't been seen before\n    actionUsers.putIfAbsent(action, () => <String>{});\n    \n    // Add the user to this action's set\n    actionUsers[action]!.add(userId);\n  }\n\n  // Convert sets of users to counts\n  return {\n    for (final entry in actionUsers.entries)\n      entry.key: entry.value.length\n  };\n}", "test_cases": "", "test_case_results": "Test Case 1 (Normal logs)\nInput logs: [login user1, login user2, purchase user1, logout user1, login user3, purchase user2, logout user2]\nUnique users per action: {login: 3, purchase: 2, logout: 2}\n\nTest Case 2 (Single action)\nInput logs: [view user1, view user2, view user1, view user3]\nUnique users per action: {view: 3}\n\nTest Case 3 (Empty logs)\nInput logs: []\nUnique users per action: {}\n\nTest Case 4 (Malformed entries)\nInput logs: [actionOnly,   , action user1]\nUnique users per action: {: 1, action: 1}", "task_id": 24759, "assertions": "void testAnalyzeLogs() {\n  // Test case 1: Normal logs with multiple actions and users\n  assert(\n    analyzeLogs([\n      'login user1',\n      'login user2',\n      'purchase user1',\n      'logout user1',\n      'login user3',\n      'purchase user2',\n      'logout user2',\n    ]) == {'login': 3, 'purchase': 2, 'logout': 2},\n  );\n\n  // Test case 2: Single action with multiple users\n  assert(\n    analyzeLogs([\n      'view user1',\n      'view user2',\n      'view user1',  // Duplicate user\n      'view user3',\n    ]) == {'view': 3},\n  );\n\n  // Test case 3: Empty logs\n  assert(\n    analyzeLogs([]) == {},\n  );\n\n  // Test case 4: Malformed entries (should be handled gracefully)\n  assert(\n    analyzeLogs([\n      'actionOnly',\n      '  ',  // Empty after trim\n      'action user1',\n    ]) == {'action': 1},\n  );\n}\n\nvoid main() {\n  testAnalyzeLogs();\n  print('All tests passed!');\n}", "all_code": "// analyzeLogs processes a list of log entries to determine the number of unique users\n// for each action. Each log entry is expected to be in the format \"action ... user_id\".\n// Returns a map where keys are actions and values are counts of unique users for each action.\nMap<String, int> analyzeLogs(List<String> logs) {\n  final Map<String, Set<String>> actionUsers = {};\n\n  for (final log in logs) {\n    final parts = log.split(' ');\n    if (parts.length < 2) continue; // Skip malformed entries\n    \n    final action = parts[0];\n    final userId = parts.last;\n\n    // Initialize the set if this action hasn't been seen before\n    actionUsers.putIfAbsent(action, () => <String>{});\n    \n    // Add the user to this action's set\n    actionUsers[action]!.add(userId);\n  }\n\n  // Convert sets of users to counts\n  return {\n    for (final entry in actionUsers.entries)\n      entry.key: entry.value.length\n  };\n}\n\nvoid testAnalyzeLogs() {\n  // Test case 1: Normal logs with multiple actions and users\n  assert(\n    analyzeLogs([\n      'login user1',\n      'login user2',\n      'purchase user1',\n      'logout user1',\n      'login user3',\n      'purchase user2',\n      'logout user2',\n    ]) == {'login': 3, 'purchase': 2, 'logout': 2},\n  );\n\n  // Test case 2: Single action with multiple users\n  assert(\n    analyzeLogs([\n      'view user1',\n      'view user2',\n      'view user1',  // Duplicate user\n      'view user3',\n    ]) == {'view': 3},\n  );\n\n  // Test case 3: Empty logs\n  assert(\n    analyzeLogs([]) == {},\n  );\n\n  // Test case 4: Malformed entries (should be handled gracefully)\n  assert(\n    analyzeLogs([\n      'actionOnly',\n      '  ',  // Empty after trim\n      'action user1',\n    ]) == {'action': 1},\n  );\n}\n\nvoid main() {\n  testAnalyzeLogs();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Returns the index of the first occurrence of the minimum value in a sorted list.\n// Since the list is sorted in non-decreasing order, the minimum value is always at index 0.\n// If the list is empty, returns -1.\nint firstOccurrenceOfMin(List<int> sortedList) {\n  if (sortedList.isEmpty) {\n    return -1;\n  }\n  \n  return 0;\n}", "test_cases": "", "test_case_results": "Input: []\nFirst occurrence of min at index: -1\n---\nInput: [1]\nFirst occurrence of min at index: 0\n---\nInput: [1, 2, 3, 4, 5]\nFirst occurrence of min at index: 0\n---\nInput: [1, 1, 2, 3, 4]\nFirst occurrence of min at index: 0\n---\nInput: [-5, -3, 0, 1, 1]\nFirst occurrence of min at index: 0\n---\nInput: [10, 10, 10, 10]\nFirst occurrence of min at index: 0\n---\nInput: [-10, -5, 0, 0, 5, 10]\nFirst occurrence of min at index: 0\n---", "task_id": 22568, "assertions": "void testFirstOccurrenceOfMin() {\n  assert(firstOccurrenceOfMin([]) == -1);\n  assert(firstOccurrenceOfMin([1]) == 0);\n  assert(firstOccurrenceOfMin([1, 2, 3, 4, 5]) == 0);\n  assert(firstOccurrenceOfMin([1, 1, 2, 3, 4]) == 0);\n  assert(firstOccurrenceOfMin([-5, -3, 0, 1, 1]) == 0);\n  assert(firstOccurrenceOfMin([10, 10, 10, 10]) == 0);\n  assert(firstOccurrenceOfMin([-10, -5, 0, 0, 5, 10]) == 0);\n}\n\nvoid main() {\n  testFirstOccurrenceOfMin();\n}", "all_code": "// Returns the index of the first occurrence of the minimum value in a sorted list.\n// Since the list is sorted in non-decreasing order, the minimum value is always at index 0.\n// If the list is empty, returns -1.\nint firstOccurrenceOfMin(List<int> sortedList) {\n  if (sortedList.isEmpty) {\n    return -1;\n  }\n  \n  return 0;\n}\n\nvoid testFirstOccurrenceOfMin() {\n  assert(firstOccurrenceOfMin([]) == -1);\n  assert(firstOccurrenceOfMin([1]) == 0);\n  assert(firstOccurrenceOfMin([1, 2, 3, 4, 5]) == 0);\n  assert(firstOccurrenceOfMin([1, 1, 2, 3, 4]) == 0);\n  assert(firstOccurrenceOfMin([-5, -3, 0, 1, 1]) == 0);\n  assert(firstOccurrenceOfMin([10, 10, 10, 10]) == 0);\n  assert(firstOccurrenceOfMin([-10, -5, 0, 0, 5, 10]) == 0);\n}\n\nvoid main() {\n  testFirstOccurrenceOfMin();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\nint reachableVertices(int n, int m, List<List<int>> edges, int v, int k) {\n  // Build the adjacency list representation of the graph\n  Map<int, List<int>> graph = {};\n  for (var edge in edges) {\n    int u = edge[0];\n    int w = edge[1];\n    if (!graph.containsKey(u)) {\n      graph[u] = [];\n    }\n    graph[u]!.add(w);\n  }\n\n  // Initialize BFS queue with the starting vertex and step count 0\n  Queue<List<int>> queue = Queue();\n  queue.add([v, 0]);\n\n  // Track visited vertices at each step level\n  Map<int, Set<int>> visited = {};\n\n  while (queue.isNotEmpty) {\n    List<int> current = queue.removeFirst();\n    int vertex = current[0];\n    int steps = current[1];\n\n    if (steps == k) {\n      if (!visited.containsKey(steps)) {\n        visited[steps] = {};\n      }\n      visited[steps]!.add(vertex);\n    } else if (steps < k) {\n      if (graph.containsKey(vertex)) {\n        for (int neighbor in graph[vertex]!) {\n          if (!visited.containsKey(steps + 1) || !visited[steps + 1]!.contains(neighbor)) {\n            if (!visited.containsKey(steps + 1)) {\n              visited[steps + 1] = {};\n            }\n            visited[steps + 1]!.add(neighbor);\n            queue.add([neighbor, steps + 1]);\n          }\n        }\n      }\n    }\n  }\n\n  return visited.containsKey(k) ? visited[k]!.length : 0;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 5, m: 4, edges: [[1, 2], [2, 3], [3, 4], [4, 5]], v: 2, k: 2\nReachable vertices: 1\n\nTest Case 2:\nn: 6, m: 5, edges: [[1, 2], [1, 3], [2, 4], [3, 5], [5, 6]], v: 1, k: 2\nReachable vertices: 2\n\nTest Case 3:\nn: 4, m: 3, edges: [[1, 2], [2, 3], [3, 4]], v: 1, k: 5\nReachable vertices: 0\n\nTest Case 4:\nn: 3, m: 2, edges: [[1, 2], [2, 3]], v: 3, k: 1\nReachable vertices: 0", "task_id": 3266, "assertions": "import 'dart:collection';\n\nvoid testReachableVertices() {\n  // Test Case 1: Simple linear graph\n  assert(reachableVertices(5, 4, [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5]\n  ], 2, 2) == 1);\n\n  // Test Case 2: Graph with multiple branches\n  assert(reachableVertices(6, 5, [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [3, 5],\n    [5, 6]\n  ], 1, 2) == 2);\n\n  // Test Case 3: No vertices reachable in k steps\n  assert(reachableVertices(4, 3, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ], 1, 5) == 0);\n\n  // Test Case 4: Starting vertex with no outgoing edges\n  assert(reachableVertices(3, 2, [\n    [1, 2],\n    [2, 3]\n  ], 3, 1) == 0);\n}\n\nvoid main() {\n  testReachableVertices();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\nint reachableVertices(int n, int m, List<List<int>> edges, int v, int k) {\n  // Build the adjacency list representation of the graph\n  Map<int, List<int>> graph = {};\n  for (var edge in edges) {\n    int u = edge[0];\n    int w = edge[1];\n    if (!graph.containsKey(u)) {\n      graph[u] = [];\n    }\n    graph[u]!.add(w);\n  }\n\n  // Initialize BFS queue with the starting vertex and step count 0\n  Queue<List<int>> queue = Queue();\n  queue.add([v, 0]);\n\n  // Track visited vertices at each step level\n  Map<int, Set<int>> visited = {};\n\n  while (queue.isNotEmpty) {\n    List<int> current = queue.removeFirst();\n    int vertex = current[0];\n    int steps = current[1];\n\n    if (steps == k) {\n      if (!visited.containsKey(steps)) {\n        visited[steps] = {};\n      }\n      visited[steps]!.add(vertex);\n    } else if (steps < k) {\n      if (graph.containsKey(vertex)) {\n        for (int neighbor in graph[vertex]!) {\n          if (!visited.containsKey(steps + 1) || !visited[steps + 1]!.contains(neighbor)) {\n            if (!visited.containsKey(steps + 1)) {\n              visited[steps + 1] = {};\n            }\n            visited[steps + 1]!.add(neighbor);\n            queue.add([neighbor, steps + 1]);\n          }\n        }\n      }\n    }\n  }\n\n  return visited.containsKey(k) ? visited[k]!.length : 0;\n}\n\nvoid testReachableVertices() {\n  // Test Case 1: Simple linear graph\n  assert(reachableVertices(5, 4, [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5]\n  ], 2, 2) == 1);\n\n  // Test Case 2: Graph with multiple branches\n  assert(reachableVertices(6, 5, [\n    [1, 2],\n    [1, 3],\n    [2, 4],\n    [3, 5],\n    [5, 6]\n  ], 1, 2) == 2);\n\n  // Test Case 3: No vertices reachable in k steps\n  assert(reachableVertices(4, 3, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ], 1, 5) == 0);\n\n  // Test Case 4: Starting vertex with no outgoing edges\n  assert(reachableVertices(3, 2, [\n    [1, 2],\n    [2, 3]\n  ], 3, 1) == 0);\n}\n\nvoid main() {\n  testReachableVertices();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection'; // For heap operations (simulated using List and sort)\n\n// MinHeap implementation in Dart\n// This class provides a minimum heap data structure with the following operations:\n// - insert: Adds a new key to the heap\n// - extractMin: Removes and returns the smallest key\n// - decreaseKey: Decreases the value of an existing key\n// - getMin: Returns the smallest key without removing it\nclass MinHeap {\n  List<int> _heap = [];\n  Map<int, int> _keyMap = {};\n\n  // Inserts a new key into the heap\n  void insert(int key) {\n    _heap.add(key);\n    _keyMap[key] = key;\n    _heap.sort(); // Simulate heap behavior by sorting\n  }\n\n  // Removes and returns the minimum key from the heap\n  int extractMin() {\n    if (_heap.isEmpty) throw StateError('Heap is empty');\n    int minKey = _heap.removeAt(0);\n    _keyMap.remove(minKey);\n    return minKey;\n  }\n\n  // Decreases the value of an existing key to a new key\n  void decreaseKey(int currentKey, int newKey) {\n    if (!_keyMap.containsKey(currentKey)) {\n      throw ArgumentError('Key not found in heap');\n    }\n    if (newKey > currentKey) {\n      throw ArgumentError('New key must be smaller than current key');\n    }\n    \n    int index = _heap.indexOf(currentKey);\n    _heap[index] = newKey;\n    _keyMap.remove(currentKey);\n    _keyMap[newKey] = newKey;\n    _heap.sort(); // Re-sort to maintain heap property\n  }\n\n  // Returns the minimum key without removing it\n  int getMin() {\n    if (_heap.isEmpty) throw StateError('Heap is empty');\n    return _heap.first;\n  }\n}", "test_cases": "", "test_case_results": "Test Case 1: Basic operations\nInitial heap state: [5, 3, 7]\ngetMin(): 3\nextractMin(): 3\ngetMin(): 5\n\nTest Case 2: Decrease key\nInitial heap state: [10, 20, 30]\ngetMin(): 10\nAfter decreasing 20 to 5\ngetMin(): 5\nextractMin(): 5\nextractMin(): 10\n\nTest Case 3: Edge cases\nAttempting getMin() on empty heap:\nCaught exception: Bad state: Heap is empty\nAttempting extractMin() on empty heap:\nCaught exception: Bad state: Heap is empty\nAttempting to decrease non-existent key:\nCaught exception: Invalid argument(s): Key not found in heap", "task_id": 8551, "assertions": "void testMinHeap() {\n  // Test basic operations\n  var heap1 = MinHeap();\n  heap1.insert(5);\n  heap1.insert(3);\n  heap1.insert(7);\n  assert(heap1.getMin() == 3);\n  assert(heap1.extractMin() == 3);\n  assert(heap1.getMin() == 5);\n\n  // Test decrease key operation\n  var heap2 = MinHeap();\n  heap2.insert(10);\n  heap2.insert(20);\n  heap2.insert(30);\n  assert(heap2.getMin() == 10);\n  heap2.decreaseKey(20, 5);\n  assert(heap2.getMin() == 5);\n  assert(heap2.extractMin() == 5);\n  assert(heap2.extractMin() == 10);\n\n  // Test edge cases\n  var heap3 = MinHeap();\n  try {\n    heap3.getMin();\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is StateError);\n  }\n  \n  try {\n    heap3.extractMin();\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is StateError);\n  }\n  \n  try {\n    heap3.insert(100);\n    heap3.decreaseKey(99, 50);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n  }\n}\n\nvoid main() {\n  testMinHeap();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n// MinHeap implementation in Dart\n// This class provides a minimum heap data structure with the following operations:\n// - insert: Adds a new key to the heap\n// - extractMin: Removes and returns the smallest key\n// - decreaseKey: Decreases the value of an existing key\n// - getMin: Returns the smallest key without removing it\nclass MinHeap {\n  List<int> _heap = [];\n  Map<int, int> _keyMap = {};\n\n  // Inserts a new key into the heap\n  void insert(int key) {\n    _heap.add(key);\n    _keyMap[key] = key;\n    _heap.sort(); // Simulate heap behavior by sorting\n  }\n\n  // Removes and returns the minimum key from the heap\n  int extractMin() {\n    if (_heap.isEmpty) throw StateError('Heap is empty');\n    int minKey = _heap.removeAt(0);\n    _keyMap.remove(minKey);\n    return minKey;\n  }\n\n  // Decreases the value of an existing key to a new key\n  void decreaseKey(int currentKey, int newKey) {\n    if (!_keyMap.containsKey(currentKey)) {\n      throw ArgumentError('Key not found in heap');\n    }\n    if (newKey > currentKey) {\n      throw ArgumentError('New key must be smaller than current key');\n    }\n    \n    int index = _heap.indexOf(currentKey);\n    _heap[index] = newKey;\n    _keyMap.remove(currentKey);\n    _keyMap[newKey] = newKey;\n    _heap.sort(); // Re-sort to maintain heap property\n  }\n\n  // Returns the minimum key without removing it\n  int getMin() {\n    if (_heap.isEmpty) throw StateError('Heap is empty');\n    return _heap.first;\n  }\n}\n\nvoid testMinHeap() {\n  // Test basic operations\n  var heap1 = MinHeap();\n  heap1.insert(5);\n  heap1.insert(3);\n  heap1.insert(7);\n  assert(heap1.getMin() == 3);\n  assert(heap1.extractMin() == 3);\n  assert(heap1.getMin() == 5);\n\n  // Test decrease key operation\n  var heap2 = MinHeap();\n  heap2.insert(10);\n  heap2.insert(20);\n  heap2.insert(30);\n  assert(heap2.getMin() == 10);\n  heap2.decreaseKey(20, 5);\n  assert(heap2.getMin() == 5);\n  assert(heap2.extractMin() == 5);\n  assert(heap2.extractMin() == 10);\n\n  // Test edge cases\n  var heap3 = MinHeap();\n  try {\n    heap3.getMin();\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is StateError);\n  }\n  \n  try {\n    heap3.extractMin();\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is StateError);\n  }\n  \n  try {\n    heap3.insert(100);\n    heap3.decreaseKey(99, 50);\n    assert(false); // Should not reach here\n  } catch (e) {\n    assert(e is ArgumentError);\n  }\n}\n\nvoid main() {\n  testMinHeap();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// isScramble checks if string s2 is a scrambled version of string s1.\n// It uses a recursive approach to determine if the strings can be split and matched in any order.\nbool isScramble(String s1, String s2) {\n  // Base case: if lengths are different, they can't be scrambled versions\n  if (s1.length != s2.length) {\n    return false;\n  }\n  // Base case: if strings are identical, they are scrambled versions\n  if (s1 == s2) {\n    return true;\n  }\n  // Base case: if sorted characters are different, they can't be scrambled versions\n  if (_sortString(s1) != _sortString(s2)) {\n    return false;\n  }\n\n  int n = s1.length;\n  for (int i = 1; i < n; i++) {\n    // Check two possible splits:\n    // 1. First i characters of s1 match first i of s2, and rest match\n    // 2. First i characters of s1 match last i of s2, and rest match\n    if ((isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n            isScramble(s1.substring(i), s2.substring(i))) ||\n        (isScramble(s1.substring(0, i), s2.substring(n - i)) &&\n            isScramble(s1.substring(i), s2.substring(0, n - i)))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Helper function to sort characters in a string for comparison\nString _sortString(String s) {\n  var chars = s.split('');\n  chars.sort();\n  return chars.join();\n}", "test_cases": "", "test_case_results": "Input: s1=\"great\", s2=\"rgeat\"\nIs scramble: true\n\nInput: s1=\"abcde\", s2=\"caebd\"\nIs scramble: false\n\nInput: s1=\"a\", s2=\"a\"\nIs scramble: true\n\nInput: s1=\"ab\", s2=\"ba\"\nIs scramble: true\n\nInput: s1=\"abcd\", s2=\"badc\"\nIs scramble: true\n\nInput: s1=\"abcd\", s2=\"dacb\"\nIs scramble: true\n\nInput: s1=\"abc\", s2=\"def\"\nIs scramble: false\n\nInput: s1=\"abb\", s2=\"bba\"\nIs scramble: true", "task_id": 17052, "assertions": "void testIsScramble() {\n  assert(isScramble('great', 'rgeat') == true);\n  assert(isScramble('abcde', 'caebd') == false);\n  assert(isScramble('a', 'a') == true);\n  assert(isScramble('ab', 'ba') == true);\n  assert(isScramble('abcd', 'badc') == true);\n  assert(isScramble('abcd', 'dacb') == true);\n  assert(isScramble('abc', 'def') == false);\n  assert(isScramble('abb', 'bba') == true);\n}\n\nvoid main() {\n  testIsScramble();\n}", "all_code": "// isScramble checks if string s2 is a scrambled version of string s1.\n// It uses a recursive approach to determine if the strings can be split and matched in any order.\nbool isScramble(String s1, String s2) {\n  // Base case: if lengths are different, they can't be scrambled versions\n  if (s1.length != s2.length) {\n    return false;\n  }\n  // Base case: if strings are identical, they are scrambled versions\n  if (s1 == s2) {\n    return true;\n  }\n  // Base case: if sorted characters are different, they can't be scrambled versions\n  if (_sortString(s1) != _sortString(s2)) {\n    return false;\n  }\n\n  int n = s1.length;\n  for (int i = 1; i < n; i++) {\n    // Check two possible splits:\n    // 1. First i characters of s1 match first i of s2, and rest match\n    // 2. First i characters of s1 match last i of s2, and rest match\n    if ((isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n            isScramble(s1.substring(i), s2.substring(i))) ||\n        (isScramble(s1.substring(0, i), s2.substring(n - i)) &&\n            isScramble(s1.substring(i), s2.substring(0, n - i)))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Helper function to sort characters in a string for comparison\nString _sortString(String s) {\n  var chars = s.split('');\n  chars.sort();\n  return chars.join();\n}\n\nvoid testIsScramble() {\n  assert(isScramble('great', 'rgeat') == true);\n  assert(isScramble('abcde', 'caebd') == false);\n  assert(isScramble('a', 'a') == true);\n  assert(isScramble('ab', 'ba') == true);\n  assert(isScramble('abcd', 'badc') == true);\n  assert(isScramble('abcd', 'dacb') == true);\n  assert(isScramble('abc', 'def') == false);\n  assert(isScramble('abb', 'bba') == true);\n}\n\nvoid main() {\n  testIsScramble();\n}", "exec_outcome": "PASSED"}
{"code": "// findLongestSubstring finds the longest substring of a string that contains only unique characters.\n// It uses a sliding window approach to check for unique characters in all possible substrings.\n// Returns an empty string if the input is empty.\nString findLongestSubstring(String s) {\n  String longestSubstring = \"\";\n  \n  for (int i = 0; i < s.length; i++) {\n    String currentSubstring = \"\";\n    Set<String> seenChars = {};\n    \n    for (int j = i; j < s.length; j++) {\n      String currentChar = s[j];\n      if (seenChars.contains(currentChar)) {\n        break;\n      } else {\n        seenChars.add(currentChar);\n        currentSubstring += currentChar;\n      }\n      \n      if (currentSubstring.length > longestSubstring.length) {\n        longestSubstring = currentSubstring;\n      }\n    }\n  }\n  \n  return longestSubstring;\n}", "test_cases": "", "test_case_results": "Input: \"abcabcbb\"\nLongest unique substring: \"abc\"\n---\nInput: \"bbbbb\"\nLongest unique substring: \"b\"\n---\nInput: \"pwwkew\"\nLongest unique substring: \"wke\"\n---\nInput: \"\"\nLongest unique substring: \"\"\n---\nInput: \"abcdef\"\nLongest unique substring: \"abcdef\"\n---\nInput: \"aab\"\nLongest unique substring: \"ab\"\n---\nInput: \"dvdf\"\nLongest unique substring: \"vdf\"\n---", "task_id": 11155, "assertions": "void testFindLongestSubstring() {\n  assert(findLongestSubstring(\"abcabcbb\") == \"abc\");\n  assert(findLongestSubstring(\"bbbbb\") == \"b\");\n  assert(findLongestSubstring(\"pwwkew\") == \"wke\");\n  assert(findLongestSubstring(\"\") == \"\");\n  assert(findLongestSubstring(\"abcdef\") == \"abcdef\");\n  assert(findLongestSubstring(\"aab\") == \"ab\");\n  assert(findLongestSubstring(\"dvdf\") == \"vdf\");\n}\n\nvoid main() {\n  testFindLongestSubstring();\n  print(\"All tests passed!\");\n}", "all_code": "// findLongestSubstring finds the longest substring of a string that contains only unique characters.\n// It uses a sliding window approach to check for unique characters in all possible substrings.\n// Returns an empty string if the input is empty.\nString findLongestSubstring(String s) {\n  String longestSubstring = \"\";\n  \n  for (int i = 0; i < s.length; i++) {\n    String currentSubstring = \"\";\n    Set<String> seenChars = {};\n    \n    for (int j = i; j < s.length; j++) {\n      String currentChar = s[j];\n      if (seenChars.contains(currentChar)) {\n        break;\n      } else {\n        seenChars.add(currentChar);\n        currentSubstring += currentChar;\n      }\n      \n      if (currentSubstring.length > longestSubstring.length) {\n        longestSubstring = currentSubstring;\n      }\n    }\n  }\n  \n  return longestSubstring;\n}\n\nvoid testFindLongestSubstring() {\n  assert(findLongestSubstring(\"abcabcbb\") == \"abc\");\n  assert(findLongestSubstring(\"bbbbb\") == \"b\");\n  assert(findLongestSubstring(\"pwwkew\") == \"wke\");\n  assert(findLongestSubstring(\"\") == \"\");\n  assert(findLongestSubstring(\"abcdef\") == \"abcdef\");\n  assert(findLongestSubstring(\"aab\") == \"ab\");\n  assert(findLongestSubstring(\"dvdf\") == \"vdf\");\n}\n\nvoid main() {\n  testFindLongestSubstring();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// performOperations executes a series of operations on an array of integers.\n// It supports two operation types:\n//   1. Multiply elements in a range by a given factor\n//   2. Calculate the sum of elements in a range\n// The function returns a list of results for all sum operations (type 2).\nList<int> performOperations(int n, List<int> arr, List<List<int>> operations) {\n  List<int> results = [];\n  \n  for (List<int> operation in operations) {\n    int operationType = operation[0];\n    \n    if (operationType == 1) {\n      // Multiplication operation: multiply elements from index l to r by x\n      int l = operation[1];\n      int r = operation[2];\n      int x = operation[3];\n      \n      for (int i = l - 1; i < r; i++) {\n        arr[i] *= x;\n      }\n    } else if (operationType == 2) {\n      // Sum operation: calculate sum of elements from index l to r\n      int l = operation[1];\n      int r = operation[2];\n      \n      int sum = 0;\n      for (int i = l - 1; i < r; i++) {\n        sum += arr[i];\n      }\n      results.add(sum);\n    }\n  }\n  \n  return results;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInitial array: [1, 2, 3, 4, 5]\nOperations: [[1, 2, 4, 2], [2, 1, 3], [1, 1, 5, 3], [2, 2, 4]]\nResults: [11, 54]\nModified array: [3, 12, 18, 24, 15]\n\nTest Case 2:\nInitial array: [10, 20, 30, 40, 50]\nOperations: [[2, 1, 5], [2, 2, 4], [2, 3, 3]]\nResults: [150, 90, 30]\nModified array: [10, 20, 30, 40, 50] (should be unchanged)\n\nTest Case 3:\nInitial array: [1, 1, 1, 1]\nOperations: [[1, 1, 4, 5], [1, 2, 3, 2], [1, 1, 1, 10]]\nResults: [] (should be empty)\nModified array: [50, 10, 10, 5]\n\nTest Case 4:\nInitial array: [2, 0, 4, 1]\nOperations: [[1, 1, 4, 0], [2, 1, 4], [1, 2, 3, 5], [2, 2, 3], [2, 4, 4]]\nResults: [0, 0, 0]\nModified array: [0, 0, 0, 0]", "task_id": 16541, "assertions": "void testPerformOperations() {\n  // Test case 1: Basic operations\n  List<int> arr1 = [1, 2, 3, 4, 5];\n  List<List<int>> operations1 = [\n    [1, 2, 4, 2],  // Multiply indices 1-3 by 2\n    [2, 1, 3],     // Sum indices 0-2\n    [1, 1, 5, 3],  // Multiply all elements by 3\n    [2, 2, 4]      // Sum indices 1-3\n  ];\n  assert(performOperations(arr1.length, arr1, operations1).toString() == [11, 54].toString());\n  assert(arr1.toString() == [3, 12, 18, 24, 15].toString());\n\n  // Test case 2: Only sum operations\n  List<int> arr2 = [10, 20, 30, 40, 50];\n  List<List<int>> operations2 = [\n    [2, 1, 5],  // Sum all elements\n    [2, 2, 4],  // Sum indices 1-3\n    [2, 3, 3]   // Sum single element at index 2\n  ];\n  assert(performOperations(arr2.length, arr2, operations2).toString() == [150, 90, 30].toString());\n  assert(arr2.toString() == [10, 20, 30, 40, 50].toString());\n\n  // Test case 3: Only multiplication operations\n  List<int> arr3 = [1, 1, 1, 1];\n  List<List<int>> operations3 = [\n    [1, 1, 4, 5],  // Multiply all by 5\n    [1, 2, 3, 2],  // Multiply middle two by 2\n    [1, 1, 1, 10]  // Multiply first by 10\n  ];\n  assert(performOperations(arr3.length, arr3, operations3).isEmpty);\n  assert(arr3.toString() == [50, 10, 10, 5].toString());\n\n  // Test case 4: Mixed operations with edge cases\n  List<int> arr4 = [2, 0, 4, 1];\n  List<List<int>> operations4 = [\n    [1, 1, 4, 0],  // Multiply all by 0\n    [2, 1, 4],     // Sum all (should be 0)\n    [1, 2, 3, 5],  // Multiply middle two by 5\n    [2, 2, 3],     // Sum middle two\n    [2, 4, 4]      // Sum last element\n  ];\n  assert(performOperations(arr4.length, arr4, operations4).toString() == [0, 0, 0].toString());\n  assert(arr4.toString() == [0, 0, 0, 0].toString());\n}\n\nvoid main() {\n  testPerformOperations();\n}", "all_code": "// performOperations executes a series of operations on an array of integers.\n// It supports two operation types:\n//   1. Multiply elements in a range by a given factor\n//   2. Calculate the sum of elements in a range\n// The function returns a list of results for all sum operations (type 2).\nList<int> performOperations(int n, List<int> arr, List<List<int>> operations) {\n  List<int> results = [];\n  \n  for (List<int> operation in operations) {\n    int operationType = operation[0];\n    \n    if (operationType == 1) {\n      // Multiplication operation: multiply elements from index l to r by x\n      int l = operation[1];\n      int r = operation[2];\n      int x = operation[3];\n      \n      for (int i = l - 1; i < r; i++) {\n        arr[i] *= x;\n      }\n    } else if (operationType == 2) {\n      // Sum operation: calculate sum of elements from index l to r\n      int l = operation[1];\n      int r = operation[2];\n      \n      int sum = 0;\n      for (int i = l - 1; i < r; i++) {\n        sum += arr[i];\n      }\n      results.add(sum);\n    }\n  }\n  \n  return results;\n}\n\nvoid testPerformOperations() {\n  // Test case 1: Basic operations\n  List<int> arr1 = [1, 2, 3, 4, 5];\n  List<List<int>> operations1 = [\n    [1, 2, 4, 2],  // Multiply indices 1-3 by 2\n    [2, 1, 3],     // Sum indices 0-2\n    [1, 1, 5, 3],  // Multiply all elements by 3\n    [2, 2, 4]      // Sum indices 1-3\n  ];\n  assert(performOperations(arr1.length, arr1, operations1).toString() == [11, 54].toString());\n  assert(arr1.toString() == [3, 12, 18, 24, 15].toString());\n\n  // Test case 2: Only sum operations\n  List<int> arr2 = [10, 20, 30, 40, 50];\n  List<List<int>> operations2 = [\n    [2, 1, 5],  // Sum all elements\n    [2, 2, 4],  // Sum indices 1-3\n    [2, 3, 3]   // Sum single element at index 2\n  ];\n  assert(performOperations(arr2.length, arr2, operations2).toString() == [150, 90, 30].toString());\n  assert(arr2.toString() == [10, 20, 30, 40, 50].toString());\n\n  // Test case 3: Only multiplication operations\n  List<int> arr3 = [1, 1, 1, 1];\n  List<List<int>> operations3 = [\n    [1, 1, 4, 5],  // Multiply all by 5\n    [1, 2, 3, 2],  // Multiply middle two by 2\n    [1, 1, 1, 10]  // Multiply first by 10\n  ];\n  assert(performOperations(arr3.length, arr3, operations3).isEmpty);\n  assert(arr3.toString() == [50, 10, 10, 5].toString());\n\n  // Test case 4: Mixed operations with edge cases\n  List<int> arr4 = [2, 0, 4, 1];\n  List<List<int>> operations4 = [\n    [1, 1, 4, 0],  // Multiply all by 0\n    [2, 1, 4],     // Sum all (should be 0)\n    [1, 2, 3, 5],  // Multiply middle two by 5\n    [2, 2, 3],     // Sum middle two\n    [2, 4, 4]      // Sum last element\n  ];\n  assert(performOperations(arr4.length, arr4, operations4).toString() == [0, 0, 0].toString());\n  assert(arr4.toString() == [0, 0, 0, 0].toString());\n}\n\nvoid main() {\n  testPerformOperations();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:math';\n\n// Finds the length of the longest contiguous subarray with a non-negative sum.\n// \n// Parameters:\n// - n: The length of the input array.\n// - arr: The input array of integers.\n//\n// Returns:\n// The length of the longest subarray where the sum of elements is non-negative.\nint lengthOfLongestNonNegativeSumSubarray(int n, List<int> arr) {\n  int maxLen = 0;\n  int currentSum = 0;\n  int start = 0;\n\n  for (int end = 0; end < n; end++) {\n    currentSum += arr[end];\n    \n    // If current sum becomes negative, move the start pointer forward\n    while (currentSum < 0 && start <= end) {\n      currentSum -= arr[start];\n      start++;\n    }\n    \n    // Update the maximum length if current window is valid and larger\n    maxLen = maxLen > (end - start + 1) ? maxLen : (end - start + 1);\n  }\n  \n  return maxLen;\n}", "test_cases": "", "test_case_results": "Test: Standard case with positive and negative numbers\nInput: [1, -1, 5, -2, 3]\nExpected: 4\nResult: 5\nTest Failed\n---\nTest: All negative numbers\nInput: [-1, -2, -3, -4]\nExpected: 0\nResult: 0\nTest Passed\n---\nTest: All positive numbers\nInput: [1, 2, 3, 4, 5]\nExpected: 5\nResult: 5\nTest Passed\n---\nTest: All zeros\nInput: [0, 0, 0, 0, 0]\nExpected: 5\nResult: 5\nTest Passed\n---\nTest: Mixed case with multiple subarrays\nInput: [1, -2, 1, 1, -2, 1]\nExpected: 3\nResult: 4\nTest Failed\n---", "task_id": 22854, "assertions": "void testLengthOfLongestNonNegativeSumSubarray() {\n  // Test case 1: Standard case with positive and negative numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [1, -1, 5, -2, 3]) == 4);\n  \n  // Test case 2: All negative numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(4, [-1, -2, -3, -4]) == 0);\n  \n  // Test case 3: All positive numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [1, 2, 3, 4, 5]) == 5);\n  \n  // Test case 4: All zeros\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [0, 0, 0, 0, 0]) == 5);\n  \n  // Test case 5: Mixed case with multiple subarrays\n  assert(lengthOfLongestNonNegativeSumSubarray(6, [1, -2, 1, 1, -2, 1]) == 3);\n}\n\nvoid main() {\n  testLengthOfLongestNonNegativeSumSubarray();\n  print('All tests passed!');\n}", "all_code": "import 'dart:math';\n\n// Finds the length of the longest contiguous subarray with a non-negative sum.\n// \n// Parameters:\n// - n: The length of the input array.\n// - arr: The input array of integers.\n//\n// Returns:\n// The length of the longest subarray where the sum of elements is non-negative.\nint lengthOfLongestNonNegativeSumSubarray(int n, List<int> arr) {\n  int maxLen = 0;\n  int currentSum = 0;\n  int start = 0;\n\n  for (int end = 0; end < n; end++) {\n    currentSum += arr[end];\n    \n    // If current sum becomes negative, move the start pointer forward\n    while (currentSum < 0 && start <= end) {\n      currentSum -= arr[start];\n      start++;\n    }\n    \n    // Update the maximum length if current window is valid and larger\n    maxLen = maxLen > (end - start + 1) ? maxLen : (end - start + 1);\n  }\n  \n  return maxLen;\n}\n\nvoid testLengthOfLongestNonNegativeSumSubarray() {\n  // Test case 1: Standard case with positive and negative numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [1, -1, 5, -2, 3]) == 4);\n  \n  // Test case 2: All negative numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(4, [-1, -2, -3, -4]) == 0);\n  \n  // Test case 3: All positive numbers\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [1, 2, 3, 4, 5]) == 5);\n  \n  // Test case 4: All zeros\n  assert(lengthOfLongestNonNegativeSumSubarray(5, [0, 0, 0, 0, 0]) == 5);\n  \n  // Test case 5: Mixed case with multiple subarrays\n  assert(lengthOfLongestNonNegativeSumSubarray(6, [1, -2, 1, 1, -2, 1]) == 3);\n}\n\nvoid main() {\n  testLengthOfLongestNonNegativeSumSubarray();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// maxShips calculates the maximum number of ships that can be loaded with containers\n// in strictly increasing order of weights, where each ship can carry at most k containers.\n// The containers are sorted by weight first to ensure the order is maintained.\nint maxShips(int n, int k, List<int> weights) {\n  // Sort the weights to ensure they're in increasing order\n  weights.sort();\n  int ships = 0;\n  int i = 0;\n  \n  // Each ship can take up to k containers\n  while (i < n) {\n    ships++;\n    i += k;\n  }\n  \n  return ships;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 5, k: 2, weights: [3, 1, 4, 1, 5]\nMax ships: 3\n\nTest Case 2:\nn: 3, k: 5, weights: [7, 2, 4]\nMax ships: 1\n\nTest Case 3:\nn: 4, k: 1, weights: [9, 3, 6, 1]\nMax ships: 4\n\nTest Case 4:\nn: 0, k: 3, weights: []\nMax ships: 0\n\nTest Case 5:\nn: 9, k: 3, weights: [5, 2, 8, 1, 3, 7, 4, 6, 9]\nMax ships: 3", "task_id": 10020, "assertions": "void testMaxShips() {\n  assert(maxShips(5, 2, [3, 1, 4, 1, 5]) == 3);\n  assert(maxShips(3, 5, [7, 2, 4]) == 1);\n  assert(maxShips(4, 1, [9, 3, 6, 1]) == 4);\n  assert(maxShips(0, 3, []) == 0);\n  assert(maxShips(9, 3, [5, 2, 8, 1, 3, 7, 4, 6, 9]) == 3);\n}\n\nvoid main() {\n  testMaxShips();\n}", "all_code": "// maxShips calculates the maximum number of ships that can be loaded with containers\n// in strictly increasing order of weights, where each ship can carry at most k containers.\n// The containers are sorted by weight first to ensure the order is maintained.\nint maxShips(int n, int k, List<int> weights) {\n  // Sort the weights to ensure they're in increasing order\n  weights.sort();\n  int ships = 0;\n  int i = 0;\n  \n  // Each ship can take up to k containers\n  while (i < n) {\n    ships++;\n    i += k;\n  }\n  \n  return ships;\n}\n\nvoid testMaxShips() {\n  assert(maxShips(5, 2, [3, 1, 4, 1, 5]) == 3);\n  assert(maxShips(3, 5, [7, 2, 4]) == 1);\n  assert(maxShips(4, 1, [9, 3, 6, 1]) == 4);\n  assert(maxShips(0, 3, []) == 0);\n  assert(maxShips(9, 3, [5, 2, 8, 1, 3, 7, 4, 6, 9]) == 3);\n}\n\nvoid main() {\n  testMaxShips();\n}", "exec_outcome": "PASSED"}
{"code": "// minMismatches calculates the minimum number of character mismatches between\n// all possible pairs of DNA sequences in the given list.\n// \n// Parameters:\n// - n: The number of DNA sequences (not actually used in calculation)\n// - l: The length of each DNA sequence (not actually used in calculation)\n// - dnaSequences: A list of DNA sequences to compare\n//\n// Returns:\n// The minimum number of mismatches found between any pair of sequences\nint minMismatches(int n, int l, List<String> dnaSequences) {\n  int minMismatch = dnaSequences[0].length; // Initialize with maximum possible mismatches\n\n  for (int i = 0; i < dnaSequences.length; i++) {\n    for (int j = i + 1; j < dnaSequences.length; j++) {\n      int mismatchCount = 0;\n      for (int k = 0; k < dnaSequences[i].length; k++) {\n        if (dnaSequences[i][k] != dnaSequences[j][k]) {\n          mismatchCount++;\n        }\n      }\n      if (mismatchCount < minMismatch) {\n        minMismatch = mismatchCount;\n      }\n    }\n  }\n\n  return minMismatch;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 4, l: 3, sequences: [\"AGT\", \"GGT\", \"TGT\", \"ATT\"]\nMinimum mismatches: 1\n\nTest Case 2:\nn: 3, l: 2, sequences: [\"AA\", \"AA\", \"AA\"]\nMinimum mismatches: 0\n\nTest Case 3:\nn: 2, l: 3, sequences: [\"ACG\", \"TGA\"]\nMinimum mismatches: 3\n\nTest Case 4:\nn: 4, l: 4, sequences: [\"AAAA\", \"AAAT\", \"ATTT\", \"TTTT\"]\nMinimum mismatches: 1", "task_id": 12117, "assertions": "void testMinMismatches() {\n  assert(minMismatches(4, 3, [\"AGT\", \"GGT\", \"TGT\", \"ATT\"]) == 1);\n  assert(minMismatches(3, 2, [\"AA\", \"AA\", \"AA\"]) == 0);\n  assert(minMismatches(2, 3, [\"ACG\", \"TGA\"]) == 3);\n  assert(minMismatches(4, 4, [\"AAAA\", \"AAAT\", \"ATTT\", \"TTTT\"]) == 1);\n}\n\nvoid main() {\n  testMinMismatches();\n}", "all_code": "// minMismatches calculates the minimum number of character mismatches between\n// all possible pairs of DNA sequences in the given list.\n// \n// Parameters:\n// - n: The number of DNA sequences (not actually used in calculation)\n// - l: The length of each DNA sequence (not actually used in calculation)\n// - dnaSequences: A list of DNA sequences to compare\n//\n// Returns:\n// The minimum number of mismatches found between any pair of sequences\nint minMismatches(int n, int l, List<String> dnaSequences) {\n  int minMismatch = dnaSequences[0].length; // Initialize with maximum possible mismatches\n\n  for (int i = 0; i < dnaSequences.length; i++) {\n    for (int j = i + 1; j < dnaSequences.length; j++) {\n      int mismatchCount = 0;\n      for (int k = 0; k < dnaSequences[i].length; k++) {\n        if (dnaSequences[i][k] != dnaSequences[j][k]) {\n          mismatchCount++;\n        }\n      }\n      if (mismatchCount < minMismatch) {\n        minMismatch = mismatchCount;\n      }\n    }\n  }\n\n  return minMismatch;\n}\n\nvoid testMinMismatches() {\n  assert(minMismatches(4, 3, [\"AGT\", \"GGT\", \"TGT\", \"ATT\"]) == 1);\n  assert(minMismatches(3, 2, [\"AA\", \"AA\", \"AA\"]) == 0);\n  assert(minMismatches(2, 3, [\"ACG\", \"TGA\"]) == 3);\n  assert(minMismatches(4, 4, [\"AAAA\", \"AAAT\", \"ATTT\", \"TTTT\"]) == 1);\n}\n\nvoid main() {\n  testMinMismatches();\n}", "exec_outcome": "PASSED"}
{"code": "// minimumRemovalsToLuckyLine calculates the minimum number of students to remove\n// so that the remaining students form a non-decreasing sequence by height.\n// It uses dynamic programming to find the longest non-decreasing subsequence (LNDS),\n// then calculates removals as total students minus LNDS length.\nList<int> minimumRemovalsToLuckyLine(int t, List<List<dynamic>> testCases) {\n  List<int> results = [];\n  \n  for (var caseData in testCases) {\n    int n = caseData[0];\n    List<int> heights = List<int>.from(caseData[1]);\n    List<int> dp = List<int>.filled(n, 1);\n\n    for (int i = 1; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (heights[i] >= heights[j]) {\n          dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;\n        }\n      }\n    }\n\n    int longestSubsequence = dp.reduce((a, b) => a > b ? a : b);\n    results.add(n - longestSubsequence);\n  }\n  \n  return results;\n}", "test_cases": "", "test_case_results": "Testing minimumRemovalsToLuckyLine function:\n------------------------------------------\nTest Case 1:\nNumber of students: 5\nHeights: [5, 4, 3, 2, 1]\nMinimum removals needed: 4\n---\nTest Case 2:\nNumber of students: 5\nHeights: [1, 2, 3, 4, 5]\nMinimum removals needed: 0\n---\nTest Case 3:\nNumber of students: 6\nHeights: [2, 5, 3, 4, 6, 1]\nMinimum removals needed: 2\n---\nTest Case 4:\nNumber of students: 4\nHeights: [1, 1, 1, 1]\nMinimum removals needed: 0\n---\nTest Case 5:\nNumber of students: 3\nHeights: [1, 2, 1]\nMinimum removals needed: 1\n---", "task_id": 28891, "assertions": "void testMinimumRemovalsToLuckyLine() {\n  List<List<dynamic>> testCases = [\n    [5, [5, 4, 3, 2, 1]],  // All decreasing - need to remove 4\n    [5, [1, 2, 3, 4, 5]],  // Already non-decreasing - remove 0\n    [6, [2, 5, 3, 4, 6, 1]],  // Remove 2 (the 5 and 1 or other combinations)\n    [4, [1, 1, 1, 1]],  // All equal - remove 0\n    [3, [1, 2, 1]],  // Remove 1 (the last 1)\n  ];\n\n  List<int> expectedResults = [4, 0, 2, 0, 1];\n  List<int> actualResults = minimumRemovalsToLuckyLine(testCases.length, testCases);\n\n  for (int i = 0; i < testCases.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testMinimumRemovalsToLuckyLine();\n  print('All tests passed!');\n}", "all_code": "// minimumRemovalsToLuckyLine calculates the minimum number of students to remove\n// so that the remaining students form a non-decreasing sequence by height.\n// It uses dynamic programming to find the longest non-decreasing subsequence (LNDS),\n// then calculates removals as total students minus LNDS length.\nList<int> minimumRemovalsToLuckyLine(int t, List<List<dynamic>> testCases) {\n  List<int> results = [];\n  \n  for (var caseData in testCases) {\n    int n = caseData[0];\n    List<int> heights = List<int>.from(caseData[1]);\n    List<int> dp = List<int>.filled(n, 1);\n\n    for (int i = 1; i < n; i++) {\n      for (int j = 0; j < i; j++) {\n        if (heights[i] >= heights[j]) {\n          dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1;\n        }\n      }\n    }\n\n    int longestSubsequence = dp.reduce((a, b) => a > b ? a : b);\n    results.add(n - longestSubsequence);\n  }\n  \n  return results;\n}\n\nvoid testMinimumRemovalsToLuckyLine() {\n  List<List<dynamic>> testCases = [\n    [5, [5, 4, 3, 2, 1]],  // All decreasing - need to remove 4\n    [5, [1, 2, 3, 4, 5]],  // Already non-decreasing - remove 0\n    [6, [2, 5, 3, 4, 6, 1]],  // Remove 2 (the 5 and 1 or other combinations)\n    [4, [1, 1, 1, 1]],  // All equal - remove 0\n    [3, [1, 2, 1]],  // Remove 1 (the last 1)\n  ];\n\n  List<int> expectedResults = [4, 0, 2, 0, 1];\n  List<int> actualResults = minimumRemovalsToLuckyLine(testCases.length, testCases);\n\n  for (int i = 0; i < testCases.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testMinimumRemovalsToLuckyLine();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// calculateRanks determines the ranks of students based on their total marks (Math + Science),\n// with Math marks as the first tiebreaker and student name as the second tiebreaker.\n// Students are sorted in descending order of total marks, then descending Math marks,\n// and finally ascending name order.\n// Returns a list of tuples containing student names and their corresponding ranks.\nList<MapEntry<String, int>> calculateRanks(List<List<dynamic>> students) {\n  // Calculate total marks for each student and store in a new list\n  List<List<dynamic>> processedStudents = [];\n  for (var student in students) {\n    String name = student[0];\n    int mathMarks = student[1];\n    int scienceMarks = student[2];\n    int totalMarks = mathMarks + scienceMarks;\n    processedStudents.add([name, mathMarks, scienceMarks, totalMarks]);\n  }\n\n  // Sort students by total marks (desc), math marks (desc), and name (asc)\n  processedStudents.sort((a, b) {\n    if (a[3] != b[3]) {\n      return b[3].compareTo(a[3]); // Higher total comes first\n    } else if (a[1] != b[1]) {\n      return b[1].compareTo(a[1]); // Higher math comes first\n    } else {\n      return a[0].compareTo(b[0]); // Alphabetical name order\n    }\n  });\n\n  // Determine ranks with proper handling of ties\n  List<MapEntry<String, int>> result = [];\n  int rank = 1;\n  for (int i = 0; i < processedStudents.length; i++) {\n    if (i == 0) {\n      result.add(MapEntry(processedStudents[i][0], rank));\n    } else {\n      // Check if current student has same total and math marks as previous\n      if (processedStudents[i][3] == processedStudents[i-1][3] && \n          processedStudents[i][1] == processedStudents[i-1][1]) {\n        // Same rank as previous student\n        result.add(MapEntry(processedStudents[i][0], result.last.value));\n      } else {\n        // New rank (current position + 1)\n        rank = i + 1;\n        result.add(MapEntry(processedStudents[i][0], rank));\n      }\n    }\n  }\n\n  return result;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Students: [[Alice, 90, 80], [Bob, 85, 95], [Charlie, 90, 80], [David, 85, 90]]\nResults:\nBob: 1\nDavid: 2\nAlice: 3\nCharlie: 3\n\nTest Case 2:\nInput Students: [[Eve, 100, 100], [Frank, 100, 100], [Grace, 99, 99]]\nResults:\nEve: 1\nFrank: 1\nGrace: 3\n\nTest Case 3:\nInput Students: [[Xavier, 80, 70], [Yvonne, 70, 80], [Zack, 70, 70]]\nResults:\nXavier: 1\nYvonne: 2\nZack: 3", "task_id": 22275, "assertions": "void testCalculateRanks() {\n  // Test Case 1\n  var testCase1 = [\n    [\"Alice\", 90, 80],\n    [\"Bob\", 85, 95],\n    [\"Charlie\", 90, 80],\n    [\"David\", 85, 90]\n  ];\n  var result1 = calculateRanks(testCase1);\n  assert(result1[0].key == \"Bob\" && result1[0].value == 1);\n  assert(result1[1].key == \"David\" && result1[1].value == 2);\n  assert(result1[2].key == \"Alice\" && result1[2].value == 3);\n  assert(result1[3].key == \"Charlie\" && result1[3].value == 3);\n\n  // Test Case 2\n  var testCase2 = [\n    [\"Eve\", 100, 100],\n    [\"Frank\", 100, 100],\n    [\"Grace\", 99, 99]\n  ];\n  var result2 = calculateRanks(testCase2);\n  assert(result2[0].key == \"Eve\" && result2[0].value == 1);\n  assert(result2[1].key == \"Frank\" && result2[1].value == 1);\n  assert(result2[2].key == \"Grace\" && result2[2].value == 3);\n\n  // Test Case 3\n  var testCase3 = [\n    [\"Xavier\", 80, 70],\n    [\"Yvonne\", 70, 80],\n    [\"Zack\", 70, 70]\n  ];\n  var result3 = calculateRanks(testCase3);\n  assert(result3[0].key == \"Xavier\" && result3[0].value == 1);\n  assert(result3[1].key == \"Yvonne\" && result3[1].value == 2);\n  assert(result3[2].key == \"Zack\" && result3[2].value == 3);\n}\n\nvoid main() {\n  testCalculateRanks();\n  print(\"All tests passed!\");\n}", "all_code": "// calculateRanks determines the ranks of students based on their total marks (Math + Science),\n// with Math marks as the first tiebreaker and student name as the second tiebreaker.\n// Students are sorted in descending order of total marks, then descending Math marks,\n// and finally ascending name order.\n// Returns a list of tuples containing student names and their corresponding ranks.\nList<MapEntry<String, int>> calculateRanks(List<List<dynamic>> students) {\n  // Calculate total marks for each student and store in a new list\n  List<List<dynamic>> processedStudents = [];\n  for (var student in students) {\n    String name = student[0];\n    int mathMarks = student[1];\n    int scienceMarks = student[2];\n    int totalMarks = mathMarks + scienceMarks;\n    processedStudents.add([name, mathMarks, scienceMarks, totalMarks]);\n  }\n\n  // Sort students by total marks (desc), math marks (desc), and name (asc)\n  processedStudents.sort((a, b) {\n    if (a[3] != b[3]) {\n      return b[3].compareTo(a[3]); // Higher total comes first\n    } else if (a[1] != b[1]) {\n      return b[1].compareTo(a[1]); // Higher math comes first\n    } else {\n      return a[0].compareTo(b[0]); // Alphabetical name order\n    }\n  });\n\n  // Determine ranks with proper handling of ties\n  List<MapEntry<String, int>> result = [];\n  int rank = 1;\n  for (int i = 0; i < processedStudents.length; i++) {\n    if (i == 0) {\n      result.add(MapEntry(processedStudents[i][0], rank));\n    } else {\n      // Check if current student has same total and math marks as previous\n      if (processedStudents[i][3] == processedStudents[i-1][3] && \n          processedStudents[i][1] == processedStudents[i-1][1]) {\n        // Same rank as previous student\n        result.add(MapEntry(processedStudents[i][0], result.last.value));\n      } else {\n        // New rank (current position + 1)\n        rank = i + 1;\n        result.add(MapEntry(processedStudents[i][0], rank));\n      }\n    }\n  }\n\n  return result;\n}\n\nvoid testCalculateRanks() {\n  // Test Case 1\n  var testCase1 = [\n    [\"Alice\", 90, 80],\n    [\"Bob\", 85, 95],\n    [\"Charlie\", 90, 80],\n    [\"David\", 85, 90]\n  ];\n  var result1 = calculateRanks(testCase1);\n  assert(result1[0].key == \"Bob\" && result1[0].value == 1);\n  assert(result1[1].key == \"David\" && result1[1].value == 2);\n  assert(result1[2].key == \"Alice\" && result1[2].value == 3);\n  assert(result1[3].key == \"Charlie\" && result1[3].value == 3);\n\n  // Test Case 2\n  var testCase2 = [\n    [\"Eve\", 100, 100],\n    [\"Frank\", 100, 100],\n    [\"Grace\", 99, 99]\n  ];\n  var result2 = calculateRanks(testCase2);\n  assert(result2[0].key == \"Eve\" && result2[0].value == 1);\n  assert(result2[1].key == \"Frank\" && result2[1].value == 1);\n  assert(result2[2].key == \"Grace\" && result2[2].value == 3);\n\n  // Test Case 3\n  var testCase3 = [\n    [\"Xavier\", 80, 70],\n    [\"Yvonne\", 70, 80],\n    [\"Zack\", 70, 70]\n  ];\n  var result3 = calculateRanks(testCase3);\n  assert(result3[0].key == \"Xavier\" && result3[0].value == 1);\n  assert(result3[1].key == \"Yvonne\" && result3[1].value == 2);\n  assert(result3[2].key == \"Zack\" && result3[2].value == 3);\n}\n\nvoid main() {\n  testCalculateRanks();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// generateSequence creates a decorative sequence by repeating each item in the input list\n// with a count that doubles for each subsequent item (starting with N repetitions for the first item).\n// For example, with N=2 and items ['A', 'B'], it returns ['A', 'A', 'B', 'B', 'B', 'B'].\nList<String> generateSequence(int N, List<String> items) {\n  List<String> sequence = [];\n  int count = N;\n  for (String item in items) {\n    sequence.addAll(List<String>.filled(count, item));\n    count *= 2;\n  }\n  return sequence;\n}\n\n// decorativeSequences processes multiple test cases to generate decorative sequences.\n// Each test case consists of N (initial repeat count), M (unused in this implementation),\n// and a list of items to be repeated in the sequence.\nList<String> decorativeSequences(List<List<dynamic>> testCases) {\n  List<String> results = [];\n  for (List<dynamic> tc in testCases) {\n    int N = tc[0] as int;\n    // M is not used in the sequence generation, but kept for compatibility with the original\n    List<String> items = (tc[2] as List).cast<String>();\n    List<String> sequence = generateSequence(N, items);\n    results.add(sequence.join(' '));\n  }\n  return results;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput - N: 2, Items: [A, B]\nGenerated Sequence: A A B B B B\n---\nTest Case 2:\nInput - N: 1, Items: [X, Y, Z]\nGenerated Sequence: X Y Y Z Z Z Z\n---\nTest Case 3:\nInput - N: 3, Items: [Hello, World]\nGenerated Sequence: Hello Hello Hello World World World World World World\n---\nTest Case 4:\nInput - N: 1, Items: []\nGenerated Sequence: \n---", "task_id": 24140, "assertions": "void testDecorativeSequences() {\n  List<List<dynamic>> testCases = [\n    [2, 0, ['A', 'B']],          // Test case 1: Start with 2 repeats, double each time\n    [1, 0, ['X', 'Y', 'Z']],     // Test case 2: Start with 1 repeat\n    [3, 0, ['Hello', 'World']],  // Test case 3: Start with 3 repeats\n    [1, 0, []]                   // Test case 4: Empty items list (edge case)\n  ];\n\n  List<String> results = decorativeSequences(testCases);\n  \n  assert(results[0] == 'A A B B B B');\n  assert(results[1] == 'X Y Y Z Z Z Z');\n  assert(results[2] == 'Hello Hello Hello World World World World World World');\n  assert(results[3] == '');\n}\n\nvoid main() {\n  testDecorativeSequences();\n}", "all_code": "// generateSequence creates a decorative sequence by repeating each item in the input list\n// with a count that doubles for each subsequent item (starting with N repetitions for the first item).\n// For example, with N=2 and items ['A', 'B'], it returns ['A', 'A', 'B', 'B', 'B', 'B'].\nList<String> generateSequence(int N, List<String> items) {\n  List<String> sequence = [];\n  int count = N;\n  for (String item in items) {\n    sequence.addAll(List<String>.filled(count, item));\n    count *= 2;\n  }\n  return sequence;\n}\n\n// decorativeSequences processes multiple test cases to generate decorative sequences.\n// Each test case consists of N (initial repeat count), M (unused in this implementation),\n// and a list of items to be repeated in the sequence.\nList<String> decorativeSequences(List<List<dynamic>> testCases) {\n  List<String> results = [];\n  for (List<dynamic> tc in testCases) {\n    int N = tc[0] as int;\n    // M is not used in the sequence generation, but kept for compatibility with the original\n    List<String> items = (tc[2] as List).cast<String>();\n    List<String> sequence = generateSequence(N, items);\n    results.add(sequence.join(' '));\n  }\n  return results;\n}\n\nvoid testDecorativeSequences() {\n  List<List<dynamic>> testCases = [\n    [2, 0, ['A', 'B']],          // Test case 1: Start with 2 repeats, double each time\n    [1, 0, ['X', 'Y', 'Z']],     // Test case 2: Start with 1 repeat\n    [3, 0, ['Hello', 'World']],  // Test case 3: Start with 3 repeats\n    [1, 0, []]                   // Test case 4: Empty items list (edge case)\n  ];\n\n  List<String> results = decorativeSequences(testCases);\n  \n  assert(results[0] == 'A A B B B B');\n  assert(results[1] == 'X Y Y Z Z Z Z');\n  assert(results[2] == 'Hello Hello Hello World World World World World World');\n  assert(results[3] == '');\n}\n\nvoid main() {\n  testDecorativeSequences();\n}", "exec_outcome": "PASSED"}
{"code": "// calculateAverageRating computes the average rating from a list of ratings.\n// The ratings should be integers between 1 and 5 inclusive.\n// If the input list is empty, it returns 0.0.\n// The result is rounded to one decimal place.\ndouble calculateAverageRating(List<int> ratings) {\n  if (ratings.isEmpty) {\n    return 0.0;\n  }\n  \n  int sum = 0;\n  for (int rating in ratings) {\n    sum += rating;\n  }\n  \n  double average = sum / ratings.length;\n  return double.parse(average.toStringAsFixed(1));\n}", "test_cases": "", "test_case_results": "Ratings: [1, 2, 3, 4, 5]\nAverage Rating: 3.0\n---\nRatings: [5, 5, 5, 5]\nAverage Rating: 5.0\n---\nRatings: [1, 1, 1]\nAverage Rating: 1.0\n---\nRatings: []\nAverage Rating: 0.0\n---\nRatings: [3, 4, 2, 5, 4, 3]\nAverage Rating: 3.5\n---", "task_id": 9151, "assertions": "void testCalculateAverageRating() {\n  assert(calculateAverageRating([1, 2, 3, 4, 5]) == 3.0);\n  assert(calculateAverageRating([5, 5, 5, 5]) == 5.0);\n  assert(calculateAverageRating([1, 1, 1]) == 1.0);\n  assert(calculateAverageRating([]) == 0.0);\n  assert(calculateAverageRating([3, 4, 2, 5, 4, 3]) == 3.5);\n}\n\nvoid main() {\n  testCalculateAverageRating();\n}", "all_code": "// calculateAverageRating computes the average rating from a list of ratings.\n// The ratings should be integers between 1 and 5 inclusive.\n// If the input list is empty, it returns 0.0.\n// The result is rounded to one decimal place.\ndouble calculateAverageRating(List<int> ratings) {\n  if (ratings.isEmpty) {\n    return 0.0;\n  }\n  \n  int sum = 0;\n  for (int rating in ratings) {\n    sum += rating;\n  }\n  \n  double average = sum / ratings.length;\n  return double.parse(average.toStringAsFixed(1));\n}\n\nvoid testCalculateAverageRating() {\n  assert(calculateAverageRating([1, 2, 3, 4, 5]) == 3.0);\n  assert(calculateAverageRating([5, 5, 5, 5]) == 5.0);\n  assert(calculateAverageRating([1, 1, 1]) == 1.0);\n  assert(calculateAverageRating([]) == 0.0);\n  assert(calculateAverageRating([3, 4, 2, 5, 4, 3]) == 3.5);\n}\n\nvoid main() {\n  testCalculateAverageRating();\n}", "exec_outcome": "PASSED"}
{"code": "// reverseWordsAndOrder reverses each word in a given string and then reverses the order of the words.\n// It splits the input string into words, reverses each word individually, then reverses the order of these reversed words.\n// The function returns the transformed string.\nString reverseWordsAndOrder(String sentence) {\n  List<String> words = sentence.split(' ');\n  List<String> reversedWords = words.map((word) => word.split('').reversed.join()).toList();\n  String reversedOrderSentence = reversedWords.reversed.join(' ');\n  return reversedOrderSentence;\n}", "test_cases": "", "test_case_results": "Input: \"Hello world\"\nResult: \"dlrow olleH\"\n---\nInput: \"Dart programming is fun\"\nResult: \"nuf si gnimmargorp traD\"\n---\nInput: \"Reverse me please\"\nResult: \"esaelp em esreveR\"\n---\nInput: \"a b c d e\"\nResult: \"e d c b a\"\n---\nInput: \"\"\nResult: \"\"\n---", "task_id": 19238, "assertions": "void testReverseWordsAndOrder() {\n  assert(reverseWordsAndOrder(\"Hello world\") == \"dlrow olleH\");\n  assert(reverseWordsAndOrder(\"Dart programming is fun\") == \"nuf si gnimmargorp traD\");\n  assert(reverseWordsAndOrder(\"Reverse me please\") == \"esaelp em esreveR\");\n  assert(reverseWordsAndOrder(\"a b c d e\") == \"e d c b a\");\n  assert(reverseWordsAndOrder(\"\") == \"\");\n}\n\nvoid main() {\n  testReverseWordsAndOrder();\n  print(\"All tests passed!\");\n}", "all_code": "// reverseWordsAndOrder reverses each word in a given string and then reverses the order of the words.\n// It splits the input string into words, reverses each word individually, then reverses the order of these reversed words.\n// The function returns the transformed string.\nString reverseWordsAndOrder(String sentence) {\n  List<String> words = sentence.split(' ');\n  List<String> reversedWords = words.map((word) => word.split('').reversed.join()).toList();\n  String reversedOrderSentence = reversedWords.reversed.join(' ');\n  return reversedOrderSentence;\n}\n\nvoid testReverseWordsAndOrder() {\n  assert(reverseWordsAndOrder(\"Hello world\") == \"dlrow olleH\");\n  assert(reverseWordsAndOrder(\"Dart programming is fun\") == \"nuf si gnimmargorp traD\");\n  assert(reverseWordsAndOrder(\"Reverse me please\") == \"esaelp em esreveR\");\n  assert(reverseWordsAndOrder(\"a b c d e\") == \"e d c b a\");\n  assert(reverseWordsAndOrder(\"\") == \"\");\n}\n\nvoid main() {\n  testReverseWordsAndOrder();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// isPalindromicScore checks if the concatenation of two scores forms a palindromic string.\n// A palindrome reads the same forwards and backwards.\n// The function takes two string scores, concatenates them, and checks if the result is a palindrome.\n// Returns 'YES' if it's a palindrome, 'NO' otherwise.\nString isPalindromicScore(String scoreA, String scoreB) {\n  String concatenatedScore = scoreA + scoreB;\n  String reversed = concatenatedScore.split('').reversed.join('');\n  return concatenatedScore == reversed ? 'YES' : 'NO';\n}", "test_cases": "", "test_case_results": "Input: 12, 21\nResult: YES\n\nInput: 123, 456\nResult: NO\n\nInput: 5, 5\nResult: YES\n\nInput: , \nResult: YES\n\nInput: 12321, 00\nResult: NO", "task_id": 16232, "assertions": "void testIsPalindromicScore() {\n  assert(isPalindromicScore('12', '21') == 'YES');\n  assert(isPalindromicScore('123', '456') == 'NO');\n  assert(isPalindromicScore('5', '5') == 'YES');\n  assert(isPalindromicScore('', '') == 'YES');\n  assert(isPalindromicScore('12321', '00') == 'NO');\n}\n\nvoid main() {\n  testIsPalindromicScore();\n}", "all_code": "// isPalindromicScore checks if the concatenation of two scores forms a palindromic string.\n// A palindrome reads the same forwards and backwards.\n// The function takes two string scores, concatenates them, and checks if the result is a palindrome.\n// Returns 'YES' if it's a palindrome, 'NO' otherwise.\nString isPalindromicScore(String scoreA, String scoreB) {\n  String concatenatedScore = scoreA + scoreB;\n  String reversed = concatenatedScore.split('').reversed.join('');\n  return concatenatedScore == reversed ? 'YES' : 'NO';\n}\n\nvoid testIsPalindromicScore() {\n  assert(isPalindromicScore('12', '21') == 'YES');\n  assert(isPalindromicScore('123', '456') == 'NO');\n  assert(isPalindromicScore('5', '5') == 'YES');\n  assert(isPalindromicScore('', '') == 'YES');\n  assert(isPalindromicScore('12321', '00') == 'NO');\n}\n\nvoid main() {\n  testIsPalindromicScore();\n}", "exec_outcome": "PASSED"}
{"code": "double maxSumSubarray(List<int> arr, int l, int r) {\n  int n = arr.length;\n  \n  // Initialize the maximum sum variable\n  double maxSum = double.negativeInfinity;\n  \n  // Iterate through all possible subarray lengths from l to r\n  for (int length = l; length <= r; length++) {\n    // Calculate the sum of the first subarray of the current length\n    double currentSum = arr.sublist(0, length).reduce((a, b) => a + b).toDouble();\n    if (currentSum > maxSum) {\n      maxSum = currentSum;\n    }\n    \n    // Use sliding window technique to calculate the sum of the remaining subarrays\n    for (int i = length; i < n; i++) {\n      currentSum += arr[i] - arr[i - length];\n      if (currentSum > maxSum) {\n        maxSum = currentSum;\n      }\n    }\n  }\n  \n  return maxSum;\n}", "test_cases": "", "test_case_results": "Input array: [1, 2, -1, 4, 5], l: 2, r: 4\nMaximum sum: 10.0\n\nInput array: [-3, 1, -2, 4, -1, 2], l: 2, r: 3\nMaximum sum: 5.0\n\nInput array: [-2, -3, -1, -4, -5], l: 1, r: 3\nMaximum sum: -1.0\n\nInput array: [5], l: 1, r: 1\nMaximum sum: 5.0", "task_id": 23533, "assertions": "void testMaxSumSubarray() {\n  // Test case 1\n  assert(maxSumSubarray([1, 2, -1, 4, 5], 2, 4) == 10.0);\n  \n  // Test case 2\n  assert(maxSumSubarray([-3, 1, -2, 4, -1, 2], 2, 3) == 5.0);\n  \n  // Test case 3 (edge case: all negative numbers)\n  assert(maxSumSubarray([-2, -3, -1, -4, -5], 1, 3) == -1.0);\n  \n  // Test case 4 (edge case: single element array)\n  assert(maxSumSubarray([5], 1, 1) == 5.0);\n}\n\nvoid main() {\n  testMaxSumSubarray();\n}", "all_code": "double maxSumSubarray(List<int> arr, int l, int r) {\n  int n = arr.length;\n  \n  // Initialize the maximum sum variable\n  double maxSum = double.negativeInfinity;\n  \n  // Iterate through all possible subarray lengths from l to r\n  for (int length = l; length <= r; length++) {\n    // Calculate the sum of the first subarray of the current length\n    double currentSum = arr.sublist(0, length).reduce((a, b) => a + b).toDouble();\n    if (currentSum > maxSum) {\n      maxSum = currentSum;\n    }\n    \n    // Use sliding window technique to calculate the sum of the remaining subarrays\n    for (int i = length; i < n; i++) {\n      currentSum += arr[i] - arr[i - length];\n      if (currentSum > maxSum) {\n        maxSum = currentSum;\n      }\n    }\n  }\n  \n  return maxSum;\n}\n\nvoid testMaxSumSubarray() {\n  // Test case 1\n  assert(maxSumSubarray([1, 2, -1, 4, 5], 2, 4) == 10.0);\n  \n  // Test case 2\n  assert(maxSumSubarray([-3, 1, -2, 4, -1, 2], 2, 3) == 5.0);\n  \n  // Test case 3 (edge case: all negative numbers)\n  assert(maxSumSubarray([-2, -3, -1, -4, -5], 1, 3) == -1.0);\n  \n  // Test case 4 (edge case: single element array)\n  assert(maxSumSubarray([5], 1, 1) == 5.0);\n}\n\nvoid main() {\n  testMaxSumSubarray();\n}", "exec_outcome": "PASSED"}
{"code": "// maxSubgridSum calculates the maximum sum of any k x k subgrid within an n x n grid.\n// It iterates through all possible k x k subgrids, calculates their sums, and keeps track of the maximum sum found.\n// Parameters:\n//   grid: A 2D list of integers representing the grid\n//   n: The size of the grid (n x n)\n//   k: The size of the subgrid to search for (k x k)\n// Returns:\n//   The maximum sum found among all possible k x k subgrids\nint maxSubgridSum(List<List<int>> grid, int n, int k) {\n  int maxSum = 0;\n\n  // Iterate through all possible starting positions for the k x k subgrid\n  for (int i = 0; i <= n - k; i++) {\n    for (int j = 0; j <= n - k; j++) {\n      int currentSum = 0;\n      \n      // Calculate the sum of the current k x k subgrid\n      for (int l = i; l < i + k; l++) {\n        for (int m = j; m < j + k; m++) {\n          currentSum += grid[l][m];\n        }\n      }\n      \n      // Update the maximum sum if current sum is greater\n      if (currentSum > maxSum) {\n        maxSum = currentSum;\n      }\n    }\n  }\n\n  return maxSum;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nGrid: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nn: 3, k: 2\nMaximum subgrid sum: 28\n\nTest Case 2:\nGrid: [[5, 5, 5], [5, 5, 5], [5, 5, 5]]\nn: 3, k: 2\nMaximum subgrid sum: 20\n\nTest Case 3:\nGrid: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\nn: 4, k: 2\nMaximum subgrid sum: 54\n\nTest Case 4:\nGrid: [[1, 2], [3, 4]]\nn: 2, k: 2\nMaximum subgrid sum: 10", "task_id": 13742, "assertions": "void testMaxSubgridSum() {\n  // Test Case 1: Small grid with obvious maximum\n  List<List<int>> grid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ];\n  assert(maxSubgridSum(grid1, 3, 2) == 28);\n\n  // Test Case 2: All elements equal\n  List<List<int>> grid2 = [\n    [5, 5, 5],\n    [5, 5, 5],\n    [5, 5, 5]\n  ];\n  assert(maxSubgridSum(grid2, 3, 2) == 20);\n\n  // Test Case 3: Larger grid with varying values\n  List<List<int>> grid3 = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n  ];\n  assert(maxSubgridSum(grid3, 4, 2) == 54);\n\n  // Test Case 4: k equals n (entire grid is the subgrid)\n  List<List<int>> grid4 = [\n    [1, 2],\n    [3, 4]\n  ];\n  assert(maxSubgridSum(grid4, 2, 2) == 10);\n}\n\nvoid main() {\n  testMaxSubgridSum();\n}", "all_code": "// maxSubgridSum calculates the maximum sum of any k x k subgrid within an n x n grid.\n// It iterates through all possible k x k subgrids, calculates their sums, and keeps track of the maximum sum found.\n// Parameters:\n//   grid: A 2D list of integers representing the grid\n//   n: The size of the grid (n x n)\n//   k: The size of the subgrid to search for (k x k)\n// Returns:\n//   The maximum sum found among all possible k x k subgrids\nint maxSubgridSum(List<List<int>> grid, int n, int k) {\n  int maxSum = 0;\n\n  // Iterate through all possible starting positions for the k x k subgrid\n  for (int i = 0; i <= n - k; i++) {\n    for (int j = 0; j <= n - k; j++) {\n      int currentSum = 0;\n      \n      // Calculate the sum of the current k x k subgrid\n      for (int l = i; l < i + k; l++) {\n        for (int m = j; m < j + k; m++) {\n          currentSum += grid[l][m];\n        }\n      }\n      \n      // Update the maximum sum if current sum is greater\n      if (currentSum > maxSum) {\n        maxSum = currentSum;\n      }\n    }\n  }\n\n  return maxSum;\n}\n\nvoid testMaxSubgridSum() {\n  // Test Case 1: Small grid with obvious maximum\n  List<List<int>> grid1 = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n  ];\n  assert(maxSubgridSum(grid1, 3, 2) == 28);\n\n  // Test Case 2: All elements equal\n  List<List<int>> grid2 = [\n    [5, 5, 5],\n    [5, 5, 5],\n    [5, 5, 5]\n  ];\n  assert(maxSubgridSum(grid2, 3, 2) == 20);\n\n  // Test Case 3: Larger grid with varying values\n  List<List<int>> grid3 = [\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n  ];\n  assert(maxSubgridSum(grid3, 4, 2) == 54);\n\n  // Test Case 4: k equals n (entire grid is the subgrid)\n  List<List<int>> grid4 = [\n    [1, 2],\n    [3, 4]\n  ];\n  assert(maxSubgridSum(grid4, 2, 2) == 10);\n}\n\nvoid main() {\n  testMaxSubgridSum();\n}", "exec_outcome": "PASSED"}
{"code": "// hasDuplicates checks if a string contains any duplicate characters.\n// It uses a Set to track seen characters and returns true if any character appears more than once.\n// The function assumes the input string contains only lowercase English letters.\nbool hasDuplicates(String s) {\n  Set<String> seenCharacters = {};\n  for (int i = 0; i < s.length; i++) {\n    String char = s[i];\n    if (seenCharacters.contains(char)) {\n      return true;\n    }\n    seenCharacters.add(char);\n  }\n  return false;\n}", "test_cases": "", "test_case_results": "Input: \"hello\", Has duplicates: true\nInput: \"world\", Has duplicates: false\nInput: \"dart\", Has duplicates: false\nInput: \"programming\", Has duplicates: true\nInput: \"abcdefg\", Has duplicates: false\nInput: \"\", Has duplicates: false\nInput: \"a\", Has duplicates: false", "task_id": 29007, "assertions": "void testHasDuplicates() {\n  assert(hasDuplicates(\"hello\") == true);\n  assert(hasDuplicates(\"world\") == false);\n  assert(hasDuplicates(\"dart\") == false);\n  assert(hasDuplicates(\"programming\") == true);\n  assert(hasDuplicates(\"abcdefg\") == false);\n  assert(hasDuplicates(\"\") == false);\n  assert(hasDuplicates(\"a\") == false);\n}\n\nvoid main() {\n  testHasDuplicates();\n}", "all_code": "// hasDuplicates checks if a string contains any duplicate characters.\n// It uses a Set to track seen characters and returns true if any character appears more than once.\n// The function assumes the input string contains only lowercase English letters.\nbool hasDuplicates(String s) {\n  Set<String> seenCharacters = {};\n  for (int i = 0; i < s.length; i++) {\n    String char = s[i];\n    if (seenCharacters.contains(char)) {\n      return true;\n    }\n    seenCharacters.add(char);\n  }\n  return false;\n}\n\nvoid testHasDuplicates() {\n  assert(hasDuplicates(\"hello\") == true);\n  assert(hasDuplicates(\"world\") == false);\n  assert(hasDuplicates(\"dart\") == false);\n  assert(hasDuplicates(\"programming\") == true);\n  assert(hasDuplicates(\"abcdefg\") == false);\n  assert(hasDuplicates(\"\") == false);\n  assert(hasDuplicates(\"a\") == false);\n}\n\nvoid main() {\n  testHasDuplicates();\n}", "exec_outcome": "PASSED"}
{"code": "// canVisitAllPeaks determines if all peaks in a mountain range can be visited from any other peak\n// with at most 2 steps. It uses the Floyd-Warshall algorithm to compute shortest paths between\n// all pairs of peaks and checks if any path exceeds 2 steps.\nString canVisitAllPeaks(int n, int m, List<List<int>> paths) {\n  // Initialize distance matrix with infinity and 0 for same vertex pairs\n  List<List<double>> dist = List.generate(n, (_) => List.filled(n, double.infinity));\n  for (int i = 0; i < n; i++) {\n    dist[i][i] = 0;\n  }\n\n  // Populate initial distances from given paths\n  for (List<int> path in paths) {\n    int i = path[0] - 1;\n    int j = path[1] - 1;\n    dist[i][j] = 1;\n    dist[j][i] = 1;\n  }\n\n  // Floyd-Warshall algorithm to find shortest paths\n  for (int k = 0; k < n; k++) {\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  // Check if any path exceeds 2 steps\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (dist[i][j] > 2) {\n        return \"NO\";\n      }\n    }\n  }\n\n  return \"YES\";\n}", "test_cases": "", "test_case_results": "Test Case: Linear connection - should be reachable\nNumber of peaks (n): 3\nNumber of paths (m): 2\nPaths: [[1, 2], [2, 3]]\nResult: YES\n---\nTest Case: Longer linear connection - some peaks too far\nNumber of peaks (n): 4\nNumber of paths (m): 3\nPaths: [[1, 2], [2, 3], [3, 4]]\nResult: NO\n---\nTest Case: Highly connected - should be reachable\nNumber of peaks (n): 5\nNumber of paths (m): 6\nPaths: [[1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [3, 5]]\nResult: YES\n---\nTest Case: Disconnected components - should fail\nNumber of peaks (n): 4\nNumber of paths (m): 2\nPaths: [[1, 2], [3, 4]]\nResult: NO\n---", "task_id": 1632, "assertions": "void testCanVisitAllPeaks() {\n  // Test case 1: Linear connection - should be reachable\n  assert(canVisitAllPeaks(3, 2, [\n    [1, 2],\n    [2, 3]\n  ]) == \"YES\");\n\n  // Test case 2: Longer linear connection - some peaks too far\n  assert(canVisitAllPeaks(4, 3, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ]) == \"NO\");\n\n  // Test case 3: Highly connected - should be reachable\n  assert(canVisitAllPeaks(5, 6, [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5],\n    [1, 3],\n    [3, 5]\n  ]) == \"YES\");\n\n  // Test case 4: Disconnected components - should fail\n  assert(canVisitAllPeaks(4, 2, [\n    [1, 2],\n    [3, 4]\n  ]) == \"NO\");\n}\n\nvoid main() {\n  testCanVisitAllPeaks();\n  print(\"All tests passed!\");\n}", "all_code": "// canVisitAllPeaks determines if all peaks in a mountain range can be visited from any other peak\n// with at most 2 steps. It uses the Floyd-Warshall algorithm to compute shortest paths between\n// all pairs of peaks and checks if any path exceeds 2 steps.\nString canVisitAllPeaks(int n, int m, List<List<int>> paths) {\n  // Initialize distance matrix with infinity and 0 for same vertex pairs\n  List<List<double>> dist = List.generate(n, (_) => List.filled(n, double.infinity));\n  for (int i = 0; i < n; i++) {\n    dist[i][i] = 0;\n  }\n\n  // Populate initial distances from given paths\n  for (List<int> path in paths) {\n    int i = path[0] - 1;\n    int j = path[1] - 1;\n    dist[i][j] = 1;\n    dist[j][i] = 1;\n  }\n\n  // Floyd-Warshall algorithm to find shortest paths\n  for (int k = 0; k < n; k++) {\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  // Check if any path exceeds 2 steps\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (dist[i][j] > 2) {\n        return \"NO\";\n      }\n    }\n  }\n\n  return \"YES\";\n}\n\nvoid testCanVisitAllPeaks() {\n  // Test case 1: Linear connection - should be reachable\n  assert(canVisitAllPeaks(3, 2, [\n    [1, 2],\n    [2, 3]\n  ]) == \"YES\");\n\n  // Test case 2: Longer linear connection - some peaks too far\n  assert(canVisitAllPeaks(4, 3, [\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ]) == \"NO\");\n\n  // Test case 3: Highly connected - should be reachable\n  assert(canVisitAllPeaks(5, 6, [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n    [4, 5],\n    [1, 3],\n    [3, 5]\n  ]) == \"YES\");\n\n  // Test case 4: Disconnected components - should fail\n  assert(canVisitAllPeaks(4, 2, [\n    [1, 2],\n    [3, 4]\n  ]) == \"NO\");\n}\n\nvoid main() {\n  testCanVisitAllPeaks();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// maxKnights calculates the maximum number of knights that can be placed on an R x C chessboard\n// without any two knights threatening each other.\n// The logic follows these rules:\n// - For 1 row or column, all squares can be filled (R*C)\n// - For 2 rows or columns, every other square can be filled (rounded up)\n// - For larger boards, half the squares can be filled (rounded up)\nint maxKnights(int R, int C) {\n  if (R == 1 || C == 1) {\n    return R * C;\n  }\n  if (R == 2 || C == 2) {\n    return (R * C + 1) ~/ 2;\n  }\n  return (R * C + 1) ~/ 2;\n}\n\n// solve processes multiple test cases and returns a list of results\nList<int> solve(List<List<int>> testCases) {\n  List<int> results = [];\n  for (List<int> testCase in testCases) {\n    results.add(maxKnights(testCase[0], testCase[1]));\n  }\n  return results;\n}", "test_cases": "", "test_case_results": "Board 1 x 1: 1 knights\nBoard 2 x 3: 3 knights\nBoard 4 x 4: 8 knights\nBoard 1 x 8: 8 knights\nBoard 3 x 2: 3 knights\nBoard 5 x 5: 13 knights\n\nAll results: [1, 3, 8, 8, 3, 13]", "task_id": 9323, "assertions": "void testMaxKnights() {\n  // Test cases from the original main function\n  assert(maxKnights(1, 1) == 1);\n  assert(maxKnights(2, 3) == 3);\n  assert(maxKnights(4, 4) == 8);\n  assert(maxKnights(1, 8) == 8);\n  assert(maxKnights(3, 2) == 3);\n  assert(maxKnights(5, 5) == 13);\n\n  // Test the solve function with batch processing\n  List<List<int>> testCases = [\n    [1, 1], [2, 3], [4, 4], [1, 8], [3, 2], [5, 5]\n  ];\n  List<int> expectedResults = [1, 3, 8, 8, 3, 13];\n  assert(solve(testCases).toString() == expectedResults.toString());\n}\n\nvoid main() {\n  testMaxKnights();\n  print('All tests passed!');\n}", "all_code": "// maxKnights calculates the maximum number of knights that can be placed on an R x C chessboard\n// without any two knights threatening each other.\n// The logic follows these rules:\n// - For 1 row or column, all squares can be filled (R*C)\n// - For 2 rows or columns, every other square can be filled (rounded up)\n// - For larger boards, half the squares can be filled (rounded up)\nint maxKnights(int R, int C) {\n  if (R == 1 || C == 1) {\n    return R * C;\n  }\n  if (R == 2 || C == 2) {\n    return (R * C + 1) ~/ 2;\n  }\n  return (R * C + 1) ~/ 2;\n}\n\n// solve processes multiple test cases and returns a list of results\nList<int> solve(List<List<int>> testCases) {\n  List<int> results = [];\n  for (List<int> testCase in testCases) {\n    results.add(maxKnights(testCase[0], testCase[1]));\n  }\n  return results;\n}\n\nvoid testMaxKnights() {\n  // Test cases from the original main function\n  assert(maxKnights(1, 1) == 1);\n  assert(maxKnights(2, 3) == 3);\n  assert(maxKnights(4, 4) == 8);\n  assert(maxKnights(1, 8) == 8);\n  assert(maxKnights(3, 2) == 3);\n  assert(maxKnights(5, 5) == 13);\n\n  // Test the solve function with batch processing\n  List<List<int>> testCases = [\n    [1, 1], [2, 3], [4, 4], [1, 8], [3, 2], [5, 5]\n  ];\n  List<int> expectedResults = [1, 3, 8, 8, 3, 13];\n  assert(solve(testCases).toString() == expectedResults.toString());\n}\n\nvoid main() {\n  testMaxKnights();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// isPathExist checks if there's a path between source and target vertices in a graph.\n// It uses Depth-First Search (DFS) to traverse the graph and find the path.\n// vertexCount: total number of vertices in the graph\n// edges: list of directed edges as pairs of vertices\n// source: starting vertex\n// target: destination vertex\n// Returns true if a path exists, false otherwise.\nbool isPathExist(int vertexCount, List<List<int>> edges, int source, int target) {\n  if (source == target) {\n    return true;\n  }\n\n  // Build adjacency list representation of the graph\n  Map<int, List<int>> graph = {};\n  for (int i = 0; i < vertexCount; i++) {\n    graph[i] = [];\n  }\n  for (List<int> edge in edges) {\n    int u = edge[0];\n    int v = edge[1];\n    graph[u]!.add(v);\n  }\n\n  // DFS function to traverse the graph\n  bool dfs(int node, Set<int> visited) {\n    if (node == target) {\n      return true;\n    }\n    visited.add(node);\n    for (int neighbor in graph[node]!) {\n      if (!visited.contains(neighbor)) {\n        if (dfs(neighbor, visited)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  return dfs(source, <int>{});\n}", "test_cases": "", "test_case_results": "Test Case:\nVertex count: 3\nEdges: [[0, 1], [1, 2]]\nSource: 0, Target: 2\nPath exists: true\n---\nTest Case:\nVertex count: 4\nEdges: [[0, 1], [2, 3]]\nSource: 0, Target: 3\nPath exists: false\n---\nTest Case:\nVertex count: 5\nEdges: [[0, 1], [1, 2], [2, 3], [3, 4]]\nSource: 0, Target: 4\nPath exists: true\n---\nTest Case:\nVertex count: 3\nEdges: [[0, 1], [1, 0], [1, 2]]\nSource: 0, Target: 2\nPath exists: true\n---\nTest Case:\nVertex count: 3\nEdges: [[0, 1]]\nSource: 0, Target: 2\nPath exists: false\n---", "task_id": 25442, "assertions": "void testIsPathExist() {\n  // Test case 1: Simple path exists\n  assert(isPathExist(3, [\n    [0, 1],\n    [1, 2]\n  ], 0, 2) == true);\n\n  // Test case 2: No path exists (disconnected components)\n  assert(isPathExist(4, [\n    [0, 1],\n    [2, 3]\n  ], 0, 3) == false);\n\n  // Test case 3: Long path exists\n  assert(isPathExist(5, [\n    [0, 1],\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ], 0, 4) == true);\n\n  // Test case 4: Path exists with cycle\n  assert(isPathExist(3, [\n    [0, 1],\n    [1, 0],\n    [1, 2]\n  ], 0, 2) == true);\n\n  // Test case 5: No path exists\n  assert(isPathExist(3, [\n    [0, 1]\n  ], 0, 2) == false);\n}\n\nvoid main() {\n  testIsPathExist();\n  print('All tests passed!');\n}", "all_code": "// isPathExist checks if there's a path between source and target vertices in a graph.\n// It uses Depth-First Search (DFS) to traverse the graph and find the path.\n// vertexCount: total number of vertices in the graph\n// edges: list of directed edges as pairs of vertices\n// source: starting vertex\n// target: destination vertex\n// Returns true if a path exists, false otherwise.\nbool isPathExist(int vertexCount, List<List<int>> edges, int source, int target) {\n  if (source == target) {\n    return true;\n  }\n\n  // Build adjacency list representation of the graph\n  Map<int, List<int>> graph = {};\n  for (int i = 0; i < vertexCount; i++) {\n    graph[i] = [];\n  }\n  for (List<int> edge in edges) {\n    int u = edge[0];\n    int v = edge[1];\n    graph[u]!.add(v);\n  }\n\n  // DFS function to traverse the graph\n  bool dfs(int node, Set<int> visited) {\n    if (node == target) {\n      return true;\n    }\n    visited.add(node);\n    for (int neighbor in graph[node]!) {\n      if (!visited.contains(neighbor)) {\n        if (dfs(neighbor, visited)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  return dfs(source, <int>{});\n}\n\nvoid testIsPathExist() {\n  // Test case 1: Simple path exists\n  assert(isPathExist(3, [\n    [0, 1],\n    [1, 2]\n  ], 0, 2) == true);\n\n  // Test case 2: No path exists (disconnected components)\n  assert(isPathExist(4, [\n    [0, 1],\n    [2, 3]\n  ], 0, 3) == false);\n\n  // Test case 3: Long path exists\n  assert(isPathExist(5, [\n    [0, 1],\n    [1, 2],\n    [2, 3],\n    [3, 4]\n  ], 0, 4) == true);\n\n  // Test case 4: Path exists with cycle\n  assert(isPathExist(3, [\n    [0, 1],\n    [1, 0],\n    [1, 2]\n  ], 0, 2) == true);\n\n  // Test case 5: No path exists\n  assert(isPathExist(3, [\n    [0, 1]\n  ], 0, 2) == false);\n}\n\nvoid main() {\n  testIsPathExist();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// sumMatrix calculates the sum of all numeric elements in a 2D matrix (list of lists).\n// It iterates through each element in each row of the matrix and adds numeric values to the total sum.\n// Non-numeric elements are skipped during the summation process.\ndouble sumMatrix(List<List<dynamic>> matrix) {\n  double totalSum = 0;\n  for (List<dynamic> row in matrix) {\n    for (dynamic element in row) {\n      if (element is num) {\n        totalSum += element.toDouble();\n      }\n    }\n  }\n  return totalSum;\n}", "test_cases": "", "test_case_results": "Input Matrix: [[1, 2, 3], [4, 5, 6]]\nSum: 21.0\n---\nInput Matrix: [[1, 2.5, 3], [4.2, 5, 6.7]]\nSum: 22.4\n---\nInput Matrix: [[1, a, 3], [4, null, 6]]\nSum: 14.0\n---\nInput Matrix: [[]]\nSum: 0.0\n---\nInput Matrix: [[42]]\nSum: 42.0\n---", "task_id": 16556, "assertions": "void testSumMatrix() {\n  // Simple integer matrix\n  assert(sumMatrix([\n    [1, 2, 3],\n    [4, 5, 6]\n  ]) == 21.0);\n  \n  // Mixed numeric types\n  assert(sumMatrix([\n    [1, 2.5, 3],\n    [4.2, 5, 6.7]\n  ]) == 22.4);\n  \n  // Matrix with non-numeric elements\n  assert(sumMatrix([\n    [1, 'a', 3],\n    [4, null, 6]\n  ]) == 14.0);\n  \n  // Empty matrix\n  assert(sumMatrix([[]]) == 0.0);\n  \n  // Single element matrix\n  assert(sumMatrix([\n    [42]\n  ]) == 42.0);\n}\n\nvoid main() {\n  testSumMatrix();\n}", "all_code": "// sumMatrix calculates the sum of all numeric elements in a 2D matrix (list of lists).\n// It iterates through each element in each row of the matrix and adds numeric values to the total sum.\n// Non-numeric elements are skipped during the summation process.\ndouble sumMatrix(List<List<dynamic>> matrix) {\n  double totalSum = 0;\n  for (List<dynamic> row in matrix) {\n    for (dynamic element in row) {\n      if (element is num) {\n        totalSum += element.toDouble();\n      }\n    }\n  }\n  return totalSum;\n}\n\nvoid testSumMatrix() {\n  // Simple integer matrix\n  assert(sumMatrix([\n    [1, 2, 3],\n    [4, 5, 6]\n  ]) == 21.0);\n  \n  // Mixed numeric types\n  assert(sumMatrix([\n    [1, 2.5, 3],\n    [4.2, 5, 6.7]\n  ]) == 22.4);\n  \n  // Matrix with non-numeric elements\n  assert(sumMatrix([\n    [1, 'a', 3],\n    [4, null, 6]\n  ]) == 14.0);\n  \n  // Empty matrix\n  assert(sumMatrix([[]]) == 0.0);\n  \n  // Single element matrix\n  assert(sumMatrix([\n    [42]\n  ]) == 42.0);\n}\n\nvoid main() {\n  testSumMatrix();\n}", "exec_outcome": "PASSED"}
{"code": "// Checks if all planets ('.' cells) in an n x n grid are connected.\n// Uses Depth-First Search (DFS) to explore connected components.\n// Returns \"YES\" if all planets are connected, \"NO\" otherwise.\nString isAllPlanetsConnected(int n, List<List<String>> grid) {\n  // Nested DFS function to mark connected cells\n  void dfs(int x, int y) {\n    if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] != '.') {\n      return;\n    }\n    grid[x][y] = '#'; // Mark as visited\n    // Explore adjacent cells\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n  }\n\n  int components = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == '.') {\n        if (components > 0) {\n          // Found another component - not all connected\n          return \"NO\";\n        }\n        dfs(i, j);\n        components++;\n      }\n    }\n  }\n  return components == 1 ? \"YES\" : \"NO\";\n}", "test_cases": "", "test_case_results": "Test case:\nGrid size: 3\nGrid:\n[., ., .]\n[., ., .]\n[., ., .]\nResult: YES\nExpected: YES\n---\nTest case:\nGrid size: 3\nGrid:\n[., #, .]\n[#, ., #]\n[., #, .]\nResult: NO\nExpected: NO\n---\nTest case:\nGrid size: 4\nGrid:\n[., ., #, #]\n[., #, #, #]\n[#, #, ., .]\n[#, #, ., .]\nResult: NO\nExpected: NO\n---\nTest case:\nGrid size: 2\nGrid:\n[#, #]\n[#, .]\nResult: YES\nExpected: YES\n---", "task_id": 2436, "assertions": "void testIsAllPlanetsConnected() {\n  // Test case 1: All connected\n  assert(isAllPlanetsConnected(3, [\n    ['.', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n  ]) == \"YES\");\n\n  // Test case 2: Not connected\n  assert(isAllPlanetsConnected(3, [\n    ['.', '#', '.'],\n    ['#', '.', '#'],\n    ['.', '#', '.']\n  ]) == \"NO\");\n\n  // Test case 3: Not connected\n  assert(isAllPlanetsConnected(4, [\n    ['.', '.', '#', '#'],\n    ['.', '#', '#', '#'],\n    ['#', '#', '.', '.'],\n    ['#', '#', '.', '.']\n  ]) == \"NO\");\n\n  // Test case 4: Single planet connected\n  assert(isAllPlanetsConnected(2, [\n    ['#', '#'],\n    ['#', '.']\n  ]) == \"YES\");\n}\n\nvoid main() {\n  testIsAllPlanetsConnected();\n  print(\"All tests passed!\");\n}", "all_code": "// Checks if all planets ('.' cells) in an n x n grid are connected.\n// Uses Depth-First Search (DFS) to explore connected components.\n// Returns \"YES\" if all planets are connected, \"NO\" otherwise.\nString isAllPlanetsConnected(int n, List<List<String>> grid) {\n  // Nested DFS function to mark connected cells\n  void dfs(int x, int y) {\n    if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] != '.') {\n      return;\n    }\n    grid[x][y] = '#'; // Mark as visited\n    // Explore adjacent cells\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n  }\n\n  int components = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (grid[i][j] == '.') {\n        if (components > 0) {\n          // Found another component - not all connected\n          return \"NO\";\n        }\n        dfs(i, j);\n        components++;\n      }\n    }\n  }\n  return components == 1 ? \"YES\" : \"NO\";\n}\n\nvoid testIsAllPlanetsConnected() {\n  // Test case 1: All connected\n  assert(isAllPlanetsConnected(3, [\n    ['.', '.', '.'],\n    ['.', '.', '.'],\n    ['.', '.', '.']\n  ]) == \"YES\");\n\n  // Test case 2: Not connected\n  assert(isAllPlanetsConnected(3, [\n    ['.', '#', '.'],\n    ['#', '.', '#'],\n    ['.', '#', '.']\n  ]) == \"NO\");\n\n  // Test case 3: Not connected\n  assert(isAllPlanetsConnected(4, [\n    ['.', '.', '#', '#'],\n    ['.', '#', '#', '#'],\n    ['#', '#', '.', '.'],\n    ['#', '#', '.', '.']\n  ]) == \"NO\");\n\n  // Test case 4: Single planet connected\n  assert(isAllPlanetsConnected(2, [\n    ['#', '#'],\n    ['#', '.']\n  ]) == \"YES\");\n}\n\nvoid main() {\n  testIsAllPlanetsConnected();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// remainingLettersAfterDeletions calculates the number of letters remaining in a string\n// after repeatedly deleting any two adjacent letters that are the same.\n// It uses a stack-based approach to efficiently process the string.\nint remainingLettersAfterDeletions(String s) {\n  List<String> stack = [];\n  for (int i = 0; i < s.length; i++) {\n    String char = s[i];\n    if (stack.isNotEmpty && stack.last == char) {\n      stack.removeLast();\n    } else {\n      stack.add(char);\n    }\n  }\n  return stack.length;\n}\n\n// processTestCases processes multiple test cases using remainingLettersAfterDeletions\n// and returns a list of results for each test case.\nList<int> processTestCases(List<String> testCases) {\n  List<int> results = [];\n  for (String s in testCases) {\n    results.add(remainingLettersAfterDeletions(s));\n  }\n  return results;\n}", "test_cases": "", "test_case_results": "Testing individual strings:\nInput: 'aab' => Remaining letters: 1\nInput: 'abba' => Remaining letters: 0\nInput: 'aaaa' => Remaining letters: 0\nInput: 'abcabc' => Remaining letters: 6\nInput: '' => Remaining letters: 0\nInput: 'a' => Remaining letters: 1\n\nTesting batch processing:\nInput: 'aabbcc' => Remaining letters: 0\nInput: 'aaabbbccc' => Remaining letters: 3\nInput: 'xyyx' => Remaining letters: 0\nInput: 'xxyyzz' => Remaining letters: 0\nInput: 'xxyyz' => Remaining letters: 1", "task_id": 15611, "assertions": "void testRemainingLettersAfterDeletions() {\n  // Test individual cases\n  assert(remainingLettersAfterDeletions(\"aab\") == 1);\n  assert(remainingLettersAfterDeletions(\"abba\") == 0);\n  assert(remainingLettersAfterDeletions(\"aaaa\") == 0);\n  assert(remainingLettersAfterDeletions(\"abcabc\") == 6);\n  assert(remainingLettersAfterDeletions(\"\") == 0);\n  assert(remainingLettersAfterDeletions(\"a\") == 1);\n\n  // Test batch processing\n  List<String> batchTestCases = [\n    \"aabbcc\",\n    \"aaabbbccc\",\n    \"xyyx\",\n    \"xxyyzz\",\n    \"xxyyz\",\n  ];\n  List<int> expectedResults = [0, 3, 0, 0, 1];\n  List<int> actualResults = processTestCases(batchTestCases);\n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testRemainingLettersAfterDeletions();\n  print(\"All tests passed!\");\n}", "all_code": "// remainingLettersAfterDeletions calculates the number of letters remaining in a string\n// after repeatedly deleting any two adjacent letters that are the same.\n// It uses a stack-based approach to efficiently process the string.\nint remainingLettersAfterDeletions(String s) {\n  List<String> stack = [];\n  for (int i = 0; i < s.length; i++) {\n    String char = s[i];\n    if (stack.isNotEmpty && stack.last == char) {\n      stack.removeLast();\n    } else {\n      stack.add(char);\n    }\n  }\n  return stack.length;\n}\n\n// processTestCases processes multiple test cases using remainingLettersAfterDeletions\n// and returns a list of results for each test case.\nList<int> processTestCases(List<String> testCases) {\n  List<int> results = [];\n  for (String s in testCases) {\n    results.add(remainingLettersAfterDeletions(s));\n  }\n  return results;\n}\n\nvoid testRemainingLettersAfterDeletions() {\n  // Test individual cases\n  assert(remainingLettersAfterDeletions(\"aab\") == 1);\n  assert(remainingLettersAfterDeletions(\"abba\") == 0);\n  assert(remainingLettersAfterDeletions(\"aaaa\") == 0);\n  assert(remainingLettersAfterDeletions(\"abcabc\") == 6);\n  assert(remainingLettersAfterDeletions(\"\") == 0);\n  assert(remainingLettersAfterDeletions(\"a\") == 1);\n\n  // Test batch processing\n  List<String> batchTestCases = [\n    \"aabbcc\",\n    \"aaabbbccc\",\n    \"xyyx\",\n    \"xxyyzz\",\n    \"xxyyz\",\n  ];\n  List<int> expectedResults = [0, 3, 0, 0, 1];\n  List<int> actualResults = processTestCases(batchTestCases);\n  for (int i = 0; i < expectedResults.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testRemainingLettersAfterDeletions();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "int maxSimultaneousSessions(List<List<int>> sessions) {\n  // Create a list to hold all events (start and end points)\n  List<List<dynamic>> events = [];\n  \n  // Convert each session into start and end events\n  for (List<int> session in sessions) {\n    int start = session[0];\n    int end = session[1];\n    events.add([start, 'start']);\n    events.add([end + 1, 'end']);  // end + 1 to make intervals inclusive\n  }\n\n  // Sort events by time, with 'end' events coming before 'start' at the same time\n  events.sort((a, b) {\n    if (a[0] == b[0]) {\n      // For same time, 'end' comes before 'start'\n      return a[1].compareTo(b[1]);\n    }\n    return a[0].compareTo(b[0]);\n  });\n\n  int currentSessions = 0;\n  int maxSessions = 0;\n\n  // Process each event to track session count\n  for (List<dynamic> event in events) {\n    if (event[1] == 'start') {\n      currentSessions++;\n      if (currentSessions > maxSessions) {\n        maxSessions = currentSessions;\n      }\n    } else {\n      currentSessions--;\n    }\n  }\n\n  return maxSessions;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Sessions: [[1, 5], [3, 7], [2, 4]]\nMaximum Simultaneous Sessions: 3\n---\nTest Case 2:\nInput Sessions: [[1, 2], [3, 4], [5, 6]]\nMaximum Simultaneous Sessions: 1\n---\nTest Case 3:\nInput Sessions: [[1, 10], [2, 3], [4, 5], [6, 7]]\nMaximum Simultaneous Sessions: 2\n---\nTest Case 4:\nInput Sessions: [[1, 5], [5, 10]]\nMaximum Simultaneous Sessions: 2\n---\nTest Case 5:\nInput Sessions: []\nMaximum Simultaneous Sessions: 0\n---\nTest Case 6:\nInput Sessions: [[1, 1]]\nMaximum Simultaneous Sessions: 1\n---\nTest Case 7:\nInput Sessions: [[1, 5], [1, 5], [1, 5]]\nMaximum Simultaneous Sessions: 3\n---", "task_id": 22519, "assertions": "void testMaxSimultaneousSessions() {\n  assert(maxSimultaneousSessions([[1, 5], [3, 7], [2, 4]]) == 3);\n  assert(maxSimultaneousSessions([[1, 2], [3, 4], [5, 6]]) == 1);\n  assert(maxSimultaneousSessions([[1, 10], [2, 3], [4, 5], [6, 7]]) == 2);\n  assert(maxSimultaneousSessions([[1, 5], [5, 10]]) == 2);\n  assert(maxSimultaneousSessions([]) == 0);\n  assert(maxSimultaneousSessions([[1, 1]]) == 1);\n  assert(maxSimultaneousSessions([[1, 5], [1, 5], [1, 5]]) == 3);\n}\n\nvoid main() {\n  testMaxSimultaneousSessions();\n  print('All tests passed!');\n}", "all_code": "int maxSimultaneousSessions(List<List<int>> sessions) {\n  // Create a list to hold all events (start and end points)\n  List<List<dynamic>> events = [];\n  \n  // Convert each session into start and end events\n  for (List<int> session in sessions) {\n    int start = session[0];\n    int end = session[1];\n    events.add([start, 'start']);\n    events.add([end + 1, 'end']);  // end + 1 to make intervals inclusive\n  }\n\n  // Sort events by time, with 'end' events coming before 'start' at the same time\n  events.sort((a, b) {\n    if (a[0] == b[0]) {\n      // For same time, 'end' comes before 'start'\n      return a[1].compareTo(b[1]);\n    }\n    return a[0].compareTo(b[0]);\n  });\n\n  int currentSessions = 0;\n  int maxSessions = 0;\n\n  // Process each event to track session count\n  for (List<dynamic> event in events) {\n    if (event[1] == 'start') {\n      currentSessions++;\n      if (currentSessions > maxSessions) {\n        maxSessions = currentSessions;\n      }\n    } else {\n      currentSessions--;\n    }\n  }\n\n  return maxSessions;\n}\n\nvoid testMaxSimultaneousSessions() {\n  assert(maxSimultaneousSessions([[1, 5], [3, 7], [2, 4]]) == 3);\n  assert(maxSimultaneousSessions([[1, 2], [3, 4], [5, 6]]) == 1);\n  assert(maxSimultaneousSessions([[1, 10], [2, 3], [4, 5], [6, 7]]) == 2);\n  assert(maxSimultaneousSessions([[1, 5], [5, 10]]) == 2);\n  assert(maxSimultaneousSessions([]) == 0);\n  assert(maxSimultaneousSessions([[1, 1]]) == 1);\n  assert(maxSimultaneousSessions([[1, 5], [1, 5], [1, 5]]) == 3);\n}\n\nvoid main() {\n  testMaxSimultaneousSessions();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// countVowels takes a list of strings and returns a map with the strings as keys\n// and the number of vowels in each string as values. The counting is case-insensitive.\nMap<String, int> countVowels(List<String> strings) {\n  // Helper function to count vowels in a single string\n  int vowelCount(String s) {\n    const vowels = 'aeiou';\n    int count = 0;\n    for (var char in s.toLowerCase().runes) {\n      if (vowels.contains(String.fromCharCode(char))) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // Create the result map by applying vowelCount to each string\n  final result = <String, int>{};\n  for (var s in strings) {\n    result[s] = vowelCount(s);\n  }\n  return result;\n}", "test_cases": "", "test_case_results": "Input: [hello, world, Dart]\nVowel counts: {hello: 2, world: 1, Dart: 1}\n---\nInput: [AEIOU, aeiou, xyz]\nVowel counts: {AEIOU: 5, aeiou: 5, xyz: 0}\n---\nInput: [, Testing, VOWELS]\nVowel counts: {: 0, Testing: 2, VOWELS: 2}\n---\nInput: [The quick brown fox, jumps over, the lazy dog]\nVowel counts: {The quick brown fox: 5, jumps over: 3, the lazy dog: 3}\n---", "task_id": 10617, "assertions": "void testCountVowels() {\n  assert(countVowels(['hello', 'world', 'Dart']) == {'hello': 2, 'world': 1, 'Dart': 1});\n  assert(countVowels(['AEIOU', 'aeiou', 'xyz']) == {'AEIOU': 5, 'aeiou': 5, 'xyz': 0});\n  assert(countVowels(['', 'Testing', 'VOWELS']) == {'': 0, 'Testing': 2, 'VOWELS': 2});\n  assert(countVowels(['The quick brown fox', 'jumps over', 'the lazy dog']) == \n      {'The quick brown fox': 5, 'jumps over': 3, 'the lazy dog': 3});\n}\n\nvoid main() {\n  testCountVowels();\n}", "all_code": "// countVowels takes a list of strings and returns a map with the strings as keys\n// and the number of vowels in each string as values. The counting is case-insensitive.\nMap<String, int> countVowels(List<String> strings) {\n  // Helper function to count vowels in a single string\n  int vowelCount(String s) {\n    const vowels = 'aeiou';\n    int count = 0;\n    for (var char in s.toLowerCase().runes) {\n      if (vowels.contains(String.fromCharCode(char))) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // Create the result map by applying vowelCount to each string\n  final result = <String, int>{};\n  for (var s in strings) {\n    result[s] = vowelCount(s);\n  }\n  return result;\n}\n\nvoid testCountVowels() {\n  assert(countVowels(['hello', 'world', 'Dart']) == {'hello': 2, 'world': 1, 'Dart': 1});\n  assert(countVowels(['AEIOU', 'aeiou', 'xyz']) == {'AEIOU': 5, 'aeiou': 5, 'xyz': 0});\n  assert(countVowels(['', 'Testing', 'VOWELS']) == {'': 0, 'Testing': 2, 'VOWELS': 2});\n  assert(countVowels(['The quick brown fox', 'jumps over', 'the lazy dog']) == \n      {'The quick brown fox': 5, 'jumps over': 3, 'the lazy dog': 3});\n}\n\nvoid main() {\n  testCountVowels();\n}", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// minChanges calculates the minimum number of changes required to make a string alternate between 'A' and 'B'.\n// It checks two possible patterns: one starting with 'A' and the other starting with 'B'.\n// For each character in the string, it compares the character with the expected value in both patterns.\n// The function returns the minimum number of changes required between the two patterns.\nint minChanges(String s) {\n  int change1 = 0; // Changes needed to make string alternate starting with 'A'\n  int change2 = 0; // Changes needed to make string alternate starting with 'B'\n\n  for (int i = 0; i < s.length; i++) {\n    if (i % 2 == 0) {\n      if (s[i] != 'A') { // Expect 'A' at even index positions\n        change1 += 1;\n      }\n      if (s[i] != 'B') { // Expect 'B' at even index positions\n        change2 += 1;\n      }\n    } else {\n      if (s[i] != 'B') { // Expect 'B' at odd index positions\n        change1 += 1;\n      }\n      if (s[i] != 'A') { // Expect 'A' at odd index positions\n        change2 += 1;\n      }\n    }\n  }\n\n  return change1 < change2 ? change1 : change2;\n}", "test_cases": "", "test_case_results": "Input: \"A\"\nMinimum changes required: 0\nInput: \"B\"\nMinimum changes required: 0\nInput: \"AA\"\nMinimum changes required: 1\nInput: \"BB\"\nMinimum changes required: 1\nInput: \"AB\"\nMinimum changes required: 0\nInput: \"BA\"\nMinimum changes required: 0\nInput: \"AAB\"\nMinimum changes required: 1\nInput: \"BBA\"\nMinimum changes required: 1\nInput: \"ABA\"\nMinimum changes required: 0\nInput: \"BAB\"\nMinimum changes required: 0\nInput: \"AAAA\"\nMinimum changes required: 2\nInput: \"BBBB\"\nMinimum changes required: 2\nInput: \"ABAB\"\nMinimum changes required: 0\nInput: \"BABA\"\nMinimum changes required: 0", "task_id": 25888, "assertions": "void testMinChanges() {\n  assert(minChanges('A') == 0);\n  assert(minChanges('B') == 0);\n  assert(minChanges('AA') == 1);\n  assert(minChanges('BB') == 1);\n  assert(minChanges('AB') == 0);\n  assert(minChanges('BA') == 0);\n  assert(minChanges('AAB') == 1);\n  assert(minChanges('BBA') == 1);\n  assert(minChanges('ABA') == 0);\n  assert(minChanges('BAB') == 0);\n  assert(minChanges('AAAA') == 2);\n  assert(minChanges('BBBB') == 2);\n  assert(minChanges('ABAB') == 0);\n  assert(minChanges('BABA') == 0);\n}\n\nvoid main() {\n  testMinChanges();\n}", "all_code": "// minChanges calculates the minimum number of changes required to make a string alternate between 'A' and 'B'.\n// It checks two possible patterns: one starting with 'A' and the other starting with 'B'.\n// For each character in the string, it compares the character with the expected value in both patterns.\n// The function returns the minimum number of changes required between the two patterns.\nint minChanges(String s) {\n  int change1 = 0; // Changes needed to make string alternate starting with 'A'\n  int change2 = 0; // Changes needed to make string alternate starting with 'B'\n\n  for (int i = 0; i < s.length; i++) {\n    if (i % 2 == 0) {\n      if (s[i] != 'A') { // Expect 'A' at even index positions\n        change1 += 1;\n      }\n      if (s[i] != 'B') { // Expect 'B' at even index positions\n        change2 += 1;\n      }\n    } else {\n      if (s[i] != 'B') { // Expect 'B' at odd index positions\n        change1 += 1;\n      }\n      if (s[i] != 'A') { // Expect 'A' at odd index positions\n        change2 += 1;\n      }\n    }\n  }\n\n  return change1 < change2 ? change1 : change2;\n}\n\nvoid testMinChanges() {\n  assert(minChanges('A') == 0);\n  assert(minChanges('B') == 0);\n  assert(minChanges('AA') == 1);\n  assert(minChanges('BB') == 1);\n  assert(minChanges('AB') == 0);\n  assert(minChanges('BA') == 0);\n  assert(minChanges('AAB') == 1);\n  assert(minChanges('BBA') == 1);\n  assert(minChanges('ABA') == 0);\n  assert(minChanges('BAB') == 0);\n  assert(minChanges('AAAA') == 2);\n  assert(minChanges('BBBB') == 2);\n  assert(minChanges('ABAB') == 0);\n  assert(minChanges('BABA') == 0);\n}\n\nvoid main() {\n  testMinChanges();\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:collection';\n\n// countWords counts the frequency of each word in the given text.\n// It splits the text into words, converts them to lowercase, and removes punctuation\n// from the start and end of each word before counting.\n// Returns a Map where keys are words and values are their respective counts.\nMap<String, int> countWords(String text) {\n  // Split the text into words\n  List<String> words = text.split(' ');\n  \n  // Clean each word by converting to lowercase and removing punctuation\n  List<String> cleanedWords = [];\n  for (String word in words) {\n    String cleaned = word.toLowerCase();\n    cleaned = cleaned.replaceAll(RegExp(r'^[^\\w]+|[^\\w]+$'), '');\n    cleanedWords.add(cleaned);\n  }\n  \n  // Count word frequencies using a HashMap\n  Map<String, int> wordCounts = HashMap();\n  for (String word in cleanedWords) {\n    wordCounts.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n  \n  return wordCounts;\n}", "test_cases": "", "test_case_results": "Input Text: \"Hello world! Hello Dart. Hello world again.\"\nWord Counts: {dart: 1, hello: 3, world: 2, again: 1}\n\nInput Text: \"The quick brown fox jumps over the lazy dog. The quick fox.\"\nWord Counts: {the: 3, over: 1, jumps: 1, lazy: 1, dog: 1, brown: 1, fox: 2, quick: 2}\n\nInput Text: \"Flutter is awesome! Awesome is Flutter? Flutter, Dart, Awesome!\"\nWord Counts: {dart: 1, flutter: 3, is: 2, awesome: 3}\n\nInput Text: \"This is a test. Just a simple test.\"\nWord Counts: {test: 2, just: 1, a: 2, simple: 1, is: 1, this: 1}", "task_id": 997, "assertions": "import 'dart:collection';\n\nvoid testCountWords() {\n  // Test case 1\n  Map<String, int> result1 = countWords(\"Hello world! Hello Dart. Hello world again.\");\n  assert(result1['hello'] == 3);\n  assert(result1['world'] == 2);\n  assert(result1['dart'] == 1);\n  assert(result1['again'] == 1);\n\n  // Test case 2\n  Map<String, int> result2 = countWords(\"The quick brown fox jumps over the lazy dog. The quick fox.\");\n  assert(result2['the'] == 3);\n  assert(result2['quick'] == 2);\n  assert(result2['fox'] == 2);\n  assert(result2['over'] == 1);\n  assert(result2['lazy'] == 1);\n\n  // Test case 3\n  Map<String, int> result3 = countWords(\"Flutter is awesome! Awesome is Flutter? Flutter, Dart, Awesome!\");\n  assert(result3['flutter'] == 3);\n  assert(result3['awesome'] == 3);\n  assert(result3['is'] == 2);\n  assert(result3['dart'] == 1);\n\n  // Test case 4\n  Map<String, int> result4 = countWords(\"This is a test. Just a simple test.\");\n  assert(result4['this'] == 1);\n  assert(result4['is'] == 1);\n  assert(result4['a'] == 2);\n  assert(result4['test'] == 2);\n  assert(result4['just'] == 1);\n  assert(result4['simple'] == 1);\n}\n\nvoid main() {\n  testCountWords();\n  print('All tests passed!');\n}", "all_code": "import 'dart:collection';\n\n// countWords counts the frequency of each word in the given text.\n// It splits the text into words, converts them to lowercase, and removes punctuation\n// from the start and end of each word before counting.\n// Returns a Map where keys are words and values are their respective counts.\nMap<String, int> countWords(String text) {\n  // Split the text into words\n  List<String> words = text.split(' ');\n  \n  // Clean each word by converting to lowercase and removing punctuation\n  List<String> cleanedWords = [];\n  for (String word in words) {\n    String cleaned = word.toLowerCase();\n    cleaned = cleaned.replaceAll(RegExp(r'^[^\\w]+|[^\\w]+$'), '');\n    cleanedWords.add(cleaned);\n  }\n  \n  // Count word frequencies using a HashMap\n  Map<String, int> wordCounts = HashMap();\n  for (String word in cleanedWords) {\n    wordCounts.update(word, (value) => value + 1, ifAbsent: () => 1);\n  }\n  \n  return wordCounts;\n}\n\nvoid testCountWords() {\n  // Test case 1\n  Map<String, int> result1 = countWords(\"Hello world! Hello Dart. Hello world again.\");\n  assert(result1['hello'] == 3);\n  assert(result1['world'] == 2);\n  assert(result1['dart'] == 1);\n  assert(result1['again'] == 1);\n\n  // Test case 2\n  Map<String, int> result2 = countWords(\"The quick brown fox jumps over the lazy dog. The quick fox.\");\n  assert(result2['the'] == 3);\n  assert(result2['quick'] == 2);\n  assert(result2['fox'] == 2);\n  assert(result2['over'] == 1);\n  assert(result2['lazy'] == 1);\n\n  // Test case 3\n  Map<String, int> result3 = countWords(\"Flutter is awesome! Awesome is Flutter? Flutter, Dart, Awesome!\");\n  assert(result3['flutter'] == 3);\n  assert(result3['awesome'] == 3);\n  assert(result3['is'] == 2);\n  assert(result3['dart'] == 1);\n\n  // Test case 4\n  Map<String, int> result4 = countWords(\"This is a test. Just a simple test.\");\n  assert(result4['this'] == 1);\n  assert(result4['is'] == 1);\n  assert(result4['a'] == 2);\n  assert(result4['test'] == 2);\n  assert(result4['just'] == 1);\n  assert(result4['simple'] == 1);\n}\n\nvoid main() {\n  testCountWords();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// quickSelect finds the kth smallest element in a list using the Quickselect algorithm.\n// If k is out of bounds (less than 1 or greater than list length), it returns null.\n// The algorithm works by partially sorting the list around a pivot until the kth element is found.\ndynamic quickSelect(List<int> arr, int k) {\n  // Check if k is out of bounds\n  if (k < 1 || k > arr.length) {\n    return null;\n  }\n\n  // Helper function to partition the list around a pivot\n  int partition(int left, int right, int pivotIndex) {\n    int pivotValue = arr[pivotIndex];\n    // Move pivot to end\n    _swap(arr, pivotIndex, right);\n    int storeIndex = left;\n    \n    for (int i = left; i < right; i++) {\n      if (arr[i] < pivotValue) {\n        _swap(arr, storeIndex, i);\n        storeIndex++;\n      }\n    }\n    // Move pivot to its final place\n    _swap(arr, right, storeIndex);\n    return storeIndex;\n  }\n\n  // Recursive selection function\n  int select(int left, int right, int kSmallest) {\n    if (left == right) {\n      return arr[left];\n    }\n    \n    int pivotIndex = (left + right) ~/ 2;\n    pivotIndex = partition(left, right, pivotIndex);\n    \n    if (kSmallest == pivotIndex) {\n      return arr[kSmallest];\n    } else if (kSmallest < pivotIndex) {\n      return select(left, pivotIndex - 1, kSmallest);\n    } else {\n      return select(pivotIndex + 1, right, kSmallest);\n    }\n  }\n\n  return select(0, arr.length - 1, k - 1);\n}\n\n// Helper function to swap elements in a list\nvoid _swap(List<int> arr, int i, int j) {\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}", "test_cases": "", "test_case_results": "Input array: [3, 2, 1, 5, 6, 4]\n  k: 1 => 1\n  k: 2 => 2\n  k: 3 => 3\n  k: 4 => 4\n  k: 5 => 5\n  k: 6 => 6\n  k: 7 => null\n  k: 0 => null\n\nInput array: [10, 4, 5, 8, 6, 11, 26]\n  k: 3 => 6\n  k: 5 => 10\n  k: 1 => 4\n  k: 7 => 26\n  k: 8 => null\n\nInput array: [7, 10, 4, 3, 20, 15]\n  k: 3 => 7\n  k: 4 => 10\n  k: 6 => 20\n  k: 2 => 4\n\nInput array: [1]\n  k: 1 => 1\n  k: 2 => null\n\nInput array: []\n  k: 1 => null", "task_id": 20480, "assertions": "void testQuickSelect() {\n  // Test case 1\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 1) == 1);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 2) == 2);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 3) == 3);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 4) == 4);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 5) == 5);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 6) == 6);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 7) == null);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 0) == null);\n\n  // Test case 2\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 3) == 6);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 5) == 10);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 1) == 4);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 7) == 26);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 8) == null);\n\n  // Test case 3\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 3) == 7);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 4) == 10);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 6) == 20);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 2) == 4);\n\n  // Test case 4\n  assert(quickSelect([1], 1) == 1);\n  assert(quickSelect([1], 2) == null);\n\n  // Test case 5\n  assert(quickSelect([], 1) == null);\n}\n\nvoid main() {\n  testQuickSelect();\n  print('All tests passed!');\n}", "all_code": "// quickSelect finds the kth smallest element in a list using the Quickselect algorithm.\n// If k is out of bounds (less than 1 or greater than list length), it returns null.\n// The algorithm works by partially sorting the list around a pivot until the kth element is found.\ndynamic quickSelect(List<int> arr, int k) {\n  // Check if k is out of bounds\n  if (k < 1 || k > arr.length) {\n    return null;\n  }\n\n  // Helper function to partition the list around a pivot\n  int partition(int left, int right, int pivotIndex) {\n    int pivotValue = arr[pivotIndex];\n    // Move pivot to end\n    _swap(arr, pivotIndex, right);\n    int storeIndex = left;\n    \n    for (int i = left; i < right; i++) {\n      if (arr[i] < pivotValue) {\n        _swap(arr, storeIndex, i);\n        storeIndex++;\n      }\n    }\n    // Move pivot to its final place\n    _swap(arr, right, storeIndex);\n    return storeIndex;\n  }\n\n  // Recursive selection function\n  int select(int left, int right, int kSmallest) {\n    if (left == right) {\n      return arr[left];\n    }\n    \n    int pivotIndex = (left + right) ~/ 2;\n    pivotIndex = partition(left, right, pivotIndex);\n    \n    if (kSmallest == pivotIndex) {\n      return arr[kSmallest];\n    } else if (kSmallest < pivotIndex) {\n      return select(left, pivotIndex - 1, kSmallest);\n    } else {\n      return select(pivotIndex + 1, right, kSmallest);\n    }\n  }\n\n  return select(0, arr.length - 1, k - 1);\n}\n\n// Helper function to swap elements in a list\nvoid _swap(List<int> arr, int i, int j) {\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n}\n\nvoid testQuickSelect() {\n  // Test case 1\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 1) == 1);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 2) == 2);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 3) == 3);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 4) == 4);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 5) == 5);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 6) == 6);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 7) == null);\n  assert(quickSelect([3, 2, 1, 5, 6, 4], 0) == null);\n\n  // Test case 2\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 3) == 6);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 5) == 10);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 1) == 4);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 7) == 26);\n  assert(quickSelect([10, 4, 5, 8, 6, 11, 26], 8) == null);\n\n  // Test case 3\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 3) == 7);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 4) == 10);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 6) == 20);\n  assert(quickSelect([7, 10, 4, 3, 20, 15], 2) == 4);\n\n  // Test case 4\n  assert(quickSelect([1], 1) == 1);\n  assert(quickSelect([1], 2) == null);\n\n  // Test case 5\n  assert(quickSelect([], 1) == null);\n}\n\nvoid main() {\n  testQuickSelect();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "// minBitFlipsToEqualize calculates the minimum number of bit flips needed to make\n// the number of 0s and 1s equal in a binary string.\n// If it's not possible to equalize them (when the difference is odd), returns -1.\nint minBitFlipsToEqualize(int n, String binaryString) {\n  int count0 = binaryString.split('').where((c) => c == '0').length;\n  int count1 = n - count0;\n  \n  if ((count0 - count1).abs() % 2 != 0) {\n    return -1;\n  } else {\n    return (count0 - count1).abs() ~/ 2;\n  }\n}\n\n// processTestCases handles multiple test cases by applying minBitFlipsToEqualize\n// to each case and collecting the results in a list.\nList<int> processTestCases(int t, List<Map<String, dynamic>> testCases) {\n  List<int> results = [];\n  for (int i = 0; i < t; i++) {\n    int n = testCases[i]['n'];\n    String binaryString = testCases[i]['binaryString'];\n    results.add(minBitFlipsToEqualize(n, binaryString));\n  }\n  return results;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nn: 4, binaryString: \"0101\"\nMinimum bit flips needed: 0\n---\nTest Case 2:\nn: 5, binaryString: \"11000\"\nMinimum bit flips needed: -1\n---\nTest Case 3:\nn: 3, binaryString: \"000\"\nMinimum bit flips needed: -1\n---\nTest Case 4:\nn: 6, binaryString: \"101010\"\nMinimum bit flips needed: 0\n---\nTest Case 5:\nn: 4, binaryString: \"1110\"\nMinimum bit flips needed: 1\n---", "task_id": 760, "assertions": "void testMinBitFlipsToEqualize() {\n  // Define test cases as a list of maps with 'n' and 'binaryString' keys\n  List<Map<String, dynamic>> testCases = [\n    {'n': 4, 'binaryString': '0101'},  // Already balanced\n    {'n': 5, 'binaryString': '11000'}, // Can be balanced\n    {'n': 3, 'binaryString': '000'},   // Impossible case\n    {'n': 6, 'binaryString': '101010'},// Already balanced\n    {'n': 4, 'binaryString': '1110'},  // Can be balanced\n  ];\n  \n  int t = testCases.length;\n  \n  // Process all test cases\n  List<int> results = processTestCases(t, testCases);\n  \n  // Assert results for each test case\n  assert(results[0] == 0);\n  assert(results[1] == -1);\n  assert(results[2] == -1);\n  assert(results[3] == 0);\n  assert(results[4] == 1);\n}\n\nvoid main() {\n  testMinBitFlipsToEqualize();\n  print('All tests passed!');\n}", "all_code": "// minBitFlipsToEqualize calculates the minimum number of bit flips needed to make\n// the number of 0s and 1s equal in a binary string.\n// If it's not possible to equalize them (when the difference is odd), returns -1.\nint minBitFlipsToEqualize(int n, String binaryString) {\n  int count0 = binaryString.split('').where((c) => c == '0').length;\n  int count1 = n - count0;\n  \n  if ((count0 - count1).abs() % 2 != 0) {\n    return -1;\n  } else {\n    return (count0 - count1).abs() ~/ 2;\n  }\n}\n\n// processTestCases handles multiple test cases by applying minBitFlipsToEqualize\n// to each case and collecting the results in a list.\nList<int> processTestCases(int t, List<Map<String, dynamic>> testCases) {\n  List<int> results = [];\n  for (int i = 0; i < t; i++) {\n    int n = testCases[i]['n'];\n    String binaryString = testCases[i]['binaryString'];\n    results.add(minBitFlipsToEqualize(n, binaryString));\n  }\n  return results;\n}\n\nvoid testMinBitFlipsToEqualize() {\n  // Define test cases as a list of maps with 'n' and 'binaryString' keys\n  List<Map<String, dynamic>> testCases = [\n    {'n': 4, 'binaryString': '0101'},  // Already balanced\n    {'n': 5, 'binaryString': '11000'}, // Can be balanced\n    {'n': 3, 'binaryString': '000'},   // Impossible case\n    {'n': 6, 'binaryString': '101010'},// Already balanced\n    {'n': 4, 'binaryString': '1110'},  // Can be balanced\n  ];\n  \n  int t = testCases.length;\n  \n  // Process all test cases\n  List<int> results = processTestCases(t, testCases);\n  \n  // Assert results for each test case\n  assert(results[0] == 0);\n  assert(results[1] == -1);\n  assert(results[2] == -1);\n  assert(results[3] == 0);\n  assert(results[4] == 1);\n}\n\nvoid main() {\n  testMinBitFlipsToEqualize();\n  print('All tests passed!');\n}", "exec_outcome": "PASSED"}
{"code": "import 'dart:core';\n\n// Finds the sentence with the most unique words in a given text.\n// Sentences are separated by '.', '!', or '?'.\n// The function ignores case and punctuation.\n// Returns:\n//   - The sentence with most unique words if found\n//   - Error message if input is invalid or no sentences found\nString sentenceWithMostUniqueWords(String text) {\n  if (text.trim().isEmpty) {\n    return \"Error: Input string is empty.\";\n  }\n\n  // Split text into sentences using punctuation marks as delimiters\n  List<String> sentences = text.split(RegExp(r'[.!?]'));\n  int maxUniqueWords = 0;\n  String resultSentence = \"\";\n\n  for (String sentence in sentences) {\n    // Extract words (ignoring punctuation and case)\n    List<String> words = RegExp(r'\\b\\w+\\b')\n        .allMatches(sentence.toLowerCase())\n        .map((match) => match.group(0)!)\n        .toList();\n    \n    // Get unique words\n    Set<String> uniqueWords = words.toSet();\n    \n    // Update result if current sentence has more unique words\n    if (uniqueWords.length > maxUniqueWords) {\n      maxUniqueWords = uniqueWords.length;\n      resultSentence = sentence.trim();\n    }\n  }\n\n  return resultSentence.isNotEmpty \n      ? resultSentence \n      : \"Error: No valid sentences found in the input text.\";\n}", "test_cases": "", "test_case_results": "Test Case: Multiple sentences with different word counts\nInput: \"Hello world. This is a test. Testing, testing! Works?\"\nResult: \"This is a test\"\n\nTest Case: Single sentence input\nInput: \"Single sentence\"\nResult: \"Single sentence\"\n\nTest Case: All identical sentences\nInput: \"Repeat. Repeat. Repeat.\"\nResult: \"Repeat\"\n\nTest Case: Empty input\nInput: \"   \"\nResult: \"Error: Input string is empty.\"\n\nTest Case: Sentences with different punctuation\nInput: \"First. Second! Third? Fourth.\"\nResult: \"First\"\n\nTest Case: Case sensitivity test\nInput: \"Hello, hello, HELLO. Different words here.\"\nResult: \"Different words here\"", "task_id": 1665, "assertions": "void testSentenceWithMostUniqueWords() {\n  assert(sentenceWithMostUniqueWords('Hello world. This is a test. Testing, testing! Works?') == \n      'This is a test');\n  assert(sentenceWithMostUniqueWords('Single sentence') == \n      'Single sentence');\n  assert(sentenceWithMostUniqueWords('Repeat. Repeat. Repeat.') == \n      'Repeat');\n  assert(sentenceWithMostUniqueWords('   ') == \n      'Error: Input string is empty.');\n  assert(sentenceWithMostUniqueWords('First. Second! Third? Fourth.') == \n      'First');\n  assert(sentenceWithMostUniqueWords('Hello, hello, HELLO. Different words here.') == \n      'Different words here');\n}\n\nvoid main() {\n  testSentenceWithMostUniqueWords();\n}", "all_code": "import 'dart:core';\n\n// Finds the sentence with the most unique words in a given text.\n// Sentences are separated by '.', '!', or '?'.\n// The function ignores case and punctuation.\n// Returns:\n//   - The sentence with most unique words if found\n//   - Error message if input is invalid or no sentences found\nString sentenceWithMostUniqueWords(String text) {\n  if (text.trim().isEmpty) {\n    return \"Error: Input string is empty.\";\n  }\n\n  // Split text into sentences using punctuation marks as delimiters\n  List<String> sentences = text.split(RegExp(r'[.!?]'));\n  int maxUniqueWords = 0;\n  String resultSentence = \"\";\n\n  for (String sentence in sentences) {\n    // Extract words (ignoring punctuation and case)\n    List<String> words = RegExp(r'\\b\\w+\\b')\n        .allMatches(sentence.toLowerCase())\n        .map((match) => match.group(0)!)\n        .toList();\n    \n    // Get unique words\n    Set<String> uniqueWords = words.toSet();\n    \n    // Update result if current sentence has more unique words\n    if (uniqueWords.length > maxUniqueWords) {\n      maxUniqueWords = uniqueWords.length;\n      resultSentence = sentence.trim();\n    }\n  }\n\n  return resultSentence.isNotEmpty \n      ? resultSentence \n      : \"Error: No valid sentences found in the input text.\";\n}\n\nvoid testSentenceWithMostUniqueWords() {\n  assert(sentenceWithMostUniqueWords('Hello world. This is a test. Testing, testing! Works?') == \n      'This is a test');\n  assert(sentenceWithMostUniqueWords('Single sentence') == \n      'Single sentence');\n  assert(sentenceWithMostUniqueWords('Repeat. Repeat. Repeat.') == \n      'Repeat');\n  assert(sentenceWithMostUniqueWords('   ') == \n      'Error: Input string is empty.');\n  assert(sentenceWithMostUniqueWords('First. Second! Third? Fourth.') == \n      'First');\n  assert(sentenceWithMostUniqueWords('Hello, hello, HELLO. Different words here.') == \n      'Different words here');\n}\n\nvoid main() {\n  testSentenceWithMostUniqueWords();\n}", "exec_outcome": "PASSED"}
{"code": "// is_valid_serial checks if a given serial number string is valid according to the rules:\n// 1. Must contain at least two different digits\n// 2. Must have no consecutive identical digits\n// Returns \"Valid\" if both conditions are met, otherwise \"Invalid\"\nString isValidSerial(String serial) {\n  // Check for at least two different digits\n  if (serial.runes.toSet().length < 2) {\n    return \"Invalid\";\n  }\n  \n  // Check for consecutive identical digits\n  for (int i = 1; i < serial.length; i++) {\n    if (serial[i] == serial[i-1]) {\n      return \"Invalid\";\n    }\n  }\n  return \"Valid\";\n}\n\n// checkSerials processes a list of serial numbers and checks their validity\n// Returns a list of \"Valid\" or \"Invalid\" strings corresponding to each input serial\nList<String> checkSerials(List<String> serials) {\n  return serials.map((serial) => isValidSerial(serial)).toList();\n}", "test_cases": "", "test_case_results": "Testing serial number validation:\n-------------------------------\nSerial: '123456'\nStatus: Valid\n---\nSerial: '112345'\nStatus: Invalid\n---\nSerial: '111111'\nStatus: Invalid\n---\nSerial: '121212'\nStatus: Valid\n---\nSerial: '12333456'\nStatus: Invalid\n---\nSerial: '12'\nStatus: Valid\n---\nSerial: '1'\nStatus: Invalid\n---\nSerial: '122334'\nStatus: Invalid\n---\nSerial: '122234'\nStatus: Invalid\n---\nSerial: 'ABABAB'\nStatus: Valid\n---\nSerial: 'AABBCD'\nStatus: Invalid\n---\n\nBatch processing test:\n123456: Valid\n112345: Invalid\n111111: Invalid\n121212: Valid\n12333456: Invalid\n12: Valid\n1: Invalid\n122334: Invalid\n122234: Invalid\nABABAB: Valid\nAABBCD: Invalid", "task_id": 28608, "assertions": "void testSerialValidation() {\n  // Test individual serial validation\n  assert(isValidSerial(\"123456\") == \"Valid\");\n  assert(isValidSerial(\"112345\") == \"Invalid\");\n  assert(isValidSerial(\"111111\") == \"Invalid\");\n  assert(isValidSerial(\"121212\") == \"Valid\");\n  assert(isValidSerial(\"12333456\") == \"Invalid\");\n  assert(isValidSerial(\"12\") == \"Valid\");\n  assert(isValidSerial(\"1\") == \"Invalid\");\n  assert(isValidSerial(\"122334\") == \"Invalid\");\n  assert(isValidSerial(\"122234\") == \"Invalid\");\n  assert(isValidSerial(\"ABABAB\") == \"Valid\");\n  assert(isValidSerial(\"AABBCD\") == \"Invalid\");\n\n  // Test batch processing\n  List<String> testCases = [\n    \"123456\", \"112345\", \"111111\", \"121212\", \"12333456\",\n    \"12\", \"1\", \"122334\", \"122234\", \"ABABAB\", \"AABBCD\"\n  ];\n  List<String> expectedResults = [\n    \"Valid\", \"Invalid\", \"Invalid\", \"Valid\", \"Invalid\",\n    \"Valid\", \"Invalid\", \"Invalid\", \"Invalid\", \"Valid\", \"Invalid\"\n  ];\n  List<String> actualResults = checkSerials(testCases);\n  for (int i = 0; i < testCases.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testSerialValidation();\n  print(\"All tests passed!\");\n}", "all_code": "// is_valid_serial checks if a given serial number string is valid according to the rules:\n// 1. Must contain at least two different digits\n// 2. Must have no consecutive identical digits\n// Returns \"Valid\" if both conditions are met, otherwise \"Invalid\"\nString isValidSerial(String serial) {\n  // Check for at least two different digits\n  if (serial.runes.toSet().length < 2) {\n    return \"Invalid\";\n  }\n  \n  // Check for consecutive identical digits\n  for (int i = 1; i < serial.length; i++) {\n    if (serial[i] == serial[i-1]) {\n      return \"Invalid\";\n    }\n  }\n  return \"Valid\";\n}\n\n// checkSerials processes a list of serial numbers and checks their validity\n// Returns a list of \"Valid\" or \"Invalid\" strings corresponding to each input serial\nList<String> checkSerials(List<String> serials) {\n  return serials.map((serial) => isValidSerial(serial)).toList();\n}\n\nvoid testSerialValidation() {\n  // Test individual serial validation\n  assert(isValidSerial(\"123456\") == \"Valid\");\n  assert(isValidSerial(\"112345\") == \"Invalid\");\n  assert(isValidSerial(\"111111\") == \"Invalid\");\n  assert(isValidSerial(\"121212\") == \"Valid\");\n  assert(isValidSerial(\"12333456\") == \"Invalid\");\n  assert(isValidSerial(\"12\") == \"Valid\");\n  assert(isValidSerial(\"1\") == \"Invalid\");\n  assert(isValidSerial(\"122334\") == \"Invalid\");\n  assert(isValidSerial(\"122234\") == \"Invalid\");\n  assert(isValidSerial(\"ABABAB\") == \"Valid\");\n  assert(isValidSerial(\"AABBCD\") == \"Invalid\");\n\n  // Test batch processing\n  List<String> testCases = [\n    \"123456\", \"112345\", \"111111\", \"121212\", \"12333456\",\n    \"12\", \"1\", \"122334\", \"122234\", \"ABABAB\", \"AABBCD\"\n  ];\n  List<String> expectedResults = [\n    \"Valid\", \"Invalid\", \"Invalid\", \"Valid\", \"Invalid\",\n    \"Valid\", \"Invalid\", \"Invalid\", \"Invalid\", \"Valid\", \"Invalid\"\n  ];\n  List<String> actualResults = checkSerials(testCases);\n  for (int i = 0; i < testCases.length; i++) {\n    assert(actualResults[i] == expectedResults[i]);\n  }\n}\n\nvoid main() {\n  testSerialValidation();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// canRepaintStones determines if it's possible to repaint the stones such that\n// no two adjacent stones have the same color. The stones are represented as a\n// string where '.' represents an unpainted stone that can be repainted to 'R', 'G', or 'B'.\n// The function uses a recursive backtracking approach to try all valid colorings.\nString canRepaintStones(int n, String stones) {\n  // isValid checks if the current stone arrangement has no adjacent stones of the same color\n  bool isValid(List<String> stoneArray) {\n    for (int i = 1; i < stoneArray.length; i++) {\n      if (stoneArray[i] == stoneArray[i - 1]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // solve is a helper function that implements the recursive backtracking solution\n  bool solve(List<String> stones, int idx) {\n    if (idx == n) {\n      return isValid(stones);\n    }\n\n    if (stones[idx] != '.') {\n      return solve(stones, idx + 1);\n    }\n\n    for (String color in [\"R\", \"G\", \"B\"]) {\n      stones[idx] = color;\n      if (idx > 0 && stones[idx] == stones[idx - 1]) {\n        continue;\n      }\n      if (solve(stones, idx + 1)) {\n        return true;\n      }\n    }\n    stones[idx] = '.';\n    return false;\n  }\n\n  return solve(stones.split(''), 0) ? \"Yes\" : \"No\";\n}", "test_cases": "", "test_case_results": "Input: n = 3, stones = 'R.G'\nCan repaint: Yes\n\nInput: n = 5, stones = 'R..G.'\nCan repaint: Yes\n\nInput: n = 4, stones = 'R.G.'\nCan repaint: Yes\n\nInput: n = 3, stones = 'RRG'\nCan repaint: No\n\nInput: n = 2, stones = '..'\nCan repaint: Yes\n\nInput: n = 1, stones = '.'\nCan repaint: Yes\n\nInput: n = 6, stones = 'R.G.B.'\nCan repaint: Yes", "task_id": 17160, "assertions": "void testCanRepaintStones() {\n  assert(canRepaintStones(3, \"R.G\") == \"Yes\");\n  assert(canRepaintStones(5, \"R..G.\") == \"Yes\");\n  assert(canRepaintStones(4, \"R.G.\") == \"Yes\");\n  assert(canRepaintStones(3, \"RRG\") == \"No\");\n  assert(canRepaintStones(2, \"..\") == \"Yes\");\n  assert(canRepaintStones(1, \".\") == \"Yes\");\n  assert(canRepaintStones(6, \"R.G.B.\") == \"Yes\");\n}\n\nvoid main() {\n  testCanRepaintStones();\n  print(\"All tests passed!\");\n}", "all_code": "// canRepaintStones determines if it's possible to repaint the stones such that\n// no two adjacent stones have the same color. The stones are represented as a\n// string where '.' represents an unpainted stone that can be repainted to 'R', 'G', or 'B'.\n// The function uses a recursive backtracking approach to try all valid colorings.\nString canRepaintStones(int n, String stones) {\n  // isValid checks if the current stone arrangement has no adjacent stones of the same color\n  bool isValid(List<String> stoneArray) {\n    for (int i = 1; i < stoneArray.length; i++) {\n      if (stoneArray[i] == stoneArray[i - 1]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // solve is a helper function that implements the recursive backtracking solution\n  bool solve(List<String> stones, int idx) {\n    if (idx == n) {\n      return isValid(stones);\n    }\n\n    if (stones[idx] != '.') {\n      return solve(stones, idx + 1);\n    }\n\n    for (String color in [\"R\", \"G\", \"B\"]) {\n      stones[idx] = color;\n      if (idx > 0 && stones[idx] == stones[idx - 1]) {\n        continue;\n      }\n      if (solve(stones, idx + 1)) {\n        return true;\n      }\n    }\n    stones[idx] = '.';\n    return false;\n  }\n\n  return solve(stones.split(''), 0) ? \"Yes\" : \"No\";\n}\n\nvoid testCanRepaintStones() {\n  assert(canRepaintStones(3, \"R.G\") == \"Yes\");\n  assert(canRepaintStones(5, \"R..G.\") == \"Yes\");\n  assert(canRepaintStones(4, \"R.G.\") == \"Yes\");\n  assert(canRepaintStones(3, \"RRG\") == \"No\");\n  assert(canRepaintStones(2, \"..\") == \"Yes\");\n  assert(canRepaintStones(1, \".\") == \"Yes\");\n  assert(canRepaintStones(6, \"R.G.B.\") == \"Yes\");\n}\n\nvoid main() {\n  testCanRepaintStones();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// findFixedPoint finds a fixed point in a sorted array of distinct integers.\n// A fixed point is an index where arr[i] == i.\n// The function uses binary search for efficient O(log n) time complexity.\n// Returns the index of the fixed point, or -1 if no fixed point exists.\nint findFixedPoint(List<int> arr) {\n  int left = 0;\n  int right = arr.length - 1;\n\n  while (left <= right) {\n    int mid = (left + right) ~/ 2;  // Integer division in Dart\n    if (arr[mid] == mid) {\n      return mid;\n    } else if (arr[mid] < mid) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}", "test_cases": "", "test_case_results": "Input array: [-10, -5, 0, 3, 7]\nFixed point found at index: 3\n\nInput array: [0, 2, 5, 8, 17]\nFixed point found at index: 0\n\nInput array: [-10, -5, 3, 4, 7, 9]\nNo fixed point exists in the array\n\nInput array: []\nNo fixed point exists in the array\n\nInput array: [0]\nFixed point found at index: 0\n\nInput array: [-1, 0, 2]\nFixed point found at index: 2\n\nInput array: [-5, 1, 3, 4]\nFixed point found at index: 1", "task_id": 29154, "assertions": "void testFindFixedPoint() {\n  assert(findFixedPoint([-10, -5, 0, 3, 7]) == 3);\n  assert(findFixedPoint([0, 2, 5, 8, 17]) == 0);\n  assert(findFixedPoint([-10, -5, 3, 4, 7, 9]) == -1);\n  assert(findFixedPoint([]) == -1);\n  assert(findFixedPoint([0]) == 0);\n  assert(findFixedPoint([-1, 0, 2]) == 2);\n  assert(findFixedPoint([-5, 1, 3, 4]) == 1);\n}\n\nvoid main() {\n  testFindFixedPoint();\n}", "all_code": "// findFixedPoint finds a fixed point in a sorted array of distinct integers.\n// A fixed point is an index where arr[i] == i.\n// The function uses binary search for efficient O(log n) time complexity.\n// Returns the index of the fixed point, or -1 if no fixed point exists.\nint findFixedPoint(List<int> arr) {\n  int left = 0;\n  int right = arr.length - 1;\n\n  while (left <= right) {\n    int mid = (left + right) ~/ 2;  // Integer division in Dart\n    if (arr[mid] == mid) {\n      return mid;\n    } else if (arr[mid] < mid) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}\n\nvoid testFindFixedPoint() {\n  assert(findFixedPoint([-10, -5, 0, 3, 7]) == 3);\n  assert(findFixedPoint([0, 2, 5, 8, 17]) == 0);\n  assert(findFixedPoint([-10, -5, 3, 4, 7, 9]) == -1);\n  assert(findFixedPoint([]) == -1);\n  assert(findFixedPoint([0]) == 0);\n  assert(findFixedPoint([-1, 0, 2]) == 2);\n  assert(findFixedPoint([-5, 1, 3, 4]) == 1);\n}\n\nvoid main() {\n  testFindFixedPoint();\n}", "exec_outcome": "PASSED"}
{"code": "// busiestHour finds the timestamp when the maximum occupancy occurs based on a list of occupancy change records.\n// It processes each record in order, tracking the current and maximum occupancy.\n// The timestamp of the record that first achieves the maximum occupancy is returned.\nString busiestHour(List<MapEntry<String, int>> records) {\n  int maxOccupancy = 0;\n  int currentOccupancy = 0;\n  String maxOccupancyTimestamp = \"\";\n\n  for (var record in records) {\n    currentOccupancy += record.value;\n    if (currentOccupancy > maxOccupancy) {\n      maxOccupancy = currentOccupancy;\n      maxOccupancyTimestamp = record.key;\n    }\n  }\n\n  return maxOccupancyTimestamp;\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput Records:\n  09:00: 5\n  10:00: 3\n  11:00: -2\n  12:00: 7\n  13:00: -4\nBusiest Hour Timestamp: 12:00\n\nTest Case 2:\nInput Records:\n  08:00: 10\n  09:00: -5\n  10:00: 5\n  11:00: -5\n  12:00: 5\nBusiest Hour Timestamp: 08:00\n\nTest Case 3:\nInput Records:\nBusiest Hour Timestamp: None\n\nTest Case 4:\nInput Records:\n  09:00: -5\n  10:00: -3\n  11:00: -2\nBusiest Hour Timestamp: None", "task_id": 4472, "assertions": "void testBusiestHour() {\n  // Test case 1: Simple case with clear maximum\n  var testCase1 = [\n    MapEntry(\"09:00\", 5),\n    MapEntry(\"10:00\", 3),\n    MapEntry(\"11:00\", -2),\n    MapEntry(\"12:00\", 7),\n    MapEntry(\"13:00\", -4),\n  ];\n  assert(busiestHour(testCase1) == \"12:00\");\n\n  // Test case 2: Multiple entries with same maximum occupancy\n  var testCase2 = [\n    MapEntry(\"08:00\", 10),\n    MapEntry(\"09:00\", -5),\n    MapEntry(\"10:00\", 5),\n    MapEntry(\"11:00\", -5),\n    MapEntry(\"12:00\", 5),\n  ];\n  assert(busiestHour(testCase2) == \"08:00\");\n\n  // Test case 3: Empty list\n  var testCase3 = <MapEntry<String, int>>[];\n  assert(busiestHour(testCase3) == \"\");\n\n  // Test case 4: Decreasing occupancy\n  var testCase4 = [\n    MapEntry(\"09:00\", -5),\n    MapEntry(\"10:00\", -3),\n    MapEntry(\"11:00\", -2),\n  ];\n  assert(busiestHour(testCase4) == \"\");\n}\n\nvoid main() {\n  testBusiestHour();\n  print(\"All tests passed!\");\n}", "all_code": "// busiestHour finds the timestamp when the maximum occupancy occurs based on a list of occupancy change records.\n// It processes each record in order, tracking the current and maximum occupancy.\n// The timestamp of the record that first achieves the maximum occupancy is returned.\nString busiestHour(List<MapEntry<String, int>> records) {\n  int maxOccupancy = 0;\n  int currentOccupancy = 0;\n  String maxOccupancyTimestamp = \"\";\n\n  for (var record in records) {\n    currentOccupancy += record.value;\n    if (currentOccupancy > maxOccupancy) {\n      maxOccupancy = currentOccupancy;\n      maxOccupancyTimestamp = record.key;\n    }\n  }\n\n  return maxOccupancyTimestamp;\n}\n\nvoid testBusiestHour() {\n  // Test case 1: Simple case with clear maximum\n  var testCase1 = [\n    MapEntry(\"09:00\", 5),\n    MapEntry(\"10:00\", 3),\n    MapEntry(\"11:00\", -2),\n    MapEntry(\"12:00\", 7),\n    MapEntry(\"13:00\", -4),\n  ];\n  assert(busiestHour(testCase1) == \"12:00\");\n\n  // Test case 2: Multiple entries with same maximum occupancy\n  var testCase2 = [\n    MapEntry(\"08:00\", 10),\n    MapEntry(\"09:00\", -5),\n    MapEntry(\"10:00\", 5),\n    MapEntry(\"11:00\", -5),\n    MapEntry(\"12:00\", 5),\n  ];\n  assert(busiestHour(testCase2) == \"08:00\");\n\n  // Test case 3: Empty list\n  var testCase3 = <MapEntry<String, int>>[];\n  assert(busiestHour(testCase3) == \"\");\n\n  // Test case 4: Decreasing occupancy\n  var testCase4 = [\n    MapEntry(\"09:00\", -5),\n    MapEntry(\"10:00\", -3),\n    MapEntry(\"11:00\", -2),\n  ];\n  assert(busiestHour(testCase4) == \"\");\n}\n\nvoid main() {\n  testBusiestHour();\n  print(\"All tests passed!\");\n}", "exec_outcome": "PASSED"}
{"code": "// findMaxAverageSum calculates the maximum average sum of k consecutive elements in an array.\n// It uses the sliding window technique to efficiently compute the sums of consecutive elements.\n// If the array has fewer than k elements, it returns -1.\ndouble findMaxAverageSum(List<int> arr, int k) {\n  int n = arr.length;\n  if (n < k) {\n    return -1;\n  }\n\n  // Calculate the sum of first 'k' elements\n  int currentSum = arr.sublist(0, k).reduce((a, b) => a + b);\n  int maxSum = currentSum;\n\n  // Use sliding window technique to find the max sum of 'k' consecutive elements\n  for (int i = k; i < n; i++) {\n    currentSum += arr[i] - arr[i - k];\n    if (currentSum > maxSum) {\n      maxSum = currentSum;\n    }\n  }\n\n  return maxSum / k;\n}", "test_cases": "", "test_case_results": "Test Case 1 - Array: [1, 12, -5, -6, 50, 3], k: 4\nMaximum average sum: 12.75\n\nTest Case 2 - Array: [5, 7, 3, 2], k: 4\nMaximum average sum: 4.25\n\nTest Case 3 - Array: [10, 20, 30], k: 4\nMaximum average sum: -1.0\n\nTest Case 4 - Array: [-1, -2, -3, -4, -5], k: 2\nMaximum average sum: -1.5\n\nTest Case 5 - Array: [8], k: 1\nMaximum average sum: 8.0", "task_id": 28993, "assertions": "void testFindMaxAverageSum() {\n  // Test case 1: Normal case with k smaller than array length\n  assert(findMaxAverageSum([1, 12, -5, -6, 50, 3], 4) == 12.75);\n  \n  // Test case 2: k equals array length\n  assert(findMaxAverageSum([5, 7, 3, 2], 4) == 4.25);\n  \n  // Test case 3: k larger than array length\n  assert(findMaxAverageSum([10, 20, 30], 4) == -1.0);\n  \n  // Test case 4: All negative numbers\n  assert(findMaxAverageSum([-1, -2, -3, -4, -5], 2) == -1.5);\n  \n  // Test case 5: Single element array with k=1\n  assert(findMaxAverageSum([8], 1) == 8.0);\n}\n\nvoid main() {\n  testFindMaxAverageSum();\n}", "all_code": "// findMaxAverageSum calculates the maximum average sum of k consecutive elements in an array.\n// It uses the sliding window technique to efficiently compute the sums of consecutive elements.\n// If the array has fewer than k elements, it returns -1.\ndouble findMaxAverageSum(List<int> arr, int k) {\n  int n = arr.length;\n  if (n < k) {\n    return -1;\n  }\n\n  // Calculate the sum of first 'k' elements\n  int currentSum = arr.sublist(0, k).reduce((a, b) => a + b);\n  int maxSum = currentSum;\n\n  // Use sliding window technique to find the max sum of 'k' consecutive elements\n  for (int i = k; i < n; i++) {\n    currentSum += arr[i] - arr[i - k];\n    if (currentSum > maxSum) {\n      maxSum = currentSum;\n    }\n  }\n\n  return maxSum / k;\n}\n\nvoid testFindMaxAverageSum() {\n  // Test case 1: Normal case with k smaller than array length\n  assert(findMaxAverageSum([1, 12, -5, -6, 50, 3], 4) == 12.75);\n  \n  // Test case 2: k equals array length\n  assert(findMaxAverageSum([5, 7, 3, 2], 4) == 4.25);\n  \n  // Test case 3: k larger than array length\n  assert(findMaxAverageSum([10, 20, 30], 4) == -1.0);\n  \n  // Test case 4: All negative numbers\n  assert(findMaxAverageSum([-1, -2, -3, -4, -5], 2) == -1.5);\n  \n  // Test case 5: Single element array with k=1\n  assert(findMaxAverageSum([8], 1) == 8.0);\n}\n\nvoid main() {\n  testFindMaxAverageSum();\n}", "exec_outcome": "PASSED"}
{"code": "// sortStoryEntries sorts a list of story entries by their timestamp.\n// Each entry is expected to be a string where the first 19 characters represent\n// the timestamp and the remaining part represents the text line.\n// The function returns a list of text lines sorted by their timestamps.\nList<String> sortStoryEntries(int n, List<String> entries) {\n  // Parse each entry into a tuple of (timestamp, text)\n  List<MapEntry<String, String>> parsedEntries = [];\n  for (String entry in entries) {\n    String timestamp = entry.substring(0, 19);\n    String text = entry.substring(20);\n    parsedEntries.add(MapEntry(timestamp, text));\n  }\n\n  // Sort entries by timestamp\n  parsedEntries.sort((a, b) => a.key.compareTo(b.key));\n\n  // Extract and return just the sorted text lines\n  return parsedEntries.map((entry) => entry.value).toList();\n}", "test_cases": "", "test_case_results": "Test Case 1:\nInput:\n[2023-01-01 12:00:00 This is the first entry, 2023-01-01 11:00:00 This is the second entry, 2023-01-01 13:00:00 This is the third entry]\nSorted Output:\n[This is the second entry, This is the first entry, This is the third entry]\n\nTest Case 2:\nInput:\n[2023-01-02 00:00:00 New Year second day, 2023-01-01 00:00:00 New Year first day, 2023-01-03 00:00:00 New Year third day]\nSorted Output:\n[New Year first day, New Year second day, New Year third day]\n\nTest Case 3:\nInput:\n[2023-12-31 23:59:59 Last moment of the year]\nSorted Output:\n[Last moment of the year]\n\nTest Case 4:\nInput:\n[]\nSorted Output:\n[]", "task_id": 5944, "assertions": "void testSortStoryEntries() {\n  // Test Case 1: Simple case with 3 entries\n  List<String> entries1 = [\n    '2023-01-01 12:00:00 This is the first entry',\n    '2023-01-01 11:00:00 This is the second entry',\n    '2023-01-01 13:00:00 This is the third entry'\n  ];\n  assert(sortStoryEntries(3, entries1) == [\n    'This is the second entry',\n    'This is the first entry',\n    'This is the third entry'\n  ]);\n\n  // Test Case 2: Case with different dates\n  List<String> entries2 = [\n    '2023-01-02 00:00:00 New Year second day',\n    '2023-01-01 00:00:00 New Year first day',\n    '2023-01-03 00:00:00 New Year third day'\n  ];\n  assert(sortStoryEntries(3, entries2) == [\n    'New Year first day',\n    'New Year second day',\n    'New Year third day'\n  ]);\n\n  // Test Case 3: Single entry case\n  List<String> entries3 = [\n    '2023-12-31 23:59:59 Last moment of the year'\n  ];\n  assert(sortStoryEntries(1, entries3) == [\n    'Last moment of the year'\n  ]);\n\n  // Test Case 4: Empty list case\n  List<String> entries4 = [];\n  assert(sortStoryEntries(0, entries4) == []);\n}\n\nvoid main() {\n  testSortStoryEntries();\n  print('All tests passed!');\n}", "all_code": "// sortStoryEntries sorts a list of story entries by their timestamp.\n// Each entry is expected to be a string where the first 19 characters represent\n// the timestamp and the remaining part represents the text line.\n// The function returns a list of text lines sorted by their timestamps.\nList<String> sortStoryEntries(int n, List<String> entries) {\n  // Parse each entry into a tuple of (timestamp, text)\n  List<MapEntry<String, String>> parsedEntries = [];\n  for (String entry in entries) {\n    String timestamp = entry.substring(0, 19);\n    String text = entry.substring(20);\n    parsedEntries.add(MapEntry(timestamp, text));\n  }\n\n  // Sort entries by timestamp\n  parsedEntries.sort((a, b) => a.key.compareTo(b.key));\n\n  // Extract and return just the sorted text lines\n  return parsedEntries.map((entry) => entry.value).toList();\n}\n\nvoid testSortStoryEntries() {\n  // Test Case 1: Simple case with 3 entries\n  List<String> entries1 = [\n    '2023-01-01 12:00:00 This is the first entry',\n    '2023-01-01 11:00:00 This is the second entry',\n    '2023-01-01 13:00:00 This is the third entry'\n  ];\n  assert(sortStoryEntries(3, entries1) == [\n    'This is the second entry',\n    'This is the first entry',\n    'This is the third entry'\n  ]);\n\n  // Test Case 2: Case with different dates\n  List<String> entries2 = [\n    '2023-01-02 00:00:00 New Year second day',\n    '2023-01-01 00:00:00 New Year first day',\n    '2023-01-03 00:00:00 New Year third day'\n  ];\n  assert(sortStoryEntries(3, entries2) == [\n    'New Year first day',\n    'New Year second day',\n    'New Year third day'\n  ]);\n\n  // Test Case 3: Single entry case\n  List<String> entries3 = [\n    '2023-12-31 23:59:59 Last moment of the year'\n  ];\n  assert(sortStoryEntries(1, entries3) == [\n    'Last moment of the year'\n  ]);\n\n  // Test Case 4: Empty list case\n  List<String> entries4 = [];\n  assert(sortStoryEntries(0, entries4) == []);\n}\n\nvoid main() {\n  testSortStoryEntries();\n  print('All tests passed!');\n}", "exec_outcome": "RUNTIME_ERROR"}
