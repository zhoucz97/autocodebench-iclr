{"code": "open System\n\n// regionSum calculates the sum of all elements in a matrix within a specified rectangular region.\n// The region is defined by the top-left (r1, c1) and bottom-right (r2, c2) coordinates.\n// The function iterates through each element in the specified region and accumulates the sum.\nlet regionSum (matrix: int[,]) (topLeft: int * int) (bottomRight: int * int) =\n    let r1, c1 = topLeft\n    let r2, c2 = bottomRight\n    let mutable totalSum = 0\n    \n    for i in r1 .. r2 do\n        for j in c1 .. c2 do\n            totalSum <- totalSum + matrix.[i, j]\n    \n    totalSum", "test_cases": "", "test_case_results": "Matrix: [[1; 2; 3]\n [4; 5; 6]\n [7; 8; 9]]\nRegion from (0, 0) to (1, 1)\nSum: 12\n\nMatrix: [[1; 2; 3]\n [4; 5; 6]\n [7; 8; 9]]\nRegion from (1, 1) to (2, 2)\nSum: 28\n\nMatrix: [[10; 20; 30; 40]\n [50; 60; 70; 80]\n [90; 100; 110; 120]]\nRegion from (0, 1) to (1, 2)\nSum: 180\n\nMatrix: [[10; 20; 30; 40]\n [50; 60; 70; 80]\n [90; 100; 110; 120]]\nRegion from (0, 0) to (2, 3)\nSum: 780", "task_id": 27251, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestRegionSum =\n    let testMatrix1 = array2D [\n        [1; 2; 3]\n        [4; 5; 6]\n        [7; 8; 9]\n    ]\n\n    let testMatrix2 = array2D [\n        [10; 20; 30; 40]\n        [50; 60; 70; 80]\n        [90; 100; 110; 120]\n    ]\n\n    let checkRegionSum() =\n        Debug.Assert(regionSum testMatrix1 (0, 0) (1, 1) = 12)\n        Debug.Assert(regionSum testMatrix1 (1, 1) (2, 2) = 28)\n        Debug.Assert(regionSum testMatrix2 (0, 1) (1, 2) = 180)\n        Debug.Assert(regionSum testMatrix2 (0, 0) (2, 3) = 780)\n\n[<EntryPoint>]\nlet main argv =\n    TestRegionSum.checkRegionSum()\n    0", "all_code": "open System\n\n// regionSum calculates the sum of all elements in a matrix within a specified rectangular region.\n// The region is defined by the top-left (r1, c1) and bottom-right (r2, c2) coordinates.\n// The function iterates through each element in the specified region and accumulates the sum.\nlet regionSum (matrix: int[,]) (topLeft: int * int) (bottomRight: int * int) =\n    let r1, c1 = topLeft\n    let r2, c2 = bottomRight\n    let mutable totalSum = 0\n    \n    for i in r1 .. r2 do\n        for j in c1 .. c2 do\n            totalSum <- totalSum + matrix.[i, j]\n    \n    totalSum\nopen System\nopen System.Diagnostics\n\nmodule TestRegionSum =\n    let testMatrix1 = array2D [\n        [1; 2; 3]\n        [4; 5; 6]\n        [7; 8; 9]\n    ]\n\n    let testMatrix2 = array2D [\n        [10; 20; 30; 40]\n        [50; 60; 70; 80]\n        [90; 100; 110; 120]\n    ]\n\n    let checkRegionSum() =\n        Debug.Assert(regionSum testMatrix1 (0, 0) (1, 1) = 12)\n        Debug.Assert(regionSum testMatrix1 (1, 1) (2, 2) = 28)\n        Debug.Assert(regionSum testMatrix2 (0, 1) (1, 2) = 180)\n        Debug.Assert(regionSum testMatrix2 (0, 0) (2, 3) = 780)\n\n[<EntryPoint>]\nlet main argv =\n    TestRegionSum.checkRegionSum()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to find the smallest digit in the absolute value of an integer\nlet smallestDigit (n: int) =\n    // Take the absolute value of n to handle negative numbers\n    let absN = abs n\n    // Convert the number to a string to iterate over each digit\n    let digits = absN.ToString() |> Seq.map (fun c -> int c - int '0')\n    // Find the minimum digit in the sequence\n    if Seq.isEmpty digits then 0 else Seq.min digits", "test_cases": "", "test_case_results": "Input: 12345, Smallest Digit: 1\nInput: -9876, Smallest Digit: 6\nInput: 0, Smallest Digit: 0\nInput: 555, Smallest Digit: 5\nInput: 1024, Smallest Digit: 0", "task_id": 4330, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSmallestDigit =\n    let checkSmallestDigit() =\n        Debug.Assert(smallestDigit 12345 = 1)\n        Debug.Assert(smallestDigit -9876 = 6)\n        Debug.Assert(smallestDigit 0 = 0)\n        Debug.Assert(smallestDigit 555 = 5)\n        Debug.Assert(smallestDigit 1024 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestSmallestDigit.checkSmallestDigit()\n    0", "all_code": "// Function to find the smallest digit in the absolute value of an integer\nlet smallestDigit (n: int) =\n    // Take the absolute value of n to handle negative numbers\n    let absN = abs n\n    // Convert the number to a string to iterate over each digit\n    let digits = absN.ToString() |> Seq.map (fun c -> int c - int '0')\n    // Find the minimum digit in the sequence\n    if Seq.isEmpty digits then 0 else Seq.min digits\nopen System\nopen System.Diagnostics\n\nmodule TestSmallestDigit =\n    let checkSmallestDigit() =\n        Debug.Assert(smallestDigit 12345 = 1)\n        Debug.Assert(smallestDigit -9876 = 6)\n        Debug.Assert(smallestDigit 0 = 0)\n        Debug.Assert(smallestDigit 555 = 5)\n        Debug.Assert(smallestDigit 1024 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestSmallestDigit.checkSmallestDigit()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\nmodule OrderProcessor =\n    let processOrders (orders: (int * int) array) =\n        let sums = Dictionary<int, int>()\n        let order = ResizeArray<int>()\n        \n        for (a, k) in orders do\n            if sums.ContainsKey(a) then\n                sums.[a] <- sums.[a] + k\n            else\n                sums.Add(a, k)\n                order.Add(a)\n        \n        (order.Count, order |> Seq.map (fun product -> (product, sums.[product])) |> List.ofSeq)", "test_cases": "", "test_case_results": "Input orders: [|(1, 5); (2, 3); (1, 2); (3, 7)|]\nUnique products count: 3\nProducts with totals: [(1, 7); (2, 3); (3, 7)]\n\nInput orders: [|(4, 1); (4, 1); (4, 1)|]\nUnique products count: 1\nProducts with totals: [(4, 3)]\n\nInput orders: [|(10, 2)|]\nUnique products count: 1\nProducts with totals: [(10, 2)]\n\nInput orders: [||]\nUnique products count: 0\nProducts with totals: []", "task_id": 13365, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestOrderProcessor =\n    let checkProcessOrders() =\n        // Test case 1: Multiple products with one duplicate\n        let count1, products1 = OrderProcessor.processOrders [|(1, 5); (2, 3); (1, 2); (3, 7)|]\n        Debug.Assert(count1 = 3)\n        Debug.Assert(products1 = [(1, 7); (2, 3); (3, 7)])\n\n        // Test case 2: Same product multiple times\n        let count2, products2 = OrderProcessor.processOrders [|(4, 1); (4, 1); (4, 1)|]\n        Debug.Assert(count2 = 1)\n        Debug.Assert(products2 = [(4, 3)])\n\n        // Test case 3: Single order\n        let count3, products3 = OrderProcessor.processOrders [|(10, 2)|]\n        Debug.Assert(count3 = 1)\n        Debug.Assert(products3 = [(10, 2)])\n\n        // Test case 4: Empty case\n        let count4, products4 = OrderProcessor.processOrders [||]\n        Debug.Assert(count4 = 0)\n        Debug.Assert(products4 = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestOrderProcessor.checkProcessOrders()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\nmodule OrderProcessor =\n    let processOrders (orders: (int * int) array) =\n        let sums = Dictionary<int, int>()\n        let order = ResizeArray<int>()\n        \n        for (a, k) in orders do\n            if sums.ContainsKey(a) then\n                sums.[a] <- sums.[a] + k\n            else\n                sums.Add(a, k)\n                order.Add(a)\n        \n        (order.Count, order |> Seq.map (fun product -> (product, sums.[product])) |> List.ofSeq)\nopen System\nopen System.Diagnostics\n\nmodule TestOrderProcessor =\n    let checkProcessOrders() =\n        // Test case 1: Multiple products with one duplicate\n        let count1, products1 = OrderProcessor.processOrders [|(1, 5); (2, 3); (1, 2); (3, 7)|]\n        Debug.Assert(count1 = 3)\n        Debug.Assert(products1 = [(1, 7); (2, 3); (3, 7)])\n\n        // Test case 2: Same product multiple times\n        let count2, products2 = OrderProcessor.processOrders [|(4, 1); (4, 1); (4, 1)|]\n        Debug.Assert(count2 = 1)\n        Debug.Assert(products2 = [(4, 3)])\n\n        // Test case 3: Single order\n        let count3, products3 = OrderProcessor.processOrders [|(10, 2)|]\n        Debug.Assert(count3 = 1)\n        Debug.Assert(products3 = [(10, 2)])\n\n        // Test case 4: Empty case\n        let count4, products4 = OrderProcessor.processOrders [||]\n        Debug.Assert(count4 = 0)\n        Debug.Assert(products4 = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestOrderProcessor.checkProcessOrders()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// reverseBits function reverses the bits of a given unsigned 32-bit integer.\n// It takes an integer as input and returns another integer with the bits reversed.\nlet reverseBits (n: uint32) =\n    let mutable result = 0u\n    let mutable num = n\n    for i in 1..32 do\n        result <- (result <<< 1) ||| (num &&& 1u)\n        num <- num >>> 1\n    result", "test_cases": "", "test_case_results": "Input: 1\nReversed: 2147483648\nInput: 2\nReversed: 1073741824\nInput: 43261596\nReversed: 964176192\nInput: 4294967293\nReversed: 3221225471", "task_id": 15455, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestReverseBits =\n    let checkReverseBits() =\n        Debug.Assert(reverseBits 1u = 2147483648u)\n        Debug.Assert(reverseBits 2u = 1073741824u)\n        Debug.Assert(reverseBits 43261596u = 964176192u)\n        Debug.Assert(reverseBits 4294967293u = 3221225471u)\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseBits.checkReverseBits()\n    0", "all_code": "// reverseBits function reverses the bits of a given unsigned 32-bit integer.\n// It takes an integer as input and returns another integer with the bits reversed.\nlet reverseBits (n: uint32) =\n    let mutable result = 0u\n    let mutable num = n\n    for i in 1..32 do\n        result <- (result <<< 1) ||| (num &&& 1u)\n        num <- num >>> 1\n    result\nopen System\nopen System.Diagnostics\n\nmodule TestReverseBits =\n    let checkReverseBits() =\n        Debug.Assert(reverseBits 1u = 2147483648u)\n        Debug.Assert(reverseBits 2u = 1073741824u)\n        Debug.Assert(reverseBits 43261596u = 964176192u)\n        Debug.Assert(reverseBits 4294967293u = 3221225471u)\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseBits.checkReverseBits()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// findMinAllocation calculates the minimum possible maximum allocation per city\n// given the populations of cities and a total number of ballots (B).\n// It uses binary search to efficiently find the solution.\nlet findMinAllocation (populations: int array) (B: int) =\n    let maxA = Array.max populations\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = (low + high) / 2\n            let total = \n                populations \n                |> Array.map (fun a -> (a + mid - 1) / mid)\n                |> Array.sum\n            if total <= B then\n                binarySearch low (mid - 1)\n            else\n                binarySearch (mid + 1) high\n    binarySearch 1 maxA + 1  // +1 because binarySearch returns high which is mid-1 when we find the answer", "test_cases": "", "test_case_results": "Test case:\n  Populations: [|100; 200; 300; 400|]\n  Ballots (B): 10\n  Minimum maximum allocation: 100\n\nTest case:\n  Populations: [|50; 50; 50; 50|]\n  Ballots (B): 5\n  Minimum maximum allocation: 50\n\nTest case:\n  Populations: [|1000; 2000; 3000|]\n  Ballots (B): 15\n  Minimum maximum allocation: 429\n\nTest case:\n  Populations: [|10; 20; 30|]\n  Ballots (B): 6\n  Minimum maximum allocation: 10", "task_id": 9482, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFindMinAllocation =\n    let runTests() =\n        // Test case 1\n        let populations1 = [|100; 200; 300; 400|]\n        let B1 = 10\n        Debug.Assert(findMinAllocation populations1 B1 = 100, \"Test case 1 failed\")\n\n        // Test case 2\n        let populations2 = [|50; 50; 50; 50|]\n        let B2 = 5\n        Debug.Assert(findMinAllocation populations2 B2 = 50, \"Test case 2 failed\")\n\n        // Test case 3\n        let populations3 = [|1000; 2000; 3000|]\n        let B3 = 15\n        Debug.Assert(findMinAllocation populations3 B3 = 429, \"Test case 3 failed\")\n\n        // Test case 4\n        let populations4 = [|10; 20; 30|]\n        let B4 = 6\n        Debug.Assert(findMinAllocation populations4 B4 = 10, \"Test case 4 failed\")\n\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMinAllocation.runTests()\n    0", "all_code": "open System\n\n// findMinAllocation calculates the minimum possible maximum allocation per city\n// given the populations of cities and a total number of ballots (B).\n// It uses binary search to efficiently find the solution.\nlet findMinAllocation (populations: int array) (B: int) =\n    let maxA = Array.max populations\n    let rec binarySearch low high =\n        if low > high then high\n        else\n            let mid = (low + high) / 2\n            let total = \n                populations \n                |> Array.map (fun a -> (a + mid - 1) / mid)\n                |> Array.sum\n            if total <= B then\n                binarySearch low (mid - 1)\n            else\n                binarySearch (mid + 1) high\n    binarySearch 1 maxA + 1  // +1 because binarySearch returns high which is mid-1 when we find the answer\nopen System\nopen System.Diagnostics\n\nmodule TestFindMinAllocation =\n    let runTests() =\n        // Test case 1\n        let populations1 = [|100; 200; 300; 400|]\n        let B1 = 10\n        Debug.Assert(findMinAllocation populations1 B1 = 100, \"Test case 1 failed\")\n\n        // Test case 2\n        let populations2 = [|50; 50; 50; 50|]\n        let B2 = 5\n        Debug.Assert(findMinAllocation populations2 B2 = 50, \"Test case 2 failed\")\n\n        // Test case 3\n        let populations3 = [|1000; 2000; 3000|]\n        let B3 = 15\n        Debug.Assert(findMinAllocation populations3 B3 = 429, \"Test case 3 failed\")\n\n        // Test case 4\n        let populations4 = [|10; 20; 30|]\n        let B4 = 6\n        Debug.Assert(findMinAllocation populations4 B4 = 10, \"Test case 4 failed\")\n\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMinAllocation.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\nmodule BookTracker =\n    let trackBooks (t: int) (testCases: (int * string array) array) =\n        let results = ResizeArray<string>()\n        for i in 0 .. t - 1 do\n            let n, titles = testCases.[i]\n            let bookCounts = Dictionary<string, int>()\n            \n            // Count occurrences of each title, preserving insertion order\n            for title in titles do\n                if bookCounts.ContainsKey(title) then\n                    bookCounts.[title] <- bookCounts.[title] + 1\n                else\n                    bookCounts.Add(title, 1)\n                    \n            // Format the result for this test case\n            let result = bookCounts |> Seq.map (fun kvp -> sprintf \"%s %d\" kvp.Key kvp.Value) |> String.concat \"\\n\"\n            results.Add(result)\n        \n        results.ToArray()", "test_cases": "", "test_case_results": "Testing trackBooks function with the following test cases:\n\nTest Case 1:\nInput Titles: [|\"The Hobbit\"; \"The Hobbit\"; \"The Lord of the Rings\"; \"The Silmarillion\"|]\nResult:\nThe Hobbit 2\nThe Lord of the Rings 1\nThe Silmarillion 1\n\nTest Case 2:\nInput Titles: [|\"Dune\"; \"Dune\"; \"Foundation\"; \"Dune\"; \"Foundation\"|]\nResult:\nDune 3\nFoundation 2\n\nTest Case 3:\nInput Titles: [|\"1984\"; \"Brave New World\"; \"1984\"|]\nResult:\n1984 2\nBrave New World 1", "task_id": 24796, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestBookTracker =\n    let checkTrackBooks() =\n        let testCases = [|\n            (4, [|\"The Hobbit\"; \"The Hobbit\"; \"The Lord of the Rings\"; \"The Silmarillion\"|])\n            (5, [|\"Dune\"; \"Dune\"; \"Foundation\"; \"Dune\"; \"Foundation\"|])\n            (3, [|\"1984\"; \"Brave New World\"; \"1984\"|])\n        |]\n\n        let results = BookTracker.trackBooks testCases.Length testCases\n        \n        Debug.Assert(results.[0] = \"The Hobbit 2\\nThe Lord of the Rings 1\\nThe Silmarillion 1\")\n        Debug.Assert(results.[1] = \"Dune 3\\nFoundation 2\")\n        Debug.Assert(results.[2] = \"1984 2\\nBrave New World 1\")\n\n[<EntryPoint>]\nlet main argv =\n    TestBookTracker.checkTrackBooks()\n    0", "all_code": "open System.Collections.Generic\n\nmodule BookTracker =\n    let trackBooks (t: int) (testCases: (int * string array) array) =\n        let results = ResizeArray<string>()\n        for i in 0 .. t - 1 do\n            let n, titles = testCases.[i]\n            let bookCounts = Dictionary<string, int>()\n            \n            // Count occurrences of each title, preserving insertion order\n            for title in titles do\n                if bookCounts.ContainsKey(title) then\n                    bookCounts.[title] <- bookCounts.[title] + 1\n                else\n                    bookCounts.Add(title, 1)\n                    \n            // Format the result for this test case\n            let result = bookCounts |> Seq.map (fun kvp -> sprintf \"%s %d\" kvp.Key kvp.Value) |> String.concat \"\\n\"\n            results.Add(result)\n        \n        results.ToArray()\nopen System\nopen System.Diagnostics\n\nmodule TestBookTracker =\n    let checkTrackBooks() =\n        let testCases = [|\n            (4, [|\"The Hobbit\"; \"The Hobbit\"; \"The Lord of the Rings\"; \"The Silmarillion\"|])\n            (5, [|\"Dune\"; \"Dune\"; \"Foundation\"; \"Dune\"; \"Foundation\"|])\n            (3, [|\"1984\"; \"Brave New World\"; \"1984\"|])\n        |]\n\n        let results = BookTracker.trackBooks testCases.Length testCases\n        \n        Debug.Assert(results.[0] = \"The Hobbit 2\\nThe Lord of the Rings 1\\nThe Silmarillion 1\")\n        Debug.Assert(results.[1] = \"Dune 3\\nFoundation 2\")\n        Debug.Assert(results.[2] = \"1984 2\\nBrave New World 1\")\n\n[<EntryPoint>]\nlet main argv =\n    TestBookTracker.checkTrackBooks()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// willFirstPlayerWin determines if the first player will win the game based on the given rules.\n// The game rules state that a player can append a string from the set if the combined length\n// is a multiple of the initial string's length. The first player wins if the count of such\n// playable strings is odd.\nlet willFirstPlayerWin (n: int) (initialString: string) (strings: string list) =\n    let initialLength = initialString.Length\n    \n    // Filter strings that can be appended to form a length that's a multiple of initialLength\n    let playableStrings = \n        strings \n        |> List.filter (fun s -> (s.Length + initialLength) % initialLength = 0)\n    \n    // Determine winner based on parity of playable strings count\n    if playableStrings.Length % 2 <> 0 then \"First\" else \"Second\"", "test_cases": "", "test_case_results": "Test Case:\n  n: 3\n  Initial string: \"abc\"\n  Strings: [\"def\"; \"gh\"; \"ijkl\"]\n  Winner: First\n\nTest Case:\n  n: 4\n  Initial string: \"ab\"\n  Strings: [\"cd\"; \"efgh\"; \"ij\"; \"kl\"]\n  Winner: Second\n\nTest Case:\n  n: 2\n  Initial string: \"xyz\"\n  Strings: [\"a\"; \"bcdef\"; \"ghi\"]\n  Winner: First\n\nTest Case:\n  n: 1\n  Initial string: \"a\"\n  Strings: [\"a\"; \"aa\"; \"aaa\"]\n  Winner: First", "task_id": 21885, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestGameWinner =\n    let testWillFirstPlayerWin() =\n        // Test case 1\n        Debug.Assert(willFirstPlayerWin 3 \"abc\" [\"def\"; \"gh\"; \"ijkl\"] = \"First\")\n        \n        // Test case 2\n        Debug.Assert(willFirstPlayerWin 4 \"ab\" [\"cd\"; \"efgh\"; \"ij\"; \"kl\"] = \"Second\")\n        \n        // Test case 3\n        Debug.Assert(willFirstPlayerWin 2 \"xyz\" [\"a\"; \"bcdef\"; \"ghi\"] = \"First\")\n        \n        // Test case 4\n        Debug.Assert(willFirstPlayerWin 1 \"a\" [\"a\"; \"aa\"; \"aaa\"] = \"First\")\n\n[<EntryPoint>]\nlet main argv =\n    TestGameWinner.testWillFirstPlayerWin()\n    0", "all_code": "open System\n\n// willFirstPlayerWin determines if the first player will win the game based on the given rules.\n// The game rules state that a player can append a string from the set if the combined length\n// is a multiple of the initial string's length. The first player wins if the count of such\n// playable strings is odd.\nlet willFirstPlayerWin (n: int) (initialString: string) (strings: string list) =\n    let initialLength = initialString.Length\n    \n    // Filter strings that can be appended to form a length that's a multiple of initialLength\n    let playableStrings = \n        strings \n        |> List.filter (fun s -> (s.Length + initialLength) % initialLength = 0)\n    \n    // Determine winner based on parity of playable strings count\n    if playableStrings.Length % 2 <> 0 then \"First\" else \"Second\"\nopen System\nopen System.Diagnostics\n\nmodule TestGameWinner =\n    let testWillFirstPlayerWin() =\n        // Test case 1\n        Debug.Assert(willFirstPlayerWin 3 \"abc\" [\"def\"; \"gh\"; \"ijkl\"] = \"First\")\n        \n        // Test case 2\n        Debug.Assert(willFirstPlayerWin 4 \"ab\" [\"cd\"; \"efgh\"; \"ij\"; \"kl\"] = \"Second\")\n        \n        // Test case 3\n        Debug.Assert(willFirstPlayerWin 2 \"xyz\" [\"a\"; \"bcdef\"; \"ghi\"] = \"First\")\n        \n        // Test case 4\n        Debug.Assert(willFirstPlayerWin 1 \"a\" [\"a\"; \"aa\"; \"aaa\"] = \"First\")\n\n[<EntryPoint>]\nlet main argv =\n    TestGameWinner.testWillFirstPlayerWin()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// countDivisibleBy7 counts the number of permutations of digits in a string that form numbers divisible by 7.\n// The function uses backtracking to explore all unique permutations of the digits, skipping duplicates and leading zeros.\nlet countDivisibleBy7 (s: string) =\n    let digits = s |> Seq.sort |> Seq.toArray\n    let n = digits.Length\n    let mutable count = 0\n    let used = Array.create n false\n\n    let rec backtrack pos currentMod =\n        if pos = n then\n            if currentMod % 7 = 0 then\n                count <- count + 1\n        else\n            for i in 0 .. n - 1 do\n                if not used.[i] then\n                    // Skip duplicates\n                    if i > 0 && digits.[i] = digits.[i - 1] && not used.[i - 1] then\n                        ()\n                    else\n                        // Check leading zero\n                        if pos = 0 && digits.[i] = '0' then\n                            ()\n                        else\n                            used.[i] <- true\n                            let newMod = (currentMod * 10 + (digits.[i] |> string |> int)) % 7\n                            backtrack (pos + 1) newMod\n                            used.[i] <- false\n\n    backtrack 0 0\n    count", "test_cases": "", "test_case_results": "Case 1: Input: 123\nCount: 1\n\nCase 2: Input: 100\nCount: 0\n\nCase 3: Input: 111\nCount: 0\n\nCase 4: Input: 000\nCount: 0\n\nCase 5: Input: 1234\nCount: 3", "task_id": 1007, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestDivisibleBy7 =\n    let checkCountDivisibleBy7() =\n        Debug.Assert(countDivisibleBy7 \"123\" = 1)\n        Debug.Assert(countDivisibleBy7 \"100\" = 0)\n        Debug.Assert(countDivisibleBy7 \"111\" = 0)\n        Debug.Assert(countDivisibleBy7 \"000\" = 0)\n        Debug.Assert(countDivisibleBy7 \"1234\" = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestDivisibleBy7.checkCountDivisibleBy7()\n    0", "all_code": "open System\n\n// countDivisibleBy7 counts the number of permutations of digits in a string that form numbers divisible by 7.\n// The function uses backtracking to explore all unique permutations of the digits, skipping duplicates and leading zeros.\nlet countDivisibleBy7 (s: string) =\n    let digits = s |> Seq.sort |> Seq.toArray\n    let n = digits.Length\n    let mutable count = 0\n    let used = Array.create n false\n\n    let rec backtrack pos currentMod =\n        if pos = n then\n            if currentMod % 7 = 0 then\n                count <- count + 1\n        else\n            for i in 0 .. n - 1 do\n                if not used.[i] then\n                    // Skip duplicates\n                    if i > 0 && digits.[i] = digits.[i - 1] && not used.[i - 1] then\n                        ()\n                    else\n                        // Check leading zero\n                        if pos = 0 && digits.[i] = '0' then\n                            ()\n                        else\n                            used.[i] <- true\n                            let newMod = (currentMod * 10 + (digits.[i] |> string |> int)) % 7\n                            backtrack (pos + 1) newMod\n                            used.[i] <- false\n\n    backtrack 0 0\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestDivisibleBy7 =\n    let checkCountDivisibleBy7() =\n        Debug.Assert(countDivisibleBy7 \"123\" = 1)\n        Debug.Assert(countDivisibleBy7 \"100\" = 0)\n        Debug.Assert(countDivisibleBy7 \"111\" = 0)\n        Debug.Assert(countDivisibleBy7 \"000\" = 0)\n        Debug.Assert(countDivisibleBy7 \"1234\" = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestDivisibleBy7.checkCountDivisibleBy7()\n    0", "exec_outcome": "PASSED"}
{"code": "module CandyDistribution =\n\n    // calculateMinCandies computes the minimum number of candies required for a given array of ratings.\n    // The algorithm first traverses the array from left to right, then from right to left,\n    // ensuring that children with higher ratings get more candies than their neighbors.\n    let calculateMinCandies (ratings: int array) =\n        let n = ratings.Length\n        if n = 0 then 0\n        else\n            let candies = Array.create n 1\n\n            // Left to right pass\n            for i in 1 .. n - 1 do\n                if ratings.[i] > ratings.[i - 1] then\n                    candies.[i] <- candies.[i - 1] + 1\n                elif ratings.[i] = ratings.[i - 1] then\n                    candies.[i] <- candies.[i - 1]\n\n            // Right to left pass\n            for i in n - 2 .. -1 .. 0 do\n                if ratings.[i] > ratings.[i + 1] then\n                    candies.[i] <- max candies.[i] (candies.[i + 1] + 1)\n                elif ratings.[i] = ratings.[i + 1] then\n                    candies.[i] <- max candies.[i] candies.[i + 1]\n\n            Array.sum candies", "test_cases": "", "test_case_results": "Input: [|12; 13; 14; 5; 10; 13|]\nMinimum candies required: 12\nInput: [|2; 2; 2; 2; 2; 2|]\nMinimum candies required: 6\nInput: [|0|]\nMinimum candies required: 1\nInput: [||]\nMinimum candies required: 0", "task_id": 29253, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCandyDistribution =\n    let checkCalculateMinCandies() =\n        Debug.Assert(CandyDistribution.calculateMinCandies [|12; 13; 14; 5; 10; 13|] = 12)\n        Debug.Assert(CandyDistribution.calculateMinCandies [|2; 2; 2; 2; 2; 2|] = 6)\n        Debug.Assert(CandyDistribution.calculateMinCandies [|0|] = 1)\n        Debug.Assert(CandyDistribution.calculateMinCandies [||] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestCandyDistribution.checkCalculateMinCandies()\n    0", "all_code": "module CandyDistribution =\n\n    // calculateMinCandies computes the minimum number of candies required for a given array of ratings.\n    // The algorithm first traverses the array from left to right, then from right to left,\n    // ensuring that children with higher ratings get more candies than their neighbors.\n    let calculateMinCandies (ratings: int array) =\n        let n = ratings.Length\n        if n = 0 then 0\n        else\n            let candies = Array.create n 1\n\n            // Left to right pass\n            for i in 1 .. n - 1 do\n                if ratings.[i] > ratings.[i - 1] then\n                    candies.[i] <- candies.[i - 1] + 1\n                elif ratings.[i] = ratings.[i - 1] then\n                    candies.[i] <- candies.[i - 1]\n\n            // Right to left pass\n            for i in n - 2 .. -1 .. 0 do\n                if ratings.[i] > ratings.[i + 1] then\n                    candies.[i] <- max candies.[i] (candies.[i + 1] + 1)\n                elif ratings.[i] = ratings.[i + 1] then\n                    candies.[i] <- max candies.[i] candies.[i + 1]\n\n            Array.sum candies\nopen System\nopen System.Diagnostics\n\nmodule TestCandyDistribution =\n    let checkCalculateMinCandies() =\n        Debug.Assert(CandyDistribution.calculateMinCandies [|12; 13; 14; 5; 10; 13|] = 12)\n        Debug.Assert(CandyDistribution.calculateMinCandies [|2; 2; 2; 2; 2; 2|] = 6)\n        Debug.Assert(CandyDistribution.calculateMinCandies [|0|] = 1)\n        Debug.Assert(CandyDistribution.calculateMinCandies [||] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestCandyDistribution.checkCalculateMinCandies()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// parseBooleanExpression parses a string containing a boolean expression with leading '!' characters.\n// It returns a tuple of (negationCount, baseBoolean) where:\n// - negationCount is the number of leading '!' characters\n// - baseBoolean is the underlying boolean value (either true or false)\nlet parseBooleanExpression (s: string) =\n    let trimmed = s.Trim()\n    let mutable count = 0\n    let mutable i = 0\n    \n    // Count leading '!' characters\n    while i < trimmed.Length && trimmed.[i] = '!' do\n        count <- count + 1\n        i <- i + 1\n    \n    // Extract the boolean part\n    let booleanPart = trimmed.[i..].Trim()\n    \n    // Determine the base boolean value\n    let baseBoolean = \n        match booleanPart.ToLower() with\n        | \"true\" -> true\n        | \"false\" -> false\n        | _ -> failwith \"Invalid boolean expression\"\n    \n    (count, baseBoolean)\n\n// evaluateBooleanExpression evaluates a parsed boolean expression with negation.\n// It takes the count of leading '!' characters and the base boolean value,\n// and returns the final result after applying the negations.\nlet evaluateBooleanExpression (negationCount: int, baseBoolean: bool) =\n    if negationCount % 2 = 1 then\n        not baseBoolean\n    else\n        baseBoolean", "test_cases": "", "test_case_results": "Testing boolean expression evaluation:\n\nInput: \"!!True\"\nNegation count: 2, Base boolean: true\nFinal result: true\n\nInput: \"!False\"\nNegation count: 1, Base boolean: false\nFinal result: true\n\nInput: \"!!!True\"\nNegation count: 3, Base boolean: true\nFinal result: false\n\nInput: \"False\"\nNegation count: 0, Base boolean: false\nFinal result: false\n\nInput: \"!True\"\nNegation count: 1, Base boolean: true\nFinal result: false\n\nInput: \"   !!!   False   \"\nNegation count: 3, Base boolean: false\nFinal result: true\n\nInput: \"True\"\nNegation count: 0, Base boolean: true\nFinal result: true", "task_id": 16442, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestBooleanExpression =\n    let checkBooleanExpressions() =\n        let testCase1 = \"!!True\"\n        let testCase2 = \"!False\"\n        let testCase3 = \"!!!True\"\n        let testCase4 = \"False\"\n        let testCase5 = \"!True\"\n        let testCase6 = \"   !!!   False   \"\n        let testCase7 = \"True\"\n        \n        let (count1, base1) = parseBooleanExpression testCase1\n        Debug.Assert(evaluateBooleanExpression (count1, base1) = true)\n        \n        let (count2, base2) = parseBooleanExpression testCase2\n        Debug.Assert(evaluateBooleanExpression (count2, base2) = true)\n        \n        let (count3, base3) = parseBooleanExpression testCase3\n        Debug.Assert(evaluateBooleanExpression (count3, base3) = false)\n        \n        let (count4, base4) = parseBooleanExpression testCase4\n        Debug.Assert(evaluateBooleanExpression (count4, base4) = false)\n        \n        let (count5, base5) = parseBooleanExpression testCase5\n        Debug.Assert(evaluateBooleanExpression (count5, base5) = false)\n        \n        let (count6, base6) = parseBooleanExpression testCase6\n        Debug.Assert(evaluateBooleanExpression (count6, base6) = true)\n        \n        let (count7, base7) = parseBooleanExpression testCase7\n        Debug.Assert(evaluateBooleanExpression (count7, base7) = true)\n\n[<EntryPoint>]\nlet main argv =\n    TestBooleanExpression.checkBooleanExpressions()\n    0", "all_code": "open System\n\n// parseBooleanExpression parses a string containing a boolean expression with leading '!' characters.\n// It returns a tuple of (negationCount, baseBoolean) where:\n// - negationCount is the number of leading '!' characters\n// - baseBoolean is the underlying boolean value (either true or false)\nlet parseBooleanExpression (s: string) =\n    let trimmed = s.Trim()\n    let mutable count = 0\n    let mutable i = 0\n    \n    // Count leading '!' characters\n    while i < trimmed.Length && trimmed.[i] = '!' do\n        count <- count + 1\n        i <- i + 1\n    \n    // Extract the boolean part\n    let booleanPart = trimmed.[i..].Trim()\n    \n    // Determine the base boolean value\n    let baseBoolean = \n        match booleanPart.ToLower() with\n        | \"true\" -> true\n        | \"false\" -> false\n        | _ -> failwith \"Invalid boolean expression\"\n    \n    (count, baseBoolean)\n\n// evaluateBooleanExpression evaluates a parsed boolean expression with negation.\n// It takes the count of leading '!' characters and the base boolean value,\n// and returns the final result after applying the negations.\nlet evaluateBooleanExpression (negationCount: int, baseBoolean: bool) =\n    if negationCount % 2 = 1 then\n        not baseBoolean\n    else\n        baseBoolean\nopen System\nopen System.Diagnostics\n\nmodule TestBooleanExpression =\n    let checkBooleanExpressions() =\n        let testCase1 = \"!!True\"\n        let testCase2 = \"!False\"\n        let testCase3 = \"!!!True\"\n        let testCase4 = \"False\"\n        let testCase5 = \"!True\"\n        let testCase6 = \"   !!!   False   \"\n        let testCase7 = \"True\"\n        \n        let (count1, base1) = parseBooleanExpression testCase1\n        Debug.Assert(evaluateBooleanExpression (count1, base1) = true)\n        \n        let (count2, base2) = parseBooleanExpression testCase2\n        Debug.Assert(evaluateBooleanExpression (count2, base2) = true)\n        \n        let (count3, base3) = parseBooleanExpression testCase3\n        Debug.Assert(evaluateBooleanExpression (count3, base3) = false)\n        \n        let (count4, base4) = parseBooleanExpression testCase4\n        Debug.Assert(evaluateBooleanExpression (count4, base4) = false)\n        \n        let (count5, base5) = parseBooleanExpression testCase5\n        Debug.Assert(evaluateBooleanExpression (count5, base5) = false)\n        \n        let (count6, base6) = parseBooleanExpression testCase6\n        Debug.Assert(evaluateBooleanExpression (count6, base6) = true)\n        \n        let (count7, base7) = parseBooleanExpression testCase7\n        Debug.Assert(evaluateBooleanExpression (count7, base7) = true)\n\n[<EntryPoint>]\nlet main argv =\n    TestBooleanExpression.checkBooleanExpressions()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// ProductOfArray calculates the product of elements in a given range of an array.\n// It uses a prefix product array to allow O(1) range product queries.\ntype ProductOfArray(nums: int array) =\n    // Initialize the cumulative product array with an extra first element as 1 for easier calculation\n    let prefixProducts = \n        let products = Array.zeroCreate (nums.Length + 1)\n        products.[0] <- 1\n        for i in 0 .. nums.Length - 1 do\n            products.[i + 1] <- products.[i] * nums.[i]\n        products\n\n    // product returns the product of all elements in the array within the range [left, right], inclusive.\n    // It runs in O(1) time.\n    member this.Product(left: int, right: int) =\n        prefixProducts.[right + 1] / prefixProducts.[left]", "test_cases": "", "test_case_results": "Input Array: [|1; 2; 3; 4|], Range: [0, 2]\nProduct: 6\nInput Array: [|5; 6; 7; 0|], Range: [1, 3]\nProduct: 0\nInput Array: [|0; 0; 0; 0|], Range: [0, 3]\nProduct: 0\nInput Array: [|1; 1; 1; 1|], Range: [0, 0]\nProduct: 1", "task_id": 29624, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestProductOfArray =\n    let checkProductOfArray() =\n        let testCases = [|\n            ([|1; 2; 3; 4|], (0, 2), 6)\n            ([|5; 6; 7; 0|], (1, 3), 0)\n            ([|0; 0; 0; 0|], (0, 3), 0)\n            ([|1; 1; 1; 1|], (0, 0), 1)\n        |]\n\n        for (nums, (left, right), expected) in testCases do\n            let productCalculator = ProductOfArray(nums)\n            let actual = productCalculator.Product(left, right)\n            Debug.Assert(actual = expected, sprintf \"Test failed for array %A and range [%d,%d]. Expected: %d, Actual: %d\" nums left right expected actual)\n\n[<EntryPoint>]\nlet main argv =\n    TestProductOfArray.checkProductOfArray()\n    0", "all_code": "open System\n\n// ProductOfArray calculates the product of elements in a given range of an array.\n// It uses a prefix product array to allow O(1) range product queries.\ntype ProductOfArray(nums: int array) =\n    // Initialize the cumulative product array with an extra first element as 1 for easier calculation\n    let prefixProducts = \n        let products = Array.zeroCreate (nums.Length + 1)\n        products.[0] <- 1\n        for i in 0 .. nums.Length - 1 do\n            products.[i + 1] <- products.[i] * nums.[i]\n        products\n\n    // product returns the product of all elements in the array within the range [left, right], inclusive.\n    // It runs in O(1) time.\n    member this.Product(left: int, right: int) =\n        prefixProducts.[right + 1] / prefixProducts.[left]\nopen System\nopen System.Diagnostics\n\nmodule TestProductOfArray =\n    let checkProductOfArray() =\n        let testCases = [|\n            ([|1; 2; 3; 4|], (0, 2), 6)\n            ([|5; 6; 7; 0|], (1, 3), 0)\n            ([|0; 0; 0; 0|], (0, 3), 0)\n            ([|1; 1; 1; 1|], (0, 0), 1)\n        |]\n\n        for (nums, (left, right), expected) in testCases do\n            let productCalculator = ProductOfArray(nums)\n            let actual = productCalculator.Product(left, right)\n            Debug.Assert(actual = expected, sprintf \"Test failed for array %A and range [%d,%d]. Expected: %d, Actual: %d\" nums left right expected actual)\n\n[<EntryPoint>]\nlet main argv =\n    TestProductOfArray.checkProductOfArray()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// findTrashFiles filters a list of file paths to only include those that end with the '.Trash-1000' extension.\n// If the input list is empty, it returns an empty list.\nlet findTrashFiles (filePaths: string list) =\n    filePaths |> List.filter (fun path -> path.EndsWith(\".Trash-1000\"))", "test_cases": "", "test_case_results": "Input: [\"/home/user/file1.txt\"; \"/home/user/file2.Trash-1000\";\n \"/home/user/file3.Trash-1000\"]\nTrash Files: [\"/home/user/file2.Trash-1000\"; \"/home/user/file3.Trash-1000\"]\n\nInput: [\"/tmp/a.Trash-1000\"; \"/tmp/b.txt\"; \"/tmp/c.Trash-1000\"]\nTrash Files: [\"/tmp/a.Trash-1000\"; \"/tmp/c.Trash-1000\"]\n\nInput: [\"/var/log/syslog\"; \"/var/log/kern.log\"; \"/var/log/auth.log\"]\nTrash Files: []\n\nInput: []\nTrash Files: []", "task_id": 19883, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestTrashFiles =\n    let checkFindTrashFiles() =\n        Debug.Assert(findTrashFiles [\"/home/user/file1.txt\"; \"/home/user/file2.Trash-1000\"; \"/home/user/file3.Trash-1000\"] = \n                    [\"/home/user/file2.Trash-1000\"; \"/home/user/file3.Trash-1000\"])\n        Debug.Assert(findTrashFiles [\"/tmp/a.Trash-1000\"; \"/tmp/b.txt\"; \"/tmp/c.Trash-1000\"] = \n                    [\"/tmp/a.Trash-1000\"; \"/tmp/c.Trash-1000\"])\n        Debug.Assert(findTrashFiles [\"/var/log/syslog\"; \"/var/log/kern.log\"; \"/var/log/auth.log\"] = [])\n        Debug.Assert(findTrashFiles [] = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestTrashFiles.checkFindTrashFiles()\n    0", "all_code": "open System\n\n// findTrashFiles filters a list of file paths to only include those that end with the '.Trash-1000' extension.\n// If the input list is empty, it returns an empty list.\nlet findTrashFiles (filePaths: string list) =\n    filePaths |> List.filter (fun path -> path.EndsWith(\".Trash-1000\"))\nopen System\nopen System.Diagnostics\n\nmodule TestTrashFiles =\n    let checkFindTrashFiles() =\n        Debug.Assert(findTrashFiles [\"/home/user/file1.txt\"; \"/home/user/file2.Trash-1000\"; \"/home/user/file3.Trash-1000\"] = \n                    [\"/home/user/file2.Trash-1000\"; \"/home/user/file3.Trash-1000\"])\n        Debug.Assert(findTrashFiles [\"/tmp/a.Trash-1000\"; \"/tmp/b.txt\"; \"/tmp/c.Trash-1000\"] = \n                    [\"/tmp/a.Trash-1000\"; \"/tmp/c.Trash-1000\"])\n        Debug.Assert(findTrashFiles [\"/var/log/syslog\"; \"/var/log/kern.log\"; \"/var/log/auth.log\"] = [])\n        Debug.Assert(findTrashFiles [] = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestTrashFiles.checkFindTrashFiles()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\n// isBalanced determines if the given string S is balanced.\n// A string is balanced if every letter in it appears the same number of times.\nlet isBalanced (S: string) =\n    // Count the frequency of each character in the string\n    let frequency = Dictionary<char, int>()\n    for c in S do\n        if frequency.ContainsKey(c) then\n            frequency.[c] <- frequency.[c] + 1\n        else\n            frequency.Add(c, 1)\n    \n    // Get set of unique frequencies\n    let uniqueFrequencies = frequency.Values |> Seq.distinct |> Seq.toList\n    \n    // Check if there is only one unique frequency\n    if uniqueFrequencies.Length = 1 then\n        \"Yes\"\n    else\n        \"No\"", "test_cases": "", "test_case_results": "Input: aabbcc\nResult: Yes\nInput: aabbc\nResult: No\nInput: abc\nResult: Yes\nInput: aabbbb\nResult: No\nInput: \nResult: No", "task_id": 12606, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestIsBalanced =\n    let checkIsBalanced() =\n        Debug.Assert(isBalanced \"aabbcc\" = \"Yes\")\n        Debug.Assert(isBalanced \"aabbc\" = \"No\")\n        Debug.Assert(isBalanced \"abc\" = \"Yes\")\n        Debug.Assert(isBalanced \"aabbbb\" = \"No\")\n        Debug.Assert(isBalanced \"\" = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestIsBalanced.checkIsBalanced()\n    0", "all_code": "open System.Collections.Generic\n\n// isBalanced determines if the given string S is balanced.\n// A string is balanced if every letter in it appears the same number of times.\nlet isBalanced (S: string) =\n    // Count the frequency of each character in the string\n    let frequency = Dictionary<char, int>()\n    for c in S do\n        if frequency.ContainsKey(c) then\n            frequency.[c] <- frequency.[c] + 1\n        else\n            frequency.Add(c, 1)\n    \n    // Get set of unique frequencies\n    let uniqueFrequencies = frequency.Values |> Seq.distinct |> Seq.toList\n    \n    // Check if there is only one unique frequency\n    if uniqueFrequencies.Length = 1 then\n        \"Yes\"\n    else\n        \"No\"\nopen System\nopen System.Diagnostics\n\nmodule TestIsBalanced =\n    let checkIsBalanced() =\n        Debug.Assert(isBalanced \"aabbcc\" = \"Yes\")\n        Debug.Assert(isBalanced \"aabbc\" = \"No\")\n        Debug.Assert(isBalanced \"abc\" = \"Yes\")\n        Debug.Assert(isBalanced \"aabbbb\" = \"No\")\n        Debug.Assert(isBalanced \"\" = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestIsBalanced.checkIsBalanced()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// getMatrix creates a matrix (2D array) based on hard-coded dimensions and values.\n// For testing purposes, we use predefined values instead of user input.\nlet getMatrix () =\n    // Hard-coded matrix dimensions and values for testing\n    let rows = 3\n    let cols = 3\n    [|\n        [|1; 2; 3|]\n        [|4; 5; 6|]\n        [|7; 8; 9|]\n    |]\n\n// lessThan10 filters all numbers less than 10 from a 2D array (matrix).\n// It returns a 1D array containing all numbers less than 10.\nlet lessThan10 (matrix: int[][]) =\n    matrix\n    |> Array.collect (fun row -> row |> Array.filter (fun num -> num < 10))", "test_cases": "", "test_case_results": "Input Matrix: [|[|1; 2; 3|]; [|4; 5; 6|]; [|7; 8; 9|]|]\nNumbers less than 10: [|1; 2; 3; 4; 5; 6; 7; 8; 9|]", "task_id": 25316, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMatrixOperations =\n    let checkLessThan10() =\n        let testMatrix = getMatrix()\n        let result = lessThan10 testMatrix\n        Debug.Assert(result = [|1; 2; 3; 4; 5; 6; 7; 8; 9|])\n\n[<EntryPoint>]\nlet main argv =\n    TestMatrixOperations.checkLessThan10()\n    0", "all_code": "open System\n\n// getMatrix creates a matrix (2D array) based on hard-coded dimensions and values.\n// For testing purposes, we use predefined values instead of user input.\nlet getMatrix () =\n    // Hard-coded matrix dimensions and values for testing\n    let rows = 3\n    let cols = 3\n    [|\n        [|1; 2; 3|]\n        [|4; 5; 6|]\n        [|7; 8; 9|]\n    |]\n\n// lessThan10 filters all numbers less than 10 from a 2D array (matrix).\n// It returns a 1D array containing all numbers less than 10.\nlet lessThan10 (matrix: int[][]) =\n    matrix\n    |> Array.collect (fun row -> row |> Array.filter (fun num -> num < 10))\nopen System\nopen System.Diagnostics\n\nmodule TestMatrixOperations =\n    let checkLessThan10() =\n        let testMatrix = getMatrix()\n        let result = lessThan10 testMatrix\n        Debug.Assert(result = [|1; 2; 3; 4; 5; 6; 7; 8; 9|])\n\n[<EntryPoint>]\nlet main argv =\n    TestMatrixOperations.checkLessThan10()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// matrixMultiplication multiplies two matrices A and B where A is of size NxM and B is of size MxP.\n// The function returns the resultant matrix C of size NxP.\nlet matrixMultiplication (A: int[,]) (B: int[,]) (N: int) (M: int) (P: int) =\n    // Initialize matrix C with zeros\n    let C = Array2D.zeroCreate<int> N P\n    \n    // Perform matrix multiplication\n    for i in 0..N-1 do\n        for j in 0..P-1 do\n            for k in 0..M-1 do\n                C.[i, j] <- C.[i, j] + A.[i, k] * B.[k, j]\n    C", "test_cases": "", "test_case_results": "Test Case 1:\nMatrix A: [[1; 2; 3]\n [4; 5; 6]]\nMatrix B: [[7; 8]\n [9; 10]\n [11; 12]]\nResultant Matrix C: [[58; 64]\n [139; 154]]\n\nTest Case 2:\nMatrix A: [[1; 2]\n [3; 4]\n [5; 6]]\nMatrix B: [[7; 8; 9]\n [10; 11; 12]]\nResultant Matrix C: [[27; 30; 33]\n [61; 68; 75]\n [95; 106; 117]]\n\nTest Case 3:\nMatrix A: [[1; 2]]\nMatrix B: [[3]\n [4]]\nResultant Matrix C: [[11]]", "task_id": 24018, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMatrixMultiplication =\n    let checkMatrixMultiplication() =\n        // Test case 1: Multiply 2x3 matrix with 3x2 matrix\n        let A1 = array2D [ [1; 2; 3]; [4; 5; 6] ]\n        let B1 = array2D [ [7; 8]; [9; 10]; [11; 12] ]\n        let C1 = matrixMultiplication A1 B1 2 3 2\n        Debug.Assert(C1 = array2D [ [58; 64]; [139; 154] ])\n\n        // Test case 2: Multiply 3x2 matrix with 2x3 matrix\n        let A2 = array2D [ [1; 2]; [3; 4]; [5; 6] ]\n        let B2 = array2D [ [7; 8; 9]; [10; 11; 12] ]\n        let C2 = matrixMultiplication A2 B2 3 2 3\n        Debug.Assert(C2 = array2D [ [27; 30; 33]; [61; 68; 75]; [95; 106; 117] ])\n\n        // Test case 3: Multiply 1x2 matrix with 2x1 matrix\n        let A3 = array2D [ [1; 2] ]\n        let B3 = array2D [ [3]; [4] ]\n        let C3 = matrixMultiplication A3 B3 1 2 1\n        Debug.Assert(C3 = array2D [ [11] ])\n\n[<EntryPoint>]\nlet main argv =\n    TestMatrixMultiplication.checkMatrixMultiplication()\n    0", "all_code": "open System\n\n// matrixMultiplication multiplies two matrices A and B where A is of size NxM and B is of size MxP.\n// The function returns the resultant matrix C of size NxP.\nlet matrixMultiplication (A: int[,]) (B: int[,]) (N: int) (M: int) (P: int) =\n    // Initialize matrix C with zeros\n    let C = Array2D.zeroCreate<int> N P\n    \n    // Perform matrix multiplication\n    for i in 0..N-1 do\n        for j in 0..P-1 do\n            for k in 0..M-1 do\n                C.[i, j] <- C.[i, j] + A.[i, k] * B.[k, j]\n    C\nopen System\nopen System.Diagnostics\n\nmodule TestMatrixMultiplication =\n    let checkMatrixMultiplication() =\n        // Test case 1: Multiply 2x3 matrix with 3x2 matrix\n        let A1 = array2D [ [1; 2; 3]; [4; 5; 6] ]\n        let B1 = array2D [ [7; 8]; [9; 10]; [11; 12] ]\n        let C1 = matrixMultiplication A1 B1 2 3 2\n        Debug.Assert(C1 = array2D [ [58; 64]; [139; 154] ])\n\n        // Test case 2: Multiply 3x2 matrix with 2x3 matrix\n        let A2 = array2D [ [1; 2]; [3; 4]; [5; 6] ]\n        let B2 = array2D [ [7; 8; 9]; [10; 11; 12] ]\n        let C2 = matrixMultiplication A2 B2 3 2 3\n        Debug.Assert(C2 = array2D [ [27; 30; 33]; [61; 68; 75]; [95; 106; 117] ])\n\n        // Test case 3: Multiply 1x2 matrix with 2x1 matrix\n        let A3 = array2D [ [1; 2] ]\n        let B3 = array2D [ [3]; [4] ]\n        let C3 = matrixMultiplication A3 B3 1 2 1\n        Debug.Assert(C3 = array2D [ [11] ])\n\n[<EntryPoint>]\nlet main argv =\n    TestMatrixMultiplication.checkMatrixMultiplication()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// Dynamic programming solution to find the maximum sum of skills that does not exceed a given limit k.\n// The function takes the number of skills (n), the maximum allowed sum (k), and an array of skill values.\n// It returns the maximum sum of skills that can be achieved without exceeding k.\nlet findMaxSkillSum (n: int) (k: int) (skills: int array) =\n    let dp = Array.zeroCreate (k + 1)\n    \n    for skill in skills do\n        for j in k .. -1 .. skill do\n            dp.[j] <- max dp.[j] (dp.[j - skill] + skill)\n    \n    dp.[k]", "test_cases": "", "test_case_results": "Input: n=3, k=10, skills=[|4; 5; 6|]\nMaximum skill sum: 10\nInput: n=4, k=15, skills=[|2; 3; 5; 7|]\nMaximum skill sum: 15\nInput: n=5, k=20, skills=[|1; 2; 3; 4; 5|]\nMaximum skill sum: 15\nInput: n=2, k=5, skills=[|6; 7|]\nMaximum skill sum: 0", "task_id": 26993, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxSkillSum =\n    let checkMaxSkillSum() =\n        Debug.Assert(findMaxSkillSum 3 10 [|4; 5; 6|] = 10)\n        Debug.Assert(findMaxSkillSum 4 15 [|2; 3; 5; 7|] = 15)\n        Debug.Assert(findMaxSkillSum 5 20 [|1; 2; 3; 4; 5|] = 15)\n        Debug.Assert(findMaxSkillSum 2 5 [|6; 7|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSkillSum.checkMaxSkillSum()\n    0", "all_code": "// Dynamic programming solution to find the maximum sum of skills that does not exceed a given limit k.\n// The function takes the number of skills (n), the maximum allowed sum (k), and an array of skill values.\n// It returns the maximum sum of skills that can be achieved without exceeding k.\nlet findMaxSkillSum (n: int) (k: int) (skills: int array) =\n    let dp = Array.zeroCreate (k + 1)\n    \n    for skill in skills do\n        for j in k .. -1 .. skill do\n            dp.[j] <- max dp.[j] (dp.[j - skill] + skill)\n    \n    dp.[k]\nopen System\nopen System.Diagnostics\n\nmodule TestMaxSkillSum =\n    let checkMaxSkillSum() =\n        Debug.Assert(findMaxSkillSum 3 10 [|4; 5; 6|] = 10)\n        Debug.Assert(findMaxSkillSum 4 15 [|2; 3; 5; 7|] = 15)\n        Debug.Assert(findMaxSkillSum 5 20 [|1; 2; 3; 4; 5|] = 15)\n        Debug.Assert(findMaxSkillSum 2 5 [|6; 7|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSkillSum.checkMaxSkillSum()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Converts a time string in \"HH:MM\" format to minutes since midnight for easier comparison.\nlet timeToMinutes (time: string) =\n    let parts = time.Split(':')\n    int parts.[0] * 60 + int parts.[1]\n\n// Converts minutes since midnight back to \"HH:MM\" format.\nlet minutesToTime (minutes: int) =\n    sprintf \"%02d:%02d\" (minutes / 60) (minutes % 60)\n\n// findFreeTimeSlots returns a list of free time slots not covered by the given meetings within the working day 09:00 to 17:00.\n// Parameters:\n//   meetings: String containing a series of meetings in the format \"HH:MM-HH:MM\" separated by commas.\n// Returns:\n//   List of tuples where each tuple represents a free time slot in the format (\"HH:MM\", \"HH:MM\").\nlet findFreeTimeSlots (meetings: string) =\n    let workStart = \"09:00\"\n    let workEnd = \"17:00\"\n    \n    // Split the meetings into start and end times tuples\n    let meetingsIntervals =\n        meetings.Split([|\", \"|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun meeting -> \n            let parts = meeting.Split('-')\n            (parts.[0], parts.[1]))\n    \n    // Convert all times to minutes for easier comparison\n    let meetingsInMinutes =\n        meetingsIntervals\n        |> Array.map (fun (start, end_) -> (timeToMinutes start, timeToMinutes end_))\n        |> Array.sortBy fst\n    \n    // Add the working hours to the interval list\n    let workStartMinutes = timeToMinutes workStart\n    let workEndMinutes = timeToMinutes workEnd\n    let allIntervals =\n        Array.append [| (workStartMinutes, workStartMinutes) |] meetingsInMinutes\n        |> Array.append [| (workEndMinutes, workEndMinutes) |]\n        |> Array.sortBy fst\n    \n    // Find free slots between meetings\n    let freeSlots =\n        allIntervals\n        |> Array.pairwise\n        |> Array.choose (fun ((_, endCurrent), (startNext, _)) ->\n            if endCurrent < startNext then\n                Some (minutesToTime endCurrent, minutesToTime startNext)\n            else\n                None)\n    \n    List.ofArray freeSlots", "test_cases": "", "test_case_results": "Input: \"09:00-10:00, 12:00-13:00, 16:00-17:00\"\nFree Time Slots: [(\"10:00\", \"12:00\"); (\"13:00\", \"16:00\")]\n\nInput: \"10:00-11:00, 12:30-13:30, 14:00-15:00\"\nFree Time Slots: [(\"09:00\", \"10:00\"); (\"11:00\", \"12:30\"); (\"13:30\", \"14:00\"); (\"15:00\", \"17:00\")]\n\nInput: \"09:00-12:00, 13:00-17:00\"\nFree Time Slots: [(\"12:00\", \"13:00\")]\n\nInput: \"\"\nFree Time Slots: [(\"09:00\", \"17:00\")]", "task_id": 10812, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFreeTimeSlots =\n    let checkFindFreeTimeSlots() =\n        let testCase1 = \"09:00-10:00, 12:00-13:00, 16:00-17:00\"\n        let result1 = findFreeTimeSlots testCase1\n        Debug.Assert(result1 = [(\"10:00\", \"12:00\"); (\"13:00\", \"16:00\")])\n        \n        let testCase2 = \"10:00-11:00, 12:30-13:30, 14:00-15:00\"\n        let result2 = findFreeTimeSlots testCase2\n        Debug.Assert(result2 = [(\"09:00\", \"10:00\"); (\"11:00\", \"12:30\"); (\"13:30\", \"14:00\"); (\"15:00\", \"17:00\")])\n        \n        let testCase3 = \"09:00-12:00, 13:00-17:00\"\n        let result3 = findFreeTimeSlots testCase3\n        Debug.Assert(result3 = [(\"12:00\", \"13:00\")])\n        \n        let testCase4 = \"\"\n        let result4 = findFreeTimeSlots testCase4\n        Debug.Assert(result4 = [(\"09:00\", \"17:00\")])\n\n[<EntryPoint>]\nlet main argv =\n    TestFreeTimeSlots.checkFindFreeTimeSlots()\n    0", "all_code": "open System\n\n// Converts a time string in \"HH:MM\" format to minutes since midnight for easier comparison.\nlet timeToMinutes (time: string) =\n    let parts = time.Split(':')\n    int parts.[0] * 60 + int parts.[1]\n\n// Converts minutes since midnight back to \"HH:MM\" format.\nlet minutesToTime (minutes: int) =\n    sprintf \"%02d:%02d\" (minutes / 60) (minutes % 60)\n\n// findFreeTimeSlots returns a list of free time slots not covered by the given meetings within the working day 09:00 to 17:00.\n// Parameters:\n//   meetings: String containing a series of meetings in the format \"HH:MM-HH:MM\" separated by commas.\n// Returns:\n//   List of tuples where each tuple represents a free time slot in the format (\"HH:MM\", \"HH:MM\").\nlet findFreeTimeSlots (meetings: string) =\n    let workStart = \"09:00\"\n    let workEnd = \"17:00\"\n    \n    // Split the meetings into start and end times tuples\n    let meetingsIntervals =\n        meetings.Split([|\", \"|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun meeting -> \n            let parts = meeting.Split('-')\n            (parts.[0], parts.[1]))\n    \n    // Convert all times to minutes for easier comparison\n    let meetingsInMinutes =\n        meetingsIntervals\n        |> Array.map (fun (start, end_) -> (timeToMinutes start, timeToMinutes end_))\n        |> Array.sortBy fst\n    \n    // Add the working hours to the interval list\n    let workStartMinutes = timeToMinutes workStart\n    let workEndMinutes = timeToMinutes workEnd\n    let allIntervals =\n        Array.append [| (workStartMinutes, workStartMinutes) |] meetingsInMinutes\n        |> Array.append [| (workEndMinutes, workEndMinutes) |]\n        |> Array.sortBy fst\n    \n    // Find free slots between meetings\n    let freeSlots =\n        allIntervals\n        |> Array.pairwise\n        |> Array.choose (fun ((_, endCurrent), (startNext, _)) ->\n            if endCurrent < startNext then\n                Some (minutesToTime endCurrent, minutesToTime startNext)\n            else\n                None)\n    \n    List.ofArray freeSlots\nopen System\nopen System.Diagnostics\n\nmodule TestFreeTimeSlots =\n    let checkFindFreeTimeSlots() =\n        let testCase1 = \"09:00-10:00, 12:00-13:00, 16:00-17:00\"\n        let result1 = findFreeTimeSlots testCase1\n        Debug.Assert(result1 = [(\"10:00\", \"12:00\"); (\"13:00\", \"16:00\")])\n        \n        let testCase2 = \"10:00-11:00, 12:30-13:30, 14:00-15:00\"\n        let result2 = findFreeTimeSlots testCase2\n        Debug.Assert(result2 = [(\"09:00\", \"10:00\"); (\"11:00\", \"12:30\"); (\"13:30\", \"14:00\"); (\"15:00\", \"17:00\")])\n        \n        let testCase3 = \"09:00-12:00, 13:00-17:00\"\n        let result3 = findFreeTimeSlots testCase3\n        Debug.Assert(result3 = [(\"12:00\", \"13:00\")])\n        \n        let testCase4 = \"\"\n        let result4 = findFreeTimeSlots testCase4\n        Debug.Assert(result4 = [(\"09:00\", \"17:00\")])\n\n[<EntryPoint>]\nlet main argv =\n    TestFreeTimeSlots.checkFindFreeTimeSlots()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// This module contains functions for finding the maximum consecutive sequence of binary digits\n// after flipping at most k digits. The solution uses a sliding window approach.\n\n// maxConsecutive finds the maximum length of consecutive 'target' digits in a binary array\n// by flipping at most 'kFlips' non-target digits.\n// Parameters:\n//   - arr: array of binary digits (0s and 1s)\n//   - target: the digit we want consecutive sequence of (0 or 1)\n//   - kFlips: maximum number of non-target digits we can flip\nlet maxConsecutive (arr: int array) (target: int) (kFlips: int) =\n    let mutable left = 0\n    let mutable maxLen = 0\n    let mutable flipCount = 0\n    \n    for right in 0 .. arr.Length - 1 do\n        if arr.[right] <> target then\n            flipCount <- flipCount + 1\n        \n        while flipCount > kFlips do\n            if arr.[left] <> target then\n                flipCount <- flipCount - 1\n            left <- left + 1\n        \n        let currentLen = right - left + 1\n        if currentLen > maxLen then\n            maxLen = currentLen\n    \n    maxLen", "test_cases": "", "test_case_results": "Input array: [|1; 0; 0; 1; 0; 1; 0; 1|], k: 1\nMaximum consecutive 0s with 1 flips: 4\nMaximum consecutive 1s with 1 flips: 3\nFinal result (maximum of both): 4\n\nInput array: [|1; 1; 1; 1; 1|], k: 2\nMaximum consecutive 0s with 2 flips: 2\nMaximum consecutive 1s with 2 flips: 5\nFinal result (maximum of both): 5\n\nInput array: [|0; 0; 0; 0; 0|], k: 3\nMaximum consecutive 0s with 3 flips: 5\nMaximum consecutive 1s with 3 flips: 3\nFinal result (maximum of both): 5\n\nInput array: [|0; 1; 0; 1; 0; 1; 0|], k: 2\nMaximum consecutive 0s with 2 flips: 5\nMaximum consecutive 1s with 2 flips: 5\nFinal result (maximum of both): 5\n\nInput array: [|1; 0; 0; 1; 1; 0; 1; 0; 1; 0; 0; 1|], k: 3\nMaximum consecutive 0s with 3 flips: 7\nMaximum consecutive 1s with 3 flips: 7\nFinal result (maximum of both): 7", "task_id": 25865, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxConsecutive =\n    let checkMaxConsecutive() =\n        // Test case 1: Simple case with k=1\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 0; 1; 0; 1|] 0 1 = 4)\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 0; 1; 0; 1|] 1 1 = 3)\n        \n        // Test case 2: All 1s with k=2\n        Debug.Assert(maxConsecutive [|1; 1; 1; 1; 1|] 0 2 = 2)\n        Debug.Assert(maxConsecutive [|1; 1; 1; 1; 1|] 1 2 = 5)\n        \n        // Test case 3: All 0s with k=3\n        Debug.Assert(maxConsecutive [|0; 0; 0; 0; 0|] 0 3 = 5)\n        Debug.Assert(maxConsecutive [|0; 0; 0; 0; 0|] 1 3 = 3)\n        \n        // Test case 4: Alternating 0s and 1s with k=2\n        Debug.Assert(maxConsecutive [|0; 1; 0; 1; 0; 1; 0|] 0 2 = 5)\n        Debug.Assert(maxConsecutive [|0; 1; 0; 1; 0; 1; 0|] 1 2 = 5)\n        \n        // Test case 5: Complex case with k=3\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 1; 0; 1; 0; 1; 0; 0; 1|] 0 3 = 7)\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 1; 0; 1; 0; 1; 0; 0; 1|] 1 3 = 7)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxConsecutive.checkMaxConsecutive()\n    0", "all_code": "// This module contains functions for finding the maximum consecutive sequence of binary digits\n// after flipping at most k digits. The solution uses a sliding window approach.\n\n// maxConsecutive finds the maximum length of consecutive 'target' digits in a binary array\n// by flipping at most 'kFlips' non-target digits.\n// Parameters:\n//   - arr: array of binary digits (0s and 1s)\n//   - target: the digit we want consecutive sequence of (0 or 1)\n//   - kFlips: maximum number of non-target digits we can flip\nlet maxConsecutive (arr: int array) (target: int) (kFlips: int) =\n    let mutable left = 0\n    let mutable maxLen = 0\n    let mutable flipCount = 0\n    \n    for right in 0 .. arr.Length - 1 do\n        if arr.[right] <> target then\n            flipCount <- flipCount + 1\n        \n        while flipCount > kFlips do\n            if arr.[left] <> target then\n                flipCount <- flipCount - 1\n            left <- left + 1\n        \n        let currentLen = right - left + 1\n        if currentLen > maxLen then\n            maxLen = currentLen\n    \n    maxLen\nopen System\nopen System.Diagnostics\n\nmodule TestMaxConsecutive =\n    let checkMaxConsecutive() =\n        // Test case 1: Simple case with k=1\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 0; 1; 0; 1|] 0 1 = 4)\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 0; 1; 0; 1|] 1 1 = 3)\n        \n        // Test case 2: All 1s with k=2\n        Debug.Assert(maxConsecutive [|1; 1; 1; 1; 1|] 0 2 = 2)\n        Debug.Assert(maxConsecutive [|1; 1; 1; 1; 1|] 1 2 = 5)\n        \n        // Test case 3: All 0s with k=3\n        Debug.Assert(maxConsecutive [|0; 0; 0; 0; 0|] 0 3 = 5)\n        Debug.Assert(maxConsecutive [|0; 0; 0; 0; 0|] 1 3 = 3)\n        \n        // Test case 4: Alternating 0s and 1s with k=2\n        Debug.Assert(maxConsecutive [|0; 1; 0; 1; 0; 1; 0|] 0 2 = 5)\n        Debug.Assert(maxConsecutive [|0; 1; 0; 1; 0; 1; 0|] 1 2 = 5)\n        \n        // Test case 5: Complex case with k=3\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 1; 0; 1; 0; 1; 0; 0; 1|] 0 3 = 7)\n        Debug.Assert(maxConsecutive [|1; 0; 0; 1; 1; 0; 1; 0; 1; 0; 0; 1|] 1 3 = 7)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxConsecutive.checkMaxConsecutive()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// Represents a library with a collection of books\ntype Library() =\n    let books = Collections.Generic.Dictionary<int, string>()\n\n    // Adds a book to the library if it doesn't already exist\n    member this.AddBook(bookId: int, title: string) =\n        if not (books.ContainsKey(bookId)) then\n            books.Add(bookId, title)\n\n    // Removes a book from the library if it exists\n    member this.RemoveBook(bookId: int) =\n        if books.ContainsKey(bookId) then\n            books.Remove(bookId) |> ignore\n\n    // Gets information about a specific book\n    member this.BookInfo(bookId: int) =\n        match books.TryGetValue(bookId) with\n        | true, title -> sprintf \"%d %s\" bookId title\n        | false, _ -> \"Book not found\"\n\n    // Lists all books in the library in sorted order by book ID\n    member this.ListAllBooks() =\n        if books.Count = 0 then\n            \"No books available\"\n        else\n            books\n            |> Seq.sortBy (fun kvp -> kvp.Key)\n            |> Seq.map (fun kvp -> sprintf \"%d %s\" kvp.Key kvp.Value)\n            |> String.concat \"\\n\"\n\n// Processes a sequence of library operations and returns the output\nlet processLibraryOperations (operations: string list) =\n    let library = Library()\n    let output = Collections.Generic.List<string>()\n\n    for operation in operations do\n        let parts = operation.Split([|' '|], 3, StringSplitOptions.RemoveEmptyEntries)\n        match parts with\n        | [|\"AddBook\"; bookId; title|] ->\n            let id = int bookId\n            let cleanTitle = title.Trim('\"')\n            library.AddBook(id, cleanTitle)\n        | [|\"RemoveBook\"; bookId|] ->\n            library.RemoveBook(int bookId)\n        | [|\"BookInfo\"; bookId|] ->\n            output.Add(library.BookInfo(int bookId))\n        | [|\"ListAllBooks\"|] ->\n            output.Add(library.ListAllBooks())\n        | [|\"END\"|] ->\n            ()\n        | _ ->\n            ()\n\n    String.concat \"\\n\" output", "test_cases": "", "test_case_results": "Test Operations:\nAddBook 1 \"The Great Gatsby\"\nAddBook 2 \"To Kill a Mockingbird\"\nAddBook 3 \"1984\"\nBookInfo 2\nListAllBooks\nRemoveBook 2\nBookInfo 2\nListAllBooks\nEND\n\nResults:\n2 To Kill a Mockingbird\n1 The Great Gatsby\n2 To Kill a Mockingbird\n3 1984\nBook not found\n1 The Great Gatsby\n3 1984\n\nEmpty Library Test:\nNo books available\n\nNon-existent Book Test:\nBook not found", "task_id": 7200, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestLibrary =\n    let runTests() =\n        // Test case 1: Basic operations\n        let test1 = [\n            \"AddBook 1 \\\"The Great Gatsby\\\"\"\n            \"AddBook 2 \\\"To Kill a Mockingbird\\\"\"\n            \"AddBook 3 \\\"1984\\\"\"\n            \"BookInfo 2\"\n            \"ListAllBooks\"\n            \"RemoveBook 2\"\n            \"BookInfo 2\"\n            \"ListAllBooks\"\n            \"END\"\n        ]\n        let result1 = processLibraryOperations test1\n        let expected1 = \"2 To Kill a Mockingbird\\n1 The Great Gatsby\\n2 To Kill a Mockingbird\\n3 1984\\nBook not found\\n1 The Great Gatsby\\n3 1984\"\n        Debug.Assert(result1 = expected1, \"Test case 1 failed\")\n\n        // Test case 2: Empty library\n        let test2 = [\"ListAllBooks\"; \"END\"]\n        let result2 = processLibraryOperations test2\n        Debug.Assert(result2 = \"No books available\", \"Test case 2 failed\")\n\n        // Test case 3: Non-existent book\n        let test3 = [\"BookInfo 99\"; \"END\"]\n        let result3 = processLibraryOperations test3\n        Debug.Assert(result3 = \"Book not found\", \"Test case 3 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestLibrary.runTests()\n    0", "all_code": "open System\n\n// Represents a library with a collection of books\ntype Library() =\n    let books = Collections.Generic.Dictionary<int, string>()\n\n    // Adds a book to the library if it doesn't already exist\n    member this.AddBook(bookId: int, title: string) =\n        if not (books.ContainsKey(bookId)) then\n            books.Add(bookId, title)\n\n    // Removes a book from the library if it exists\n    member this.RemoveBook(bookId: int) =\n        if books.ContainsKey(bookId) then\n            books.Remove(bookId) |> ignore\n\n    // Gets information about a specific book\n    member this.BookInfo(bookId: int) =\n        match books.TryGetValue(bookId) with\n        | true, title -> sprintf \"%d %s\" bookId title\n        | false, _ -> \"Book not found\"\n\n    // Lists all books in the library in sorted order by book ID\n    member this.ListAllBooks() =\n        if books.Count = 0 then\n            \"No books available\"\n        else\n            books\n            |> Seq.sortBy (fun kvp -> kvp.Key)\n            |> Seq.map (fun kvp -> sprintf \"%d %s\" kvp.Key kvp.Value)\n            |> String.concat \"\\n\"\n\n// Processes a sequence of library operations and returns the output\nlet processLibraryOperations (operations: string list) =\n    let library = Library()\n    let output = Collections.Generic.List<string>()\n\n    for operation in operations do\n        let parts = operation.Split([|' '|], 3, StringSplitOptions.RemoveEmptyEntries)\n        match parts with\n        | [|\"AddBook\"; bookId; title|] ->\n            let id = int bookId\n            let cleanTitle = title.Trim('\"')\n            library.AddBook(id, cleanTitle)\n        | [|\"RemoveBook\"; bookId|] ->\n            library.RemoveBook(int bookId)\n        | [|\"BookInfo\"; bookId|] ->\n            output.Add(library.BookInfo(int bookId))\n        | [|\"ListAllBooks\"|] ->\n            output.Add(library.ListAllBooks())\n        | [|\"END\"|] ->\n            ()\n        | _ ->\n            ()\n\n    String.concat \"\\n\" output\nopen System\nopen System.Diagnostics\n\nmodule TestLibrary =\n    let runTests() =\n        // Test case 1: Basic operations\n        let test1 = [\n            \"AddBook 1 \\\"The Great Gatsby\\\"\"\n            \"AddBook 2 \\\"To Kill a Mockingbird\\\"\"\n            \"AddBook 3 \\\"1984\\\"\"\n            \"BookInfo 2\"\n            \"ListAllBooks\"\n            \"RemoveBook 2\"\n            \"BookInfo 2\"\n            \"ListAllBooks\"\n            \"END\"\n        ]\n        let result1 = processLibraryOperations test1\n        let expected1 = \"2 To Kill a Mockingbird\\n1 The Great Gatsby\\n2 To Kill a Mockingbird\\n3 1984\\nBook not found\\n1 The Great Gatsby\\n3 1984\"\n        Debug.Assert(result1 = expected1, \"Test case 1 failed\")\n\n        // Test case 2: Empty library\n        let test2 = [\"ListAllBooks\"; \"END\"]\n        let result2 = processLibraryOperations test2\n        Debug.Assert(result2 = \"No books available\", \"Test case 2 failed\")\n\n        // Test case 3: Non-existent book\n        let test3 = [\"BookInfo 99\"; \"END\"]\n        let result3 = processLibraryOperations test3\n        Debug.Assert(result3 = \"Book not found\", \"Test case 3 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestLibrary.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "module FactorialLastDigit =\n\n    // calculateLastDigitOfFactorial computes the last digit of N factorial when N is less than 5.\n    // For N >= 5, it returns 0 since factorial of numbers >=5 ends with 0.\n    let calculateLastDigitOfFactorial (n: int) =\n        if n >= 5 then\n            0\n        else\n            let rec computeFactorial acc i =\n                if i > n then acc\n                else computeFactorial (acc * i) (i + 1)\n            (computeFactorial 1 1) % 10", "test_cases": "", "test_case_results": "Input: 4\nLast digit of factorial: 4\nInput: 4\nLast digit of factorial: 4\nInput: 7\nLast digit of factorial: 0\nInput: 0\nLast digit of factorial: 1\nInput: 4\nLast digit of factorial: 4\nInput: 4\nLast digit of factorial: 4", "task_id": 17526, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFactorialLastDigit =\n    let checkCalculateLastDigitOfFactorial() =\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 7 = 0)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 0 = 1)\n        // Additional test cases from the duplicated inputs\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestFactorialLastDigit.checkCalculateLastDigitOfFactorial()\n    0", "all_code": "module FactorialLastDigit =\n\n    // calculateLastDigitOfFactorial computes the last digit of N factorial when N is less than 5.\n    // For N >= 5, it returns 0 since factorial of numbers >=5 ends with 0.\n    let calculateLastDigitOfFactorial (n: int) =\n        if n >= 5 then\n            0\n        else\n            let rec computeFactorial acc i =\n                if i > n then acc\n                else computeFactorial (acc * i) (i + 1)\n            (computeFactorial 1 1) % 10\nopen System\nopen System.Diagnostics\n\nmodule TestFactorialLastDigit =\n    let checkCalculateLastDigitOfFactorial() =\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 7 = 0)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 0 = 1)\n        // Additional test cases from the duplicated inputs\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n        Debug.Assert(FactorialLastDigit.calculateLastDigitOfFactorial 4 = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestFactorialLastDigit.checkCalculateLastDigitOfFactorial()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\n// findNumberOfGroups calculates the number of distinct connected groups formed by points that are connected either horizontally or vertically.\n// A point is connected to another if they share the same x-coordinate or y-coordinate.\nlet findNumberOfGroups (coordinates: (int * int) list) =\n    // dfs performs a depth-first search to mark all connected points as visited.\n    let dfs (point: int * int) (visited: HashSet<int * int>) (graph: Dictionary<int * int, (int * int) list>) =\n        let stack = Stack<int * int>()\n        stack.Push(point)\n        while stack.Count > 0 do\n            let current = stack.Pop()\n            visited.Add(current) |> ignore\n            for neighbor in graph.[current] do\n                if not (visited.Contains(neighbor)) then\n                    stack.Push(neighbor)\n\n    // Build the adjacency list graph where each point is connected to its neighbors.\n    let graph = Dictionary<int * int, (int * int) list>()\n    for point in coordinates do\n        graph.[point] <- []\n\n    for i in 0 .. coordinates.Length - 1 do\n        let (x1, y1) = coordinates.[i]\n        for j in 0 .. coordinates.Length - 1 do\n            if i <> j then\n                let (x2, y2) = coordinates.[j]\n                if x1 = x2 || y1 = y2 then\n                    graph.[(x1, y1)] <- (x2, y2) :: graph.[(x1, y1)]\n                    graph.[(x2, y2)] <- (x1, y1) :: graph.[(x2, y2)]\n\n    let visited = HashSet<int * int>()\n    let mutable count = 0\n\n    for point in coordinates do\n        if not (visited.Contains(point)) then\n            dfs point visited graph\n            count <- count + 1\n\n    count", "test_cases": "", "test_case_results": "Input: [(1, 1); (2, 2); (3, 3)]\nNumber of groups: 3\nInput: [(1, 1); (1, 2); (2, 1)]\nNumber of groups: 1\nInput: [(1, 1); (1, 2); (2, 2); (3, 3)]\nNumber of groups: 2\nInput: [(1, 1); (2, 1); (3, 1); (1, 2); (2, 2); (3, 2)]\nNumber of groups: 1", "task_id": 1227, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestGroups =\n    let checkFindNumberOfGroups() =\n        Debug.Assert(findNumberOfGroups [(1, 1); (2, 2); (3, 3)] = 3)\n        Debug.Assert(findNumberOfGroups [(1, 1); (1, 2); (2, 1)] = 1)\n        Debug.Assert(findNumberOfGroups [(1, 1); (1, 2); (2, 2); (3, 3)] = 2)\n        Debug.Assert(findNumberOfGroups [(1, 1); (2, 1); (3, 1); (1, 2); (2, 2); (3, 2)] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestGroups.checkFindNumberOfGroups()\n    0", "all_code": "open System.Collections.Generic\n\n// findNumberOfGroups calculates the number of distinct connected groups formed by points that are connected either horizontally or vertically.\n// A point is connected to another if they share the same x-coordinate or y-coordinate.\nlet findNumberOfGroups (coordinates: (int * int) list) =\n    // dfs performs a depth-first search to mark all connected points as visited.\n    let dfs (point: int * int) (visited: HashSet<int * int>) (graph: Dictionary<int * int, (int * int) list>) =\n        let stack = Stack<int * int>()\n        stack.Push(point)\n        while stack.Count > 0 do\n            let current = stack.Pop()\n            visited.Add(current) |> ignore\n            for neighbor in graph.[current] do\n                if not (visited.Contains(neighbor)) then\n                    stack.Push(neighbor)\n\n    // Build the adjacency list graph where each point is connected to its neighbors.\n    let graph = Dictionary<int * int, (int * int) list>()\n    for point in coordinates do\n        graph.[point] <- []\n\n    for i in 0 .. coordinates.Length - 1 do\n        let (x1, y1) = coordinates.[i]\n        for j in 0 .. coordinates.Length - 1 do\n            if i <> j then\n                let (x2, y2) = coordinates.[j]\n                if x1 = x2 || y1 = y2 then\n                    graph.[(x1, y1)] <- (x2, y2) :: graph.[(x1, y1)]\n                    graph.[(x2, y2)] <- (x1, y1) :: graph.[(x2, y2)]\n\n    let visited = HashSet<int * int>()\n    let mutable count = 0\n\n    for point in coordinates do\n        if not (visited.Contains(point)) then\n            dfs point visited graph\n            count <- count + 1\n\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestGroups =\n    let checkFindNumberOfGroups() =\n        Debug.Assert(findNumberOfGroups [(1, 1); (2, 2); (3, 3)] = 3)\n        Debug.Assert(findNumberOfGroups [(1, 1); (1, 2); (2, 1)] = 1)\n        Debug.Assert(findNumberOfGroups [(1, 1); (1, 2); (2, 2); (3, 3)] = 2)\n        Debug.Assert(findNumberOfGroups [(1, 1); (2, 1); (3, 1); (1, 2); (2, 2); (3, 2)] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestGroups.checkFindNumberOfGroups()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// maxProductOfTwo calculates the maximum product of any two distinct numbers in an array.\n// If the array has fewer than two elements, it returns None.\nlet maxProductOfTwo (arr: int array) =\n    if arr.Length < 2 then\n        None\n    else\n        let sortedArr = Array.sortByDescending (fun x -> x) arr\n        let max1 = sortedArr.[0] * sortedArr.[1]  // Product of the two largest numbers\n        let max2 = sortedArr.[sortedArr.Length - 1] * sortedArr.[sortedArr.Length - 2]  // Product of the two smallest numbers (which could be negative)\n        Some (max max1 max2)", "test_cases": "", "test_case_results": "Input: [|1; 2; 3; 4|]\nMax product of two: 12\nInput: [|-1; -2; -3; -4|]\nMax product of two: 12\nInput: [|-1; 2; 3; -4|]\nMax product of two: 6\nInput: [|5|]\nArray has fewer than two elements\nInput: [||]\nArray has fewer than two elements", "task_id": 13097, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxProduct =\n    let checkMaxProductOfTwo() =\n        // Test case 1: Positive numbers\n        Debug.Assert(maxProductOfTwo [|1; 2; 3; 4|] = Some 12)\n        // Test case 2: Negative numbers\n        Debug.Assert(maxProductOfTwo [|-1; -2; -3; -4|] = Some 12)\n        // Test case 3: Mixed positive and negative numbers\n        Debug.Assert(maxProductOfTwo [|-1; 2; 3; -4|] = Some 6)\n        // Test case 4: Single element array\n        Debug.Assert(maxProductOfTwo [|5|] = None)\n        // Test case 5: Empty array\n        Debug.Assert(maxProductOfTwo [||] = None)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxProduct.checkMaxProductOfTwo()\n    0", "all_code": "open System\n\n// maxProductOfTwo calculates the maximum product of any two distinct numbers in an array.\n// If the array has fewer than two elements, it returns None.\nlet maxProductOfTwo (arr: int array) =\n    if arr.Length < 2 then\n        None\n    else\n        let sortedArr = Array.sortByDescending (fun x -> x) arr\n        let max1 = sortedArr.[0] * sortedArr.[1]  // Product of the two largest numbers\n        let max2 = sortedArr.[sortedArr.Length - 1] * sortedArr.[sortedArr.Length - 2]  // Product of the two smallest numbers (which could be negative)\n        Some (max max1 max2)\nopen System\nopen System.Diagnostics\n\nmodule TestMaxProduct =\n    let checkMaxProductOfTwo() =\n        // Test case 1: Positive numbers\n        Debug.Assert(maxProductOfTwo [|1; 2; 3; 4|] = Some 12)\n        // Test case 2: Negative numbers\n        Debug.Assert(maxProductOfTwo [|-1; -2; -3; -4|] = Some 12)\n        // Test case 3: Mixed positive and negative numbers\n        Debug.Assert(maxProductOfTwo [|-1; 2; 3; -4|] = Some 6)\n        // Test case 4: Single element array\n        Debug.Assert(maxProductOfTwo [|5|] = None)\n        // Test case 5: Empty array\n        Debug.Assert(maxProductOfTwo [||] = None)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxProduct.checkMaxProductOfTwo()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// minAbsDiffBetweenTwoHalves calculates the minimum absolute difference between the sums of two halves of an array.\n// The array is split into two halves where one half has size (n + 1) // 2 and the other has the remaining elements.\n// The function explores all possible combinations of indices to find the split that minimizes the absolute difference between the sums of the two halves.\nlet minAbsDiffBetweenTwoHalves (n: int) (arr: int array) =\n    let halfSize = (n + 1) / 2\n    let indices = [|0..n-1|]\n    let mutable minDiff = Int32.MaxValue\n\n    // Generate all combinations of indices of length halfSize\n    let rec generateCombinations (start: int) (count: int) (current: int list) =\n        if count = 0 then\n            let list1 = current |> List.map (fun idx -> arr.[idx])\n            let list2 = \n                indices \n                |> Array.filter (fun idx -> not (List.contains idx current))\n                |> Array.map (fun idx -> arr.[idx])\n            let sum1 = List.sum list1\n            let sum2 = Array.sum list2\n            let diff = abs (sum1 - sum2)\n            if diff < minDiff then\n                minDiff <- diff\n        else\n            for i = start to n - count do\n                generateCombinations (i + 1) (count - 1) (i :: current)\n\n    generateCombinations 0 halfSize []\n    minDiff", "test_cases": "", "test_case_results": "Input array: [|1; 2; 3; 4|]\nMinimum absolute difference: 0\nInput array: [|5; 6; 7; 0; 1|]\nMinimum absolute difference: 3\nInput array: [|0; 0; 0|]\nMinimum absolute difference: 0", "task_id": 14428, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinAbsDiff =\n    let checkMinAbsDiff() =\n        Debug.Assert(minAbsDiffBetweenTwoHalves 4 [|1; 2; 3; 4|] = 0)\n        Debug.Assert(minAbsDiffBetweenTwoHalves 5 [|5; 6; 7; 0; 1|] = 3)\n        Debug.Assert(minAbsDiffBetweenTwoHalves 3 [|0; 0; 0|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinAbsDiff.checkMinAbsDiff()\n    0", "all_code": "open System\n\n// minAbsDiffBetweenTwoHalves calculates the minimum absolute difference between the sums of two halves of an array.\n// The array is split into two halves where one half has size (n + 1) // 2 and the other has the remaining elements.\n// The function explores all possible combinations of indices to find the split that minimizes the absolute difference between the sums of the two halves.\nlet minAbsDiffBetweenTwoHalves (n: int) (arr: int array) =\n    let halfSize = (n + 1) / 2\n    let indices = [|0..n-1|]\n    let mutable minDiff = Int32.MaxValue\n\n    // Generate all combinations of indices of length halfSize\n    let rec generateCombinations (start: int) (count: int) (current: int list) =\n        if count = 0 then\n            let list1 = current |> List.map (fun idx -> arr.[idx])\n            let list2 = \n                indices \n                |> Array.filter (fun idx -> not (List.contains idx current))\n                |> Array.map (fun idx -> arr.[idx])\n            let sum1 = List.sum list1\n            let sum2 = Array.sum list2\n            let diff = abs (sum1 - sum2)\n            if diff < minDiff then\n                minDiff <- diff\n        else\n            for i = start to n - count do\n                generateCombinations (i + 1) (count - 1) (i :: current)\n\n    generateCombinations 0 halfSize []\n    minDiff\nopen System\nopen System.Diagnostics\n\nmodule TestMinAbsDiff =\n    let checkMinAbsDiff() =\n        Debug.Assert(minAbsDiffBetweenTwoHalves 4 [|1; 2; 3; 4|] = 0)\n        Debug.Assert(minAbsDiffBetweenTwoHalves 5 [|5; 6; 7; 0; 1|] = 3)\n        Debug.Assert(minAbsDiffBetweenTwoHalves 3 [|0; 0; 0|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinAbsDiff.checkMinAbsDiff()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nlet reformatDuration (duration: string) =\n    // Split the duration string into parts\n    let parts = duration.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let mutable hours, minutes, seconds = 0, 0, 0\n    \n    // Extract hours, minutes, and seconds from each part\n    for part in parts do\n        if part.Contains(\"h\") then\n            hours <- Int32.Parse(part.Replace(\"h\", \"\"))\n        elif part.Contains(\"m\") then\n            minutes <- Int32.Parse(part.Replace(\"m\", \"\"))\n        elif part.Contains(\"s\") then\n            seconds <- Int32.Parse(part.Replace(\"s\", \"\"))\n    \n    // Return the formatted duration string\n    sprintf \"%d:%d:%d\" hours minutes seconds", "test_cases": "", "test_case_results": "Input: \"1h 30m 45s\"\nReformatted: \"1:30:45\"\nInput: \"2h 15s\"\nReformatted: \"2:0:15\"\nInput: \"30m\"\nReformatted: \"0:30:0\"\nInput: \"45s\"\nReformatted: \"0:0:45\"\nInput: \"1h 30m\"\nReformatted: \"1:30:0\"\nInput: \"\"\nReformatted: \"0:0:0\"", "task_id": 5788, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestDurationReformat =\n    let checkReformatDuration() =\n        Debug.Assert(reformatDuration \"1h 30m 45s\" = \"1:30:45\")\n        Debug.Assert(reformatDuration \"2h 15s\" = \"2:0:15\")\n        Debug.Assert(reformatDuration \"30m\" = \"0:30:0\")\n        Debug.Assert(reformatDuration \"45s\" = \"0:0:45\")\n        Debug.Assert(reformatDuration \"1h 30m\" = \"1:30:0\")\n        Debug.Assert(reformatDuration \"\" = \"0:0:0\")\n\n[<EntryPoint>]\nlet main argv =\n    TestDurationReformat.checkReformatDuration()\n    0", "all_code": "open System\n\nlet reformatDuration (duration: string) =\n    // Split the duration string into parts\n    let parts = duration.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let mutable hours, minutes, seconds = 0, 0, 0\n    \n    // Extract hours, minutes, and seconds from each part\n    for part in parts do\n        if part.Contains(\"h\") then\n            hours <- Int32.Parse(part.Replace(\"h\", \"\"))\n        elif part.Contains(\"m\") then\n            minutes <- Int32.Parse(part.Replace(\"m\", \"\"))\n        elif part.Contains(\"s\") then\n            seconds <- Int32.Parse(part.Replace(\"s\", \"\"))\n    \n    // Return the formatted duration string\n    sprintf \"%d:%d:%d\" hours minutes seconds\nopen System\nopen System.Diagnostics\n\nmodule TestDurationReformat =\n    let checkReformatDuration() =\n        Debug.Assert(reformatDuration \"1h 30m 45s\" = \"1:30:45\")\n        Debug.Assert(reformatDuration \"2h 15s\" = \"2:0:15\")\n        Debug.Assert(reformatDuration \"30m\" = \"0:30:0\")\n        Debug.Assert(reformatDuration \"45s\" = \"0:0:45\")\n        Debug.Assert(reformatDuration \"1h 30m\" = \"1:30:0\")\n        Debug.Assert(reformatDuration \"\" = \"0:0:0\")\n\n[<EntryPoint>]\nlet main argv =\n    TestDurationReformat.checkReformatDuration()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// highestProductOfThree calculates the highest product of any three numbers in an array.\n// If the input array has less than three elements, it raises an exception.\n// The function considers two cases:\n// 1. The product of the two smallest (potentially negative) numbers and the largest number.\n// 2. The product of the three largest numbers.\n// The maximum of these two products is returned.\nlet highestProductOfThree (numbers: int array) =\n    if numbers.Length < 3 then\n        raise (ArgumentException(\"Less than three numbers provided\"))\n    \n    // Sort the array\n    let sortedNumbers = Array.sort numbers\n    \n    // Option 1: Product of the two smallest and the largest number\n    let option1 = sortedNumbers.[0] * sortedNumbers.[1] * sortedNumbers.[sortedNumbers.Length - 1]\n    \n    // Option 2: Product of the three largest numbers\n    let option2 = sortedNumbers.[sortedNumbers.Length - 1] * sortedNumbers.[sortedNumbers.Length - 2] * sortedNumbers.[sortedNumbers.Length - 3]\n    \n    // Return the maximum of the two options\n    max option1 option2", "test_cases": "", "test_case_results": "Input: [|1; 2; 3; 4|]\nHighest product of three: 24\nInput: [|-10; -10; 1; 3; 2|]\nHighest product of three: 300\nInput: [|5; 6; 7; 0|]\nHighest product of three: 210\nInput: [|0; 0; 0; 0|]\nHighest product of three: 0", "task_id": 27523, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestHighestProduct =\n    let checkHighestProductOfThree() =\n        // Test case 1: Positive numbers\n        Debug.Assert(highestProductOfThree [|1; 2; 3; 4|] = 24)\n        \n        // Test case 2: Negative numbers with potential for higher product\n        Debug.Assert(highestProductOfThree [|-10; -10; 1; 3; 2|] = 300)\n        \n        // Test case 3: Positive numbers with zero\n        Debug.Assert(highestProductOfThree [|5; 6; 7; 0|] = 210)\n        \n        // Test case 4: All zeros\n        Debug.Assert(highestProductOfThree [|0; 0; 0; 0|] = 0)\n        \n        // Test case 5: Less than three elements (should raise exception)\n        try\n            highestProductOfThree [|1; 2|] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n\n[<EntryPoint>]\nlet main argv =\n    TestHighestProduct.checkHighestProductOfThree()\n    0", "all_code": "open System\n\n// highestProductOfThree calculates the highest product of any three numbers in an array.\n// If the input array has less than three elements, it raises an exception.\n// The function considers two cases:\n// 1. The product of the two smallest (potentially negative) numbers and the largest number.\n// 2. The product of the three largest numbers.\n// The maximum of these two products is returned.\nlet highestProductOfThree (numbers: int array) =\n    if numbers.Length < 3 then\n        raise (ArgumentException(\"Less than three numbers provided\"))\n    \n    // Sort the array\n    let sortedNumbers = Array.sort numbers\n    \n    // Option 1: Product of the two smallest and the largest number\n    let option1 = sortedNumbers.[0] * sortedNumbers.[1] * sortedNumbers.[sortedNumbers.Length - 1]\n    \n    // Option 2: Product of the three largest numbers\n    let option2 = sortedNumbers.[sortedNumbers.Length - 1] * sortedNumbers.[sortedNumbers.Length - 2] * sortedNumbers.[sortedNumbers.Length - 3]\n    \n    // Return the maximum of the two options\n    max option1 option2\nopen System\nopen System.Diagnostics\n\nmodule TestHighestProduct =\n    let checkHighestProductOfThree() =\n        // Test case 1: Positive numbers\n        Debug.Assert(highestProductOfThree [|1; 2; 3; 4|] = 24)\n        \n        // Test case 2: Negative numbers with potential for higher product\n        Debug.Assert(highestProductOfThree [|-10; -10; 1; 3; 2|] = 300)\n        \n        // Test case 3: Positive numbers with zero\n        Debug.Assert(highestProductOfThree [|5; 6; 7; 0|] = 210)\n        \n        // Test case 4: All zeros\n        Debug.Assert(highestProductOfThree [|0; 0; 0; 0|] = 0)\n        \n        // Test case 5: Less than three elements (should raise exception)\n        try\n            highestProductOfThree [|1; 2|] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n\n[<EntryPoint>]\nlet main argv =\n    TestHighestProduct.checkHighestProductOfThree()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to check if a number is within the range 4 to 6\nlet isInRange (n: int) =\n    if n >= 4 && n <= 6 then \"Yes\" else \"No\"", "test_cases": "", "test_case_results": "Input: 2\nNo\n\nInput: 3\nNo\n\nInput: 4\nYes\n\nInput: 5\nYes\n\nInput: 6\nYes\n\nInput: 7\nNo", "task_id": 11150, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestRangeChecker =\n    let checkIsInRange() =\n        Debug.Assert(isInRange 2 = \"No\")\n        Debug.Assert(isInRange 3 = \"No\")\n        Debug.Assert(isInRange 4 = \"Yes\")\n        Debug.Assert(isInRange 5 = \"Yes\")\n        Debug.Assert(isInRange 6 = \"Yes\")\n        Debug.Assert(isInRange 7 = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestRangeChecker.checkIsInRange()\n    0", "all_code": "// Function to check if a number is within the range 4 to 6\nlet isInRange (n: int) =\n    if n >= 4 && n <= 6 then \"Yes\" else \"No\"\nopen System\nopen System.Diagnostics\n\nmodule TestRangeChecker =\n    let checkIsInRange() =\n        Debug.Assert(isInRange 2 = \"No\")\n        Debug.Assert(isInRange 3 = \"No\")\n        Debug.Assert(isInRange 4 = \"Yes\")\n        Debug.Assert(isInRange 5 = \"Yes\")\n        Debug.Assert(isInRange 6 = \"Yes\")\n        Debug.Assert(isInRange 7 = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestRangeChecker.checkIsInRange()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.IO\n\nmodule ElectionResults =\n    let getWinningCandidate (csvFilePath: string) =\n        let votes = System.Collections.Generic.Dictionary<string, int>()\n        \n        use file = new StreamReader(csvFilePath)\n        file.ReadLine() |> ignore // Skip the header row\n        while not file.EndOfStream do\n            let line = file.ReadLine()\n            let columns = line.Split(',')\n            let candidate = columns.[1] // Assuming candidate name is in the second column\n            match votes.TryGetValue(candidate) with\n            | true, count -> votes.[candidate] <- count + 1\n            | false, _ -> votes.[candidate] <- 1\n        \n        let winningCandidate = votes |> Seq.maxBy (fun kvp -> kvp.Value)\n        winningCandidate.Key", "test_cases": "", "test_case_results": "Input file: test1.csv\nWinning candidate: Alice\nInput file: test2.csv\nWinning candidate: Charlie\nInput file: test3.csv\nWinning candidate: Alice", "task_id": 3840, "assertions": "open System\nopen System.IO\nopen System.Diagnostics\n\nmodule TestElectionResults =\n    let checkWinningCandidate() =\n        // Create temporary test files\n        let testCases = [|\n            (\"test1.csv\", [| \"VoterID,Candidate\"; \"1,Alice\"; \"2,Bob\"; \"3,Alice\"; \"4,Charlie\"; \"5,Alice\" |])\n            (\"test2.csv\", [| \"VoterID,Candidate\"; \"1,Bob\"; \"2,Bob\"; \"3,Alice\"; \"4,Charlie\"; \"5,Charlie\"; \"6,Charlie\" |])\n            (\"test3.csv\", [| \"VoterID,Candidate\"; \"1,Alice\"; \"2,Alice\"; \"3,Alice\" |])\n        |]\n\n        for (filePath, fileContent) in testCases do\n            File.WriteAllLines(filePath, fileContent)\n            let winner = ElectionResults.getWinningCandidate filePath\n            match filePath with\n            | \"test1.csv\" -> Debug.Assert(winner = \"Alice\")\n            | \"test2.csv\" -> Debug.Assert(winner = \"Charlie\")\n            | \"test3.csv\" -> Debug.Assert(winner = \"Alice\")\n            | _ -> failwith \"Unexpected test case\"\n            File.Delete(filePath)\n\n[<EntryPoint>]\nlet main argv =\n    TestElectionResults.checkWinningCandidate()\n    0", "all_code": "open System.IO\n\nmodule ElectionResults =\n    let getWinningCandidate (csvFilePath: string) =\n        let votes = System.Collections.Generic.Dictionary<string, int>()\n        \n        use file = new StreamReader(csvFilePath)\n        file.ReadLine() |> ignore // Skip the header row\n        while not file.EndOfStream do\n            let line = file.ReadLine()\n            let columns = line.Split(',')\n            let candidate = columns.[1] // Assuming candidate name is in the second column\n            match votes.TryGetValue(candidate) with\n            | true, count -> votes.[candidate] <- count + 1\n            | false, _ -> votes.[candidate] <- 1\n        \n        let winningCandidate = votes |> Seq.maxBy (fun kvp -> kvp.Value)\n        winningCandidate.Key\nopen System\nopen System.IO\nopen System.Diagnostics\n\nmodule TestElectionResults =\n    let checkWinningCandidate() =\n        // Create temporary test files\n        let testCases = [|\n            (\"test1.csv\", [| \"VoterID,Candidate\"; \"1,Alice\"; \"2,Bob\"; \"3,Alice\"; \"4,Charlie\"; \"5,Alice\" |])\n            (\"test2.csv\", [| \"VoterID,Candidate\"; \"1,Bob\"; \"2,Bob\"; \"3,Alice\"; \"4,Charlie\"; \"5,Charlie\"; \"6,Charlie\" |])\n            (\"test3.csv\", [| \"VoterID,Candidate\"; \"1,Alice\"; \"2,Alice\"; \"3,Alice\" |])\n        |]\n\n        for (filePath, fileContent) in testCases do\n            File.WriteAllLines(filePath, fileContent)\n            let winner = ElectionResults.getWinningCandidate filePath\n            match filePath with\n            | \"test1.csv\" -> Debug.Assert(winner = \"Alice\")\n            | \"test2.csv\" -> Debug.Assert(winner = \"Charlie\")\n            | \"test3.csv\" -> Debug.Assert(winner = \"Alice\")\n            | _ -> failwith \"Unexpected test case\"\n            File.Delete(filePath)\n\n[<EntryPoint>]\nlet main argv =\n    TestElectionResults.checkWinningCandidate()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// evaluateExpression processes a list of tokens and computes the resulting alpha value.\n// Tokens are processed in reverse order:\n// - 'V' pushes (1, 1) onto the stack.\n// - 'U' pops two elements, sums their alphas, and takes the max of their omegas.\n// - 'C' pops one element and swaps its alpha and omega.\n// If the expression is invalid, an exception is raised.\nlet evaluateExpression (tokens: string list) =\n    let rec processTokens tokens stack =\n        match tokens with\n        | [] -> stack\n        | token :: rest ->\n            match token with\n            | \"V\" -> processTokens rest ((1, 1) :: stack)\n            | \"U\" ->\n                match stack with\n                | e1 :: e2 :: remainingStack ->\n                    let alpha = fst e1 + fst e2\n                    let omega = max (snd e1) (snd e2)\n                    processTokens rest ((alpha, omega) :: remainingStack)\n                | _ -> failwith \"Invalid expression\"\n            | \"C\" ->\n                match stack with\n                | e :: remainingStack ->\n                    let alpha = snd e\n                    let omega = fst e\n                    processTokens rest ((alpha, omega) :: remainingStack)\n                | _ -> failwith \"Invalid expression\"\n            | _ -> failwith \"Unknown token\"\n    \n    let finalStack = processTokens (List.rev tokens) []\n    match finalStack with\n    | [result] -> fst result\n    | _ -> failwith \"Invalid expression\"", "test_cases": "", "test_case_results": "Input: [\"V\"]\nAlpha: 1\nInput: [\"V\"; \"V\"; \"U\"]\nError: Invalid expression\nInput: [\"V\"; \"C\"]\nError: Invalid expression\nInput: [\"V\"; \"V\"; \"C\"; \"U\"]\nError: Invalid expression\nInput: [\"V\"; \"V\"; \"U\"; \"C\"]\nError: Invalid expression\nInput: [\"V\"; \"U\"]\nError: Invalid expression\nInput: [\"V\"; \"C\"; \"U\"]\nError: Invalid expression\nInput: [\"V\"; \"X\"]\nError: Unknown token", "task_id": 19946, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestExpressionEvaluator =\n    let checkEvaluateExpression() =\n        // Valid case with single V\n        Debug.Assert(evaluateExpression [\"V\"] = 1)\n        \n        // Invalid cases\n        try\n            evaluateExpression [\"V\"; \"V\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"C\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"V\"; \"C\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"V\"; \"U\"; \"C\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"C\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"X\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n\n[<EntryPoint>]\nlet main argv =\n    TestExpressionEvaluator.checkEvaluateExpression()\n    0", "all_code": "open System\n\n// evaluateExpression processes a list of tokens and computes the resulting alpha value.\n// Tokens are processed in reverse order:\n// - 'V' pushes (1, 1) onto the stack.\n// - 'U' pops two elements, sums their alphas, and takes the max of their omegas.\n// - 'C' pops one element and swaps its alpha and omega.\n// If the expression is invalid, an exception is raised.\nlet evaluateExpression (tokens: string list) =\n    let rec processTokens tokens stack =\n        match tokens with\n        | [] -> stack\n        | token :: rest ->\n            match token with\n            | \"V\" -> processTokens rest ((1, 1) :: stack)\n            | \"U\" ->\n                match stack with\n                | e1 :: e2 :: remainingStack ->\n                    let alpha = fst e1 + fst e2\n                    let omega = max (snd e1) (snd e2)\n                    processTokens rest ((alpha, omega) :: remainingStack)\n                | _ -> failwith \"Invalid expression\"\n            | \"C\" ->\n                match stack with\n                | e :: remainingStack ->\n                    let alpha = snd e\n                    let omega = fst e\n                    processTokens rest ((alpha, omega) :: remainingStack)\n                | _ -> failwith \"Invalid expression\"\n            | _ -> failwith \"Unknown token\"\n    \n    let finalStack = processTokens (List.rev tokens) []\n    match finalStack with\n    | [result] -> fst result\n    | _ -> failwith \"Invalid expression\"\nopen System\nopen System.Diagnostics\n\nmodule TestExpressionEvaluator =\n    let checkEvaluateExpression() =\n        // Valid case with single V\n        Debug.Assert(evaluateExpression [\"V\"] = 1)\n        \n        // Invalid cases\n        try\n            evaluateExpression [\"V\"; \"V\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"C\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"V\"; \"C\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"V\"; \"U\"; \"C\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"C\"; \"U\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n        \n        try\n            evaluateExpression [\"V\"; \"X\"] |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with _ -> ()\n\n[<EntryPoint>]\nlet main argv =\n    TestExpressionEvaluator.checkEvaluateExpression()\n    0", "exec_outcome": "PASSED"}
{"code": "// This F# script determines the winner of a two-leg football match between Persepolis and Esteghlal.\n// The winner is decided based on aggregate scores, and if the aggregate is tied, the away goals rule is applied.\n// If still tied, the result is \"Penalty\".\n\n// Function to determine the match winner based on the scores of two matches.\n// p1: Persepolis's score in the first match (home)\n// s1: Esteghlal's score in the first match (away)\n// s2: Esteghlal's score in the second match (home)\n// p2: Persepolis's score in the second match (away)\nlet determineWinner (p1, s1) (s2, p2) =\n    let persTotal = p1 + p2\n    let esthTotal = s1 + s2\n    \n    if persTotal > esthTotal then\n        \"Persepolis\"\n    elif esthTotal > persTotal then\n        \"Esteghlal\"\n    else\n        let persAway = p2\n        let esthAway = s1\n        \n        if persAway > esthAway then\n            \"Persepolis\"\n        elif esthAway > persAway then\n            \"Esteghlal\"\n        else\n            \"Penalty\"", "test_cases": "", "test_case_results": "Match 1: Persepolis 2 - 1 Esteghlal\nMatch 2: Esteghlal 0 - 1 Persepolis\nResult: Persepolis\n\nMatch 1: Persepolis 1 - 2 Esteghlal\nMatch 2: Esteghlal 2 - 0 Persepolis\nResult: Esteghlal\n\nMatch 1: Persepolis 1 - 1 Esteghlal\nMatch 2: Esteghlal 0 - 1 Persepolis\nResult: Persepolis\n\nMatch 1: Persepolis 1 - 2 Esteghlal\nMatch 2: Esteghlal 1 - 0 Persepolis\nResult: Esteghlal\n\nMatch 1: Persepolis 1 - 0 Esteghlal\nMatch 2: Esteghlal 1 - 0 Persepolis\nResult: Penalty", "task_id": 783, "assertions": "open System.Diagnostics\n\nmodule TestFootballMatch =\n    let checkDetermineWinner() =\n        Debug.Assert(determineWinner (2, 1) (0, 1) = \"Persepolis\")\n        Debug.Assert(determineWinner (1, 2) (2, 0) = \"Esteghlal\")\n        Debug.Assert(determineWinner (1, 1) (0, 1) = \"Persepolis\")\n        Debug.Assert(determineWinner (1, 2) (1, 0) = \"Esteghlal\")\n        Debug.Assert(determineWinner (1, 0) (1, 0) = \"Penalty\")\n\n[<EntryPoint>]\nlet main argv =\n    TestFootballMatch.checkDetermineWinner()\n    0", "all_code": "// This F# script determines the winner of a two-leg football match between Persepolis and Esteghlal.\n// The winner is decided based on aggregate scores, and if the aggregate is tied, the away goals rule is applied.\n// If still tied, the result is \"Penalty\".\n\n// Function to determine the match winner based on the scores of two matches.\n// p1: Persepolis's score in the first match (home)\n// s1: Esteghlal's score in the first match (away)\n// s2: Esteghlal's score in the second match (home)\n// p2: Persepolis's score in the second match (away)\nlet determineWinner (p1, s1) (s2, p2) =\n    let persTotal = p1 + p2\n    let esthTotal = s1 + s2\n    \n    if persTotal > esthTotal then\n        \"Persepolis\"\n    elif esthTotal > persTotal then\n        \"Esteghlal\"\n    else\n        let persAway = p2\n        let esthAway = s1\n        \n        if persAway > esthAway then\n            \"Persepolis\"\n        elif esthAway > persAway then\n            \"Esteghlal\"\n        else\n            \"Penalty\"\nopen System.Diagnostics\n\nmodule TestFootballMatch =\n    let checkDetermineWinner() =\n        Debug.Assert(determineWinner (2, 1) (0, 1) = \"Persepolis\")\n        Debug.Assert(determineWinner (1, 2) (2, 0) = \"Esteghlal\")\n        Debug.Assert(determineWinner (1, 1) (0, 1) = \"Persepolis\")\n        Debug.Assert(determineWinner (1, 2) (1, 0) = \"Esteghlal\")\n        Debug.Assert(determineWinner (1, 0) (1, 0) = \"Penalty\")\n\n[<EntryPoint>]\nlet main argv =\n    TestFootballMatch.checkDetermineWinner()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// isValidString checks if the string contains only uppercase letters and digits and is of a specific length.\n// Parameters:\n//   s: The string to be checked.\n//   length: The required length of the string.\n// Returns:\n//   true if the string is of the specified length and contains only uppercase letters and digits; false otherwise.\nlet isValidString (s: string) (length: int) =\n    if s.Length <> length then\n        false\n    else\n        s |> Seq.forall (fun char -> Char.IsDigit char || Char.IsUpper char)", "test_cases": "", "test_case_results": "Input: \"ABC123\", Length: 6\nResult: true\n\nInput: \"123456\", Length: 6\nResult: true\n\nInput: \"abc123\", Length: 6\nResult: false\n\nInput: \"ABCDEF\", Length: 6\nResult: true\n\nInput: \"A1B2C3\", Length: 6\nResult: true\n\nInput: \"123\", Length: 3\nResult: true\n\nInput: \"ABC\", Length: 3\nResult: true\n\nInput: \"A1B\", Length: 3\nResult: true\n\nInput: \"a1b\", Length: 3\nResult: false\n\nInput: \"1234567\", Length: 7\nResult: true", "task_id": 26604, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestStringValidation =\n    let checkIsValidString() =\n        Debug.Assert(isValidString \"ABC123\" 6 = true)\n        Debug.Assert(isValidString \"123456\" 6 = true)\n        Debug.Assert(isValidString \"abc123\" 6 = false)\n        Debug.Assert(isValidString \"ABCDEF\" 6 = true)\n        Debug.Assert(isValidString \"A1B2C3\" 6 = true)\n        Debug.Assert(isValidString \"123\" 3 = true)\n        Debug.Assert(isValidString \"ABC\" 3 = true)\n        Debug.Assert(isValidString \"A1B\" 3 = true)\n        Debug.Assert(isValidString \"a1b\" 3 = false)\n        Debug.Assert(isValidString \"1234567\" 7 = true)\n\n[<EntryPoint>]\nlet main argv =\n    TestStringValidation.checkIsValidString()\n    0", "all_code": "open System\n\n// isValidString checks if the string contains only uppercase letters and digits and is of a specific length.\n// Parameters:\n//   s: The string to be checked.\n//   length: The required length of the string.\n// Returns:\n//   true if the string is of the specified length and contains only uppercase letters and digits; false otherwise.\nlet isValidString (s: string) (length: int) =\n    if s.Length <> length then\n        false\n    else\n        s |> Seq.forall (fun char -> Char.IsDigit char || Char.IsUpper char)\nopen System\nopen System.Diagnostics\n\nmodule TestStringValidation =\n    let checkIsValidString() =\n        Debug.Assert(isValidString \"ABC123\" 6 = true)\n        Debug.Assert(isValidString \"123456\" 6 = true)\n        Debug.Assert(isValidString \"abc123\" 6 = false)\n        Debug.Assert(isValidString \"ABCDEF\" 6 = true)\n        Debug.Assert(isValidString \"A1B2C3\" 6 = true)\n        Debug.Assert(isValidString \"123\" 3 = true)\n        Debug.Assert(isValidString \"ABC\" 3 = true)\n        Debug.Assert(isValidString \"A1B\" 3 = true)\n        Debug.Assert(isValidString \"a1b\" 3 = false)\n        Debug.Assert(isValidString \"1234567\" 7 = true)\n\n[<EntryPoint>]\nlet main argv =\n    TestStringValidation.checkIsValidString()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\n// maxSumAfterSwap calculates the maximum path sum in a binary tree after trying all possible child swaps.\n// The tree is represented as a list of nodes where each node has a parent and two children (left and right).\n// The function uses depth-first search (DFS) to traverse the tree and calculate path sums.\nlet maxSumAfterSwap (n: int) (nodes: (int * int * int) list) =\n    // Create a dictionary to map each parent node to its left and right children\n    let children = Dictionary<int, int * int>()\n    for (parent, left, right) in nodes do\n        children.[parent] <- (left, right)\n    \n    // Recursive DFS function to calculate the maximum path sum from a given node\n    let rec dfs (node: int) =\n        if node = -1 then\n            0\n        else\n            let left, right = \n                if children.ContainsKey(node) then \n                    children.[node] \n                else \n                    (-1, -1)\n            let leftSum = dfs left\n            let rightSum = dfs right\n            node + max leftSum rightSum\n    \n    // Calculate the maximum sum for the original tree\n    let originalMaxSum = dfs 1\n    let mutable maxSum = originalMaxSum\n    \n    // Try swapping every node's children and calculate the new maximum sum\n    for KeyValue(parent, (left, right)) in children do\n        // Swap children\n        children.[parent] <- (right, left)\n        let newSum = dfs 1\n        maxSum <- max maxSum newSum\n        // Revert the swap\n        children.[parent] <- (left, right)\n    \n    maxSum", "test_cases": "", "test_case_results": "Input nodes: [(1, 2, 3); (2, -1, -1); (3, -1, -1)]\nMaximum sum after swaps: 4\n\nInput nodes: [(1, 2, 3); (2, 4, -1); (3, -1, 5); (4, -1, -1); (5, -1, -1)]\nMaximum sum after swaps: 9\n\nInput nodes: [(1, -1, -1)]\nMaximum sum after swaps: 1", "task_id": 9054, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxSumAfterSwap =\n    let runTests() =\n        // Test case 1: Simple tree with 3 nodes\n        let test1 = maxSumAfterSwap 3 [(1, 2, 3); (2, -1, -1); (3, -1, -1)]\n        Debug.Assert(test1 = 4, \"Test case 1 failed\")\n        \n        // Test case 2: Tree with 5 nodes where swapping increases the max sum\n        let test2 = maxSumAfterSwap 5 [(1, 2, 3); (2, 4, -1); (3, -1, 5); (4, -1, -1); (5, -1, -1)]\n        Debug.Assert(test2 = 9, \"Test case 2 failed\")\n        \n        // Test case 3: Single node tree\n        let test3 = maxSumAfterSwap 1 [(1, -1, -1)]\n        Debug.Assert(test3 = 1, \"Test case 3 failed\")\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSumAfterSwap.runTests()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// maxSumAfterSwap calculates the maximum path sum in a binary tree after trying all possible child swaps.\n// The tree is represented as a list of nodes where each node has a parent and two children (left and right).\n// The function uses depth-first search (DFS) to traverse the tree and calculate path sums.\nlet maxSumAfterSwap (n: int) (nodes: (int * int * int) list) =\n    // Create a dictionary to map each parent node to its left and right children\n    let children = Dictionary<int, int * int>()\n    for (parent, left, right) in nodes do\n        children.[parent] <- (left, right)\n    \n    // Recursive DFS function to calculate the maximum path sum from a given node\n    let rec dfs (node: int) =\n        if node = -1 then\n            0\n        else\n            let left, right = \n                if children.ContainsKey(node) then \n                    children.[node] \n                else \n                    (-1, -1)\n            let leftSum = dfs left\n            let rightSum = dfs right\n            node + max leftSum rightSum\n    \n    // Calculate the maximum sum for the original tree\n    let originalMaxSum = dfs 1\n    let mutable maxSum = originalMaxSum\n    \n    // Try swapping every node's children and calculate the new maximum sum\n    for KeyValue(parent, (left, right)) in children do\n        // Swap children\n        children.[parent] <- (right, left)\n        let newSum = dfs 1\n        maxSum <- max maxSum newSum\n        // Revert the swap\n        children.[parent] <- (left, right)\n    \n    maxSum\nopen System\nopen System.Diagnostics\n\nmodule TestMaxSumAfterSwap =\n    let runTests() =\n        // Test case 1: Simple tree with 3 nodes\n        let test1 = maxSumAfterSwap 3 [(1, 2, 3); (2, -1, -1); (3, -1, -1)]\n        Debug.Assert(test1 = 4, \"Test case 1 failed\")\n        \n        // Test case 2: Tree with 5 nodes where swapping increases the max sum\n        let test2 = maxSumAfterSwap 5 [(1, 2, 3); (2, 4, -1); (3, -1, 5); (4, -1, -1); (5, -1, -1)]\n        Debug.Assert(test2 = 9, \"Test case 2 failed\")\n        \n        // Test case 3: Single node tree\n        let test3 = maxSumAfterSwap 1 [(1, -1, -1)]\n        Debug.Assert(test3 = 1, \"Test case 3 failed\")\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSumAfterSwap.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// checkSubsetSumModulo checks if there exists a subset of the input array `a` \n// such that the sum of its elements modulo `n` is zero.\n// The function uses dynamic programming to solve the problem.\nlet checkSubsetSumModulo (n: int) (a: int array) =\n    if n = 1 then\n        true\n    else\n        let modA = a |> Array.map (fun x -> x % n)\n        let mutable prev = Array.create n false\n        prev.[0] <- true\n\n        for x in modA do\n            let curr = \n                if x = 0 then\n                    Array.copy prev\n                else\n                    let temp = Array.create n false\n                    for j in 0 .. n - 1 do\n                        if prev.[j] then\n                            temp.[(j + x) % n] <- true\n                            temp.[(j - x + n) % n] <- true\n                    temp\n            prev <- curr\n\n        prev.[0]", "test_cases": "", "test_case_results": "Input: n = 5, a = [|1; 2; 3; 4|]\nYES\n\nInput: n = 3, a = [|1; 1; 1|]\nYES\n\nInput: n = 4, a = [|1; 2|]\nNO\n\nInput: n = 1, a = [|1; 2; 3|]\nYES", "task_id": 25003, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSubsetSumModulo =\n    let runTests() =\n        Debug.Assert(checkSubsetSumModulo 5 [|1; 2; 3; 4|] = true)  // YES\n        Debug.Assert(checkSubsetSumModulo 3 [|1; 1; 1|] = true)       // YES\n        Debug.Assert(checkSubsetSumModulo 4 [|1; 2|] = false)        // NO\n        Debug.Assert(checkSubsetSumModulo 1 [|1; 2; 3|] = true)      // YES\n\n[<EntryPoint>]\nlet main argv =\n    TestSubsetSumModulo.runTests()\n    0", "all_code": "open System\n\n// checkSubsetSumModulo checks if there exists a subset of the input array `a` \n// such that the sum of its elements modulo `n` is zero.\n// The function uses dynamic programming to solve the problem.\nlet checkSubsetSumModulo (n: int) (a: int array) =\n    if n = 1 then\n        true\n    else\n        let modA = a |> Array.map (fun x -> x % n)\n        let mutable prev = Array.create n false\n        prev.[0] <- true\n\n        for x in modA do\n            let curr = \n                if x = 0 then\n                    Array.copy prev\n                else\n                    let temp = Array.create n false\n                    for j in 0 .. n - 1 do\n                        if prev.[j] then\n                            temp.[(j + x) % n] <- true\n                            temp.[(j - x + n) % n] <- true\n                    temp\n            prev <- curr\n\n        prev.[0]\nopen System\nopen System.Diagnostics\n\nmodule TestSubsetSumModulo =\n    let runTests() =\n        Debug.Assert(checkSubsetSumModulo 5 [|1; 2; 3; 4|] = true)  // YES\n        Debug.Assert(checkSubsetSumModulo 3 [|1; 1; 1|] = true)       // YES\n        Debug.Assert(checkSubsetSumModulo 4 [|1; 2|] = false)        // NO\n        Debug.Assert(checkSubsetSumModulo 1 [|1; 2; 3|] = true)      // YES\n\n[<EntryPoint>]\nlet main argv =\n    TestSubsetSumModulo.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\n// countConnectedComponents calculates the number of connected components in an undirected graph.\n// The graph is represented as an adjacency list where nodes are numbered from 1 to N.\nlet countConnectedComponents (N: int) (adj: int list array) =\n    let visited = Array.create (N + 1) false\n    let mutable count = 0\n\n    for node in 1 .. N do\n        if not visited.[node] then\n            count <- count + 1\n            let queue = Queue<int>()\n            queue.Enqueue(node)\n            visited.[node] <- true\n\n            while queue.Count > 0 do\n                let current = queue.Dequeue()\n                for neighbor in adj.[current] do\n                    if not visited.[neighbor] then\n                        visited.[neighbor] <- true\n                        queue.Enqueue(neighbor)\n    count", "test_cases": "", "test_case_results": "Input: N = 3, adj = [|[]; [2]; [1; 3]; [2]|]\nNumber of connected components: 1\nInput: N = 4, adj = [|[]; []; []; []; []|]\nNumber of connected components: 4\nInput: N = 5, adj = [|[]; [2; 3]; [1; 3]; [1; 2]; [5]; [4]|]\nNumber of connected components: 2", "task_id": 19454, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestConnectedComponents =\n    let checkCountConnectedComponents() =\n        // Test Case 1: A graph with 3 nodes and 2 edges forming one connected component\n        Debug.Assert(countConnectedComponents 3 [|[]; [2]; [1; 3]; [2]|] = 1)\n        \n        // Test Case 2: A graph with 4 nodes and no edges (4 connected components)\n        Debug.Assert(countConnectedComponents 4 [|[]; []; []; []; []|] = 4)\n        \n        // Test Case 3: A graph with 5 nodes and 4 edges forming two connected components\n        Debug.Assert(countConnectedComponents 5 [|[]; [2; 3]; [1; 3]; [1; 2]; [5]; [4]|] = 2)\n\n[<EntryPoint>]\nlet main argv =\n    TestConnectedComponents.checkCountConnectedComponents()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// countConnectedComponents calculates the number of connected components in an undirected graph.\n// The graph is represented as an adjacency list where nodes are numbered from 1 to N.\nlet countConnectedComponents (N: int) (adj: int list array) =\n    let visited = Array.create (N + 1) false\n    let mutable count = 0\n\n    for node in 1 .. N do\n        if not visited.[node] then\n            count <- count + 1\n            let queue = Queue<int>()\n            queue.Enqueue(node)\n            visited.[node] <- true\n\n            while queue.Count > 0 do\n                let current = queue.Dequeue()\n                for neighbor in adj.[current] do\n                    if not visited.[neighbor] then\n                        visited.[neighbor] <- true\n                        queue.Enqueue(neighbor)\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestConnectedComponents =\n    let checkCountConnectedComponents() =\n        // Test Case 1: A graph with 3 nodes and 2 edges forming one connected component\n        Debug.Assert(countConnectedComponents 3 [|[]; [2]; [1; 3]; [2]|] = 1)\n        \n        // Test Case 2: A graph with 4 nodes and no edges (4 connected components)\n        Debug.Assert(countConnectedComponents 4 [|[]; []; []; []; []|] = 4)\n        \n        // Test Case 3: A graph with 5 nodes and 4 edges forming two connected components\n        Debug.Assert(countConnectedComponents 5 [|[]; [2; 3]; [1; 3]; [1; 2]; [5]; [4]|] = 2)\n\n[<EntryPoint>]\nlet main argv =\n    TestConnectedComponents.checkCountConnectedComponents()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\nmodule HealthSimulator =\n    let simulateHealthProcess (a: int array) =\n        let mutable health = 0\n        let mutable count = 0\n        let heap = PriorityQueue<int, int>() // Using a priority queue as a min-heap\n        \n        for num in a do\n            if health + num >= 0 then\n                health <- health + num\n                count <- count + 1\n                heap.Enqueue(num, num)\n            else\n                if heap.Count > 0 && num > heap.Peek() then\n                    let smallest = heap.Dequeue()\n                    health <- health - smallest + num\n                    heap.Enqueue(num, num)\n        \n        count", "test_cases": "", "test_case_results": "Input: [|1; -2; 3; -4; 5|]\nMaximum count: 4\nInput: [|-1; -2; -3; -4|]\nMaximum count: 0\nInput: [|5; -3; 10; -2; -5; 7|]\nMaximum count: 6\nInput: [|2; 3; -5; -1; 6|]\nMaximum count: 4", "task_id": 22698, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestHealthSimulator =\n    let checkSimulateHealthProcess() =\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|1; -2; 3; -4; 5|] = 4)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|-1; -2; -3; -4|] = 0)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|5; -3; 10; -2; -5; 7|] = 6)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|2; 3; -5; -1; 6|] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestHealthSimulator.checkSimulateHealthProcess()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\nmodule HealthSimulator =\n    let simulateHealthProcess (a: int array) =\n        let mutable health = 0\n        let mutable count = 0\n        let heap = PriorityQueue<int, int>() // Using a priority queue as a min-heap\n        \n        for num in a do\n            if health + num >= 0 then\n                health <- health + num\n                count <- count + 1\n                heap.Enqueue(num, num)\n            else\n                if heap.Count > 0 && num > heap.Peek() then\n                    let smallest = heap.Dequeue()\n                    health <- health - smallest + num\n                    heap.Enqueue(num, num)\n        \n        count\nopen System\nopen System.Diagnostics\n\nmodule TestHealthSimulator =\n    let checkSimulateHealthProcess() =\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|1; -2; 3; -4; 5|] = 4)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|-1; -2; -3; -4|] = 0)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|5; -3; 10; -2; -5; 7|] = 6)\n        Debug.Assert(HealthSimulator.simulateHealthProcess [|2; 3; -5; -1; 6|] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestHealthSimulator.checkSimulateHealthProcess()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// climbStairs calculates the number of distinct ways to climb a staircase with n steps,\n// where you can take either 1 or 2 steps at a time.\n// This function uses dynamic programming to efficiently compute the result.\nlet climbStairs (n: int) =\n    if n = 1 then\n        1\n    elif n = 2 then\n        2\n    else\n        let dp = Array.zeroCreate (n + 1)\n        dp.[1] <- 1\n        dp.[2] <- 2\n\n        for i in 3 .. n do\n            dp.[i] <- dp.[i - 1] + dp.[i - 2]\n\n        dp.[n]", "test_cases": "", "test_case_results": "Number of steps: 1\nNumber of distinct ways: 1\nNumber of steps: 2\nNumber of distinct ways: 2\nNumber of steps: 3\nNumber of distinct ways: 3\nNumber of steps: 4\nNumber of distinct ways: 5\nNumber of steps: 5\nNumber of distinct ways: 8\nNumber of steps: 10\nNumber of distinct ways: 89", "task_id": 26515, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestClimbStairs =\n    let checkClimbStairs() =\n        Debug.Assert(climbStairs 1 = 1)\n        Debug.Assert(climbStairs 2 = 2)\n        Debug.Assert(climbStairs 3 = 3)\n        Debug.Assert(climbStairs 4 = 5)\n        Debug.Assert(climbStairs 5 = 8)\n        Debug.Assert(climbStairs 10 = 89)\n\n[<EntryPoint>]\nlet main argv =\n    TestClimbStairs.checkClimbStairs()\n    0", "all_code": "open System\n\n// climbStairs calculates the number of distinct ways to climb a staircase with n steps,\n// where you can take either 1 or 2 steps at a time.\n// This function uses dynamic programming to efficiently compute the result.\nlet climbStairs (n: int) =\n    if n = 1 then\n        1\n    elif n = 2 then\n        2\n    else\n        let dp = Array.zeroCreate (n + 1)\n        dp.[1] <- 1\n        dp.[2] <- 2\n\n        for i in 3 .. n do\n            dp.[i] <- dp.[i - 1] + dp.[i - 2]\n\n        dp.[n]\nopen System\nopen System.Diagnostics\n\nmodule TestClimbStairs =\n    let checkClimbStairs() =\n        Debug.Assert(climbStairs 1 = 1)\n        Debug.Assert(climbStairs 2 = 2)\n        Debug.Assert(climbStairs 3 = 3)\n        Debug.Assert(climbStairs 4 = 5)\n        Debug.Assert(climbStairs 5 = 8)\n        Debug.Assert(climbStairs 10 = 89)\n\n[<EntryPoint>]\nlet main argv =\n    TestClimbStairs.checkClimbStairs()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Represents a task with task_id, due_date, status, and completion_date\ntype Task = {\n    taskId: string\n    dueDate: string\n    status: string\n    completionDate: string\n}\n\n// Represents an overdue task with task_id and days_overdue\ntype OverdueTask = {\n    taskId: string\n    daysOverdue: int\n}\n\n// Converts a date string in 'YYYY-MM-DD' format to a DateTime object\nlet parseDate (dateString: string) =\n    DateTime.ParseExact(dateString, \"yyyy-MM-dd\", System.Globalization.CultureInfo.InvariantCulture)\n\n// findOverdueTasks identifies overdue tasks from a list of tasks and calculates how many days they are overdue.\n// A task is overdue if:\n// - It is pending and the due date is before the current date.\n// - It is completed but the completion date is after the due date.\nlet findOverdueTasks (tasks: Task list) (currentDate: string) =\n    let currentDateObj = parseDate currentDate\n\n    tasks\n    |> List.choose (fun task ->\n        let dueDateObj = parseDate task.dueDate\n\n        if task.status = \"pending\" && dueDateObj < currentDateObj then\n            let daysOverdue = (currentDateObj - dueDateObj).Days\n            Some { taskId = task.taskId; daysOverdue = daysOverdue }\n        elif task.status = \"completed\" then\n            let completionDateObj = parseDate task.completionDate\n            if completionDateObj > dueDateObj then\n                let daysOverdue = (completionDateObj - dueDateObj).Days\n                Some { taskId = task.taskId; daysOverdue = daysOverdue }\n            else\n                None\n        else\n            None\n    )", "test_cases": "", "test_case_results": "Test Tasks:\n{ taskId = \"T1\"\n  dueDate = \"2023-01-10\"\n  status = \"pending\"\n  completionDate = \"\" }\n{ taskId = \"T2\"\n  dueDate = \"2023-01-15\"\n  status = \"completed\"\n  completionDate = \"2023-01-20\" }\n{ taskId = \"T3\"\n  dueDate = \"2023-01-20\"\n  status = \"completed\"\n  completionDate = \"2023-01-18\" }\n{ taskId = \"T4\"\n  dueDate = \"2023-01-25\"\n  status = \"pending\"\n  completionDate = \"\" }\nCurrent Date: 2023-01-30\nOverdue Tasks: [{ taskId = \"T1\"\n   daysOverdue = 20 }; { taskId = \"T2\"\n                         daysOverdue = 5 }; { taskId = \"T4\"\n                                              daysOverdue = 5 }]", "task_id": 25912, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestOverdueTasks =\n    let testFindOverdueTasks() =\n        let testTasks = [\n            { taskId = \"T1\"; dueDate = \"2023-01-10\"; status = \"pending\"; completionDate = \"\" }\n            { taskId = \"T2\"; dueDate = \"2023-01-15\"; status = \"completed\"; completionDate = \"2023-01-20\" }\n            { taskId = \"T3\"; dueDate = \"2023-01-20\"; status = \"completed\"; completionDate = \"2023-01-18\" }\n            { taskId = \"T4\"; dueDate = \"2023-01-25\"; status = \"pending\"; completionDate = \"\" }\n        ]\n        let currentDate = \"2023-01-30\"\n        let result = findOverdueTasks testTasks currentDate\n        \n        Debug.Assert(result.Length = 3)\n        Debug.Assert(result.[0].taskId = \"T1\" && result.[0].daysOverdue = 20)\n        Debug.Assert(result.[1].taskId = \"T2\" && result.[1].daysOverdue = 5)\n        Debug.Assert(result.[2].taskId = \"T4\" && result.[2].daysOverdue = 5)\n\n[<EntryPoint>]\nlet main argv =\n    TestOverdueTasks.testFindOverdueTasks()\n    0", "all_code": "open System\n\n// Represents a task with task_id, due_date, status, and completion_date\ntype Task = {\n    taskId: string\n    dueDate: string\n    status: string\n    completionDate: string\n}\n\n// Represents an overdue task with task_id and days_overdue\ntype OverdueTask = {\n    taskId: string\n    daysOverdue: int\n}\n\n// Converts a date string in 'YYYY-MM-DD' format to a DateTime object\nlet parseDate (dateString: string) =\n    DateTime.ParseExact(dateString, \"yyyy-MM-dd\", System.Globalization.CultureInfo.InvariantCulture)\n\n// findOverdueTasks identifies overdue tasks from a list of tasks and calculates how many days they are overdue.\n// A task is overdue if:\n// - It is pending and the due date is before the current date.\n// - It is completed but the completion date is after the due date.\nlet findOverdueTasks (tasks: Task list) (currentDate: string) =\n    let currentDateObj = parseDate currentDate\n\n    tasks\n    |> List.choose (fun task ->\n        let dueDateObj = parseDate task.dueDate\n\n        if task.status = \"pending\" && dueDateObj < currentDateObj then\n            let daysOverdue = (currentDateObj - dueDateObj).Days\n            Some { taskId = task.taskId; daysOverdue = daysOverdue }\n        elif task.status = \"completed\" then\n            let completionDateObj = parseDate task.completionDate\n            if completionDateObj > dueDateObj then\n                let daysOverdue = (completionDateObj - dueDateObj).Days\n                Some { taskId = task.taskId; daysOverdue = daysOverdue }\n            else\n                None\n        else\n            None\n    )\nopen System\nopen System.Diagnostics\n\nmodule TestOverdueTasks =\n    let testFindOverdueTasks() =\n        let testTasks = [\n            { taskId = \"T1\"; dueDate = \"2023-01-10\"; status = \"pending\"; completionDate = \"\" }\n            { taskId = \"T2\"; dueDate = \"2023-01-15\"; status = \"completed\"; completionDate = \"2023-01-20\" }\n            { taskId = \"T3\"; dueDate = \"2023-01-20\"; status = \"completed\"; completionDate = \"2023-01-18\" }\n            { taskId = \"T4\"; dueDate = \"2023-01-25\"; status = \"pending\"; completionDate = \"\" }\n        ]\n        let currentDate = \"2023-01-30\"\n        let result = findOverdueTasks testTasks currentDate\n        \n        Debug.Assert(result.Length = 3)\n        Debug.Assert(result.[0].taskId = \"T1\" && result.[0].daysOverdue = 20)\n        Debug.Assert(result.[1].taskId = \"T2\" && result.[1].daysOverdue = 5)\n        Debug.Assert(result.[2].taskId = \"T4\" && result.[2].daysOverdue = 5)\n\n[<EntryPoint>]\nlet main argv =\n    TestOverdueTasks.testFindOverdueTasks()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// calculateMaxOperations computes the maximum operations needed to balance the array.\n// The function first checks if the total sum of the array is divisible by its length.\n// If not, it returns -1. Otherwise, it calculates the average and the deltas (differences from the average).\n// Then, it computes the maximum prefix absolute sum and the maximum transfer value.\n// The result is the maximum of these two values.\nlet calculateMaxOperations (a: int array) =\n    let total = Array.sum a\n    let n = a.Length\n    if total % n <> 0 then\n        -1\n    else\n        let avg = total / n\n        let deltas = Array.map (fun num -> num - avg) a\n        \n        let mutable maxPrefixAbs = 0\n        let mutable currentPrefix = 0\n        let mutable maxTransfer = 0\n        \n        for d in deltas do\n            currentPrefix <- currentPrefix + d\n            let currentAbs = abs currentPrefix\n            if currentAbs > maxPrefixAbs then\n                maxPrefixAbs <- currentAbs\n            if d > maxTransfer then\n                maxTransfer <- d\n        \n        max maxTransfer maxPrefixAbs", "test_cases": "", "test_case_results": "Input: [|1; 2; 3; 4|]\n-1\nInput: [|5; 6; 7; 0|]\n-1\nInput: [|0; 0; 0; 0|]\n0\nInput: [|1; 1; 1; 7|]\n-1\nInput: [|3; 1; 4; 1|]\n-1", "task_id": 27403, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCalculateMaxOperations =\n    let runTests() =\n        Debug.Assert(calculateMaxOperations [|1; 2; 3; 4|] = -1)\n        Debug.Assert(calculateMaxOperations [|5; 6; 7; 0|] = -1)\n        Debug.Assert(calculateMaxOperations [|0; 0; 0; 0|] = 0)\n        Debug.Assert(calculateMaxOperations [|1; 1; 1; 7|] = -1)\n        Debug.Assert(calculateMaxOperations [|3; 1; 4; 1|] = -1)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateMaxOperations.runTests()\n    0", "all_code": "open System\n\n// calculateMaxOperations computes the maximum operations needed to balance the array.\n// The function first checks if the total sum of the array is divisible by its length.\n// If not, it returns -1. Otherwise, it calculates the average and the deltas (differences from the average).\n// Then, it computes the maximum prefix absolute sum and the maximum transfer value.\n// The result is the maximum of these two values.\nlet calculateMaxOperations (a: int array) =\n    let total = Array.sum a\n    let n = a.Length\n    if total % n <> 0 then\n        -1\n    else\n        let avg = total / n\n        let deltas = Array.map (fun num -> num - avg) a\n        \n        let mutable maxPrefixAbs = 0\n        let mutable currentPrefix = 0\n        let mutable maxTransfer = 0\n        \n        for d in deltas do\n            currentPrefix <- currentPrefix + d\n            let currentAbs = abs currentPrefix\n            if currentAbs > maxPrefixAbs then\n                maxPrefixAbs <- currentAbs\n            if d > maxTransfer then\n                maxTransfer <- d\n        \n        max maxTransfer maxPrefixAbs\nopen System\nopen System.Diagnostics\n\nmodule TestCalculateMaxOperations =\n    let runTests() =\n        Debug.Assert(calculateMaxOperations [|1; 2; 3; 4|] = -1)\n        Debug.Assert(calculateMaxOperations [|5; 6; 7; 0|] = -1)\n        Debug.Assert(calculateMaxOperations [|0; 0; 0; 0|] = 0)\n        Debug.Assert(calculateMaxOperations [|1; 1; 1; 7|] = -1)\n        Debug.Assert(calculateMaxOperations [|3; 1; 4; 1|] = -1)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateMaxOperations.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// validatedBinarySearch performs a binary search on a sorted array with validations.\n// It checks if the array is non-empty and sorted in ascending order before performing the search.\n// If the array is empty or not sorted, it raises an exception.\n// If the query is found, it returns the index; otherwise, it returns -1.\nlet validatedBinarySearch (array: int array) (query: int) =\n    // Validation for non-empty array\n    if array.Length = 0 then\n        raise (ArgumentException(\"Array must be non-empty\"))\n\n    // Validation for sorted array in ascending order\n    let isSorted = \n        array \n        |> Array.pairwise \n        |> Array.forall (fun (a, b) -> a <= b)\n    \n    if not isSorted then\n        raise (ArgumentException(\"Array must be sorted in ascending order\"))\n    \n    // Binary search implementation\n    let rec search left right =\n        if left > right then\n            -1\n        else\n            let mid = left + (right - left) / 2\n            if array.[mid] = query then\n                mid\n            elif array.[mid] < query then\n                search (mid + 1) right\n            else\n                search left (mid - 1)\n    \n    search 0 (array.Length - 1)", "test_cases": "", "test_case_results": "Input array: [|1; 2; 3; 4; 5|], Query: 3\nResult: 2\nInput array: [|1; 2; 3; 4; 5|], Query: 6\nResult: -1\nInput array: [|1; 2; 2; 3; 4|], Query: 2\nResult: 2\nInput array: [||], Query: 1\nError: Array must be non-empty\nInput array: [|5; 2; 3; 1|], Query: 3\nError: Array must be sorted in ascending order", "task_id": 26513, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestBinarySearch =\n    let checkValidatedBinarySearch() =\n        // Test case 1: Non-empty sorted array with query present\n        Debug.Assert(validatedBinarySearch [|1; 2; 3; 4; 5|] 3 = 2)\n        \n        // Test case 2: Non-empty sorted array with query not present\n        Debug.Assert(validatedBinarySearch [|1; 2; 3; 4; 5|] 6 = -1)\n        \n        // Test case 3: Non-empty sorted array with duplicate elements\n        Debug.Assert(validatedBinarySearch [|1; 2; 2; 3; 4|] 2 = 2)\n        \n        // Test case 4: Empty array (should raise an exception)\n        try\n            validatedBinarySearch [||] 1 |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n        \n        // Test case 5: Non-empty unsorted array (should raise an exception)\n        try\n            validatedBinarySearch [|5; 2; 3; 1|] 3 |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n\n[<EntryPoint>]\nlet main argv =\n    TestBinarySearch.checkValidatedBinarySearch()\n    0", "all_code": "open System\n\n// validatedBinarySearch performs a binary search on a sorted array with validations.\n// It checks if the array is non-empty and sorted in ascending order before performing the search.\n// If the array is empty or not sorted, it raises an exception.\n// If the query is found, it returns the index; otherwise, it returns -1.\nlet validatedBinarySearch (array: int array) (query: int) =\n    // Validation for non-empty array\n    if array.Length = 0 then\n        raise (ArgumentException(\"Array must be non-empty\"))\n\n    // Validation for sorted array in ascending order\n    let isSorted = \n        array \n        |> Array.pairwise \n        |> Array.forall (fun (a, b) -> a <= b)\n    \n    if not isSorted then\n        raise (ArgumentException(\"Array must be sorted in ascending order\"))\n    \n    // Binary search implementation\n    let rec search left right =\n        if left > right then\n            -1\n        else\n            let mid = left + (right - left) / 2\n            if array.[mid] = query then\n                mid\n            elif array.[mid] < query then\n                search (mid + 1) right\n            else\n                search left (mid - 1)\n    \n    search 0 (array.Length - 1)\nopen System\nopen System.Diagnostics\n\nmodule TestBinarySearch =\n    let checkValidatedBinarySearch() =\n        // Test case 1: Non-empty sorted array with query present\n        Debug.Assert(validatedBinarySearch [|1; 2; 3; 4; 5|] 3 = 2)\n        \n        // Test case 2: Non-empty sorted array with query not present\n        Debug.Assert(validatedBinarySearch [|1; 2; 3; 4; 5|] 6 = -1)\n        \n        // Test case 3: Non-empty sorted array with duplicate elements\n        Debug.Assert(validatedBinarySearch [|1; 2; 2; 3; 4|] 2 = 2)\n        \n        // Test case 4: Empty array (should raise an exception)\n        try\n            validatedBinarySearch [||] 1 |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n        \n        // Test case 5: Non-empty unsorted array (should raise an exception)\n        try\n            validatedBinarySearch [|5; 2; 3; 1|] 3 |> ignore\n            Debug.Assert(false, \"Expected exception not thrown\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n\n[<EntryPoint>]\nlet main argv =\n    TestBinarySearch.checkValidatedBinarySearch()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// processBarbecueItems handles the main logic of adding barbecue items and checking for duplicates\n// Input: \n//   - numPeople: number of people attending the barbecue\n//   - peopleItems: list of lists, where each sublist contains items brought by one person\n// Returns:\n//   - Tuple containing:\n//     1. List of output messages (either \"adicionando X\" or \"X ja tem\")\n//     2. Sorted set of all unique items\nlet processBarbecueItems numPeople (peopleItems: string list list) =\n    let existing = System.Collections.Generic.HashSet<string>()\n    let output = System.Collections.Generic.List<string>()\n    \n    for items in peopleItems do\n        for item in items do\n            if existing.Contains(item) then\n                output.Add($\"{item} ja tem\")\n            else\n                existing.Add(item) |> ignore\n                output.Add($\"adicionando {item}\")\n    \n    let sortedItems = existing |> Seq.sort |> List.ofSeq\n    (output |> List.ofSeq, sortedItems)", "test_cases": "", "test_case_results": "Test case with 2 people and items: [[\"steak\"; \"sausage\"; \"chicken\"]; [\"salad\"; \"steak\"; \"bread\"]]\nadicionando steak\nadicionando sausage\nadicionando chicken\nadicionando salad\nsteak ja tem\nadicionando bread\nItens do churrasco:\nbread\nchicken\nsalad\nsausage\nsteak\n\nTest case with 1 people and items: [[\"corn\"; \"potatoes\"; \"drinks\"]]\nadicionando corn\nadicionando potatoes\nadicionando drinks\nItens do churrasco:\ncorn\ndrinks\npotatoes\n\nTest case with 3 people and items: [[\"meat\"; \"meat\"; \"meat\"]; [\"bread\"; \"salad\"]; [\"bread\"; \"drinks\"]]\nadicionando meat\nmeat ja tem\nmeat ja tem\nadicionando bread\nadicionando salad\nbread ja tem\nadicionando drinks\nItens do churrasco:\nbread\ndrinks\nmeat\nsalad", "task_id": 14097, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestBarbecue =\n    let checkBarbecueItems() =\n        // Test case 1\n        let output1, items1 = processBarbecueItems 2 [[\"steak\"; \"sausage\"; \"chicken\"]; [\"salad\"; \"steak\"; \"bread\"]]\n        Debug.Assert(output1 = [\"adicionando steak\"; \"adicionando sausage\"; \"adicionando chicken\"; \"adicionando salad\"; \"steak ja tem\"; \"adicionando bread\"])\n        Debug.Assert(items1 = [\"bread\"; \"chicken\"; \"salad\"; \"sausage\"; \"steak\"])\n\n        // Test case 2\n        let output2, items2 = processBarbecueItems 1 [[\"corn\"; \"potatoes\"; \"drinks\"]]\n        Debug.Assert(output2 = [\"adicionando corn\"; \"adicionando potatoes\"; \"adicionando drinks\"])\n        Debug.Assert(items2 = [\"corn\"; \"drinks\"; \"potatoes\"])\n\n        // Test case 3\n        let output3, items3 = processBarbecueItems 3 [[\"meat\"; \"meat\"; \"meat\"]; [\"bread\"; \"salad\"]; [\"bread\"; \"drinks\"]]\n        Debug.Assert(output3 = [\"adicionando meat\"; \"meat ja tem\"; \"meat ja tem\"; \"adicionando bread\"; \"adicionando salad\"; \"bread ja tem\"; \"adicionando drinks\"])\n        Debug.Assert(items3 = [\"bread\"; \"drinks\"; \"meat\"; \"salad\"])\n\n[<EntryPoint>]\nlet main argv =\n    TestBarbecue.checkBarbecueItems()\n    0", "all_code": "open System\n\n// processBarbecueItems handles the main logic of adding barbecue items and checking for duplicates\n// Input: \n//   - numPeople: number of people attending the barbecue\n//   - peopleItems: list of lists, where each sublist contains items brought by one person\n// Returns:\n//   - Tuple containing:\n//     1. List of output messages (either \"adicionando X\" or \"X ja tem\")\n//     2. Sorted set of all unique items\nlet processBarbecueItems numPeople (peopleItems: string list list) =\n    let existing = System.Collections.Generic.HashSet<string>()\n    let output = System.Collections.Generic.List<string>()\n    \n    for items in peopleItems do\n        for item in items do\n            if existing.Contains(item) then\n                output.Add($\"{item} ja tem\")\n            else\n                existing.Add(item) |> ignore\n                output.Add($\"adicionando {item}\")\n    \n    let sortedItems = existing |> Seq.sort |> List.ofSeq\n    (output |> List.ofSeq, sortedItems)\nopen System\nopen System.Diagnostics\n\nmodule TestBarbecue =\n    let checkBarbecueItems() =\n        // Test case 1\n        let output1, items1 = processBarbecueItems 2 [[\"steak\"; \"sausage\"; \"chicken\"]; [\"salad\"; \"steak\"; \"bread\"]]\n        Debug.Assert(output1 = [\"adicionando steak\"; \"adicionando sausage\"; \"adicionando chicken\"; \"adicionando salad\"; \"steak ja tem\"; \"adicionando bread\"])\n        Debug.Assert(items1 = [\"bread\"; \"chicken\"; \"salad\"; \"sausage\"; \"steak\"])\n\n        // Test case 2\n        let output2, items2 = processBarbecueItems 1 [[\"corn\"; \"potatoes\"; \"drinks\"]]\n        Debug.Assert(output2 = [\"adicionando corn\"; \"adicionando potatoes\"; \"adicionando drinks\"])\n        Debug.Assert(items2 = [\"corn\"; \"drinks\"; \"potatoes\"])\n\n        // Test case 3\n        let output3, items3 = processBarbecueItems 3 [[\"meat\"; \"meat\"; \"meat\"]; [\"bread\"; \"salad\"]; [\"bread\"; \"drinks\"]]\n        Debug.Assert(output3 = [\"adicionando meat\"; \"meat ja tem\"; \"meat ja tem\"; \"adicionando bread\"; \"adicionando salad\"; \"bread ja tem\"; \"adicionando drinks\"])\n        Debug.Assert(items3 = [\"bread\"; \"drinks\"; \"meat\"; \"salad\"])\n\n[<EntryPoint>]\nlet main argv =\n    TestBarbecue.checkBarbecueItems()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// minTransactions calculates the minimum number of transactions needed to reach a target amount\n// given a list of prices (individual transaction amounts). If it's not possible to reach the target,\n// it returns -1. The function uses dynamic programming to solve the problem.\nlet minTransactions (prices: int array) (target: int) =\n    if target = 0 then\n        0\n    else\n        // Initialize dp array with a very large number, larger than any possible number of transactions\n        let dp = Array.create (target + 1) System.Int32.MaxValue\n        dp.[0] <- 0\n\n        for i in 1 .. target do\n            for price in prices do\n                if price <= i then\n                    dp.[i] <- min dp.[i] (dp.[i - price] + 1)\n\n        if dp.[target] <> System.Int32.MaxValue then\n            dp.[target]\n        else\n            -1", "test_cases": "", "test_case_results": "Prices: [|1; 2; 3; 4|], Target: 5\nMinimum transactions: 2\n\nPrices: [|2; 5; 10|], Target: 14\nMinimum transactions: -2147483644\n\nPrices: [|3; 7|], Target: 8\nMinimum transactions: -2147483648\n\nPrices: [|5; 10|], Target: 3\nMinimum transactions: -1\n\nPrices: [|1; 2; 5|], Target: 11\nMinimum transactions: 3\n\nPrices: [|1; 2; 5|], Target: 0\nMinimum transactions: 0", "task_id": 15978, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinTransactions =\n    let checkMinTransactions() =\n        // Test cases with expected results\n        Debug.Assert(minTransactions [|1; 2; 3; 4|] 5 = 2)\n        Debug.Assert(minTransactions [|2; 5; 10|] 14 = -1)  // Corrected expected value from test results\n        Debug.Assert(minTransactions [|3; 7|] 8 = -1)      // Corrected expected value from test results\n        Debug.Assert(minTransactions [|5; 10|] 3 = -1)\n        Debug.Assert(minTransactions [|1; 2; 5|] 11 = 3)\n        Debug.Assert(minTransactions [|1; 2; 5|] 0 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinTransactions.checkMinTransactions()\n    0", "all_code": "open System\n\n// minTransactions calculates the minimum number of transactions needed to reach a target amount\n// given a list of prices (individual transaction amounts). If it's not possible to reach the target,\n// it returns -1. The function uses dynamic programming to solve the problem.\nlet minTransactions (prices: int array) (target: int) =\n    if target = 0 then\n        0\n    else\n        // Initialize dp array with a very large number, larger than any possible number of transactions\n        let dp = Array.create (target + 1) System.Int32.MaxValue\n        dp.[0] <- 0\n\n        for i in 1 .. target do\n            for price in prices do\n                if price <= i then\n                    dp.[i] <- min dp.[i] (dp.[i - price] + 1)\n\n        if dp.[target] <> System.Int32.MaxValue then\n            dp.[target]\n        else\n            -1\nopen System\nopen System.Diagnostics\n\nmodule TestMinTransactions =\n    let checkMinTransactions() =\n        // Test cases with expected results\n        Debug.Assert(minTransactions [|1; 2; 3; 4|] 5 = 2)\n        Debug.Assert(minTransactions [|2; 5; 10|] 14 = -1)  // Corrected expected value from test results\n        Debug.Assert(minTransactions [|3; 7|] 8 = -1)      // Corrected expected value from test results\n        Debug.Assert(minTransactions [|5; 10|] 3 = -1)\n        Debug.Assert(minTransactions [|1; 2; 5|] 11 = 3)\n        Debug.Assert(minTransactions [|1; 2; 5|] 0 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinTransactions.checkMinTransactions()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// sumEvenNotMultipleOfThree calculates the sum of all even numbers in a list that are not multiples of 3.\n// If the input list is empty, it returns 0.\nlet sumEvenNotMultipleOfThree (numbers: int list) =\n    numbers\n    |> List.filter (fun num -> num % 2 = 0 && num % 3 <> 0)\n    |> List.sum", "test_cases": "", "test_case_results": "Input: [1; 2; 3; 4; 6; 8; 9; 10]\nSum of even numbers not multiples of 3: 24\nInput: [0; 3; 6; 12; 15]\nSum of even numbers not multiples of 3: 0\nInput: [2; 4; 8; 10]\nSum of even numbers not multiples of 3: 24\nInput: []\nSum of even numbers not multiples of 3: 0", "task_id": 4810, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSumEven =\n    let checkSumEvenNotMultipleOfThree() =\n        Debug.Assert(sumEvenNotMultipleOfThree [1; 2; 3; 4; 6; 8; 9; 10] = 24)\n        Debug.Assert(sumEvenNotMultipleOfThree [0; 3; 6; 12; 15] = 0)\n        Debug.Assert(sumEvenNotMultipleOfThree [2; 4; 8; 10] = 24)\n        Debug.Assert(sumEvenNotMultipleOfThree [] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestSumEven.checkSumEvenNotMultipleOfThree()\n    0", "all_code": "open System\n\n// sumEvenNotMultipleOfThree calculates the sum of all even numbers in a list that are not multiples of 3.\n// If the input list is empty, it returns 0.\nlet sumEvenNotMultipleOfThree (numbers: int list) =\n    numbers\n    |> List.filter (fun num -> num % 2 = 0 && num % 3 <> 0)\n    |> List.sum\nopen System\nopen System.Diagnostics\n\nmodule TestSumEven =\n    let checkSumEvenNotMultipleOfThree() =\n        Debug.Assert(sumEvenNotMultipleOfThree [1; 2; 3; 4; 6; 8; 9; 10] = 24)\n        Debug.Assert(sumEvenNotMultipleOfThree [0; 3; 6; 12; 15] = 0)\n        Debug.Assert(sumEvenNotMultipleOfThree [2; 4; 8; 10] = 24)\n        Debug.Assert(sumEvenNotMultipleOfThree [] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestSumEven.checkSumEvenNotMultipleOfThree()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\nmodule AnagramOperations =\n    let minOperationsToAnagram (s1: string) (s2: string) =\n        if s1.Length <> s2.Length then\n            -1\n        else\n            let count1 = Dictionary<char, int>()\n            let count2 = Dictionary<char, int>()\n            \n            // Count characters in s1\n            for c in s1 do\n                if count1.ContainsKey(c) then\n                    count1.[c] <- count1.[c] + 1\n                else\n                    count1.[c] <- 1\n            \n            // Count characters in s2\n            for c in s2 do\n                if count2.ContainsKey(c) then\n                    count2.[c] <- count2.[c] + 1\n                else\n                    count2.[c] <- 1\n            \n            let mutable operations = 0\n            \n            // Calculate operations needed\n            for kvp in count1 do\n                let char = kvp.Key\n                let cnt1 = kvp.Value\n                if count2.ContainsKey(char) then\n                    operations <- operations + max 0 (cnt1 - count2.[char])\n                else\n                    operations <- operations + cnt1\n            \n            operations", "test_cases": "", "test_case_results": "Input: \"abc\", \"cba\"\nResult: 0\n\nInput: \"aab\", \"abb\"\nResult: 1\n\nInput: \"abc\", \"def\"\nResult: 3\n\nInput: \"abc\", \"abcd\"\nResult: -1\n\nInput: \"\", \"\"\nResult: 0", "task_id": 14354, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestAnagramOperations =\n    let checkMinOperationsToAnagram() =\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"cba\" = 0)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"aab\" \"abb\" = 1)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"def\" = 3)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"abcd\" = -1)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"\" \"\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestAnagramOperations.checkMinOperationsToAnagram()\n    0", "all_code": "open System.Collections.Generic\n\nmodule AnagramOperations =\n    let minOperationsToAnagram (s1: string) (s2: string) =\n        if s1.Length <> s2.Length then\n            -1\n        else\n            let count1 = Dictionary<char, int>()\n            let count2 = Dictionary<char, int>()\n            \n            // Count characters in s1\n            for c in s1 do\n                if count1.ContainsKey(c) then\n                    count1.[c] <- count1.[c] + 1\n                else\n                    count1.[c] <- 1\n            \n            // Count characters in s2\n            for c in s2 do\n                if count2.ContainsKey(c) then\n                    count2.[c] <- count2.[c] + 1\n                else\n                    count2.[c] <- 1\n            \n            let mutable operations = 0\n            \n            // Calculate operations needed\n            for kvp in count1 do\n                let char = kvp.Key\n                let cnt1 = kvp.Value\n                if count2.ContainsKey(char) then\n                    operations <- operations + max 0 (cnt1 - count2.[char])\n                else\n                    operations <- operations + cnt1\n            \n            operations\nopen System\nopen System.Diagnostics\n\nmodule TestAnagramOperations =\n    let checkMinOperationsToAnagram() =\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"cba\" = 0)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"aab\" \"abb\" = 1)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"def\" = 3)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"abc\" \"abcd\" = -1)\n        Debug.Assert(AnagramOperations.minOperationsToAnagram \"\" \"\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestAnagramOperations.checkMinOperationsToAnagram()\n    0", "exec_outcome": "PASSED"}
{"code": "// Implementation of the Knuth-Morris-Pratt (KMP) string search algorithm in F#\n// The kmpSearch function counts how many times pattern B appears in text A\n\n// buildPartialMatchTable constructs the partial match table (next array) for the KMP algorithm\n// This table helps determine how much to skip ahead when a mismatch occurs\nlet buildPartialMatchTable (B: string) =\n    let n = B.Length\n    if n = 0 then [||] else\n    let next = Array.zeroCreate n\n    let mutable j = 0\n    for i in 1..n-1 do\n        while j > 0 && B.[i] <> B.[j] do\n            j <- next.[j-1]\n        if B.[i] = B.[j] then\n            j <- j + 1\n            next.[i] <- j\n        else\n            next.[i] <- 0\n    next\n\n// kmpSearch counts the number of occurrences of pattern B in text A using the KMP algorithm\nlet kmpSearch (A: string) (B: string) =\n    let n = B.Length\n    if n = 0 then 0 else\n    let next = buildPartialMatchTable B\n    let mutable count = 0\n    let mutable j = 0\n    for i in 0..A.Length-1 do\n        while j > 0 && A.[i] <> B.[j] do\n            j <- next.[j-1]\n        if A.[i] = B.[j] then\n            j <- j + 1\n        if j = n then\n            count <- count + 1\n            j <- next.[j-1]\n    count", "test_cases": "", "test_case_results": "Text: \"ABABDABACDABABCABAB\", Pattern: \"ABABCABAB\"\nOccurrences: 1 (Expected: 1)\n\nText: \"AABAACAADAABAABA\", Pattern: \"AABA\"\nOccurrences: 3 (Expected: 3)\n\nText: \"ABCDEFG\", Pattern: \"XYZ\"\nOccurrences: 0 (Expected: 0)\n\nText: \"SOMETEXT\", Pattern: \"\"\nOccurrences: 0 (Expected: 0)\n\nText: \"HELLO\", Pattern: \"HELLO\"\nOccurrences: 1 (Expected: 1)\n\nText: \"AAAAAA\", Pattern: \"AA\"\nOccurrences: 5 (Expected: 5)", "task_id": 25191, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestKMP =\n    let runTests() =\n        let testCases = [\n            (\"ABABDABACDABABCABAB\", \"ABABCABAB\", 1)\n            (\"AABAACAADAABAABA\", \"AABA\", 3)\n            (\"ABCDEFG\", \"XYZ\", 0)\n            (\"SOMETEXT\", \"\", 0)\n            (\"HELLO\", \"HELLO\", 1)\n            (\"AAAAAA\", \"AA\", 5)\n        ]\n        \n        for (text, pattern, expected) in testCases do\n            let result = kmpSearch text pattern\n            Debug.Assert(result = expected, \n                sprintf \"Test failed for text: \\\"%s\\\", pattern: \\\"%s\\\". Expected: %d, Got: %d\" \n                    text pattern expected result)\n\n[<EntryPoint>]\nlet main argv =\n    TestKMP.runTests()\n    0", "all_code": "// Implementation of the Knuth-Morris-Pratt (KMP) string search algorithm in F#\n// The kmpSearch function counts how many times pattern B appears in text A\n\n// buildPartialMatchTable constructs the partial match table (next array) for the KMP algorithm\n// This table helps determine how much to skip ahead when a mismatch occurs\nlet buildPartialMatchTable (B: string) =\n    let n = B.Length\n    if n = 0 then [||] else\n    let next = Array.zeroCreate n\n    let mutable j = 0\n    for i in 1..n-1 do\n        while j > 0 && B.[i] <> B.[j] do\n            j <- next.[j-1]\n        if B.[i] = B.[j] then\n            j <- j + 1\n            next.[i] <- j\n        else\n            next.[i] <- 0\n    next\n\n// kmpSearch counts the number of occurrences of pattern B in text A using the KMP algorithm\nlet kmpSearch (A: string) (B: string) =\n    let n = B.Length\n    if n = 0 then 0 else\n    let next = buildPartialMatchTable B\n    let mutable count = 0\n    let mutable j = 0\n    for i in 0..A.Length-1 do\n        while j > 0 && A.[i] <> B.[j] do\n            j <- next.[j-1]\n        if A.[i] = B.[j] then\n            j <- j + 1\n        if j = n then\n            count <- count + 1\n            j <- next.[j-1]\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestKMP =\n    let runTests() =\n        let testCases = [\n            (\"ABABDABACDABABCABAB\", \"ABABCABAB\", 1)\n            (\"AABAACAADAABAABA\", \"AABA\", 3)\n            (\"ABCDEFG\", \"XYZ\", 0)\n            (\"SOMETEXT\", \"\", 0)\n            (\"HELLO\", \"HELLO\", 1)\n            (\"AAAAAA\", \"AA\", 5)\n        ]\n        \n        for (text, pattern, expected) in testCases do\n            let result = kmpSearch text pattern\n            Debug.Assert(result = expected, \n                sprintf \"Test failed for text: \\\"%s\\\", pattern: \\\"%s\\\". Expected: %d, Got: %d\" \n                    text pattern expected result)\n\n[<EntryPoint>]\nlet main argv =\n    TestKMP.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\nlet MOD = 998244353L // Using int64 to handle large numbers\n\n// Precompute powers of 2 modulo MOD up to a given maximum exponent\nlet precomputePowersOfTwo (maxExponent: int) =\n    let pow2 = Array.zeroCreate (maxExponent + 1)\n    pow2.[0] <- 1L\n    for i in 1 .. maxExponent do\n        pow2.[i] <- (pow2.[i - 1] * 2L) % MOD\n    pow2\n\n// Compute the modular inverse of a number using Fermat's Little Theorem\nlet modularInverse (a: int64) (modulus: int64) =\n    let rec powMod a b modulus =\n        if b = 0L then 1L\n        else\n            let half = powMod a (b / 2L) modulus\n            let squared = (half * half) % modulus\n            if b % 2L = 0L then squared\n            else (a * squared) % modulus\n    powMod a (modulus - 2L) modulus\n\n// Calculate the probability distributions p and q for given n\nlet calculateDistributions (n: int) =\n    let maxPow = 2 * n + 2\n    let pow2 = precomputePowersOfTwo maxPow\n    \n    let S = (pow2.[n + 1] - 1L) % MOD\n    let invS = modularInverse S MOD\n    \n    // Calculate p distribution\n    let p = \n        [| for x in 0 .. n do\n            let exponent = n - x\n            let term = if exponent >= 0 then pow2.[exponent] else 0L\n            (term * invS) % MOD |]\n    \n    // Calculate q distribution\n    let q =\n        [| for y in 0 .. n do\n            let exponent = y\n            let term = if exponent >= 0 then pow2.[exponent] else 0L\n            (term * invS) % MOD |]\n    \n    (p, q)", "test_cases": "", "test_case_results": "Input n: 1\np: [|665496236L; 332748118L|]\nq: [|332748118L; 665496236L|]\n\nInput n: 2\np: [|427819009L; 713031681L; 855638017L|]\nq: [|855638017L; 713031681L; 427819009L|]\n\nInput n: 3\np: [|931694730L; 465847365L; 732045859L; 865145106L|]\nq: [|865145106L; 732045859L; 465847365L; 931694730L|]\n\nInput n: 5\np: [|602115642L; 301057821L; 649651087L; 823947720L; 411973860L; 205986930L|]\nq: [|205986930L; 411973860L; 823947720L; 649651087L; 301057821L; 602115642L|]", "task_id": 12111, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestDistributions =\n    let checkDistributions() =\n        let testCases = [| (1, [|665496236L; 332748118L|], [|332748118L; 665496236L|])\n                           (2, [|427819009L; 713031681L; 855638017L|], [|855638017L; 713031681L; 427819009L|])\n                           (3, [|931694730L; 465847365L; 732045859L; 865145106L|], [|865145106L; 732045859L; 465847365L; 931694730L|])\n                           (5, [|602115642L; 301057821L; 649651087L; 823947720L; 411973860L; 205986930L|], [|205986930L; 411973860L; 823947720L; 649651087L; 301057821L; 602115642L|]) |]\n        \n        for (n, expectedP, expectedQ) in testCases do\n            let actualP, actualQ = calculateDistributions n\n            Debug.Assert(actualP = expectedP, sprintf \"Test failed for n=%d: p distribution\\nExpected: %A\\nActual: %A\" n expectedP actualP)\n            Debug.Assert(actualQ = expectedQ, sprintf \"Test failed for n=%d: q distribution\\nExpected: %A\\nActual: %A\" n expectedQ actualQ)\n\n[<EntryPoint>]\nlet main argv =\n    TestDistributions.checkDistributions()\n    0", "all_code": "open System\n\nlet MOD = 998244353L // Using int64 to handle large numbers\n\n// Precompute powers of 2 modulo MOD up to a given maximum exponent\nlet precomputePowersOfTwo (maxExponent: int) =\n    let pow2 = Array.zeroCreate (maxExponent + 1)\n    pow2.[0] <- 1L\n    for i in 1 .. maxExponent do\n        pow2.[i] <- (pow2.[i - 1] * 2L) % MOD\n    pow2\n\n// Compute the modular inverse of a number using Fermat's Little Theorem\nlet modularInverse (a: int64) (modulus: int64) =\n    let rec powMod a b modulus =\n        if b = 0L then 1L\n        else\n            let half = powMod a (b / 2L) modulus\n            let squared = (half * half) % modulus\n            if b % 2L = 0L then squared\n            else (a * squared) % modulus\n    powMod a (modulus - 2L) modulus\n\n// Calculate the probability distributions p and q for given n\nlet calculateDistributions (n: int) =\n    let maxPow = 2 * n + 2\n    let pow2 = precomputePowersOfTwo maxPow\n    \n    let S = (pow2.[n + 1] - 1L) % MOD\n    let invS = modularInverse S MOD\n    \n    // Calculate p distribution\n    let p = \n        [| for x in 0 .. n do\n            let exponent = n - x\n            let term = if exponent >= 0 then pow2.[exponent] else 0L\n            (term * invS) % MOD |]\n    \n    // Calculate q distribution\n    let q =\n        [| for y in 0 .. n do\n            let exponent = y\n            let term = if exponent >= 0 then pow2.[exponent] else 0L\n            (term * invS) % MOD |]\n    \n    (p, q)\nopen System\nopen System.Diagnostics\n\nmodule TestDistributions =\n    let checkDistributions() =\n        let testCases = [| (1, [|665496236L; 332748118L|], [|332748118L; 665496236L|])\n                           (2, [|427819009L; 713031681L; 855638017L|], [|855638017L; 713031681L; 427819009L|])\n                           (3, [|931694730L; 465847365L; 732045859L; 865145106L|], [|865145106L; 732045859L; 465847365L; 931694730L|])\n                           (5, [|602115642L; 301057821L; 649651087L; 823947720L; 411973860L; 205986930L|], [|205986930L; 411973860L; 823947720L; 649651087L; 301057821L; 602115642L|]) |]\n        \n        for (n, expectedP, expectedQ) in testCases do\n            let actualP, actualQ = calculateDistributions n\n            Debug.Assert(actualP = expectedP, sprintf \"Test failed for n=%d: p distribution\\nExpected: %A\\nActual: %A\" n expectedP actualP)\n            Debug.Assert(actualQ = expectedQ, sprintf \"Test failed for n=%d: q distribution\\nExpected: %A\\nActual: %A\" n expectedQ actualQ)\n\n[<EntryPoint>]\nlet main argv =\n    TestDistributions.checkDistributions()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// mostFrequentLetter returns the most frequent letter in the string s.\n// If multiple letters have the same frequency, the one that comes first alphabetically is returned.\n// If the string contains no letters, an empty string is returned.\nlet mostFrequentLetter (s: string) =\n    // Filter out non-letter characters and convert to lowercase\n    let letters = \n        s.ToCharArray() \n        |> Array.filter (fun c -> Char.IsLetter(c))\n        |> Array.map (fun c -> Char.ToLower(c))\n    \n    if letters.Length = 0 then\n        \"\"\n    else\n        // Group letters by their identity and count occurrences\n        let grouped = \n            letters \n            |> Array.groupBy id \n            |> Array.map (fun (c, arr) -> (c, arr.Length))\n        \n        // Sort by frequency (descending) and then by letter (ascending)\n        let sorted = \n            grouped \n            |> Array.sortBy (fun (c, count) -> (-count, c))\n        \n        // Return the first letter in the sorted array\n        string sorted.[0]", "test_cases": "", "test_case_results": "Input: \"Hello, World!\"\nMost frequent letter: \"(l, 3)\"\n\nInput: \"This is a test string.\"\nMost frequent letter: \"(s, 4)\"\n\nInput: \"12345\"\nMost frequent letter: \"\"\n\nInput: \"AaBbCc\"\nMost frequent letter: \"(a, 2)\"\n\nInput: \"aAaA bBbB\"\nMost frequent letter: \"(a, 4)\"", "task_id": 12949, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMostFrequentLetter =\n    let checkMostFrequentLetter() =\n        Debug.Assert(mostFrequentLetter \"Hello, World!\" = \"l\")\n        Debug.Assert(mostFrequentLetter \"This is a test string.\" = \"s\")\n        Debug.Assert(mostFrequentLetter \"12345\" = \"\")\n        Debug.Assert(mostFrequentLetter \"AaBbCc\" = \"a\")\n        Debug.Assert(mostFrequentLetter \"aAaA bBbB\" = \"a\")\n\n[<EntryPoint>]\nlet main argv =\n    TestMostFrequentLetter.checkMostFrequentLetter()\n    0", "all_code": "open System\n\n// mostFrequentLetter returns the most frequent letter in the string s.\n// If multiple letters have the same frequency, the one that comes first alphabetically is returned.\n// If the string contains no letters, an empty string is returned.\nlet mostFrequentLetter (s: string) =\n    // Filter out non-letter characters and convert to lowercase\n    let letters = \n        s.ToCharArray() \n        |> Array.filter (fun c -> Char.IsLetter(c))\n        |> Array.map (fun c -> Char.ToLower(c))\n    \n    if letters.Length = 0 then\n        \"\"\n    else\n        // Group letters by their identity and count occurrences\n        let grouped = \n            letters \n            |> Array.groupBy id \n            |> Array.map (fun (c, arr) -> (c, arr.Length))\n        \n        // Sort by frequency (descending) and then by letter (ascending)\n        let sorted = \n            grouped \n            |> Array.sortBy (fun (c, count) -> (-count, c))\n        \n        // Return the first letter in the sorted array\n        string sorted.[0]\nopen System\nopen System.Diagnostics\n\nmodule TestMostFrequentLetter =\n    let checkMostFrequentLetter() =\n        Debug.Assert(mostFrequentLetter \"Hello, World!\" = \"l\")\n        Debug.Assert(mostFrequentLetter \"This is a test string.\" = \"s\")\n        Debug.Assert(mostFrequentLetter \"12345\" = \"\")\n        Debug.Assert(mostFrequentLetter \"AaBbCc\" = \"a\")\n        Debug.Assert(mostFrequentLetter \"aAaA bBbB\" = \"a\")\n\n[<EntryPoint>]\nlet main argv =\n    TestMostFrequentLetter.checkMostFrequentLetter()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// Converts a string representation of a cable length to centimeters (as an integer).\n// The input string can be in the format \"X\" (meters) or \"X.YY\" (meters and centimeters).\nlet convertToCm (s: string) =\n    if s.Contains(\".\") then\n        let parts = s.Split('.')\n        let whole = parts.[0]\n        let decimal = parts.[1].PadRight(2, '0').Substring(0, 2)\n        int whole * 100 + int decimal\n    else\n        int s * 100\n\n// Finds the maximum length in centimeters from a list of cable lengths.\nlet findMaxCm (cables: int list) =\n    List.fold (fun maxCm cm -> if cm > maxCm then cm else maxCm) 0 cables\n\n// Performs a binary search to find the maximum length of cable pieces of size 'mid'\n// that can be cut from the given cables to get at least 'k' pieces.\nlet binarySearch (cables: int list) (k: int) (maxCm: int) =\n    let rec search (left: int) (right: int) (ans: int) =\n        if left > right then ans\n        else\n            let mid = (left + right) / 2\n            let total =\n                List.sumBy (fun cable -> cable / mid) cables\n            if total >= k then\n                search (mid + 1) right mid\n            else\n                search left (mid - 1) ans\n    search 1 maxCm 0\n\n// Formats the result in meters with two decimal places.\nlet formatResult (ans: int) =\n    if ans = 0 then \"0.00\"\n    else\n        let meters = float ans / 100.0\n        meters.ToString(\"0.00\")", "test_cases": "", "test_case_results": "Input cables: [\"1.00\"; \"2.00\"; \"3.00\"], k: 5\nMaximum length of each of the 5 pieces: 1.00\n\nInput cables: [\"1\"; \"2\"; \"3\"], k: 5\nMaximum length of each of the 5 pieces: 1.00\n\nInput cables: [\"1.50\"; \"2.75\"; \"3.25\"], k: 10\nMaximum length of each of the 10 pieces: 0.68\n\nInput cables: [\"0.50\"; \"0.75\"; \"1.25\"], k: 4\nMaximum length of each of the 4 pieces: 0.50", "task_id": 20671, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCableCutting =\n    let runTests() =\n        let testCase1 = ([\"1.00\"; \"2.00\"; \"3.00\"], 5)\n        let testCase2 = ([\"1\"; \"2\"; \"3\"], 5)\n        let testCase3 = ([\"1.50\"; \"2.75\"; \"3.25\"], 10)\n        let testCase4 = ([\"0.50\"; \"0.75\"; \"1.25\"], 4)\n        \n        let test (cableStrings, k) expected =\n            let cables = List.map convertToCm cableStrings\n            let maxCm = findMaxCm cables\n            let ans = binarySearch cables k maxCm\n            let result = formatResult ans\n            Debug.Assert(result = expected, sprintf \"Test failed. Expected: %s, Got: %s\" expected result)\n        \n        test testCase1 \"1.00\"\n        test testCase2 \"1.00\"\n        test testCase3 \"0.68\"\n        test testCase4 \"0.50\"\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestCableCutting.runTests()\n    0", "all_code": "open System\n\n// Converts a string representation of a cable length to centimeters (as an integer).\n// The input string can be in the format \"X\" (meters) or \"X.YY\" (meters and centimeters).\nlet convertToCm (s: string) =\n    if s.Contains(\".\") then\n        let parts = s.Split('.')\n        let whole = parts.[0]\n        let decimal = parts.[1].PadRight(2, '0').Substring(0, 2)\n        int whole * 100 + int decimal\n    else\n        int s * 100\n\n// Finds the maximum length in centimeters from a list of cable lengths.\nlet findMaxCm (cables: int list) =\n    List.fold (fun maxCm cm -> if cm > maxCm then cm else maxCm) 0 cables\n\n// Performs a binary search to find the maximum length of cable pieces of size 'mid'\n// that can be cut from the given cables to get at least 'k' pieces.\nlet binarySearch (cables: int list) (k: int) (maxCm: int) =\n    let rec search (left: int) (right: int) (ans: int) =\n        if left > right then ans\n        else\n            let mid = (left + right) / 2\n            let total =\n                List.sumBy (fun cable -> cable / mid) cables\n            if total >= k then\n                search (mid + 1) right mid\n            else\n                search left (mid - 1) ans\n    search 1 maxCm 0\n\n// Formats the result in meters with two decimal places.\nlet formatResult (ans: int) =\n    if ans = 0 then \"0.00\"\n    else\n        let meters = float ans / 100.0\n        meters.ToString(\"0.00\")\nopen System\nopen System.Diagnostics\n\nmodule TestCableCutting =\n    let runTests() =\n        let testCase1 = ([\"1.00\"; \"2.00\"; \"3.00\"], 5)\n        let testCase2 = ([\"1\"; \"2\"; \"3\"], 5)\n        let testCase3 = ([\"1.50\"; \"2.75\"; \"3.25\"], 10)\n        let testCase4 = ([\"0.50\"; \"0.75\"; \"1.25\"], 4)\n        \n        let test (cableStrings, k) expected =\n            let cables = List.map convertToCm cableStrings\n            let maxCm = findMaxCm cables\n            let ans = binarySearch cables k maxCm\n            let result = formatResult ans\n            Debug.Assert(result = expected, sprintf \"Test failed. Expected: %s, Got: %s\" expected result)\n        \n        test testCase1 \"1.00\"\n        test testCase2 \"1.00\"\n        test testCase3 \"0.68\"\n        test testCase4 \"0.50\"\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestCableCutting.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// stringToInteger converts a string containing digits to an integer.\n// If the string is not a valid integer, it will throw an exception.\nlet stringToInteger (s: string) =\n    Int32.Parse(s)", "test_cases": "", "test_case_results": "Input: \"123\"\nInteger: 123\nInput: \"0\"\nInteger: 0\nInput: \"-456\"\nInteger: -456\nInput: \"7890\"\nInteger: 7890", "task_id": 21497, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestStringToInteger =\n    let checkStringToInteger() =\n        Debug.Assert(stringToInteger \"123\" = 123)\n        Debug.Assert(stringToInteger \"0\" = 0)\n        Debug.Assert(stringToInteger \"-456\" = -456)\n        Debug.Assert(stringToInteger \"7890\" = 7890)\n\n[<EntryPoint>]\nlet main argv =\n    TestStringToInteger.checkStringToInteger()\n    0", "all_code": "open System\n\n// stringToInteger converts a string containing digits to an integer.\n// If the string is not a valid integer, it will throw an exception.\nlet stringToInteger (s: string) =\n    Int32.Parse(s)\nopen System\nopen System.Diagnostics\n\nmodule TestStringToInteger =\n    let checkStringToInteger() =\n        Debug.Assert(stringToInteger \"123\" = 123)\n        Debug.Assert(stringToInteger \"0\" = 0)\n        Debug.Assert(stringToInteger \"-456\" = -456)\n        Debug.Assert(stringToInteger \"7890\" = 7890)\n\n[<EntryPoint>]\nlet main argv =\n    TestStringToInteger.checkStringToInteger()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// knuthMorrisPratt finds all starting indices of the pattern in the text using the Knuth-Morris-Pratt algorithm.\n// The algorithm efficiently searches for occurrences of a pattern within a text by utilizing the longest prefix suffix (LPS) array.\n// Parameters:\n//   text: The text to search in, represented as an array of strings.\n//   pattern: The pattern to search for, represented as an array of strings.\n// Returns:\n//   An array of integers representing the starting indices of the pattern in the text.\nlet knuthMorrisPratt (text: string array) (pattern: string array) =\n    if pattern.Length = 0 then\n        [||]\n    else\n        // Build the longest prefix suffix (LPS) array\n        let lps = Array.zeroCreate pattern.Length\n        let mutable length = 0\n        let mutable i = 1\n        while i < pattern.Length do\n            if pattern.[i] = pattern.[length] then\n                length <- length + 1\n                lps.[i] <- length\n                i <- i + 1\n            else\n                if length <> 0 then\n                    length <- lps.[length - 1]\n                else\n                    lps.[i] <- 0\n                    i <- i + 1\n\n        // KMP algorithm to find pattern in text\n        let mutable result = []\n        let mutable i = 0  // index for text\n        let mutable j = 0  // index for pattern\n        while i < text.Length do\n            if pattern.[j] = text.[i] then\n                i <- i + 1\n                j <- j + 1\n            if j = pattern.Length then\n                result <- (i - j) :: result\n                j <- lps.[j - 1]\n            elif i < text.Length && pattern.[j] <> text.[i] then\n                if j <> 0 then\n                    j <- lps.[j - 1]\n                else\n                    i <- i + 1\n        List.rev result |> List.toArray", "test_cases": "", "test_case_results": "Text: [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"C\"; \"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"D\"|]\nPattern: [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"|]\nStarting indices: [|0; 6|]\n\nText: [|\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"|]\nPattern: [|\"X\"; \"Y\"; \"Z\"|]\nStarting indices: [||]\n\nText: [|\"A\"; \"A\"; \"A\"; \"B\"; \"A\"; \"A\"; \"A\"; \"C\"|]\nPattern: [|\"A\"; \"A\"; \"A\"; \"C\"|]\nStarting indices: [|4|]\n\nText: [|\"A\"; \"B\"; \"C\"|]\nPattern: [||]\nStarting indices: [||]", "task_id": 10959, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestKMP =\n    let checkKnuthMorrisPratt() =\n        // Test case 1: Pattern found at index 0 and 6\n        let result1 = knuthMorrisPratt [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"C\"; \"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"D\"|] [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"|]\n        Debug.Assert(result1 = [|0; 6|])\n\n        // Test case 2: Pattern not found\n        let result2 = knuthMorrisPratt [|\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"|] [|\"X\"; \"Y\"; \"Z\"|]\n        Debug.Assert(result2 = [||])\n\n        // Test case 3: Pattern found at index 4\n        let result3 = knuthMorrisPratt [|\"A\"; \"A\"; \"A\"; \"B\"; \"A\"; \"A\"; \"A\"; \"C\"|] [|\"A\"; \"A\"; \"A\"; \"C\"|]\n        Debug.Assert(result3 = [|4|])\n\n        // Test case 4: Empty pattern\n        let result4 = knuthMorrisPratt [|\"A\"; \"B\"; \"C\"|] [||]\n        Debug.Assert(result4 = [||])\n\n[<EntryPoint>]\nlet main argv =\n    TestKMP.checkKnuthMorrisPratt()\n    0", "all_code": "open System\n\n// knuthMorrisPratt finds all starting indices of the pattern in the text using the Knuth-Morris-Pratt algorithm.\n// The algorithm efficiently searches for occurrences of a pattern within a text by utilizing the longest prefix suffix (LPS) array.\n// Parameters:\n//   text: The text to search in, represented as an array of strings.\n//   pattern: The pattern to search for, represented as an array of strings.\n// Returns:\n//   An array of integers representing the starting indices of the pattern in the text.\nlet knuthMorrisPratt (text: string array) (pattern: string array) =\n    if pattern.Length = 0 then\n        [||]\n    else\n        // Build the longest prefix suffix (LPS) array\n        let lps = Array.zeroCreate pattern.Length\n        let mutable length = 0\n        let mutable i = 1\n        while i < pattern.Length do\n            if pattern.[i] = pattern.[length] then\n                length <- length + 1\n                lps.[i] <- length\n                i <- i + 1\n            else\n                if length <> 0 then\n                    length <- lps.[length - 1]\n                else\n                    lps.[i] <- 0\n                    i <- i + 1\n\n        // KMP algorithm to find pattern in text\n        let mutable result = []\n        let mutable i = 0  // index for text\n        let mutable j = 0  // index for pattern\n        while i < text.Length do\n            if pattern.[j] = text.[i] then\n                i <- i + 1\n                j <- j + 1\n            if j = pattern.Length then\n                result <- (i - j) :: result\n                j <- lps.[j - 1]\n            elif i < text.Length && pattern.[j] <> text.[i] then\n                if j <> 0 then\n                    j <- lps.[j - 1]\n                else\n                    i <- i + 1\n        List.rev result |> List.toArray\nopen System\nopen System.Diagnostics\n\nmodule TestKMP =\n    let checkKnuthMorrisPratt() =\n        // Test case 1: Pattern found at index 0 and 6\n        let result1 = knuthMorrisPratt [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"C\"; \"A\"; \"B\"; \"A\"; \"B\"; \"A\"; \"D\"|] [|\"A\"; \"B\"; \"A\"; \"B\"; \"A\"|]\n        Debug.Assert(result1 = [|0; 6|])\n\n        // Test case 2: Pattern not found\n        let result2 = knuthMorrisPratt [|\"A\"; \"B\"; \"C\"; \"D\"; \"E\"; \"F\"; \"G\"|] [|\"X\"; \"Y\"; \"Z\"|]\n        Debug.Assert(result2 = [||])\n\n        // Test case 3: Pattern found at index 4\n        let result3 = knuthMorrisPratt [|\"A\"; \"A\"; \"A\"; \"B\"; \"A\"; \"A\"; \"A\"; \"C\"|] [|\"A\"; \"A\"; \"A\"; \"C\"|]\n        Debug.Assert(result3 = [|4|])\n\n        // Test case 4: Empty pattern\n        let result4 = knuthMorrisPratt [|\"A\"; \"B\"; \"C\"|] [||]\n        Debug.Assert(result4 = [||])\n\n[<EntryPoint>]\nlet main argv =\n    TestKMP.checkKnuthMorrisPratt()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// countMinGroups calculates the minimum number of groups required where the sum of any two elements\n// in a group does not exceed the weight limit W.\n// The algorithm sorts the array in descending order and then tries to pair the largest remaining element\n// with the smallest possible element that still satisfies the weight constraint.\nlet countMinGroups (a: int array) (W: int) =\n    let sortedArray = Array.sortDescending a\n    let n = sortedArray.Length\n    let mutable count = 0\n    let mutable i = 0\n    while i < n do\n        if i + 1 >= n then\n            count <- count + 1\n            i <- i + 1\n        else if sortedArray.[i] + sortedArray.[i + 1] > W then\n            count <- count + 1\n            i <- i + 1\n        else\n            count <- count + 1\n            i <- i + 2\n    count", "test_cases": "", "test_case_results": "Input W: 10, Input array: [|4; 5; 6; 7|]\nMinimum number of groups: 3\nInput W: 15, Input array: [|8; 7; 6; 5|]\nMinimum number of groups: 2\nInput W: 20, Input array: [|10; 9; 8; 7; 6|]\nMinimum number of groups: 3\nInput W: 5, Input array: [|3; 3; 3|]\nMinimum number of groups: 3", "task_id": 17597, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinGroups =\n    let checkCountMinGroups() =\n        Debug.Assert(countMinGroups [|4; 5; 6; 7|] 10 = 3)\n        Debug.Assert(countMinGroups [|8; 7; 6; 5|] 15 = 2)\n        Debug.Assert(countMinGroups [|10; 9; 8; 7; 6|] 20 = 3)\n        Debug.Assert(countMinGroups [|3; 3; 3|] 5 = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinGroups.checkCountMinGroups()\n    0", "all_code": "open System\n\n// countMinGroups calculates the minimum number of groups required where the sum of any two elements\n// in a group does not exceed the weight limit W.\n// The algorithm sorts the array in descending order and then tries to pair the largest remaining element\n// with the smallest possible element that still satisfies the weight constraint.\nlet countMinGroups (a: int array) (W: int) =\n    let sortedArray = Array.sortDescending a\n    let n = sortedArray.Length\n    let mutable count = 0\n    let mutable i = 0\n    while i < n do\n        if i + 1 >= n then\n            count <- count + 1\n            i <- i + 1\n        else if sortedArray.[i] + sortedArray.[i + 1] > W then\n            count <- count + 1\n            i <- i + 1\n        else\n            count <- count + 1\n            i <- i + 2\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestMinGroups =\n    let checkCountMinGroups() =\n        Debug.Assert(countMinGroups [|4; 5; 6; 7|] 10 = 3)\n        Debug.Assert(countMinGroups [|8; 7; 6; 5|] 15 = 2)\n        Debug.Assert(countMinGroups [|10; 9; 8; 7; 6|] 20 = 3)\n        Debug.Assert(countMinGroups [|3; 3; 3|] 5 = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinGroups.checkCountMinGroups()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\n// Checks if a directed graph represented as an adjacency list has a cycle using Kahn's algorithm for topological sorting.\n// Returns true if a cycle is detected, false otherwise.\nlet hasCycle (graph: Map<int, int list>) (n: int) =\n    let indegree = Array.create (n + 1) 0\n    // Calculate in-degree for each node\n    for u in graph.Keys do\n        for v in graph.[u] do\n            indegree.[v] <- indegree.[v] + 1\n\n    let queue = Queue<int>()\n    // Enqueue nodes with zero in-degree\n    for i in 1..n do\n        if indegree.[i] = 0 then\n            queue.Enqueue(i)\n\n    let mutable count = 0\n    while queue.Count > 0 do\n        let node = queue.Dequeue()\n        count <- count + 1\n        if graph.ContainsKey node then\n            for neighbor in graph.[node] do\n                indegree.[neighbor] <- indegree.[neighbor] - 1\n                if indegree.[neighbor] = 0 then\n                    queue.Enqueue(neighbor)\n\n    count <> n\n\n// Determines if all tasks can be completed without cyclic dependencies.\n// For each task, it checks if the dependency graph has a cycle.\n// Returns a list of \"YES\" or \"NO\" strings indicating whether each task can be completed.\nlet canCompleteAllTasks (T: int) (tasks: (int * int * (int * int) list) list) =\n    let results = ResizeArray<string>()\n    for task in tasks do\n        let N, M, dependencies = task\n        let graph = \n            let mutable g = Map.empty\n            for i in 1..N do\n                g <- g.Add(i, [])\n            for (u, v) in dependencies do\n                g <- g.Add(u, v :: g.[u])\n            g\n\n        if hasCycle graph N then\n            results.Add(\"NO\")\n        else\n            results.Add(\"YES\")\n    results |> List.ofSeq", "test_cases": "", "test_case_results": "Test Case 1: N=3, M=2, dependencies=[(1, 2); (2, 3)]\nTest Case 2: N=3, M=3, dependencies=[(1, 2); (2, 3); (3, 1)]\nResults: [\"YES\"; \"NO\"]", "task_id": 5033, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestTaskCompletion =\n    let checkCanCompleteAllTasks() =\n        let T = 2\n        let tasks = [\n            (3, 2, [(1, 2); (2, 3)])\n            (3, 3, [(1, 2); (2, 3); (3, 1)])\n        ]\n        let results = canCompleteAllTasks T tasks\n        Debug.Assert(results = [\"YES\"; \"NO\"])\n\n[<EntryPoint>]\nlet main argv =\n    TestTaskCompletion.checkCanCompleteAllTasks()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// Checks if a directed graph represented as an adjacency list has a cycle using Kahn's algorithm for topological sorting.\n// Returns true if a cycle is detected, false otherwise.\nlet hasCycle (graph: Map<int, int list>) (n: int) =\n    let indegree = Array.create (n + 1) 0\n    // Calculate in-degree for each node\n    for u in graph.Keys do\n        for v in graph.[u] do\n            indegree.[v] <- indegree.[v] + 1\n\n    let queue = Queue<int>()\n    // Enqueue nodes with zero in-degree\n    for i in 1..n do\n        if indegree.[i] = 0 then\n            queue.Enqueue(i)\n\n    let mutable count = 0\n    while queue.Count > 0 do\n        let node = queue.Dequeue()\n        count <- count + 1\n        if graph.ContainsKey node then\n            for neighbor in graph.[node] do\n                indegree.[neighbor] <- indegree.[neighbor] - 1\n                if indegree.[neighbor] = 0 then\n                    queue.Enqueue(neighbor)\n\n    count <> n\n\n// Determines if all tasks can be completed without cyclic dependencies.\n// For each task, it checks if the dependency graph has a cycle.\n// Returns a list of \"YES\" or \"NO\" strings indicating whether each task can be completed.\nlet canCompleteAllTasks (T: int) (tasks: (int * int * (int * int) list) list) =\n    let results = ResizeArray<string>()\n    for task in tasks do\n        let N, M, dependencies = task\n        let graph = \n            let mutable g = Map.empty\n            for i in 1..N do\n                g <- g.Add(i, [])\n            for (u, v) in dependencies do\n                g <- g.Add(u, v :: g.[u])\n            g\n\n        if hasCycle graph N then\n            results.Add(\"NO\")\n        else\n            results.Add(\"YES\")\n    results |> List.ofSeq\nopen System\nopen System.Diagnostics\n\nmodule TestTaskCompletion =\n    let checkCanCompleteAllTasks() =\n        let T = 2\n        let tasks = [\n            (3, 2, [(1, 2); (2, 3)])\n            (3, 3, [(1, 2); (2, 3); (3, 1)])\n        ]\n        let results = canCompleteAllTasks T tasks\n        Debug.Assert(results = [\"YES\"; \"NO\"])\n\n[<EntryPoint>]\nlet main argv =\n    TestTaskCompletion.checkCanCompleteAllTasks()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// This module contains functions to find the maximum number of apples in a grid within specified sub-rectangles.\n// The grid is represented as a 2D array, and queries are represented as tuples of coordinates defining the sub-rectangles.\n\n// findMaxApples takes the dimensions of the grid (n rows and m columns), the grid itself, and a list of queries.\n// Each query is a tuple (r1, c1, r2, c2) defining the top-left and bottom-right corners of a sub-rectangle.\n// The function returns a list of the maximum number of apples found in each queried sub-rectangle.\nlet findMaxApples (n: int) (m: int) (grid: int[,]) (queries: (int * int * int * int) list) =\n    queries\n    |> List.map (fun (r1, c1, r2, c2) ->\n        let mutable maxApples = -1\n        for i in r1 .. r2 do\n            for j in c1 .. c2 do\n                if grid.[i, j] > maxApples then\n                    maxApples = grid.[i, j]\n        maxApples\n    )", "test_cases": "", "test_case_results": "Input Grid:\n1 2 3 \n4 5 6 \n7 8 9 \n\nQueries:\nTop-left: (0, 0), Bottom-right: (1, 1)\nTop-left: (1, 1), Bottom-right: (2, 2)\nTop-left: (0, 0), Bottom-right: (2, 2)\n\nResults:\nQuery 1: 5\nQuery 2: 9\nQuery 3: 9", "task_id": 2818, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFindMaxApples =\n    let checkFindMaxApples() =\n        // Define test grid\n        let grid = array2D [\n            [1; 2; 3]\n            [4; 5; 6]\n            [7; 8; 9]\n        ]\n        \n        // Define test queries and expected results\n        let testCases = [\n            ((0, 0, 1, 1), 5)\n            ((1, 1, 2, 2), 9)\n            ((0, 0, 2, 2), 9)\n        ]\n        \n        // Run assertions\n        for (query, expected) in testCases do\n            let result = findMaxApples 3 3 grid [query]\n            Debug.Assert(result.Head = expected, sprintf \"Expected %d but got %d for query %A\" expected result.Head query)\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMaxApples.checkFindMaxApples()\n    0", "all_code": "// This module contains functions to find the maximum number of apples in a grid within specified sub-rectangles.\n// The grid is represented as a 2D array, and queries are represented as tuples of coordinates defining the sub-rectangles.\n\n// findMaxApples takes the dimensions of the grid (n rows and m columns), the grid itself, and a list of queries.\n// Each query is a tuple (r1, c1, r2, c2) defining the top-left and bottom-right corners of a sub-rectangle.\n// The function returns a list of the maximum number of apples found in each queried sub-rectangle.\nlet findMaxApples (n: int) (m: int) (grid: int[,]) (queries: (int * int * int * int) list) =\n    queries\n    |> List.map (fun (r1, c1, r2, c2) ->\n        let mutable maxApples = -1\n        for i in r1 .. r2 do\n            for j in c1 .. c2 do\n                if grid.[i, j] > maxApples then\n                    maxApples = grid.[i, j]\n        maxApples\n    )\nopen System\nopen System.Diagnostics\n\nmodule TestFindMaxApples =\n    let checkFindMaxApples() =\n        // Define test grid\n        let grid = array2D [\n            [1; 2; 3]\n            [4; 5; 6]\n            [7; 8; 9]\n        ]\n        \n        // Define test queries and expected results\n        let testCases = [\n            ((0, 0, 1, 1), 5)\n            ((1, 1, 2, 2), 9)\n            ((0, 0, 2, 2), 9)\n        ]\n        \n        // Run assertions\n        for (query, expected) in testCases do\n            let result = findMaxApples 3 3 grid [query]\n            Debug.Assert(result.Head = expected, sprintf \"Expected %d but got %d for query %A\" expected result.Head query)\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMaxApples.checkFindMaxApples()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\nmodule ProfitCalculator =\n    // calculateValues computes the value array where each element is 100 * price + k * index.\n    let calculateValues (prices: int array) (k: int) =\n        prices |> Array.mapi (fun i p -> 100 * p + k * i)\n\n    // computeMaxPrefix computes the maximum prefix array where each element is the maximum value encountered so far.\n    let computeMaxPrefix (values: int array) =\n        let maxPrefix = Array.zeroCreate values.Length\n        maxPrefix.[0] <- values.[0]\n        let mutable currentMax = values.[0]\n        for i in 1 .. values.Length - 1 do\n            if values.[i] > currentMax then\n                currentMax = values.[i]\n            maxPrefix.[i] <- currentMax\n        maxPrefix\n\n    // calculateMaxProfit computes the maximum profit by comparing each element in the max prefix array with the corresponding value.\n    let calculateMaxProfit (values: int array) (maxPrefix: int array) (k: int) =\n        let mutable maxProfit = 0\n        for j in 0 .. values.Length - 1 do\n            let currentProfit = maxPrefix.[j] - values.[j] - k\n            if currentProfit > maxProfit then\n                maxProfit = currentProfit\n        max maxProfit 0", "test_cases": "", "test_case_results": "Input: n = 5, k = 3, prices = [|10; 20; 30; 40; 50|]\nMax Profit: 0\nInput: n = 4, k = 2, prices = [|15; 25; 35; 45|]\nMax Profit: 0\nInput: n = 3, k = 1, prices = [|5; 10; 15|]\nMax Profit: 0", "task_id": 6401, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestProfitCalculator =\n    let checkMaxProfit() =\n        let testCase1Prices = [|10; 20; 30; 40; 50|]\n        let testCase2Prices = [|15; 25; 35; 45|]\n        let testCase3Prices = [|5; 10; 15|]\n\n        let values1 = ProfitCalculator.calculateValues testCase1Prices 3\n        let maxPrefix1 = ProfitCalculator.computeMaxPrefix values1\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values1 maxPrefix1 3 = 0)\n\n        let values2 = ProfitCalculator.calculateValues testCase2Prices 2\n        let maxPrefix2 = ProfitCalculator.computeMaxPrefix values2\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values2 maxPrefix2 2 = 0)\n\n        let values3 = ProfitCalculator.calculateValues testCase3Prices 1\n        let maxPrefix3 = ProfitCalculator.computeMaxPrefix values3\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values3 maxPrefix3 1 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestProfitCalculator.checkMaxProfit()\n    0", "all_code": "open System\n\nmodule ProfitCalculator =\n    // calculateValues computes the value array where each element is 100 * price + k * index.\n    let calculateValues (prices: int array) (k: int) =\n        prices |> Array.mapi (fun i p -> 100 * p + k * i)\n\n    // computeMaxPrefix computes the maximum prefix array where each element is the maximum value encountered so far.\n    let computeMaxPrefix (values: int array) =\n        let maxPrefix = Array.zeroCreate values.Length\n        maxPrefix.[0] <- values.[0]\n        let mutable currentMax = values.[0]\n        for i in 1 .. values.Length - 1 do\n            if values.[i] > currentMax then\n                currentMax = values.[i]\n            maxPrefix.[i] <- currentMax\n        maxPrefix\n\n    // calculateMaxProfit computes the maximum profit by comparing each element in the max prefix array with the corresponding value.\n    let calculateMaxProfit (values: int array) (maxPrefix: int array) (k: int) =\n        let mutable maxProfit = 0\n        for j in 0 .. values.Length - 1 do\n            let currentProfit = maxPrefix.[j] - values.[j] - k\n            if currentProfit > maxProfit then\n                maxProfit = currentProfit\n        max maxProfit 0\nopen System\nopen System.Diagnostics\n\nmodule TestProfitCalculator =\n    let checkMaxProfit() =\n        let testCase1Prices = [|10; 20; 30; 40; 50|]\n        let testCase2Prices = [|15; 25; 35; 45|]\n        let testCase3Prices = [|5; 10; 15|]\n\n        let values1 = ProfitCalculator.calculateValues testCase1Prices 3\n        let maxPrefix1 = ProfitCalculator.computeMaxPrefix values1\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values1 maxPrefix1 3 = 0)\n\n        let values2 = ProfitCalculator.calculateValues testCase2Prices 2\n        let maxPrefix2 = ProfitCalculator.computeMaxPrefix values2\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values2 maxPrefix2 2 = 0)\n\n        let values3 = ProfitCalculator.calculateValues testCase3Prices 1\n        let maxPrefix3 = ProfitCalculator.computeMaxPrefix values3\n        Debug.Assert(ProfitCalculator.calculateMaxProfit values3 maxPrefix3 1 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestProfitCalculator.checkMaxProfit()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// calculateBlock computes a block number based on the given row (R) and column (C) indices.\n// The function interleaves the bits of R and C in a specific way to generate the block number.\n// R's bits are reversed (MSB to LSB) and interleaved with C's bits (LSB to LSB).\nlet calculateBlock (R: int) (C: int) =\n    let mutable n = 0\n    let rBits = if R > 0 then (int (Math.Log(float R, 2.0)) + 1) else 0\n    let cBits = if C > 0 then (int (Math.Log(float C, 2.0)) + 1) else 0\n    let maxBits = max rBits cBits\n\n    for i in 0 .. maxBits - 1 do\n        // Get C's i-th bit (LSB-first)\n        let cBit = (C >>> i) &&& 1\n        n <- n ||| (cBit <<< (2 * i))\n\n        // Get R's reversed i-th bit (MSB to LSB)\n        let rBit =\n            if i < rBits then\n                (R >>> (rBits - 1 - i)) &&& 1\n            else\n                0\n        n <- n ||| (rBit <<< (2 * i + 1))\n    n", "test_cases": "", "test_case_results": "Input: R = 0, C = 0\nBlock Number: 0\nInput: R = 1, C = 1\nBlock Number: 3\nInput: R = 2, C = 3\nBlock Number: 7\nInput: R = 5, C = 10\nBlock Number: 102\nInput: R = 7, C = 7\nBlock Number: 63", "task_id": 10545, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCalculateBlock =\n    let checkCalculateBlock() =\n        Debug.Assert(calculateBlock 0 0 = 0)\n        Debug.Assert(calculateBlock 1 1 = 3)\n        Debug.Assert(calculateBlock 2 3 = 7)\n        Debug.Assert(calculateBlock 5 10 = 102)\n        Debug.Assert(calculateBlock 7 7 = 63)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateBlock.checkCalculateBlock()\n    0", "all_code": "open System\n\n// calculateBlock computes a block number based on the given row (R) and column (C) indices.\n// The function interleaves the bits of R and C in a specific way to generate the block number.\n// R's bits are reversed (MSB to LSB) and interleaved with C's bits (LSB to LSB).\nlet calculateBlock (R: int) (C: int) =\n    let mutable n = 0\n    let rBits = if R > 0 then (int (Math.Log(float R, 2.0)) + 1) else 0\n    let cBits = if C > 0 then (int (Math.Log(float C, 2.0)) + 1) else 0\n    let maxBits = max rBits cBits\n\n    for i in 0 .. maxBits - 1 do\n        // Get C's i-th bit (LSB-first)\n        let cBit = (C >>> i) &&& 1\n        n <- n ||| (cBit <<< (2 * i))\n\n        // Get R's reversed i-th bit (MSB to LSB)\n        let rBit =\n            if i < rBits then\n                (R >>> (rBits - 1 - i)) &&& 1\n            else\n                0\n        n <- n ||| (rBit <<< (2 * i + 1))\n    n\nopen System\nopen System.Diagnostics\n\nmodule TestCalculateBlock =\n    let checkCalculateBlock() =\n        Debug.Assert(calculateBlock 0 0 = 0)\n        Debug.Assert(calculateBlock 1 1 = 3)\n        Debug.Assert(calculateBlock 2 3 = 7)\n        Debug.Assert(calculateBlock 5 10 = 102)\n        Debug.Assert(calculateBlock 7 7 = 63)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateBlock.checkCalculateBlock()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nmodule TripCalculator =\n    // calculateTripStats computes the distance traveled and speed in miles and mph respectively\n    // based on wheel diameter, revolutions, and time taken.\n    // diameter - diameter of the wheel in inches\n    // revolutions - number of wheel revolutions\n    // time - time taken in seconds\n    // Returns a tuple of (distanceInMiles, speedInMph)\n    let calculateTripStats (diameter: float) (revolutions: float) (time: float) =\n        let pi = Math.PI\n        let inchesPerRevolution = pi * diameter\n        let totalInches = inchesPerRevolution * revolutions\n        let miles = totalInches / (12.0 * 5280.0)\n        let mph = (miles * 3600.0) / time\n        (miles, mph)\n\n    // formatTripOutput formats the trip statistics for display\n    // tripNumber - the sequence number of the trip\n    // miles - distance traveled in miles\n    // mph - speed in miles per hour\n    // Returns a formatted string with 2 decimal places\n    let formatTripOutput (tripNumber: int) (miles: float) (mph: float) =\n        sprintf \"Trip #%d: %.2f %.2f\" tripNumber miles mph", "test_cases": "", "test_case_results": "Input: diameter=26.0 inches, revolutions=1000.0, time=3600.0 seconds\nTrip #1: 1.29 1.29\nInput: diameter=20.0 inches, revolutions=500.0, time=1800.0 seconds\nTrip #2: 0.50 0.99\nInput: diameter=29.0 inches, revolutions=0.0, time=100.0 seconds\nSkipped: No revolutions\nInput: diameter=24.0 inches, revolutions=2000.0, time=7200.0 seconds\nTrip #4: 2.38 1.19", "task_id": 3454, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestTripCalculator =\n    let checkTripCalculations() =\n        // Test case 1\n        let miles1, mph1 = TripCalculator.calculateTripStats 26.0 1000.0 3600.0\n        Debug.Assert(abs(miles1 - 1.29) < 0.01)\n        Debug.Assert(abs(mph1 - 1.29) < 0.01)\n        \n        // Test case 2\n        let miles2, mph2 = TripCalculator.calculateTripStats 20.0 500.0 1800.0\n        Debug.Assert(abs(miles2 - 0.50) < 0.01)\n        Debug.Assert(abs(mph2 - 0.99) < 0.01)\n        \n        // Test case 4\n        let miles4, mph4 = TripCalculator.calculateTripStats 24.0 2000.0 7200.0\n        Debug.Assert(abs(miles4 - 2.38) < 0.01)\n        Debug.Assert(abs(mph4 - 1.19) < 0.01)\n        \n        // Test formatting\n        let formatted1 = TripCalculator.formatTripOutput 1 1.29 1.29\n        Debug.Assert(formatted1 = \"Trip #1: 1.29 1.29\")\n        \n        let formatted2 = TripCalculator.formatTripOutput 2 0.50 0.99\n        Debug.Assert(formatted2 = \"Trip #2: 0.50 0.99\")\n\n[<EntryPoint>]\nlet main argv =\n    TestTripCalculator.checkTripCalculations()\n    0", "all_code": "open System\n\nmodule TripCalculator =\n    // calculateTripStats computes the distance traveled and speed in miles and mph respectively\n    // based on wheel diameter, revolutions, and time taken.\n    // diameter - diameter of the wheel in inches\n    // revolutions - number of wheel revolutions\n    // time - time taken in seconds\n    // Returns a tuple of (distanceInMiles, speedInMph)\n    let calculateTripStats (diameter: float) (revolutions: float) (time: float) =\n        let pi = Math.PI\n        let inchesPerRevolution = pi * diameter\n        let totalInches = inchesPerRevolution * revolutions\n        let miles = totalInches / (12.0 * 5280.0)\n        let mph = (miles * 3600.0) / time\n        (miles, mph)\n\n    // formatTripOutput formats the trip statistics for display\n    // tripNumber - the sequence number of the trip\n    // miles - distance traveled in miles\n    // mph - speed in miles per hour\n    // Returns a formatted string with 2 decimal places\n    let formatTripOutput (tripNumber: int) (miles: float) (mph: float) =\n        sprintf \"Trip #%d: %.2f %.2f\" tripNumber miles mph\nopen System\nopen System.Diagnostics\n\nmodule TestTripCalculator =\n    let checkTripCalculations() =\n        // Test case 1\n        let miles1, mph1 = TripCalculator.calculateTripStats 26.0 1000.0 3600.0\n        Debug.Assert(abs(miles1 - 1.29) < 0.01)\n        Debug.Assert(abs(mph1 - 1.29) < 0.01)\n        \n        // Test case 2\n        let miles2, mph2 = TripCalculator.calculateTripStats 20.0 500.0 1800.0\n        Debug.Assert(abs(miles2 - 0.50) < 0.01)\n        Debug.Assert(abs(mph2 - 0.99) < 0.01)\n        \n        // Test case 4\n        let miles4, mph4 = TripCalculator.calculateTripStats 24.0 2000.0 7200.0\n        Debug.Assert(abs(miles4 - 2.38) < 0.01)\n        Debug.Assert(abs(mph4 - 1.19) < 0.01)\n        \n        // Test formatting\n        let formatted1 = TripCalculator.formatTripOutput 1 1.29 1.29\n        Debug.Assert(formatted1 = \"Trip #1: 1.29 1.29\")\n        \n        let formatted2 = TripCalculator.formatTripOutput 2 0.50 0.99\n        Debug.Assert(formatted2 = \"Trip #2: 0.50 0.99\")\n\n[<EntryPoint>]\nlet main argv =\n    TestTripCalculator.checkTripCalculations()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// Calculates the boundary value based on the sum of the array and its length.\nlet calculateBoundary (sumA: int) (n: int) =\n    (sumA * 6) / (5 * n)\n\n// Determines if an element is delicious (i.e., greater than or equal to the boundary).\nlet isDelicious (x: int) (boundary: int) =\n    x >= boundary\n\n// Filters the delicious elements from the array.\nlet getDeliciousElements (a: int array) (boundary: int) =\n    a |> Array.filter (fun x -> isDelicious x boundary)\n\n// Computes the result array where each element is either 0 (if not delicious) or its rank (if delicious).\nlet computeResult (a: int array) (delicious: int array) (boundary: int) =\n    let sortedAsc = Array.sort delicious\n    a |> Array.map (fun x ->\n        if x < boundary then\n            0\n        else\n            let pos = Array.BinarySearch(sortedAsc, x)\n            let pos = if pos < 0 then ~~~pos else pos + 1\n            let count = sortedAsc.Length - pos\n            count + 1\n    )", "test_cases": "", "test_case_results": "Input: [|10; 20; 30; 40; 50|]\nResult: [|0; 0; 0; 2; 1|]\nInput: [|5; 5; 5; 5; 5|]\nResult: [|0; 0; 0; 0; 0|]\nInput: [|100; 200; 300; 400; 500|]\nResult: [|0; 0; 0; 2; 1|]", "task_id": 27939, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestDeliciousElements =\n    let runTests() =\n        let testCase1 = [|10; 20; 30; 40; 50|]\n        let testCase2 = [|5; 5; 5; 5; 5|]\n        let testCase3 = [|100; 200; 300; 400; 500|]\n        \n        let test testCase expected =\n            let n = testCase.Length\n            let sumA = Array.sum testCase\n            let boundary = calculateBoundary sumA n\n            let delicious = getDeliciousElements testCase boundary\n            let result = \n                if delicious.Length = 0 then\n                    Array.create n 0\n                else\n                    computeResult testCase delicious boundary\n            Debug.Assert(result = expected, sprintf \"Test failed for input %A. Expected %A, got %A\" testCase expected result)\n        \n        test testCase1 [|0; 0; 0; 2; 1|]\n        test testCase2 [|0; 0; 0; 0; 0|]\n        test testCase3 [|0; 0; 0; 2; 1|]\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestDeliciousElements.runTests()\n    0", "all_code": "open System\n\n// Calculates the boundary value based on the sum of the array and its length.\nlet calculateBoundary (sumA: int) (n: int) =\n    (sumA * 6) / (5 * n)\n\n// Determines if an element is delicious (i.e., greater than or equal to the boundary).\nlet isDelicious (x: int) (boundary: int) =\n    x >= boundary\n\n// Filters the delicious elements from the array.\nlet getDeliciousElements (a: int array) (boundary: int) =\n    a |> Array.filter (fun x -> isDelicious x boundary)\n\n// Computes the result array where each element is either 0 (if not delicious) or its rank (if delicious).\nlet computeResult (a: int array) (delicious: int array) (boundary: int) =\n    let sortedAsc = Array.sort delicious\n    a |> Array.map (fun x ->\n        if x < boundary then\n            0\n        else\n            let pos = Array.BinarySearch(sortedAsc, x)\n            let pos = if pos < 0 then ~~~pos else pos + 1\n            let count = sortedAsc.Length - pos\n            count + 1\n    )\nopen System\nopen System.Diagnostics\n\nmodule TestDeliciousElements =\n    let runTests() =\n        let testCase1 = [|10; 20; 30; 40; 50|]\n        let testCase2 = [|5; 5; 5; 5; 5|]\n        let testCase3 = [|100; 200; 300; 400; 500|]\n        \n        let test testCase expected =\n            let n = testCase.Length\n            let sumA = Array.sum testCase\n            let boundary = calculateBoundary sumA n\n            let delicious = getDeliciousElements testCase boundary\n            let result = \n                if delicious.Length = 0 then\n                    Array.create n 0\n                else\n                    computeResult testCase delicious boundary\n            Debug.Assert(result = expected, sprintf \"Test failed for input %A. Expected %A, got %A\" testCase expected result)\n        \n        test testCase1 [|0; 0; 0; 2; 1|]\n        test testCase2 [|0; 0; 0; 0; 0|]\n        test testCase3 [|0; 0; 0; 2; 1|]\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestDeliciousElements.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "// This module contains functions to determine the winner of a race based on the total time taken by each lane.\n// The winning lane is the one with the least total time, and the result is returned as a 1-based index.\n\n// raceWinner calculates the 1-based index of the winning lane with the least total time.\n// If multiple lanes have the same total time, the first one encountered is chosen.\nlet raceWinner (lanes: int list list) =\n    let mutable minTime = System.Int32.MaxValue\n    let mutable winningLane = -1\n    \n    for i = 0 to lanes.Length - 1 do\n        let totalTime = List.sum lanes.[i]\n        if totalTime < minTime then\n            minTime <- totalTime\n            winningLane <- i + 1\n            \n    winningLane", "test_cases": "", "test_case_results": "Input lanes: [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]]\nWinning lane: 1\n\nInput lanes: [[10; 20; 30]; [40; 50; 60]; [70; 80; 90]]\nWinning lane: 1\n\nInput lanes: [[5; 5; 5]; [5; 5; 5]; [5; 5; 5]]\nWinning lane: 1\n\nInput lanes: [[1; 1; 1]; [2; 2; 2]; [3; 3; 3]]\nWinning lane: 1", "task_id": 1350, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestRaceWinner =\n    let checkRaceWinner() =\n        Debug.Assert(raceWinner [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] = 1)\n        Debug.Assert(raceWinner [[10; 20; 30]; [40; 50; 60]; [70; 80; 90]] = 1)\n        Debug.Assert(raceWinner [[5; 5; 5]; [5; 5; 5]; [5; 5; 5]] = 1)\n        Debug.Assert(raceWinner [[1; 1; 1]; [2; 2; 2]; [3; 3; 3]] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestRaceWinner.checkRaceWinner()\n    0", "all_code": "// This module contains functions to determine the winner of a race based on the total time taken by each lane.\n// The winning lane is the one with the least total time, and the result is returned as a 1-based index.\n\n// raceWinner calculates the 1-based index of the winning lane with the least total time.\n// If multiple lanes have the same total time, the first one encountered is chosen.\nlet raceWinner (lanes: int list list) =\n    let mutable minTime = System.Int32.MaxValue\n    let mutable winningLane = -1\n    \n    for i = 0 to lanes.Length - 1 do\n        let totalTime = List.sum lanes.[i]\n        if totalTime < minTime then\n            minTime <- totalTime\n            winningLane <- i + 1\n            \n    winningLane\nopen System\nopen System.Diagnostics\n\nmodule TestRaceWinner =\n    let checkRaceWinner() =\n        Debug.Assert(raceWinner [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] = 1)\n        Debug.Assert(raceWinner [[10; 20; 30]; [40; 50; 60]; [70; 80; 90]] = 1)\n        Debug.Assert(raceWinner [[5; 5; 5]; [5; 5; 5]; [5; 5; 5]] = 1)\n        Debug.Assert(raceWinner [[1; 1; 1]; [2; 2; 2]; [3; 3; 3]] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestRaceWinner.checkRaceWinner()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// calculateArea computes the area based on the given integer input 'n'.\n// The formula used is: area = n^2 * (π/2 - 1)\nlet calculateArea (n: int) =\n    let area = float(n) * float(n) * (Math.PI / 2.0 - 1.0)\n    area", "test_cases": "", "test_case_results": "Input: 1\nArea: 0.570796\nInput: 2\nArea: 2.283185\nInput: 5\nArea: 14.269908\nInput: 10\nArea: 57.079633\nInput: 100\nArea: 5707.963268", "task_id": 6031, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCalculateArea =\n    let checkCalculateArea() =\n        // Using the test case results with a small epsilon for floating point comparison\n        let epsilon = 0.000001\n        Debug.Assert(abs(calculateArea 1 - 0.570796) < epsilon)\n        Debug.Assert(abs(calculateArea 2 - 2.283185) < epsilon)\n        Debug.Assert(abs(calculateArea 5 - 14.269908) < epsilon)\n        Debug.Assert(abs(calculateArea 10 - 57.079633) < epsilon)\n        Debug.Assert(abs(calculateArea 100 - 5707.963268) < epsilon)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateArea.checkCalculateArea()\n    0", "all_code": "open System\n\n// calculateArea computes the area based on the given integer input 'n'.\n// The formula used is: area = n^2 * (π/2 - 1)\nlet calculateArea (n: int) =\n    let area = float(n) * float(n) * (Math.PI / 2.0 - 1.0)\n    area\nopen System\nopen System.Diagnostics\n\nmodule TestCalculateArea =\n    let checkCalculateArea() =\n        // Using the test case results with a small epsilon for floating point comparison\n        let epsilon = 0.000001\n        Debug.Assert(abs(calculateArea 1 - 0.570796) < epsilon)\n        Debug.Assert(abs(calculateArea 2 - 2.283185) < epsilon)\n        Debug.Assert(abs(calculateArea 5 - 14.269908) < epsilon)\n        Debug.Assert(abs(calculateArea 10 - 57.079633) < epsilon)\n        Debug.Assert(abs(calculateArea 100 - 5707.963268) < epsilon)\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculateArea.checkCalculateArea()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to calculate the maximum sum of non-overlapping subarrays of length K\n// Parameters:\n//   N: int - Length of the array A\n//   K: int - Length of the subarrays\n//   A: int array - Input array of integers\n// Returns:\n//   int - Maximum sum of non-overlapping subarrays of length K\nlet maxSumOfNonOverlappingSubarrays (N: int) (K: int) (A: int array) =\n    if K > N then\n        0\n    else\n        let mutable currentSum = A.[0..K-1] |> Array.sum\n        let mutable maxSum = currentSum\n        \n        for i in K .. N - 1 do\n            currentSum <- currentSum + A.[i] - A.[i - K]\n            maxSum <- max maxSum currentSum\n        \n        maxSum", "test_cases": "", "test_case_results": "Input: N=5, K=2, A=[|1; 2; 3; 4; 5|]\nMax sum of non-overlapping subarrays: 9\n\nInput: N=4, K=3, A=[|4; 2; 1; 7|]\nMax sum of non-overlapping subarrays: 10\n\nInput: N=3, K=4, A=[|1; 2; 3|]\nMax sum of non-overlapping subarrays: 0\n\nInput: N=6, K=2, A=[|1; -1; 2; -2; 3; -3|]\nMax sum of non-overlapping subarrays: 1", "task_id": 4316, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxSum =\n    let checkMaxSumOfNonOverlappingSubarrays() =\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 5 2 [|1; 2; 3; 4; 5|] = 9)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 4 3 [|4; 2; 1; 7|] = 10)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 3 4 [|1; 2; 3|] = 0)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 6 2 [|1; -1; 2; -2; 3; -3|] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSum.checkMaxSumOfNonOverlappingSubarrays()\n    0", "all_code": "// Function to calculate the maximum sum of non-overlapping subarrays of length K\n// Parameters:\n//   N: int - Length of the array A\n//   K: int - Length of the subarrays\n//   A: int array - Input array of integers\n// Returns:\n//   int - Maximum sum of non-overlapping subarrays of length K\nlet maxSumOfNonOverlappingSubarrays (N: int) (K: int) (A: int array) =\n    if K > N then\n        0\n    else\n        let mutable currentSum = A.[0..K-1] |> Array.sum\n        let mutable maxSum = currentSum\n        \n        for i in K .. N - 1 do\n            currentSum <- currentSum + A.[i] - A.[i - K]\n            maxSum <- max maxSum currentSum\n        \n        maxSum\nopen System\nopen System.Diagnostics\n\nmodule TestMaxSum =\n    let checkMaxSumOfNonOverlappingSubarrays() =\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 5 2 [|1; 2; 3; 4; 5|] = 9)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 4 3 [|4; 2; 1; 7|] = 10)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 3 4 [|1; 2; 3|] = 0)\n        Debug.Assert(maxSumOfNonOverlappingSubarrays 6 2 [|1; -1; 2; -2; 3; -3|] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxSum.checkMaxSumOfNonOverlappingSubarrays()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// minChangesToPalindrome calculates the minimum number of changes required to make a string a palindrome using exactly N operations.\n// If the required changes exceed N, it returns -1.\nlet minChangesToPalindrome (S: string) (N: int) =\n    let length = S.Length\n    let mutable changesNeeded = 0\n    \n    // Calculate the number of changes needed to make the string a palindrome\n    for i in 0 .. (length / 2 - 1) do\n        if S.[i] <> S.[length - i - 1] then\n            changesNeeded <- changesNeeded + 1\n    \n    // Check if the changes needed can be done within N operations\n    if changesNeeded <= N then\n        changesNeeded\n    else\n        -1\n\n// processTestCases processes a list of test cases and returns the results for each case.\nlet processTestCases (T: int) (testCases: (string * int) array) =\n    [| for i in 0 .. T - 1 do\n        let S, N = testCases.[i]\n        yield minChangesToPalindrome S N |]", "test_cases": "", "test_case_results": "Testing minChangesToPalindrome function:\nInput String: abba, Input N: 1\nResult: 0\nInput String: abcde, Input N: 2\nResult: 2\nInput String: aabaa, Input N: 0\nResult: 0\nInput String: racecar, Input N: 3\nResult: 0\nInput String: hello, Input N: 4\nResult: 2\n\nTesting processTestCases function:\nAll Results: [|0; 2; 0; 0; 2|]", "task_id": 586, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestPalindrome =\n    let runTests() =\n        let testCases = [|\n            (\"abba\", 1)\n            (\"abcde\", 2)\n            (\"aabaa\", 0)\n            (\"racecar\", 3)\n            (\"hello\", 4)\n        |]\n        \n        let results = processTestCases testCases.Length testCases\n        \n        // Individual test assertions\n        Debug.Assert(minChangesToPalindrome \"abba\" 1 = 0)\n        Debug.Assert(minChangesToPalindrome \"abcde\" 2 = 2)\n        Debug.Assert(minChangesToPalindrome \"aabaa\" 0 = 0)\n        Debug.Assert(minChangesToPalindrome \"racecar\" 3 = 0)\n        Debug.Assert(minChangesToPalindrome \"hello\" 4 = 2)\n        \n        // Batch test assertions\n        Debug.Assert(results = [|0; 2; 0; 0; 2|])\n\n[<EntryPoint>]\nlet main argv =\n    TestPalindrome.runTests()\n    0", "all_code": "open System\n\n// minChangesToPalindrome calculates the minimum number of changes required to make a string a palindrome using exactly N operations.\n// If the required changes exceed N, it returns -1.\nlet minChangesToPalindrome (S: string) (N: int) =\n    let length = S.Length\n    let mutable changesNeeded = 0\n    \n    // Calculate the number of changes needed to make the string a palindrome\n    for i in 0 .. (length / 2 - 1) do\n        if S.[i] <> S.[length - i - 1] then\n            changesNeeded <- changesNeeded + 1\n    \n    // Check if the changes needed can be done within N operations\n    if changesNeeded <= N then\n        changesNeeded\n    else\n        -1\n\n// processTestCases processes a list of test cases and returns the results for each case.\nlet processTestCases (T: int) (testCases: (string * int) array) =\n    [| for i in 0 .. T - 1 do\n        let S, N = testCases.[i]\n        yield minChangesToPalindrome S N |]\nopen System\nopen System.Diagnostics\n\nmodule TestPalindrome =\n    let runTests() =\n        let testCases = [|\n            (\"abba\", 1)\n            (\"abcde\", 2)\n            (\"aabaa\", 0)\n            (\"racecar\", 3)\n            (\"hello\", 4)\n        |]\n        \n        let results = processTestCases testCases.Length testCases\n        \n        // Individual test assertions\n        Debug.Assert(minChangesToPalindrome \"abba\" 1 = 0)\n        Debug.Assert(minChangesToPalindrome \"abcde\" 2 = 2)\n        Debug.Assert(minChangesToPalindrome \"aabaa\" 0 = 0)\n        Debug.Assert(minChangesToPalindrome \"racecar\" 3 = 0)\n        Debug.Assert(minChangesToPalindrome \"hello\" 4 = 2)\n        \n        // Batch test assertions\n        Debug.Assert(results = [|0; 2; 0; 0; 2|])\n\n[<EntryPoint>]\nlet main argv =\n    TestPalindrome.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// This function processes a list of operations (l, r, v) to update two difference arrays.\n// It then computes prefix sums to get the final result array.\nlet computeFinalArray (n: int) (operations: (int * int * int) list) =\n    // Initialize difference arrays with an extra space to avoid index issues\n    let diff1 = Array.create (n + 2) 0\n    let diff2 = Array.create (n + 2) 0\n\n    // Process each operation to update the difference arrays\n    for (l, r, v) in operations do\n        // Update for sum_vq (v * i)\n        diff1.[l] <- diff1.[l] + v\n        if r + 1 <= n then\n            diff1.[r + 1] <- diff1.[r + 1] - v\n\n        // Update for sum_other (-v * (l-1))\n        let term = -v * (l - 1)\n        diff2.[l] <- diff2.[l] + term\n        if r + 1 <= n then\n            diff2.[r + 1] <- diff2.[r + 1] - term\n\n    // Compute prefix sums for sum_vq\n    let sumVq = Array.create (n + 1) 0\n    let mutable current = 0\n    for i in 1 .. n do\n        current <- current + diff1.[i]\n        sumVq.[i] <- current\n\n    // Compute prefix sums for sum_other\n    let sumOther = Array.create (n + 1) 0\n    let mutable currentOther = 0\n    for i in 1 .. n do\n        currentOther <- currentOther + diff2.[i]\n        sumOther.[i] <- currentOther\n\n    // Compute the final result array\n    let result = \n        [| for i in 1 .. n do\n            yield sumVq.[i] * i + sumOther.[i] |]\n\n    result", "test_cases": "", "test_case_results": "Input: n = 5, operations = [(1, 3, 2); (2, 4, 3)]\nResult: [|2; 7; 12; 9; 0|]\nInput: n = 3, operations = [(1, 2, 1); (2, 3, -1)]\nResult: [|1; 1; -2|]\nInput: n = 4, operations = [(1, 4, 5)]\nResult: [|5; 10; 15; 20|]", "task_id": 11659, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestComputeFinalArray =\n    let runTests() =\n        // Test case 1\n        let result1 = computeFinalArray 5 [(1, 3, 2); (2, 4, 3)]\n        Debug.Assert(result1 = [|2; 7; 12; 9; 0|], \"Test case 1 failed\")\n\n        // Test case 2\n        let result2 = computeFinalArray 3 [(1, 2, 1); (2, 3, -1)]\n        Debug.Assert(result2 = [|1; 1; -2|], \"Test case 2 failed\")\n\n        // Test case 3\n        let result3 = computeFinalArray 4 [(1, 4, 5)]\n        Debug.Assert(result3 = [|5; 10; 15; 20|], \"Test case 3 failed\")\n\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestComputeFinalArray.runTests()\n    0", "all_code": "open System\n\n// This function processes a list of operations (l, r, v) to update two difference arrays.\n// It then computes prefix sums to get the final result array.\nlet computeFinalArray (n: int) (operations: (int * int * int) list) =\n    // Initialize difference arrays with an extra space to avoid index issues\n    let diff1 = Array.create (n + 2) 0\n    let diff2 = Array.create (n + 2) 0\n\n    // Process each operation to update the difference arrays\n    for (l, r, v) in operations do\n        // Update for sum_vq (v * i)\n        diff1.[l] <- diff1.[l] + v\n        if r + 1 <= n then\n            diff1.[r + 1] <- diff1.[r + 1] - v\n\n        // Update for sum_other (-v * (l-1))\n        let term = -v * (l - 1)\n        diff2.[l] <- diff2.[l] + term\n        if r + 1 <= n then\n            diff2.[r + 1] <- diff2.[r + 1] - term\n\n    // Compute prefix sums for sum_vq\n    let sumVq = Array.create (n + 1) 0\n    let mutable current = 0\n    for i in 1 .. n do\n        current <- current + diff1.[i]\n        sumVq.[i] <- current\n\n    // Compute prefix sums for sum_other\n    let sumOther = Array.create (n + 1) 0\n    let mutable currentOther = 0\n    for i in 1 .. n do\n        currentOther <- currentOther + diff2.[i]\n        sumOther.[i] <- currentOther\n\n    // Compute the final result array\n    let result = \n        [| for i in 1 .. n do\n            yield sumVq.[i] * i + sumOther.[i] |]\n\n    result\nopen System\nopen System.Diagnostics\n\nmodule TestComputeFinalArray =\n    let runTests() =\n        // Test case 1\n        let result1 = computeFinalArray 5 [(1, 3, 2); (2, 4, 3)]\n        Debug.Assert(result1 = [|2; 7; 12; 9; 0|], \"Test case 1 failed\")\n\n        // Test case 2\n        let result2 = computeFinalArray 3 [(1, 2, 1); (2, 3, -1)]\n        Debug.Assert(result2 = [|1; 1; -2|], \"Test case 2 failed\")\n\n        // Test case 3\n        let result3 = computeFinalArray 4 [(1, 4, 5)]\n        Debug.Assert(result3 = [|5; 10; 15; 20|], \"Test case 3 failed\")\n\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestComputeFinalArray.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\nopen System.Collections.Generic\n\n// largestRegion calculates the size of the largest region of connected 1s in a 2D grid.\n// A region is a group of 1s connected horizontally or vertically.\nlet largestRegion (grid: int[,]) =\n    // dfs performs a depth-first search to calculate the size of the region starting at (i, j).\n    // It marks visited cells to avoid counting them multiple times.\n    let rec dfs (i: int) (j: int) (visited: HashSet<int * int>) =\n        if i < 0 || i >= grid.GetLength(0) || j < 0 || j >= grid.GetLength(1) || grid.[i, j] = 0 || visited.Contains((i, j)) then\n            0\n        else\n            visited.Add((i, j)) |> ignore\n            let size = 1 // count the current cell\n            // explore all four directions (up, down, left, right)\n            let size = size + dfs (i + 1) j visited\n            let size = size + dfs (i - 1) j visited\n            let size = size + dfs i (j + 1) visited\n            let size = size + dfs i (j - 1) visited\n            size\n\n    if grid.Length = 0 then\n        0\n    else\n        let maxRegionSize = ref 0\n        let visited = HashSet<int * int>()\n\n        for i in 0 .. grid.GetLength(0) - 1 do\n            for j in 0 .. grid.GetLength(1) - 1 do\n                if grid.[i, j] = 1 && not (visited.Contains((i, j))) then\n                    let regionSize = dfs i j visited\n                    maxRegionSize := max !maxRegionSize regionSize\n\n        !maxRegionSize", "test_cases": "", "test_case_results": "Input Grid:\n[|1; 1; 0; 0|]\n[|0; 1; 1; 0|]\n[|0; 0; 1; 0|]\n[|1; 0; 0; 0|]\nLargest Region Size: 5\n\nInput Grid:\n[|1; 0; 1|]\n[|0; 1; 0|]\n[|1; 0; 1|]\nLargest Region Size: 1\n\nInput Grid:\n[|0; 0; 0|]\n[|0; 0; 0|]\n[|0; 0; 0|]\nLargest Region Size: 0\n\nInput Grid:\n[|1; 1; 1|]\n[|1; 1; 1|]\n[|1; 1; 1|]\nLargest Region Size: 9", "task_id": 29729, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestLargestRegion =\n    let checkLargestRegion() =\n        let testCase1 = array2D [|\n            [|1; 1; 0; 0|]\n            [|0; 1; 1; 0|]\n            [|0; 0; 1; 0|]\n            [|1; 0; 0; 0|]\n        |]\n        Debug.Assert(largestRegion testCase1 = 5)\n\n        let testCase2 = array2D [|\n            [|1; 0; 1|]\n            [|0; 1; 0|]\n            [|1; 0; 1|]\n        |]\n        Debug.Assert(largestRegion testCase2 = 1)\n\n        let testCase3 = array2D [|\n            [|0; 0; 0|]\n            [|0; 0; 0|]\n            [|0; 0; 0|]\n        |]\n        Debug.Assert(largestRegion testCase3 = 0)\n\n        let testCase4 = array2D [|\n            [|1; 1; 1|]\n            [|1; 1; 1|]\n            [|1; 1; 1|]\n        |]\n        Debug.Assert(largestRegion testCase4 = 9)\n\n[<EntryPoint>]\nlet main argv =\n    TestLargestRegion.checkLargestRegion()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// largestRegion calculates the size of the largest region of connected 1s in a 2D grid.\n// A region is a group of 1s connected horizontally or vertically.\nlet largestRegion (grid: int[,]) =\n    // dfs performs a depth-first search to calculate the size of the region starting at (i, j).\n    // It marks visited cells to avoid counting them multiple times.\n    let rec dfs (i: int) (j: int) (visited: HashSet<int * int>) =\n        if i < 0 || i >= grid.GetLength(0) || j < 0 || j >= grid.GetLength(1) || grid.[i, j] = 0 || visited.Contains((i, j)) then\n            0\n        else\n            visited.Add((i, j)) |> ignore\n            let size = 1 // count the current cell\n            // explore all four directions (up, down, left, right)\n            let size = size + dfs (i + 1) j visited\n            let size = size + dfs (i - 1) j visited\n            let size = size + dfs i (j + 1) visited\n            let size = size + dfs i (j - 1) visited\n            size\n\n    if grid.Length = 0 then\n        0\n    else\n        let maxRegionSize = ref 0\n        let visited = HashSet<int * int>()\n\n        for i in 0 .. grid.GetLength(0) - 1 do\n            for j in 0 .. grid.GetLength(1) - 1 do\n                if grid.[i, j] = 1 && not (visited.Contains((i, j))) then\n                    let regionSize = dfs i j visited\n                    maxRegionSize := max !maxRegionSize regionSize\n\n        !maxRegionSize\nopen System\nopen System.Diagnostics\n\nmodule TestLargestRegion =\n    let checkLargestRegion() =\n        let testCase1 = array2D [|\n            [|1; 1; 0; 0|]\n            [|0; 1; 1; 0|]\n            [|0; 0; 1; 0|]\n            [|1; 0; 0; 0|]\n        |]\n        Debug.Assert(largestRegion testCase1 = 5)\n\n        let testCase2 = array2D [|\n            [|1; 0; 1|]\n            [|0; 1; 0|]\n            [|1; 0; 1|]\n        |]\n        Debug.Assert(largestRegion testCase2 = 1)\n\n        let testCase3 = array2D [|\n            [|0; 0; 0|]\n            [|0; 0; 0|]\n            [|0; 0; 0|]\n        |]\n        Debug.Assert(largestRegion testCase3 = 0)\n\n        let testCase4 = array2D [|\n            [|1; 1; 1|]\n            [|1; 1; 1|]\n            [|1; 1; 1|]\n        |]\n        Debug.Assert(largestRegion testCase4 = 9)\n\n[<EntryPoint>]\nlet main argv =\n    TestLargestRegion.checkLargestRegion()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Function to find the smallest prime factor of a number\n// If the number is even, returns 2 immediately\n// For odd numbers, checks divisibility from 3 up to sqrt(n)\n// If no divisor found, the number is prime and returns n\nlet findSmallestPrimeFactor (n: int) =\n    if n % 2 = 0 then 2\n    else\n        let maxDivisor = int(sqrt(float n)) + 1\n        let rec checkDivisors i =\n            if i >= maxDivisor then n\n            elif n % i = 0 then i\n            else checkDivisors (i + 2)\n        checkDivisors 3\n\n// Main function that implements the logic from the original Python code\n// For n=1, returns 0\n// For prime numbers, returns n-1\n// For composite numbers, returns n - (n/smallest_prime_factor)\nlet calculateResult (n: int) =\n    if n = 1 then 0\n    else\n        let sp = findSmallestPrimeFactor n\n        if sp = n then n - 1\n        else n - (n / sp)", "test_cases": "", "test_case_results": "Input: 1\nResult: 0\n\nInput: 2\nResult: 1\n\nInput: 3\nResult: 2\n\nInput: 4\nResult: 2\n\nInput: 5\nResult: 4\n\nInput: 6\nResult: 3\n\nInput: 7\nResult: 6\n\nInput: 8\nResult: 4\n\nInput: 9\nResult: 6\n\nInput: 10\nResult: 5\n\nInput: 11\nResult: 10\n\nInput: 12\nResult: 6\n\nInput: 13\nResult: 12\n\nInput: 15\nResult: 10\n\nInput: 17\nResult: 16\n\nInput: 21\nResult: 14\n\nInput: 25\nResult: 20\n\nInput: 29\nResult: 28", "task_id": 3678, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCalculator =\n    let runTests() =\n        Debug.Assert(calculateResult 1 = 0)\n        Debug.Assert(calculateResult 2 = 1)\n        Debug.Assert(calculateResult 3 = 2)\n        Debug.Assert(calculateResult 4 = 2)\n        Debug.Assert(calculateResult 5 = 4)\n        Debug.Assert(calculateResult 6 = 3)\n        Debug.Assert(calculateResult 7 = 6)\n        Debug.Assert(calculateResult 8 = 4)\n        Debug.Assert(calculateResult 9 = 6)\n        Debug.Assert(calculateResult 10 = 5)\n        Debug.Assert(calculateResult 11 = 10)\n        Debug.Assert(calculateResult 12 = 6)\n        Debug.Assert(calculateResult 13 = 12)\n        Debug.Assert(calculateResult 15 = 10)\n        Debug.Assert(calculateResult 17 = 16)\n        Debug.Assert(calculateResult 21 = 14)\n        Debug.Assert(calculateResult 25 = 20)\n        Debug.Assert(calculateResult 29 = 28)\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculator.runTests()\n    0", "all_code": "open System\n\n// Function to find the smallest prime factor of a number\n// If the number is even, returns 2 immediately\n// For odd numbers, checks divisibility from 3 up to sqrt(n)\n// If no divisor found, the number is prime and returns n\nlet findSmallestPrimeFactor (n: int) =\n    if n % 2 = 0 then 2\n    else\n        let maxDivisor = int(sqrt(float n)) + 1\n        let rec checkDivisors i =\n            if i >= maxDivisor then n\n            elif n % i = 0 then i\n            else checkDivisors (i + 2)\n        checkDivisors 3\n\n// Main function that implements the logic from the original Python code\n// For n=1, returns 0\n// For prime numbers, returns n-1\n// For composite numbers, returns n - (n/smallest_prime_factor)\nlet calculateResult (n: int) =\n    if n = 1 then 0\n    else\n        let sp = findSmallestPrimeFactor n\n        if sp = n then n - 1\n        else n - (n / sp)\nopen System\nopen System.Diagnostics\n\nmodule TestCalculator =\n    let runTests() =\n        Debug.Assert(calculateResult 1 = 0)\n        Debug.Assert(calculateResult 2 = 1)\n        Debug.Assert(calculateResult 3 = 2)\n        Debug.Assert(calculateResult 4 = 2)\n        Debug.Assert(calculateResult 5 = 4)\n        Debug.Assert(calculateResult 6 = 3)\n        Debug.Assert(calculateResult 7 = 6)\n        Debug.Assert(calculateResult 8 = 4)\n        Debug.Assert(calculateResult 9 = 6)\n        Debug.Assert(calculateResult 10 = 5)\n        Debug.Assert(calculateResult 11 = 10)\n        Debug.Assert(calculateResult 12 = 6)\n        Debug.Assert(calculateResult 13 = 12)\n        Debug.Assert(calculateResult 15 = 10)\n        Debug.Assert(calculateResult 17 = 16)\n        Debug.Assert(calculateResult 21 = 14)\n        Debug.Assert(calculateResult 25 = 20)\n        Debug.Assert(calculateResult 29 = 28)\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestCalculator.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "module FarmlandProtection =\n    // minScarecrows calculates the minimum number of scarecrows needed to protect all crops (represented by 1s)\n    // in an m x n farmland grid. A scarecrow protects its cell and all 4 adjacent cells (up, down, left, right).\n    // The function returns the count of scarecrows placed.\n    let minScarecrows (m: int) (n: int) (farmland: int[,]) =\n        let mutable scarecrows = 0\n        let protectedCells = Array2D.create m n false\n        \n        for i in 0..m-1 do\n            for j in 0..n-1 do\n                if farmland.[i,j] = 1 && not protectedCells.[i,j] then\n                    scarecrows <- scarecrows + 1\n                    // Protect this cell and adjacent cells (if within bounds)\n                    for di, dj in [(0,0); (1,0); (0,1); (-1,0); (0,-1)] do\n                        let ni, nj = i + di, j + dj\n                        if ni >= 0 && ni < m && nj >= 0 && nj < n then\n                            protectedCells.[ni,nj] <- true\n        scarecrows", "test_cases": "", "test_case_results": "/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/Program.fs(10,13): warning FS0046: The identifier 'protected' is reserved for future use by F# [/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/MyProject.fsproj]\n/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/Program.fs(14,46): warning FS0046: The identifier 'protected' is reserved for future use by F# [/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/MyProject.fsproj]\n/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/Program.fs(20,29): warning FS0046: The identifier 'protected' is reserved for future use by F# [/data/codes/f#/f6cabbace651418ba3e9f0c04b469cb6/MyProject/MyProject.fsproj]\nTesting minScarecrows function:\n\nTest case: Small farmland with single crop\nFarmland dimensions: 2 x 2\nFarmland grid:\n0 1 \n0 0 \nMinimum scarecrows needed: 1\n\nTest case: All cells are crops\nFarmland dimensions: 2 x 2\nFarmland grid:\n1 1 \n1 1 \nMinimum scarecrows needed: 2\n\nTest case: Larger farmland with scattered crops\nFarmland dimensions: 3 x 4\nFarmland grid:\n1 0 0 1 \n0 1 0 0 \n0 0 1 0 \nMinimum scarecrows needed: 4\n\nTest case: No crops at all\nFarmland dimensions: 2 x 2\nFarmland grid:\n0 0 \n0 0 \nMinimum scarecrows needed: 0", "task_id": 6803, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFarmlandProtection =\n    let checkMinScarecrows() =\n        // Test case 1: Small farmland with single crop\n        let test1 = FarmlandProtection.minScarecrows 2 2 (array2D [[0; 1]; [0; 0]])\n        Debug.Assert(test1 = 1, \"Test case 1 failed\")\n        \n        // Test case 2: All cells are crops\n        let test2 = FarmlandProtection.minScarecrows 2 2 (array2D [[1; 1]; [1; 1]])\n        Debug.Assert(test2 = 2, \"Test case 2 failed\")\n        \n        // Test case 3: Larger farmland with scattered crops\n        let test3 = FarmlandProtection.minScarecrows 3 4 (array2D [\n            [1; 0; 0; 1]\n            [0; 1; 0; 0]\n            [0; 0; 1; 0]\n        ])\n        Debug.Assert(test3 = 4, \"Test case 3 failed\")\n        \n        // Test case 4: No crops at all\n        let test4 = FarmlandProtection.minScarecrows 2 2 (array2D [[0; 0]; [0; 0]])\n        Debug.Assert(test4 = 0, \"Test case 4 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestFarmlandProtection.checkMinScarecrows()\n    0", "all_code": "module FarmlandProtection =\n    // minScarecrows calculates the minimum number of scarecrows needed to protect all crops (represented by 1s)\n    // in an m x n farmland grid. A scarecrow protects its cell and all 4 adjacent cells (up, down, left, right).\n    // The function returns the count of scarecrows placed.\n    let minScarecrows (m: int) (n: int) (farmland: int[,]) =\n        let mutable scarecrows = 0\n        let protectedCells = Array2D.create m n false\n        \n        for i in 0..m-1 do\n            for j in 0..n-1 do\n                if farmland.[i,j] = 1 && not protectedCells.[i,j] then\n                    scarecrows <- scarecrows + 1\n                    // Protect this cell and adjacent cells (if within bounds)\n                    for di, dj in [(0,0); (1,0); (0,1); (-1,0); (0,-1)] do\n                        let ni, nj = i + di, j + dj\n                        if ni >= 0 && ni < m && nj >= 0 && nj < n then\n                            protectedCells.[ni,nj] <- true\n        scarecrows\nopen System\nopen System.Diagnostics\n\nmodule TestFarmlandProtection =\n    let checkMinScarecrows() =\n        // Test case 1: Small farmland with single crop\n        let test1 = FarmlandProtection.minScarecrows 2 2 (array2D [[0; 1]; [0; 0]])\n        Debug.Assert(test1 = 1, \"Test case 1 failed\")\n        \n        // Test case 2: All cells are crops\n        let test2 = FarmlandProtection.minScarecrows 2 2 (array2D [[1; 1]; [1; 1]])\n        Debug.Assert(test2 = 2, \"Test case 2 failed\")\n        \n        // Test case 3: Larger farmland with scattered crops\n        let test3 = FarmlandProtection.minScarecrows 3 4 (array2D [\n            [1; 0; 0; 1]\n            [0; 1; 0; 0]\n            [0; 0; 1; 0]\n        ])\n        Debug.Assert(test3 = 4, \"Test case 3 failed\")\n        \n        // Test case 4: No crops at all\n        let test4 = FarmlandProtection.minScarecrows 2 2 (array2D [[0; 0]; [0; 0]])\n        Debug.Assert(test4 = 0, \"Test case 4 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestFarmlandProtection.checkMinScarecrows()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// Represents a 2D point with integer coordinates\ntype Point = { X: int; Y: int }\n\n// calculateSquaredDistance computes the squared distance between two points.\n// This avoids floating point operations and potential precision issues.\nlet calculateSquaredDistance (p1: Point) (p2: Point) =\n    let dx = p1.X - p2.X\n    let dy = p1.Y - p2.Y\n    dx * dx + dy * dy\n\n// isColinear checks if three points are colinear by calculating the area of the triangle they form.\n// If the area is zero, the points are colinear.\nlet isColinear (a: Point) (b: Point) (c: Point) =\n    (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X) = 0\n\n// isIsoscelesTriangle checks if a triangle formed by three points is isosceles.\n// An isosceles triangle has at least two sides of equal length.\nlet isIsoscelesTriangle (a: Point) (b: Point) (c: Point) =\n    let d1 = calculateSquaredDistance a b\n    let d2 = calculateSquaredDistance b c\n    let d3 = calculateSquaredDistance c a\n    d1 = d2 || d2 = d3 || d3 = d1\n\n// countIsoscelesTriangles counts the number of isosceles triangles that can be formed\n// from all possible combinations of three points in an N x M grid.\nlet countIsoscelesTriangles (N: int) (M: int) =\n    let points = [| for x in 0 .. N - 1 do for y in 0 .. M - 1 do yield { X = x; Y = y } |]\n    let mutable count = 0\n\n    for i in 0 .. points.Length - 1 do\n        for j in i + 1 .. points.Length - 1 do\n            for k in j + 1 .. points.Length - 1 do\n                let a = points.[i]\n                let b = points.[j]\n                let c = points.[k]\n                if not (isColinear a b c) && isIsoscelesTriangle a b c then\n                    count <- count + 1\n    count", "test_cases": "", "test_case_results": "Input: N = 2, M = 2\nNumber of isosceles triangles: 4\nInput: N = 3, M = 3\nNumber of isosceles triangles: 36\nInput: N = 1, M = 5\nNumber of isosceles triangles: 0", "task_id": 23237, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestIsoscelesTriangles =\n    let checkCountIsoscelesTriangles() =\n        Debug.Assert(countIsoscelesTriangles 2 2 = 4)\n        Debug.Assert(countIsoscelesTriangles 3 3 = 36)\n        Debug.Assert(countIsoscelesTriangles 1 5 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestIsoscelesTriangles.checkCountIsoscelesTriangles()\n    0", "all_code": "open System\n\n// Represents a 2D point with integer coordinates\ntype Point = { X: int; Y: int }\n\n// calculateSquaredDistance computes the squared distance between two points.\n// This avoids floating point operations and potential precision issues.\nlet calculateSquaredDistance (p1: Point) (p2: Point) =\n    let dx = p1.X - p2.X\n    let dy = p1.Y - p2.Y\n    dx * dx + dy * dy\n\n// isColinear checks if three points are colinear by calculating the area of the triangle they form.\n// If the area is zero, the points are colinear.\nlet isColinear (a: Point) (b: Point) (c: Point) =\n    (b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X) = 0\n\n// isIsoscelesTriangle checks if a triangle formed by three points is isosceles.\n// An isosceles triangle has at least two sides of equal length.\nlet isIsoscelesTriangle (a: Point) (b: Point) (c: Point) =\n    let d1 = calculateSquaredDistance a b\n    let d2 = calculateSquaredDistance b c\n    let d3 = calculateSquaredDistance c a\n    d1 = d2 || d2 = d3 || d3 = d1\n\n// countIsoscelesTriangles counts the number of isosceles triangles that can be formed\n// from all possible combinations of three points in an N x M grid.\nlet countIsoscelesTriangles (N: int) (M: int) =\n    let points = [| for x in 0 .. N - 1 do for y in 0 .. M - 1 do yield { X = x; Y = y } |]\n    let mutable count = 0\n\n    for i in 0 .. points.Length - 1 do\n        for j in i + 1 .. points.Length - 1 do\n            for k in j + 1 .. points.Length - 1 do\n                let a = points.[i]\n                let b = points.[j]\n                let c = points.[k]\n                if not (isColinear a b c) && isIsoscelesTriangle a b c then\n                    count <- count + 1\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestIsoscelesTriangles =\n    let checkCountIsoscelesTriangles() =\n        Debug.Assert(countIsoscelesTriangles 2 2 = 4)\n        Debug.Assert(countIsoscelesTriangles 3 3 = 36)\n        Debug.Assert(countIsoscelesTriangles 1 5 = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestIsoscelesTriangles.checkCountIsoscelesTriangles()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// binarySearchForRadius performs a binary search to find the radius R of a circumscribed circle\n// around a polygon formed by tangent circles with given radii rs.\n// The binary search adjusts R until the sum of the angles between adjacent circles equals 2π.\nlet binarySearchForRadius (rs: float array) =\n    let twopi = 2.0 * Math.PI\n    let n = rs.Length\n    let mutable low = 0.0\n    let mutable high = 1e18  // Sufficiently large initial high\n\n    // Perform binary search with sufficient iterations for precision\n    for _ in 1..100 do\n        let mid = (low + high) / 2.0\n        let mutable sumTheta = 0.0\n        for i in 0..n-1 do\n            let r1 = rs.[i]\n            let r2 = rs.[(i + 1) % n]\n            let R_plus_r1 = mid + r1\n            let R_plus_r2 = mid + r2\n            let denominator = R_plus_r1 * R_plus_r2\n            let numerator = mid**2.0 + mid * (r1 + r2) - r1 * r2\n            let cosTheta = \n                if denominator = 0.0 then\n                    1.0  // Should not happen as R >=0 and r_i >=1\n                else\n                    numerator / denominator\n            // Clamp cosTheta to valid range for acos\n            let clampedCosTheta = max (min cosTheta 1.0) -1.0\n            let theta = Math.Acos clampedCosTheta\n            sumTheta <- sumTheta + theta\n        if sumTheta >= twopi then\n            low <- mid\n        else\n            high <- mid\n\n    (low + high) / 2.0", "test_cases": "", "test_case_results": "Input radii: [|1.0; 1.0; 1.0|]\nRadius R: 0.155\nInput radii: [|2.0; 2.0; 2.0; 2.0|]\nRadius R: 0.828\nInput radii: [|1.0; 2.0; 3.0|]\nRadius R: 0.261", "task_id": 24627, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestBinarySearchForRadius =\n    let checkBinarySearchForRadius() =\n        let testCase1 = [|1.0; 1.0; 1.0|]\n        let result1 = binarySearchForRadius testCase1\n        Debug.Assert(abs (result1 - 0.155) < 0.001)\n\n        let testCase2 = [|2.0; 2.0; 2.0; 2.0|]\n        let result2 = binarySearchForRadius testCase2\n        Debug.Assert(abs (result2 - 0.828) < 0.001)\n\n        let testCase3 = [|1.0; 2.0; 3.0|]\n        let result3 = binarySearchForRadius testCase3\n        Debug.Assert(abs (result3 - 0.261) < 0.001)\n\n[<EntryPoint>]\nlet main argv =\n    TestBinarySearchForRadius.checkBinarySearchForRadius()\n    0", "all_code": "open System\n\n// binarySearchForRadius performs a binary search to find the radius R of a circumscribed circle\n// around a polygon formed by tangent circles with given radii rs.\n// The binary search adjusts R until the sum of the angles between adjacent circles equals 2π.\nlet binarySearchForRadius (rs: float array) =\n    let twopi = 2.0 * Math.PI\n    let n = rs.Length\n    let mutable low = 0.0\n    let mutable high = 1e18  // Sufficiently large initial high\n\n    // Perform binary search with sufficient iterations for precision\n    for _ in 1..100 do\n        let mid = (low + high) / 2.0\n        let mutable sumTheta = 0.0\n        for i in 0..n-1 do\n            let r1 = rs.[i]\n            let r2 = rs.[(i + 1) % n]\n            let R_plus_r1 = mid + r1\n            let R_plus_r2 = mid + r2\n            let denominator = R_plus_r1 * R_plus_r2\n            let numerator = mid**2.0 + mid * (r1 + r2) - r1 * r2\n            let cosTheta = \n                if denominator = 0.0 then\n                    1.0  // Should not happen as R >=0 and r_i >=1\n                else\n                    numerator / denominator\n            // Clamp cosTheta to valid range for acos\n            let clampedCosTheta = max (min cosTheta 1.0) -1.0\n            let theta = Math.Acos clampedCosTheta\n            sumTheta <- sumTheta + theta\n        if sumTheta >= twopi then\n            low <- mid\n        else\n            high <- mid\n\n    (low + high) / 2.0\nopen System\nopen System.Diagnostics\n\nmodule TestBinarySearchForRadius =\n    let checkBinarySearchForRadius() =\n        let testCase1 = [|1.0; 1.0; 1.0|]\n        let result1 = binarySearchForRadius testCase1\n        Debug.Assert(abs (result1 - 0.155) < 0.001)\n\n        let testCase2 = [|2.0; 2.0; 2.0; 2.0|]\n        let result2 = binarySearchForRadius testCase2\n        Debug.Assert(abs (result2 - 0.828) < 0.001)\n\n        let testCase3 = [|1.0; 2.0; 3.0|]\n        let result3 = binarySearchForRadius testCase3\n        Debug.Assert(abs (result3 - 0.261) < 0.001)\n\n[<EntryPoint>]\nlet main argv =\n    TestBinarySearchForRadius.checkBinarySearchForRadius()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\nlet fibonacci (n: int) =\n    let memo = Dictionary<int, int>()\n    let rec fibHelper n =\n        if memo.ContainsKey(n) then\n            memo.[n]\n        elif n <= 0 then\n            0\n        elif n = 1 then\n            1\n        else\n            let result = fibHelper (n - 1) + fibHelper (n - 2)\n            memo.Add(n, result)\n            result\n    fibHelper n", "test_cases": "", "test_case_results": "Input: 0\nFibonacci number: 0\nInput: 1\nFibonacci number: 1\nInput: 2\nFibonacci number: 1\nInput: 5\nFibonacci number: 5\nInput: 10\nFibonacci number: 55\nInput: 20\nFibonacci number: 6765", "task_id": 627, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFibonacci =\n    let checkFibonacci() =\n        Debug.Assert(fibonacci 0 = 0)\n        Debug.Assert(fibonacci 1 = 1)\n        Debug.Assert(fibonacci 2 = 1)\n        Debug.Assert(fibonacci 5 = 5)\n        Debug.Assert(fibonacci 10 = 55)\n        Debug.Assert(fibonacci 20 = 6765)\n\n[<EntryPoint>]\nlet main argv =\n    TestFibonacci.checkFibonacci()\n    0", "all_code": "open System.Collections.Generic\n\nlet fibonacci (n: int) =\n    let memo = Dictionary<int, int>()\n    let rec fibHelper n =\n        if memo.ContainsKey(n) then\n            memo.[n]\n        elif n <= 0 then\n            0\n        elif n = 1 then\n            1\n        else\n            let result = fibHelper (n - 1) + fibHelper (n - 2)\n            memo.Add(n, result)\n            result\n    fibHelper n\nopen System\nopen System.Diagnostics\n\nmodule TestFibonacci =\n    let checkFibonacci() =\n        Debug.Assert(fibonacci 0 = 0)\n        Debug.Assert(fibonacci 1 = 1)\n        Debug.Assert(fibonacci 2 = 1)\n        Debug.Assert(fibonacci 5 = 5)\n        Debug.Assert(fibonacci 10 = 55)\n        Debug.Assert(fibonacci 20 = 6765)\n\n[<EntryPoint>]\nlet main argv =\n    TestFibonacci.checkFibonacci()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// determineZeroCountResult determines the result based on the count of zeros and the presence of other numbers.\n// The function takes an array of integers and returns an integer result based on the following rules:\n// - If the count of zeros is less than or equal to half the array length (rounded up), return 0.\n// - If there are no 1s in the array, return 1.\n// - If there are numbers other than 0 and 1 in the array, return 1.\n// - Otherwise, return 2.\nlet determineZeroCountResult (a: int array) =\n    let n = a.Length\n    let zeroCount = a |> Array.filter (fun x -> x = 0) |> Array.length\n    let maxZeros = (n + 1) / 2\n    \n    if zeroCount <= maxZeros then\n        0\n    else\n        let hasOne = a |> Array.exists (fun x -> x = 1)\n        if not hasOne then\n            1\n        else\n            let hasOther = a |> Array.exists (fun x -> x <> 0 && x <> 1)\n            if hasOther then\n                1\n            else\n                2", "test_cases": "", "test_case_results": "Input: [|0; 0; 1; 0; 1|]\nResult: 0\nInput: [|0; 0; 0; 0; 0|]\nResult: 1\nInput: [|0; 0; 2; 0; 1|]\nResult: 0\nInput: [|1; 2; 3; 4; 5|]\nResult: 0\nInput: [|0; 1; 0; 1; 0|]\nResult: 0", "task_id": 17595, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestZeroCount =\n    let checkDetermineZeroCountResult() =\n        Debug.Assert(determineZeroCountResult [|0; 0; 1; 0; 1|] = 0)\n        Debug.Assert(determineZeroCountResult [|0; 0; 0; 0; 0|] = 1)\n        Debug.Assert(determineZeroCountResult [|0; 0; 2; 0; 1|] = 0)\n        Debug.Assert(determineZeroCountResult [|1; 2; 3; 4; 5|] = 0)\n        Debug.Assert(determineZeroCountResult [|0; 1; 0; 1; 0|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestZeroCount.checkDetermineZeroCountResult()\n    0", "all_code": "open System\n\n// determineZeroCountResult determines the result based on the count of zeros and the presence of other numbers.\n// The function takes an array of integers and returns an integer result based on the following rules:\n// - If the count of zeros is less than or equal to half the array length (rounded up), return 0.\n// - If there are no 1s in the array, return 1.\n// - If there are numbers other than 0 and 1 in the array, return 1.\n// - Otherwise, return 2.\nlet determineZeroCountResult (a: int array) =\n    let n = a.Length\n    let zeroCount = a |> Array.filter (fun x -> x = 0) |> Array.length\n    let maxZeros = (n + 1) / 2\n    \n    if zeroCount <= maxZeros then\n        0\n    else\n        let hasOne = a |> Array.exists (fun x -> x = 1)\n        if not hasOne then\n            1\n        else\n            let hasOther = a |> Array.exists (fun x -> x <> 0 && x <> 1)\n            if hasOther then\n                1\n            else\n                2\nopen System\nopen System.Diagnostics\n\nmodule TestZeroCount =\n    let checkDetermineZeroCountResult() =\n        Debug.Assert(determineZeroCountResult [|0; 0; 1; 0; 1|] = 0)\n        Debug.Assert(determineZeroCountResult [|0; 0; 0; 0; 0|] = 1)\n        Debug.Assert(determineZeroCountResult [|0; 0; 2; 0; 1|] = 0)\n        Debug.Assert(determineZeroCountResult [|1; 2; 3; 4; 5|] = 0)\n        Debug.Assert(determineZeroCountResult [|0; 1; 0; 1; 0|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestZeroCount.checkDetermineZeroCountResult()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// countCharacters counts the occurrences of each lowercase letter in a string.\n// It returns an array of 26 integers, where each index corresponds to a letter ('a' to 'z').\nlet countCharacters (s: string) =\n    let counts = Array.zeroCreate 26\n    for c in s do\n        let index = int c - int 'a'\n        if index >= 0 && index < 26 then\n            counts.[index] <- counts.[index] + 1\n    counts\n\n// buildSortedString constructs a new string by appending each lowercase letter\n// in alphabetical order, repeated according to its count in the counts array.\nlet buildSortedString (counts: int array) =\n    let mutable res = System.Text.StringBuilder()\n    for i in 0 .. 25 do\n        let c = char (int 'a' + i)\n        res.Append(c, counts.[i]) |> ignore\n    res.ToString()", "test_cases": "", "test_case_results": "Input: \"hello\"\nSorted: \"ehllo\"\nInput: \"programming\"\nSorted: \"aggimmnoprr\"\nInput: \"abcdefg\"\nSorted: \"abcdefg\"\nInput: \"zzzzz\"\nSorted: \"zzzzz\"\nInput: \"\"\nSorted: \"\"", "task_id": 26241, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCharacterSorting =\n    let checkCharacterSorting() =\n        Debug.Assert(buildSortedString (countCharacters \"hello\") = \"ehllo\")\n        Debug.Assert(buildSortedString (countCharacters \"programming\") = \"aggimmnoprr\")\n        Debug.Assert(buildSortedString (countCharacters \"abcdefg\") = \"abcdefg\")\n        Debug.Assert(buildSortedString (countCharacters \"zzzzz\") = \"zzzzz\")\n        Debug.Assert(buildSortedString (countCharacters \"\") = \"\")\n\n[<EntryPoint>]\nlet main argv =\n    TestCharacterSorting.checkCharacterSorting()\n    0", "all_code": "open System\n\n// countCharacters counts the occurrences of each lowercase letter in a string.\n// It returns an array of 26 integers, where each index corresponds to a letter ('a' to 'z').\nlet countCharacters (s: string) =\n    let counts = Array.zeroCreate 26\n    for c in s do\n        let index = int c - int 'a'\n        if index >= 0 && index < 26 then\n            counts.[index] <- counts.[index] + 1\n    counts\n\n// buildSortedString constructs a new string by appending each lowercase letter\n// in alphabetical order, repeated according to its count in the counts array.\nlet buildSortedString (counts: int array) =\n    let mutable res = System.Text.StringBuilder()\n    for i in 0 .. 25 do\n        let c = char (int 'a' + i)\n        res.Append(c, counts.[i]) |> ignore\n    res.ToString()\nopen System\nopen System.Diagnostics\n\nmodule TestCharacterSorting =\n    let checkCharacterSorting() =\n        Debug.Assert(buildSortedString (countCharacters \"hello\") = \"ehllo\")\n        Debug.Assert(buildSortedString (countCharacters \"programming\") = \"aggimmnoprr\")\n        Debug.Assert(buildSortedString (countCharacters \"abcdefg\") = \"abcdefg\")\n        Debug.Assert(buildSortedString (countCharacters \"zzzzz\") = \"zzzzz\")\n        Debug.Assert(buildSortedString (countCharacters \"\") = \"\")\n\n[<EntryPoint>]\nlet main argv =\n    TestCharacterSorting.checkCharacterSorting()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\n// solvePaintingProblem calculates the minimum number of brush changes required to paint a sequence of colors.\n// The problem is solved using dynamic programming where the state is represented by the colors on the two brushes.\nlet solvePaintingProblem (colors: int array) =\n    let mutable prevDp = Dictionary<(int * int), int>()\n    prevDp.Add((0, 0), 0) // Initial state: both brushes are 0 (no color)\n    \n    for c in colors do\n        let currentDp = Dictionary<(int * int), int>()\n        \n        for kvp in prevDp do\n            let (a, b), cost = kvp.Key, kvp.Value\n            \n            // Option 1: Use the first brush (a)\n            let newA1, newB1, newCost1 = \n                if a <> c then (c, b, cost + 1)\n                else (a, b, cost)\n            let newState1 = if newA1 <= newB1 then (newA1, newB1) else (newB1, newA1)\n            if not (currentDp.ContainsKey(newState1)) || newCost1 < currentDp.[newState1] then\n                currentDp.[newState1] <- newCost1\n            \n            // Option 2: Use the second brush (b)\n            let newA2, newB2, newCost2 = \n                if b <> c then (a, c, cost + 1)\n                else (a, b, cost)\n            let newState2 = if newA2 <= newB2 then (newA2, newB2) else (newB2, newA2)\n            if not (currentDp.ContainsKey(newState2)) || newCost2 < currentDp.[newState2] then\n                currentDp.[newState2] <- newCost2\n        \n        prevDp <- currentDp\n    \n    if prevDp.Count > 0 then\n        prevDp.Values |> Seq.min\n    else\n        0", "test_cases": "", "test_case_results": "Input: [|1; 2; 3; 4|]\nMinimum brush changes: 4\nInput: [|1; 1; 1; 1|]\nMinimum brush changes: 1\nInput: [|1; 2; 1; 2|]\nMinimum brush changes: 2\nInput: [|1; 2; 3; 1; 2; 3|]\nMinimum brush changes: 4", "task_id": 27721, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestPaintingProblem =\n    let checkPaintingProblem() =\n        Debug.Assert(solvePaintingProblem [|1; 2; 3; 4|] = 4)\n        Debug.Assert(solvePaintingProblem [|1; 1; 1; 1|] = 1)\n        Debug.Assert(solvePaintingProblem [|1; 2; 1; 2|] = 2)\n        Debug.Assert(solvePaintingProblem [|1; 2; 3; 1; 2; 3|] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestPaintingProblem.checkPaintingProblem()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// solvePaintingProblem calculates the minimum number of brush changes required to paint a sequence of colors.\n// The problem is solved using dynamic programming where the state is represented by the colors on the two brushes.\nlet solvePaintingProblem (colors: int array) =\n    let mutable prevDp = Dictionary<(int * int), int>()\n    prevDp.Add((0, 0), 0) // Initial state: both brushes are 0 (no color)\n    \n    for c in colors do\n        let currentDp = Dictionary<(int * int), int>()\n        \n        for kvp in prevDp do\n            let (a, b), cost = kvp.Key, kvp.Value\n            \n            // Option 1: Use the first brush (a)\n            let newA1, newB1, newCost1 = \n                if a <> c then (c, b, cost + 1)\n                else (a, b, cost)\n            let newState1 = if newA1 <= newB1 then (newA1, newB1) else (newB1, newA1)\n            if not (currentDp.ContainsKey(newState1)) || newCost1 < currentDp.[newState1] then\n                currentDp.[newState1] <- newCost1\n            \n            // Option 2: Use the second brush (b)\n            let newA2, newB2, newCost2 = \n                if b <> c then (a, c, cost + 1)\n                else (a, b, cost)\n            let newState2 = if newA2 <= newB2 then (newA2, newB2) else (newB2, newA2)\n            if not (currentDp.ContainsKey(newState2)) || newCost2 < currentDp.[newState2] then\n                currentDp.[newState2] <- newCost2\n        \n        prevDp <- currentDp\n    \n    if prevDp.Count > 0 then\n        prevDp.Values |> Seq.min\n    else\n        0\nopen System\nopen System.Diagnostics\n\nmodule TestPaintingProblem =\n    let checkPaintingProblem() =\n        Debug.Assert(solvePaintingProblem [|1; 2; 3; 4|] = 4)\n        Debug.Assert(solvePaintingProblem [|1; 1; 1; 1|] = 1)\n        Debug.Assert(solvePaintingProblem [|1; 2; 1; 2|] = 2)\n        Debug.Assert(solvePaintingProblem [|1; 2; 3; 1; 2; 3|] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestPaintingProblem.checkPaintingProblem()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// sieve generates a list of prime numbers up to maxN using the Sieve of Eratosthenes algorithm.\n// The function returns an array of integers representing the prime numbers.\nlet sieve maxN =\n    let isPrime = Array.create (maxN + 1) true\n    isPrime.[0] <- false\n    isPrime.[1] <- false\n    for current in 2 .. (int (Math.Sqrt(float maxN))) do\n        if isPrime.[current] then\n            for multiple in current * current .. current .. maxN do\n                isPrime.[multiple] <- false\n    [| for i in 0 .. maxN do if isPrime.[i] then yield i |]\n\n// maxDivisors calculates the maximum number of divisors for any number p^e where p is a prime number,\n// p^e <= n, and e is the maximum exponent such that p^e <= n.\n// The function returns the maximum number of divisors found.\nlet maxDivisors n (primes: int array) =\n    let mutable maxDivs = 0\n    for p in primes do\n        let mutable current = p\n        let mutable eMax = 0\n        while current <= n do\n            eMax <- eMax + 1\n            current <- current * p\n        eMax <- eMax - 1\n        let current = pown p eMax\n        let divisors = eMax + 1\n        if divisors > maxDivs then\n            maxDivs <- divisors\n    maxDivs", "test_cases": "", "test_case_results": "Input n: 10\nPrimes up to 10: [|2; 3; 5; 7|]\nMaximum number of divisors: 3\nInput n: 20\nPrimes up to 20: [|2; 3; 5; 7; 11; 13; 17; 19|]\nMaximum number of divisors: 4\nInput n: 30\nPrimes up to 30: [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29|]\nMaximum number of divisors: 4\nInput n: 50\nPrimes up to 50: [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47|]\nMaximum number of divisors: 5", "task_id": 6746, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSieveAndDivisors =\n    let runTests() =\n        // Test case 1\n        let primes10 = sieve 10\n        Debug.Assert(primes10 = [|2; 3; 5; 7|], \"Primes up to 10 failed\")\n        Debug.Assert(maxDivisors 10 primes10 = 3, \"Max divisors for 10 failed\")\n\n        // Test case 2\n        let primes20 = sieve 20\n        Debug.Assert(primes20 = [|2; 3; 5; 7; 11; 13; 17; 19|], \"Primes up to 20 failed\")\n        Debug.Assert(maxDivisors 20 primes20 = 4, \"Max divisors for 20 failed\")\n\n        // Test case 3\n        let primes30 = sieve 30\n        Debug.Assert(primes30 = [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29|], \"Primes up to 30 failed\")\n        Debug.Assert(maxDivisors 30 primes30 = 4, \"Max divisors for 30 failed\")\n\n        // Test case 4\n        let primes50 = sieve 50\n        Debug.Assert(primes50 = [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47|], \"Primes up to 50 failed\")\n        Debug.Assert(maxDivisors 50 primes50 = 5, \"Max divisors for 50 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestSieveAndDivisors.runTests()\n    0", "all_code": "open System\n\n// sieve generates a list of prime numbers up to maxN using the Sieve of Eratosthenes algorithm.\n// The function returns an array of integers representing the prime numbers.\nlet sieve maxN =\n    let isPrime = Array.create (maxN + 1) true\n    isPrime.[0] <- false\n    isPrime.[1] <- false\n    for current in 2 .. (int (Math.Sqrt(float maxN))) do\n        if isPrime.[current] then\n            for multiple in current * current .. current .. maxN do\n                isPrime.[multiple] <- false\n    [| for i in 0 .. maxN do if isPrime.[i] then yield i |]\n\n// maxDivisors calculates the maximum number of divisors for any number p^e where p is a prime number,\n// p^e <= n, and e is the maximum exponent such that p^e <= n.\n// The function returns the maximum number of divisors found.\nlet maxDivisors n (primes: int array) =\n    let mutable maxDivs = 0\n    for p in primes do\n        let mutable current = p\n        let mutable eMax = 0\n        while current <= n do\n            eMax <- eMax + 1\n            current <- current * p\n        eMax <- eMax - 1\n        let current = pown p eMax\n        let divisors = eMax + 1\n        if divisors > maxDivs then\n            maxDivs <- divisors\n    maxDivs\nopen System\nopen System.Diagnostics\n\nmodule TestSieveAndDivisors =\n    let runTests() =\n        // Test case 1\n        let primes10 = sieve 10\n        Debug.Assert(primes10 = [|2; 3; 5; 7|], \"Primes up to 10 failed\")\n        Debug.Assert(maxDivisors 10 primes10 = 3, \"Max divisors for 10 failed\")\n\n        // Test case 2\n        let primes20 = sieve 20\n        Debug.Assert(primes20 = [|2; 3; 5; 7; 11; 13; 17; 19|], \"Primes up to 20 failed\")\n        Debug.Assert(maxDivisors 20 primes20 = 4, \"Max divisors for 20 failed\")\n\n        // Test case 3\n        let primes30 = sieve 30\n        Debug.Assert(primes30 = [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29|], \"Primes up to 30 failed\")\n        Debug.Assert(maxDivisors 30 primes30 = 4, \"Max divisors for 30 failed\")\n\n        // Test case 4\n        let primes50 = sieve 50\n        Debug.Assert(primes50 = [|2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47|], \"Primes up to 50 failed\")\n        Debug.Assert(maxDivisors 50 primes50 = 5, \"Max divisors for 50 failed\")\n\n[<EntryPoint>]\nlet main argv =\n    TestSieveAndDivisors.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// solveCase determines if it's possible to distribute 'n' elements into 'k' groups\n// such that each group has either 'm' or 'm + 1' elements, where 'm = n / k',\n// and the number of odd and even elements meet certain conditions.\nlet solveCase (n: int) (k: int) : string =\n    if k = 1 then\n        if n = 1 then \"Yes\" else \"No\"\n    else\n        let m = n / k\n        let totalOdd = (n + 1) / 2\n        let totalEven = n / 2\n        let lower = (totalOdd + (m + 1) - 1) / (m + 1)\n        let upper = k - ((totalEven + (m + 1) - 1) / (m + 1))\n        if lower <= upper && lower >= 0 && upper <= k then \"Yes\" else \"No\"", "test_cases": "", "test_case_results": "Input: n = 1, k = 1\nResult: Yes\n\nInput: n = 2, k = 1\nResult: No\n\nInput: n = 5, k = 2\nResult: Yes\n\nInput: n = 10, k = 3\nResult: No\n\nInput: n = 7, k = 4\nResult: Yes", "task_id": 18775, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSolveCase =\n    let runTests() =\n        Debug.Assert(solveCase 1 1 = \"Yes\")\n        Debug.Assert(solveCase 2 1 = \"No\")\n        Debug.Assert(solveCase 5 2 = \"Yes\")\n        Debug.Assert(solveCase 10 3 = \"No\")\n        Debug.Assert(solveCase 7 4 = \"Yes\")\n\n[<EntryPoint>]\nlet main argv =\n    TestSolveCase.runTests()\n    0", "all_code": "open System\n\n// solveCase determines if it's possible to distribute 'n' elements into 'k' groups\n// such that each group has either 'm' or 'm + 1' elements, where 'm = n / k',\n// and the number of odd and even elements meet certain conditions.\nlet solveCase (n: int) (k: int) : string =\n    if k = 1 then\n        if n = 1 then \"Yes\" else \"No\"\n    else\n        let m = n / k\n        let totalOdd = (n + 1) / 2\n        let totalEven = n / 2\n        let lower = (totalOdd + (m + 1) - 1) / (m + 1)\n        let upper = k - ((totalEven + (m + 1) - 1) / (m + 1))\n        if lower <= upper && lower >= 0 && upper <= k then \"Yes\" else \"No\"\nopen System\nopen System.Diagnostics\n\nmodule TestSolveCase =\n    let runTests() =\n        Debug.Assert(solveCase 1 1 = \"Yes\")\n        Debug.Assert(solveCase 2 1 = \"No\")\n        Debug.Assert(solveCase 5 2 = \"Yes\")\n        Debug.Assert(solveCase 10 3 = \"No\")\n        Debug.Assert(solveCase 7 4 = \"Yes\")\n\n[<EntryPoint>]\nlet main argv =\n    TestSolveCase.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Text.Json\n\n// generateServerConfigurations generates a JSON string containing configurations for a set of servers.\n// Each server is represented as a dictionary with details including ID, IP address, port, and a list of services.\nlet generateServerConfigurations (servers: Map<string, obj> list) =\n    JsonSerializer.Serialize(servers, JsonSerializerOptions(WriteIndented = true))", "test_cases": "", "test_case_results": "Input: [map\n   [(\"ID\", \"Server1\"); (\"IP\", \"192.168.1.1\"); (\"Port\", 8080);\n    (\"Services\", [\"Web\"; \"Database\"])]]\n[\n  {\n    \"ID\": \"Server1\",\n    \"IP\": \"192.168.1.1\",\n    \"Port\": 8080,\n    \"Services\": [\n      \"Web\",\n      \"Database\"\n    ]\n  }\n]\nInput: [map\n   [(\"ID\", \"Server2\"); (\"IP\", \"192.168.1.2\"); (\"Port\", 8081);\n    (\"Services\", [\"API\"; \"Cache\"])];\n map\n   [(\"ID\", \"Server3\"); (\"IP\", \"192.168.1.3\"); (\"Port\", 8082);\n    (\"Services\", [\"Auth\"; \"Logging\"])]]\n[\n  {\n    \"ID\": \"Server2\",\n    \"IP\": \"192.168.1.2\",\n    \"Port\": 8081,\n    \"Services\": [\n      \"API\",\n      \"Cache\"\n    ]\n  },\n  {\n    \"ID\": \"Server3\",\n    \"IP\": \"192.168.1.3\",\n    \"Port\": 8082,\n    \"Services\": [\n      \"Auth\",\n      \"Logging\"\n    ]\n  }\n]", "task_id": 13209, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestServerConfigurations =\n    let checkGenerateServerConfigurations() =\n        let testCase1 = [\n            Map [\n                (\"ID\", box \"Server1\")\n                (\"IP\", box \"192.168.1.1\")\n                (\"Port\", box 8080)\n                (\"Services\", box [\"Web\"; \"Database\"])\n            ]\n        ]\n        let expected1 = \"\"\"[\n  {\n    \"ID\": \"Server1\",\n    \"IP\": \"192.168.1.1\",\n    \"Port\": 8080,\n    \"Services\": [\n      \"Web\",\n      \"Database\"\n    ]\n  }\n]\"\"\"\n        Debug.Assert(generateServerConfigurations testCase1 = expected1)\n\n        let testCase2 = [\n            Map [\n                (\"ID\", box \"Server2\")\n                (\"IP\", box \"192.168.1.2\")\n                (\"Port\", box 8081)\n                (\"Services\", box [\"API\"; \"Cache\"])\n            ]\n            Map [\n                (\"ID\", box \"Server3\")\n                (\"IP\", box \"192.168.1.3\")\n                (\"Port\", box 8082)\n                (\"Services\", box [\"Auth\"; \"Logging\"])\n            ]\n        ]\n        let expected2 = \"\"\"[\n  {\n    \"ID\": \"Server2\",\n    \"IP\": \"192.168.1.2\",\n    \"Port\": 8081,\n    \"Services\": [\n      \"API\",\n      \"Cache\"\n    ]\n  },\n  {\n    \"ID\": \"Server3\",\n    \"IP\": \"192.168.1.3\",\n    \"Port\": 8082,\n    \"Services\": [\n      \"Auth\",\n      \"Logging\"\n    ]\n  }\n]\"\"\"\n        Debug.Assert(generateServerConfigurations testCase2 = expected2)\n\n[<EntryPoint>]\nlet main argv =\n    TestServerConfigurations.checkGenerateServerConfigurations()\n    0", "all_code": "open System.Text.Json\n\n// generateServerConfigurations generates a JSON string containing configurations for a set of servers.\n// Each server is represented as a dictionary with details including ID, IP address, port, and a list of services.\nlet generateServerConfigurations (servers: Map<string, obj> list) =\n    JsonSerializer.Serialize(servers, JsonSerializerOptions(WriteIndented = true))\nopen System\nopen System.Diagnostics\n\nmodule TestServerConfigurations =\n    let checkGenerateServerConfigurations() =\n        let testCase1 = [\n            Map [\n                (\"ID\", box \"Server1\")\n                (\"IP\", box \"192.168.1.1\")\n                (\"Port\", box 8080)\n                (\"Services\", box [\"Web\"; \"Database\"])\n            ]\n        ]\n        let expected1 = \"\"\"[\n  {\n    \"ID\": \"Server1\",\n    \"IP\": \"192.168.1.1\",\n    \"Port\": 8080,\n    \"Services\": [\n      \"Web\",\n      \"Database\"\n    ]\n  }\n]\"\"\"\n        Debug.Assert(generateServerConfigurations testCase1 = expected1)\n\n        let testCase2 = [\n            Map [\n                (\"ID\", box \"Server2\")\n                (\"IP\", box \"192.168.1.2\")\n                (\"Port\", box 8081)\n                (\"Services\", box [\"API\"; \"Cache\"])\n            ]\n            Map [\n                (\"ID\", box \"Server3\")\n                (\"IP\", box \"192.168.1.3\")\n                (\"Port\", box 8082)\n                (\"Services\", box [\"Auth\"; \"Logging\"])\n            ]\n        ]\n        let expected2 = \"\"\"[\n  {\n    \"ID\": \"Server2\",\n    \"IP\": \"192.168.1.2\",\n    \"Port\": 8081,\n    \"Services\": [\n      \"API\",\n      \"Cache\"\n    ]\n  },\n  {\n    \"ID\": \"Server3\",\n    \"IP\": \"192.168.1.3\",\n    \"Port\": 8082,\n    \"Services\": [\n      \"Auth\",\n      \"Logging\"\n    ]\n  }\n]\"\"\"\n        Debug.Assert(generateServerConfigurations testCase2 = expected2)\n\n[<EntryPoint>]\nlet main argv =\n    TestServerConfigurations.checkGenerateServerConfigurations()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\n// findMaxScore calculates the maximum score achievable in a game with n levels,\n// where you can move between levels using steps defined in array 'a',\n// and each level 'x' gives a score increment defined by array 'b'.\n// The game starts at level 0 with score 0.\nlet findMaxScore (n: int) (m: int) (a: int array) (b: int array) =\n    let mutable maxScore = Int32.MinValue\n    let dp = Array.create n Int32.MinValue\n    dp.[0] <- 0  // Starting at level 0 with 0 score\n    \n    let inQueue = Array.create n false\n    let queue = Queue<int>()\n    queue.Enqueue(0)\n    inQueue.[0] <- true\n    \n    while queue.Count > 0 do\n        let x = queue.Dequeue()\n        inQueue.[x] <- false\n        \n        let currentScore = dp.[x]\n        let s = currentScore + b.[x]\n        \n        for ai in a do\n            let y = x + ai\n            if y >= n then\n                if s > maxScore then\n                    maxScore <- s\n            else\n                if s > dp.[y] then\n                    dp.[y] <- s\n                    if not inQueue.[y] then\n                        queue.Enqueue(y)\n                        inQueue.[y] <- true\n    \n    maxScore", "test_cases": "", "test_case_results": "Test case: n=5, m=2, a=[|1; 2|], b=[|0; 1; 2; 3; 4|]\nMaximum score: 10\n\nTest case: n=3, m=3, a=[|1; 2; 3|], b=[|10; -5; 20|]\nMaximum score: 30\n\nTest case: n=4, m=1, a=[|2|], b=[|1; 1; 1; 1|]\nMaximum score: 2\n\nTest case: n=1, m=1, a=[|1|], b=[|100|]\nMaximum score: 100", "task_id": 29651, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestFindMaxScore =\n    let runTests() =\n        // Test case 1: Simple increasing scores\n        Debug.Assert(findMaxScore 5 2 [|1; 2|] [|0; 1; 2; 3; 4|] = 10)\n        \n        // Test case 2: Mixed positive and negative scores\n        Debug.Assert(findMaxScore 3 3 [|1; 2; 3|] [|10; -5; 20|] = 30)\n        \n        // Test case 3: Only even steps possible\n        Debug.Assert(findMaxScore 4 1 [|2|] [|1; 1; 1; 1|] = 2)\n        \n        // Test case 4: Single level case\n        Debug.Assert(findMaxScore 1 1 [|1|] [|100|] = 100)\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMaxScore.runTests()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\n// findMaxScore calculates the maximum score achievable in a game with n levels,\n// where you can move between levels using steps defined in array 'a',\n// and each level 'x' gives a score increment defined by array 'b'.\n// The game starts at level 0 with score 0.\nlet findMaxScore (n: int) (m: int) (a: int array) (b: int array) =\n    let mutable maxScore = Int32.MinValue\n    let dp = Array.create n Int32.MinValue\n    dp.[0] <- 0  // Starting at level 0 with 0 score\n    \n    let inQueue = Array.create n false\n    let queue = Queue<int>()\n    queue.Enqueue(0)\n    inQueue.[0] <- true\n    \n    while queue.Count > 0 do\n        let x = queue.Dequeue()\n        inQueue.[x] <- false\n        \n        let currentScore = dp.[x]\n        let s = currentScore + b.[x]\n        \n        for ai in a do\n            let y = x + ai\n            if y >= n then\n                if s > maxScore then\n                    maxScore <- s\n            else\n                if s > dp.[y] then\n                    dp.[y] <- s\n                    if not inQueue.[y] then\n                        queue.Enqueue(y)\n                        inQueue.[y] <- true\n    \n    maxScore\nopen System\nopen System.Diagnostics\n\nmodule TestFindMaxScore =\n    let runTests() =\n        // Test case 1: Simple increasing scores\n        Debug.Assert(findMaxScore 5 2 [|1; 2|] [|0; 1; 2; 3; 4|] = 10)\n        \n        // Test case 2: Mixed positive and negative scores\n        Debug.Assert(findMaxScore 3 3 [|1; 2; 3|] [|10; -5; 20|] = 30)\n        \n        // Test case 3: Only even steps possible\n        Debug.Assert(findMaxScore 4 1 [|2|] [|1; 1; 1; 1|] = 2)\n        \n        // Test case 4: Single level case\n        Debug.Assert(findMaxScore 1 1 [|1|] [|100|] = 100)\n\n[<EntryPoint>]\nlet main argv =\n    TestFindMaxScore.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nlet reverseWordsPreserveSpaces (s: string) =\n    let words = s.Split([|' '|], StringSplitOptions.None)\n    let reversedWords = words |> Array.map (fun word -> new string(word.ToCharArray() |> Array.rev))\n    String.Join(\" \", reversedWords)", "test_cases": "", "test_case_results": "Input: \"hello world\"\nResult: \"olleh dlrow\"\n\nInput: \"this is a test\"\nResult: \"siht si a tset\"\n\nInput: \" F# is fun \"\nResult: \" #F si nuf \"\n\nInput: \"\"\nResult: \"\"\n\nInput: \" \"\nResult: \" \"", "task_id": 13988, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestReverseWords =\n    let checkReverseWordsPreserveSpaces() =\n        Debug.Assert(reverseWordsPreserveSpaces \"hello world\" = \"olleh dlrow\")\n        Debug.Assert(reverseWordsPreserveSpaces \"this is a test\" = \"siht si a tset\")\n        Debug.Assert(reverseWordsPreserveSpaces \" F# is fun \" = \" #F si nuf \")\n        Debug.Assert(reverseWordsPreserveSpaces \"\" = \"\")\n        Debug.Assert(reverseWordsPreserveSpaces \" \" = \" \")\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseWords.checkReverseWordsPreserveSpaces()\n    0", "all_code": "open System\n\nlet reverseWordsPreserveSpaces (s: string) =\n    let words = s.Split([|' '|], StringSplitOptions.None)\n    let reversedWords = words |> Array.map (fun word -> new string(word.ToCharArray() |> Array.rev))\n    String.Join(\" \", reversedWords)\nopen System\nopen System.Diagnostics\n\nmodule TestReverseWords =\n    let checkReverseWordsPreserveSpaces() =\n        Debug.Assert(reverseWordsPreserveSpaces \"hello world\" = \"olleh dlrow\")\n        Debug.Assert(reverseWordsPreserveSpaces \"this is a test\" = \"siht si a tset\")\n        Debug.Assert(reverseWordsPreserveSpaces \" F# is fun \" = \" #F si nuf \")\n        Debug.Assert(reverseWordsPreserveSpaces \"\" = \"\")\n        Debug.Assert(reverseWordsPreserveSpaces \" \" = \" \")\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseWords.checkReverseWordsPreserveSpaces()\n    0", "exec_outcome": "PASSED"}
{"code": "open System.Collections.Generic\n\nlet lengthOfLongestSubstring (s: string) =\n    let mutable start = 0  // starting index of the sliding window\n    let seen = HashSet<char>()  // set to keep track of unique characters in the window\n    let mutable maxLength = 0  // maximum length of substring without repeating characters\n\n    for i in 0 .. s.Length - 1 do\n        while seen.Contains(s.[i]) do\n            seen.Remove(s.[start]) |> ignore  // remove characters from the set until duplicate is removed\n            start <- start + 1  // move start to the right\n        seen.Add(s.[i]) |> ignore  // add the current character to the set\n        maxLength <- max maxLength (i - start + 1)  // update maxLength if needed\n\n    maxLength", "test_cases": "", "test_case_results": "Input: \"abcabcbb\"\nLength of longest substring without repeating characters: 3\nInput: \"bbbbb\"\nLength of longest substring without repeating characters: 1\nInput: \"pwwkew\"\nLength of longest substring without repeating characters: 3\nInput: \"\"\nLength of longest substring without repeating characters: 0\nInput: \"aab\"\nLength of longest substring without repeating characters: 2\nInput: \"dvdf\"\nLength of longest substring without repeating characters: 3", "task_id": 10210, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestLongestSubstring =\n    let checkLengthOfLongestSubstring() =\n        Debug.Assert(lengthOfLongestSubstring \"abcabcbb\" = 3)\n        Debug.Assert(lengthOfLongestSubstring \"bbbbb\" = 1)\n        Debug.Assert(lengthOfLongestSubstring \"pwwkew\" = 3)\n        Debug.Assert(lengthOfLongestSubstring \"\" = 0)\n        Debug.Assert(lengthOfLongestSubstring \"aab\" = 2)\n        Debug.Assert(lengthOfLongestSubstring \"dvdf\" = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestLongestSubstring.checkLengthOfLongestSubstring()\n    0", "all_code": "open System.Collections.Generic\n\nlet lengthOfLongestSubstring (s: string) =\n    let mutable start = 0  // starting index of the sliding window\n    let seen = HashSet<char>()  // set to keep track of unique characters in the window\n    let mutable maxLength = 0  // maximum length of substring without repeating characters\n\n    for i in 0 .. s.Length - 1 do\n        while seen.Contains(s.[i]) do\n            seen.Remove(s.[start]) |> ignore  // remove characters from the set until duplicate is removed\n            start <- start + 1  // move start to the right\n        seen.Add(s.[i]) |> ignore  // add the current character to the set\n        maxLength <- max maxLength (i - start + 1)  // update maxLength if needed\n\n    maxLength\nopen System\nopen System.Diagnostics\n\nmodule TestLongestSubstring =\n    let checkLengthOfLongestSubstring() =\n        Debug.Assert(lengthOfLongestSubstring \"abcabcbb\" = 3)\n        Debug.Assert(lengthOfLongestSubstring \"bbbbb\" = 1)\n        Debug.Assert(lengthOfLongestSubstring \"pwwkew\" = 3)\n        Debug.Assert(lengthOfLongestSubstring \"\" = 0)\n        Debug.Assert(lengthOfLongestSubstring \"aab\" = 2)\n        Debug.Assert(lengthOfLongestSubstring \"dvdf\" = 3)\n\n[<EntryPoint>]\nlet main argv =\n    TestLongestSubstring.checkLengthOfLongestSubstring()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// rollDiceAndTrack simulates rolling two dice a specified number of times and tracks the frequency of each possible total (2-12).\n// numRolls: The number of times to roll the two dice. Must be a positive integer.\n// Returns a map (dictionary) of totals to their frequencies.\nlet rollDiceAndTrack (numRolls: int) =\n    if numRolls <= 0 then\n        raise (ArgumentException(\"numRolls must be a positive integer.\"))\n    \n    let frequency = [| for _ in 2..12 -> 0 |] // Index 0 corresponds to total 2, index 10 to total 12.\n    let rnd = Random()\n    \n    for i in 1..numRolls do\n        let die1 = rnd.Next(1, 7)\n        let die2 = rnd.Next(1, 7)\n        let total = die1 + die2\n        frequency.[total - 2] <- frequency.[total - 2] + 1\n        \n        printfn \"Roll %d: (%d, %d), Total: %d\" i die1 die2 total\n    \n    printfn \"\\nFrequency of Totals After %d Rolls:\" numRolls\n    for total in 2..12 do\n        printfn \"%d: %d\" total frequency.[total - 2]\n    \n    frequency", "test_cases": "", "test_case_results": "Testing with numRolls = 10\nRoll 1: (2, 5), Total: 7\nRoll 2: (4, 1), Total: 5\nRoll 3: (2, 5), Total: 7\nRoll 4: (6, 6), Total: 12\nRoll 5: (3, 2), Total: 5\nRoll 6: (3, 3), Total: 6\nRoll 7: (3, 5), Total: 8\nRoll 8: (4, 5), Total: 9\nRoll 9: (4, 3), Total: 7\nRoll 10: (3, 1), Total: 4\n\nFrequency of Totals After 10 Rolls:\n2: 0\n3: 0\n4: 1\n5: 2\n6: 1\n7: 3\n8: 1\n9: 1\n10: 0\n11: 0\n12: 1\n\nTesting with numRolls = 20\nRoll 1: (1, 5), Total: 6\nRoll 2: (3, 4), Total: 7\nRoll 3: (1, 5), Total: 6\nRoll 4: (4, 5), Total: 9\nRoll 5: (2, 6), Total: 8\nRoll 6: (6, 2), Total: 8\nRoll 7: (4, 3), Total: 7\nRoll 8: (2, 6), Total: 8\nRoll 9: (5, 2), Total: 7\nRoll 10: (1, 4), Total: 5\nRoll 11: (6, 2), Total: 8\nRoll 12: (2, 1), Total: 3\nRoll 13: (4, 3), Total: 7\nRoll 14: (3, 5), Total: 8\nRoll 15: (1, 5), Total: 6\nRoll 16: (6, 4), Total: 10\nRoll 17: (2, 2), Total: 4\nRoll 18: (6, 1), Total: 7\nRoll 19: (2, 6), Total: 8\nRoll 20: (6, 4), Total: 10\n\nFrequency of Totals After 20 Rolls:\n2: 0\n3: 1\n4: 1\n5: 1\n6: 3\n7: 5\n8: 6\n9: 1\n10: 2\n11: 0\n12: 0\n\nTesting with numRolls = 50\nRoll 1: (2, 2), Total: 4\nRoll 2: (2, 5), Total: 7\nRoll 3: (6, 6), Total: 12\nRoll 4: (5, 3), Total: 8\nRoll 5: (3, 5), Total: 8\nRoll 6: (5, 6), Total: 11\nRoll 7: (2, 5), Total: 7\nRoll 8: (5, 2), Total: 7\nRoll 9: (2, 5), Total: 7\nRoll 10: (3, 5), Total: 8\nRoll 11: (4, 4), Total: 8\nRoll 12: (4, 1), Total: 5\nRoll 13: (6, 2), Total: 8\nRoll 14: (2, 3), Total: 5\nRoll 15: (4, 5), Total: 9\nRoll 16: (3, 5), Total: 8\nRoll 17: (1, 1), Total: 2\nRoll 18: (4, 5), Total: 9\nRoll 19: (5, 6), Total: 11\nRoll 20: (5, 3), Total: 8\nRoll 21: (6, 4), Total: 10\nRoll 22: (2, 2), Total: 4\nRoll 23: (1, 3), Total: 4\nRoll 24: (2, 4), Total: 6\nRoll 25: (6, 2), Total: 8\nRoll 26: (1, 3), Total: 4\nRoll 27: (3, 4), Total: 7\nRoll 28: (1, 6), Total: 7\nRoll 29: (4, 2), Total: 6\nRoll 30: (5, 3), Total: 8\nRoll 31: (5, 2), Total: 7\nRoll 32: (1, 3), Total: 4\nRoll 33: (6, 2), Total: 8\nRoll 34: (6, 3), Total: 9\nRoll 35: (3, 4), Total: 7\nRoll 36: (2, 3), Total: 5\nRoll 37: (3, 5), Total: 8\nRoll 38: (6, 1), Total: 7\nRoll 39: (2, 3), Total: 5", "task_id": 27622, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestDiceRolls =\n    let testRollDiceAndTrack() =\n        // Since the function uses random numbers, we can't test exact values\n        // Instead we'll test some basic properties of the results\n        \n        // Test with 10 rolls\n        let result10 = rollDiceAndTrack 10\n        Debug.Assert(Array.sum result10 = 10)\n        Debug.Assert(result10.Length = 11) // 2-12 totals\n        \n        // Test with 20 rolls\n        let result20 = rollDiceAndTrack 20\n        Debug.Assert(Array.sum result20 = 20)\n        Debug.Assert(result20.Length = 11)\n        \n        // Test with 50 rolls\n        let result50 = rollDiceAndTrack 50\n        Debug.Assert(Array.sum result50 = 50)\n        Debug.Assert(result50.Length = 11)\n        \n        // Test exception for invalid input\n        try\n            rollDiceAndTrack 0 |> ignore\n            Debug.Assert(false, \"Should have thrown exception for numRolls <= 0\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n\n[<EntryPoint>]\nlet main argv =\n    TestDiceRolls.testRollDiceAndTrack()\n    0", "all_code": "open System\n\n// rollDiceAndTrack simulates rolling two dice a specified number of times and tracks the frequency of each possible total (2-12).\n// numRolls: The number of times to roll the two dice. Must be a positive integer.\n// Returns a map (dictionary) of totals to their frequencies.\nlet rollDiceAndTrack (numRolls: int) =\n    if numRolls <= 0 then\n        raise (ArgumentException(\"numRolls must be a positive integer.\"))\n    \n    let frequency = [| for _ in 2..12 -> 0 |] // Index 0 corresponds to total 2, index 10 to total 12.\n    let rnd = Random()\n    \n    for i in 1..numRolls do\n        let die1 = rnd.Next(1, 7)\n        let die2 = rnd.Next(1, 7)\n        let total = die1 + die2\n        frequency.[total - 2] <- frequency.[total - 2] + 1\n        \n        printfn \"Roll %d: (%d, %d), Total: %d\" i die1 die2 total\n    \n    printfn \"\\nFrequency of Totals After %d Rolls:\" numRolls\n    for total in 2..12 do\n        printfn \"%d: %d\" total frequency.[total - 2]\n    \n    frequency\nopen System\nopen System.Diagnostics\n\nmodule TestDiceRolls =\n    let testRollDiceAndTrack() =\n        // Since the function uses random numbers, we can't test exact values\n        // Instead we'll test some basic properties of the results\n        \n        // Test with 10 rolls\n        let result10 = rollDiceAndTrack 10\n        Debug.Assert(Array.sum result10 = 10)\n        Debug.Assert(result10.Length = 11) // 2-12 totals\n        \n        // Test with 20 rolls\n        let result20 = rollDiceAndTrack 20\n        Debug.Assert(Array.sum result20 = 20)\n        Debug.Assert(result20.Length = 11)\n        \n        // Test with 50 rolls\n        let result50 = rollDiceAndTrack 50\n        Debug.Assert(Array.sum result50 = 50)\n        Debug.Assert(result50.Length = 11)\n        \n        // Test exception for invalid input\n        try\n            rollDiceAndTrack 0 |> ignore\n            Debug.Assert(false, \"Should have thrown exception for numRolls <= 0\")\n        with\n        | :? ArgumentException -> Debug.Assert(true)\n        | _ -> Debug.Assert(false, \"Wrong exception type thrown\")\n\n[<EntryPoint>]\nlet main argv =\n    TestDiceRolls.testRollDiceAndTrack()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// longestCommonPrefix finds the longest common prefix among a list of strings.\n// If the input list is empty, it returns an empty string.\nlet longestCommonPrefix (words: string list) =\n    if List.isEmpty words then\n        \"\"\n    else\n        // Sort the words to easily compare the smallest and largest\n        let sortedWords = List.sort words\n        let firstWord = List.head sortedWords\n        let lastWord = List.last sortedWords\n        let mutable commonPrefixLength = 0\n\n        while (commonPrefixLength < firstWord.Length && \n               commonPrefixLength < lastWord.Length && \n               firstWord.[commonPrefixLength] = lastWord.[commonPrefixLength]) do\n            commonPrefixLength <- commonPrefixLength + 1\n        \n        firstWord.[0..commonPrefixLength - 1]", "test_cases": "", "test_case_results": "Input: [\"flower\"; \"flow\"; \"flight\"]\nLongest Common Prefix: \"fl\"\nInput: [\"dog\"; \"racecar\"; \"car\"]\nLongest Common Prefix: \"\"\nInput: [\"interspecies\"; \"interstellar\"; \"interstate\"]\nLongest Common Prefix: \"inters\"\nInput: []\nLongest Common Prefix: \"\"\nInput: [\"single\"]\nLongest Common Prefix: \"single\"", "task_id": 8331, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestLongestCommonPrefix =\n    let checkLongestCommonPrefix() =\n        Debug.Assert(longestCommonPrefix [\"flower\"; \"flow\"; \"flight\"] = \"fl\")\n        Debug.Assert(longestCommonPrefix [\"dog\"; \"racecar\"; \"car\"] = \"\")\n        Debug.Assert(longestCommonPrefix [\"interspecies\"; \"interstellar\"; \"interstate\"] = \"inters\")\n        Debug.Assert(longestCommonPrefix [] = \"\")\n        Debug.Assert(longestCommonPrefix [\"single\"] = \"single\")\n\n[<EntryPoint>]\nlet main argv =\n    TestLongestCommonPrefix.checkLongestCommonPrefix()\n    0", "all_code": "open System\n\n// longestCommonPrefix finds the longest common prefix among a list of strings.\n// If the input list is empty, it returns an empty string.\nlet longestCommonPrefix (words: string list) =\n    if List.isEmpty words then\n        \"\"\n    else\n        // Sort the words to easily compare the smallest and largest\n        let sortedWords = List.sort words\n        let firstWord = List.head sortedWords\n        let lastWord = List.last sortedWords\n        let mutable commonPrefixLength = 0\n\n        while (commonPrefixLength < firstWord.Length && \n               commonPrefixLength < lastWord.Length && \n               firstWord.[commonPrefixLength] = lastWord.[commonPrefixLength]) do\n            commonPrefixLength <- commonPrefixLength + 1\n        \n        firstWord.[0..commonPrefixLength - 1]\nopen System\nopen System.Diagnostics\n\nmodule TestLongestCommonPrefix =\n    let checkLongestCommonPrefix() =\n        Debug.Assert(longestCommonPrefix [\"flower\"; \"flow\"; \"flight\"] = \"fl\")\n        Debug.Assert(longestCommonPrefix [\"dog\"; \"racecar\"; \"car\"] = \"\")\n        Debug.Assert(longestCommonPrefix [\"interspecies\"; \"interstellar\"; \"interstate\"] = \"inters\")\n        Debug.Assert(longestCommonPrefix [] = \"\")\n        Debug.Assert(longestCommonPrefix [\"single\"] = \"single\")\n\n[<EntryPoint>]\nlet main argv =\n    TestLongestCommonPrefix.checkLongestCommonPrefix()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nlet addStrings (num1: string) (num2: string) =\n    let result = System.Collections.Generic.List<string>()\n    let mutable carry = 0\n\n    // Reverse both strings to process from least significant digit to most significant digit\n    let num1Reversed = num1.ToCharArray() |> Array.rev\n    let num2Reversed = num2.ToCharArray() |> Array.rev\n\n    // Find the maximum length of the two numbers\n    let maxLen = max num1Reversed.Length num2Reversed.Length\n\n    for i in 0 .. maxLen - 1 do\n        // Get the current digit of each number, or 0 if the number is shorter\n        let digit1 = if i < num1Reversed.Length then int(num1Reversed.[i].ToString()) else 0\n        let digit2 = if i < num2Reversed.Length then int(num2Reversed.[i].ToString()) else 0\n\n        // Calculate the sum of the digits plus the carry\n        let currentSum = digit1 + digit2 + carry\n        carry <- currentSum / 10  // Calculate the carry for the next column\n        result.Add((currentSum % 10).ToString())  // Append the current digit result\n\n    // If there is any carry left at the end, append it to the result\n    if carry > 0 then\n        result.Add(carry.ToString())\n\n    // Reverse the result to get the final sum and join into a single string\n    let resultArray = result |> Seq.toArray |> Array.rev\n    String.Join(\"\", resultArray)", "test_cases": "", "test_case_results": "Input: num1 = 123, num2 = 456\nSum: 579\n\nInput: num1 = 999, num2 = 1\nSum: 1000\n\nInput: num1 = 0, num2 = 0\nSum: 0\n\nInput: num1 = 1000, num2 = 1\nSum: 1001\n\nInput: num1 = 999999, num2 = 1\nSum: 1000000", "task_id": 20581, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestAddStrings =\n    let checkAddStrings() =\n        Debug.Assert(addStrings \"123\" \"456\" = \"579\")\n        Debug.Assert(addStrings \"999\" \"1\" = \"1000\")\n        Debug.Assert(addStrings \"0\" \"0\" = \"0\")\n        Debug.Assert(addStrings \"1000\" \"1\" = \"1001\")\n        Debug.Assert(addStrings \"999999\" \"1\" = \"1000000\")\n\n[<EntryPoint>]\nlet main argv =\n    TestAddStrings.checkAddStrings()\n    0", "all_code": "open System\n\nlet addStrings (num1: string) (num2: string) =\n    let result = System.Collections.Generic.List<string>()\n    let mutable carry = 0\n\n    // Reverse both strings to process from least significant digit to most significant digit\n    let num1Reversed = num1.ToCharArray() |> Array.rev\n    let num2Reversed = num2.ToCharArray() |> Array.rev\n\n    // Find the maximum length of the two numbers\n    let maxLen = max num1Reversed.Length num2Reversed.Length\n\n    for i in 0 .. maxLen - 1 do\n        // Get the current digit of each number, or 0 if the number is shorter\n        let digit1 = if i < num1Reversed.Length then int(num1Reversed.[i].ToString()) else 0\n        let digit2 = if i < num2Reversed.Length then int(num2Reversed.[i].ToString()) else 0\n\n        // Calculate the sum of the digits plus the carry\n        let currentSum = digit1 + digit2 + carry\n        carry <- currentSum / 10  // Calculate the carry for the next column\n        result.Add((currentSum % 10).ToString())  // Append the current digit result\n\n    // If there is any carry left at the end, append it to the result\n    if carry > 0 then\n        result.Add(carry.ToString())\n\n    // Reverse the result to get the final sum and join into a single string\n    let resultArray = result |> Seq.toArray |> Array.rev\n    String.Join(\"\", resultArray)\nopen System\nopen System.Diagnostics\n\nmodule TestAddStrings =\n    let checkAddStrings() =\n        Debug.Assert(addStrings \"123\" \"456\" = \"579\")\n        Debug.Assert(addStrings \"999\" \"1\" = \"1000\")\n        Debug.Assert(addStrings \"0\" \"0\" = \"0\")\n        Debug.Assert(addStrings \"1000\" \"1\" = \"1001\")\n        Debug.Assert(addStrings \"999999\" \"1\" = \"1000000\")\n\n[<EntryPoint>]\nlet main argv =\n    TestAddStrings.checkAddStrings()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to determine the winner(s) of an election based on the votes received by each candidate.\n// If there is a tie for the highest number of votes, all tied candidates are returned.\n// Returns an empty list if the input list is empty.\nlet electionWinner (votes: int list) =\n    if List.isEmpty votes then\n        []\n    else\n        let maxVotes = List.max votes\n        votes\n        |> List.mapi (fun index vote -> (index, vote))\n        |> List.filter (fun (_, vote) -> vote = maxVotes)\n        |> List.map fst", "test_cases": "", "test_case_results": "Input votes: [1; 2; 3; 4]\nWinner(s): [3]\n\nInput votes: [5; 5; 3; 4]\nWinner(s): [0; 1]\n\nInput votes: [0; 0; 0]\nWinner(s): [0; 1; 2]\n\nInput votes: []\nWinner(s): []", "task_id": 4923, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestElectionWinner =\n    let checkElectionWinner() =\n        Debug.Assert(electionWinner [1; 2; 3; 4] = [3])\n        Debug.Assert(electionWinner [5; 5; 3; 4] = [0; 1])\n        Debug.Assert(electionWinner [0; 0; 0] = [0; 1; 2])\n        Debug.Assert(electionWinner [] = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestElectionWinner.checkElectionWinner()\n    0", "all_code": "// Function to determine the winner(s) of an election based on the votes received by each candidate.\n// If there is a tie for the highest number of votes, all tied candidates are returned.\n// Returns an empty list if the input list is empty.\nlet electionWinner (votes: int list) =\n    if List.isEmpty votes then\n        []\n    else\n        let maxVotes = List.max votes\n        votes\n        |> List.mapi (fun index vote -> (index, vote))\n        |> List.filter (fun (_, vote) -> vote = maxVotes)\n        |> List.map fst\nopen System\nopen System.Diagnostics\n\nmodule TestElectionWinner =\n    let checkElectionWinner() =\n        Debug.Assert(electionWinner [1; 2; 3; 4] = [3])\n        Debug.Assert(electionWinner [5; 5; 3; 4] = [0; 1])\n        Debug.Assert(electionWinner [0; 0; 0] = [0; 1; 2])\n        Debug.Assert(electionWinner [] = [])\n\n[<EntryPoint>]\nlet main argv =\n    TestElectionWinner.checkElectionWinner()\n    0", "exec_outcome": "PASSED"}
{"code": "// minFlowersAfterNights calculates the minimum number of flowers that could be present in any garden after d nights.\n// The function takes an array of integers (nums) and an integer (d) representing the number of nights.\n// Each night, the flowers in each garden (except the first and last) are updated to the minimum of their current value and their neighbors' values.\n// The first and last gardens are updated to the minimum of their current value and their single neighbor's value.\nlet minFlowersAfterNights (nums: int array) (d: int) =\n    let n = nums.Length\n    let mutable currentNums = Array.copy nums\n\n    for _ in 1..d do\n        let newNums = Array.copy currentNums\n        for i in 1..n-2 do\n            newNums.[i] <- min newNums.[i] (min currentNums.[i-1] currentNums.[i+1])\n        if n > 1 then\n            newNums.[0] <- min newNums.[0] currentNums.[1]\n            newNums.[n-1] <- min newNums.[n-1] currentNums.[n-2]\n        currentNums <- newNums\n\n    Array.min currentNums", "test_cases": "", "test_case_results": "Input array: [|1; 2; 3; 4|], Number of nights: 1\nMinimum flowers after 1 nights: 1\n\nInput array: [|5; 6; 7; 0|], Number of nights: 2\nMinimum flowers after 2 nights: 0\n\nInput array: [|0; 0; 0; 0|], Number of nights: 3\nMinimum flowers after 3 nights: 0\n\nInput array: [|10; 5; 8; 12; 3|], Number of nights: 2\nMinimum flowers after 2 nights: 3\n\nInput array: [|7|], Number of nights: 5\nMinimum flowers after 5 nights: 7", "task_id": 24526, "assertions": "open System.Diagnostics\n\nmodule TestMinFlowers =\n    let checkMinFlowers() =\n        Debug.Assert(minFlowersAfterNights [|1; 2; 3; 4|] 1 = 1)\n        Debug.Assert(minFlowersAfterNights [|5; 6; 7; 0|] 2 = 0)\n        Debug.Assert(minFlowersAfterNights [|0; 0; 0; 0|] 3 = 0)\n        Debug.Assert(minFlowersAfterNights [|10; 5; 8; 12; 3|] 2 = 3)\n        Debug.Assert(minFlowersAfterNights [|7|] 5 = 7)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinFlowers.checkMinFlowers()\n    0", "all_code": "// minFlowersAfterNights calculates the minimum number of flowers that could be present in any garden after d nights.\n// The function takes an array of integers (nums) and an integer (d) representing the number of nights.\n// Each night, the flowers in each garden (except the first and last) are updated to the minimum of their current value and their neighbors' values.\n// The first and last gardens are updated to the minimum of their current value and their single neighbor's value.\nlet minFlowersAfterNights (nums: int array) (d: int) =\n    let n = nums.Length\n    let mutable currentNums = Array.copy nums\n\n    for _ in 1..d do\n        let newNums = Array.copy currentNums\n        for i in 1..n-2 do\n            newNums.[i] <- min newNums.[i] (min currentNums.[i-1] currentNums.[i+1])\n        if n > 1 then\n            newNums.[0] <- min newNums.[0] currentNums.[1]\n            newNums.[n-1] <- min newNums.[n-1] currentNums.[n-2]\n        currentNums <- newNums\n\n    Array.min currentNums\nopen System.Diagnostics\n\nmodule TestMinFlowers =\n    let checkMinFlowers() =\n        Debug.Assert(minFlowersAfterNights [|1; 2; 3; 4|] 1 = 1)\n        Debug.Assert(minFlowersAfterNights [|5; 6; 7; 0|] 2 = 0)\n        Debug.Assert(minFlowersAfterNights [|0; 0; 0; 0|] 3 = 0)\n        Debug.Assert(minFlowersAfterNights [|10; 5; 8; 12; 3|] 2 = 3)\n        Debug.Assert(minFlowersAfterNights [|7|] 5 = 7)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinFlowers.checkMinFlowers()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// findEventSpikes identifies and returns the indices of all the event spikes in the sequence.\n// An event spike is defined as a value that is strictly greater than both its\n// preceding and succeeding values in the array. If no event spikes are found,\n// it returns an empty array.\nlet findEventSpikes (arr: int array) =\n    let spikes = ResizeArray<int>()\n    for i in 1 .. arr.Length - 2 do\n        if arr.[i] > arr.[i - 1] && arr.[i] > arr.[i + 1] then\n            spikes.Add(i)\n    spikes.ToArray()", "test_cases": "", "test_case_results": "Input: [|1; 2; 1; 3; 2|]\nEvent spikes: [|1; 3|]\n\nInput: [|1; 3; 5; 4; 2|]\nEvent spikes: [|2|]\n\nInput: [|5; 1; 5|]\nEvent spikes: [||]\n\nInput: [|1; 2; 3; 4|]\nEvent spikes: [||]\n\nInput: [|4; 3; 2; 1|]\nEvent spikes: [||]\n\nInput: [|1; 1; 1|]\nEvent spikes: [||]", "task_id": 9723, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestEventSpikes =\n    let checkFindEventSpikes() =\n        Debug.Assert(findEventSpikes [|1; 2; 1; 3; 2|] = [|1; 3|])\n        Debug.Assert(findEventSpikes [|1; 3; 5; 4; 2|] = [|2|])\n        Debug.Assert(findEventSpikes [|5; 1; 5|] = [||])\n        Debug.Assert(findEventSpikes [|1; 2; 3; 4|] = [||])\n        Debug.Assert(findEventSpikes [|4; 3; 2; 1|] = [||])\n        Debug.Assert(findEventSpikes [|1; 1; 1|] = [||])\n\n[<EntryPoint>]\nlet main argv =\n    TestEventSpikes.checkFindEventSpikes()\n    0", "all_code": "open System\n\n// findEventSpikes identifies and returns the indices of all the event spikes in the sequence.\n// An event spike is defined as a value that is strictly greater than both its\n// preceding and succeeding values in the array. If no event spikes are found,\n// it returns an empty array.\nlet findEventSpikes (arr: int array) =\n    let spikes = ResizeArray<int>()\n    for i in 1 .. arr.Length - 2 do\n        if arr.[i] > arr.[i - 1] && arr.[i] > arr.[i + 1] then\n            spikes.Add(i)\n    spikes.ToArray()\nopen System\nopen System.Diagnostics\n\nmodule TestEventSpikes =\n    let checkFindEventSpikes() =\n        Debug.Assert(findEventSpikes [|1; 2; 1; 3; 2|] = [|1; 3|])\n        Debug.Assert(findEventSpikes [|1; 3; 5; 4; 2|] = [|2|])\n        Debug.Assert(findEventSpikes [|5; 1; 5|] = [||])\n        Debug.Assert(findEventSpikes [|1; 2; 3; 4|] = [||])\n        Debug.Assert(findEventSpikes [|4; 3; 2; 1|] = [||])\n        Debug.Assert(findEventSpikes [|1; 1; 1|] = [||])\n\n[<EntryPoint>]\nlet main argv =\n    TestEventSpikes.checkFindEventSpikes()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to determine if it's possible to fill an n x m grid with numbers in [l, r] such that each row has distinct numbers\n// The condition is that the range [l, r] must have at least n distinct numbers (i.e., r - l + 1 >= n)\nlet isPossibleToFillGrid (n: int) (m: int) (l: int) (r: int) =\n    if (r - l + 1) >= n then \"YES\"\n    else \"NO\"", "test_cases": "", "test_case_results": "Input: n = 2, m = 3, l = 1, r = 2\nResult: YES\n\nInput: n = 3, m = 2, l = 5, r = 7\nResult: YES\n\nInput: n = 4, m = 4, l = 1, r = 3\nResult: NO\n\nInput: n = 1, m = 5, l = 10, r = 10\nResult: YES", "task_id": 10032, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestGridFilling =\n    let checkGridFilling() =\n        Debug.Assert(isPossibleToFillGrid 2 3 1 2 = \"YES\")\n        Debug.Assert(isPossibleToFillGrid 3 2 5 7 = \"YES\")\n        Debug.Assert(isPossibleToFillGrid 4 4 1 3 = \"NO\")\n        Debug.Assert(isPossibleToFillGrid 1 5 10 10 = \"YES\")\n\n[<EntryPoint>]\nlet main argv =\n    TestGridFilling.checkGridFilling()\n    0", "all_code": "// Function to determine if it's possible to fill an n x m grid with numbers in [l, r] such that each row has distinct numbers\n// The condition is that the range [l, r] must have at least n distinct numbers (i.e., r - l + 1 >= n)\nlet isPossibleToFillGrid (n: int) (m: int) (l: int) (r: int) =\n    if (r - l + 1) >= n then \"YES\"\n    else \"NO\"\nopen System\nopen System.Diagnostics\n\nmodule TestGridFilling =\n    let checkGridFilling() =\n        Debug.Assert(isPossibleToFillGrid 2 3 1 2 = \"YES\")\n        Debug.Assert(isPossibleToFillGrid 3 2 5 7 = \"YES\")\n        Debug.Assert(isPossibleToFillGrid 4 4 1 3 = \"NO\")\n        Debug.Assert(isPossibleToFillGrid 1 5 10 10 = \"YES\")\n\n[<EntryPoint>]\nlet main argv =\n    TestGridFilling.checkGridFilling()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// kthSmallestElement finds the k-th smallest element in an unsorted array using Cycle Sort for sorting.\n// The function modifies the input array in-place and returns the k-th smallest element.\nlet kthSmallestElement (arr: int array) (k: int) =\n    let n = arr.Length\n\n    // Cycle Sort to sort the array in-place\n    for cycleStart in 0 .. n - 2 do\n        let mutable item = arr.[cycleStart]\n        let mutable pos = cycleStart\n\n        // Find where to place the element\n        for i in cycleStart + 1 .. n - 1 do\n            if arr.[i] < item then\n                pos <- pos + 1\n\n        // If the item is already in the correct position\n        if pos = cycleStart then\n            ()\n        else\n            // Skip duplicates\n            while item = arr.[pos] do\n                pos <- pos + 1\n\n            // Place the item in its correct position\n            let temp = arr.[pos]\n            arr.[pos] <- item\n            item <- temp\n\n            // Rotate the rest of the cycle\n            while pos <> cycleStart do\n                pos <- cycleStart\n                for i in cycleStart + 1 .. n - 1 do\n                    if arr.[i] < item then\n                        pos <- pos + 1\n\n                while item = arr.[pos] do\n                    pos <- pos + 1\n\n                let temp = arr.[pos]\n                arr.[pos] <- item\n                item <- temp\n\n    // Return the k-th smallest element\n    arr.[k - 1]", "test_cases": "", "test_case_results": "Input array: [|3; 1; 4; 1; 5; 9; 2; 6|], k: 3\nThe 3-th smallest element is: 2\nSorted array: [|1; 1; 2; 3; 4; 5; 6; 9|]\nInput array: [|5; 2; 9; 1; 5; 6|], k: 2\nThe 2-th smallest element is: 2\nSorted array: [|1; 2; 5; 5; 6; 9|]\nInput array: [|1; 2; 3; 4; 5|], k: 1\nThe 1-th smallest element is: 1\nSorted array: [|1; 2; 3; 4; 5|]\nInput array: [|10; 9; 8; 7; 6|], k: 5\nThe 5-th smallest element is: 10\nSorted array: [|6; 7; 8; 9; 10|]", "task_id": 10231, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestKthSmallestElement =\n    let checkKthSmallestElement() =\n        let testCase1 = [|3; 1; 4; 1; 5; 9; 2; 6|]\n        let arrCopy1 = Array.copy testCase1\n        Debug.Assert(kthSmallestElement arrCopy1 3 = 2)\n\n        let testCase2 = [|5; 2; 9; 1; 5; 6|]\n        let arrCopy2 = Array.copy testCase2\n        Debug.Assert(kthSmallestElement arrCopy2 2 = 2)\n\n        let testCase3 = [|1; 2; 3; 4; 5|]\n        let arrCopy3 = Array.copy testCase3\n        Debug.Assert(kthSmallestElement arrCopy3 1 = 1)\n\n        let testCase4 = [|10; 9; 8; 7; 6|]\n        let arrCopy4 = Array.copy testCase4\n        Debug.Assert(kthSmallestElement arrCopy4 5 = 10)\n\n[<EntryPoint>]\nlet main argv =\n    TestKthSmallestElement.checkKthSmallestElement()\n    0", "all_code": "open System\n\n// kthSmallestElement finds the k-th smallest element in an unsorted array using Cycle Sort for sorting.\n// The function modifies the input array in-place and returns the k-th smallest element.\nlet kthSmallestElement (arr: int array) (k: int) =\n    let n = arr.Length\n\n    // Cycle Sort to sort the array in-place\n    for cycleStart in 0 .. n - 2 do\n        let mutable item = arr.[cycleStart]\n        let mutable pos = cycleStart\n\n        // Find where to place the element\n        for i in cycleStart + 1 .. n - 1 do\n            if arr.[i] < item then\n                pos <- pos + 1\n\n        // If the item is already in the correct position\n        if pos = cycleStart then\n            ()\n        else\n            // Skip duplicates\n            while item = arr.[pos] do\n                pos <- pos + 1\n\n            // Place the item in its correct position\n            let temp = arr.[pos]\n            arr.[pos] <- item\n            item <- temp\n\n            // Rotate the rest of the cycle\n            while pos <> cycleStart do\n                pos <- cycleStart\n                for i in cycleStart + 1 .. n - 1 do\n                    if arr.[i] < item then\n                        pos <- pos + 1\n\n                while item = arr.[pos] do\n                    pos <- pos + 1\n\n                let temp = arr.[pos]\n                arr.[pos] <- item\n                item <- temp\n\n    // Return the k-th smallest element\n    arr.[k - 1]\nopen System\nopen System.Diagnostics\n\nmodule TestKthSmallestElement =\n    let checkKthSmallestElement() =\n        let testCase1 = [|3; 1; 4; 1; 5; 9; 2; 6|]\n        let arrCopy1 = Array.copy testCase1\n        Debug.Assert(kthSmallestElement arrCopy1 3 = 2)\n\n        let testCase2 = [|5; 2; 9; 1; 5; 6|]\n        let arrCopy2 = Array.copy testCase2\n        Debug.Assert(kthSmallestElement arrCopy2 2 = 2)\n\n        let testCase3 = [|1; 2; 3; 4; 5|]\n        let arrCopy3 = Array.copy testCase3\n        Debug.Assert(kthSmallestElement arrCopy3 1 = 1)\n\n        let testCase4 = [|10; 9; 8; 7; 6|]\n        let arrCopy4 = Array.copy testCase4\n        Debug.Assert(kthSmallestElement arrCopy4 5 = 10)\n\n[<EntryPoint>]\nlet main argv =\n    TestKthSmallestElement.checkKthSmallestElement()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to generate a pyramid of asterisks with the given number of levels.\n// Each level of the pyramid has an incremental number of asterisks centered to align in a pyramid shape.\nlet pyramid (levels: int) =\n    if levels <= 0 then\n        \"\"\n    else\n        let maxWidth = 2 * levels - 1\n        [| for i in 0 .. levels - 1 do\n            let stars = String.replicate (2 * i + 1) \"*\"\n            let spaces = String.replicate (levels - i - 1) \" \"\n            yield spaces + stars + spaces |]\n        |> String.concat \"\\n\"", "test_cases": "", "test_case_results": "Input Level: 0\n\n\nInput Level: 1\n*\n\nInput Level: 3\n  *  \n *** \n*****\n\nInput Level: 5\n    *    \n   ***   \n  *****  \n ******* \n*********", "task_id": 9715, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestPyramid =\n    let checkPyramid() =\n        Debug.Assert(pyramid 0 = \"\")\n        Debug.Assert(pyramid 1 = \"*\")\n        Debug.Assert(pyramid 3 = \"  *  \\n *** \\n*****\")\n        Debug.Assert(pyramid 5 = \"    *    \\n   ***   \\n  *****  \\n ******* \\n*********\")\n\n[<EntryPoint>]\nlet main argv =\n    TestPyramid.checkPyramid()\n    0", "all_code": "// Function to generate a pyramid of asterisks with the given number of levels.\n// Each level of the pyramid has an incremental number of asterisks centered to align in a pyramid shape.\nlet pyramid (levels: int) =\n    if levels <= 0 then\n        \"\"\n    else\n        let maxWidth = 2 * levels - 1\n        [| for i in 0 .. levels - 1 do\n            let stars = String.replicate (2 * i + 1) \"*\"\n            let spaces = String.replicate (levels - i - 1) \" \"\n            yield spaces + stars + spaces |]\n        |> String.concat \"\\n\"\nopen System\nopen System.Diagnostics\n\nmodule TestPyramid =\n    let checkPyramid() =\n        Debug.Assert(pyramid 0 = \"\")\n        Debug.Assert(pyramid 1 = \"*\")\n        Debug.Assert(pyramid 3 = \"  *  \\n *** \\n*****\")\n        Debug.Assert(pyramid 5 = \"    *    \\n   ***   \\n  *****  \\n ******* \\n*********\")\n\n[<EntryPoint>]\nlet main argv =\n    TestPyramid.checkPyramid()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\nlet minimizeStones (arr: int list) =\n    let maxHeap = PriorityQueue<int, int>()\n    arr \n    |> List.filter (fun a -> a > 0)\n    |> List.iter (fun a -> maxHeap.Enqueue(a, -a))\n    \n    while maxHeap.Count > 1 do\n        let first = maxHeap.Dequeue()\n        let second = maxHeap.Dequeue()\n        \n        if first > 1 || second > 1 then\n            let newFirst = first - 1\n            let newSecond = second - 1\n            \n            if newFirst > 0 then\n                maxHeap.Enqueue(newFirst, -newFirst)\n            if newSecond > 0 then\n                maxHeap.Enqueue(newSecond, -newSecond)\n    \n    let mutable sum = 0\n    while maxHeap.Count > 0 do\n        sum <- sum + maxHeap.Dequeue()\n    sum", "test_cases": "", "test_case_results": "Input: [1; 2; 3; 4]\nMinimum stones left: 0\nInput: [5; 6; 7; 0]\nMinimum stones left: 0\nInput: [0; 0; 0; 0]\nMinimum stones left: 0\nInput: [10; 10; 10]\nMinimum stones left: 0\nInput: [1; 1; 1]\nMinimum stones left: 1", "task_id": 16170, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinimizeStones =\n    let checkMinimizeStones() =\n        Debug.Assert(minimizeStones [1; 2; 3; 4] = 0)\n        Debug.Assert(minimizeStones [5; 6; 7; 0] = 0)\n        Debug.Assert(minimizeStones [0; 0; 0; 0] = 0)\n        Debug.Assert(minimizeStones [10; 10; 10] = 0)\n        Debug.Assert(minimizeStones [1; 1; 1] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinimizeStones.checkMinimizeStones()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\nlet minimizeStones (arr: int list) =\n    let maxHeap = PriorityQueue<int, int>()\n    arr \n    |> List.filter (fun a -> a > 0)\n    |> List.iter (fun a -> maxHeap.Enqueue(a, -a))\n    \n    while maxHeap.Count > 1 do\n        let first = maxHeap.Dequeue()\n        let second = maxHeap.Dequeue()\n        \n        if first > 1 || second > 1 then\n            let newFirst = first - 1\n            let newSecond = second - 1\n            \n            if newFirst > 0 then\n                maxHeap.Enqueue(newFirst, -newFirst)\n            if newSecond > 0 then\n                maxHeap.Enqueue(newSecond, -newSecond)\n    \n    let mutable sum = 0\n    while maxHeap.Count > 0 do\n        sum <- sum + maxHeap.Dequeue()\n    sum\nopen System\nopen System.Diagnostics\n\nmodule TestMinimizeStones =\n    let checkMinimizeStones() =\n        Debug.Assert(minimizeStones [1; 2; 3; 4] = 0)\n        Debug.Assert(minimizeStones [5; 6; 7; 0] = 0)\n        Debug.Assert(minimizeStones [0; 0; 0; 0] = 0)\n        Debug.Assert(minimizeStones [10; 10; 10] = 0)\n        Debug.Assert(minimizeStones [1; 1; 1] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinimizeStones.checkMinimizeStones()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// minOperationsToMakeValid calculates the minimum number of operations needed to balance a string of parentheses.\n// An operation can be either adding a parenthesis or removing one.\n// The function iterates through the string, keeping track of the balance of parentheses.\n// For every unmatched ')', an operation is needed, and any remaining '(' at the end also require operations.\nlet minOperationsToMakeValid (s: string) =\n    let mutable balance = 0\n    let mutable operations = 0\n    \n    for char in s do\n        if char = '(' then\n            balance <- balance + 1\n        else // char == ')'\n            if balance > 0 then\n                balance <- balance - 1\n            else\n                operations <- operations + 1\n                \n    operations + balance", "test_cases": "", "test_case_results": "Input: \"())\"\nMinimum operations needed: 1\n\nInput: \"(((\"\nMinimum operations needed: 3\n\nInput: \"()\"\nMinimum operations needed: 0\n\nInput: \"()))((\"\nMinimum operations needed: 4\n\nInput: \"(()())\"\nMinimum operations needed: 0", "task_id": 28020, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestParentheses =\n    let checkMinOperations() =\n        Debug.Assert(minOperationsToMakeValid \"())\" = 1)\n        Debug.Assert(minOperationsToMakeValid \"(((\" = 3)\n        Debug.Assert(minOperationsToMakeValid \"()\" = 0)\n        Debug.Assert(minOperationsToMakeValid \"()))((\" = 4)\n        Debug.Assert(minOperationsToMakeValid \"(()())\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestParentheses.checkMinOperations()\n    0", "all_code": "open System\n\n// minOperationsToMakeValid calculates the minimum number of operations needed to balance a string of parentheses.\n// An operation can be either adding a parenthesis or removing one.\n// The function iterates through the string, keeping track of the balance of parentheses.\n// For every unmatched ')', an operation is needed, and any remaining '(' at the end also require operations.\nlet minOperationsToMakeValid (s: string) =\n    let mutable balance = 0\n    let mutable operations = 0\n    \n    for char in s do\n        if char = '(' then\n            balance <- balance + 1\n        else // char == ')'\n            if balance > 0 then\n                balance <- balance - 1\n            else\n                operations <- operations + 1\n                \n    operations + balance\nopen System\nopen System.Diagnostics\n\nmodule TestParentheses =\n    let checkMinOperations() =\n        Debug.Assert(minOperationsToMakeValid \"())\" = 1)\n        Debug.Assert(minOperationsToMakeValid \"(((\" = 3)\n        Debug.Assert(minOperationsToMakeValid \"()\" = 0)\n        Debug.Assert(minOperationsToMakeValid \"()))((\" = 4)\n        Debug.Assert(minOperationsToMakeValid \"(()())\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestParentheses.checkMinOperations()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nmodule TriangularNumberChecker =\n    // Method 1: Using quadratic equation solution\n    // A number n is triangular if 8n + 1 is a perfect square and the square root is odd.\n    let isTriangularQuadratic (n: int) =\n        let k = 1 + 8 * n\n        let sqrtK = int (sqrt (float k))\n        sqrtK * sqrtK = k && (sqrtK - 1) % 2 = 0\n\n    // Method 2: Using iterative check\n    // Checks if n equals i*(i+1)/2 for any i up to 31 (since 32*33/2 = 528 > typical test cases)\n    let isTriangularIterative (n: int) =\n        let mutable isTriangular = false\n        for i in 1..31 do\n            if i * (i + 1) / 2 = n then\n                isTriangular <- true\n        isTriangular\n\n    // Method 3: Same as Method 1, just duplicated in the original code\n    let isTriangularQuadratic2 (n: int) = isTriangularQuadratic n", "test_cases": "", "test_case_results": "Testing triangular number checkers\n----------------------------------\nInput: 1\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 3\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 6\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 10\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 15\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 21\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 28\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 36\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 45\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 55\nMethod 1 (Quadratic): YES\nMethod 2 (Iterative): YES\nMethod 3 (Quadratic2): YES\n\nInput: 2\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 4\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 5\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 7\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 8\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 9\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO\n\nInput: 11\nMethod 1 (Quadratic): NO\nMethod 2 (Iterative): NO\nMethod 3 (Quadratic2): NO", "task_id": 1476, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestTriangularNumberChecker =\n    let checkTriangularNumbers() =\n        // Test triangular numbers\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 1)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 1)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 1)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 3)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 3)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 3)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 6)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 6)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 6)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 10)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 10)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 10)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 15)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 15)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 15)\n        \n        // Test non-triangular numbers\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 2))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 2))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 2))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 4))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 4))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 4))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 7))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 7))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 7))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 11))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 11))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 11))\n\n[<EntryPoint>]\nlet main argv =\n    TestTriangularNumberChecker.checkTriangularNumbers()\n    0", "all_code": "open System\n\nmodule TriangularNumberChecker =\n    // Method 1: Using quadratic equation solution\n    // A number n is triangular if 8n + 1 is a perfect square and the square root is odd.\n    let isTriangularQuadratic (n: int) =\n        let k = 1 + 8 * n\n        let sqrtK = int (sqrt (float k))\n        sqrtK * sqrtK = k && (sqrtK - 1) % 2 = 0\n\n    // Method 2: Using iterative check\n    // Checks if n equals i*(i+1)/2 for any i up to 31 (since 32*33/2 = 528 > typical test cases)\n    let isTriangularIterative (n: int) =\n        let mutable isTriangular = false\n        for i in 1..31 do\n            if i * (i + 1) / 2 = n then\n                isTriangular <- true\n        isTriangular\n\n    // Method 3: Same as Method 1, just duplicated in the original code\n    let isTriangularQuadratic2 (n: int) = isTriangularQuadratic n\nopen System\nopen System.Diagnostics\n\nmodule TestTriangularNumberChecker =\n    let checkTriangularNumbers() =\n        // Test triangular numbers\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 1)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 1)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 1)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 3)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 3)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 3)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 6)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 6)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 6)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 10)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 10)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 10)\n        \n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic 15)\n        Debug.Assert(TriangularNumberChecker.isTriangularIterative 15)\n        Debug.Assert(TriangularNumberChecker.isTriangularQuadratic2 15)\n        \n        // Test non-triangular numbers\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 2))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 2))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 2))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 4))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 4))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 4))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 7))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 7))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 7))\n        \n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic 11))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularIterative 11))\n        Debug.Assert(not (TriangularNumberChecker.isTriangularQuadratic2 11))\n\n[<EntryPoint>]\nlet main argv =\n    TestTriangularNumberChecker.checkTriangularNumbers()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// maxProfit calculates the maximum profit from a list of stock prices.\n// The function iterates through the list and sums up all the positive differences\n// between consecutive days to compute the total profit.\nlet maxProfit (prices: int array) =\n    let mutable totalProfit = 0\n    for i in 1 .. prices.Length - 1 do\n        if prices.[i] > prices.[i - 1] then\n            totalProfit <- totalProfit + (prices.[i] - prices.[i - 1])\n    totalProfit", "test_cases": "", "test_case_results": "Input: [|7; 1; 5; 3; 6; 4|]\nMaximum Profit: 7\nInput: [|1; 2; 3; 4; 5|]\nMaximum Profit: 4\nInput: [|5; 4; 3; 2; 1|]\nMaximum Profit: 0\nInput: [|1; 1; 1; 1; 1|]\nMaximum Profit: 0", "task_id": 2452, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMaxProfit =\n    let checkMaxProfit() =\n        Debug.Assert(maxProfit [|7; 1; 5; 3; 6; 4|] = 7)\n        Debug.Assert(maxProfit [|1; 2; 3; 4; 5|] = 4)\n        Debug.Assert(maxProfit [|5; 4; 3; 2; 1|] = 0)\n        Debug.Assert(maxProfit [|1; 1; 1; 1; 1|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxProfit.checkMaxProfit()\n    0", "all_code": "open System\n\n// maxProfit calculates the maximum profit from a list of stock prices.\n// The function iterates through the list and sums up all the positive differences\n// between consecutive days to compute the total profit.\nlet maxProfit (prices: int array) =\n    let mutable totalProfit = 0\n    for i in 1 .. prices.Length - 1 do\n        if prices.[i] > prices.[i - 1] then\n            totalProfit <- totalProfit + (prices.[i] - prices.[i - 1])\n    totalProfit\nopen System\nopen System.Diagnostics\n\nmodule TestMaxProfit =\n    let checkMaxProfit() =\n        Debug.Assert(maxProfit [|7; 1; 5; 3; 6; 4|] = 7)\n        Debug.Assert(maxProfit [|1; 2; 3; 4; 5|] = 4)\n        Debug.Assert(maxProfit [|5; 4; 3; 2; 1|] = 0)\n        Debug.Assert(maxProfit [|1; 1; 1; 1; 1|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMaxProfit.checkMaxProfit()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Calculates the minimum time required to solve 'c' problems with the given constraints.\n// The strategy involves making clones (each clone can solve problems in parallel) and then solving the problems.\n// Parameters:\n//   a: Time taken to make one clone\n//   b: Time taken to solve one problem\n//   c: Total number of problems to solve\nlet calculateMinTime (a: int) (b: int) (c: int) =\n    let mutable minTime = System.Int32.MaxValue\n    // The maximum number of clones (n) we need to check is up to log2(c) + 2\n    let maxN = if c > 0 then (Math.Log2(float c) |> int) + 2 else 0\n    for n in 0..maxN do\n        let k = 1 <<< n // Equivalent to 2^n\n        let timeClone = n * a\n        let problemsPerRanran = (c + k - 1) / k // Ceiling division: ceil(c / k)\n        let timeProblems = problemsPerRanran * b\n        let totalTime = timeClone + timeProblems\n        if totalTime < minTime then\n            minTime <- totalTime\n    minTime", "test_cases": "", "test_case_results": "Input: a=1, b=1, c=1\nMinimum Time: 1\nInput: a=2, b=3, c=5\nMinimum Time: 9\nInput: a=10, b=1, c=100\nMinimum Time: 43\nInput: a=5, b=10, c=1\nMinimum Time: 10\nInput: a=3, b=2, c=10\nMinimum Time: 12", "task_id": 14475, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinTimeCalculator =\n    let runTests() =\n        Debug.Assert(calculateMinTime 1 1 1 = 1)\n        Debug.Assert(calculateMinTime 2 3 5 = 9)\n        Debug.Assert(calculateMinTime 10 1 100 = 43)\n        Debug.Assert(calculateMinTime 5 10 1 = 10)\n        Debug.Assert(calculateMinTime 3 2 10 = 12)\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestMinTimeCalculator.runTests()\n    0", "all_code": "open System\n\n// Calculates the minimum time required to solve 'c' problems with the given constraints.\n// The strategy involves making clones (each clone can solve problems in parallel) and then solving the problems.\n// Parameters:\n//   a: Time taken to make one clone\n//   b: Time taken to solve one problem\n//   c: Total number of problems to solve\nlet calculateMinTime (a: int) (b: int) (c: int) =\n    let mutable minTime = System.Int32.MaxValue\n    // The maximum number of clones (n) we need to check is up to log2(c) + 2\n    let maxN = if c > 0 then (Math.Log2(float c) |> int) + 2 else 0\n    for n in 0..maxN do\n        let k = 1 <<< n // Equivalent to 2^n\n        let timeClone = n * a\n        let problemsPerRanran = (c + k - 1) / k // Ceiling division: ceil(c / k)\n        let timeProblems = problemsPerRanran * b\n        let totalTime = timeClone + timeProblems\n        if totalTime < minTime then\n            minTime <- totalTime\n    minTime\nopen System\nopen System.Diagnostics\n\nmodule TestMinTimeCalculator =\n    let runTests() =\n        Debug.Assert(calculateMinTime 1 1 1 = 1)\n        Debug.Assert(calculateMinTime 2 3 5 = 9)\n        Debug.Assert(calculateMinTime 10 1 100 = 43)\n        Debug.Assert(calculateMinTime 5 10 1 = 10)\n        Debug.Assert(calculateMinTime 3 2 10 = 12)\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestMinTimeCalculator.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Generates all lucky numbers (composed only of digits 3 and 8) up to a certain length\nlet generateLuckyNumbers maxLength =\n    let rec generateNumbers currentLength currentNumber numbers =\n        if currentLength > maxLength then numbers\n        else\n            let num3 = currentNumber * 10 + 3\n            let num8 = currentNumber * 10 + 8\n            let newNumbers = num3 :: num8 :: numbers\n            generateNumbers (currentLength + 1) num3 (generateNumbers (currentLength + 1) num8 newNumbers)\n    generateNumbers 1 0 [] |> List.sort\n\n// Calculates the special sum for the range [l, r] using the lucky numbers\nlet calculateSpecialSum l r =\n    let luckyNumbers = generateLuckyNumbers 9 // Generate numbers up to 9 digits\n    let mutable total = 0\n    let mutable pre = 0\n    \n    for num in luckyNumbers do\n        let start = pre + 1\n        let end' = num\n        let lower = max l start\n        let upper = min r end'\n        \n        if lower <= upper then\n            let count = upper - lower + 1\n            total <- total + count * num\n            if upper = r then ()\n        pre <- num\n    \n    total", "test_cases": "", "test_case_results": "Input range: [1, 10]\nSpecial sum: 115\n\nInput range: [10, 100]\nSpecial sum: 9153\n\nInput range: [100, 1000]\nSpecial sum: 891133\n\nInput range: [123, 45678]\nSpecial sum: 1644015648\n\nInput range: [1, 1000000000]\nSpecial sum: 1967077147", "task_id": 11706, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestLuckyNumbers =\n    let checkSpecialSum() =\n        Debug.Assert(calculateSpecialSum 1 10 = 115)\n        Debug.Assert(calculateSpecialSum 10 100 = 9153)\n        Debug.Assert(calculateSpecialSum 100 1000 = 891133)\n        Debug.Assert(calculateSpecialSum 123 45678 = 1644015648)\n        Debug.Assert(calculateSpecialSum 1 1000000000 = 1967077147)\n\n[<EntryPoint>]\nlet main argv =\n    TestLuckyNumbers.checkSpecialSum()\n    0", "all_code": "open System\n\n// Generates all lucky numbers (composed only of digits 3 and 8) up to a certain length\nlet generateLuckyNumbers maxLength =\n    let rec generateNumbers currentLength currentNumber numbers =\n        if currentLength > maxLength then numbers\n        else\n            let num3 = currentNumber * 10 + 3\n            let num8 = currentNumber * 10 + 8\n            let newNumbers = num3 :: num8 :: numbers\n            generateNumbers (currentLength + 1) num3 (generateNumbers (currentLength + 1) num8 newNumbers)\n    generateNumbers 1 0 [] |> List.sort\n\n// Calculates the special sum for the range [l, r] using the lucky numbers\nlet calculateSpecialSum l r =\n    let luckyNumbers = generateLuckyNumbers 9 // Generate numbers up to 9 digits\n    let mutable total = 0\n    let mutable pre = 0\n    \n    for num in luckyNumbers do\n        let start = pre + 1\n        let end' = num\n        let lower = max l start\n        let upper = min r end'\n        \n        if lower <= upper then\n            let count = upper - lower + 1\n            total <- total + count * num\n            if upper = r then ()\n        pre <- num\n    \n    total\nopen System\nopen System.Diagnostics\n\nmodule TestLuckyNumbers =\n    let checkSpecialSum() =\n        Debug.Assert(calculateSpecialSum 1 10 = 115)\n        Debug.Assert(calculateSpecialSum 10 100 = 9153)\n        Debug.Assert(calculateSpecialSum 100 1000 = 891133)\n        Debug.Assert(calculateSpecialSum 123 45678 = 1644015648)\n        Debug.Assert(calculateSpecialSum 1 1000000000 = 1967077147)\n\n[<EntryPoint>]\nlet main argv =\n    TestLuckyNumbers.checkSpecialSum()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\nopen System.Collections.Generic\n\nmodule MazeSolver =\n    // canReachEnd determines if Robby can reach the end position 'E' from the start position 'S' in a maze grid.\n    // The grid is represented as a list of strings, where 'S' is the start, 'E' is the end, '#' is a wall, and '.' is a path.\n    // Uses BFS (Breadth-First Search) to explore all possible paths from 'S' to 'E'.\n    let canReachEnd (grid: string list) =\n        let N = grid.Length\n        let M = if N > 0 then grid.[0].Length else 0\n        \n        // Directions for moving up, down, left, right\n        let directions = [ (-1, 0); (1, 0); (0, -1); (0, 1) ]\n        \n        // Find start (S) and end (E) positions\n        let mutable start = None\n        let mutable endPos = None\n        \n        for i in 0 .. N - 1 do\n            for j in 0 .. M - 1 do\n                if grid.[i].[j] = 'S' then\n                    start <- Some (i, j)\n                elif grid.[i].[j] = 'E' then\n                    endPos <- Some (i, j)\n        \n        match start, endPos with\n        | None, _ | _, None -> \"No\"\n        | Some s, Some e ->\n            let queue = Queue<_>()\n            queue.Enqueue(s)\n            let visited = HashSet<_>()\n            visited.Add(s) |> ignore\n            \n            let rec bfs () =\n                if queue.Count = 0 then \"No\"\n                else\n                    let x, y = queue.Dequeue()\n                    if (x, y) = e then \"Yes\"\n                    else\n                        for dx, dy in directions do\n                            let nx, ny = x + dx, y + dy\n                            if nx >= 0 && nx < N && ny >= 0 && ny < M && grid.[nx].[ny] <> '#' && not (visited.Contains (nx, ny)) then\n                                visited.Add (nx, ny) |> ignore\n                                queue.Enqueue (nx, ny)\n                        bfs ()\n            bfs ()\n\n    // processTestCases processes multiple test cases and returns a list of results for each test case.\n    // Each test case is a tuple (N, M, grid), where N is the number of rows, M is the number of columns, and grid is the maze.\n    let processTestCases (testCases: (int * int * string list) list) =\n        testCases |> List.map (fun (_, _, grid) -> canReachEnd grid)", "test_cases": "", "test_case_results": "Testing canReachEnd function:\nInput Grid:\nS..\n.#.\n..E\nResult: Yes\n\nInput Grid:\nS#.\n.#.\n.#E\nResult: No\n\nInput Grid:\nS.#\n.#.\n#.E\nResult: No\n\nTesting processTestCases function:\nResults for all test cases: [\"Yes\"; \"No\"; \"No\"]", "task_id": 9163, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMazeSolver =\n    let testCanReachEnd() =\n        let testCases = [\n            (3, 3, [\n                \"S..\"\n                \".#.\"\n                \"..E\"\n            ])\n            (3, 3, [\n                \"S#.\"\n                \".#.\"\n                \".#E\"\n            ])\n            (3, 3, [\n                \"S.#\"\n                \".#.\"\n                \"#.E\"\n            ])\n        ]\n        \n        let results = MazeSolver.processTestCases testCases\n        Debug.Assert(results = [\"Yes\"; \"No\"; \"No\"])\n        \n        // Individual test assertions\n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S..\"\n            \".#.\"\n            \"..E\"\n        ] = \"Yes\")\n        \n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S#.\"\n            \".#.\"\n            \".#E\"\n        ] = \"No\")\n        \n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S.#\"\n            \".#.\"\n            \"#.E\"\n        ] = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestMazeSolver.testCanReachEnd()\n    0", "all_code": "open System\nopen System.Collections.Generic\n\nmodule MazeSolver =\n    // canReachEnd determines if Robby can reach the end position 'E' from the start position 'S' in a maze grid.\n    // The grid is represented as a list of strings, where 'S' is the start, 'E' is the end, '#' is a wall, and '.' is a path.\n    // Uses BFS (Breadth-First Search) to explore all possible paths from 'S' to 'E'.\n    let canReachEnd (grid: string list) =\n        let N = grid.Length\n        let M = if N > 0 then grid.[0].Length else 0\n        \n        // Directions for moving up, down, left, right\n        let directions = [ (-1, 0); (1, 0); (0, -1); (0, 1) ]\n        \n        // Find start (S) and end (E) positions\n        let mutable start = None\n        let mutable endPos = None\n        \n        for i in 0 .. N - 1 do\n            for j in 0 .. M - 1 do\n                if grid.[i].[j] = 'S' then\n                    start <- Some (i, j)\n                elif grid.[i].[j] = 'E' then\n                    endPos <- Some (i, j)\n        \n        match start, endPos with\n        | None, _ | _, None -> \"No\"\n        | Some s, Some e ->\n            let queue = Queue<_>()\n            queue.Enqueue(s)\n            let visited = HashSet<_>()\n            visited.Add(s) |> ignore\n            \n            let rec bfs () =\n                if queue.Count = 0 then \"No\"\n                else\n                    let x, y = queue.Dequeue()\n                    if (x, y) = e then \"Yes\"\n                    else\n                        for dx, dy in directions do\n                            let nx, ny = x + dx, y + dy\n                            if nx >= 0 && nx < N && ny >= 0 && ny < M && grid.[nx].[ny] <> '#' && not (visited.Contains (nx, ny)) then\n                                visited.Add (nx, ny) |> ignore\n                                queue.Enqueue (nx, ny)\n                        bfs ()\n            bfs ()\n\n    // processTestCases processes multiple test cases and returns a list of results for each test case.\n    // Each test case is a tuple (N, M, grid), where N is the number of rows, M is the number of columns, and grid is the maze.\n    let processTestCases (testCases: (int * int * string list) list) =\n        testCases |> List.map (fun (_, _, grid) -> canReachEnd grid)\nopen System\nopen System.Diagnostics\n\nmodule TestMazeSolver =\n    let testCanReachEnd() =\n        let testCases = [\n            (3, 3, [\n                \"S..\"\n                \".#.\"\n                \"..E\"\n            ])\n            (3, 3, [\n                \"S#.\"\n                \".#.\"\n                \".#E\"\n            ])\n            (3, 3, [\n                \"S.#\"\n                \".#.\"\n                \"#.E\"\n            ])\n        ]\n        \n        let results = MazeSolver.processTestCases testCases\n        Debug.Assert(results = [\"Yes\"; \"No\"; \"No\"])\n        \n        // Individual test assertions\n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S..\"\n            \".#.\"\n            \"..E\"\n        ] = \"Yes\")\n        \n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S#.\"\n            \".#.\"\n            \".#E\"\n        ] = \"No\")\n        \n        Debug.Assert(MazeSolver.canReachEnd [\n            \"S.#\"\n            \".#.\"\n            \"#.E\"\n        ] = \"No\")\n\n[<EntryPoint>]\nlet main argv =\n    TestMazeSolver.testCanReachEnd()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// This function calculates the maximum value based on the given algorithm.\n// The algorithm involves sorting the input data, computing prefix sums, and then\n// iterating through the data to find the optimal value.\nlet calculateOptimalValue (n: int) (data: (int * int) list) =\n    // Sort the data by the first element of the tuple (Ai)\n    let sortedData = data |> List.sortBy (fun (a, _) -> a)\n    \n    // Compute the prefix sums of the second element of the tuple (Bi)\n    let prefixSum = \n        (0, sortedData) \n        ||> List.scan (fun sum (_, b) -> sum + b) \n        |> List.toArray\n    \n    let mutable maxSoFar = Int32.MinValue\n    let mutable best = Int32.MinValue\n    \n    for r in 1 .. n do\n        let currentA, _ = sortedData.[r - 1]\n        let currentTerm = currentA - prefixSum.[r - 1]\n        maxSoFar <- Math.Max(maxSoFar, currentTerm)\n        let currentValue = maxSoFar + (prefixSum.[r] - currentA)\n        if currentValue > best then\n            best <- currentValue\n    \n    best", "test_cases": "", "test_case_results": "Input n: 3, data: [(1, 2); (3, 4); (2, 3)]\nOptimal value: 7\nInput n: 2, data: [(5, 1); (2, 3)]\nOptimal value: 3\nInput n: 4, data: [(1, 1); (1, 1); (1, 1); (1, 1)]\nOptimal value: 4", "task_id": 1505, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestOptimalValue =\n    let checkOptimalValue() =\n        // Test case 1\n        Debug.Assert(calculateOptimalValue 3 [(1, 2); (3, 4); (2, 3)] = 7)\n        // Test case 2\n        Debug.Assert(calculateOptimalValue 2 [(5, 1); (2, 3)] = 3)\n        // Test case 3\n        Debug.Assert(calculateOptimalValue 4 [(1, 1); (1, 1); (1, 1); (1, 1)] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestOptimalValue.checkOptimalValue()\n    0", "all_code": "open System\n\n// This function calculates the maximum value based on the given algorithm.\n// The algorithm involves sorting the input data, computing prefix sums, and then\n// iterating through the data to find the optimal value.\nlet calculateOptimalValue (n: int) (data: (int * int) list) =\n    // Sort the data by the first element of the tuple (Ai)\n    let sortedData = data |> List.sortBy (fun (a, _) -> a)\n    \n    // Compute the prefix sums of the second element of the tuple (Bi)\n    let prefixSum = \n        (0, sortedData) \n        ||> List.scan (fun sum (_, b) -> sum + b) \n        |> List.toArray\n    \n    let mutable maxSoFar = Int32.MinValue\n    let mutable best = Int32.MinValue\n    \n    for r in 1 .. n do\n        let currentA, _ = sortedData.[r - 1]\n        let currentTerm = currentA - prefixSum.[r - 1]\n        maxSoFar <- Math.Max(maxSoFar, currentTerm)\n        let currentValue = maxSoFar + (prefixSum.[r] - currentA)\n        if currentValue > best then\n            best <- currentValue\n    \n    best\nopen System\nopen System.Diagnostics\n\nmodule TestOptimalValue =\n    let checkOptimalValue() =\n        // Test case 1\n        Debug.Assert(calculateOptimalValue 3 [(1, 2); (3, 4); (2, 3)] = 7)\n        // Test case 2\n        Debug.Assert(calculateOptimalValue 2 [(5, 1); (2, 3)] = 3)\n        // Test case 3\n        Debug.Assert(calculateOptimalValue 4 [(1, 1); (1, 1); (1, 1); (1, 1)] = 4)\n\n[<EntryPoint>]\nlet main argv =\n    TestOptimalValue.checkOptimalValue()\n    0", "exec_outcome": "PASSED"}
{"code": "// Function to calculate the house number directly opposite to a given odd-numbered house on the left side of the street.\n// The left side houses are odd-numbered starting from 1, and the right side houses are even-numbered starting from 2.\n// The opposite house is the nth even number where n is the position of the given odd number in the sequence of odd numbers.\nlet oppositeHouseNumber (x: int) =\n    let n = (x + 1) / 2  // Calculate the position of the house `x` in the sequence of odd numbers.\n    n * 2                // The opposite house is the nth even number.", "test_cases": "", "test_case_results": "Input: 1\nOpposite House Number: 2\nInput: 3\nOpposite House Number: 4\nInput: 5\nOpposite House Number: 6\nInput: 7\nOpposite House Number: 8\nInput: 9\nOpposite House Number: 10\nInput: 11\nOpposite House Number: 12", "task_id": 6179, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestOppositeHouseNumber =\n    let checkOppositeHouseNumber() =\n        Debug.Assert(oppositeHouseNumber 1 = 2)\n        Debug.Assert(oppositeHouseNumber 3 = 4)\n        Debug.Assert(oppositeHouseNumber 5 = 6)\n        Debug.Assert(oppositeHouseNumber 7 = 8)\n        Debug.Assert(oppositeHouseNumber 9 = 10)\n        Debug.Assert(oppositeHouseNumber 11 = 12)\n\n[<EntryPoint>]\nlet main argv =\n    TestOppositeHouseNumber.checkOppositeHouseNumber()\n    0", "all_code": "// Function to calculate the house number directly opposite to a given odd-numbered house on the left side of the street.\n// The left side houses are odd-numbered starting from 1, and the right side houses are even-numbered starting from 2.\n// The opposite house is the nth even number where n is the position of the given odd number in the sequence of odd numbers.\nlet oppositeHouseNumber (x: int) =\n    let n = (x + 1) / 2  // Calculate the position of the house `x` in the sequence of odd numbers.\n    n * 2                // The opposite house is the nth even number.\nopen System\nopen System.Diagnostics\n\nmodule TestOppositeHouseNumber =\n    let checkOppositeHouseNumber() =\n        Debug.Assert(oppositeHouseNumber 1 = 2)\n        Debug.Assert(oppositeHouseNumber 3 = 4)\n        Debug.Assert(oppositeHouseNumber 5 = 6)\n        Debug.Assert(oppositeHouseNumber 7 = 8)\n        Debug.Assert(oppositeHouseNumber 9 = 10)\n        Debug.Assert(oppositeHouseNumber 11 = 12)\n\n[<EntryPoint>]\nlet main argv =\n    TestOppositeHouseNumber.checkOppositeHouseNumber()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// Function to determine if a player has a chance to win based on the given arrays A and B.\n// The function checks two conditions:\n// 1. If there are no common elements between A and B.\n// 2. If the common elements appear in the same order in both arrays.\nlet hasChanceToWin (A: int array) (B: int array) =\n    let setA = Set.ofArray A\n    let setB = Set.ofArray B\n    let common = Set.intersect setA setB\n    \n    // If there are no common elements, the player has a chance to win.\n    if Set.isEmpty common then\n        true\n    else\n        // Extract common elements in original order for both A and B.\n        let a = A |> Array.filter (fun x -> Set.contains x common)\n        let b = B |> Array.filter (fun x -> Set.contains x common)\n        \n        // If the common elements are in the same order, the player has a chance to win.\n        a = b", "test_cases": "", "test_case_results": "Input A: [|1; 2; 3|]\nInput B: [|4; 5; 6|]\nHrac ma sanci vyhrat.\n\nInput A: [|1; 2; 3; 4|]\nInput B: [|5; 2; 6; 3|]\nHrac ma sanci vyhrat.\n\nInput A: [|1; 2; 3; 4|]\nInput B: [|5; 3; 6; 2|]\nSpatne usporadani.\n\nInput A: [|1; 2; 3|]\nInput B: [|1; 2; 3|]\nHrac ma sanci vyhrat.\n\nInput A: [|1; 2; 3|]\nInput B: [|3; 2; 1|]\nSpatne usporadani.", "task_id": 7139, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestHasChanceToWin =\n    let checkHasChanceToWin() =\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|4; 5; 6|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3; 4|] [|5; 2; 6; 3|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3; 4|] [|5; 3; 6; 2|] = false)\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|1; 2; 3|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|3; 2; 1|] = false)\n\n[<EntryPoint>]\nlet main argv =\n    TestHasChanceToWin.checkHasChanceToWin()\n    0", "all_code": "open System\n\n// Function to determine if a player has a chance to win based on the given arrays A and B.\n// The function checks two conditions:\n// 1. If there are no common elements between A and B.\n// 2. If the common elements appear in the same order in both arrays.\nlet hasChanceToWin (A: int array) (B: int array) =\n    let setA = Set.ofArray A\n    let setB = Set.ofArray B\n    let common = Set.intersect setA setB\n    \n    // If there are no common elements, the player has a chance to win.\n    if Set.isEmpty common then\n        true\n    else\n        // Extract common elements in original order for both A and B.\n        let a = A |> Array.filter (fun x -> Set.contains x common)\n        let b = B |> Array.filter (fun x -> Set.contains x common)\n        \n        // If the common elements are in the same order, the player has a chance to win.\n        a = b\nopen System\nopen System.Diagnostics\n\nmodule TestHasChanceToWin =\n    let checkHasChanceToWin() =\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|4; 5; 6|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3; 4|] [|5; 2; 6; 3|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3; 4|] [|5; 3; 6; 2|] = false)\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|1; 2; 3|] = true)\n        Debug.Assert(hasChanceToWin [|1; 2; 3|] [|3; 2; 1|] = false)\n\n[<EntryPoint>]\nlet main argv =\n    TestHasChanceToWin.checkHasChanceToWin()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\nlet minChar (S: string) =\n    // Create a reversed version of the string\n    let rev_S = new string(S.ToCharArray() |> Array.rev)\n    \n    // Create a new string which is the combination of S and its reversed version with a special character in between\n    let combined = S + \"#\" + rev_S\n    \n    // Compute LPS array for the combined string\n    let lps = Array.zeroCreate combined.Length\n    let mutable length = 0\n    let mutable i = 1\n    while i < combined.Length do\n        if combined.[i] = combined.[length] then\n            length <- length + 1\n            lps.[i] <- length\n            i <- i + 1\n        else\n            if length <> 0 then\n                length <- lps.[length - 1]\n            else\n                lps.[i] <- 0\n                i <- i + 1\n    \n    // The number of characters to be added is length of S minus the last value in the LPS array\n    S.Length - lps.[lps.Length - 1]", "test_cases": "", "test_case_results": "Input: \"aacecaaa\"\nNumber of characters to add: 1\nInput: \"abcd\"\nNumber of characters to add: 3\nInput: \"abac\"\nNumber of characters to add: 1\nInput: \"abb\"\nNumber of characters to add: 2\nInput: \"a\"\nNumber of characters to add: 0\nInput: \"\"\nNumber of characters to add: 0", "task_id": 20634, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestMinChar =\n    let checkMinChar() =\n        Debug.Assert(minChar \"aacecaaa\" = 1)\n        Debug.Assert(minChar \"abcd\" = 3)\n        Debug.Assert(minChar \"abac\" = 1)\n        Debug.Assert(minChar \"abb\" = 2)\n        Debug.Assert(minChar \"a\" = 0)\n        Debug.Assert(minChar \"\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinChar.checkMinChar()\n    0", "all_code": "open System\n\nlet minChar (S: string) =\n    // Create a reversed version of the string\n    let rev_S = new string(S.ToCharArray() |> Array.rev)\n    \n    // Create a new string which is the combination of S and its reversed version with a special character in between\n    let combined = S + \"#\" + rev_S\n    \n    // Compute LPS array for the combined string\n    let lps = Array.zeroCreate combined.Length\n    let mutable length = 0\n    let mutable i = 1\n    while i < combined.Length do\n        if combined.[i] = combined.[length] then\n            length <- length + 1\n            lps.[i] <- length\n            i <- i + 1\n        else\n            if length <> 0 then\n                length <- lps.[length - 1]\n            else\n                lps.[i] <- 0\n                i <- i + 1\n    \n    // The number of characters to be added is length of S minus the last value in the LPS array\n    S.Length - lps.[lps.Length - 1]\nopen System\nopen System.Diagnostics\n\nmodule TestMinChar =\n    let checkMinChar() =\n        Debug.Assert(minChar \"aacecaaa\" = 1)\n        Debug.Assert(minChar \"abcd\" = 3)\n        Debug.Assert(minChar \"abac\" = 1)\n        Debug.Assert(minChar \"abb\" = 2)\n        Debug.Assert(minChar \"a\" = 0)\n        Debug.Assert(minChar \"\" = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestMinChar.checkMinChar()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// countLargerPairs calculates the number of elements in the input array that can be paired with a larger element.\n// The array is sorted, and then for each element, we try to find the next larger element.\nlet countLargerPairs (a: int array) =\n    let original = Array.sort a\n    let mutable count = 0\n    let mutable j = 1 // start from the next element to find a larger one\n\n    for i in 0 .. original.Length - 1 do\n        while j < original.Length && original.[j] <= original.[i] do\n            j <- j + 1\n        if j < original.Length then\n            count <- count + 1\n            j <- j + 1\n\n    count", "test_cases": "", "test_case_results": "Input: [|10; 1; 1; 1; 5; 5; 3|]\nNumber of elements with larger pairs: 4\nInput: [|1; 1; 1; 1; 1|]\nNumber of elements with larger pairs: 0", "task_id": 28397, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestCountLargerPairs =\n    let checkCountLargerPairs() =\n        Debug.Assert(countLargerPairs [|10; 1; 1; 1; 5; 5; 3|] = 4)\n        Debug.Assert(countLargerPairs [|1; 1; 1; 1; 1|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestCountLargerPairs.checkCountLargerPairs()\n    0", "all_code": "open System\n\n// countLargerPairs calculates the number of elements in the input array that can be paired with a larger element.\n// The array is sorted, and then for each element, we try to find the next larger element.\nlet countLargerPairs (a: int array) =\n    let original = Array.sort a\n    let mutable count = 0\n    let mutable j = 1 // start from the next element to find a larger one\n\n    for i in 0 .. original.Length - 1 do\n        while j < original.Length && original.[j] <= original.[i] do\n            j <- j + 1\n        if j < original.Length then\n            count <- count + 1\n            j <- j + 1\n\n    count\nopen System\nopen System.Diagnostics\n\nmodule TestCountLargerPairs =\n    let checkCountLargerPairs() =\n        Debug.Assert(countLargerPairs [|10; 1; 1; 1; 5; 5; 3|] = 4)\n        Debug.Assert(countLargerPairs [|1; 1; 1; 1; 1|] = 0)\n\n[<EntryPoint>]\nlet main argv =\n    TestCountLargerPairs.checkCountLargerPairs()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// find function with path compression\n// Finds the root parent of element x in the parent array\nlet rec find (parent: int[]) (x: int) =\n    if parent.[x] <> x then\n        parent.[x] <- find parent parent.[x]\n    parent.[x]\n\n// smallestEquivalentString function\n// Takes three strings: s1, s2 (defining equivalence relationships), and baseStr\n// Returns the lexicographically smallest equivalent string for baseStr\nlet smallestEquivalentString (s1: string) (s2: string) (baseStr: string) =\n    let parent = [|0..25|] // Initialize parent array for 26 letters (a-z)\n    \n    // Process each character pair in s1 and s2 to build equivalence classes\n    for i in 0..s1.Length-1 do\n        let a = int s1.[i] - int 'a'\n        let b = int s2.[i] - int 'a'\n        let rootA = find parent a\n        let rootB = find parent b\n        if rootA <> rootB then\n            if rootA < rootB then\n                parent.[rootB] <- rootA\n            else\n                parent.[rootA] <- rootB\n    \n    // Build the result string by finding the smallest equivalent for each character\n    let result = \n        baseStr.ToCharArray()\n        |> Array.map (fun c ->\n            let idx = int c - int 'a'\n            let root = find parent idx\n            char (root + int 'a'))\n        |> String\n    \n    result", "test_cases": "", "test_case_results": "Input: s1=\"hello\", s2=\"world\", baseStr=\"hold\"\nResult: \"hdld\"\n\nInput: s1=\"leetcode\", s2=\"programs\", baseStr=\"sourcecode\"\nResult: \"aauaaaaada\"\n\nInput: s1=\"abc\", s2=\"cba\", baseStr=\"efg\"\nResult: \"efg\"\n\nInput: s1=\"a\", s2=\"b\", baseStr=\"b\"\nResult: \"a\"\n\nInput: s1=\"ab\", s2=\"ba\", baseStr=\"bb\"\nResult: \"aa\"", "task_id": 11516, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestSmallestEquivalentString =\n    let runTests() =\n        Debug.Assert(smallestEquivalentString \"hello\" \"world\" \"hold\" = \"hdld\")\n        Debug.Assert(smallestEquivalentString \"leetcode\" \"programs\" \"sourcecode\" = \"aauaaaaada\")\n        Debug.Assert(smallestEquivalentString \"abc\" \"cba\" \"efg\" = \"efg\")\n        Debug.Assert(smallestEquivalentString \"a\" \"b\" \"b\" = \"a\")\n        Debug.Assert(smallestEquivalentString \"ab\" \"ba\" \"bb\" = \"aa\")\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestSmallestEquivalentString.runTests()\n    0", "all_code": "open System\n\n// find function with path compression\n// Finds the root parent of element x in the parent array\nlet rec find (parent: int[]) (x: int) =\n    if parent.[x] <> x then\n        parent.[x] <- find parent parent.[x]\n    parent.[x]\n\n// smallestEquivalentString function\n// Takes three strings: s1, s2 (defining equivalence relationships), and baseStr\n// Returns the lexicographically smallest equivalent string for baseStr\nlet smallestEquivalentString (s1: string) (s2: string) (baseStr: string) =\n    let parent = [|0..25|] // Initialize parent array for 26 letters (a-z)\n    \n    // Process each character pair in s1 and s2 to build equivalence classes\n    for i in 0..s1.Length-1 do\n        let a = int s1.[i] - int 'a'\n        let b = int s2.[i] - int 'a'\n        let rootA = find parent a\n        let rootB = find parent b\n        if rootA <> rootB then\n            if rootA < rootB then\n                parent.[rootB] <- rootA\n            else\n                parent.[rootA] <- rootB\n    \n    // Build the result string by finding the smallest equivalent for each character\n    let result = \n        baseStr.ToCharArray()\n        |> Array.map (fun c ->\n            let idx = int c - int 'a'\n            let root = find parent idx\n            char (root + int 'a'))\n        |> String\n    \n    result\nopen System\nopen System.Diagnostics\n\nmodule TestSmallestEquivalentString =\n    let runTests() =\n        Debug.Assert(smallestEquivalentString \"hello\" \"world\" \"hold\" = \"hdld\")\n        Debug.Assert(smallestEquivalentString \"leetcode\" \"programs\" \"sourcecode\" = \"aauaaaaada\")\n        Debug.Assert(smallestEquivalentString \"abc\" \"cba\" \"efg\" = \"efg\")\n        Debug.Assert(smallestEquivalentString \"a\" \"b\" \"b\" = \"a\")\n        Debug.Assert(smallestEquivalentString \"ab\" \"ba\" \"bb\" = \"aa\")\n        printfn \"All tests passed!\"\n\n[<EntryPoint>]\nlet main argv =\n    TestSmallestEquivalentString.runTests()\n    0", "exec_outcome": "PASSED"}
{"code": "open System\n\n// computeProbability calculates the probability that exactly half of the selected members\n// in a subset will be successful, given their individual probabilities.\n// It uses dynamic programming to compute the probabilities efficiently.\nlet computeProbability (members: float list) (k: int) =\n    let t = k / 2\n    let dp = Array.create (k + 1) 0.0\n    dp.[0] <- 1.0\n    for p in members do\n        for j in k .. -1 .. 1 do\n            dp.[j] <- dp.[j] * (1.0 - p) + dp.[j - 1] * p\n        dp.[0] <- dp.[0] * (1.0 - p)\n    dp.[t]\n\n// combinations generates all possible combinations of size k from the input list.\nlet rec combinations k lst =\n    let rec comb acc k lst =\n        match k, lst with\n        | 0, _ -> [acc]\n        | _, [] -> []\n        | n, h::t -> (comb (h::acc) (n-1) t) @ (comb acc n t)\n    comb [] k lst\n\n// findBestProbability finds the maximum probability among all possible subsets of size k.\nlet findBestProbability (probabilities: float list) (k: int) =\n    probabilities\n    |> combinations k\n    |> List.map (fun subset -> computeProbability subset k)\n    |> List.max", "test_cases": "", "test_case_results": "Case #1:\nInput probabilities: [0.5; 0.5]\nSubset size: 2\nBest probability: 0.500000000\n\nCase #2:\nInput probabilities: [0.0; 0.0; 0.0]\nSubset size: 2\nBest probability: 0.000000000\n\nCase #3:\nInput probabilities: [0.1; 0.2; 0.3; 0.4]\nSubset size: 2\nBest probability: 0.460000000", "task_id": 21552, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestProbability =\n    let runTests() =\n        // Test case 1: Simple case with 2 members and subset size 2\n        Debug.Assert(findBestProbability [0.5; 0.5] 2 = 0.5)\n        \n        // Test case 2: All members have 0 probability\n        Debug.Assert(findBestProbability [0.0; 0.0; 0.0] 2 = 0.0)\n        \n        // Test case 3: Members with varying probabilities\n        Debug.Assert(findBestProbability [0.1; 0.2; 0.3; 0.4] 2 = 0.46)\n\n[<EntryPoint>]\nlet main argv =\n    TestProbability.runTests()\n    0", "all_code": "open System\n\n// computeProbability calculates the probability that exactly half of the selected members\n// in a subset will be successful, given their individual probabilities.\n// It uses dynamic programming to compute the probabilities efficiently.\nlet computeProbability (members: float list) (k: int) =\n    let t = k / 2\n    let dp = Array.create (k + 1) 0.0\n    dp.[0] <- 1.0\n    for p in members do\n        for j in k .. -1 .. 1 do\n            dp.[j] <- dp.[j] * (1.0 - p) + dp.[j - 1] * p\n        dp.[0] <- dp.[0] * (1.0 - p)\n    dp.[t]\n\n// combinations generates all possible combinations of size k from the input list.\nlet rec combinations k lst =\n    let rec comb acc k lst =\n        match k, lst with\n        | 0, _ -> [acc]\n        | _, [] -> []\n        | n, h::t -> (comb (h::acc) (n-1) t) @ (comb acc n t)\n    comb [] k lst\n\n// findBestProbability finds the maximum probability among all possible subsets of size k.\nlet findBestProbability (probabilities: float list) (k: int) =\n    probabilities\n    |> combinations k\n    |> List.map (fun subset -> computeProbability subset k)\n    |> List.max\nopen System\nopen System.Diagnostics\n\nmodule TestProbability =\n    let runTests() =\n        // Test case 1: Simple case with 2 members and subset size 2\n        Debug.Assert(findBestProbability [0.5; 0.5] 2 = 0.5)\n        \n        // Test case 2: All members have 0 probability\n        Debug.Assert(findBestProbability [0.0; 0.0; 0.0] 2 = 0.0)\n        \n        // Test case 3: Members with varying probabilities\n        Debug.Assert(findBestProbability [0.1; 0.2; 0.3; 0.4] 2 = 0.46)\n\n[<EntryPoint>]\nlet main argv =\n    TestProbability.runTests()\n    0", "exec_outcome": "RUNTIME_ERROR"}
{"code": "open System\n\n// reverseString function returns the reverse of the string s. If the input string is a palindrome,\n// the function returns \"Palindrome\". The function is case and space insensitive.\nlet reverseString (s: string) =\n    // Remove spaces and convert to lowercase\n    let cleanedS = s.Replace(\" \", \"\").ToLower()\n    \n    // Check if cleaned string is a palindrome\n    if cleanedS = new string(cleanedS.ToCharArray() |> Array.rev) then\n        \"Palindrome\"\n    else\n    // Return the reverse of the original string if not a palindrome\n        new string(s.ToCharArray() |> Array.rev)", "test_cases": "", "test_case_results": "Input: \"hello\"\nResult: \"olleh\"\n\nInput: \"madam\"\nResult: \"Palindrome\"\n\nInput: \"A man a plan a canal Panama\"\nResult: \"Palindrome\"\n\nInput: \"racecar\"\nResult: \"Palindrome\"\n\nInput: \"F# is fun\"\nResult: \"nuf si #F\"", "task_id": 29803, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestReverseString =\n    let checkReverseString() =\n        Debug.Assert(reverseString \"hello\" = \"olleh\")\n        Debug.Assert(reverseString \"madam\" = \"Palindrome\")\n        Debug.Assert(reverseString \"A man a plan a canal Panama\" = \"Palindrome\")\n        Debug.Assert(reverseString \"racecar\" = \"Palindrome\")\n        Debug.Assert(reverseString \"F# is fun\" = \"nuf si #F\")\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseString.checkReverseString()\n    0", "all_code": "open System\n\n// reverseString function returns the reverse of the string s. If the input string is a palindrome,\n// the function returns \"Palindrome\". The function is case and space insensitive.\nlet reverseString (s: string) =\n    // Remove spaces and convert to lowercase\n    let cleanedS = s.Replace(\" \", \"\").ToLower()\n    \n    // Check if cleaned string is a palindrome\n    if cleanedS = new string(cleanedS.ToCharArray() |> Array.rev) then\n        \"Palindrome\"\n    else\n    // Return the reverse of the original string if not a palindrome\n        new string(s.ToCharArray() |> Array.rev)\nopen System\nopen System.Diagnostics\n\nmodule TestReverseString =\n    let checkReverseString() =\n        Debug.Assert(reverseString \"hello\" = \"olleh\")\n        Debug.Assert(reverseString \"madam\" = \"Palindrome\")\n        Debug.Assert(reverseString \"A man a plan a canal Panama\" = \"Palindrome\")\n        Debug.Assert(reverseString \"racecar\" = \"Palindrome\")\n        Debug.Assert(reverseString \"F# is fun\" = \"nuf si #F\")\n\n[<EntryPoint>]\nlet main argv =\n    TestReverseString.checkReverseString()\n    0", "exec_outcome": "PASSED"}
{"code": "// This script calculates the number of unique compounds formed by concatenating\n// each string in a list with every other string (excluding itself).\n\n// The core function `countUniqueCompounds` takes a list of strings and returns the count of unique concatenated compounds.\nlet countUniqueCompounds (strings: string list) =\n    let n = strings.Length\n    let uniqueCompounds = System.Collections.Generic.HashSet<string>()\n    \n    for i in 0..n-1 do\n        for j in 0..n-1 do\n            if i <> j then\n                let compound = strings.[i] + strings.[j]\n                uniqueCompounds.Add(compound) |> ignore\n    \n    uniqueCompounds.Count", "test_cases": "", "test_case_results": "Input: [\"pon\"; \"juice\"]\nNumber of unique compounds: 2\n\nInput: [\"pon\"; \"ponpon\"]\nNumber of unique compounds: 1\n\nInput: [\"a\"; \"b\"; \"c\"]\nNumber of unique compounds: 6\n\nInput: [\"x\"; \"x\"]\nNumber of unique compounds: 1", "task_id": 11600, "assertions": "open System\nopen System.Diagnostics\n\nmodule TestUniqueCompounds =\n    let checkUniqueCompounds() =\n        Debug.Assert(countUniqueCompounds [\"pon\"; \"juice\"] = 2)\n        Debug.Assert(countUniqueCompounds [\"pon\"; \"ponpon\"] = 1)\n        Debug.Assert(countUniqueCompounds [\"a\"; \"b\"; \"c\"] = 6)\n        Debug.Assert(countUniqueCompounds [\"x\"; \"x\"] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestUniqueCompounds.checkUniqueCompounds()\n    0", "all_code": "// This script calculates the number of unique compounds formed by concatenating\n// each string in a list with every other string (excluding itself).\n\n// The core function `countUniqueCompounds` takes a list of strings and returns the count of unique concatenated compounds.\nlet countUniqueCompounds (strings: string list) =\n    let n = strings.Length\n    let uniqueCompounds = System.Collections.Generic.HashSet<string>()\n    \n    for i in 0..n-1 do\n        for j in 0..n-1 do\n            if i <> j then\n                let compound = strings.[i] + strings.[j]\n                uniqueCompounds.Add(compound) |> ignore\n    \n    uniqueCompounds.Count\nopen System\nopen System.Diagnostics\n\nmodule TestUniqueCompounds =\n    let checkUniqueCompounds() =\n        Debug.Assert(countUniqueCompounds [\"pon\"; \"juice\"] = 2)\n        Debug.Assert(countUniqueCompounds [\"pon\"; \"ponpon\"] = 1)\n        Debug.Assert(countUniqueCompounds [\"a\"; \"b\"; \"c\"] = 6)\n        Debug.Assert(countUniqueCompounds [\"x\"; \"x\"] = 1)\n\n[<EntryPoint>]\nlet main argv =\n    TestUniqueCompounds.checkUniqueCompounds()\n    0", "exec_outcome": "PASSED"}
