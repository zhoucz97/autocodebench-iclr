{"messages": [{"role": "system", "content": ""}, {"role": "user", "content": "# Code Benchmark Construction Task\nIn order to build the code benchmark, I need you to help me create a Python function, as well as two test functions. Later, I will construct programming problems based on them.\n\n## Task Overview\nGiven a code file or code snippet in any programming language, your task is to **refine and evolve its core logic** and remove non-core logic (if necessary) to create a **self-contained**, **verifiable**, **correct** Python function. You also need to create two testing functions for testing: `demo_testing()` and `full_testing()`. Below are the detailed requirements:\n\n1. **Separate Code Blocks**: \n   - Provide **three distinct code blocks**:\n     - One block for the rewritten Python functions that contain the core logic.\n     - Two blocks for the test functions (`demo_testing()` and `full_testing()`).\n   - The three code blocks are wrapped with ```python and ```.\n\n2. **Test Code in `demo_testing()`**: \n   - This function should contain **no more than 2 test cases**. It will be used to **demonstrate** the input-output format.\n   - For each test case, **hard-code the input values** and print both the input and the corresponding output when `demo_testing()` is executed.\n   - Avoid edge cases in this function, and focus on basic test cases for demonstration purposes.\n\n3. **Test Code in `full_testing()`**: \n   - This function should include a comprehensive set of **at least 7 test cases**.\n   - These test cases should be designed to thoroughly test the functionality of the converted functions, including:\n     - **Basic cases** (e.g., test cases used in `demo_testing()`).\n     - **Boundary cases** (e.g., minimum/maximum values, empty inputs).\n     - **Edge cases** that test the robustness of the code (e.g., abnormal value, boundary condition checks).\n   - For each test case, **hard-code the input values** and print both the input and the corresponding output when `full_testing()` is executed.\n   - The goal of the test function is to provide comprehensive inputs and call the function being tested to obtain the output. Input handling (e.g., validation, edge cases) should be done by the function itself, not the test.\n\n4. **Use Standard and Third-Party Python Libraries**: \n   - You are allowed to use standard Python libraries (e.g., `math`, `print`) and third-party libraries (if required) for implementing the core logic.\n   - Ensure that all dependencies are clearly explained in the comments if used.\n\n5. **Executable Code**:\n   - Provide **self-contained and executable Python code** with hard-coded test inputs.\n   - Remove any non-core logic such as plots, file I/O, and unused functions. \n   - If the original code is not directly executable (e.g., due to dependency on specific business logic or external systems), adapt the code to a self-contained, testable form by simulating the required context or simplifying the logic while preserving the core functionality.\n   - For overly simplistic code (like a function that simply adds two numbers), please evolve its logic to make it more challenging. For overly difficult and complex code (like multiple functions and classes containing multiple core logics that make it hard to test), please simplify its logic to make it moderately challenging.\n\n6. **Code Style and Naming**:\n   - Follow **Pythonic** naming conventions and ensure that function names are **descriptive** and **clear** in conveying their purpose.\n   - Provide **clear and concise comments** explaining the core logic and the purpose of each function, especially the key steps.\n\n\n## Output Requirements  \n\n### 1. Converted Python Functions\n- **Dependencies**: Use standard Python libraries (e.g., math) and third-party libraries when necessary.\n- **Adaptation for Executability**: If the original code depends on external data sources or specific business workflows, modify it to be self-contained by hardcoding inputs, simulating dependencies, or simplifying the logic, while preserving the core algorithm.\n- **Remove Non-Core Logic**: Eliminate all non-essential parts such as plots, file I/O, and unused functions.\n- **Code Style**: Follow good Python coding practices, including proper indentation, consistent naming conventions, and adherence to PEP 8 guidelines. Add comments to explain the functionality of the code and clarify key steps.\n\n### 2. Executable Test Functions\n- **Function Names**: Use `demo_testing()` and `full_testing()` for the test functions.\n- **Inputs**: Hardcode the test inputs within the test functions. Do not pass parameters into the `demo_testing()` or `full_testing()` functions.\n- **Output**: Directly print the test inputs and their corresponding outputs to the console. Ensure that outputs are in JSON-serializable types (e.g., strings, integers, floats, lists). Do not include the word \"Output\" in the printed results.\n- **Dependencies**: Use standard Python libraries (e.g., math, print) and third-party libraries, if needed, for the core logic.\n- **Testing Adaptation**: If the original code's logic is part of a larger system, adapt the `demo_testing()` and `full_testing()` functions to create a self-contained testing environment. This may include initializing necessary objects, setting up test data, or mocking external interactions.\n- **Code Style**: Follow good Python code style in the test functions, with proper indentation and clarity. Include comments to explain the test setup and key steps in the testing process.\n- **Test Function Format**: The structure and format of `demo_testing()` and `full_testing()` should be identical, with the only difference being the number of test cases.\n\n### 3. Code Structure  \n# Converted Python functions\n```python  \nimport math  \nimport third_party_library  # Example: If third - party libraries are needed  \n\n# Function to calculate the average of a given list of data  \n# If the list is empty, it returns 0.0 to avoid division by zero error  \ndef calculate_average(data):  \n    if len(data) == 0:  \n        return 0.0\n    total = sum(data)  \n    return total / len(data)  \n```\n\n# demo_testing function \n```python  \ndef demo_testing():  \n    # Hard-coded test inputs. We create a list of no more than 2 test cases, where each test case  \n    # is itself a list of numbers to test the calculate_average function.  \n    test_cases = [   \n        [1, 2, 3]\n    ]  \n\n    for input_data in test_cases:  \n        # Print the input data for the current test case  \n        print(f\"Input: {input_data}\")  \n\n        # Call the calculate_average function with the current input data  \n        result = calculate_average(input_data)  \n\n        # Print the result (average) of the calculation for the current test case  \n        print(f\"Mean: {result}\")  \n\nif __name__ == \"__main__\":  \n    demo_testing()  \n```\n\n# full_testing function \n```python  \ndef full_testing():\n    # Hard-coded test inputs. We create a list of at least 7 test cases, where each test case  \n    # is itself a list of numbers to test the calculate_average function.  \n    test_cases = [  \n        [1, 2, 3],\n        [12, 45, 6, 89, 34],\n        [],  # None\n        [5],  # Single - element test case  \n        [-2, 4, -6, 8],  # Test with negative numbers  \n        [0],\n        [999, 999999999, 999999999], # extremum\n        [0.5, 9.8, -9.2, 25365423435], # decimals\n    ]  \n\n    for input_data in test_cases:  \n        # Print the input data for the current test case  \n        print(f\"Input: {input_data}\")  \n\n        # Call the calculate_average function with the current input data  \n        result = calculate_average(input_data)  \n\n        # Print the result (average) of the calculation for the current test case  \n        print(f\"Mean: {result}\")  \n\nif __name__ == \"__main__\":  \n    full_testing()  \n```  \n\n#### 4. Key Rules  \n- **No external inputs**: All test parameters should be hard-coded in the demo_testing or full_testing function.  \n- **No complex types**: Use lists for arrays and primitive types for scalars.  \n- **No boilerplate**: Remove comments, unused code, and non-essential logic from the original code (but add appropriate comments in the generated Python code as per the requirements).\n- **No randomness**: The code must not rely on any random values or functions. Ensure that all inputs and outputs are predictable and consistent every time the code is executed. Also, ensure that numerical calculation results do not vary across machines and environments.\n- **Direct execution**: The code must run with `python main.py`, possibly requiring `pip install` for any third-party dependencies specified in the code.\n\n\n### Example Conversion  \n**Original Code** (in any programming language, here a hypothetical example using Pandas):  \n```python\nimport pandas as pd  \ndef analyze_data(df):  \n    return df.mean(), df.std()  \ndata = pd.DataFrame([1, 2, 3, 4])  \nprint(analyze_data(data))  # Output: (2.5, 1.118...)  \n```  \n\n**Converted Python Code**:  \n```python  \nimport pandas as pd\nimport numpy as np\n\n# Function to perform multiple statistical analyses on a DataFrame\ndef analyze_data(df):\n    # Check if the DataFrame is empty\n    if df.empty:\n        return \"Error: Empty DataFrame\"\n\n    # Check if all values are numeric (useful for validation)\n    if not pd.api.types.is_numeric_dtype(df.iloc[:, 0]):\n        return \"Error: Non-numeric data\"\n\n    # Calculate statistics: mean, standard deviation\n    mean = df.mean().values[0]\n    std = df.std().values[0]\n\n    # Return the results as a dictionary\n    return {\n        \"mean\": mean,\n        \"std_dev\": std,\n    }\n```  \n\n**Demo Testing Function**:  \n```python  \ndef demo_testing():\n    # Hard-coded test cases for demonstration\n    test_cases = [\n        pd.DataFrame([1, 2, 3, 4]),  # Test case 1: A simple list of numbers\n    ]\n\n    for input_data in test_cases:\n        # Print the input data for the current test case\n        print(f\"Input: {input_data}\")\n\n        # Call the analyze_data function with the current input data\n        result = analyze_data(input_data)\n\n        # Print the result of the analysis\n        print(f\"Analysis Result: {result}\")\n\nif __name__ == \"__main__\":\n    demo_testing()\n```\n\n**Full Testing Function**:  \n```python\ndef full_testing():\n    # Hard-coded test cases with a variety of conditions\n    test_cases = [\n        pd.DataFrame([1, 2, 3, 4]),  # Test case 1: Simple sequence of numbers\n        pd.DataFrame([12, 45, 6, 89, 34]),  # Test case 2: Larger set of numbers\n        pd.DataFrame([5]),  # Test case 3: Single value\n        pd.DataFrame([]),  # Test case 4: Empty DataFrame\n        pd.DataFrame([1, -1, 1, -1]),  # Test case 5: Mixed positive and negative numbers\n        pd.DataFrame([0, 0, 0, 0]),  # Test case 6: All zeros\n        pd.DataFrame([999999, 1000000, 1000001]),  # Test case 7: Large numbers\n        pd.DataFrame([100, 200, 300, 400]),  # Test case 8: Even larger set of numbers\n        pd.DataFrame(['a', 'b', 'c']),  # Test case 9: Non-numeric data\n    ]\n\n    for input_data in test_cases:\n        # Print the input data for the current test case\n        print(f\"Input: {input_data}\")\n\n        # Call the analyze_data function with the current input data\n        result = analyze_data(input_data)\n\n        # Print the result of the analysis\n        print(f\"Analysis Result: {result}\")\n\nif __name__ == \"__main__\":\n    full_testing()\n\n```  \n\n\n\nHere is the code file you need to process:\n[Code Start]\ndef add_two_numbers(a, b):\n    return a + b\n[Code End]\n"}], "index": 0, "lang": "python", "seed": "def add_two_numbers(a, b):\n    return a + b", "output": "Based on the simple addition function provided, I'll evolve it into a more complex mathematical function while maintaining testability. Here's the solution:\n\n### Converted Python Functions\n```python\nimport math\n\ndef calculate_vector_magnitude(vector):\n    \"\"\"\n    Calculates the magnitude (length) of a vector in n-dimensional space.\n    \n    Args:\n        vector: A list of numerical values representing the vector components.\n    \n    Returns:\n        float: The magnitude of the vector.\n    \n    Raises:\n        ValueError: If input is not a list or contains non-numeric values.\n    \"\"\"\n    if not isinstance(vector, list):\n        raise ValueError(\"Input must be a list\")\n    \n    if not all(isinstance(x, (int, float)) for x in vector):\n        raise ValueError(\"All vector components must be numeric\")\n    \n    if len(vector) == 0:\n        return 0.0\n    \n    squared_sum = sum(x**2 for x in vector)\n    return math.sqrt(squared_sum)\n```\n\n### demo_testing function\n```python\ndef demo_testing():\n    \"\"\"\n    Demonstrates basic functionality with 2 simple test cases.\n    Prints inputs and corresponding outputs for verification.\n    \"\"\"\n    test_vectors = [\n        [3, 4],        # 2D vector (3,4) should have magnitude 5\n        [1, 2, 2]      # 3D vector (1,2,2) should have magnitude 3\n    ]\n    \n    for vector in test_vectors:\n        print(f\"Vector: {vector}\")\n        magnitude = calculate_vector_magnitude(vector)\n        print(f\"Magnitude: {magnitude}\")\n\nif __name__ == \"__main__\":\n    demo_testing()\n```\n\n### full_testing function\n```python\ndef full_testing():\n    \"\"\"\n    Comprehensive testing with various cases including:\n    - Basic calculations\n    - Edge cases (empty vector, single element)\n    - High-dimensional vectors\n    - Negative values\n    - Large numbers\n    - Decimal values\n    - Error cases\n    \"\"\"\n    test_vectors = [\n        [3, 4],            # Basic 2D case (should be 5)\n        [1, 2, 2],         # Basic 3D case (should be 3)\n        [],                 # Empty vector (should be 0)\n        [5],                # Single element (should be 5)\n        [-3, -4],           # Negative values (should be 5)\n        [0, 0, 0],          # Zero vector (should be 0)\n        [1, 1, 1, 1, 1],    # 5D vector (should be √5 ≈ 2.236)\n        [10**6, 10**6],     # Large numbers (should be √2 * 10^6)\n        [0.3, 0.4],         # Decimals (should be 0.5)\n        \"not a vector\",     # Invalid type (should raise error)\n        [1, \"a\", 3]         # Non-numeric element (should raise error)\n    ]\n    \n    for vector in test_vectors:\n        print(f\"Vector: {vector}\")\n        try:\n            magnitude = calculate_vector_magnitude(vector)\n            print(f\"Magnitude: {magnitude}\")\n        except ValueError as e:\n            print(f\"Error: {str(e)}\")\n\nif __name__ == \"__main__\":\n    full_testing()\n```\n\nThis solution evolves the simple addition function into a vector magnitude calculator that:\n1. Works with vectors of any dimension\n2. Includes proper input validation\n3. Handles edge cases like empty vectors\n4. Provides comprehensive testing through both demo and full test functions\n\nThe test cases cover:\n- Basic vector calculations\n- Edge cases (empty vector, single element)\n- Different dimensions (2D, 3D, 5D)\n- Negative values\n- Zero vectors\n- Large numbers\n- Decimal values\n- Invalid input types\n- Non-numeric elements\n\nAll test inputs are hard-coded and the functions print both inputs and outputs as required. The code is self-contained and executable with standard Python libraries."}
