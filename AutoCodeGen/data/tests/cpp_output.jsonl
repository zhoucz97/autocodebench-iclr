{"index": 0, "seed": "#include <iostream>\nusing namespace std;\n\nint add_two_numbers(int a, int b) {\n    return a + b;\n}", "canonical_solution": "```cpp\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nmap<string, double> compute_operations(int a, int b) {\n    map<string, double> results;\n    results[\"addition\"] = a + b;\n    results[\"subtraction\"] = a - b;\n    results[\"multiplication\"] = a * b;\n    \n    if (b != 0) {\n        results[\"division\"] = static_cast<double>(a) / b;\n        results[\"modulo\"] = a % b;\n    } else {\n        results[\"division\"] = NAN;\n        results[\"modulo\"] = NAN;\n    }\n    \n    return results;\n}\n```", "language": "cpp", "demo_test_input": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nvoid demo_testing() {\n    vector<pair<int, int>> test_cases = {\n        {10, 5},\n        {5, 0}\n    };\n\n    for (const auto& test : test_cases) {\n        int a = test.first;\n        int b = test.second;\n        cout << \"Input: a = \" << a << \", b = \" << b << endl;\n        map<string, double> result = compute_operations(a, b);\n        \n        cout << \"{\";\n        bool first = true;\n        for (const auto& pair : result) {\n            if (!first) cout << \", \";\n            cout << \"\\\"\" << pair.first << \"\\\": \";\n            if (isnan(pair.second)) cout << \"NaN\";\n            else cout << pair.second;\n            first = false;\n        }\n        cout << \"}\" << endl;\n    }\n}\n\nint main() {\n    demo_testing();\n    return 0;\n}", "demo_test_output": "Input: a = 10, b = 5\n{\"addition\": 15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": 5}\nInput: a = 5, b = 0\n{\"addition\": 5, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 5}\n", "full_test_input": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nvoid full_testing() {\n    vector<pair<int, int>> test_cases = {\n        {10, 5},        // Basic case\n        {5, 0},         // Division by zero\n        {0, 0},         // Double zero\n        {0, 10},        // Zero dividend\n        {-10, 5},       // Negative dividend\n        {-10, -5},      // Both negative\n        {1000000, 500000}, // Large numbers\n        {5, 2},         // Non-zero modulo\n        {1, 2}          // Fractional division\n    };\n\n    for (const auto& test : test_cases) {\n        int a = test.first;\n        int b = test.second;\n        cout << \"Input: a = \" << a << \", b = \" << b << endl;\n        map<string, double> result = compute_operations(a, b);\n        \n        cout << \"{\";\n        bool first = true;\n        for (const auto& pair : result) {\n            if (!first) cout << \", \";\n            cout << \"\\\"\" << pair.first << \"\\\": \";\n            if (isnan(pair.second)) cout << \"NaN\";\n            else cout << pair.second;\n            first = false;\n        }\n        cout << \"}\" << endl << endl;\n    }\n}\n\nint main() {\n    full_testing();\n    return 0;\n}", "full_test_output": "Input: a = 10, b = 5\n{\"addition\": 15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": 5}\n\nInput: a = 5, b = 0\n{\"addition\": 5, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 5}\n\nInput: a = 0, b = 0\n{\"addition\": 0, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 0}\n\nInput: a = 0, b = 10\n{\"addition\": 10, \"division\": 0, \"modulo\": 0, \"multiplication\": 0, \"subtraction\": -10}\n\nInput: a = -10, b = 5\n{\"addition\": -5, \"division\": -2, \"modulo\": 0, \"multiplication\": -50, \"subtraction\": -15}\n\nInput: a = -10, b = -5\n{\"addition\": -15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": -5}\n\nInput: a = 1000000, b = 500000\n{\"addition\": 1.5e+06, \"division\": 2, \"modulo\": 0, \"multiplication\": 1.78379e+09, \"subtraction\": 500000}\n\nInput: a = 5, b = 2\n{\"addition\": 7, \"division\": 2.5, \"modulo\": 1, \"multiplication\": 10, \"subtraction\": 3}\n\nInput: a = 1, b = 2\n{\"addition\": 3, \"division\": 0.5, \"modulo\": 1, \"multiplication\": 2, \"subtraction\": -1}\n\n", "messages": [{"role": "system", "content": ""}, {"role": "user", "content": "I'll provide you with a C++ code, a test function call (including inputs) that uses this C++ function, and the test output obtained after executing that test function call.\n\nPlease combine the provided inputs and outputs into assert statements, and place these `assert` statements inside a new `test` function. You can only use the inputs and outputs provided by me. Please do not create your own or modify the test cases.\n\nHere is an example:\n**Code**:\n```cpp\n#include <cmath>\n#include <cassert>\n\nbool is_prime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint nth_prime(int n) {\n    if (n < 1) {\n        return -1; // Using -1 as error code for invalid input\n    }\n    int count = 1;\n    int i = 2;\n    while (count < n) {\n        ++i;\n        if (is_prime(i)) {\n            ++count;\n        }\n    }\n    return i;\n}\n```\n\n**Test Cases**:\n```cpp\n#include <iostream>\n\nvoid main_test() {\n    // Hard-coded test inputs\n    int test_cases[] = {1, 5, 10, 100, 10001};\n\n    for (int n : test_cases) {\n        // Print the input\n        std::cout << \"Input: \" << n << std::endl;\n\n        // Core logic\n        int result = nth_prime(n);\n\n        // Output\n        std::cout << \"The \" << n << \"th prime number is: \" << result << std::endl;\n    }\n}\n\nint main() {\n    main_test();\n    return 0;\n}\n```\n\n**Test Case Results**:\n```\nInput: 1\nThe 1th prime number is: 2\nInput: 5\nThe 5th prime number is: 11\nInput: 10\nThe 10th prime number is: 29\nInput: 100\nThe 100th prime number is: 541\nInput: 10001\nThe 10001th prime number is: 104743\n```\n\nBased on the above information, the generated `assert` statements should be placed in a new `test` function. Below are the detailed requirements: \n1. The code should include all the library used.\n2. Do not generate code to catch the exception. (i.e. do not use \"try\" \"catch\")\n3. If necessary, declare the namespace before the test function.(such as using namespace std)\nThe test function should be like this:\n```cpp\n#include <cassert>\n#include <string>\nusing namespace std;\n\nvoid test() {\n    string a = \"1234\";\n    assert(nth_prime(1) == 2);\n    assert(nth_prime(5) == 11);\n    assert(nth_prime(10) == 29);\n    assert(nth_prime(100) == 541);\n    assert(nth_prime(10001) == 104743);\n}\n\nint main() {\n    test();\n    return 0;\n}\n```\n\nHere is the data you need to process. Please place the function named `test` that you need to generate two code blocks enclosed by ```cpp and ```. Place demo and full in two separate code blocks, not in the same code block.\n\n[Code Start]\n```cpp\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <vector>\n#include <stdexcept>\nusing namespace std;\n\nmap<string, double> compute_operations(int a, int b) {\n    map<string, double> results;\n    results[\"addition\"] = a + b;\n    results[\"subtraction\"] = a - b;\n    results[\"multiplication\"] = a * b;\n    \n    if (b != 0) {\n        results[\"division\"] = static_cast<double>(a) / b;\n        results[\"modulo\"] = a % b;\n    } else {\n        results[\"division\"] = NAN;\n        results[\"modulo\"] = NAN;\n    }\n    \n    return results;\n}\n```\n[Code End]\n\n[Test Function Call 1 Start]\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nvoid demo_testing() {\n    vector<pair<int, int>> test_cases = {\n        {10, 5},\n        {5, 0}\n    };\n\n    for (const auto& test : test_cases) {\n        int a = test.first;\n        int b = test.second;\n        cout << \"Input: a = \" << a << \", b = \" << b << endl;\n        map<string, double> result = compute_operations(a, b);\n        \n        cout << \"{\";\n        bool first = true;\n        for (const auto& pair : result) {\n            if (!first) cout << \", \";\n            cout << \"\\\"\" << pair.first << \"\\\": \";\n            if (isnan(pair.second)) cout << \"NaN\";\n            else cout << pair.second;\n            first = false;\n        }\n        cout << \"}\" << endl;\n    }\n}\n\nint main() {\n    demo_testing();\n    return 0;\n}\n[Test Function Call 1 End]\n\n[Test Case Results 1 Start]\nInput: a = 10, b = 5\n{\"addition\": 15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": 5}\nInput: a = 5, b = 0\n{\"addition\": 5, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 5}\n\n[Test Case Results 1 End]\n\n[Test Function Call 2 Start]\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nvoid full_testing() {\n    vector<pair<int, int>> test_cases = {\n        {10, 5},        // Basic case\n        {5, 0},         // Division by zero\n        {0, 0},         // Double zero\n        {0, 10},        // Zero dividend\n        {-10, 5},       // Negative dividend\n        {-10, -5},      // Both negative\n        {1000000, 500000}, // Large numbers\n        {5, 2},         // Non-zero modulo\n        {1, 2}          // Fractional division\n    };\n\n    for (const auto& test : test_cases) {\n        int a = test.first;\n        int b = test.second;\n        cout << \"Input: a = \" << a << \", b = \" << b << endl;\n        map<string, double> result = compute_operations(a, b);\n        \n        cout << \"{\";\n        bool first = true;\n        for (const auto& pair : result) {\n            if (!first) cout << \", \";\n            cout << \"\\\"\" << pair.first << \"\\\": \";\n            if (isnan(pair.second)) cout << \"NaN\";\n            else cout << pair.second;\n            first = false;\n        }\n        cout << \"}\" << endl << endl;\n    }\n}\n\nint main() {\n    full_testing();\n    return 0;\n}\n[Test Function Call 2 End]\n\n[Test Case Results 2 Start]\nInput: a = 10, b = 5\n{\"addition\": 15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": 5}\n\nInput: a = 5, b = 0\n{\"addition\": 5, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 5}\n\nInput: a = 0, b = 0\n{\"addition\": 0, \"division\": NaN, \"modulo\": NaN, \"multiplication\": 0, \"subtraction\": 0}\n\nInput: a = 0, b = 10\n{\"addition\": 10, \"division\": 0, \"modulo\": 0, \"multiplication\": 0, \"subtraction\": -10}\n\nInput: a = -10, b = 5\n{\"addition\": -5, \"division\": -2, \"modulo\": 0, \"multiplication\": -50, \"subtraction\": -15}\n\nInput: a = -10, b = -5\n{\"addition\": -15, \"division\": 2, \"modulo\": 0, \"multiplication\": 50, \"subtraction\": -5}\n\nInput: a = 1000000, b = 500000\n{\"addition\": 1.5e+06, \"division\": 2, \"modulo\": 0, \"multiplication\": 1.78379e+09, \"subtraction\": 500000}\n\nInput: a = 5, b = 2\n{\"addition\": 7, \"division\": 2.5, \"modulo\": 1, \"multiplication\": 10, \"subtraction\": 3}\n\nInput: a = 1, b = 2\n{\"addition\": 3, \"division\": 0.5, \"modulo\": 1, \"multiplication\": 2, \"subtraction\": -1}\n\n\n[Test Case Results 2 End]"}], "output": "To solve this problem, we need to create test functions that validate the functionality of the `compute_operations` function using provided test cases and their expected outputs. The `compute_operations` function performs arithmetic operations (addition, subtraction, multiplication, division, and modulo) on two integers and returns the results in a map. The test functions will use assert statements to verify that the results match the expected outputs for each test case.\n\n### Approach\n1. **Problem Analysis**: The `compute_operations` function takes two integers, `a` and `b`, and returns a map containing the results of various arithmetic operations. Special cases, such as division by zero, result in NaN values for division and modulo operations.\n2. **Test Cases**: We are provided with two sets of test cases:\n   - **Demo Test Cases**: Includes basic cases and division by zero.\n   - **Full Test Cases**: Includes additional scenarios like negative numbers, zero values, and large numbers.\n3. **Assert Statements**: For each test case, we will:\n   - Call `compute_operations` with the given inputs.\n   - Use assert statements to verify each operation's result against the expected value.\n   - Handle NaN values using `std::isnan` for division and modulo operations when `b` is zero.\n4. **Test Functions**: Separate test functions (`demo_test` and `full_test`) are created for each set of test cases. Each function includes all relevant test cases with corresponding assert statements.\n\n### Solution Code\n\n#### Demo Test Function\n```cpp\n#include <cassert>\n#include <cmath>\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, double> compute_operations(int a, int b);\n\nvoid demo_test() {\n    map<string, double> res = compute_operations(10, 5);\n    assert(res[\"addition\"] == 15);\n    assert(res[\"subtraction\"] == 5);\n    assert(res[\"multiplication\"] == 50);\n    assert(res[\"division\"] == 2.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(5, 0);\n    assert(res[\"addition\"] == 5);\n    assert(res[\"subtraction\"] == 5);\n    assert(res[\"multiplication\"] == 0);\n    assert(isnan(res[\"division\"]));\n    assert(isnan(res[\"modulo\"]));\n}\n\nint main() {\n    demo_test();\n    return 0;\n}\n```\n\n#### Full Test Function\n```cpp\n#include <cassert>\n#include <cmath>\n#include <map>\n#include <string>\nusing namespace std;\n\nmap<string, double> compute_operations(int a, int b);\n\nvoid full_test() {\n    map<string, double> res;\n\n    res = compute_operations(10, 5);\n    assert(res[\"addition\"] == 15);\n    assert(res[\"subtraction\"] == 5);\n    assert(res[\"multiplication\"] == 50);\n    assert(res[\"division\"] == 2.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(5, 0);\n    assert(res[\"addition\"] == 5);\n    assert(res[\"subtraction\"] == 5);\n    assert(res[\"multiplication\"] == 0);\n    assert(isnan(res[\"division\"]));\n    assert(isnan(res[\"modulo\"]));\n\n    res = compute_operations(0, 0);\n    assert(res[\"addition\"] == 0);\n    assert(res[\"subtraction\"] == 0);\n    assert(res[\"multiplication\"] == 0);\n    assert(isnan(res[\"division\"]));\n    assert(isnan(res[\"modulo\"]));\n\n    res = compute_operations(0, 10);\n    assert(res[\"addition\"] == 10);\n    assert(res[\"subtraction\"] == -10);\n    assert(res[\"multiplication\"] == 0);\n    assert(res[\"division\"] == 0.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(-10, 5);\n    assert(res[\"addition\"] == -5);\n    assert(res[\"subtraction\"] == -15);\n    assert(res[\"multiplication\"] == -50);\n    assert(res[\"division\"] == -2.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(-10, -5);\n    assert(res[\"addition\"] == -15);\n    assert(res[\"subtraction\"] == -5);\n    assert(res[\"multiplication\"] == 50);\n    assert(res[\"division\"] == 2.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(1000000, 500000);\n    assert(res[\"addition\"] == 1500000.0);\n    assert(res[\"subtraction\"] == 500000.0);\n    assert(res[\"multiplication\"] == 1783790000.0);\n    assert(res[\"division\"] == 2.0);\n    assert(res[\"modulo\"] == 0);\n\n    res = compute_operations(5, 2);\n    assert(res[\"addition\"] == 7);\n    assert(res[\"subtraction\"] == 3);\n    assert(res[\"multiplication\"] == 10);\n    assert(res[\"division\"] == 2.5);\n    assert(res[\"modulo\"] == 1);\n\n    res = compute_operations(1, 2);\n    assert(res[\"addition\"] == 3);\n    assert(res[\"subtraction\"] == -1);\n    assert(res[\"multiplication\"] == 2);\n    assert(res[\"division\"] == 0.5);\n    assert(res[\"modulo\"] == 1);\n}\n\nint main() {\n    full_test();\n    return 0;\n}\n```\n\n### Explanation\n1. **Headers and Namespace**: The necessary headers (`cassert`, `cmath`, `map`, `string`) are included, and the `std` namespace is used for simplicity.\n2. **Function Declaration**: The `compute_operations` function is declared to be used in the test functions.\n3. **Test Functions**:\n   - **`demo_test`**: Tests basic cases including valid operations and division by zero. Asserts verify each operation's result, with NaN checks for division by zero.\n   - **`full_test`**: Extends testing to include edge cases like zero values, negative numbers, and large numbers. Each test case's results are validated against expected values, including handling NaN for division by zero.\n4. **Main Function**: Each test function is called from `main` to execute the tests, returning 0 upon successful completion. The assert statements ensure the correctness of the `compute_operations` function across all provided test cases."}
