# 代码基准构建任务
*为了构建代码基准，我需要你帮助我创建一个go函数，以及两个测试函数。*

## 任务概述
给定任何编程语言的代码文件或代码片段，你的任务是提炼其核心逻辑，创建一个自包含、可验证、具有教育意义且具有挑战性的go函数。你还需要创建两个测试函数：demoTesting()和fullTesting()。以下是详细要求：
1. 分离代码块：
- 提供三个独立的代码块：
- 一个块用于重写的包含核心逻辑的go函数。
- 两个块用于测试函数（demoTesting()和fullTesting()）。
- 这三个代码块用```go和```包裹。
2. demoTesting()中的测试代码：
- 此函数应包含不超过2个测试用例。它将用于演示输入-输出格式。
- 对于每个测试用例，硬编码输入值，并在执行demoTesting()时打印输入和对应的输出。
- 在此函数中避免边缘用例，专注于用于演示的基本测试用例。
3. fullTesting()中的测试代码：
- 此函数应包含至少7个测试用例的全面集合。
- 这些测试用例应设计为全面测试转换后的函数功能，包括:
    (1) 基本用例（例如demoTesting()中使用的测试用例）。
    (2) 边界用例（例如最小/最大值、空输入）。
    (3) 边缘用例，测试代码的健壮性（例如异常值、边界条件检查）。
    (4) 对于每个测试用例，硬编码输入值，并在执行fullTesting()时打印输入和对应的输出。
- 测试函数的目的是提供全面的输入并调用被测试函数以获取输出。输入处理（例如验证、边缘用例）应由函数本身完成，而非测试。
4. 使用标准和第三方go库：
- 允许使用标准go库和第三方库（如果需要）来实现核心逻辑。
- 如果使用依赖项，请在注释中明确说明。
5. 可执行代码：
- 提供自包含且可执行的go代码，包含硬编码的测试输入。
- 移除任何非核心逻辑，例如绘图、文件I/O和未使用的函数。
- 如果原始代码由于依赖特定业务逻辑或外部系统而无法直接执行，请通过模拟所需上下文或简化逻辑来调整代码，使其成为自包含、可测试的形式，同时保留核心功能。
- 对于过于简单的代码（例如仅将两个数字相加的函数），请扩展其逻辑以使其更具挑战性。
6. 代码风格和命名：
- 遵循go命名约定，确保函数名称描述性且清晰地传达其目的。
- 提供清晰简洁的注释，解释核心逻辑和每个函数的目的，特别是关键步骤。


## 输出要求
1. 转换后的go函数
- 依赖项：使用标准go库（如fmt）和第三方库（如果需要）。
- 可执行性调整：如果原始代码依赖外部数据源或特定业务工作流，请通过硬编码输入、模拟依赖项或简化逻辑来修改代码，使其自包含，同时保留核心算法。
- 移除非核心逻辑：消除所有非必要部分，例如绘图、文件I/O和未使用的函数。
- 代码风格：遵循良好的go编码实践，包括适当的缩进、一致的命名约定。添加注释以解释代码功能和阐明关键步骤。
- 不拘泥于一种模式：不受给定代码片段逻辑的限制。进行演进和扩展，使代码更完整且具有教育意义。
2. 可执行的测试函数
- 函数名称：使用demoTesting()和fullTesting()作为测试函数名称。
- 输入：在测试函数中硬编码测试输入。不要将参数传递给demoTesting()或fullTesting()函数。
- 输出：直接将测试输入及其对应的输出打印到控制台。确保输出为JSON可序列化类型（例如字符串、整数、浮点数、列表）。不要在打印结果中包含“Output”一词。
- 依赖项：使用标准go库（如fmt,测试函数中如果使用到了）和第三方库（如果需要）用于核心逻辑。
- 自适应调整测试函数：如果原始代码的逻辑是更大系统的一部分，请调整demoTesting()和fullTesting()函数以创建自包含的测试环境。这可能包括初始化必要的对象、设置测试数据或模拟外部交互。
- 代码风格：在测试函数中遵循良好的go代码风格，缩进正确且清晰。包括注释以解释测试设置和测试过程中的关键步骤。
- 测试函数格式：demoTesting()和fullTesting()的结构和格式应相同，唯一的区别是测试用例的数量。
3. 关键规则
- 无外部输入：所有测试参数应在demoTesting或fullTesting函数中硬编码。
- 无复杂类型：使用列表作为数组，使用基本类型作为标量。
- 无样板代码：从原始代码中移除注释、未使用的代码和非必要逻辑（但根据要求在生成的go代码中添加适当的注释）。
- 无随机性：代码不得依赖任何随机值或函数。确保所有输入和输出每次执行时都是可预测且一致的。
- 直接执行：代码必须能够直接运行，可能需要安装代码中指定的任何第三方依赖项。
- 不要实现main函数：特别注意不要在代码里生成main函数
- 包名统一为main：不要使用除了main之外的其他包名，未使用到的包名不要导入
- 需要导入fmt：使用到fmt包的话，需要进行导入，即使是测试函数

## 示例转换
【原始代码】（任何编程语言，此处为使用Pandas的假设示例）：
```python
import pandas as pd
def analyze_data(df):
    return df.mean(), df.std()
data = pd.DataFrame([1, 2, 3, 4])
print(analyze_data(data))  # 输出：(2.5, 1.118...)
```
【转换后的go代码】:
```go
// Converted go functions
package main

import (
	"fmt"
	"math"
)

// AnalyzeData 分析数据并返回均值和标准差
func AnalyzeData(df [][]float64) (map[string]float64, string) {
	// 检查DataFrame是否为空
	if len(df) == 0 {
		return nil, "Error: Empty DataFrame"
	}

	// 计算均值和标准差
	var sum float64
	values := make([]float64, len(df))

	for i, row := range df {
		values[i] = row[0]
		sum += row[0]
	}

	mean := sum / float64(len(values))

	var variance float64
	for _, val := range values {
		variance += math.Pow(val-mean, 2)
	}
	variance /= float64(len(values))
	stdDev := math.Sqrt(variance)

	// 返回结果
	return map[string]float64{
		"mean":   mean,
		"stdDev": stdDev,
	}, ""
}
```

```go
// demoTesting 演示测试函数
func demoTesting() {
	// 硬编码的测试用例
	testCases := [][][]float64{
		{{1}, {2}, {3}, {4}}, // 测试用例1: 简单的数字列表
	}

	for _, inputData := range testCases {
		// 打印当前测试用例的输入数据
		fmt.Printf("Input: %v\n", inputData)

		// 调用AnalyzeData函数
		result, err := AnalyzeData(inputData)

		// 打印分析结果
		if err != "" {
			fmt.Printf("Analysis Error: %s\n", err)
		} else {
			fmt.Printf("Analysis Result: %v\n", result)
		}
	}
}
```

```go
// fullTesting
完整测试函数
func fullTesting() {
	// 硬编码的测试用例，包含各种条件
	testCases := [][][]float64{
		{{1}, {2}, {3}, {4}},               // 测试用例1: 简单序列
		{{12}, {45}, {6}, {89}, {34}},      // 测试用例2: 更大的数据集
		{{5}},                              // 测试用例3: 单个值
		{},                                 // 测试用例4: 空数据集
		{{1}, {-1}, {1}, {-1}},             // 测试用例5: 混合符号
		{{0}, {0}, {0}, {0}},               // 测试用例6: 全零
		{{999999}, {1000000}, {1000001}},   // 测试用例7: 大数字
		{{100}, {200}, {300}, {400}},       // 测试用例8: 更大的数据集
	}

	for _, inputData := range testCases {
		// 打印当前测试用例的输入数据
		fmt.Printf("Input: %v\n", inputData)

		// 调用AnalyzeData函数
		result, err := AnalyzeData(inputData)

		// 打印分析结果
		if err != "" {
			fmt.Printf("Analysis Error: %s\n", err)
		} else {
			fmt.Printf("Analysis Result: %v\n", result)
		}
	}
}
```

# 以下是需要处理的代码文件：
[代码开始]
<<<<code>>>>
[代码结束]